<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>/etc/yaws/yaws.conf - Configuration file for the Yaws web server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/yaws">yaws_2.2.0+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       /etc/yaws/yaws.conf - Configuration file for the Yaws web server

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Yaws  is  fast  lightweight  web  server.  It  reads a configuration file called yaws.conf to control its
       operations. The configuration contains two distinct parts: a global part which affects  all  the  virtual
       hosts and a server part where options for each virtual host is supplied.

</pre><h4><b>GLOBAL</b> <b>PART</b></h4><pre>
       <b>logdir</b> <b>=</b> <b>[+]Directory</b>
              All  Yaws  logs will be written to files in this directory. If specified with <b>+</b>, Yaws will attempt
              to create the directory if it does not exist. There are several different  log  files  written  by
              Yaws:

              <b>report.log</b> - this is a text file that contains all error logger printouts from Yaws.

              <b>&lt;Host&gt;.access</b>  -  for  each virtual host served by Yaws, a file &lt;Host&gt;.access will be written that
              contains an  access  log  in  NCSA  combined/XLF/ELF  log  format.  (See  <a href="http://www.w3.org/TR/WD">http://www.w3.org/TR/WD</a>-
              logfile.html for more details on Extended Log File Format.)

              <b>&lt;Host&gt;.auth</b>  -  for  each  virtual  host  served by Yaws, a file &lt;Host&gt;.auth will be written which
              contains all http auth related messages.

              <b>trace_&lt;YYYYMMDD_hhmmss&gt;</b> - Trace files are written in this subdirectory, suffixed by  the  creation
              date.

                   <b>trace.&lt;Pid&gt;.http</b>  -  this file contains the HTTP trace if that is enabled, where &lt;Pid&gt; is the
                   process id handling the TCP connection.

                   <b>trace.&lt;Pid&gt;.traffic</b> - this file contains the traffic trace if that is enabled, where &lt;Pid&gt; is
                   the process id handling the TCP connection.

              Note that &lt;Host&gt;.access and &lt;Host&gt;.auth files will be used only if the directive <b>logger_mod</b> is not
              set or set to yaws_log. The default value for logdir is <u>"."</u>

       <b>ebin_dir</b> <b>=</b> <b>Directory</b>
              This directive adds Directory to the Erlang search path. It is possible to have several  of  these
              commands in the configuration file. The default value is <u>"yaws_dir"/examples/ebin</u>

       <b>src_dir</b> <b>=</b> <b>Directory</b>
              This  directive  defines  a  Directory as a <u>source</u> directory. Yaws will compile all erlang modules
              found in this directory and all its subdirectories. The compilation occurs when the  configuration
              is  loaded or reloaded. The <b>include_dir</b> directives are used to search for includes files. Multiple
              <b>src_dir</b> directives may be used. There is no such directory configured by default.

       <b>id</b> <b>=</b> <b>String</b>
              It is possible to run multiple Yaws servers on the same machine. We use the id of a Yaws server to
              control it using the different control commands such as:

                # /usr/local/bin/yaws --id foobar --stop

              To stop the Yaws server with id "foobar". Each Yaws server will write its  internal  data  into  a
              file  called  $HOME/.yaws/yaws/ID where ID is the identity of the server. Yaws also creates a file
              called $HOME/.yaws/yaws/ID/CTL which contains the port number where the server  is  listening  for
              control commands. The default id is <u>"default"</u>.

       <b>server_signature</b> <b>=</b> <b>String</b>
              This  directive  sets  the  "Server:  "  output  header  to the custom value. The default value is
              <u>"yaws/%VSN%,</u> <u>Yet</u> <u>Another</u> <u>Web</u> <u>Server"</u>.

       <b>include_dir</b> <b>=</b> <b>Directory</b>
              This directive adds Directory to the path of directories where the Erlang  compiler  searches  for
              include files. We need to use this if we want to include .hrl files in our Yaws Erlang code. It is
              possible  to  have  several  of  these  commands  in  the configuration file. The default value is
              <u>"yaws_dir"/examples/include</u>.

       <b>max_num_cached_files</b> <b>=</b> <b>Integer</b>
              Yaws will cache small files such as commonly accessed GIF images in RAM.  This  directive  sets  a
              maximum number on the number of cached files.  The default value is <u>400</u>.

       <b>max_num_cached_bytes</b> <b>=</b> <b>Integer</b>
              This  directive controls the total amount of RAM which can maximally be used for cached RAM files.
              The default value is <u>1000000</u>, 1 megabyte.

       <b>max_size_cached_file</b> <b>=</b> <b>Integer</b>
              This directive sets a maximum size on the files that are RAM cached by Yaws.  The default value is
              <u>8000</u>, 8 kBytes.

       <b>cache_refresh_secs</b> <b>=</b> <b>Integer</b>
              The RAM cache is used to serve pages that sit in the  cache.  An  entry  sits  in  cache  at  most
              cache_refresh_secs  number  of  seconds.  The  default  is <u>30</u>. This means that when the content is
              updated under the docroot, that change doesn't show until 30 seconds have passed. While developing
              a Yaws site, it may be convenient to set this value to 0. If the debug flag (-d) is passed to  the
              Yaws start script, this value is automatically set to 0.

       <b>trace</b>  <b>=</b> <b>false</b> <b>|</b> <b>traffic</b> <b>|</b> <b>http</b>
              This  enables traffic or http tracing. Tracing is also possible to enable with a command line flag
              to Yaws. Default is <u>false</u>.

       <b>auth_log</b>  <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              <b>Deprecated</b> <b>and</b> <b>ignored.</b> <b>Now,</b> <b>this</b> <b>target</b> <b>must</b> <b>be</b> <b>set</b> <b>in</b> <b>server</b> <b>part.</b>

       <b>max_connections</b> <b>=</b> <b>nolimit</b> <b>|</b> <b>Integer</b>
              Set this value to control the maximum number of connections from HTTP  clients  into  the  server.
              This is implemented by closing the last socket if the limit threshold is reached.

       <b>keepalive_maxuses</b> <b>=</b> <b>nolimit</b> <b>|</b> <b>Integer</b>
              Normally,  Yaws  does not restrict the number of times a connection is kept alive using keepalive.
              Setting this parameter to an integer X will ensure that connections are closed once they have been
              used X times.  This can be a useful to guard against long running connections collecting too  much
              garbage in the Erlang VM.

       <b>process_options</b> <b>=</b> <b>undefined</b> <b>|</b> <b>Proplist</b>
              Set  process  spawn  options for client acceptor processes.  Options must be specified as a quoted
              string of either the atom <u>undefined</u> or as a proplist  of  valid  process  options.  The  supported
              options  are  <u>fullsweep_after</u>,  <u>min_heap_size</u>,  and  <u>min_bin_vheap_size</u>, each taking an associated
              integer  value.  Other  process  options  are  ignored.  The  proplist  may  also  be  empty.  See
              <b>erlang:spawn_opt/4</b> for details on these options.

       <b>large_file_chunk_size</b> <b>=</b> <b>Integer</b>
              Set the chunk size used by Yaws to send large files. The default value is <u>10240</u>.

       <b>large_file_sendfile</b> <b>=</b> <b>erlang</b> <b>|</b> <b>disable</b>
              Set the version of sendfile method to use to send large files:

              <b>erlang</b> - use <u>file:sendfile/5</u>.

              <b>disable</b> - use <u>gen_tcp:send/2</u>.

              The default value is <u>erlang</u>.

       <b>acceptor_pool_size</b> <b>=</b> <b>Integer</b>
              Set the size of the pool of cached acceptor processes. The specified value must be greater than or
              equal to 0. The default value is <u>8</u>. Specifying a value of 0 effectively disables the process pool.

       <b>log_wrap_size</b> <b>=</b> <b>Integer</b>
              The  logs  written by Yaws are all wrap logs, the default value at the size where they wrap around
              and the original gets renamed to File.old is <u>1000000</u>, 1 megabyte. This value can be changed.
              If we set the value to 0 the logs will never wrap. If we want to use Yaws in  combination  with  a
              more  traditional  log  wrapper  such  as  logrotate,  set  the size to 0 and Yaws will reopen the
              logfiles once they have be renamed/removed.

       <b>log_resolve_hostname</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              By default the client host IP is not resolved in the access logs.

       <b>fail_on_bind_err</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Fail completely or not if Yaws fails to bind a listen socket Default is <u>true</u>.

       <b>enable_soap</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              If true, a soap server will be started at startup of Yaws.  Default is <u>false</u>.

       <b>soap_srv_mods</b> <b>=</b> <b>ListOfModuleSetting</b>
              If enable_soap is true, a startup Yaws will invoke  <u>yaws_soap_srv:setup()</u>  to  setup  modules  set
              here.  ModuleSetting  is either a triad like <u>&lt;Mod,</u> <u>HandlerFunc,</u> <u>WsdlFile&gt;</u> or a quadruple form like
              <u>&lt;Mod,</u> <u>HandlerFunc,</u> <u>WsdlFile,</u> <u>Prefix&gt;</u> which specifies the <u>prefix</u>. A <u>prefix</u> will be used as argument
              of <u>yaws_soap_lib:initModel()</u> and then be used as a XML namespace prefix.  Note, the <u>WsdlFile</u>  here
              should be an absolute-path file in local file systems.

              For example, we can specify

                soap_srv_mods=&lt;Mod1, Handler, Wsdl1&gt; &lt;Mod2, Handler, Wsdl2, Prefix&gt; ...

       <b>php_exe_path</b> <b>=</b> <b>Path</b>
              <b>this</b> <b>target</b> <b>is</b> <b>deprecated</b> <b>and</b> <b>useless.</b> <b>use</b> <b>'php_handler'</b> <b>target</b> <b>in</b> <b>server</b> <b>part</b> <b>instead.</b>
              The  name of (and possibly path to) the php executable used to interpret php scripts (if allowed).
              Default is <u>php_exe_path</u> <u>=</u> <u>php-cgi</u>.

       <b>copy_error_log</b>  <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Enable or disable copying of the error log. When we run in embedded mode, there may very  well  be
              some  other systems process that is responsible for writing the errorlog to a file whereas when we
              run in normal standalone mode, we typically want the Erlang errorlog written to a report.log file.
              Default value is <u>true</u>.

       <b>ysession_mod</b> <b>=</b> <b>Module</b>
              Allows specifying a different Yaws session storage mechanism instead of an ETS table. One  of  the
              drawbacks  of  the default yaws_session_server implementation is that server side cookies are lost
              when the server restarts. Specifying a different module here will pass all  write/read  operations
              to this module (it must implement appropriate callbacks).

       <b>ysession_cookiegen</b> <b>=</b> <b>Module</b>
              Allows  specifying  a different Yaws session cookie generator than the built-in default. <u>Module</u> is
              expected to provide a <u>new_cookie/0</u> function that returns a session cookie in the form of  a  list.
              Such a cookie generator module must be careful to return a unique cookie each time it's called.

       <b>ysession_idle_timeout</b> <b>=</b> <b>Integer</b>
              Controls  Yaws  session  idle  cleanup.  If  a  server  has  been  idle  for <u>ysession_idle_timeout</u>
              milliseconds,  check  all  Yaws  sessions  and  remove  any  that  have  timed  out.  The  default
              <u>ysession_idle_timeout</u> value is 2*60*1000 (2 minutes).

       <b>ysession_long_timeout</b> <b>=</b> <b>Integer</b>
              Controls  Yaws  session periodic cleanup. Every <u>ysession_long_timeout</u> milliseconds, check all Yaws
              sessions and remove any that have timed out. The default <u>ysession_long_timeout</u> value is 60*60*1000
              (1 hour).

       <b>runmod</b> <b>=</b> <b>ModuleName</b>
              At startup Yaws will invoke <u>ModuleName:start()</u> in a separate  process.  It  is  possible  to  have
              several  runmods.   This  is  useful if we want to reuse the Yaws startup shell script for our own
              application.

       <b>pick_first_virthost_on_nomatch</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              When Yaws gets a request, it extracts the Host header from the client request to choose a  virtual
              server  amongst  all  servers  with  the  same IP/Port pair.  This configuration parameter decides
              whether Yaws should pick the first server (as defined in the yaws.conf file) if no name  match  or
              not. If this is false and no Host header is present in the request, Yaws returns a 400 Bad Request
              as  required  by  the  HTTP  standard. In real live hosting scenarios we typically want this to be
              false, whereas in testing/development scenarios it may be convenient to set it to true. Default is
              <u>true</u>.

       <b>keepalive_timeout</b> <b>=</b> <b>TimeInMilliseconds</b> <b>|</b> <b>infinity</b>
              If the HTTP session will be kept  alive  (i.e.,  not  immediately  closed)  it  will  close  after
              keepalive_timeout milliseconds unless a new request is received in that time. The default value is
              <u>30000</u>. The value <u>infinity</u> is legal but not recommended.

       <b>subconfig</b> <b>=</b> <b>File</b>
              Load  specified  config  file.  Absolute  paths or relative ones to the configuration location are
              allowed. Unix-style  wildcard  strings  can  be  used  to  include  several  files  at  once.  See
              <u>filelib:wildcard/1</u> for details. Hidden files, starting by a dot, will be ignored. For example:

                subconfig = /etc/yaws/global.conf
                subconfig = /etc/yaws/vhosts/*.conf

              Or, relatively to the configuration location:

                subconfig = global.conf
                subconfig = vhosts/*.conf

       <b>subconfigdir</b> <b>=</b> <b>Directory</b>
              Load  all  config  files  found in the specified directory. The given Directory can be an absolute
              path or relative to the configuration location. Hidden files, starting by a dot, will be ignored.

       <b>x_forwarded_for_log_proxy_whitelist</b> <b>=</b> <b>ListOfUpstreamProxyServerIps</b>
              <b>this</b> <b>target</b> <b>is</b> <b>deprecated</b> <b>and</b> <b>will</b> <b>be</b> <b>ignored.</b>

       <b>default_type</b> <b>=</b> <b>MimeType</b>
              Defines the default MIME type to be used  where  Yaws  cannot  determine  it  by  its  MIME  types
              mappings. Default is <u>text/plain</u>.

       <b>default_charset</b> <b>=</b> <b>Charset</b>
              Defines  the  default  charset  to be added when a response content-type is <u>text/*</u>. By default, no
              charset is added.

       <b>mime_types_file</b> <b>=</b> <b>File</b>
              Overrides the default <u>mime.types</u> file included with Yaws. This file must use the following format:

                # Lines beginning with a '#' or a whitespace are ignored
                # blank lines are also ignored
                &lt;MIME type&gt; &lt;space separated file extensions&gt;

              The default file is located at <u>${PREFIX}/lib/yaws/priv/mime.types</u>. You should not edit  this  file
              because it may be replaced when you upgrade your server.

       <b>add_types</b> <b>=</b> <b>ListOfTypes</b>
              Specifies one or more mappings between MIME types and file extensions. More than one extension can
              be assigned to a MIME type. <u>ListOfTypes</u> is defined as follows:

                add_types = &lt;MimeType1, Ext&gt; &lt;MimeType2, Ext1 Ext2 ...&gt; ...

              The mappings defined using this directive will overload all other definitions. If a file extension
              is defined several times, only the last one is kept. Multiple <b>add_types</b> directives may be used.

       <b>add_charsets</b> <b>=</b> <b>ListOfCharsets</b>
              Specifies  one  or more mappings between charsets and file extensions. More than one extension can
              be assigned to a charset. <u>ListOfCharsets</u> is defined as follows:

                add_charsets = &lt;Charset1, Ext&gt; &lt;Charset2, Ext1 Ext2 ...&gt; ...

              The mappings defined using this directive will overload all other definitions. If a file extension
              is defined several times, only the last one is kept. Multiple <b>add_charsets</b> directives may be used.

       <b>sni</b> <b>=</b> <b>disable</b> <b>|</b> <b>enable</b> <b>|</b> <b>strict</b>
              Enables or disables the TLS SNI (Server Name Indication) support.

              When disabled (or not supported), all virtual servers in the same group (same IP/Port) must  share
              the same SSL configuration, especially the same SSL certificate. Only the HTTP Host header will be
              considered to find the right virtual server.

              When  enabled, SSL configuration can be different from one virtual server to another; each one can
              have its own SSL certificate. In this case, if a client provides a SNI hostname, it will  be  used
              to find the right virtual server. To accept the SNI information from the client, the first virtual
              server  --  the default one, see <b>pick_first_virthost_on_nomatch</b> -- <b>must</b> include TLS as a permitted
              protocol.

              If the <b>sni</b> directive is set to <u>enable</u>, non-SNI clients are allowed.   For  such  clients,  virtual
              servers  are selected as if Yaws did not have SNI support. If it is set to <u>strict</u>, SNI hostname is
              mandatory to access a SSL virtual server. But in all cases, when SNI  support  is  enabled,  if  a
              client provides a SNI hostname, it <b>must</b> match the HTTP Host header (which is mandatory too).  Note
              that  the  first  virtual server (the default one) will be used for any request where the provided
              SNI hostname doesn't match any of virtual server names. So, it is important that the first virtual
              server have the most restrictive access control, otherwise clients can access restricted resources
              by sending a request for any unknown hostname. (This  isn't  actually  any  different  from  using
              virtual  servers  without  SNI support.) If you're using self-signed certificates, be sure to also
              set the <b>depth</b> configuration variable to 0 to avoid following certificate chains.

              The <b>sni</b> directive is a global one, so if you set it to <u>strict</u>, non-SNI clients will be refused for
              <b>all</b> SSL groups. See <b>require_sni</b> directive from the server part to mitigate this requirement.

              Default is <u>disable</u>.

</pre><h4><b>SERVER</b> <b>PART</b></h4><pre>
       Yaws can virthost several web servers on the same IP address as well as several web servers on  different
       IP addresses. This includes SSL servers.

       Each  virtual host is defined within a matching pair of <b>&lt;server</b> <b>ServerName&gt;</b> and <b>&lt;/server&gt;</b>. The ServerName
       will be the name of the webserver.

       The following directives are allowed inside a server definition.

       <b>port</b> <b>=</b> <b>Port</b>
              This makes the server listen on Port. Default is <u>8000</u>.

       <b>listen</b> <b>=</b> <b>IpAddress</b>
              This makes the server listen on IpAddress.  When virthosting several servers on the  same  ip/port
              address,  if  the browser doesn't send a Host: field, Yaws will pick the <u>first</u> server specified in
              the config file.  If the specified IP address  is  0.0.0.0  Yaws  will  listen  on  all  local  IP
              addresses  on the specified port. Default is <u>127.0.0.1</u>.  Multiple <b>listen</b> directives may be used to
              specify several addresses to listen on.

       <b>listen_backlog</b> <b>=</b> <b>Integer</b>
              This sets the TCP listen backlog for the server to define the maximum length the queue of  pending
              connections may grow to. The default is 1024.

       <b>&lt;listen_opts&gt;</b> <b>...</b> <b>&lt;/listen_opts&gt;</b>
              Defines extra options to be set on the listen socket and, by inheritance, on accepted sockets. See
              <u>inet:setopts/2</u> for details. Supported options are:

              <b>buffer</b> <b>=</b> <b>Integer</b> (default: same as <u>inet:setopts/2</u>)

              <b>delay_send</b> <b>=</b> <b>true</b>  <b>|</b> <b>false</b>  (default: same as <u>inet:setopts/2</u>)

              <b>linger</b> <b>=</b> <b>Integer</b> <b>|</b> <b>false</b>  (default: same as <u>inet:setopts/2</u>)

              <b>nodelay</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>  (default: same as <u>inet:setopts/2</u>)

              <b>priority</b> <b>=</b> <b>Integer</b> (default: same as <u>inet:setopts/2</u>)

              <b>sndbuf</b> <b>=</b> <b>Integer</b> (default: same as <u>inet:setopts/2</u>)

              <b>recbuf</b> <b>=</b> <b>Integer</b> (default: same as <u>inet:setopts/2</u>)

              <b>send_timeout</b> <b>=</b> <b>Integer</b> <b>|</b> <b>infinity</b> (default: same as <u>inet:setopts/2</u>)

              <b>send_timeout_close</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>  (default: same as <u>inet:setopts/2</u>)

       <b>server_signature</b> <b>=</b> <b>String</b>
              This  directive sets the "Server: " output header to the custom value and overloads the global one
              for this virtual server.

       <b>subconfig</b> <b>=</b> <b>File</b>
              Same as <b>subconfig</b> directive of the global part, but here  files  should  only  contain  directives
              allowed in the server part.

       <b>subconfigdir</b> <b>=</b> <b>Directory</b>
              Same  as  <b>subconfigdir</b> directive of the global part, but here files should only contain directives
              allowed in server part.

       <b>rhost</b> <b>=</b> <b>Host[:Port]</b>
              This forces all local redirects issued by the server to go to Host.   This  is  useful  when  Yaws
              listens to a port which is different from the port that the user connects to. For example, running
              Yaws  as  a non-privileged user makes it impossible to listen to port 80, since that port can only
              be opened by a privileged user. Instead Yaws listens  to  a  high  port  number  port,  8000,  and
              iptables are used to redirect traffic to port 80 to port 8000 (most NAT:ing firewalls will also do
              this for you).

       <b>rmethod</b> <b>=</b> <b>http</b> <b>|</b> <b>https</b>
              This  forces  all  local redirects issued by the server to use this method. This is useful when an
              SSL off-loader, or stunnel, is used in front of Yaws.

       <b>auth_log</b>  <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Enable or disable the auth log for this virtual server. Default is <u>true</u>.

       <b>access_log</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Setting this directive to false turns off traffic logging for this  virtual  server.  The  default
              value is <u>true</u>.

       <b>logger_mod</b> <b>=</b> <b>Module</b>
              It is possible to set a special module that handles access and auth logging. The default is to log
              all web server traffic to &lt;Host&gt;.access and &lt;Host&gt;.auth files in the configured or default logdir.
              This module must implement the behaviour <u>yaws_logger</u>. Default value is <u>yaws_log</u>.

              The following functions should be exported:

              <b>Module:open_log(ServerName,</b> <b>Type,</b> <b>LogDir)</b>
                   When  Yaws is started, this function is called for this virtual server. If the initialization
                   is successful, the function must return <u>{true,State}</u> and if an error occurred, it must return
                   <u>false</u>.

              <b>Module:close_log(ServerName,</b> <b>Type,</b> <b>State)</b>
                   This function is called for this virtual server when Yaws is stopped.

              <b>Module:wrap_log(ServerName,</b> <b>Type,</b> <b>State,</b> <b>LogWrapSize)</b>
                   This function is used to rotate log files. It is regularly called by Yaws and must return the
                   possibly updated internal NewState.

              <b>Module:write_log(ServerName,</b> <b>Type,</b> <b>State,</b> <b>Infos)</b>
                   When it needs to log a message,  Yaws  will  call  this  function.  The  parameter  Infos  is
                   <u>{Ip,Req,InHdrs,OutHdrs,Time}</u> for an access log and <u>{Ip,Path,Item}</u> for an auth log, where:

                   <b>Ip</b> - IP address of the accessing client (as a tuple).

                   <b>Req</b>  -  the  HTTP  method,  URI  path,  and HTTP version of the request (as a #http_request{}
                   record).

                   <b>InHdrs</b> - the HTTP headers which were received from the WWW client (as a #headers{} record).

                   <b>OutHdrs</b> - the HTTP headers sent to the WWW client (as a #outh{} record)

                   <b>Path</b> - the URI path of the request (as a string).

                   <b>Item</b> - the result of an authentication request. May be <u>{ok,User}</u>, <u>403</u> or <u>{401,Realm}</u>.

                   <b>Time</b> - The time taken to serve the request, in microseconds.

              For all of these callbacks, <b>ServerName</b> is the virtual server's name, <u>Type</u> is the  atom  access  or
              auth and <u>State</u> is the internal state of the logger.

       <b>shaper</b> <b>=</b> <b>Module</b>
              Defines  a  module to control access to this virtual server. Access can be controlled based on the
              IP address of the client. It is also possible to throttle HTTP  requests  based  on  the  client's
              download rate. This module must implement the behaviour <u>yaws_shaper</u>.

              There is no such module configured by default.

       <b>dir_listings</b> <b>=</b> <b>true</b> <b>|</b> <b>true_nozip</b> <b>|</b> <b>false</b>
              Setting this directive to false disallows the automatic dir listing feature of Yaws. A status code
              403  Forbidden  will  be  sent.   Set  to  true_nozip to avoid the auto-generated all.zip entries.
              Default is <u>false</u>.

       <b>extra_cgi_vars</b> <b>=</b> <b>.....</b>
              Add additional CGI or FastCGI variables. For example:

                &lt;extra_cgi_vars dir='/path/to/some/scripts'&gt;
                  var = val
                  ...
                &lt;/extra_cgi_vars&gt;

       <b>statistics</b>  <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Turns on/off statistics gathering for a virtual server. Default is <u>false</u>.

       <b>fcgi_app_server</b> <b>=</b> <b>Host:Port</b>
              The hostname and TCP port number of a FastCGI application server.  To specify an IPv6 address, put
              it inside square brackets (ex: "[::1]:9000"). The TCP port number is not  optional.  There  is  no
              default value.

       <b>fcgi_trace_protocol</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Enable or disable tracing of FastCGI protocol messages as info log messages. Disabled by default.

       <b>fcgi_log_app_error</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Enable  or  disable  logging  of  application  error  messages (output to stderr and non-zero exit
              value). Disabled by default.

       <b>deflate</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Turns on or off deflate compression for a server. Default is <u>false</u>.

       <b>&lt;deflate&gt;</b> <b>...</b> <b>&lt;/deflate&gt;</b>
              This begins and ends the deflate compression configuration for this server.  The  following  items
              are allowed within a matching pair of &lt;deflate&gt; and &lt;/deflate&gt; delimiters.

              <b>min_compress_size</b> <b>=</b> <b>nolimit</b> <b>|</b> <b>Integer</b>
                   Defines  the  smallest  response  size  that  will be compressed. If nolimit is not used, the
                   specified value must be strictly positive. The default value is <u>nolimit</u>.

              <b>compression_level</b> <b>=</b> <b>none</b> <b>|</b> <b>default</b> <b>|</b> <b>best_compression</b> <b>|</b> <b>best_speed</b> <b>|</b> <b>0..9</b>
                   Defines the compression level  to  be  used.  0  (<u>none</u>),  gives  no  compression  at  all,  1
                   (<u>best_speed</u>)  gives  best  speed and 9 (<u>best_compression</u>) gives best compression. The default
                   value is <u>default</u>.

              <b>window_size</b> <b>=</b> <b>9..15</b>
                   Specifies the zlib compression window size. It should be in the range 9  through  15.  Larger
                   values  of  this  parameter  result in better compression at the expense of memory usage. The
                   default value is <u>15</u>.

              <b>mem_level</b> <b>=</b> <b>1..9</b>
                   Specifies how much memory should be allocated for the internal compression state. <u>mem_level=1</u>
                   uses minimum memory but is slow and  reduces  compression  ratio;  <u>mem_level=9</u>  uses  maximum
                   memory for optimal speed. The default value is <u>8</u>.

              <b>strategy</b> <b>=</b> <b>default</b> <b>|</b> <b>filtered</b> <b>|</b> <b>huffman_only</b>
                   This  parameter is used to tune the compression algorithm. See <b><a href="../man3erl/zlib.3erl.html">zlib</a>(3erl)</b> for more details on
                   the <u>strategy</u> parameter. The default value is <u>default</u>.

              <b>use_gzip_static</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
                   If true, Yaws will try to serve precompressed versions of static  files.  It  will  look  for
                   precompressed files in the same location as original files that end in ".gz". Only files that
                   do not fit in the cache are concerned. The default value is <u>false</u>.

              <b>mime_types</b> <b>=</b> <b>ListOfTypes</b> <b>|</b> <b>defaults</b> <b>|</b> <b>all</b>
                   Restricts  the  deflate compression to particular MIME types. The special value <u>all</u> enable it
                   for all types (It is a synonym of `*/*'). MIME types into  <u>ListOfTypes</u>  must  have  the  form
                   `type/subtype' or `type/*' (indicating all subtypes of that type). Here is an example:

                     mime_types = default image/*
                     mime_types = application/xml application/xhtml+xml application/rss+xml

                   By  default,  the  following  MIME  types are compressed (if <b>deflate</b> is set to true): <u>text/*,</u>
                   <u>application/rtf,</u>        <u>application/msword,</u>        <u>application/pdf,</u>        <u>application/x-dvi,</u>
                   <u>application/javascript</u>. Multiple <b>mime_types</b> directives can be used.

       <b>docroot</b> <b>=</b> <b>Directory</b> <b>...</b>
              This makes the server serve all its content from Directory.
              It  is possible to pass a space-separated list of directories as docroot. If this is the case, the
              various directories will be searched in order for the requested file. This also works with the ssi
              and yssi constructs where the full list of directories will be  searched  for  files  to  ssi/yssi
              include.  Multiple  docroot  directives can be used.  You need at least one valid docroot, invalid
              docroots are skipped with their associated auth structures.

       <b>auth_skip_docroot</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              If true, the docroot will not be searched for <u>.yaws_auth</u> files. This is useful when the docroot is
              quite large and the time to search it is prohibitive when Yaws starts up. Defaults to <u>false</u>.

       <b>partial_post_size</b> <b>=</b> <b>Integer</b> <b>|</b> <b>nolimit</b>
              When a Yaws file receives large POSTs, the amount of data received in each chunk is determined  by
              this parameter.  The default value is <u>10240</u>. Setting it to nolimit is potentially dangerous.

       <b>dav</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Turns  on  the  DAV protocol for this server. The dav support in Yaws is highly limited. If dav is
              turned on, .yaws processing of .yaws pages is turned  off.  Default  is  <u>false</u>.  The  socket  read
              timeout is supplied by the keepalive_timeout setting.  If the read is not done within the timeout,
              the POST will fail.

       <b>tilde_expand</b> <b>=</b> <b>true|false</b>
              If  this  value  is  set  to  false  Yaws  will  never  do  tilde expansion. The default is <u>false</u>.
              tilde_expansion is the mechanism whereby a URL on the form <a href="http://www.foo.com/~username">http://www.foo.com/~username</a> is changed
              into  a  request  where  the  docroot  for  that  particular  request  is  set  to  the  directory
              ~username/public_html/.

       <b>allowed_scripts</b> <b>=</b> <b>ListOfSuffixes</b>
              The  allowed  script types for this server.  Recognized are `yaws', `cgi', `fcgi', `php'.  Default
              is <u>allowed_scripts</u> <u>=</u> <u>yaws</u> <u>php</u> <u>cgi</u> <u>fcgi</u>.

              Note: for fcgi scripts, the FastCGI application server is only called if a  local  file  with  the
              .fcgi extension exists. However, the contents of the local .fcgi file are ignored.

       <b>tilde_allowed_scripts</b> <b>=</b> <b>ListOfSuffixes</b>
              The  allowed  script  types  for  this  server  when executing files in a users public_html folder
              Recognized are `yaws', `cgi', `fcgi', `php'.  Default is <u>tilde_allowed_scripts</u> <u>=</u> i.e. empty

       <b>index_files</b> <b>=</b> <b>ListOfResources</b>
              This directive sets the list of resources to look for,  when  a  directory  is  requested  by  the
              client.  If  the  last  entry begins with a `/', and none of the earlier resources are found, Yaws
              will perform a redirect to this uri.  Default is <u>index_files</u> <u>=</u> <u>index.yaws</u> <u>index.html</u> <u>index.php</u>.

       <b>appmods</b> <b>=</b> <b>ListOfModuleNames</b>
              If any of the names in ListOfModuleNames appear as components in the path for a request, the  path
              request  parsing  will terminate and that module will be called. There is also an alternate syntax
              for specifying the appmods if we don't want our internal erlang module names to be exposed in  the
              URL paths.  We can specify

                appmods = &lt;Path1, Module1&gt; &lt;Path2, Modules2&gt; ...

              Assume  for  example that we have the URL <a href="http://www.hyber.org/myapp/foo/bar/baz">http://www.hyber.org/myapp/foo/bar/baz</a>?user=joe while we
              have the module foo defined as an appmod, the function foo:out(Arg) will  be  invoked  instead  of
              searching the filesystems below the point foo.
              The Arg argument will have the missing path part supplied in its appmoddata field.

              It  is  also  possible  to exclude certain directories from appmod processing. This is particulaly
              interesting for '/' appmods.  Here is an example:

                appmods = &lt;/, myapp exclude_paths icons js top/static&gt;

              The above configuration will invoke the 'myapp' erlang module on everything except any file  found
              in directories 'icons', 'js' and 'top/static' relative to the docroot.

       <b>dispatchmod</b> <b>=</b> <b>DispatchModule</b>
              Set <u>DispatchModule</u> as a server-specific request dispatching module. Yaws expects <u>DispatchModule</u> to
              export  a  <u>dispatch/1</u>  function.  When  it receives a request, Yaws passes an <u>#arg{}</u> record to the
              dispatch module's <u>dispatch/1</u> function, which returns one of the following atom results:

                   <b>done</b> - this indicates the dispatch module handled the request itself  and  already  sent  the
                   response, and Yaws should resume watching for new requests on the connection

                   <b>closed</b> - same as <u>done</u> but the <u>DispatchModule</u> also closed the connection

                   <b>continue</b>  - the dispatch module has decided not to handle the request, and instead wants Yaws
                   to perform its regular request dispatching

              Note that when <u>DispatchModule</u> handles a request itself, Yaws does not support  tracing,  increment
              statistics counters or allow traffic shaping for that request. It does however still keep track of
              maximum keepalive uses on the connection.

       <b>errormod_404</b> <b>=</b> <b>Module</b>
              It  is  possible  to  set  a  special  module  that  handles  404 Not Found messages. The function
              <u>Module:out404(Arg,</u> <u>GC,</u> <u>SC)</u> will be invoked. The arguments are

                   <b>Arg</b> - a #arg{} record

                   <b>GC</b> - a #gconf{} record (defined in yaws.hrl)

                   <b>SC</b> - a #sconf{} record (defined in yaws.hrl)

              The function can and must do the same things that a normal <u>out/1</u> does.

       <b>errormod_401</b> <b>=</b> <b>Module</b>
              It is possible to set a special module that  handles  401  Unauthorized  messages.  This  can  for
              example be used to display a login page instead. The function <u>Module:out401(Arg,</u> <u>Auth,</u> <u>Realm)</u> will
              be invoked. The arguments are

                   <b>Arg</b> - a #arg{} record

                   <b>Auth</b> - a #auth{} record

                   <b>Realm</b> - a string

              The function can and must do the same things that a normal <u>out/1</u> does.

       <b>errormod_crash</b> <b>=</b> <b>Module</b>
              It  is possible to set a special module that handles the HTML generation of server crash messages.
              The default is to display the entire formatted crash message in the  browser.  This  is  good  for
              debugging but not in production.
              The  function  <u>Module:crashmsg(Arg,</u>  <u>SC,</u>  <u>Str)</u>  will  be called. The <u>Str</u> is the real crash message
              formatted as a string.
              The function must return, <u>{content,MimeType,Cont}</u> or <u>{html,</u> <u>Str}</u> or <u>{ehtml,</u> <u>Term}</u>. That data  will
              be shipped to the client.

       <b>expires</b> <b>=</b> <b>ListOfExpires</b>
              Controls  the  setting  of  the <u>Expires</u> HTTP header and the <u>max-age</u> directive of the <u>Cache-Control</u>
              HTTP header in server responses for specific MIME  types.  The  expiration  date  can  be  set  as
              relative  to  either the time the source file was last modified; as the time of the client access;
              or as always in order to empty the cache altogether. ListOfExpires is defined as follows:

                expires = &lt;MimeType1, access+Seconds&gt; &lt;MimeType2, modify+Seconds&gt; &lt;MimeType3, always&gt; ...

              A MimeType can also have a wildcard as subtype or both as subtype and type, like type/* or */*.

              These HTTP headers are an instruction to the client about the document's validity and persistence.
              If cached, the document may be fetched from the cache rather than from the source until this  time
              has passed. After that, the cache copy is considered "expired" and invalid, and a new copy must be
              obtained from the source. Here is an example:

                expires = &lt;image/gif, access+2592000&gt; &lt;image/png, access+2592000&gt;
                expires = &lt;image/jpeg, access+2592000&gt; &lt;text/css, access+2592000&gt;
                expires = &lt;text/*, always&gt;

              and here is another:

                expires = &lt;*/*, always&gt;

       <b>arg_rewrite_mod</b> <b>=</b> <b>Module</b>
              It  is  possible to install a module that rewrites all the Arg #arg{} records at an early stage in
              the Yaws server.  This can be used to do various things such as checking a cookie, rewriting paths
              etc. An arg_rewrite_mod must export an <u>arg_rewrite/1</u>  function  taking  and  returning  an  #arg{}
              record. If the function wants to return a response, it must set the #arg.state field of its return
              value to an instance of the #rewrite_response{} record.

              The  module  <u>yaws_vdir</u> can be used in case you want to serve static content that is not located in
              your docroot. See the example at the bottom of this man page for how to  use  the  <u>opaque</u>  +  <u>vdir</u>
              elements to instruct the <u>yaws_vdir</u> module what paths to rewrite.

       <b>start_mod</b> <b>=</b> <b>Module</b>
              Defines a user provided callback module.  At startup of the server, Module:start/1 will be called.
              The  #sconf{}  record  (defined  in  yaws.hrl)  will  be used as the input argument. This makes it
              possible for a user application to synchronize the startup with the Yaws server as well as getting
              hold of user specific configuration data, see the explanation for the &lt;opaque&gt; context.

       <b>revproxy</b> <b>=</b> <b>Prefix</b> <b>Url</b> <b>[intercept_mod</b> <b>Module]</b>
              Make Yaws a reverse proxy. <u>Prefix</u> is a path inside our own docroot  and  <u>Url</u>  <b>argument</b>  <b>is</b>  <b>a</b>  <b>URL</b>
              <b>pointing</b> <b>to</b> <b>a</b> <b>website</b> <b>we</b> <b>want</b> <b>to</b> <b>"mount"</b> <b>under</b> <b>the</b> <u>Prefix</u> path. This example:

                revproxy = /tmp/foo <a href="http://yaws.hyber.org">http://yaws.hyber.org</a>

              makes the hyber website appear under <u>/tmp/foo</u>.

              It is possible to have multiple reverse proxies inside the same server.

              You  can  optionally  configure  an  interception  module  for  each  reverse proxy, allowing your
              application to examine and modify requests and HTTP headers as they pass through  the  proxy  from
              client  to  backend  server  and also examine and modify responses and HTTP headers as they return
              from the backend server through the proxy to the client.

              You specify an interception module by including the optional  <u>intercept_mod</u>  keyword  followed  by
              <u>Module</u>, which should be the name of your interception module.

              An   interception   module   is   expected   to   export   two  functions:  <u>rewrite_request/2</u>  and
              <u>rewrite_response/2</u>. The two arguments passed to <u>rewrite_request/2</u> function are  a  <u>#http_request{}</u>
              record  and  a  <u>#headers{}</u>  record,  whereas  <u>rewrite_response/2</u> function takes a <u>#http_response{}</u>
              record and also a <u>#headers{}</u> record. You can find  definitions  for  these  record  types  in  the
              <u>yaws_api.hrl</u>  header  file.  Each  function can examine each record instance and can either return
              each original instance or can return a modified  copy  of  each  instance  in  its  response.  The
              <u>rewrite_request/2</u> function should return a tuple of the following form:

                <u>{ok,</u> <u>#http_request{},</u> <u>#headers{}}</u>

              and the <u>rewrite_response/2</u> function should similarly return a tuple of the following form:

                <u>{ok,</u> <u>#http_response{},</u> <u>#headers{}}</u>

              A <u>#headers{}</u> record can easily be manipulated in an interceptor using the functions listed below:

                <u>yaws_api:set_header/2</u>, <u>yaws_api:set_header/3</u>
                <u>yaws_api:get_header/2</u>, <u>yaws_api:get_header/3</u>
                <u>yaws_api:delete_header/2</u>

              Any  failures  in  your  interception  module's  functions  will  result  in HTTP status code 500,
              indicating an internal server error.

       <b>fwdproxy</b> <b>=</b> <b>true|false</b>
              Make Yaws a forward proxy. By enabling this option you can use Yaws as a proxy  for  outgoing  web
              traffic, typically by configuring the proxy settings in a web-browser to explicitly target Yaws as
              its proxy server.

       <b>servername</b> <b>=</b> <b>Name</b>
              If we're virthosting several servers and want to force a server to match specific Host: headers we
              can  do this with the "servername" directive. This name doesn't necessarily have to be the same as
              the the name inside &lt;server Name&gt; in certain NAT scenarios. Rarely used feature.

       <b>serveralias</b> <b>=</b> <b>ListOfNames</b>

              This directive sets the alternate names for a virtual host. A server alias may contain wildcards:
                    '*' matches any sequence of zero or more characters
                    '?' matches one character unless that character is a period ('.')

              Multiple <b>serveralias</b> directives may be used. Here is an example:

                &lt;server server.domain.com&gt;
                  serveralias = server server2.domain.com server2
                  serveralias = *.server.domain.com *.server?.domain.com
                  ...
                &lt;/server&gt;

       <b>php_handler</b> <b>=</b> <b>&lt;Type,</b> <b>Spec&gt;</b>
              Set handler to interpret .php files. It can be one of the following definitions:

              <b>php_handler</b> <b>=</b> <b>&lt;cgi,</b> <b>Filename&gt;</b> - The name of (and possibly path to)  the  php  executable  used  to
              interpret php scripts (if allowed).

              <b>php_handler</b>  <b>=</b>  <b>&lt;fcgi,</b>  <b>Host:Port&gt;</b>  - Use the specified fastcgi server to interpret .php files (if
              allowed).

                   Yaws does not start the PHP interpreter in fastcgi mode for you. To run PHP in fastcgi  mode,
                   call it with the -b option. For example:

                     php5-cgi -b '127.0.0.1:54321'

                   This  starts  a php5 in fastcgi mode listening on the local network interface. To make use of
                   this PHP server from Yaws, specify:

                     php_handler = &lt;fcgi, 127.0.0.1:54321&gt;

                   If you need to specify an IPv6 address, use square brackets:

                     php_handler = &lt;fcgi, [::1]:54321&gt;

                   The PHP interpreter needs read access to the files it is to serve. Thus, if you run it  in  a
                   different security context than Yaws itself, make sure it has access to the .php files.
                   Please  note that anyone who is able to connect to the php fastcgi server directly can use it
                   to read any file to which it has read access. You should consider  this  when  setting  up  a
                   system with several mutually untrusted instances of php.

              <b>php_handler</b> <b>=</b> <b>&lt;extern,</b> <b>Module:Function</b> <b>|</b> <b>Node:Module:Function&gt;</b> - Use an external handler, possibly
              on another node, to interpret .php files (if allowed).

                   To interpret a .php file, the function <u>Module:Function(Arg)</u> will be invoked (Evaluated inside
                   a rpc call if a <u>Node</u> is specified), where Arg is an #arg{} record.
                   The function must do the same things that a normal out/1 does.

              Default value is <u>&lt;cgi,</u> <u>"/usr/bin/php-cgi"&gt;</u>.

       <b>phpfcgi</b> <b>=</b> <b>Host:Port</b>
              <b>this</b> <b>target</b> <b>is</b> <b>deprecated.</b> <b>use</b> <b>'php_handler'</b> <b>target</b> <b>in</b> <b>server</b> <b>part</b> <b>instead.</b>
              Using this directive is the same as: php_handler = &lt;fcgi, Host:Port&gt;.

       <b>default_type</b> <b>=</b> <b>MimeType</b>
              Overloads the global <b>default_type</b> value for this virtual server.

       <b>default_charset</b> <b>=</b> <b>Charset</b>
              Overloads the global <b>default_charset</b> value for this virtual server.

       <b>mime_types_file</b> <b>=</b> <b>File</b>
              Overloads  the  global <b>mime_type_file</b> value for this virtual server. Mappings defined in <u>File</u> will
              not overload those defined by <b>add_types</b> directives in the global part.

       <b>add_types</b> <b>=</b> <b>ListOfTypes</b>
              Overloads the global <b>add_types</b> values for this virtual server. If a  mapping  is  defined  in  the
              global  part  and redefined in a server part using this directive, then it is replaced. Else it is
              kept.

       <b>add_charsets</b> <b>=</b> <b>ListOfCharsets</b>
              Overloads the global <b>add_charsets</b> values for this virtual server. If a mapping is defined  in  the
              global  part  and redefined in a server part using this directive, then it is replaced. Else it is
              kept.

       <b>nslookup_pref</b> <b>=</b> <b>[inet</b> <b>|</b> <b>inet6]</b>
              For fcgi servers and revproxy URLs, define the name resolution preference. For example, to perform
              only IPv4 name resolution, use [inet]. To do both IPv4 and IPv6 but try IPv6  first,  use  [inet6,
              inet].  Default value is [inet].

       <b>&lt;ssl&gt;</b> <b>...</b> <b>&lt;/ssl&gt;</b>

              This  begins  and ends an SSL configuration for this server. It's possible to virthost several SSL
              servers on the same IP/Port. If SNI support is disabled or not supported, they must share the same
              certificate configuration. In this situation, it is complicated to virthost several SSL servers on
              the same IP/Port since the certificate is typically bound to a domainname in the common name  part
              of  the  certificate.  One  solution  to  this  problem  is  to  have  a certificate with multiple
              subjectAltNames. If SNI support is enabled, SSL servers on the same IP/Port can have their own SSL
              configuration with a different SSL certificate for each one. See the global <b>sni</b> directive.

              The SNI support was introduced in the SSL application in Erlang/OTP 18.0. It is  an  extension  to
              the  TLS  protocol  (RFC  4366),  which allows the client to include the requested hostname in the
              first message of its SSL handshake.

              See also <a href="http://wiki.cacert.org/VhostTaskForce">http://wiki.cacert.org/VhostTaskForce</a>#Interoperability_Test for browser compatibility.

              <b>keyfile</b> <b>=</b> <b>File</b>
                   Specifies which file contains the private key for the certificate. If not specified then  the
                   certificate file will be used.

              <b>certfile</b> <b>=</b> <b>File</b>
                   Specifies which file contains the certificate for the server.

              <b>cacertfile</b> <b>=</b> <b>File</b>
                   A  file  containing  trusted certificates to use during client authentication and to use when
                   attempting to build the server certificate chain.  The list is  also  used  in  the  list  of
                   acceptable client CAs passed to the client when a certificate is requested.

              <b>dhfile</b> <b>=</b> <b>File</b>
                   A  file containing PEM-encoded Diffie-Hellman parameters to be used by the server if a cipher
                   suite using Diffie-Hellman key exchange is negotiated. If not specified,  default  parameters
                   are used.

              <b>verify</b> <b>=</b> <b>verify_none</b> <b>|</b> <b>verify_peer</b>
                   Specifies  the  level  of  verification  the server does on client certs. Setting <u>verify_none</u>
                   means that the x509 validation will be  skipped  (no  certificate  request  is  sent  to  the
                   client),  <u>verify_peer</u> means that a certificate request is sent to the client (x509 validation
                   is performed.

                   You might want to use <b>fail_if_no_peer_cert</b> in combination with <u>verify_peer</u><b>.</b>

              <b>fail_if_no_peer_cert</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
                   If <b>verify</b> is set to <u>verify_peer</u> and set to <u>true</u> the connection will fail if the  client  does
                   not send a certificate (i.e. an empty certificate). If set to <u>false</u> the server will fail only
                   if an invalid certificate is supplied (an empty certificate is considered valid).

              <b>depth</b> <b>=</b> <b>Int</b>
                   Specifies  the  depth  of  certificate chains the server is prepared to follow when verifying
                   client certs. For the OTP new SSL implementation it is also  used  to  specify  how  far  the
                   server (Yaws in our case) shall follow the SSL certificates we present to the clients. Hence,
                   using self-signed certs, we typically need to set this to 0.

              <b>password</b> <b>=</b> <b>String</b>
                   If the private key is encrypted on disc, this password is the 3DES key to decrypt it.

              <b>ciphers</b> <b>=</b> <b>String</b>
                   This string specifies the SSL cipher string. The syntax of the SSL cipher string is a 4-tuple
                   representation  of  the  map  returned by ssl:cipher_suites/2,3: <u>{#{key_exchange},</u> <u>#{cipher},</u>
                   <u>#{mac},</u> <u>#{prf}}</u>.

                   ciphers = "[{dhe_rsa,aes_256_cbc,sha,default_prf}, \
                               {dhe_dss,aes_256_cbc,sha,default_prf}]"

                   In older versions of Yaws, a cipher tuple lacked the <u>#{prf}</u> element. When Yaws reads a cipher
                   of the old format from configuration, it attempts to  convert  it  to  a  4-tuple  by  adding
                   <u>default_prf</u>  for  the  <u>#{prf}</u> element. Be aware that this may not work for all ciphers; if it
                   fails, manual intervention is needed to properly configure the ciphers in the new format.

              <b>eccs</b> <b>=</b> <b>String</b>
                   This string specifies the supported Elliptic Curve Cryptography (ECC).  It must be  a  subset
                   of <b>ssl:eccs()</b>.  For PCI DSS compliance (which is the main reason why you would want to change
                   this), set it on a single line to:

                   eccs = "[sect571r1, sect571k1, secp521r1, brainpoolP512r1, \
                            sect409k1, sect409r1, brainpoolP384r1, secp384r1, \
                            sect283k1, sect283r1, brainpoolP256r1, secp256k1, \
                            secp256r1, sect239k1, xsect233k1, sect233r1, \
                            secp224k1, secp224r1]"

              <b>secure_renegotiate</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b> <b>|</b> <b>undefined</b>
                   Specifies  whether  to  reject  renegotiation  attempt  that does not live up to RFC 5746. By
                   default <b>secure_renegotiate</b> is set to false for protocol versions that support it, i.e. secure
                   renegotiation will be used if possible but it will fallback to unsecure renegotiation if  the
                   peer  does not support RFC 5746. Set it to undefined to use the <u>ssl</u> module default setting to
                   avoid errors with protocol versions that don't support it, such as TLS version 1.3. For  more
                   details, see the <u>ssl</u> manual page at <a href="http://www.erlang.org/doc/man/ssl.html">http://www.erlang.org/doc/man/ssl.html</a>

              <b>client_renegotiation</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b> <b>|</b> <b>undefined</b>
                   Enables  or  disables the Erlang/OTP SSL application client renegotiation option. Defaults to
                   true for protocol versions that support it. Set it to undefined to use the <u>ssl</u> module default
                   setting to avoid errors with protocol versions that don't support it,  such  as  TLS  version
                   1.3. For more details, see the <u>ssl</u> manual page at <a href="http://www.erlang.org/doc/man/ssl.html">http://www.erlang.org/doc/man/ssl.html</a>

              <b>honor_cipher_order</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
                   If  true  (the  default), use the server's preference for cipher selection. If false, use the
                   client's preference.

              <b>protocol_version</b> <b>=</b> <b>ProtocolList</b>
                   Specifies the list of SSL protocols that will be supported.  If  not  set,  defaults  to  all
                   protocols  supported by the erlang <b>ssl</b> application. For example, to support only TLS versions
                   1.3, 1.2, 1.1, and 1:

                   protocol_version = tlsv1.3, tlsv1.2, tlsv1.1, tlsv1

              <b>require_sni</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
                   If <u>true</u>,the server will reject non-SNI clients and clients providing an unknown SNI  hostname
                   (this  last  remark  is  only  relevant  for  the  first virtual server of a SSL group). This
                   directive is ignored if SNI support is disabled (or not supported).

                   Default is <u>false</u>.

       <b>&lt;redirect&gt;</b> <b>...</b> <b>&lt;/redirect&gt;</b>
              Defines a redirect mapping. The following items are allowed within a matching pair  of  &lt;redirect&gt;
              and &lt;/redirect&gt; delimiters.

              We can have a series of redirect rules in one of the formats below:

                Path = URL
                Path = code
                Path = code URL

              <b>Path</b>  must be an url-decoded path beginning with a slash. <b>URL</b> may be either a relative URL (a path
              beginning with a slash), or an absolute URL. In the first case, the  <u>scheme:hostname:port</u>  of  the
              current  server  will  be  added.  All  accesses  to  <b>Path</b>  will  be  redirected  to  <b>URL/Path</b> (or
              <b>scheme:hostname:port/URL/Path</b> if <b>URL</b> is relative). <b>URL</b> must be url-encoded. Note that the original
              path is appended to the redirected URL.

              For example, assume we have the following redirect configuration:

                &lt;redirect&gt;
                  /foo = <a href="http://www.mysite.org/zapp">http://www.mysite.org/zapp</a>
                  /bar = /tomato.html
                &lt;/redirect&gt;

              Assuming this config resides on a site called <a href="http://abc.com">http://abc.com</a>, we have the following redirects:

                <a href="http://abc.com/foo">http://abc.com/foo</a> -&gt; <a href="http://www.mysite.org/zapp/foo">http://www.mysite.org/zapp/foo</a>
                <a href="http://abc.com/foo/test">http://abc.com/foo/test</a> -&gt; <a href="http://www.mysite.org/zapp/foo/test">http://www.mysite.org/zapp/foo/test</a>
                <a href="http://abc.com/bar">http://abc.com/bar</a> -&gt; <a href="http://abc.com/tomato.html/bar">http://abc.com/tomato.html/bar</a>
                <a href="http://abc.com/bar/x/y/z">http://abc.com/bar/x/y/z</a> -&gt; <a href="http://abc.com/tomato.html/bar/x/y/z">http://abc.com/tomato.html/bar/x/y/z</a>

              By default, Yaws will perform a 302 redirect. The HTTP status code can be changed using  the  <b>code</b>
              parameter. Note that the status code must be known by Yaws.

              •  For  3xx  status  codes,  the  <b>URL</b>  parameter must be present and will be used to build the new
                 location.

              •  For other status codes (1xx, 2xx, 4xx and 5xx), it can be omitted. In the absence of <b>URL</b>,  Yaws
                 will return a generic response with the specified status code.

              •  Otherwise, the <b>URL</b> parameter must be a relative URL and will be used to customize the response.

              Sometimes  we  do  not want to have the original path appended to the redirected path. To get that
              behaviour we specify the config with '==' instead of '='.

                &lt;redirect&gt;
                  /foo == <a href="http://www.mysite.org/zapp">http://www.mysite.org/zapp</a>
                  /bar = /tomato.html
                &lt;/redirect&gt;

              Now a request for <a href="http://abc.com/foo/x/y/z">http://abc.com/foo/x/y/z</a> simply gets redirected  to  <a href="http://www.mysite.org/zapp">http://www.mysite.org/zapp</a>.
              This is typically used when we simply want a static redirect at some place in the docroot.

              When we specify a relative URL as the target for the redirect, the redirect will be to the current
              http(s) server.

       <b>&lt;auth&gt;</b> <b>...</b> <b>&lt;/auth&gt;</b>
              Defines  an  auth  structure. The following items are allowed within a matching pair of &lt;auth&gt; and
              &lt;/auth&gt; delimiters.

              <b>docroot</b> <b>=</b> <b>Docroot</b>
                   If a docroot is defined, this auth  structure  will  be  tested  only  for  requests  in  the
                   specified  docroot.  No  docroot  configured  means all docroots.  If two auth structures are
                   defined, one with a docroot and one with no docroot, the first of both overrides  the  second
                   one for requests in the configured docroot.

              <b>dir</b> <b>=</b> <b>Dir</b>
                   Makes Dir to be controlled by WWW-authenticate headers. In order for a user to have access to
                   WWW-Authenticate  controlled  directory,  the  user  must  supply a password. The Dir must be
                   specified relative to the docroot.  Multiple dir can be used. If no dir is set,  the  default
                   value, <u>"/"</u>, will be used.

              <b>realm</b> <b>=</b> <b>Realm</b>
                   In the directory defined here, the WWW-Authenticate Realm is set to this value.

              <b>authmod</b> <b>=</b> <b>AuthMod</b>
                   If  an  auth  module is defined then AuthMod:auth(Arg, Auth) will be called for all access to
                   the directory. The auth/2 function  should  return  one  of:  true,  false,  {false,  Realm},
                   {appmod, Mod}.  If {appmod, Mod} is returned then a call to Mod:out401(Arg, Auth, Realm) will
                   be  used to deliver the content. If errormod_401 is defined, the call to Mod will be ignored.
                   (Mod:out(Arg) is deprecated).

                   This can, for example, be used to implement cookie authentication.  The auth() callback would
                   check if a valid cookie header is present, if not it would return {appmod, ?MODULE}  and  the
                   out401/1 function in the same module would return {redirect_local, "/login.html"}.

              <b>user</b> <b>=</b> <b>User:Password</b> <b>|</b> <b>"User:{Algo}Hash"</b> <b>|</b> <b>"User:{Algo}$Salt$Hash"</b>
                   Inside this directory, the user <u>User</u> has access if the user supplies the password <u>Password</u> in
                   the  popup  dialogue  presented  by  the  browser.  It  is  also possible to provide a hashed
                   password, encoded in base64. In that case, the algorithm used to hash the  password  must  be
                   set. <u>Algo</u> must be one of the following algorithms:

                       md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512

                   It  is possible to use salted hashes. If so, the <u>Salt</u> must be provided, encoded in base64. We
                   can specify multiple users inside a single &lt;auth&gt; &lt;/auth&gt; pair.

              <b>pam</b> <b>service</b> <b>=</b> <u>pam-service</u>
                   If the item <b>pam</b> is part of the auth structure, Yaws will also try to  authenticate  the  user
                   using  "pam"  using  the  pam  <u>service</u>  indicated.  Usual  services are typically found under
                   /etc/pam.d. Usual values are "system-auth" etc.

                   pam authentication is performed by an Erlang port program which  is  typically  installed  as
                   suid root by the Yaws install script.

              <b>allow</b> <b>=</b> <b>all</b> <b>|</b> <b>ListOfHost</b>
                   The  <u>allow</u>  directive  affects  which  hosts  can access an area of the server. Access can be
                   controlled by IP address or IP address range. If all is specified, then all hosts are allowed
                   access, subject to the configuration  of  the  <u>deny</u>  and  <u>order</u>  directives.  To  allow  only
                   particular hosts or groups of hosts to access the server, the host can be specified in any of
                   the following formats:

                   <b>A</b> <b>full</b> <b>IP</b> <b>address</b>
                     allow = 10.1.2.3
                     allow = 192.168.1.104, 192.168.1.205

                   <b>A</b> <b>network/netmask</b> <b>pair</b>
                     allow = 10.1.0.0/255.255.0.0

                   <b>A</b> <b>network/nnn</b> <b>CIDR</b> <b>specification</b>
                     allow = 10.1.0.0/16

              <b>deny</b> <b>=</b> <b>all</b> <b>|</b> <b>ListOfHost</b>
                   This  directive  allows  access  to  the  server  to  be  restricted based on IP address. The
                   arguments for the <u>deny</u> directive are identical to the arguments for the <u>allow</u> directive.

              <b>order</b> <b>=</b> <b>Ordering</b>
                   The <u>order</u> directive, along with <u>allow</u> and  <u>deny</u>  directives,  controls  a  three-pass  access
                   control  system.  The  first  pass  processes  either  all  <u>allow</u>  or all <u>deny</u> directives, as
                   specified by the <u>order</u> directive. The second pass parses the rest of the directives (<u>deny</u>  or
                   <u>allow</u>). The third pass applies to all requests which do not match either of the first two.

                   Ordering is one of (Default value is <u>deny,allow</u>):

                   <b>allow,deny</b>
                          First,  all <u>allow</u> directives are evaluated; at least one must match, or the request is
                          rejected. Next, <u>deny</u>  directives  are  evaluated.  If  any  matches,  the  request  is
                          rejected.  Last,  any  requests  which  do  not match an <u>allow</u> or a <u>deny</u> directive are
                          denied by default.

                   <b>deny,allow</b>
                          First, all <u>deny</u> directives are evaluated; if any matched, the request is denied unless
                          it also matches an <u>allow</u> directive. Any requests which do not match any <u>allow</u> or  <u>deny</u>
                          directives are permitted.

       <b>&lt;opaque&gt;</b> <b>...</b> <b>&lt;/opaque&gt;</b>
              This  begins  and  ends  an  opaque  configuration  context  for  this server, where 'Key = Value'
              directives can be specified. These directives are ignored by Yaws (hence the name opaque), but can
              be accessed as a list of tuples <u>{Key,Value}</u> stored in the #sconf.opaque record entry. See also the
              description of the <u>start_mod</u> directive.

              This mechanism can be used to pass data from a surrounding application into the  individual  .yaws
              pages.

       <b>strip_undefined_bindings</b> <b>=</b> <b>true</b> <b>|</b> <b>false</b>
              Change  the  behavior  of  the  <u>{bindings,</u>  <u>[...]}</u>  directive to treat all undefined keys found in
              returned <u>out/1</u> content as if they were defined with an empty value,  resulting  in  all  undefined
              bindings  effectively being stripped out of returned content. By default, <u>strip_undefined_bindings</u>
              is false, which means undefined bindings are ignored and their text is  left  as  is  in  returned
              content.

              This setting applies only for <u>out/1</u> content, not to static pages or other returned content.

       <b>&lt;extra_response_headers&gt;</b> <b>...</b> <b>&lt;/extra_response_headers&gt;</b>
              This  begins  and  ends  a configuration context for extra response headers for this server, where
              directives for adding headers, erasing headers, and modules for handling  extra  response  headers
              can be specified as follows:

                   <b>add</b> <b>Hdr</b> <b>=</b> <b>Value</b>
                          Add  <u>Hdr</u> with value <u>Value</u> to the response, but only if the response status code is one
                          of these values:

                               200 OK
                               201 Created
                               204 No Content
                               206 Partial Content
                               301 Moved Permanently
                               302 Found
                               303 See Other
                               304 Not Modified
                               307 Temporary Redirect
                               308 Permanent Redirect

                   For any other status code, <u>Hdr</u> is not added.

                   <b>always</b> <b>add</b> <b>Hdr</b> <b>=</b> <b>Value</b>
                          Unconditionally add <u>Hdr</u> with value <u>Value</u> to the response, regardless of  the  response
                          status code.

                   <b>erase</b> <b>Hdr</b>
                          Remove <u>Hdr</u> <u>and</u> <u>its</u> <u>associated</u> <u>value</u> <u>from</u> <u>the</u> <u>response.</u>

                   <b>extramod</b> <b>=</b> <b>Module</b>
                          Specifies   a   module   to  call  to  process  extra  response  headers.  Yaws  calls
                          <u>Module:extra_response_headers/3</u> passing the following arguments:

                               <b>Response</b> <b>headers</b>
                                      An Erlang map holding the response headers with  header  name  strings  as
                                      keys and strings as header values

                               <b>Arg</b>    An  <u>#arg{}</u>  record  representing  the  request. In cases where an <u>extramod</u>
                                      module is called following the invocation of an appmod, the <u>#arg{}</u>  record
                                      field  <u>appmod_name</u>  indicates  the  name  of  the appmod that serviced the
                                      request, allowing the <u>extramod</u> to return extra  HTTP  headers  appropriate
                                      for that appmod.

                               <b>{StatusCode,Version}</b>
                                      A tuple where <u>StatusCode</u> is the numeric HTTP status code for the response,
                                      and  <u>Version</u>  is  a tuple specifying the HTTP version, e.g. <u>{1,1}</u> for HTTP
                                      1.1.

                   The <u>Module:extra_response_headers/3</u> function should return either the original header map  or
                   a  modified  map  where  headers  have been added, changed, or deleted. Added headers are not
                   subject to the status code restrictions for the <u>add</u> extra response header directive, but  the
                   function  can  call  <b>yaws_api:http_extra_response_headers_add_status_codes/0</b>  to retrieve the
                   list of the status codes for which adding headers is normally allowed.

                   For response headers that can have multiple settings, such as <u>Set-Cookie</u>, multiple values can
                   be specified in the extra response header map by using a  value  of  <u>{multi,</u>  <u>[Value]}</u>  where
                   <u>[Value]</u>  is  a list of one or more header values. The <u>Set-Cookie</u> header is a standard special
                   case for which Yaws converts a <u>multi</u> header into a separate Set-Cookie header for each value;
                   for other headers, Yaws converts a <u>multi</u> header into a  single  HTTP  header  with  a  comma-
                   separated value.

       Note that extra response headers do not apply to responses returned directly by any <u>DispatchModule</u>.

       <b>options_asterisk_methods</b> <b>=</b> <b>Methods</b>
              Setting  <u>options_asterisk_methods</u>  to a comma-separated list of HTTP <u>Methods</u> makes Yaws respond to
              an <u>OPTIONS</u> request that specifies a literal <u>*</u> as the target with a <u>200</u>  <u>OK</u>  status  and  an  <u>Allow</u>
              header   listing  the  specified  <u>Methods</u>.  If  the  configuration  does  not  explicitly  specify
              <u>options_asterisk_methods</u>, Yaws defaults to responding to <u>OPTIONS</u> <u>*</u> requests with a <u>200</u>  <u>OK</u>  status
              and an <u>Allow</u> header listing these HTTP methods:

                GET, HEAD, POST, PUT, DELETE, OPTIONS

              RFC 7231 section 4.3 lists the standard HTTP method names:

                GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE

              An  <u>options_asterisk_methods</u>  setting can include any of these HTTP method names as well as <u>PATCH</u>.
              <u>PATCH</u> is not mentioned in RFC 7231 but Yaws supports it. Yaws does not implement <u>CONNECT</u>,  but  it
              supports  it in <u>options_asterisk_methods</u> because it's possible to implement support for it using a
              <u>dispatchmod</u>.

              If <u>options_asterisk_methods</u> is set to an empty value, Yaws responds to  <u>OPTIONS</u>  <u>*</u>  requests  with
              status <u>400</u> <u>Bad</u> <u>Request</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example defines a single server on port 80.

           logdir = /var/log/yaws
           &lt;server www.mydomain.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www
           &lt;/server&gt;

       And this example shows a similar setup but two web servers on the same IP address.

           logdir = /var/log/yaws
           &lt;server www.mydomain.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www
           &lt;/server&gt;

           &lt;server www.funky.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www_funky_org
           &lt;/server&gt;

       An example with www-authenticate and no access logging at all.

           logdir = /var/log/yaws
           &lt;server www.mydomain.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www
               access_log = false
               &lt;auth&gt;
                   dir = secret/dir1
                   realm = foobar
                   user = jonny:verysecretpwd
                   user = benny:thequestion
                   user = ronny:havinganamethatendswithy
              &lt;/auth&gt;
           &lt;/server&gt;

       An  example  specifying  a  user  defined  module  to be called at startup, as well as some user specific
       configuration.

           &lt;server www.funky.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www_funky_org
               start_mod = btt
               &lt;opaque&gt;
                       mydbdir = <a href="file:/tmp">/tmp</a>
                       mylogdir = /tmp/log
               &lt;/opaque&gt;
           &lt;/server&gt;

       An example specifying the GSSAPI/SPNEGO module (authmod_gssapi)  to  be  used  for  authentication.  This
       module requires egssapi version 0.1~pre2 or later available at <a href="http://www.hem.za.org/egssapi/">http://www.hem.za.org/egssapi/</a>.

       The  Kerberos5 keytab is specified as 'keytab = File' directive in opaque. This keytab should contain the
       keys of the HTTP service principal, 'HTTP/www.funky.org' in this example.

           &lt;server www.funky.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www_funky_org
               start_mod = authmod_gssapi
               &lt;auth&gt;
                       authmod = authmod_gssapi
                       dir = secret/dir1
               &lt;/auth&gt;
               &lt;opaque&gt;
                       keytab = /etc/yaws/http.keytab
               &lt;/opaque&gt;
           &lt;/server&gt;

       And finally a slightly more complex example with two servers on the same IP, and  one  SSL  server  on  a
       different IP.

       When there are more than one server on the same IP, and they have different names the server must be able
       to  choose  one of them if the client doesn't send a Host: header. Yaws will choose the first one defined
       in the conf file.

           logdir = /var/log/yaws
           max_num_cached_files = 8000
           max_num_cached_bytes = 6000000

           &lt;server www.mydomain.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www
           &lt;/server&gt;

           &lt;server www.funky.org&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www_funky_org
           &lt;/server&gt;

           &lt;server www.funky.org&gt;
               port = 443
               listen = 192.168.128.32
               docroot = /var/yaws/www_funky_org
               &lt;ssl&gt;
                  keyfile = /etc/funky.key
                  certfile = /etc/funky.cert
                  password = gazonk
               &lt;/ssl&gt;
           &lt;/server&gt;

       Finally an example with virtual directories, vdirs.

           &lt;server server.domain&gt;
               port = 80
               listen = 192.168.128.31
               docroot = /var/yaws/www
               arg_rewrite_mod = yaws_vdir
               &lt;opaque&gt;
                   vdir = "/virtual1/ /usr/local/somewhere/notrelated/to/main/docroot"
                   vdir = "/myapp/ /some/other/path can include/spaces"
                   vdir = "/icons/  /usr/local/www/yaws/icons"
               &lt;/opaque&gt;
           &lt;/server&gt;

       The  first  defined  vdir  can  then  be  accessed  at   or   under   <a href="http://server.domain/virtual1/">http://server.domain/virtual1/</a>   or
       <a href="http://server.domain/virtual1">http://server.domain/virtual1</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Claes Wikstrom

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/yaws.1.html">yaws</a></b>(1) <b><a href="../man1/erl.1.html">erl</a></b>(1)

                                                                                                    <u><a href="../man5/YAWS.CONF.5.html">YAWS.CONF</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>