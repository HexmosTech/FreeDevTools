<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yaws_api - api available to yaws web server programmers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/erlang-yaws">erlang-yaws_2.2.0+dfsg-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       yaws_api - api available to yaws web server programmers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>yaws_api:Function(...)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  is  the  api  available  to yaws web server programmers. The Erlang module yaws_api contains a wide
       variety of functions that can be used inside yaws pages.

       Each chunk of yaws code is executed while the yaws page is being delivered from the  server.  We  give  a
       very simple example here to show the basic idea. Imagine the following HTML code:

       <u>&lt;html&gt;</u>
       <u>&lt;body&gt;</u>

       <u>&lt;h1&gt;</u> <u>Header</u> <u>1&lt;/h1&gt;</u>

       <u>&lt;erl&gt;</u>
       <u>out(Arg)</u> <u>-&gt;</u>
           <u>{html,</u> <u>"&lt;p&gt;</u> <u>Insert</u> <u>this</u> <u>text</u> <u>into</u> <u>the</u> <u>document"}.</u>
       <u>&lt;/erl&gt;</u>

       <u>&lt;/body&gt;</u>
       <u>&lt;/html&gt;</u>

       The  <b>out(Arg)</b>  function  is  supplied  one argument, an #arg{} structure.  We have the following relevant
       record definitions:

       <u>-record(arg,</u> <u>{</u>
                 <u>clisock,</u>        <u>%</u> <u>the</u> <u>socket</u> <u>leading</u> <u>to</u> <u>the</u> <u>peer</u> <u>client</u>
                 <u>client_ip_port,</u> <u>%</u> <u>{ClientIp,</u> <u>ClientPort}</u> <u>tuple</u>
                 <u>headers,</u>        <u>%</u> <u>headers</u>
                 <u>req,</u>            <u>%</u> <u>request</u> <u>(possibly</u> <u>rewritten)</u>
                 <u>orig_req,</u>       <u>%</u> <u>original</u> <u>request</u>
                 <u>clidata,</u>        <u>%</u> <u>The</u> <u>client</u> <u>data</u> <u>(as</u> <u>a</u> <u>binary</u> <u>in</u> <u>POST</u> <u>requests)</u>
                 <u>server_path,</u>    <u>%</u> <u>The</u> <u>normalized</u> <u>server</u> <u>path</u>
                                 <u>%</u> <u>(pre-querystring</u> <u>part</u> <u>of</u> <u>URI)</u>
                 <u>querydata,</u>      <u>%</u> <u>For</u> <u>URIs</u> <u>of</u> <u>the</u> <u>form</u> <u>...?querydata</u>
                                 <u>%</u>  <u>equiv</u> <u>of</u> <u>cgi</u> <u>QUERY_STRING</u>
                 <u>appmoddata,</u>     <u>%</u> <u>(deprecated</u> <u>-</u> <u>use</u> <u>pathinfo</u> <u>instead)</u> <u>the</u> <u>remainder</u>
                                 <u>%</u> <u>of</u> <u>the</u> <u>path</u> <u>leading</u> <u>up</u> <u>to</u> <u>the</u> <u>query</u>
                 <u>docroot,</u>        <u>%</u> <u>Physical</u> <u>base</u> <u>location</u> <u>of</u> <u>data</u> <u>for</u> <u>this</u> <u>request</u>
                 <u>docroot_mount,</u>  <u>%</u> <u>virtual</u> <u>directory</u> <u>e.g</u> <u>/myapp/</u> <u>that</u> <u>the</u> <u>docroot</u>
                                 <u>%</u>  <u>refers</u> <u>to.</u>
                 <u>fullpath,</u>       <u>%</u> <u>full</u> <u>deep</u> <u>path</u> <u>to</u> <u>yaws</u> <u>file</u>
                 <u>cont,</u>           <u>%</u> <u>Continuation</u> <u>for</u> <u>chunked</u> <u>multipart</u> <u>uploads</u>
                 <u>state,</u>          <u>%</u> <u>State</u> <u>for</u> <u>use</u> <u>by</u> <u>users</u> <u>of</u> <u>the</u> <u>out/1</u> <u>callback</u>
                 <u>pid,</u>            <u>%</u> <u>pid</u> <u>of</u> <u>the</u> <u>yaws</u> <u>worker</u> <u>process</u>
                 <u>opaque,</u>         <u>%</u> <u>useful</u> <u>to</u> <u>pass</u> <u>static</u> <u>data</u>
                 <u>appmod_prepath,</u> <u>%</u> <u>(deprecated</u> <u>-</u> <u>use</u> <u>prepath</u> <u>instead)</u> <u>path</u> <u>in</u> <u>front</u>
                                 <u>%</u>  <u>of:</u> <u>&lt;appmod&gt;&lt;appmoddata&gt;</u>
                 <u>prepath,</u>        <u>%</u> <u>Path</u> <u>prior</u> <u>to</u> <u>'dynamic'</u> <u>segment</u> <u>of</u> <u>URI.</u>
                                 <u>%</u>  <u>ie</u> <u><a href="http://some.host/">http://some.host/</a>&lt;prepath&gt;/&lt;script-point&gt;/d/e</u>
                                 <u>%</u> <u>where</u> <u>&lt;script-point&gt;</u> <u>is</u> <u>an</u> <u>appmod</u> <u>mount</u> <u>point,</u>
                                 <u>%</u> <u>or</u> <u>.yaws,.php,.cgi,.fcgi</u> <u>etc</u> <u>script</u> <u>file.</u>
                 <u>pathinfo,</u>       <u>%</u> <u>Set</u> <u>to</u> <u>'/d/e'</u> <u>when</u> <u>calling</u> <u>c.yaws</u> <u>for</u> <u>the</u> <u>request</u>
                                 <u>%</u> <u><a href="http://some.host/a/b/c.yaws/d/e">http://some.host/a/b/c.yaws/d/e</a></u>
                                 <u>%</u>  <u>equiv</u> <u>of</u> <u>cgi</u> <u>PATH_INFO</u>
                 <u>appmod_name</u>     <u>%</u> <u>name</u> <u>of</u> <u>the</u> <u>appmod</u> <u>handling</u> <u>a</u> <u>request,</u>
                                 <u>%</u> <u>or</u> <u>undefined</u> <u>if</u> <u>not</u> <u>applicable</u>
                <u>}).</u>

       The headers argument is also a record:

       <u>-record(headers,</u> <u>{</u>
                 <u>connection,</u>
                 <u>accept,</u>
                 <u>host,</u>
                 <u>if_modified_since,</u>
                 <u>if_match,</u>
                 <u>if_none_match,</u>
                 <u>if_range,</u>
                 <u>if_unmodified_since,</u>
                 <u>range,</u>
                 <u>referer,</u>
                 <u>user_agent,</u>
                 <u>accept_ranges,</u>
                 <u>cookie</u> <u>=</u> <u>[],</u>
                 <u>keep_alive,</u>
                 <u>location,</u>
                 <u>content_length,</u>
                 <u>content_type,</u>
                 <u>content_encoding,</u>
                 <u>authorization,</u>
                 <u>transfer_encoding,</u>
                 <u>x_forwarded_for,</u>
                 <u>other</u> <u>=</u> <u>[]</u>   <u>%</u> <u>misc</u> <u>other</u> <u>headers</u>
                <u>}).</u>

       The <b>out/1</b> function can use the Arg to generate any content it likes. We have the following  functions  to
       aid that generation.

</pre><h4><b>API</b></h4><pre>
       <b>ssi(DocRoot,</b> <b>ListOfFiles)</b>
              Server  side  include.  Just include the files as is in the document. The files will <b>not</b> be parsed
              and searched for &lt;erl&gt; tags.

       <b>pre_ssi_files(DocRoot,</b> <b>ListOfFiles)</b> <b>-&gt;</b>
              Server side include of pre-indented code.  The data in Files will be included but contained  in  a
              &lt;pre&gt; tag. The data will be htmlized.

       <b>pre_ssi_string(String)</b>
              Include htmlized content from String.

       <b>f(Fmt,</b> <b>Args)</b>
              The  equivalent  of  io_lib:format/2.  This function is automatically -included in all erlang code
              which is a part of a yaws page.

       <b>htmlize(Binary</b> <b>|</b> <b>List</b> <b>|</b> <b>Char)</b>
              Htmlize an IO list object.

       <b>set_cookie(Name,</b> <b>Value,</b> <b>Options])</b>
              Sets a cookie to the browser. Options are:

              <u>{expires,</u> <u>UtcTime}</u>  <u>-</u> <u>Cookie</u> <u>expiration</u> <u>time,</u> <u>where</u> <u>UtcTime</u> <u>is</u>
                                    <u>a</u> <u>tuple</u> <u>returned</u> <u>by</u> <u>calendar:universal_time/0.</u>
              <u>{max_age,</u> <u>Age}</u>      <u>-</u> <u>Defines</u> <u>the</u> <u>lifetime</u> <u>of</u> <u>the</u> <u>cookie,</u> <u>in</u> <u>seconds,</u>
                                    <u>where</u> <u>age</u> <u>is</u> <u>an</u> <u>integer</u> <u>&gt;=</u> <u>0.</u>
              <u>{path,</u> <u>Path}</u>        <u>-</u> <u>Path</u> <u>is</u> <u>a</u> <u>string</u> <u>that</u> <u>specifies</u> <u>the</u> <u>subset</u> <u>of</u> <u>URLs</u> <u>to</u>
                                    <u>which</u> <u>this</u> <u>cookie</u> <u>applies.</u>
              <u>{domain,</u> <u>Domain}</u>    <u>-</u> <u>Domain</u> <u>is</u> <u>a</u> <u>string</u> <u>that</u> <u>specifies</u> <u>the</u> <u>domain</u> <u>for</u> <u>which</u>
                                    <u>the</u> <u>cookie</u> <u>is</u> <u>valid.</u>
              <u>{same_site,</u> <u>Policy}</u> <u>-</u> <u>Policy</u> <u>is</u> <u>one</u> <u>of</u> <u>the</u> <u>atoms</u> <u>lax,</u> <u>none</u> <u>or</u> <u>strict.</u>
              <u>{comment,</u> <u>Comment}</u>  <u>-</u> <u>Comment</u> <u>is</u> <u>a</u> <u>string</u> <u>that</u> <u>doccuments</u> <u>the</u> <u>server's</u>
                                    <u>intended</u> <u>use</u> <u>of</u> <u>the</u> <u>cookie.</u>
              <u>secure</u>              <u>-</u> <u>Directs</u> <u>the</u> <u>user</u> <u>agent</u> <u>to</u> <u>use</u> <u>only</u> <u>secure</u> <u>means</u> <u>to</u>
                                    <u>contact</u> <u>the</u> <u>origin</u> <u>server</u> <u>whenever</u> <u>it</u> <u>sends</u> <u>back</u> <u>this</u>
                                    <u>cookie.</u>
              <u>http_only</u>           <u>-</u> <u>Restricts</u> <u>cookie</u> <u>access</u> <u>from</u> <u>other</u> <u>non-HTTP</u> <u>APIs.</u>

       <b>setcookie(Name,</b> <b>Value,</b> <b>[Path,</b> <b>[</b> <b>Expire,</b> <b>[Domain</b> <b>,</b> <b>[Secure]]]])</b>
              Sets a cookie to the browser. This function is deprecated by set_cookie/3.

       <b>find_cookie_val(Cookie,</b> <b>Header)</b>
              This function can be used to search for a cookie that was previously  set  by  <b>setcookie/2-6</b>.  For
              example if we set a cookie as <b>yaws_api:setcookie("sid",SomeRandomSid)</b>, then on subsequent requests
              from the browser we can call: <b>find_cookie("sid",(Arg#arg.headers)#headers.cookie)</b>

              The  function  returns  []  if  no  cookie was found, otherwise the actual cookie is returned as a
              string.

       <b>parse_set_cookie(Str)</b>
              This function parses the value of a <b>Set-Cookie</b> header, following the  RFC6265.  Because  old  RFCs
              (2109 and 2965) are still used, it is backward compatible. So this function returns a <u>#setcookie{}</u>
              record  when  only one cookie is found. If multiple cookies are set in a single <b>Set-Cookie</b> header,
              it returns a list of <u>#setcookie{}</u> records. If no cookie was found or  if  an  error  occurred,  it
              returns [].

              <u>#setcookie{}</u> record is defined in <u>yaws_api.hrl</u>:

              <u>-record(setcookie,</u> <u>{key,</u>
                                  <u>value,</u>
                                  <u>quoted</u> <u>=</u> <u>false,</u>
                                  <u>domain,</u>
                                  <u>max_age,</u>
                                  <u>expires,</u>
                                  <u>path,</u>
                                  <u>secure</u> <u>=</u> <u>false,</u>
                                  <u>http_only</u> <u>=</u> <u>false,</u>
                                  <u>extensions</u> <u>=</u> <u>[]}).</u>

       <b>parse_cookie(Str)</b>
              This  function  parses  the  value  of  <b>Cookie</b> header, following the RFC6265. It returns a list of
              <u>#cookie{}</u> records. If no cookie was found or if an error occurred, it returns [].

              <u>#cookie{}</u> record is defined in <u>yaws_api.hrl</u>:

              <u>-record(cookie,</u> <u>{key,</u>
                               <u>value,</u>
                               <u>quoted</u> <u>=</u> <u>false}).</u>

       <b>format_set_cookie(SetCookie)</b>
              Build a cookie string from a <u>#setcookie{}</u> record like returned by <b>parse_set_cookie/1</b>.

       <b>format_cookie(Cookie</b> <b>|</b> <b>[Cookie])</b>
              Build a cookie  string  from  a  <u>#cookie{}</u>  record  (or  a  list  or  records)  like  returned  by
              <b>parse_cookie/1</b>.

       <b>redirect(Url)</b>
              This  function  generates a redirect to the browser.  It will clear any previously set headers. So
              to generate a redirect <b>and</b> set a cookie, we need to set the cookie after the redirect as in:
              <u>out(Arg)</u> <u>-&gt;</u>
                <u>...</u> <u>do</u> <u>some</u> <u>stuff</u>

                <u>Ret</u> <u>=</u> <u>[{redirect,</u> <u>"<a href="http://www.somewhere.com">http://www.somewhere.com</a>"},</u>
                        <u>setcookie("sid",</u> <u>Random)</u>
                      <u>].</u>

       <b>redirect_self(Arg)</b>
              If we want to issue a redirect to  ourselves,  this  function  is  useful.  It  returns  a  record
              <u>#redir_self{}</u> defined in <u>yaws_api.hrl</u>. The record contains fields to construct a URL to ourselves.

              <u>-record(redir_self,</u> <u>{</u>
                        <u>host,</u>        <u>%</u> <u>string()</u> <u>-</u> <u>our</u> <u>own</u> <u>host</u>
                        <u>scheme,</u>      <u>%</u> <u>http</u> <u>|</u> <u>https</u>
                        <u>scheme_str,</u>  <u>%</u> <u>"https://"</u>  <u>|</u> <u>"http://"</u>
                        <u>port,</u>        <u>%</u> <u>integer()</u>  <u>-</u> <u>our</u> <u>own</u> <u>port</u>
                        <u>port_str</u>     <u>%</u> <u>""</u> <u>|</u> <u>":&lt;int&gt;"</u> <u>-</u> <u>the</u> <u>optional</u> <u>port</u> <u>part</u>
                                     <u>%</u>                 <u>to</u> <u>append</u> <u>to</u> <u>the</u> <u>url</u>
                       <u>}).</u>

       <b>get_line(String)</b>
              This function is convenient when getting \r\n terminated lines from a stream of data. It returns:

              <b>{line,</b> <b>Line,</b> <b>Tail}</b> or <b>{lastline,</b> <b>Line,</b> <b>Tail}</b>

              The function handles multilines as defined in e.g. SMTP or HTTP

       <b>mime_type(Scope,</b> <b>FileName)</b>
              Returns the MIME type as defined by the extension of <u>FileName</u>. <u>Scope</u> can have following values:

                   <b>global</b> - returns the result obtained from the global context.
                   <b>#sconf{}</b>  <b>|</b>  <b>{ServerName,</b>  <b>Port}</b>  -  returns  the  result  obtained from the virtual server's
                   context. If no MIME type is found in this scope, it falls back on the global one.

       <b>mime_type(FileName)</b>
              Tries to determine the right <u>Scope</u> before calling mime_type/2.

       <b>stream_chunk_deliver(YawsPid,</b> <b>Data)</b>
              When a yaws function needs to deliver chunks of data which it  gets  from  a  process.  The  other
              process  can  call this function to deliver these chunks. It requires the <b>out/1</b> function to return
              the value <b>{streamcontent,</b> <b>MimeType,</b> <b>FirstChunk}</b> to work.  YawsPid is the process identifier of the
              yaws process delivering the original .yaws file. That is self() in the yaws code.   The  Pid  must
              typically be passed (somehow) to the producer of the stream.

       <b>stream_chunk_deliver_blocking(YawsPid,</b> <b>Data)</b>
              A synchronous version of the above function. This synchronous version must always be used when the
              producer  of  the stream is faster than the consumer. This is usually the case since the client is
              the WWW browser.

       <b>stream_chunk_end(YawsPid)</b>
              When the process discussed above is done delivering data, it must call this function  to  let  the
              yaws content delivering process finish up the HTTP transaction.

       <b>stream_process_deliver(Socket,</b> <b>IoList)</b>
              Yaws  allows  application  processes to deliver data directly to the client. The application tells
              yaws about such a process by returning <b>{streamcontent_from_pid,</b>  <b>MimeType,</b>  <b>Pid}</b>  from  its  <b>out/1</b>
              function.  In  this  case,  <u>Pid</u>  uses the <b>stream_process_deliver/2</b> function to deliver data to the
              client. The application gets <u>Socket</u> from <u>Arg#arg.clisock</u>, and <u>IoList</u> is the data to be sent to the
              client.

       <b>stream_process_deliver_chunk(Socket,</b> <b>IoList)</b>
              Same as above but delivers <u>IoList</u> using HTTP chunked transfer format.  <u>IoList</u>  must  have  a  size
              greater  than  zero.  The  application process delivering the data will have had to have make sure
              that the HTTP headers of the response indicate  chunked  transfer  mode,  either  by  ensuring  no
              Content-Length header is set or by specifically setting the Transfer-Encoding header to chunked.

       <b>stream_process_deliver_final_chunk(Socket,</b> <b>IoList)</b>
              If  the application process delivering data to the client uses chunked transfer mode, it must call
              this to deliver the final chunk of the transfer. This tells yaws to create a special  final  chunk
              in  the format required by the HTTP specification (RFC 2616). <u>IoList</u> may be empty, but if its size
              is greater than zero, that data will be sent as a separate chunk before the final chunk.

       <b>stream_process_end(Socket,</b> <b>YawsPid)</b>
              Application processes delivering data directly to clients must call this function to  inform  yaws
              that  they've  finished  using  <u>Socket</u>.  The <u>YawsPid</u> argument will have been passed to the process
              earlier when yaws sent it a message telling it to proceed with data delivery. Yaws expects  <u>Socket</u>
              to be open.

       <b>stream_process_end(closed,</b> <b>YawsPid)</b>
              Same  as  the  previous  function but the application calls this if it closes the client socket as
              part of its data delivery process. This allows yaws to continue without  assuming  the  socket  is
              still  open  and  encountering  errors due to that assumption. The <u>YawsPid</u> argument will have been
              passed to the application process earlier when yaws sent it a message telling it to  proceed  with
              data delivery.

       <b>parse_query(Arg)</b>
              This function will parse the query part of the URL. It will return a {Key, Value} list.

       <b>queryvar(Arg,</b> <b>VarName)</b>
              This function is automatically included from yaws_api in all .yaws pages. It is used to search for
              a  variable  in the querypart of the url. Returns {ok, Val} or undefined. If a variable is defined
              multiple times, the function may also return <u>{Val1,</u> <u>Val2...}</u>.

       <b>parse_post(Arg)</b>
              If the browser has set the Content-Type header to the  value  "application/x-www-form-urlencoded",
              this function will parse the request's body. It will return a {Key, Value} list.

       <b>postvar(Arg,</b> <b>VarName)</b>
              This function is automatically included from yaws_api in all .yaws pages. It is used to search for
              a variable in the request's body sent by the client. Returns {ok, Val} or undefined. If a variable
              is defined multiple times, the function may also return <u>{Val1,</u> <u>Val2...}</u>.

       <b>getvar(Arg,</b> <b>VarName)</b>
              This function is used to search a variable in the query part of the URL and in the request's body.
              it invokes queryvar/2 and postvar/2 and merges the results.

       <b>parse_multipart_post(Arg)</b>
              If  the  browser  has set the Content-Type header to the value "multipart/form-data", which is the
              case when the browser wants to upload a file to the server the following happens:

              If the function returns <b>{result,</b> <b>Res}</b> no more data will come from the browser.

              If the function returns <b>{cont,</b> <b>Cont,</b> <b>Res}</b> the browser will supply more data. (The file was too big
              to come in one read)

              This indicates that there is more data to come and the out/1  function  should  return  {get_more,
              Cont,  User_state}  where User_state might usefully be a File Descriptor.  The Res value is a list
              of either: <b>{head,</b> <b>{Name,</b> <b>Headers}}</b> | <b>{part_body,</b> <b>Binary}</b> | <b>{body,</b> <b>Binary}</b>

              The function returns <b>{error,</b> <b>Reason}</b> when an error occurred during the parsing.

              Example usage could be:
               <u>&lt;erl&gt;</u>

               <u>out(A)</u> <u>-&gt;</u>
                      <u>case</u> <u>yaws_api:parse_multipart_post(A)</u> <u>of</u>
                           <u>{cont,</u> <u>Cont,</u> <u>Res}</u> <u>-&gt;</u>
                                  <u>St</u> <u>=</u> <u>handle_res(A,</u> <u>Res),</u>
                                  <u>{get_more,</u> <u>Cont,</u> <u>St};</u>
                           <u>{result,</u> <u>Res}</u> <u>-&gt;</u>
                                  <u>handle_res(A,</u> <u>Res),</u>
                                  <u>{html,</u> <u>f("&lt;pre&gt;Done</u> <u>&lt;/pre&gt;",[])};</u>
                           <u>{error,</u> <u>Reason}</u> <u>-&gt;</u>
                                  <u>{html,</u> <u>f("An</u> <u>error</u> <u>occured:</u> <u>~p",</u> <u>[Reason])}</u>
                      <u>end.</u>

               <u>handle_res(A,</u> <u>[{head,</u> <u>{Name,</u> <b>_</b><u>Hdrs}}|T])</u> <u>-&gt;</u>
                    <u>io:format("head:~p~n",[Name]),</u>
                    <u>handle_res(A,</u> <u>T);</u>
               <u>handle_res(A,</u> <u>[{part_body,</u> <u>Data}|T])</u> <u>-&gt;</u>
                    <u>io:format("part_body:~p~n",[Data]),</u>
                    <u>handle_res(A,</u> <u>T);</u>
               <u>handle_res(A,</u> <u>[{body,</u> <u>Data}|T])</u> <u>-&gt;</u>
                    <u>io:format("body:~p~n",[Data]),</u>
                    <u>handle_res(A,</u> <u>T);</u>
               <u>handle_res(A,</u> <u>[])</u> <u>-&gt;</u>
                    <u>io:format("End_res~n").</u>

               <u>&lt;/erl&gt;</u>

       <b>new_cookie_session(Opaque)</b>
              Create a new cookie-based  session.  Yaws  will  either  generate  the  cookie  itself  or,  if  a
              <u>ysession_cookiegen</u> module is configured, call <u>new_cookie()</u> on that module to get a new cookie. The
              new  cookie  is  returned from this function. The <u>Opaque</u> argument will typically contain user data
              such as user name and password

       <b>new_cookie_session(Opaque,</b> <b>TTL)</b>
              As above, but allows to set a session specific time-out value,  overriding  the  system  specified
              time-out value.

       <b>new_cookie_session(Opaque,</b> <b>TTL,</b> <b>CleanupPid)</b>
              As  above,  but  also  sends  a message <u>{yaws_session_end,</u> <u>Reason,</u> <u>Cookie,</u> <u>Opaque}</u> to the provided
              <u>CleanupPid</u> where Reason can be either of <u>timeout</u> or <u>normal</u>. The  <u>Cookie</u>  is  the  HTTP  cookie  as
              returned  by <u>new_session()</u> and <u>Opaque</u> is the user-provided <u>Opaque</u> parameter to <u>new_session()</u>.  The
              purpose of the feature is to cleanup resources assigned to the session.

       <b>cookieval_to_opaque(CookieVal)</b>

       <b>print_cookie_sessions()</b>

       <b>replace_cookie_session(Cookie,</b> <b>NewOpaque)</b>

       <b>delete_cookie_session(Cookie)</b>

       <b>setconf(Gconf,</b> <b>Groups)</b>
              This function is intended for embedded mode  in  yaws.  It  makes  it  possible  to  load  a  yaws
              configuration  from  another  data  source  than  /etc/yaws.conf,  such as a database.  If yaws is
              started  with  the  environment  <u>{embedded,</u>  <u>true}</u>,  yaws  will  start  with  an   empty   default
              configuration,  and  wait  for  some  other program to execute a <u>setconf/2</u> The Gconf is a <u>#gconf{}</u>
              record and the Group variable is a list of lists of <u>#sconf{}</u> records. Each  sublist  must  contain
              <u>#sconf{}</u>  records  with  the  same  IP/Port listen address.  To create a suitable initial #gconf{}
              record see the code in yaws_config:make_default_gconf/2.  Especially  the  <u>yaws_dir</u>  parameter  is
              important to get right.

       <b>url_decode(Str)</b>
              Decode  url-encoded string. A URL encoded string is a string where all alfa numeric characters and
              the the character _ are preserved and all other characters are encode as "%XY" where X and  Y  are
              the hex values of the least respective most significant 4 bits in the 8 bit character.

       <b>url_encode(URL)</b>
              URL-encodes  a  string  or  binary,  and  returns a string. All URLs in HTML documents must be URL
              encoded.

       <b>get_sslsocket(Socket)</b>
              Returns a socket  for  SSL  sockets  or  the  atom  <u>undefined</u>  for  non-SSL  sockets.  Useful  for
              applications that have to deal with both SSL and non-SSL sockets.

       <b>get_listen_port(Sconf)</b>
              Return  the  actual  port  number used by the listen socket of the virtual server indicated by the
              function argument, an <u>#sconf{}</u> record instance. If successful, returns the requested port  number,
              or  returns  <u>{error,</u>  <u>not_found}</u> if the function argument does not match any known virtual server.
              This function is useful for retrieving the actual port number when, e.g. for testing  purposes,  a
              virtual server is configured to use port 0, which will cause it to have an ephemeral port assigned
              by the operating system.

       <b>reformat_header(H)</b>
              Returns  a list of reformatted header values from a #headers{} record. The return list is suitable
              for retransmit.

       <b>reformat_header(H,</b> <b>FormatFun)</b>
              Returns a list of reformatted header values from a #headers{} record, with  each  element  of  the
              list  formatted  via  a call to <u>FormatFun</u>. This enables converting #headers{} records into various
              lists of headers and their values. Note that sometimes the <u>Set-Cookie</u> header or other headers will
              contain a tuple value of the form <u>{multi,</u> <u>ValueList}</u>. (The <u>{multi,</u> <u>ValueList}</u> construct  typically
              results  from calls to <u>merge_header/2</u> or <u>merge_header/3</u>, where multiple values are set in separate
              calls for the same header; see <u>merge_header/2</u> below for  details.)   Formatting  functions  should
              therefore  be  capable of handling a <u>{multi,</u> <u>ValueList}</u> tuple. They should handle it by formatting
              each member of <u>ValueList</u> as a separate header string, storing all such header strings in  a  list,
              and  returning  that  list  in  a  <u>{multi,</u> <u>HdrList}</u> tuple. Note that in versions of Yaws 2.0.6 and
              older, formatting functions returned such header lists directly, which implies that sometimes  the
              return  values of <u>reformat_header/1</u> and <u>reformat_header/2</u> can be a multi-level list if constructed
              by one of these older formatting functions.

       <b>reformat_header(H,</b> <b>FormatFun,</b> <b>Options)</b>
              Same as <u>reformat_header/2</u> except that  header  and  value  data  passed  to  <u>FormatFun</u>  are  first
              converted  to  the data format specified in <u>Options</u>. <u>Options</u> is expected to be either an atom or a
              list of atoms, either <u>string</u> or <u>binary</u>. If the list contains multiple items,  options  earlier  in
              the  list  override  those  later  in  the  list,  so  for example <u>[string,</u> <u>binary]</u> is the same as
              <u>[string]</u>. If the first item in <u>Options</u> specifies anything other than <u>string</u> or  <u>binary</u>,  data  are
              passed to <u>FormatFun</u> without conversion.

       <b>set_header(Headers,</b> <b>{Header,</b> <b>Value})</b>
              Sets header <u>Header</u> with value <u>Value</u> in the #headers{} record <u>Headers</u>, and returns a new #headers{}
              record.   Using   the   atom   <u>undefined</u>  for  <u>Value</u>  effectively  deletes  the  header,  same  as
              <u>delete_header/2</u>.

       <b>set_header(Headers,</b> <b>Header,</b> <b>Value)</b>
              Same as <u>set_header/2</u> above, except <u>Header</u> and <u>Value</u> are not passed in a tuple.

       <b>merge_header(Headers,</b> <b>{Header,</b> <b>Value})</b>
              Merges value <u>Value</u> for header <u>Header</u> with any existing value for that  header  in  the  #headers{}
              record  <u>Headers</u>,  and  returns  a new #headers{} record. Using the atom <u>undefined</u> for <u>Value</u> simply
              returns <u>Headers</u>. Otherwise, <u>Value</u> is merged with any existing value already present in the <u>Headers</u>
              record for header <u>Header</u>, comma-separated from that existing value. If no such value exists in the
              <u>Headers</u> record, the effect is the same as <u>set_header/2</u>.  Note  that  for  the  <u>Set-Cookie</u>  header,
              values  are  not  comma-separated  but are instead collected into a tuple <u>{multi,</u> <u>ValueList}</u> where
              <u>ValueList</u> is the collection of <u>Set-Cookie</u> values. This implies that any formatting fun  passed  to
              <u>reformat_header/2</u> must be prepared to handle such tuples.

       <b>merge_header(Headers,</b> <b>Header,</b> <b>Value)</b>
              Same as <u>merge_header/2</u> above, except <u>Header</u> and <u>Value</u> are not passed in a tuple.

       <b>get_header(Headers,</b> <b>Header)</b>
              Gets  the  value of header <u>Header</u> from the #headers{} record <u>Headers</u> and returns it. If the header
              isn't set, the atom <u>undefined</u> is returned.

       <b>delete_header(Headers,</b> <b>Header)</b>
              Deletes any value set for header <u>Header</u> in the  #headers{}  record  <u>Headers</u>,  and  returns  a  new
              #headers{} record.

       <b>request_url(ARG)</b>
              Return  the  url  as  requested  by  the  client.  Return  value  is a #url{} record as defined in
              yaws_api.hrl

       <b>parse_url(Str)</b>
              Parse URL in a string, returns a #url record

       <b>format_url(UrlRecord)</b>
              Takes a #url record a formats the Url as a string

       <b>call_cgi(Arg,</b> <b>Scriptfilename)</b>
              Calls an executable CGI script, given by its full path.  Used to make  `.yaws'  wrappers  for  CGI
              programs.  This function usually returns <u>streamcontent</u>.

       <b>call_cgi(Arg,</b> <b>Exefilename,</b> <b>Scriptfilename)</b>
              Like before, but calls <u>Exefilename</u> to handle the script.  The file name of the script is handed to
              the executable via a CGI meta variable.

       <b>call_fcgi_responder(Arg)</b>
              Calls  a FastCGI responder.  The address and port of the FastCGI application server are taken from
              the server configuration (see yaws.conf).  Used to make `.yaws' wrappers for  FastCGI  responders.
              Returns the same return values as out/1 (see below).

       <b>call_fcgi_responder(Arg,</b> <b>Options)</b>
              Same as above, but Options overrides the defaults from the server configuration:

              <u>Options</u> <u>=</u> <u>[Option]</u>
              <u>Option</u> <u>--</u> <u>one</u> <u>of</u> <u>the</u> <u>following:</u>

              <b>{app_server_host,</b>  <b>string()</b>  <b>|</b>  <b>ip_address()}</b>  The  hostname  or  the  IP  address  of the FastCGI
              application server.

              <b>{app_server_port,</b> <b>0..65535}</b> The TCP port number of the FastCGI application server.

              <b>{path_info,</b> <b>string()}</b> Override default pathinfo in Arg#arg.pathinfo.

              <b>{extra_env,</b> <b>ExtraEnv}</b> Extra environment variables to be passed to the FastCGI application  server,
              as a list of name-value pairs.

              <u>ExtraEnv</u> <u>=</u> <u>[Var]</u>
              <u>Var</u> <u>=</u> <u>{Name,</u> <u>Value}</u>
              <u>Name</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>
              <u>Value</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>

              <b>{trace_protocol,</b>  <b>boolean()}</b>  Enable  or  disable tracing of FastCGI protocol messages as info log
              messages.

              <b>{log_app_error,</b> <b>boolean()}</b> Enable or disable logging of  application  error  messages:  output  to
              stderr and non-zero exit value.

       <b>call_fcgi_authorizer(Arg)</b> <b>-&gt;</b> <b>{allowed,</b> <b>Out}</b> <b>|</b> <b>{denied,</b> <b>Out}</b>
              Calls a FastCGI authorizer.  The address and port of the FastCGI application server are taken from
              the  server configuration (see yaws.conf).  Used to make `.yaws' wrappers for FastCGI authorizers.
              Variables contains the values of the variables returned by the FastCGI application server  in  the
              "Variable-XXX: YYY" headers.

              If  access  is  denied,  Out  contains  the  complete response returned by the FastCGI application
              server. This response is typically returned as-is to the HTTP client.

              If access is allowed, Out contains the response returned by the FastCGI application  server  minus
              the  body  (i.e.  minus  the  content) which should be ignored per the FastCGI specification. This
              response is typically not returned to the HTTP client. The calling application module may wish  to
              inspect the response, for example by extracting variables (see fcgi_extract_variables below) or by
              inspecting the headers returned by the FastCGI application server.

              <u>Out</u> <u>--</u> <u>See</u> <u>return</u> <u>values</u> <u>for</u> <u>out/1</u> <u>below</u>

       <b>call_fcgi_authorizer(Arg,</b> <b>Options)</b> <b>-&gt;</b> <b>{allowed,</b> <b>Out}</b> <b>|</b> <b>{denied,</b> <b>Out}</b>
              Same   as   above,  but  Options  overrides  the  defaults  from  the  server  configuration.  See
              call_fcgi_responder/2 above for a description of Options.

       <b>fcgi_extract_variables(Out)</b> <b>-&gt;</b> <b>[{Name,</b> <b>Value}]</b>
              Extracts the environment variables from a FastCGI authorizer response by looking  for  headers  of
              the form "Variable-Name: Value".

              <u>Name</u> <u>=</u> <u>string()</u> <u>--</u> <u>The</u> <u>name</u> <u>of</u> <u>the</u> <u>variable</u> <u>(the</u> <u>"Variable-"</u> <u>prefix</u>
              <u>has</u> <u>already</u> <u>been</u> <u>removed).</u>
              <u>Value</u> <u>=</u> <u>string()</u> <u>--</u> <u>The</u> <u>value</u> <u>of</u> <u>the</u> <u>variable.</u>

       <b>dir_listing(Arg)</b>
              Perform  a directory listing. Can be used in special directories when we don't want to turn on dir
              listings for the entire server.  Always returns ok.

</pre><h4><b>RETURN</b> <b>VALUES</b> <b>from</b> <b>out/1</b></h4><pre>
       The out/1 function can return different values to control the behavior of the server.

       <b>{html,</b> <b>DeepList}</b>
              This assumes that DeepList is formatted HTML code.  The code will be inserted in the page.

       <b>{ehtml|exhtml,</b> <b>Term}</b>
              This will transform the erlang term Term into  a  stream  of  HTML  content.  The  exhtml  variant
              transforms into strict XHTML code. The basic syntax of Term is

              <u>EHTML</u> <u>=</u> <u>[EHTML]</u> <u>|</u> <u>{Tag,</u> <u>Attrs,</u> <u>Body}</u> <u>|</u> <u>{Tag,</u> <u>Attrs}</u> <u>|</u> <u>{Tag}</u> <u>|</u>
                      <u>{Module,</u> <u>Fun,</u> <u>[Args]}</u> <u>|</u> <u>fun/0</u> <u>|</u>
                      <u>binary()</u> <u>|</u> <u>character()</u>
              <u>Tag</u>   <u>=</u> <u>atom()</u>
              <u>Attrs</u> <u>=</u> <u>[{Key,</u> <u>Value}]</u>
              <u>Key</u>   <u>=</u> <u>atom()</u>
              <u>Value</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u> <u>|</u> <u>atom()</u> <u>|</u> <u>integer()</u> <u>|</u> <u>float()</u> <u>|</u>
                      <u>{Module,</u> <u>Fun,</u> <u>[Args]}</u> <u>|</u> <u>fun/0</u>
              <u>Body</u>  <u>=</u> <u>EHTML</u>

              For example, <u>{p,</u> <u>[],</u> <u>"Howdy"}</u> expands into "&lt;p&gt;Howdy&lt;/p&gt;" and

              <u>{form,</u> <u>[{action,</u> <u>"a.yaws"}],</u>
                 <u>{input,</u> <u>[{type,text}]}}</u>

              expands into

              <u>&lt;form</u> <u>action="a.yaws"</u>
                <u>&lt;input</u> <u>type="text"&gt;</u>
              <u>&lt;/form&gt;</u>

              It may be more convenient to generate erlang tuples than plain html code.

       <b>{content,</b> <b>MimeType,</b> <b>Content}</b>
              This  function will make the web server generate different content than HTML. This return value is
              only allowed in a yaws file which has only one &lt;erl&gt; &lt;/erl&gt; part and no html parts at all.

       <b>{streamcontent,</b> <b>MimeType,</b> <b>FirstChunk}</b>
              This return value plays the same role as the <u>content</u> return value above.

              However it makes it possible to stream data to the client if the yaws code doesn't have access  to
              all  the  data  in  one  go.  (Typically  if a file is very large or if data arrives from back end
              servers on the network.

       <b>{streamcontent_with_timeout,</b> <b>MimeType,</b> <b>FirstChunk,</b> <b>Timeout}</b>
              Similar to above, but with an explicit timeout. The  default  timeout  is  30  secs.  I.e  if  the
              application  fails to deliver data to the Yaws process, the streaming will stop. This is often not
              the desired behaviour in Comet/Ajax applications.  It's possible to provide 'infinity' as timeout.

       <b>{streamcontent_from_pid,</b> <b>MimeType,</b> <b>Pid}</b>
              This return value is similar to the <u>streamcontent</u> return value above.

              However it makes it possible to stream data to the client directly from an application process  to
              the  socket.  This  approach  can  be  useful  for  applications  that employ long-polling (Comet)
              techniques, for example, and for applications wanting  to  avoid  buffering  data  or  avoid  HTTP
              chunked mode transfer for streamed data.

       <b>{streamcontent_with_size,</b> <b>Sz,</b> <b>MimeType,</b> <b>FirstChunk}</b>
              This return value is similar to the <u>streamcontent</u> return value above.

              However  it  makes  it  possible to stream data to the client by setting the content length of the
              response. As the opposite of other ways to stream data, in this case, the response is not  chunked
              encoded.

       <b>{header,</b> <b>H}</b>
              Accumulates a HTTP header. The trailing CRNL which is supposed to end all HTTP headers must NOT be
              added. It is added by the server.  The following list of headers are given special treatment.

              <u>{connection,</u> <u>What}</u>

              This  sets  the  Connection:  header. If <u>What</u> is the special value <u>"close"</u>, the connection will be
              closed once the yaws page is delivered to the client.

              <u>{server,</u> <u>What}</u>

              Sets the Server: header. By setting this  header,  the  server's  signature  will  be  dynamically
              overloaded.

              <u>{location,</u> <u>Url}</u>

              Sets the Location: header. This header is typically combined with the <u>{status,</u> <u>302}</u> return value.

              <u>{cache_control,</u> <u>What}</u>

              Sets the Cache-Control: header.

              <u>{expires,</u> <u>What}</u>

              Sets the Expires: header.

              <u>{date,</u> <u>What}</u>

              Sets the Date: header.

              <u>{allow,</u> <u>What}</u>

              Sets the Allow: header.

              <u>{last_modified,</u> <u>What}</u>

              Sets the Last-Modified: header.

              <u>{etag,</u> <u>What}</u>

              Sets the Etag: header.

              <u>{set_cookie,</u> <u>Cookie}</u>

              Prepends a Set-Cookie: header to the list of previously set Set-Cookie: headers.

              <u>{content_range,</u> <u>What}</u>

              Sets the Content-Range: header.

              <u>{content_type,</u> <u>MimeType}</u>

              Sets the Content-Type: header.

              <u>{content_encoding,</u> <u>What}</u>

              Sets  the  Content-Encoding:  header.  If this header is defined, no deflate is performed by Yaws,
              allowing you to compress data yourself if you wish to do so.

              <u>{content_length,</u> <u>Len}</u>

              Normally yaws will ship Yaws pages using Transfer-Encoding: chunked. This is because we  generally
              can't  know  how  long  a yaws page will be. If we for some reason want to force a Content-Length:
              header (and we actually do know the length of the content, we can force Yaws to not ship the  page
              chunked.

              <u>{transfer_encoding,</u> <u>What}</u>

              Sets the Transfer-Encoding: header.

              <u>{www_authenticate,</u> <u>What}</u>

              Sets the WWW-Authenticate: header.

              <u>{vary,</u> <u>What}</u>

              Sets the Vary: header.

              <u>{accept_ranges,</u> <u>What}</u>

              Sets the Accept-Ranges: header.

              All other headers must be added using the normal HTTP syntax.  Example:

              <u>{header,</u> <u>{"My-X-Header",</u> <u>"gadong"}}</u> or <u>{header,</u> <u>"My-X-Header:</u> <u>gadong"}</u>

       <b>{header,</b> <b>{HeaderName,</b> <b>erase}}</b>
              Clears the header named <u>HeaderName</u> from the accumulated headers.

       <b>{allheaders,</b> <b>HeaderList}</b>
              Will clear all previously accumulated headers and replace them.

       <b>{status,</b> <b>Code}</b>
              Will set another HTTP status code than 200.

       <b>break</b>  Will stop processing of any consecutive chunks of erl or html code in the yaws file.

       <b>ok</b>     Do nothing.

       <b>flush</b>  Flush remaining data sent by the client.

       <b>{redirect,</b> <b>Url}</b>
              Erase all previous headers and accumulate a single Location header. Set the status code.

       <b>{redirect_local,</b> <b>Path}</b>
              Does a redirect to the same Scheme://Host:Port/Path as we currently are executing in.

       <b>{get_more,</b> <b>Cont,</b> <b>State}</b>
              When  we  are  receiving  large POSTs we can return this value and be invoked again when more Data
              arrives.

       <b>{page,</b> <b>Page}</b>

              Make Yaws returns a different page than the one being requested. <u>Page</u> is a Request-URI, so it must
              be url-encoded and can contain a query-string.

       <b>{page,</b> <b>{Options,</b> <b>Page}}</b>
              Like the above, but supplying an additional deep list of options. Supported option types are:

              <u>{status,</u> <u>C}</u> - Set the HTTP response status code <u>C</u> for page <u>Page</u>.

              <u>{header,</u> <u>H}</u> - Accumulate the HTTP header <u>H</u> for page <u>Page</u>.

              <u>{disable_cache,</u> <u>Bool}</u> - if set to <u>true</u>, disable the cache of <u>Page</u> for this call.

       <b>{websocket,</b> <b>CallbackModule,</b> <b>Options}</b>
              Tell Yaws to use <u>CallbackModule</u> as a WebSocket Protocol handler for traffic on the client  socket.
              See the Yaws websocket documentation for more details.

       <b>{ssi,</b> <b>File,</b> <b>Delimiter,</b> <b>Bindings}</b>
              Server  side  include  <u>File</u>  and macro expansion in <u>File</u>.  Each occurrence of a string, say "xyz",
              inside <u>File</u> that's within a <u>Delimiter</u> pair is replaced with the corresponding value in <u>Bindings</u>.

              Example: Delimiter = %%

              File contains the string .... %%xyz%%  .....

              Bindings contain the tuple {"xyz", "Dingbat"}

              The occurrence of %%xyz%% in File will be replaced with "Dingbat"  in  the  Server  side  included
              output.

              The {ssi, File, Delimiter, Bindings} statement can also occur within a deep ehtml structure.

              The  special  directive  <u>strip_undefined</u> can be specified in the <u>Bindings</u> list, just as it can for
              the <u>{bindings,</u> <u>....}</u> directive, but it's ignored because treating undefined variables as empty  is
              the default for <u>ssi</u> bindings.

       <b>{bindings,</b> <b>[{Key1,</b> <b>Value2},</b> <b>{Key2,</b> <b>Value2}</b> <b>.....]}</b>
              Establish variable bindings that can be used in the page.

              All  bindings  can then be used in the rest of yaws code (in HTML source and within erl tags).  In
              HTML source %%Key%% is expanded to Value and within erl tags  <u>yaws_api:binding(Key)</u>  (which  calls
              <u>error</u> if no such binding exists) or <u>yaws_api:binding_find(Key)</u> (which returns <u>undefined</u> if no such
              binding  exists)  can  be  used  to extract Value, and <u>yaws_api:binding_exists(Key)</u> can be used to
              check for the existence of a binding.

              If a page happens to contains text that looks like a  binding,  e.g.   %%SomeText%%,  but  no  key
              <u>SomeText</u>  is  supplied,  then  by  default  the  original  text is left as is.  If you prefer that
              anything parsed as a binding gets stripped out of a page whenever the <b>bindings</b> directive does  not
              specify its key, include the special directive <u>strip_undefined</u> in the bindings list:

              {bindings, [{Key1, Value1}, strip_undefined]}

       <b>{yssi,</b> <b>YawsFile}</b>
              Include a yaws file. Compile it and expand as if it had occured inline.

       <b>#arg{}</b> Return  an  instance of an <u>#arg{}</u> record. This can be useful when used as part of a <u>[ListOfValues]</u>
              return value, so that any subsequent elements in the return list that require an  #arg{}  get  the
              returned  instance  rather  than  the original. For example, an <u>out/1</u> function might set the <u>state</u>
              field of an #arg{}, then return both it and <u>{yssi,</u> <u>YawsFile}</u> in a list, in which  case  Yaws  will
              pass the returned #arg{}, rather than the original instance, to the yaws file out/1 function.

       <b>[ListOfValues]</b>
              It  is  possible  to  return  a  deep  list  of the above defined return values. Any occurrence of
              <u>streamcontent</u>,   <u>streamcontent_with_timeout</u>,   <u>streamcontent_with_size</u>,    <u>streamcontent_from_pid</u>,
              <u>get_more</u>, <u>page</u> or <u>break</u> in this list is legal only if it is the last position of the list. If not,
              remaining values in the list are ignored.

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Claes Wikstrom

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/yaws.conf.5.html">yaws.conf</a></b>(5) <b><a href="../man1/erl.1.html">erl</a></b>(1)

                                                                                                     <u><a href="../man5/YAWS_API.5.html">YAWS_API</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>