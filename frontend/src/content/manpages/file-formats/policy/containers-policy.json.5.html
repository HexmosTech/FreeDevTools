<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>containers-policy.json - syntax for the signature verification policy file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/golang-github-containers-image">golang-github-containers-image_5.34.2-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       containers-policy.json - syntax for the signature verification policy file

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Signature  verification  policy  files  are  used  to  specify policy, e.g. trusted keys, applicable when
       deciding whether to accept an image, or individual signatures of that image, as valid.

       By default, the policy is read from <b>$HOME/.config/containers/policy.json</b>, if it  exists,  otherwise  from
       <b>/etc/containers/policy.json</b>;   applications  performing  verification  may allow using a different policy
       instead.

</pre><h4><b>FORMAT</b></h4><pre>
       The signature verification policy file, usually called <b>policy.json</b>, uses  a  JSON  format.   Unlike  some
       other  JSON  files,  its  parsing  is fairly strict: unrecognized, duplicated or otherwise invalid fields
       cause the entire file, and usually the entire operation, to be rejected.

       The purpose of the policy file is to define a set of <u>policy</u> <u>requirements</u> for a container  image,  usually
       depending on its location (where it is being pulled from) or otherwise defined identity.

       Policy requirements can be defined for:

              • An individual <u>scope</u> in a <u>transport</u>.  The <u>transport</u> values are the same as the transport prefixes
                when  pushing/pulling  images  (e.g.  <b>docker:</b>,  <b>atomic:</b>),  and  <u>scope</u> values are defined by each
                transport; see below for more details.

       Usually, a scope can be defined to match a single image, and various prefixes of
         such a most specific scope define namespaces of matching images.

              • A default policy for a single transport, expressed using an empty string as a scope

              • A global default policy.

       If multiple policy requirements match a given image, only the requirements from the most  specific  match
       apply, the more general policy requirements definitions are ignored.

       This is expressed in JSON using the top-level syntax

       {
           "default": [/* policy requirements: global default */]
           "transports": {
               transport_name: {
                   "": [/* policy requirements: default for transport $transport_name */],
                   scope_1: [/* policy requirements: default for $scope_1 in $transport_name */],
                   scope_2: [/*…*/]
                   /*…*/
               },
               transport_name_2: {/*…*/}
               /*…*/
           }
       }

       The  global  <b>default</b> set of policy requirements is mandatory; all of the other fields (<b>transports</b> itself,
       any specific transport, the transport-specific default, etc.) are optional.

</pre><h4><b>Supported</b> <b>transports</b> <b>and</b> <b>their</b> <b>scopes</b></h4><pre>
       See <a href="../man5/containers-transports.5.html">containers-transports</a>(5) for general documentation about the transports and their reference syntax.

   <b>atomic:</b>
       The deprecated <b>atomic:</b> transport refers to images in an Atomic Registry.

       Supported scopes use the form <u>hostname</u>[<b>:</b><u>port</u>][<b>/</b><u>namespace</u>[<b>/</b><u>imagestream</u> [<b>:</b><u>tag</u>]]], i.e. either specifying  a
       complete  name  of  a  tagged  image,  or  prefix denoting a host/namespace/image stream, or a wildcarded
       expression starting with <b>*.</b> for matching all subdomains. For wildcarded subdomain matching, <b>*.example.com</b>
       is a valid case, but <b>example*.*.com</b> is not.

       <u>Note:</u> The <u>hostname</u> and <u>port</u> refer to the container registry host and port (the one used e.g.  for  <b>docker</b>
       <b>pull</b>), <u>not</u> to the OpenShift API host and port.

   <b>containers-storage:</b>
       Supported scopes have the form <b>[</b><u>storage-specifier</u><b>]</b><u>image-scope</u>.

       <b>[</b><u>storage-specifier</u><b>]</b>           is           usually          <b>[</b><u>graph-driver-name</u><b>@</b><u>graph-root</u><b>]</b>,          e.g.
       <b>[overlay@/var/lib/containers/storage]</b>.

       <u>image-scope</u> matching the individual image is - a named Docker  reference  <u>in</u>  <u>the</u>  <u>fully</u>  <u>expanded</u>  <u>form</u>,
       either using a tag or digest. For example, <b>docker.io/library/busybox:latest</b> (<u>not</u> <b>busybox:latest</b>) - and/or
       (depending on which one the user’s input provides) <b>@</b><u>image-id</u>

       More  general  scopes  are  prefixes  of  individual-image scopes, and specify a less-precisely-specified
       image, or a repository (by omitting first the image ID, if any; then the digest, if any;  and  finally  a
       tag, if any), a repository namespace, or a registry host (by only specifying the host name and possibly a
       port number).

       Finally,  two  full-store  specifiers matching all images in the store are valid scopes: - <b>[</b><u>graph-driver-</u>
       <u>name</u><b>@</b><u>graph-root</u><b>]</b> and - <b>[</b><u>graph-root</u><b>]</b>

       Note that some tools like Podman and Buildah hard-code overrides of the signature verification policy for
       “push” operations, allowing these operations regardless of configuration in <b>policy.json</b>.

   <b>dir:</b>
       The <b>dir:</b> transport refers to images stored in local directories.

       Supported scopes are paths of directories (either containing a single image  or  subdirectories  possibly
       containing images).

       <u>Note:</u>  -  The  paths  must be absolute and contain no symlinks. Paths violating these requirements may be
       silently ignored.  - The top-level scope <b>"/"</b> is forbidden; use the transport default scope <b>""</b>,
         for consistency with other transports.

   <b>docker:</b>
       The <b>docker:</b> transport refers to images in a registry implementing the "Docker Registry HTTP API V2".

       Scopes matching individual images are named Docker references <u>in</u> <u>the</u> <u>fully</u> <u>expanded</u> <u>form</u>, either using  a
       tag or digest. For example, <b>docker.io/library/busybox:latest</b> (<u>not</u> <b>busybox:latest</b>).

       More  general  scopes  are prefixes of individual-image scopes, and specify a repository (by omitting the
       tag or digest), a repository namespace, or a registry host (by only specifying the host name and possibly
       a port number) or a wildcarded expression starting with <b>*.</b>, for matching all subdomains (not including  a
       port  number).  For  wildcarded  subdomain matching, <b>*.example.com</b> is a valid case, but <b>example*.*.com</b> is
       not.

   <b>docker-archive:</b>
       Only the default <b>""</b> scope is supported.

   <b>docker-daemon:</b>
       For references using the <u>algo:digest</u> format (referring to an image ID), only  the  default  <b>""</b>  scope  is
       used.

       For  images  using  a  named reference, scopes matching individual images are <u>in</u> <u>the</u> <u>fully</u> <u>expanded</u> <u>form</u>,
       either using a tag or digest. For example, <b>docker.io/library/busybox:latest</b> (<u>not</u> <b>busybox:latest</b>).

       More general named scopes are prefixes of individual-image scopes, and specify a repository (by  omitting
       the  tag  or  digest),  a  repository namespace, or a registry host (by only specifying the host name and
       possibly a port number) or a wildcarded expression starting with <b>*.</b>, for  matching  all  subdomains  (not
       including  a  port  number).  For  wildcarded  subdomain  matching,  <b>*.example.com</b>  is  a valid case, but
       <b>example*.*.com</b> is not.

   <b>oci:</b>
       The <b>oci:</b> transport  refers  to  images  in  directories  compliant  with  "Open  Container  Image  Layout
       Specification".

       Supported  scopes  are  paths to directories (either containing an OCI layout, or subdirectories possibly
       containing OCI layout directories).  The <u>reference</u> annotation value, if any, is not used.

       <u>Note:</u> - The paths must be absolute and contain no symlinks. Paths violating  these  requirements  may  be
       silently ignored.  - The top-level scope <b>"/"</b> is forbidden; use the transport default scope <b>""</b>,
         for consistency with other transports.

   <b>oci-archive:</b>
       Supported  scopes  are  paths  to  OCI archives, and their parent directories (either containing a single
       archive, or subdirectories possibly containing archives).  The <u>reference</u> annotation value, if any, is not
       used.

       <u>Note:</u> - The paths must be absolute and contain no symlinks. Paths violating  these  requirements  may  be
       silently ignored.  - The top-level scope <b>"/"</b> is forbidden; use the transport default scope <b>""</b>,
         for consistency with other transports.

   <b>ostree</b>:
       Supported scopes have the form <u>repo-path</u><b>:</b><u>image-scope</u>; _repo<u>path</u> is the path to the OSTree repository.

       <u>image-scope</u>  is  the _docker<u>reference</u> part of the reference, with with a <b>:latest</b> tag implied if no tag is
       present, and parent namespaces of the _docker<u>reference</u> value (by omitting the tag, or a prefix specifying
       a higher-level namespace).

       <u>Note:</u> - The _repo<u>path</u> must be absolute and contain no symlinks. Paths violating these requirements may be
       silently ignored.

   <b>sif:</b>
       Supported scopes are paths to Singularity images, and their parent directories (either containing images,
       or subdirectories possibly containing images).

       <u>Note:</u> - The paths must be absolute and contain no symlinks. Paths violating  these  requirements  may  be
       silently ignored.  - The top-level scope <b>"/"</b> is forbidden; use the transport default scope <b>""</b>,
         for consistency with other transports.

   <b>tarball:</b>
       The <b>tarball:</b> transport is an implementation detail of some import workflows. Only the default <b>""</b> scope is
       supported.

</pre><h4><b>Policy</b> <b>Requirements</b></h4><pre>
       Using  the  mechanisms  above,  a  set  of policy requirements is looked up.  The policy requirements are
       represented as a JSON array of individual requirement objects.  For an image to be accepted, <u>all</u>  of  the
       requirements must be satisfied simultaneously.

       The  policy  requirements  can  also  be used to decide whether an individual signature is accepted (= is
       signed by a recognized key of a known author); in that case some requirements  may  apply  only  to  some
       signatures, but each signature must be accepted by <u>at</u> <u>least</u> <u>one</u> requirement object.

       The following requirement objects are supported:

   <b>insecureAcceptAnything</b>
       A simple requirement with the following syntax

       {"type":"insecureAcceptAnything"}

       This requirement accepts any image (but note that other requirements in the array still apply).

       When  deciding  to accept an individual signature, this requirement does not have any effect; it does <u>not</u>
       cause the signature to be accepted, though.

       This is useful primarily for policy scopes where no signature verification is required; because the array
       of policy requirements must not be empty, this requirement is used to represent the lack of  requirements
       explicitly.

   <b>reject</b>
       A simple requirement with the following syntax:

       {"type":"reject"}

       This requirement rejects every image, and every signature.

   <b>signedBy</b>
       This  requirement  requires  an  image  to be signed using “simple signing” with an expected identity, or
       accepts a signature if it is using an expected identity and key.

       {
           "type":    "signedBy",
           "keyType": "GPGKeys", /* The only currently supported value */
           "keyPath": "/path/to/local/keyring/file",
           "keyPaths": ["/path/to/local/keyring/file1","/path/to/local/keyring/file2"…],
           "keyData": "base64-encoded-keyring-data",
           "signedIdentity": identity_requirement
       }

       Exactly one of <b>keyPath</b>, <b>keyPaths</b> and <b>keyData</b> must be present, containing a GPG keyring  of  one  or  more
       public keys.  Only signatures made by these keys are accepted.

       The  <b>signedIdentity</b>  field,  a  JSON object, specifies what image identity the signature claims about the
       image.  One of the following alternatives are supported:

              • The identity in the signature must exactly match the  image  identity.   Note  that  with  this,
                referencing an image by digest (with a signature claiming a <u>repository</u><b>:</b><u>tag</u> identity) will fail.

         {"type":"matchExact"}

              • If  the  image  identity carries a tag, the identity in the signature must exactly match; if the
                image identity uses a digest reference, the identity in  the  signature  must  be  in  the  same
                repository as the image identity (using any tag).

       (Note  that  with  images  identified using digest references, the digest from the reference is validated
       even before signature verification starts.)

         {"type":"matchRepoDigestOrExact"}

              • The identity in the signature must be in the same repository as the  image  identity.   This  is
                useful  e.g.  to  pull  an  image  using  the  <b>:latest</b>  tag  when the image is signed with a tag
                specifying an exact image version.

         {"type":"matchRepository"}

              • The identity in the signature must exactly match a specified identity.  This is useful e.g. when
                locally mirroring images signed using their public identity.

         {
             "type": "exactReference",
             "dockerReference": docker_reference_value
         }

              • The identity in the signature must be in the same repository  as  a  specified  identity.   This
                combines the properties of <b>matchRepository</b> and <b>exactReference</b>.

         {
             "type": "exactRepository",
             "dockerRepository": docker_repository_value
         }

              • Prefix remapping:

       If  the  image  identity  matches  the specified prefix, that prefix is replaced by the specified “signed
       prefix”
         (otherwise it is used as unchanged and no remapping takes place);
         matching then follows the <b>matchRepoDigestOrExact</b> semantics documented above
         (i.e. if the image identity carries a tag, the identity in the signature must exactly match,
         if it uses a digest reference, the repository must match).

       The <b>prefix</b> and <b>signedPrefix</b> values can be either host[:port] values
         (matching exactly the same host[:port], string),
         repository namespaces, or repositories (i.e. they must not contain tags/digests),
         and match as prefixes <u>of</u> <u>the</u> <u>fully</u> <u>expanded</u> <u>form</u>.
         For example, <b>docker.io/library/busybox</b> (<u>not</u> <b>busybox</b>) to specify that single repository,
         or   <b>docker.io/library</b>   (not   an   empty   string)   to   specify    the    parent    namespace    of
       <b>docker.io/library/busybox</b>==<b>busybox</b>).

       The <b>prefix</b> value is usually the same as the scope containing the parent <b>signedBy</b> requirement.

         {
             "type": "remapIdentity",
             "prefix": prefix,
             "signedPrefix": prefix,
         }

       If the <b>signedIdentity</b> field is missing, it is treated as <b>matchRepoDigestOrExact</b>.

       <u>Note</u>:  <b>matchExact</b>,  <b>matchRepoDigestOrExact</b>  and  <b>matchRepository</b>  can be only used if a Docker-like image
       identity is provided by the transport.  In particular, the <b>dir:</b> and <b>oci:</b> transports can be only used with
       <b>exactReference</b> or <b>exactRepository</b>.

   <b>sigstoreSigned</b>
       This requirement requires an image to be signed using a sigstore signature with an expected identity  and
       key.

       {
           "type":    "sigstoreSigned",
           "keyPath": "/path/to/local/public/key/file",
           "keyPaths": ["/path/to/first/public/key/one", "/path/to/first/public/key/two"],
           "keyData": "base64-encoded-public-key-data",
           "keyDatas": ["base64-encoded-public-key-one-data", "base64-encoded-public-key-two-data"]
           "fulcio": {
               "caPath": "/path/to/local/CA/file",
               "caData": "base64-encoded-CA-data",
               "oidcIssuer": "https://expected.OIDC.issuer/",
               "subjectEmail", "<a href="mailto:expected-signing-user@example.com">expected-signing-user@example.com</a>",
           },
           "pki": {
               "caRootsPath": "/path/to/local/CARoots/file",
               "caRootsData": "base64-encoded-CARoots-data",
               "caIntermediatesPath": "/path/to/local/CAIntermediates/file",
               "caIntermediatesData": "base64-encoded-CAIntermediates-data",
               "subjectHostname": "expected-signing-hostname.example.com",
               "subjectEmail": "<a href="mailto:expected-signing-user@example.com">expected-signing-user@example.com</a>"
           },
           "rekorPublicKeyPath": "/path/to/local/public/key/file",
           "rekorPublicKeyPaths": ["/path/to/local/public/key/one","/path/to/local/public/key/two"],
           "rekorPublicKeyData": "base64-encoded-public-key-data",
           "rekorPublicKeyDatas": ["base64-encoded-public-key-one-data","base64-encoded-public-key-two-data"],
           "signedIdentity": identity_requirement
       }

       Exactly one of <b>keyPath</b>, <b>keyPaths</b>, <b>keyData</b>, <b>keyDatas</b>, <b>fulcio</b> and <b>pki</b> must be present.

       If  <b>keyPath</b>  or  <b>keyData</b> is present, it contains a sigstore public key.  Only signatures made by this key
       are accepted.

       If <b>keyPaths</b> or <b>keyDatas</b> is present, it contains sigstore public keys.  Only signatures made by any key in
       the list are accepted.

       If <b>fulcio</b> is present, the signature must be based on a Fulcio-issued  certificate.   One  of  <b>caPath</b>  and
       <b>caData</b>  must  be  specified,  containing  the  public  key  of  the Fulcio instance.  Both <b>oidcIssuer</b> and
       <b>subjectEmail</b> are mandatory, exactly specifying the expected identity provider, and the  identity  of  the
       user obtaining the Fulcio certificate.

       If <b>pki</b> is present, the signature must be based on a non-Fulcio X.509 certificate.  One of <b>caRootsPath</b> and
       <b>caRootsData</b>  must  be specified, containing certificates of the CAs.  Only one of <b>caIntermediatesPath</b> and
       <b>caIntermediatesData</b> can be present, containing certificates of the intermediate CAs.  One of <b>subjectEmail</b>
       and <b>subjectHostname</b> must be specified, exactly specifying the expected identity to which the  certificate
       was issued.

       At most one of <b>rekorPublicKeyPath</b>, <b>rekorPublicKeyPaths</b>, <b>rekorPublicKeyData</b> and <b>rekorPublicKeyDatas</b> can be
       present;  it is mandatory if <b>fulcio</b> is specified.  If a Rekor public key is specified, the signature must
       have been uploaded to a Rekor server and the signature must contain an (offline-verifiable) “signed entry
       timestamp” proving the existence of the Rekor log record, signed by one of the provided public keys.

       The <b>signedIdentity</b> field has the same semantics as in the <b>signedBy</b>  requirement  described  above.   Note
       that <b>cosign</b>-created signatures only contain a repository, so only <b>matchRepository</b> and <b>exactRepository</b> can
       be  used  to  accept  them  (and  that  does  not  protect against substitution of a signed image with an
       unexpected tag).

       To use this with images hosted on image registries,  the  <b>use-sigstore-attachments</b>  option  needs  to  be
       enabled for the relevant registry or repository in the client's <a href="../man5/containers-registries.d.5.html">containers-registries.d</a>(5).

</pre><h4><b>Examples</b></h4><pre>
       It  is  <u>strongly</u>  recommended  to set the <b>default</b> policy to <b>reject</b>, and then selectively allow individual
       transports and scopes as desired.

   <b>A</b> <b>reasonably</b> <b>locked-down</b> <b>system</b>
       (Note that the <b>/*</b>…<b>*/</b> comments are not valid in JSON, and must not be used in real policies.)

       {
           "default": [{"type": "reject"}], /* Reject anything not explicitly allowed */
           "transports": {
               "docker": {
                   /* Allow installing images from a specific repository namespace, without cryptographic verification.
                      This namespace includes images like openshift/hello-openshift and openshift/origin. */
                   "docker.io/openshift": [{"type": "insecureAcceptAnything"}],
                   /* Similarly, allow installing the “official” busybox images.  Note how the fully expanded
                      form, with the explicit /library/, must be used. */
                   "docker.io/library/busybox": [{"type": "insecureAcceptAnything"}],
                   /* Allow installing images from all subdomains */
                   "*.temporary-project.example.com": [{"type": "insecureAcceptAnything"}],
                   /* A sigstore-signed repository */
                   "hostname:5000/myns/sigstore-signed-with-full-references": [
                       {
                           "type": "sigstoreSigned",
                           "keyPath": "/path/to/sigstore-pubkey.pub"
                       }
                   ],
                   /* A sigstore-signed repository using the community Fulcio+Rekor servers.

                      The community servers’ public keys can be obtained from
                      https://github.com/sigstore/sigstore/tree/main/pkg/tuf/repository/targets .  */
                   "hostname:5000/myns/sigstore-signed-fulcio-rekor": [
                       {
                           "type": "sigstoreSigned",
                           "fulcio": {
                               "caPath": "/path/to/fulcio_v1.crt.pem",
                               "oidcIssuer": "https://github.com/login/oauth",
                               "subjectEmail": "<a href="mailto:test-user@example.com">test-user@example.com</a>"
                           },
                           "rekorPublicKeyPath": "/path/to/rekor.pub",
                       }
                   ],
                   /* A Sigstore-signed repository using a certificate generated by a custom public-key infrastructure.*/
                   "hostname:5000/myns/sigstore-signed-byopki": [
                       {
                           "type": "sigstoreSigned",
                           "pki": {
                               "caRootsPath": "/path/to/pki_root_crts.pem",
                               "caIntermediatesPath": "/path/to/pki_intermediate_crts.pem",
                               "subjectHostname": "test-user.example.com"
                               "subjectEmail": "<a href="mailto:test-user@example.com">test-user@example.com</a>"
                           }
                       }
                   ],
                   /* A sigstore-signed repository, accepts signatures by /usr/bin/cosign */
                   "hostname:5000/myns/sigstore-signed-allows-malicious-tag-substitution": [
                       {
                           "type": "sigstoreSigned",
                           "keyPath": "/path/to/sigstore-pubkey.pub",
                           "signedIdentity": {"type": "matchRepository"}
                       }
                   ],
                   /* A sigstore-signed repository using the community Fulcio+Rekor servers,
                      accepts signatures by /usr/bin/cosign.

                      The community servers’ public keys can be obtained from
                      https://github.com/sigstore/sigstore/tree/main/pkg/tuf/repository/targets .  */
                   "hostname:5000/myns/sigstore-signed-fulcio-rekor- allows-malicious-tag-substitution": [
                       {
                           "type": "sigstoreSigned",
                           "fulcio": {
                               "caPath": "/path/to/fulcio_v1.crt.pem",
                               "oidcIssuer": "https://github.com/login/oauth",
                               "subjectEmail": "<a href="mailto:test-user@example.com">test-user@example.com</a>"
                           },
                           "rekorPublicKeyPath": "/path/to/rekor.pub",
                           "signedIdentity": { "type": "matchRepository" }
                       }
                   ]
                     /* Other docker: images use the global default policy and are rejected */
               },
               "dir": {
                   "": [{"type": "insecureAcceptAnything"}] /* Allow any images originating in local directories */
               },
               "atomic": {
                   /* The common case: using a known key for a repository or set of repositories */
                   "hostname:5000/myns/official": [
                       {
                           "type": "signedBy",
                           "keyType": "GPGKeys",
                           "keyPath": "/path/to/official-pubkey.gpg"
                       }
                   ],
                   /* A more complex example, for a repository which contains a mirror of a third-party product,
                      which must be signed-off by local IT */
                   "hostname:5000/vendor/product": [
                       { /* Require the image to be signed by the original vendor, using the vendor's repository location. */
                           "type": "signedBy",
                           "keyType": "GPGKeys",
                           "keyPath": "/path/to/vendor-pubkey.gpg",
                           "signedIdentity": {
                               "type": "exactRepository",
                               "dockerRepository": "vendor-hostname/product/repository"
                           }
                       },
                       { /* Require the image to _also_ be signed by a local reviewer. */
                           "type": "signedBy",
                           "keyType": "GPGKeys",
                           "keyPath": "/path/to/reviewer-pubkey.gpg"
                       }
                   ],
                   /* A way to mirror many repositories from a single vendor */
                   "private-mirror:5000/vendor-mirror": [
                       { /* Require the image to be signed by the original vendor, using the vendor's repository location.
                            For example, private-mirror:5000/vendor-mirror/productA/image1:latest needs to be signed as
                            vendor.example/productA/image1:latest . */
                           "type": "signedBy",
                           "keyType": "GPGKeys",
                           "keyPath": "/path/to/vendor-pubkey.gpg",
                           "signedIdentity": {
                               "type": "remapIdentity",
                               "prefix": "private-mirror:5000/vendor-mirror",
                               "signedPrefix": "vendor.example.com"
                           }
                       }
                   ]
               }
           }
       }

   <b>Completely</b> <b>disable</b> <b>security,</b> <b>allow</b> <b>all</b> <b>images,</b> <b>do</b> <b>not</b> <b>trust</b> <b>any</b> <b>signatures</b>
       {
           "default": [{"type": "insecureAcceptAnything"}]
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/atomic.1.html">atomic</a>(1)

</pre><h4><b>HISTORY</b></h4><pre>
       August   2018,   Rename   to   <a href="../man5/containers-policy.json.5.html">containers-policy.json</a>(5)   by   Valentin   Rothberg    <a href="mailto:vrothberg@suse.com">vrothberg@suse.com</a>
       ⟨<a href="mailto:vrothberg@suse.com">mailto:vrothberg@suse.com</a>⟩

       September 2016, Originally compiled by Miloslav Trmač <a href="mailto:mitr@redhat.com">mitr@redhat.com</a> ⟨<a href="mailto:mitr@redhat.com">mailto:mitr@redhat.com</a>⟩

Man                                                policy.json                         <u><a href="../man5/CONTAINERS-POLICY.JSON.5.html">CONTAINERS-POLICY.JSON</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>