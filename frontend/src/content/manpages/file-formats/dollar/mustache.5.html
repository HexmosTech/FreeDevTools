<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mustache - Logic-less templates.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ruby-mustache">ruby-mustache_1.1.1-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>mustache</b> - Logic-less templates.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       A typical Mustache template:

           Hello {{name}}
           You have just won {{value}} dollars!
           {{#in_ca}}
           Well, {{taxed_value}} dollars, after taxes.
           {{/in_ca}}

       Given the following hash:

           {
             "name": "Chris",
             "value": 10000,
             "taxed_value": 10000 - (10000 * 0.4),
             "in_ca": true
           }

       Will produce the following:

           Hello Chris
           You have just won 10000 dollars!
           Well, 6000.0 dollars, after taxes.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mustache  can  be  used  for  HTML, config files, source code - anything. It works by expanding tags in a
       template using values provided in a hash or object.

       We call it "logic-less" because there are no if statements, else clauses, or for loops. Instead there are
       only tags. Some tags are replaced with a value, some  nothing,  and  others  a  series  of  values.  This
       document explains the different types of Mustache tags.

</pre><h4><b>TAG</b> <b>TYPES</b></h4><pre>
       Tags  are  indicated  by  the double mustaches. <b>{{person}}</b> is a tag, as is <b>{{#person}}</b>. In both examples,
       we´d refer to <b>person</b> as the key or tag key. Let´s talk about the different types of tags.

   <b>Variables</b>
       The most basic tag type is the variable. A <b>{{name}}</b> tag in a basic template will try to find the <b>name</b> key
       in the current context. If there is no <b>name</b> key, the parent contexts will be checked recursively. If  the
       top context is reached and the <b>name</b> key is still not found, nothing will be rendered.

       All  variables  are HTML escaped by default. If you want to return raw contents without escaping, use the
       triple mustache: <b>{{{name}}}</b>.

       You can also use <b>&amp;</b> to return its raw contents: <b>{{&amp;</b> <b>name}}</b>. This may be useful  when  changing  delimiters
       (see "Set Delimiter" below).

       By  default  a  variable  "miss" returns an empty string. This can usually be configured in your Mustache
       library. The Ruby version of Mustache supports raising an exception in this situation, for instance.

       Template:

           * {{name}}
           * {{age}}
           * {{company}}
           * {{{company}}}

       Hash:

           {
             "name": "Chris",
             "company": "&lt;b&gt;GitHub&lt;/b&gt;"
           }

       Output:

           * Chris
           *
           * &amp;lt;b&amp;gt;GitHub&amp;lt;/b&amp;gt;
           * &lt;b&gt;GitHub&lt;/b&gt;

   <b>Sections</b>
       Sections render blocks of text zero or more times, depending on the value  of  the  key  in  the  current
       context.

       A section begins with a pound and ends with a slash. That is, <b>{{#person}}</b> begins a "person" section while
       <b>{{/person}}</b> ends it.

       The behavior of the section is determined by the value of the key.

       <b>False</b> <b>Values</b> <b>or</b> <b>Empty</b> <b>Lists</b>

       If  the <b>person</b> key exists and has a value of false or an empty list, the HTML between the pound and slash
       will not be displayed.

       Template:

           Shown.
           {{#person}}
             Never shown!
           {{/person}}

       Hash:

           {
             "person": false
           }

       Output:

           Shown.

       <b>Non-Empty</b> <b>Lists</b>

       If the <b>person</b> key exists and has a non-false value, the HTML between the pound and slash will be rendered
       and displayed one or more times.

       When the value is a non-empty list, the text in the block will be displayed once for  each  item  in  the
       list.  The  context  of  the block will be set to the current item for each iteration. In this way we can
       loop over collections.

       Template:

           {{#repo}}
             &lt;b&gt;{{name}}&lt;/b&gt;
           {{/repo}}

       Hash:

           {
             "repo": [
               { "name": "resque" },
               { "name": "hub" },
               { "name": "rip" }
             ]
           }

       Output:

           &lt;b&gt;resque&lt;/b&gt;
           &lt;b&gt;hub&lt;/b&gt;
           &lt;b&gt;rip&lt;/b&gt;

       <b>Lambdas</b>

       When the value is a callable object, such as a function or lambda, the object will be invoked and  passed
       the block of text. The text passed is the literal block, unrendered. <b>{{tags}}</b> will not have been expanded
       - the lambda should do that on its own. In this way you can implement filters or caching.

       Template:

           {{#wrapped}}
             {{name}} is awesome.
           {{/wrapped}}

       Hash:

           {
             "name": "Willy",
             "wrapped": function() {
               return function(text, render) {
                 return "&lt;b&gt;" + render(text) + "&lt;/b&gt;"
               }
             }
           }

       Output:

           &lt;b&gt;Willy is awesome.&lt;/b&gt;

       <b>Non-False</b> <b>Values</b>

       When  the value is non-false but not a list, it will be used as the context for a single rendering of the
       block.

       Template:

           {{#person?}}
             Hi {{name}}!
           {{/person?}}

       Hash:

           {
             "person?": { "name": "Jon" }
           }

       Output:

           Hi Jon!

   <b>Inverted</b> <b>Sections</b>
       An inverted section begins with a caret (hat) and ends  with  a  slash.  That  is  <b>{{^person}}</b>  begins  a
       "person" inverted section while <b>{{/person}}</b> ends it.

       While  sections  can  be  used  to render text zero or more times based on the value of the key, inverted
       sections may render text once based on the inverse value of the key. That is, they will  be  rendered  if
       the key doesn´t exist, is false, or is an empty list.

       Template:

           {{#repo}}
             &lt;b&gt;{{name}}&lt;/b&gt;
           {{/repo}}
           {{^repo}}
             No repos :(
           {{/repo}}

       Hash:

           {
             "repo": []
           }

       Output:

           No repos :(

   <b>Comments</b>
       Comments begin with a bang and are ignored. The following template:

           &lt;h1&gt;Today{{! ignore me }}.&lt;/h1&gt;

       Will render as follows:

           &lt;h1&gt;Today.&lt;/h1&gt;

       Comments may contain newlines.

   <b>Partials</b>
       Partials begin with a greater than sign, like <b>{{&gt;</b> <b>box}}</b>.

       Partials  are  rendered at runtime (as opposed to compile time), so recursive partials are possible. Just
       avoid infinite loops.

       They also inherit the calling context. Whereas in ERB you may have this:

           &lt;%= partial :next_more, :start =&gt; start, :size =&gt; size %&gt;

       Mustache requires only this:

           {{&gt; next_more}}

       Why? Because the <b>next_more.mustache</b> file will inherit  the  <b>size</b>  and  <b>start</b>  methods  from  the  calling
       context.

       In  this  way  you may want to think of partials as includes, or template expansion, even though it´s not
       literally true.

       For example, this template and partial:

           base.mustache:
           &lt;h2&gt;Names&lt;/h2&gt;
           {{#names}}
             {{&gt; user}}
           {{/names}}

           user.mustache:
           &lt;strong&gt;{{name}}&lt;/strong&gt;

       Can be thought of as a single, expanded template:

           &lt;h2&gt;Names&lt;/h2&gt;
           {{#names}}
             &lt;strong&gt;{{name}}&lt;/strong&gt;
           {{/names}}

   <b>Set</b> <b>Delimiter</b>
       Set Delimiter tags start with an equal sign and change the tag  delimiters  from  <b>{{</b>  and  <b>}}</b>  to  custom
       strings.

       Consider the following contrived example:

           * {{default_tags}}
           {{=&lt;% %&gt;=}}
           * &lt;% erb_style_tags %&gt;
           &lt;%={{ }}=%&gt;
           * {{ default_tags_again }}

       Here  we  have  a  list  with three items. The first item uses the default tag style, the second uses erb
       style as defined by the Set Delimiter tag, and the third returns to the default style after  yet  another
       Set Delimiter declaration.

       According  to ctemplates <u><a href="http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html">http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html</a></u>, this "is useful
       for languages like TeX, where double-braces may occur in the text and are awkward to use for markup."

       Custom delimiters may not contain whitespace or the equals sign.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Mustache is Copyright (C) 2009 Chris Wanstrath

       Original CTemplate by Google

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/mustache.1.html">mustache</a>(1), <u><a href="http://mustache.github.io/">http://mustache.github.io/</a></u>

DEFUNKT                                           November 2016                                      <u><a href="../man5/MUSTACHE.5.html">MUSTACHE</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>