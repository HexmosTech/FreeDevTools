<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Containerfile(Dockerfile) - automate the steps of creating a container image</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/golang-github-containers-common">golang-github-containers-common_0.62.2+ds1-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Containerfile(Dockerfile) - automate the steps of creating a container image

</pre><h4><b>INTRODUCTION</b></h4><pre>
       The  <b>Containerfile</b>  is a configuration file that automates the steps of creating a container image. It is
       similar  to  a  Makefile.  Container  engines  (Podman,  Buildah,  Docker)  read  instructions  from  the
       <b>Containerfile</b>  to  automate the steps otherwise performed manually to create an image. To build an image,
       create a file called <b>Containerfile</b>.

       The <b>Containerfile</b> describes the steps taken to assemble  the  image.  When  the  <b>Containerfile</b>  has  been
       created,  call the <b>buildah</b> <b>build</b>, <b>podman</b> <b>build</b>, <b>docker</b> <b>build</b> command, using the path of context directory
       that contains <b>Containerfile</b> as the argument. Podman and Buildah default to <b>Containerfile</b>  and  will  fall
       back to <b>Dockerfile</b>. Docker only will search for <b>Dockerfile</b> in the context directory.

       <b>Dockerfile</b>  is  an  alternate  name  for  the same object.  <b>Containerfile</b> and <b>Dockerfile</b> support the same
       syntax.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       INSTRUCTION arguments

       For example:

       FROM image

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Containerfile is a file that automates the steps of creating a container  image.   A  Containerfile  is
       similar to a Makefile.

</pre><h4><b>USAGE</b></h4><pre>
         buildah build .
         podman build .

       -- Runs the steps and commits them, building a final image.
         The path to the source repository defines where to find the context of the
         build.

         buildah build -t repository/tag .
         podman build -t repository/tag .

       -- specifies a repository and tag at which to save the new image if the build
         succeeds. The container engine runs the steps one-by-one, committing the result
         to a new image if necessary, before finally outputting the ID of the new
         image.

       Container engines reuse intermediate images whenever possible. This significantly
         accelerates the <u>build</u> process.

</pre><h4><b>FORMAT</b></h4><pre>
       <b>FROM</b> <b>image</b> <b>[AS</b> <b>&lt;name&gt;]</b>

       <b>FROM</b> <b>image:tag</b> <b>[AS</b> <b>&lt;name&gt;]</b>

       <b>FROM</b> <b>image@digest</b> <b>[AS</b> <b>&lt;name&gt;]</b>

       -- The <b>FROM</b> instruction sets the base image for subsequent instructions. A
         valid Containerfile must have either <b>ARG</b> or <b>FROM</b> as its first instruction.
         If <b>FROM</b> is not the first instruction in the file, it may only be preceded by
         one  or  more  ARG  instructions,  which  declare  arguments that are used in the next FROM line in the
       Containerfile.
         The image can be any valid image. It is easy to start by pulling an image from the public
         repositories.

       -- <b>FROM</b> must appear at least once in the Containerfile.

       -- <b>FROM</b> The first <b>FROM</b> command must come before all other instructions in
         the Containerfile except <b>ARG</b>

       -- <b>FROM</b> may appear multiple times within a single Containerfile in order to create
         multiple images. Make a note of the last image ID output by the commit before
         each new <b>FROM</b> command.

       -- If no tag is given to the <b>FROM</b> instruction, container engines apply the
         <b>latest</b> tag. If the used tag does not exist, an error is returned.

       -- If no digest is given to the <b>FROM</b> instruction, container engines apply the
         <b>latest</b> tag. If the used tag does not exist, an error is returned.

       -- A name can be assigned to a build stage by adding <b>AS</b> <b>name</b> to the instruction.
         The name can be referenced later in the Containerfile using the <b>FROM</b> or <b>COPY</b> <b>--from=</b> instructions.

       <b>MAINTAINER</b>
         -- <b>MAINTAINER</b> sets the Author field for the generated images.
         Useful for providing users with an email or url for support.

       <b>RUN</b>
         -- <b>RUN</b> has two forms:

         # the command is run in a shell - <a href="file:/bin/sh">/bin/sh</a> -c
         RUN &lt;command&gt;

         # Executable form
         RUN ["executable", "param1", "param2"]

       <b>RUN</b> <b>mounts</b>

       <b>--mount</b>=<u>type=TYPE,TYPE-SPECIFIC-OPTION[,...]</u>

       Attach a filesystem mount to the container

       Current supported mount TYPES are bind, cache, secret and tmpfs.

          e.g.

          mount=type=bind,source=/path/on/host,destination=/path/in/container,relabel=shared

          mount=type=tmpfs,tmpfs-size=512M,destination=/path/in/container

          mount=type=secret,id=mysecret cat /run/secrets/mysecret

          Common Options:

             · src, source: mount source spec for bind and volume. Mandatory for bind. If `from` is specified, `src` is the subpath in the `from` field.

             · dst, destination, target: mount destination spec.

             · ro, read-only: true (default) or false.

          Options specific to bind:

             · bind-propagation: shared, slave, private, rshared, rslave, or rprivate(default). See also <a href="../man2/mount.2.html">mount</a>(2).

             . bind-nonrecursive: do not setup a recursive bind mount.  By default it is recursive.

             · from: stage or image name for the root of the source. Defaults to the build context.

             · relabel=shared, z: Relabels src content with a shared label.

             . relabel=private, Z: Relabels src content with a private label.

             Labeling systems like SELinux require proper labels on the bind mounted content mounted into a container. Without a label, the security system might prevent the processes running in side the container from using the content. By default, container engines do not change the labels set by the OS. The relabel flag tells the engine to relabel file objects on the shared mountz.

             The relabel=shared and z options tell the engine that two or more containers will share the mount content. The engine labels the content with a shared content label.

             The relabel=private and Z options tell the engine to label the content with a private unshared label. Only the current container can use a private mount.

             Relabeling walks the file system under the mount and changes the label on each file, if the mount has thousands of inodes, this process takes a long time, delaying the start of the container.

             · rw, read-write: allows writes on the mount.

          Options specific to tmpfs:

             · tmpfs-size: Size of the tmpfs mount in bytes. Unlimited by default in Linux.

             · tmpfs-mode: File mode of the tmpfs in octal. (e.g. 700 or 0700.) Defaults to 1777 in Linux.

             · tmpcopyup: Path that is shadowed by the tmpfs mount is recursively copied up to the tmpfs itself.

       Options specific to cache:

             · id: Create a separate cache directory for a particular id.

             · mode: File mode for new cache directory in octal. Default 0755.

             · ro, readonly: read only cache if set.

             · uid: uid for cache directory.

             · gid: gid for cache directory.

             · from: stage name for the root of the source. Defaults to host cache directory.

             · rw, read-write: allows writes on the mount.

       <b>RUN</b> <b>--network</b>

       <b>RUN</b> <b>--network</b> allows control over which networking environment the command is run in.

       Syntax: <b>--network=&lt;TYPE&gt;</b>

       <b>Network</b> <b>types</b>

       ┌───────────────────────────────────┬───────────────────────────────────────┐
       │ <b>Type</b>                              │ <b>Description</b>                           │
       ├───────────────────────────────────┼───────────────────────────────────────┤
       │                                   │                                       │
       ├───────────────────────────────────┼───────────────────────────────────────┤
       │ ⟨#run---networkdefault⟩ (default) │ Run in the default network.           │
       ├───────────────────────────────────┼───────────────────────────────────────┤
       │                                   │                                       │
       ├───────────────────────────────────┼───────────────────────────────────────┤
       │ ⟨#run---networknone⟩              │ Run with no network access.           │
       ├───────────────────────────────────┼───────────────────────────────────────┤
       │                                   │                                       │
       ├───────────────────────────────────┼───────────────────────────────────────┤
       │ ⟨#run---networkhost⟩              │ Run    in    the    host's    network │
       │                                   │ environment.                          │
       └───────────────────────────────────┴───────────────────────────────────────┘

   <b>RUN</b> <b>--network=default</b>
       Equivalent to not supplying a flag at all, the command is run in the default network for the build.

   <b>RUN</b> <b>--network=none</b>
       The command is run with no network access (<b>lo</b> is still available, but is isolated to this process).

   <b>Example:</b> <b>isolating</b> <b>external</b> <b>effects</b>
       FROM python:3.6
       ADD mypackage.tgz wheels/
       RUN --network=none pip install --find-links wheels mypackage

       <b>pip</b>  will  only  be  able  to install the packages provided in the tarfile, which can be controlled by an
       earlier build stage.

   <b>RUN</b> <b>--network=host</b>
       The command is run in the host's network environment (similar to <b>buildah</b> <b>build</b> <b>--network=host</b>, but  on  a
       per-instruction basis)

       <b>RUN</b> <b>Secrets</b>

       The  RUN  command  has  a  feature to allow the passing of secret information into the image build. These
       secrets files can be used during the RUN command but are not  committed  to  the  final  image.  The  <b>RUN</b>
       command  supports  the <b>--mount</b> option to identify the secret file. A secret file from the host is mounted
       into the container while the image is being built.

       Container engines pass secret the secret file into the build using the <b>--secret</b> flag.

       <b>--mount</b>=<u>type=secret,TYPE-SPECIFIC-OPTION[,...]</u>

              • <b>id</b> is the identifier for the secret passed into the  <b>buildah</b>  <b>build</b>  <b>--secret</b>  or  <b>podman</b>  <b>build</b>
                <b>--secret</b>.  This  identifier  is  associated  with  the  RUN  --mount  identifier  to  use in the
                Containerfile.

              • <b>dst</b>|<b>target</b>|<b>destination</b> rename the secret file to  a  specific  file  in  the  Containerfile  RUN
                command to use.

              • <b>type=secret</b> tells the --mount command that it is mounting in a secret file
                # shows secret from default secret location:
                RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret

                # shows secret from custom secret location:
                RUN --mount=type=secret,id=mysecret,dst=/foobar cat /foobar

       The  secret  needs  to  be  passed  to  the build using the --secret flag. The final image built does not
       container the secret file:

        buildah build --no-cache --secret id=mysecret,src=mysecret.txt .

       -- The <b>RUN</b> instruction executes any commands in a new layer on top of the current
         image and commits the results. The committed image is used for the next step in
         Containerfile.

       -- Layering <b>RUN</b> instructions and generating commits conforms to the core
         concepts of container engines where commits are cheap and containers can be created from
         any point in the history of an image. This is similar to source control.  The
         exec form makes it possible to avoid shell string munging. The exec form makes
         it possible to <b>RUN</b> commands using a base image that does not contain <b><a href="file:/bin/sh">/bin/sh</a></b>.

       Note that the exec form is parsed as a JSON array, which means that you must
         use double-quotes (") around words, not single-quotes (').

       <b>CMD</b>
         -- <b>CMD</b> has three forms:

         # Executable form
         CMD ["executable", "param1", "param2"]`

         # Provide default arguments to ENTRYPOINT
         CMD ["param1", "param2"]`

         # the command is run in a shell - <a href="file:/bin/sh">/bin/sh</a> -c
         CMD command param1 param2

       -- There should be only one <b>CMD</b> in a Containerfile. If more than one <b>CMD</b> is listed, only
         the last <b>CMD</b> takes effect.
         The main purpose of a <b>CMD</b> is to provide defaults for an executing container.
         These defaults may include an executable, or they can omit the executable. If
         they omit the executable, an <b>ENTRYPOINT</b> must be specified.
         When used in the shell or exec formats, the <b>CMD</b> instruction sets the command to
         be executed when running the image.
         If you use the shell form of the <b>CMD</b>, the <b>&lt;command&gt;</b> executes in <b><a href="file:/bin/sh">/bin/sh</a></b> <b>-c</b>:

       Note that the exec form is parsed as a JSON array, which means that you must
         use double-quotes (") around words, not single-quotes (').

         FROM ubuntu
         CMD echo "This is a test." | wc -

       -- If you run <b>command</b> without a shell, then you must express the command as a
         JSON array and give the full path to the executable. This array form is the
         preferred form of <b>CMD</b>. All additional parameters must be individually expressed
         as strings in the array:

         FROM ubuntu
         CMD ["<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a>","--help"]

       -- To make the container run the same executable every time, use <b>ENTRYPOINT</b> in
         combination with <b>CMD</b>.
         If the user specifies arguments to <b>podman</b> <b>run</b> or <b>docker</b> <b>run</b>, the specified commands
         override the default in <b>CMD</b>.
         Do not confuse <b>RUN</b> with <b>CMD</b>. <b>RUN</b> runs a command and commits the result.
         <b>CMD</b> executes nothing at build time, but specifies the intended command for
         the image.

       <b>LABEL</b>
         -- <b>LABEL</b> <b>&lt;key&gt;=&lt;value&gt;</b> <b>[&lt;key&gt;=&lt;value&gt;</b> <b>...]</b>or

         LABEL &lt;key&gt;[ &lt;value&gt;]
         LABEL &lt;key&gt;[ &lt;value&gt;]
         ...

       The <b>LABEL</b> instruction adds metadata to an image. A <b>LABEL</b> is a
         key-value pair. To specify a <b>LABEL</b> without a value, simply use an empty
         string. To include spaces within a <b>LABEL</b> value, use quotes and
         backslashes as you would in command-line parsing.

         LABEL com.example.vendor="ACME Incorporated"
         LABEL com.example.vendor "ACME Incorporated"
         LABEL com.example.vendor.is-beta ""
         LABEL com.example.vendor.is-beta=
         LABEL com.example.vendor.is-beta=""

       An image can have more than one label. To specify multiple labels, separate
         each key-value pair by a space.

       Labels are additive including <b>LABEL</b>s in <b>FROM</b> images. As the system
         encounters and then applies a new label, new <b>key</b>s override any previous
         labels with identical keys.

       To display an image's labels, use the <b>buildah</b> <b>inspect</b> command.

       <b>EXPOSE</b>
         -- <b>EXPOSE</b> <b>&lt;port&gt;</b> <b>[&lt;port&gt;...]</b>
         The <b>EXPOSE</b> instruction informs the container engine that the container listens on the
         specified network ports at runtime. The container engine uses this information to
         interconnect containers using links and to set up port redirection on the host
         system.

       <b>ENV</b>
         -- <b>ENV</b> <b>&lt;key&gt;</b> <b>&lt;value&gt;</b>
         The <b>ENV</b> instruction sets the environment variable  to
         the value <b>&lt;value&gt;</b>. This value is passed to all future
         <b>RUN</b>, <b>ENTRYPOINT</b>, and <b>CMD</b> instructions. This is
         functionally equivalent to prefixing the command with <b>&lt;key&gt;=&lt;value&gt;</b>.  The
         environment variables that are set with <b>ENV</b> persist when a container is run
         from the resulting image. Use <b>podman</b> <b>inspect</b> to inspect these values, and
         change them using <b>podman</b> <b>run</b> <b>--env</b> <b>&lt;key&gt;=&lt;value&gt;</b>.

       Note that setting "<b>ENV</b> <b>DEBIAN_FRONTEND=noninteractive</b>" may cause
         unintended consequences, because it will persist when the container is run
         interactively, as with the following command: <b>podman</b> <b>run</b> <b>-t</b> <b>-i</b> <b>image</b> <b>bash</b>

       <b>ADD</b>
         -- <b>ADD</b> has two forms:

         ADD &lt;src&gt; &lt;dest&gt;

         # Required for paths with whitespace
         ADD ["&lt;src&gt;",... "&lt;dest&gt;"]

       The <b>ADD</b> instruction copies new files, directories
         or remote file URLs to the filesystem of the container at path <b>&lt;dest&gt;</b>.
         Multiple <b>&lt;src&gt;</b> resources may be specified but if they are files or directories
         then they must be relative to the source directory that is being built
         (the context of the build). The <b>&lt;dest&gt;</b> is the absolute path, or path relative
         to <b>WORKDIR</b>, into which the source is copied inside the target container.
         If the <b>&lt;src&gt;</b> argument is a local file in a recognized compression format
         (tar, gzip, bzip2, etc) then it is unpacked at the specified <b>&lt;dest&gt;</b> in the
         container's filesystem.  Note that only local compressed files will be unpacked,
         i.e., the URL download and archive unpacking features cannot be used together.
         All new directories are created with mode 0755 and with the uid and gid of <b>0</b>.

       <b>COPY</b>
         -- <b>COPY</b> has two forms:

         COPY [--chown=&lt;user&gt;:&lt;group&gt;] [--chmod=&lt;mode&gt;] &lt;src&gt; &lt;dest&gt;

         # Required for paths with whitespace
         COPY [--chown=&lt;user&gt;:&lt;group&gt;] [--chmod=&lt;mode&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]

       The <b>COPY</b> instruction copies new files from <b>&lt;src&gt;</b> and
         adds them to the filesystem of the container at path . The <b>&lt;src&gt;</b> must be
         the path to a file or directory relative to the source directory that is
         being built (the context of the build) or a remote file URL. The <b>&lt;dest&gt;</b> is an
         absolute path, or a path relative to <b>WORKDIR</b>, into which the source will
         be copied inside the target container. If you <b>COPY</b> an archive file it will
         land in the container exactly as it appears in the build context without any
         attempt to unpack it.  All new files and directories are created with mode <b>0755</b>
         and with the uid and gid of <b>0</b>.

       <b>--chown=&lt;user&gt;:&lt;group&gt;</b> changes the ownership of new files and directories.
         Supports names, if defined in the containers <b><a href="file:/etc/passwd">/etc/passwd</a></b> and <b>/etc/groups</b> files, or using
         uid and gid integers. The build will fail if a user or group name can't be mapped in the container.
         Numeric id's are set without looking them up in the container.

       <b>--chmod=&lt;mode&gt;</b> changes the mode of new files and directories.

       The optional flag <b>--from=name</b> can be used to copy files from a named previous build stage. It
         changes the context of <b>&lt;src&gt;</b> from the build context to the named build stage.

       <b>ENTRYPOINT</b>
         -- <b>ENTRYPOINT</b> has two forms:

         # executable form
         ENTRYPOINT ["executable", "param1", "param2"]`

         # run command in a shell - <a href="file:/bin/sh">/bin/sh</a> -c
         ENTRYPOINT command param1 param2

       -- An <b>ENTRYPOINT</b> helps you configure a
         container that can be run as an executable. When you specify an <b>ENTRYPOINT</b>,
         the whole container runs as if it was only that executable.  The <b>ENTRYPOINT</b>
         instruction adds an entry command that is not overwritten when arguments are
         passed to <b>podman</b> <b>run</b>. This is different from the behavior of <b>CMD</b>. This allows
         arguments to be passed to the entrypoint, for instance <b>podman</b> <b>run</b> <b>&lt;image&gt;</b> <b>-d</b>
         passes the -d argument to the <b>ENTRYPOINT</b>.  Specify parameters either in the
         <b>ENTRYPOINT</b> JSON array (as in the preferred exec form above), or by using a <b>CMD</b>
         statement.  Parameters in the <b>ENTRYPOINT</b> are not overwritten by the <b>podman</b> <b>run</b>  arguments.   Parameters
       specified  via  <b>CMD</b>  are overwritten by <b>podman</b> <b>run</b> arguments.  Specify a plain string for the <b>ENTRYPOINT</b>,
       and it will execute in
         <b><a href="file:/bin/sh">/bin/sh</a></b> <b>-c</b>, like a <b>CMD</b> instruction:

         FROM ubuntu
         ENTRYPOINT wc -l -

       This means that the Containerfile's image always takes stdin as input (that's
         what "-" means), and prints the number of lines (that's what "-l" means). To
         make this optional but default, use a <b>CMD</b>:

         FROM ubuntu
         CMD ["-l", "-"]
         ENTRYPOINT ["<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a>"]

       <b>VOLUME</b>
         -- <b>VOLUME</b> <b>["/data"]</b>
         The <b>VOLUME</b> instruction creates a mount point with the specified name and marks
         it as holding externally-mounted volumes from the native host or from other
         containers.

       <b>USER</b>
         -- <b>USER</b> <b>daemon</b>
         Sets the username or UID used for running subsequent commands.

       The <b>USER</b> instruction can optionally be used to set the group or GID. The
         following examples are all valid:
         USER [user | user:group | uid | uid:gid | user:gid | uid:group ]

       Until the <b>USER</b> instruction is set, instructions will be run as root. The USER
         instruction can be used any number of times in a Containerfile, and will only affect
         subsequent commands.

       <b>WORKDIR</b>
         -- <b>WORKDIR</b> <b>/path/to/workdir</b>
         The <b>WORKDIR</b> instruction sets the working directory for the <b>RUN</b>, <b>CMD</b>,
         <b>ENTRYPOINT</b>, <b>COPY</b> and <b>ADD</b> Containerfile commands that follow it. It can
         be used multiple times in a single Containerfile. Relative paths are defined
         relative to the path of the previous <b>WORKDIR</b> instruction. For example:

         WORKDIR /a
         WORKDIR b
         WORKDIR c
         RUN pwd

       In the above example, the output of the <b>pwd</b> command is <b>a/b/c</b>.

       <b>ARG</b>
          -- <b>ARG</b> <b>&lt;name&gt;[=&lt;default</b> <b>value&gt;]</b>

       The <b>ARG</b> instruction defines a variable that users can pass at build-time to
         the builder with the <b>podman</b> <b>build</b> and <b>buildah</b> <b>build</b> commands using the
         <b>--build-arg</b> <b>&lt;varname&gt;=&lt;value&gt;</b> flag. If a user specifies a build argument that
         was not defined in the Containerfile, the build outputs a warning.

       Note that a second FROM in a Containerfile sets the values associated with an
         Arg variable to nil and they must be reset if they are to be used later in
         the Containerfile

         [Warning] One or more build-args [foo] were not consumed

       The Containerfile author can define a single variable by specifying <b>ARG</b> once or many
         variables by specifying <b>ARG</b> more than once. For example, a valid Containerfile:

         FROM busybox
         ARG user1
         ARG buildno
         ...

       A Containerfile author may optionally specify a default value for an <b>ARG</b> instruction:

         FROM busybox
         ARG user1=someuser
         ARG buildno=1
         ...

       If an <b>ARG</b> value has a default and if there is no value passed at build-time, the
         builder uses the default.

       An <b>ARG</b> variable definition comes into effect from the line on which it is
         defined in the <b>Containerfile</b> not from the argument's use on the command-line or
         elsewhere.  For example, consider this Containerfile:

         1 FROM busybox
         2 USER ${user:-some_user}
         3 ARG user
         4 USER $user
         ...

       A user builds this file by calling:

         $ podman build --build-arg user=what_user Containerfile

       The <b>USER</b> at line 2 evaluates to <b>some_user</b> as the <b>user</b> variable is defined on the
         subsequent line 3. The <b>USER</b> at line 4 evaluates to <b>what_user</b> as <b>user</b> is
         defined and the <b>what_user</b> value was passed on the command line. Prior to its definition by an
         <b>ARG</b> instruction, any use of a variable results in an empty string.

              <b>Warning:</b> It is not recommended to use build-time variables for
               passing secrets like github keys, user credentials etc. Build-time variable
               values are visible to any user of the image with the <b>podman</b> <b>history</b> command.

       You can use an <b>ARG</b> or an <b>ENV</b> instruction to specify variables that are
         available to the <b>RUN</b> instruction. Environment variables defined using the
         <b>ENV</b> instruction always override an <b>ARG</b> instruction of the same name. Consider
         this Containerfile with an <b>ENV</b> and <b>ARG</b> instruction.

         1 FROM ubuntu
         2 ARG CONT_IMG_VER
         3 ENV CONT_IMG_VER=v1.0.0
         4 RUN echo $CONT_IMG_VER

       Then, assume this image is built with this command:

         $ podman build --build-arg CONT_IMG_VER=v2.0.1 Containerfile

       In this case, the <b>RUN</b> instruction uses <b>v1.0.0</b> instead of the <b>ARG</b> setting
         passed by the user:<b>v2.0.1</b> This behavior is similar to a shell
         script where a locally scoped variable overrides the variables passed as
         arguments or inherited from environment, from its point of definition.

       Using the example above but a different <b>ENV</b> specification you can create more
         useful interactions between <b>ARG</b> and <b>ENV</b> instructions:

         1 FROM ubuntu
         2 ARG CONT_IMG_VER
         3 ENV CONT_IMG_VER=${CONT_IMG_VER:-v1.0.0}
         4 RUN echo $CONT_IMG_VER

       Unlike an <b>ARG</b> instruction, <b>ENV</b> values are always persisted in the built
         image. Consider a <b>podman</b> <b>build</b> without the --build-arg flag:

         $ podman build Containerfile

       Using this Containerfile example, <b>CONT_IMG_VER</b> is still persisted in the image but
         its value would be <b>v1.0.0</b> as it is the default set in line 3 by the <b>ENV</b> instruction.

       The variable expansion technique in this example allows you to pass arguments
         from the command line and persist them in the final image by leveraging the
         <b>ENV</b> instruction. Variable expansion is only supported for a limited set of
         Containerfile instructions.  ⟨#environment-replacement⟩

       Container engines have a set of predefined <b>ARG</b> variables that you can use without a
         corresponding <b>ARG</b> instruction in the Containerfile.

              • <b>HTTP_PROXY</b>

              • <b>http_proxy</b>

              • <b>HTTPS_PROXY</b>

              • <b>https_proxy</b>

              • <b>FTP_PROXY</b>

              • <b>ftp_proxy</b>

              • <b>NO_PROXY</b>

              • <b>no_proxy</b>

              • <b>ALL_PROXY</b>

              • <b>all_proxy</b>

       To use these, pass them on the command line using <b>--build-arg</b> flag, for
         example:

         $ podman build --build-arg HTTPS_PROXY=https://my-proxy.example.com .

       <b>Platform/OS/Arch</b> <b>ARG</b>
          -- <b>ARG</b> <b>&lt;name&gt;</b>

       When building multi-arch manifest-lists or images for a foreign-architecture,
         it's often helpful to have access to platform details within the <b>Containerfile</b>.
         For example, when using a <b>RUN</b> <b>curl</b> <b>...</b> command to install OS/Arch specific
         binary into the image.  Or, if certain <b>RUN</b> operations are known incompatible
         or non-performant when emulating a specific architecture.

       There are several named <b>ARG</b> variables available. The purpose of each should be
         self-evident by its name.  <u>However</u>, in all cases these ARG values are <b>not</b>
         automatically populated.  You must always declare them within each <b>FROM</b> section
         of the <b>Containerfile</b>.

       The available <b>ARG</b> <b>&lt;name&gt;</b> variables are available with two prefixes:

              • <b>TARGET...</b> variable names represent details about  the  currently  running  build  context  (i.e.
                "inside" the container).  These are often the most useful:

                • <b>TARGETOS</b>: For example <b>linux</b>

                • <b>TARGETARCH</b>: For example <b>amd64</b>

                • <b>TARGETPLATFORM</b>: For example <b>linux/amd64</b>

                • <b>TARGETVARIANT</b>: Uncommonly used, specific to <b>TARGETARCH</b>

              • <b>BUILD...</b>  variable names signify details about the <u>host</u> performing the build (i.e. "outside" the
                container):

                • <b>BUILDOS</b>: OS of host performing the build

                • <b>BUILDARCH</b>: Arch of host performing the build

                • <b>BUILDPLATFORM</b>: Combined OS/Arch of host performing the build

                • <b>BUILDVARIANT</b>: Uncommonly used, specific to <b>BUILDARCH</b>

       An example <b>Containerfile</b> that uses <b>TARGETARCH</b> to fetch an arch-specific binary could be:

         FROM busybox
         ARG TARGETARCH
         RUN curl -sSf -O https://example.com/downloads/bin-${TARGETARCH}.zip

       Assuming the host platform is <b>linux/amd64</b> and foreign-architecture emulation
         enabled (e.g. <b>qemu-user-static</b>), then running the command:

         $ podman build --platform linux/s390x .

       Would end up running <b>curl</b> on <b>https://example.com/downloads/bin-s390x.zip</b> and producing
         a container image suited for the the <b>linux/s390x</b> platform.  <b>Note:</b> Emulation isn't
         strictly required, these special build-args will also function when building using
         <b>podman</b> <b>farm</b> <b>build</b>.

       <b>ONBUILD</b>
         -- <b>ONBUILD</b> <b>[INSTRUCTION]</b>
         The <b>ONBUILD</b> instruction adds a trigger instruction to an image. The
         trigger is executed at a later time, when the image is used as the base for
         another build. Container engines execute the trigger in the context of the downstream
         build, as if the trigger existed immediately after the <b>FROM</b> instruction in
         the downstream Containerfile.

       You can register any build instruction as a trigger. A trigger is useful if
         you are defining an image to use as a base for building other images. For
         example, if you are defining an application build environment or a daemon that
         is customized with a user-specific configuration.

       Consider an image intended as a reusable python application builder. It must
         add application source code to a particular directory, and might need a build
         script called after that. You can't just call <b>ADD</b> and <b>RUN</b> now, because
         you don't yet have access to the application source code, and it is different
         for each application build.

       -- Providing application developers with a boilerplate Containerfile to copy-paste
         into their application is inefficient, error-prone, and
         difficult to update because it mixes with application-specific code.
         The solution is to use <b>ONBUILD</b> to register instructions in advance, to
         run later, during the next build stage.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/buildah.1.html">buildah</a>(1), <a href="../man1/podman.1.html">podman</a>(1), <a href="../man1/docker.1.html">docker</a>(1)

</pre><h4><b>HISTORY</b></h4><pre>
       May 2014, Compiled by Zac Dover (zdover at redhat dot com) based on docker.com Dockerfile documentation.
       Feb 2015, updated by Brian Goff (<a href="mailto:cpuguy83@gmail.com">cpuguy83@gmail.com</a>) for readability
       Sept 2015, updated by Sally O'Malley (<a href="mailto:somalley@redhat.com">somalley@redhat.com</a>)
       Oct 2016, updated by Addam Hardy (<a href="mailto:addam.hardy@gmail.com">addam.hardy@gmail.com</a>)
       Aug 2021, converted Dockerfile man page to Containerfile by Dan Walsh (<a href="mailto:dwalsh@redhat.com">dwalsh@redhat.com</a>)

                                                    Aug 2021                                    <u><a href="../man5/CONTAINERFILE.5.html">CONTAINERFILE</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>