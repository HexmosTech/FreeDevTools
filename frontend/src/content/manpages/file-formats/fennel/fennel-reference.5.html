<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fennel-reference - Fennel Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/fennel">fennel_1.5.3+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fennel-reference - Fennel Reference

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  document  covers  the syntax, built-in macros, and special forms recognized by the Fennel compiler.
       It does not include built-in Lua functions;  see  the  Lua  reference  manual  (https://www.lua.org/manu‐
       al/5.1/)  or  the  Lua primer (https://fennel-lang.org/lua-primer) for that.  This is not an introductory
       text; see the tutorial (https://fennel-lang.org/tutorial) for that.  If you already have a piece  of  Lua
       code you just want to see translated to Fennel, use antifennel (https://fennel-lang.org/see).

       A  macro  is a function which runs at compile time and transforms some Fennel code into different Fennel.
       A special form (or special) is a primitive construct which emits Lua code directly.  When you are coding,
       you don't need to care about the difference between built-in macros and special forms; it is an implemen‐
       tation detail.

       Remember that Fennel relies completely on Lua for its runtime.  Everything Fennel does  happens  at  com‐
       pile-time,  so  you  will need to familiarize yourself with Lua's standard library functions.  Thankfully
       it's much smaller than almost any other language.

       The one exception to this compile-time rule is the <b>fennel.view</b> function which returns a string  represen‐
       tation  of  any  Fennel data suitable for printing.  But this is not part of the language itself; it is a
       library function which can be used from Lua just as easily.

       Fennel source code should be UTF-8-encoded text.

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>(parentheses)</b>: used to delimit lists, which are primarily used to denote calls to functions, macros,  and
       specials,  but also can be used in binding contexts to bind to multiple values.  Lists are a compile-time
       construct; they are not used at runtime.  For example: <b>(print</b> <b>"hello</b> <b>world")</b>

       <b>{curly</b> <b>brackets}</b>: used to denote key/value table literals, also known as dictionaries.  For example:  <b>{:a</b>
       <b>1</b>  <b>:b</b> <b>2}</b> In a table if you have a string key followed by a symbol of the same name as the string, you can
       use <b>:</b> as the key and it will be expanded to a string containing the name of the following symbol.

              {: this} ; is shorthand for {:this this}

       <b>[square</b> <b>brackets]</b>: used to denote sequential tables, which can be used for literal  data  structures  and
       also  in  specials  and macros to delimit where new identifiers are introduced, such as argument lists or
       let bindings.  For example: <b>[1</b> <b>2</b> <b>3]</b>

       The syntax for numbers is the same as Lua's (https://www.lua.org/manual/5.4/manual.html#3.1), except that
       underscores may be used to separate digits for readability.  Non-ASCII digits are not yet supported.  In‐
       finity and negative infinity are represented as <b>.inf</b> and <b>-.inf</b>.  NaN and negative Nan are <b>.nan</b> and <b>-.nan</b>.

       The syntax for strings uses double-quotes <b>"</b> around the string's contents.  Double quotes inside a  string
       must  be  escaped with backslashes.  The syntax for these is the same as Lua's (https://www.lua.org/manu‐
       al/5.4/manual.html#3.1), except that strings may  contain  newline  characters.   Single-quoted  or  long
       bracket strings are not supported.

       Fennel has a lot fewer restrictions on identifiers than Lua.  Identifiers are represented by symbols, but
       identifiers  are  not  exactly the same as symbols; some symbols are used by macros for things other than
       identifiers.  Symbols may not begin with digits or a colon, but may have digits  anywhere  else.   Beyond
       that,  any  unicode characters are accepted as long as they are not unprintable or whitespace, one of the
       delimiter characters mentioned above, one of the a prefix characters listed below, or one  of  these  re‐
       served characters:

       • single quote: <b>'</b>

       • tilde: <b>~</b>

       • semicolon: <b>;</b>

       • at: <b>@</b>

       Underscores are allowed in identifier names, but dashes are preferred as word separators.  By convention,
       identifiers  starting  with  underscores  are  used to indicate that a local is bound but not meant to be
       used.

       The ampersand character <b>&amp;</b> is allowed in symbols but not in identifiers.  This allows it  to  be  reserved
       for macros, like the behavior of <b>&amp;as</b> in destructuring.

       Symbols  that  contain  a dot <b>.</b> or colon <b>:</b> are considered "multi symbols".  The part of the symbol before
       the first dot or colon is used as an identifier, and the part after the dot or colon is a field looked up
       on the local identified.  A colon is only allowed before the final segment of a multi symbol, so <b>x.y:z</b> is
       valid but <b>a:b.c</b> is not.  Colon multi symbols can only be used for method calls.

       Fennel also supports certain kinds of strings that begin with a colon as long as they don't  contain  any
       characters  which wouldn't be allowed in a symbol, for example <b>:fennel-lang.org</b> is another way of writing
       the string "fennel-lang.org".

       Spaces, tabs, newlines, vertical tabs, form feeds, and carriage returns are counted as whitespace.   Non-
       ASCII whitespace characters are not yet supported.

       Certain prefixes are expanded by the parser into longhand equivalents:

       • <b>#foo</b> expands to <b>(hashfn</b> <b>foo)</b>

       • <b>`foo</b> expands to <b>(quote</b> <b>foo)</b>

       • <b>,foo</b> expands to <b>(unquote</b> <b>foo)</b>

       A semicolon and everything following it up to the end of the line is a comment.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>fn</b> function
       Creates a function which binds the arguments given inside the square brackets.  Will accept any number of
       arguments;  ones  in excess of the declared ones are ignored, and if not enough arguments are supplied to
       cover the declared ones, the remaining ones are given values of <b>nil</b>.

       Example:

              (fn pxy [x y]
                (print (+ x y)))

       Giving it a name is optional; if one is provided it will be bound to it as a local.  The  following  mean
       exactly the same thing; the first is preferred mostly for indentation reasons, but also because it allows
       recursion:

              (fn pxy [x y]
                (print (+ x y)))

              (local pxy (fn [x y]
                           (print (+ x y))))

       Providing  a  name that's a table field will cause it to be inserted in a table instead of bound as a lo‐
       cal:

              (local functions {})

              (fn functions.p [x y z]
                (print (* x (+ y z))))

              ;; equivalent to:
              (set functions.p (fn [x y z]
                                 (print (* x (+ y z)))))

       Like Lua, functions in Fennel support tail-call optimization, allowing (among other things) functions  to
       recurse indefinitely without overflowing the stack, provided the call is in a tail position.

       The final form in this and all other function forms is used as the return value.

   <b>lambda</b>/<b>λ</b> nil-checked function
       Creates  a  function like <b>fn</b> does, but throws an error at runtime if any of the listed arguments are nil,
       unless its identifier begins with <b>?</b>.

       Example:

              (lambda [x ?y z]
                (print (- x (* (or ?y 1) z))))

       Note that the Lua runtime will fill in missing arguments with nil when  they  are  not  provided  by  the
       caller, so an explicit nil argument is no different than omitting an argument.

       Programmers  coming from other languages in which it is an error to call a function with a different num‐
       ber of arguments than it is defined with often get tripped up by the behavior of <b>fn</b>.  This is where <b>lamb‐</b>
       <b>da</b> is most useful.

       The <b>lambda</b>, <b>case</b>, <b>case-try</b>, <b>match</b> and <b>match-try</b> forms are the only place where the <b>?foo</b> notation is  used
       by  the  compiler to indicate that a nil value is allowed, but it is a useful notation to communicate in‐
       tent anywhere a new local is introduced.

       The <b>λ</b> form is an alias for <b>lambda</b> and behaves identically.

   <b>Docstrings</b> <b>and</b> <b>metadata</b>
       The <b>fn</b>, <b>lambda</b>, <b>λ</b> and <b>macro</b> forms accept an optional docstring.

              (fn pxy [x y]
                "Print the sum of x and y"
                (print (+ x y)))

              (λ pxyz [x ?y z]
                "Print the sum of x, y, and z. If y is not provided, defaults to 0."
                (print (+ x (or ?y 0) z)))

       These are ignored by default outside of the REPL, unless metadata is enabled from the  CLI  (<b>---metadata</b>)
       or  compiler options <b>{useMetadata=true}</b>, in which case they are stored in a metadata table along with the
       arglist, enabling viewing function docs via the <b>doc</b> macro.

              ;; this only works in the repl
              &gt;&gt; ,doc pxy
              (pxy x y)
                Print the sum of x and y

       All function metadata will be garbage collected along with the function  itself.   Docstrings  and  other
       metadata can also be accessed via functions on the fennel API with <b>fennel.doc</b> and <b>fennel.metadata</b>.

       <u>(Since</u> <u>1.1.0)</u>

       All forms that accept a docstring will also accept a metadata table in the same place:

              (fn add [...]
                {:fnl/docstring "Add arbitrary amount of numbers."
                 :fnl/arglist [a b &amp; more]}
                (match (values (select :# ...) ...)
                  (0) 0
                  (1 a) a
                  (2 a b) (+ a b)
                  (_ a b) (add (+ a b) (select 3 ...))))

       Here the arglist is overridden by that in the metadata table (note that the contents of the table are im‐
       plicitly quoted).  Calling <b>,doc</b> command in the REPL prints specified argument list of the next form:

              &gt;&gt; ,doc add
              (add a b &amp; more)
                Add arbitrary amount of numbers.

       <u>(Since</u> <u>1.3.0)</u>

       Arbitrary metadata keys are allowed in the metadata table syntax:

              (fn foo []
                {:deprecated "v1.9.0"
                 :fnl/docstring "*DEPRECATED* use foo2"}
                ;; old way to do stuff
                )

              (fn foo2 [x]
                {:added "v2.0.0"
                 :fnl/docstring "Incompatible but better version of foo!"}
                ;; do stuff better, now with x!
                x)

       In  this  example, the <b>deprecated</b> and <b>added</b> keys are used to store a version of a hypothetical library on
       which the functions were deprecated or added.  External tooling then can leverage this information by us‐
       ing Fennel's metadata API:

              &gt;&gt; (local {: metadata} (require :fennel))
              &gt;&gt; (metadata:get foo :deprecated)
              "v1.9.0"
              &gt;&gt; (metadata:get foo2 :added)
              "v2.0.0"

       Such metadata can be any data literal, including tables, with the only restriction that there are no side
       effects.  Fennel's lists are disallowed as metadata values.

       <u>(Since</u> <u>1.3.1)</u>

       For editing convenience, the metadata table literals are allowed after docstrings:

              (fn some-function [x ...]
                "Docstring for some-function."
                {:fnl/arglist [x &amp; xs]
                 :other :metadata}
                (let [xs [...]]
                  ;; ...
                  ))

       In this case, the documentation string is automatically inserted to the metadata table by the compiler.

       The whole metadata table can be obtained by calling <b>metadata:get</b> without the <b>key</b> argument:

              &gt;&gt; (local {: metadata} (require :fennel))
              &gt;&gt; (metadata:get some-function)
              {:fnl/arglist ["x" "&amp;" "xs"]
               :fnl/docstring "Docstring for some-function."
               :other "metadata"}

       Fennel itself only uses the <b>fnl/docstring</b> and <b>fnl/arglist</b> metadata keys but third-party code can make use
       of arbitrary keys.

   <b>Hash</b> <b>function</b> <b>literal</b> <b>shorthand</b>
       It's pretty easy to create function literals, but Fennel provides an  even  shorter  form  of  functions.
       Hash  functions  are  anonymous functions of one form, with implicitly named arguments.  All of the below
       functions are functionally equivalent:

              (fn [a b] (+ a b))

              (hashfn (+ $1 $2)) ; implementation detail; don't use directly

              #(+ $1 $2)

       This style of anonymous function is useful as a parameter to higher order  functions.   It's  recommended
       only for simple one-line functions that get passed as arguments to other functions.

       The current implementation only allows for hash functions to use up to 9 arguments, each named <b>$1</b> through
       <b>$9</b>,  or  those with varargs, delineated by <b>$...</b> instead of the usual <b>...</b>.  A lone <b>$</b> in a hash function is
       treated as an alias for <b>$1</b>.

       Hash functions are defined with the <b>hashfn</b> macro or special character <b>#</b>, which wraps its single  argument
       in a function literal.  For example,

              #$3               ; same as (fn [x y z] z)
              #[$1 $2 $3]       ; same as (fn [a b c] [a b c])
              #{:a $1 :b $2}    ; same as (fn [a b] {:a a :b b})
              #$                ; same as (fn [x] x) (aka the identity function)
              #val              ; same as (fn [] val)
              #[:one :two $...] ; same as (fn [...] ["one" "two" ...])

       Hash arguments can also be used as parts of multisyms.  For instance, <b>#$.foo</b> is a function which will re‐
       turn the value of the "foo" key in its first argument.

       Unlike regular functions, there is no implicit <b>do</b> in a hash function, and thus it cannot contain multiple
       forms  without an explicit <b>do</b>.  The body itself is directly used as the return value rather than the last
       element in the body.

   <b>partial</b> partial application
       Returns a new function which works like its first argument, but fills the first few  arguments  in  place
       with the given ones.  This is related to currying but different because calling it will call the underly‐
       ing function instead of waiting till it has the "correct" number of args.

       Example:

              (fn add-print [x y] (print (+ x y)))
              (partial add-print 2)

       This  example  returns  a  function  which  will print a number that is 2 greater than the argument it is
       passed.

</pre><h4><b>BINDING</b></h4><pre>
   <b>let</b> scoped locals
       Introduces a new scope in which a given set of local bindings are used.

       Example:

              (let [x 89
                    y 198]
                (print (+ x y 12))) ; =&gt; 299

       These locals cannot be changed with <b>set</b> but they can be shadowed by an inner <b>let</b> or <b>local</b>.   Outside  the
       body  of the <b>let</b>, the bindings it introduces are no longer visible.  The last form in the body is used as
       the return value.

       Any time you bind a local, you can destructure it if the value is a table or a function  call  which  re‐
       turns multiple values:

       Example:

              (let [(x y z) (unpack [10 9 8])]
                (+ x y z)) ; =&gt; 27

       Example:

              (let [[a b c] [1 2 3]]
                (+ a b c)) ; =&gt; 6

       If  a table key is a string with the same name as the local you want to bind to, you can use shorthand of
       just <b>:</b> for the key name followed by the local name.  This works for both creating tables and  destructur‐
       ing them.

       Example:

              (let [{:msg message : val} {:msg "hello there" :val 19}]
                (print message)
                val) ; prints "hello there" and returns 19

       When destructuring a sequential table, you can capture all the remainder of the table in a local by using
       <b>&amp;</b>:

       Example:

              (let [[a b &amp; c] [1 2 3 4 5 6]]
                (table.concat c ",")) ; =&gt; "3,4,5,6"

       <u>(Since</u> <u>1.3.0)</u>: This also works with function argument lists, but it has a small performance cost, so it's
       recommended to use <b>...</b> instead in cases that are sensitive to overhead.

       When  destructuring a non-sequential table, you can capture the original table along with the destructur‐
       ing by using <b>&amp;as</b>:

       Example:

              (let [{:a a :b b &amp;as all} {:a 1 :b 2 :c 3 :d 4}]
                (+ a b all.c all.d)) ; =&gt; 10

   <b>local</b> declare local
       Introduces a new local inside an existing scope.  Similar to <b>let</b> but without a body argument.  Recommend‐
       ed for use at the top-level of a file for locals which will be used throughout the file.

       Example:

              (local tau-approx 6.28318)

       Supports destructuring and multiple-value binding.

   <b>case</b> pattern matching
       <u>(Since</u> <u>1.3.0)</u>

       Evaluates its first argument, then searches thru the subsequent pattern/body clauses to  find  one  where
       the  pattern matches the value, and evaluates the corresponding body.  Pattern matching can be thought of
       as a combination of destructuring and conditionals.

       <b>Note</b>: Lua also has "patterns" which are matched against strings similar to how regular  expressions  work
       in other languages; these are two distinct concepts with similar names.

       Example:

              (case mytable
                59      :will-never-match-hopefully
                [9 q 5] (print :q q)
                [1 a b] (+ a b))

       In the example above, we have a <b>mytable</b> value followed by three pattern/body clauses.

       The first clause will only match if <b>mytable</b> is 59.

       The  second clause will match if <b>mytable</b> is a table with 9 as its first element, any non-nil value as its
       second value and 5 as its third element; if it matches, then it evaluates <b>(print</b> <b>:q</b> <b>q)</b> with  <b>q</b>  bound  to
       the second element of <b>mytable</b>.

       The  final  clause will only match if <b>mytable</b> has 1 as its first element and two non-nil values after it;
       if so then it will add up the second and third elements.

       If no clause matches, the form evaluates to nil.

       Patterns can be tables, literal values, or symbols.  Any symbol is implicitly  checked  to  be  not  <b>nil</b>.
       Symbols can be repeated in an expression to check for the same value.

       Example:

              (case mytable
                ;; the first and second values of mytable are not nil and are the same value
                [a a] (* a 2)
                ;; the first and second values are not nil and are not the same value
                [a b] (+ a b))

       It's  important  to  note  that  expressions  are  checked <u>in</u> <u>order!</u> In the above example, since <b>[a</b> <b>a]</b> is
       checked first, we can be confident that when <b>[a</b> <b>b]</b> is checked, the two values must be different.  Had the
       order been reversed, <b>[a</b> <b>b]</b> would always match as long as they're not <b>nil</b> - even if  they  have  the  same
       value!

       You may allow a symbol to optionally be <b>nil</b> by prefixing it with <b>?</b>.

       Example:

              (case mytable
                ;; not-nil, maybe-nil
                [a ?b] :maybe-one-maybe-two-values
                ;; maybe-nil == maybe-nil, both are nil or both are the same value
                [?a ?a] :maybe-none-maybe-two-same-values
                ;; maybe-nil, maybe-nil
                [?a ?b] :maybe-none-maybe-one-maybe-two-values)

       Symbols  prefixed  by  an  <b>_</b> are ignored and may stand in as positional placeholders or markers for "any"
       value - including a <b>nil</b> value.  A single <b>_</b> is also often used at the end of a <b>case</b> expression  to  define
       an "else" style fall-through value.

       Example:

              (case mytable
                ;; not-nil, anything
                [a _b] :maybe-one-maybe-two-values
                ;; anything, anything (different to the previous ?a example!)
                ;; note this is effectively the same as []
                [_a _a] :maybe-none-maybe-one-maybe-two-values
                ;; anything, anything
                ;; this is identical to [_a _a] and in this example would never actually match.
                [_a _b] :maybe-none-maybe-one-maybe-two-values
                ;; when no other clause matched, in this case any non-table value
                _ :no-match)

       Tables  can  be nested, and they may be either sequential (<b>[]</b> style) or key/value (<b>{}</b> style) tables.  Se‐
       quential tables will match if they have at least as many elements as the pattern.  (To allow  an  element
       to be nil, see <b>?</b> and <b>_</b> as above.)  Tables will <u>never</u> fail to match due to having too many elements - this
       means <b>[]</b> matches <u>any</u> table, not an <u>empty</u> table.  You can use <b>&amp;</b> to capture all the remaining elements of a
       sequential table, just like <b>let</b>.

              (case mytable
                {:subtable [a b ?c] :depth depth} (* b depth)
                _ :unknown)

       You  can  also match against multiple return values using parentheses.  (These cannot be nested, but they
       can contain tables.)  This can be useful for error checking.

              (case (io.open "/some/file")
                (nil msg) (report-error msg)
                f (read-file f))

   <b>Guard</b> <b>Clauses</b>
       Sometimes you need to match on something more general than a structure or specific value.  In these cases
       you can use guard clauses:

              (case [91 12 53]
                (where [a b c] (= 5 a)) :will-not-match
                (where [a b c] (= 0 (math.fmod (+ a b c) 2)) (= 91 a)) c) ; -&gt; 53

       In this case the pattern should be wrapped in parentheses (like when matching  against  multiple  values)
       but  the first thing in the parentheses is the <b>where</b> symbol.  Each form after the pattern is a condition;
       all the conditions must evaluate to true for that pattern to match.

       If several patterns share the same body and guards, such patterns can be combined with <b>or</b> special in  the
       <b>where</b> clause:

              (case [5 1 2]
                (where (or [a 3 9] [a 1 2]) (= 5 a)) "Either [5 3 9] or [5 1 2]"
                _ "anything else")

       This is essentially equivalent to:

              (case [5 1 2]
                (where [a 3 9] (= 5 a)) "Either [5 3 9] or [5 1 2]"
                (where [a 1 2] (= 5 a)) "Either [5 3 9] or [5 1 2]"
                _ "anything else")

       However, patterns which bind variables should not be combined with <b>or</b> if different variables are bound in
       different patterns or some variables are missing:

              ;; bad
              (case [1 2 3]
                ;; Will throw an error because `b' is nil for the first
                ;; pattern but the guard still uses it.
                (where (or [a 1 2] [a b 3]) (&lt; a 0) (&lt; b 1))
                :body)

              ;; ok
              (case [1 2 3]
                (where (or [a b 2] [a b 3]) (&lt; a 0) (&lt;= b 1))
                :body)

   <b>Binding</b> <b>Pinning</b>
       Symbols  bound inside a <b>case</b> pattern are independent from any existing symbols in the current scope, that
       is - names may be re-used without consequence.

       Example:

              (let [x 1]
                (case [:hello]
                  ;; `x` is simply bound to the first value of [:hello]
                  [x] x)) ; -&gt; :hello

       Sometimes it may be desirable to match against an existing value in the outer scope.  To do this  we  can
       "pin"  a  binding inside the pattern with an existing outer binding with the unary <b>(=</b> <b>binding-name)</b> form.
       The unary <b>(=</b> <b>binding-name)</b> form is <u>only</u> valid in a <b>case</b> pattern and <u>must</u> be inside a <b>(where)</b> guard.

       Example:

              (let [x 1]
                (case [:hello]
                  ;; 1 != :hello
                  (where [(= x)]) x
                  _ :no-match)) ; -&gt; no-match

              (let [x 1]
                (case [1]
                  ;; 1 == 1
                  (where [(= x)]) x
                  _ :no-match)) ; -&gt; 1

              (let [pass :hunter2]
                (case (user-input)
                  (where (= pass)) :login
                  _ :try-again!))

       Pinning is only required inside the pattern.  Outer bindings are automatically  available  inside  guards
       and bodies as long as the name has not been rebound in the pattern.

       <b>Note:</b>  The  <b>case</b>  macro can be used in place of the <b>if-let</b> macro from Clojure.  The reason Fennel doesn't
       have <b>if-let</b> is that <b>case</b> makes it redundant.

   <b>match</b> pattern matching
       <b>match</b> is conceptually equivalent to <b>case</b>, except symbols in the patterns are always  pinned  with  outer-
       scope symbols if they exist.

       It  supports all the same syntax as described in <b>case</b> except the pin (<b>(=</b> <b>binding-name)</b>) expression, as it
       is always performed.

              Be careful when using <b>match</b> that your symbols are not accidentally the same as any  existing  sym‐
              bols!   If  you  know you don't intend to pin any existing symbols you should use the <b>case</b> expres‐
              sion.

              (let [x 95]
               (match [52 85 95]
                 [b a a] :no ; because a=85 and a=95
                 [x y z] :no ; because x=95 and x=52
                 [a b x] :yes)) ; a and b are fresh values while x=95 and x=95

       Unlike in <b>case</b>, if an existing binding has the value <b>nil</b>, the <b>?</b> prefix is not necessary -  it  would  in‐
       stead create a new un-pinned binding!

       Example:

              (let [name nil
                    get-input (fn [] "Dave")]
                (match (get-input)
                  ;; name already exists as nil, "Dave" != nil so this *wont* match
                  name (.. "Hello " name)
                  ?no-input (.. "Hello anonymous"))) ; -&gt; "Hello anonymous"

       <b>Note:</b>  Prior  to  Fennel 0.9.0 the <b>match</b> macro used infix <b>?</b> operator to test patterns against the guards.
       While this syntax is still supported, <b>where</b> should be preferred instead:

              (match [1 2 3]
                (where [a 2 3] (&lt; 0 a)) "new guard syntax"
                ([a 2 3] ? (&lt; 0 a)) "obsolete guard syntax")

   <b>case-try</b> for matching multiple steps
       Evaluates a series of pattern matching steps.  The value from the first expression is matched against the
       first pattern.  If it matches, the first body is evaluated and its value is matched  against  the  second
       pattern, etc.

       If  there  is  a  <b>(catch</b>  <b>pat1</b> <b>body1</b> <b>pat2</b> <b>body2</b> <b>...)</b> form at the end, any mismatch from the steps will be
       tried against these patterns in sequence as a fallback just like a normal  <b>case</b>.   If  no  <b>catch</b>  pattern
       matches, nil is returned.

       If there is no catch, the mismatched value will be returned as the value of the entire expression.

              (fn handle [conn token]
                (case-try (conn:receive :*l)
                  input (parse input)
                  (command-name params (= token)) (commands.get command-name)
                  command (pcall command (table.unpack params))
                  (catch
                   (_ :timeout) nil
                   (_ :closed) (pcall disconnect conn "connection closed")
                   (_ msg) (print "Error handling input" msg))))

       This  is  useful  when  you want to perform a series of steps, any of which could fail.  The <b>catch</b> clause
       lets you keep all your error handling in one place.  Note that there are two ways to indicate failure  in
       Fennel  and Lua: using the <b>assert</b>/<b>error</b> functions or returning nil followed by some data representing the
       failure.  This form only works on the latter, but you can use <b>pcall</b> to transform <b>error</b> calls into values.

   <b>match-try</b> for matching multiple steps
       Equivalent to <b>case-try</b> but uses <b>match</b> internally.  See <b>case</b> and <b>match</b> for details on the differences  be‐
       tween these two forms.

       Unlike <b>case-try</b>, <b>match-try</b> will pin values in a given <b>catch</b> block with those in the original steps.

              (fn handle [conn token]
                (match-try (conn:receive :*l)
                  input (parse input)
                  (command-name params token) (commands.get command-name)
                  command (pcall command (table.unpack params))
                  (catch
                    (_ :timeout) nil
                    (_ :closed) (pcall disconnect conn "connection closed")
                    (_ msg) (print "Error handling input" msg))))

   <b>var</b> declare local variable
       Introduces  a  new  local  inside an existing scope which may have its value changed.  Identical to <b>local</b>
       apart from allowing <b>set</b> to work on it.

       Example:

              (var x 83)

       Supports destructuring and multiple-value binding.

   <b>set</b> set local variable or table field
       Changes the value of a variable introduced with <b>var</b>.  Will not work on globals or <b>let</b>/<b>local</b>-bound locals.
       Can also be used to change a field of a table, even if the table is bound with <b>let</b> or <b>local</b>.  If the  ta‐
       ble field name is static, use <b>tbl.field</b>; if the field name is dynamic, use <b>(.</b> <b>tbl</b> <b>field)</b>.

       Examples:

              (set x (+ x 91)) ; var

              (let [t {:a 4 :b 8}] ; static table field
                (set t.a 2) t) ; =&gt; {:a 2 :b 8}

              (let [t {:supported-chars {:x true}}
                    field1 :supported-chars
                    field2 :y] ; dynamic table field
                (set (. t field1 field2) true) t) ; =&gt; {:supported-chars {:x true :y true}}

       Supports destructuring and multiple-value binding.

   <b>multiple</b> <b>value</b> <b>binding</b>
       In  any of the above contexts where you can make a new binding, you can use multiple value binding.  Oth‐
       erwise you will only capture the first value.

       Example:

              (let [x (values 1 2 3)]
                x) ; =&gt; 1

       Example:

              (let [(file-handle message code) (io.open "foo.blah")]
                message) ; =&gt; "foo.blah: No such file or directory"

       Example:

              (do (local (_ _ z) (unpack [:a :b :c :d :e])) z)  =&gt; c

   <b>tset</b> set table field
       Sets the field of a given table to a new value.

       Example:

              (let [tbl {:d 32} field :d]
                (tset tbl field 19) tbl) ; =&gt; {:d 19}

       You can provide multiple successive field names to perform nested sets.  For example:

              (let [tbl {:a {:b {}}} field :c]
                (tset tbl :a :b field "d") tbl) ; =&gt; {:a {:b {:c "d"}}}

       Since 1.5.0, <b>tset</b> is mostly redundant because <b>set</b> can be used for table fields.  The  main  exception  is
       that <b>tset</b> works with <b>doto</b> and <b>set</b> does not.

   <b>with-open</b> bind and auto-close file handles
       While  Lua will automatically close an open file handle when it's garbage collected, GC may not run right
       away; <b>with-open</b> ensures handles are closed immediately, error or no, without boilerplate.

       The usage is similar to <b>let</b>, except:

       • destructuring is disallowed (symbols only on the left-hand side)

       • every binding should be a file handle or other value with a <b>:close</b> method.

       After executing the body, or upon encountering an error, <b>with-open</b> will  invoke  <b>(value:close)</b>  on  every
       bound variable before returning the results.

       The body is implicitly wrapped in a function and run with <b>xpcall</b> so that all bound handles are closed be‐
       fore it re-raises the error.

       Example:

              ;; Basic usage
              (with-open [fout (io.open :output.txt :w) fin (io.open :input.txt)]
                (fout:write "Here is some text!\n")
                ((fin:lines))) ; =&gt; first line of input.txt

              ;; This demonstrates that the file will also be closed upon error.
              (var fh nil)
              (local (ok err)
                (pcall #(with-open [file (io.open :test.txt :w)]
                          (set fh file) ; you would normally never do this
                          (error :whoops!))))
              (io.type fh) ; =&gt; "closed file"
              [ok err]     ; =&gt; [false "&lt;error message and stacktrace&gt;"]

   <b>pick-values</b> emit exactly n values
       Discards  all values after the first n when dealing with multi-values (<b>...</b>) and multiple returns.  Useful
       for composing functions that return multiple values with variadic functions.  Expands to a <b>let</b> expression
       that binds and re-emits exactly n values, e.g.

              (pick-values 2 (func))

       expands to

              (let [(_0_ _1_) (func)] (values _0_ _1_))

       Example:

              (pick-values 0 :a :b :c :d :e) ; =&gt; nil
              [(pick-values 2 (table.unpack [:a :b :c]))] ;-&gt; ["a" "b"]

              (fn add [x y ...] (let [sum (+ (or x 0) (or y 0))]
                                      (if (= (select :# ...) 0) sum (add sum ...))))

              (add (pick-values 2 10 10 10 10)) ; =&gt; 20
              (-&gt;&gt; [1 2 3 4 5] (table.unpack) (pick-values 3) (add)) ; =&gt; 6

       <b>Note:</b> If n is greater than the number of values supplied, n values will still be emitted.   This  is  re‐
       flected when using <b>(select</b> <b>"#"</b> <b>...)</b> to count varargs, but tables <b>[...]</b> ignore trailing nils:

              (select :# (pick-values 5 "one" "two")) ; =&gt; 5
              [(pick-values 5 "one" "two")]           ; =&gt; ["one" "two"]

</pre><h4><b>FLOW</b> <b>CONTROL</b></h4><pre>
   <b>if</b> conditional
       Checks a condition and evaluates a corresponding body.  Accepts any number of condition/body pairs; if an
       odd  number  of  arguments is given, the last value is treated as a catch-all "else".  Similar to <b>cond</b> in
       other lisps.

       Example:

              (let [x (math.random 64)]
                (if (= 0 (% x 10))
                    "multiple of ten"
                    (= 0 (% x 2))
                    "even"
                    "I dunno, something else"))

       All values other than nil or false are treated as true.

   <b>when</b> single side-effecting conditional
       Takes a single condition and evaluates the rest as a body if it's not nil or false.  This is intended for
       side-effects.  The last form in the body is used as the return value.

       Example:

              (when launch-missiles?
                (power-on)
                (open-doors)
                (fire))

   <b>each</b> general iteration
       Runs the body once for each value provided by the iterator.  Commonly used with  <b>ipairs</b>  (for  sequential
       tables) or <b>pairs</b> (for any table in undefined order) but can be used with any iterator.  Returns nil.

       Example:

              (each [key value (pairs mytbl)]
                (print "executing key")
                (print (f value)))

       Any loop can be terminated early by placing an <b>&amp;until</b> clause at the end of the bindings:

              (local out [])
              (each [_ value (pairs tbl) &amp;until (&lt; max-len (length out))]
                (table.insert out value))

       <b>Note:</b> prior to fennel version 1.2.0, <b>:until</b> was used instead of <b>&amp;until</b>; the old syntax is still supported
       for backwards compatibility.

       Most   iterators   return   two  values,  but  <b>each</b>  will  bind  any  number.   See  Programming  in  Lua
       (https://www.lua.org/pil/7.1.html) for details about how iterators work.

   <b>for</b> numeric loop
       Counts a number from a start to stop point (inclusive), evaluating the body once for each value.  Accepts
       an optional step.  Returns nil.

       Example:

              (for [i 1 10 2]
                (log-number i)
                (print i))

       This example will print all odd numbers under ten.

       Like <b>each</b>, loops using <b>for</b> can also be terminated early with an <b>&amp;until</b> clause.  The clause is checked be‐
       fore each iteration of the body; if it is true at the beginning then the body will not run at all.

              (var x 0)
              (for [i 1 128 &amp;until (maxed-out? x)]
                (set x (+ x i)))

   <b>while</b> good old while loop
       Loops over a body until a condition is met.  Uses a native Lua <b>while</b> loop.  Returns nil.

       Example:

              (var done? false)
              (while (not done?)
                (print :not-done)
                (when (&lt; 0.95 (math.random))
                  (set done? true)))

   <b>do</b> evaluate multiple forms returning last value
       Accepts any number of forms and evaluates all of them in order, returning the last value.  This  is  used
       for inserting side-effects into a form which accepts only a single value, such as in a body of an <b>if</b> when
       multiple clauses make it so you can't use <b>when</b>.  Some lisps call this <b>begin</b> or <b>progn</b>.

              (if launch-missiles?
                  (do
                    (power-on)
                    (open-doors)
                    (fire))
                  false-alarm?
                  (promote lt-petrov))

       Some other forms like <b>fn</b> and <b>let</b> have an implicit <b>do</b>.

</pre><h4><b>DATA</b></h4><pre>
   <b>operators</b>
       • <b>and</b>, <b>or</b>, <b>not</b>: boolean

       • <b>+</b>, <b>-</b>, <b>*</b>, <b>/</b>, <b>//</b>, <b>%</b>, <b>^</b>: arithmetic

       • <b>&gt;</b>, <b>&lt;</b>, <b>&gt;=</b>, <b>&lt;=</b>, <b>=</b>, <b>not=</b>: comparison

       • <b>lshift</b>, <b>rshift</b>, <b>band</b>, <b>bor</b>, <b>bxor</b>, <b>bnot</b>: bitwise operations

       These  all work as you would expect, with a few caveats.  The bitwise operators are only available in Lua
       5.3+, unless you use the <b>--use-bit-lib</b> flag or the <b>useBitLib</b> flag in the options table, which  lets  them
       be used in LuaJIT.  The integer division operator (<b>//</b>) is only available in Lua 5.3+.

       They all take any number of arguments, as long as that number is fixed at compile-time.  For instance, <b>(=</b>
       <b>2</b>  <b>2</b> <b>(unpack</b> <b>[2</b> <b>5]))</b> will evaluate to <b>true</b> because the compile-time number of values being compared is 3.
       Multiple values at runtime will not be taken into account.

       Note that these are all special forms which cannot be used as higher-order functions.

   <b>..</b> string concatenation
       Concatenates its arguments into one string.  Will coerce numbers into strings, but not other types.

       Example:

              (.. "Hello" " " "world" 7 "!!!") ; =&gt; "Hello world7!!!"

       String concatenation is subject to the same compile-time limit as the operators above; it is not aware of
       multiple values at runtime.

   <b>length</b> string or table length
       <u>(Changed</u> <u>in</u> <u>0.3.0:</u> <u>it</u> <u>was</u> <u>called</u> <u><b>#</b></u> <u>before.)</u>

       Returns the length of a string or table.  Note that the length of a table with gaps (nils) in it is unde‐
       fined; it can return a number corresponding to any of the table's "boundary" positions  between  nil  and
       non-nil  values.  If a table has nils and you want to know the last consecutive numeric index starting at
       1, you must calculate it yourself with <b>ipairs</b>; if you want to know the maximum numeric  key  in  a  table
       with nils, you can use <b>table.maxn</b> on Lua &lt;= 5.2.

       Example:

              (+ (length [1 2 3 nil 8]) (length "abc")) ; =&gt; 6 or 8

   <b>.</b> table lookup
       Looks up a given key in a table.  Multiple arguments will perform nested lookup.

       Example:

              (. mytbl myfield)

       Example:

              (let [t {:a [2 3 4]}] (. t :a 2)) ; =&gt; 3

       Note  that if the field name is a string known at compile time, you don't need this and can just use <b>myt‐</b>
       <b>bl.field</b>.

   <b>Nil-safe</b> <b>?.</b> table lookup
       Looks up a given key in a table.  Multiple arguments will perform nested lookup.  If  any  of  subsequent
       keys is not present, will short-circuit to <b>nil</b>.

       Example:

              (?. mytbl myfield)

       Example:

              (let [t {:a [2 3 4]}] (?. t :a 4 :b)) ; =&gt; nil
              (let [t {:a [2 3 4 {:b 42}]}] (?. t :a 4 :b)) ; =&gt; 42

   <b>icollect</b>, <b>collect</b> table comprehension macros
       <u>(Since</u> <u>0.8.0)</u>

       The  <b>icollect</b> macro takes a "iterator binding table" in the format that <b>each</b> takes, and returns a sequen‐
       tial table containing all the values produced by each iteration of the macro's body.  This is similar  to
       how <b>map</b> works in several other languages, but it is a macro, not a function.

       If  the  value  is  nil,  it is omitted from the return table.  This is analogous to <b>filter</b> in other lan‐
       guages.

              (icollect [_ v (ipairs [1 2 3 4 5 6])]
                (if (&lt; 2 v) (* v v)))
              ;; -&gt; [9 16 25 36]

              ;; equivalent to:
              (let [tbl []]
                (each [_ v (ipairs [1 2 3 4 5 6])]
                  (tset tbl (+ (length tbl) 1) (if (&lt; 2 v) (* v v))))
                tbl)

       The <b>collect</b> macro is almost identical, except that the body should return two things: a key and a value.

              (collect [k v (pairs {:apple "red" :orange "orange" :lemon "yellow"})]
                (if (not= v "yellow")
                    (values (.. "color-" v) k)))
              ;; -&gt; {:color-orange "orange" :color-red "apple"}

              ;; equivalent to:
              (let [tbl {}]
                (each [k v (pairs {:apple "red" :orange "orange"})]
                  (if (not= v "yellow")
                    (match (values (.. "color-" v) k)
                      (key value) (tset tbl key value))))
                tbl)

       If the key and value are given directly in the body of <b>collect</b> and not nested in an outer form, then  the
       <b>values</b> can be omitted for brevity:

              (collect [k v (pairs {:a 85 :b 52 :c 621 :d 44})]
                k (* v 5))

       Like <b>each</b> and <b>for</b>, the table comprehensions support an <b>&amp;until</b> clause for early termination.

       Both  <b>icollect</b>  and <b>collect</b> take an <b>&amp;into</b> clause which allows you put your results into an existing table
       instead of starting with an empty one:

              (icollect [_ x (ipairs [2 3]) &amp;into [9]]
                (* x 11))
              ;; -&gt; [9 22 33]

       <b>Note:</b> Prior to fennel version 1.2.0, <b>:into</b> was used instead of <b>&amp;into</b>; the old syntax is  still  supported
       for backwards compatibility.

   <b>accumulate</b> iterator accumulation
       <u>(Since</u> <u>0.10.0)</u>

       Runs through an iterator and performs accumulation, similar to <b>fold</b> and <b>reduce</b> commonly used in function‐
       al  programming  languages.  Like <b>collect</b> and <b>icollect</b>, it takes an iterator binding table and an expres‐
       sion as its arguments.  The difference is that in <b>accumulate</b>, the first two items in  the  binding  table
       are  used  as an "accumulator" variable and its initial value.  For each iteration step, it evaluates the
       given expression and its value becomes the next accumulator variable.  <b>accumulate</b> returns the final value
       of the accumulator variable.

       Example:

              (accumulate [sum 0
                           i n (ipairs [10 20 30 40])]
                  (+ sum n)) ; -&gt; 100

       The <b>&amp;until</b> clause is also supported here for early termination.

   <b>faccumulate</b> range accumulation
       <u>(Since</u> <u>1.3.0)</u>

       Identical to accumulate, but instead of taking an iterator and the same bindings as <b>each</b>, it accepts  the
       same bindings as <b>for</b> and will iterate the numerical range.  Accepts <b>&amp;until</b> just like <b>for</b> and <b>accumulate</b>.

       Example:

              (faccumulate [n 0 i 1 5] (+ n i)) ; =&gt; 15

   <b>fcollect</b> range comprehension macro
       <u>(Since</u> <u>1.1.1)</u>

       Similarly  to <b>icollect</b>, <b>fcollect</b> provides a way of building a sequential table.  Unlike <b>icollect</b>, instead
       of an iterator it traverses a range, as accepted by the <b>for</b> special.  The <b>&amp;into</b> and <b>&amp;until</b>  clauses  work
       the same as in <b>icollect</b>.

       Example:

              (fcollect [i 0 10 2]
                (if (&gt; i 2) (* i i)))
              ;; -&gt; [16 36 64 100]

              ;; equivalent to:
              (let [tbl {}]
                (for [i 0 10 2]
                  (if (&gt; i 2)
                      (table.insert tbl (* i i))))
                tbl)

   <b>values</b> multi-valued return
       Returns  multiple  values from a function.  Usually used to signal failure by returning nil followed by a
       message.

       Example:

              (fn [filename]
                (if (valid-file-name? filename)
                    (open-file filename)
                    (values nil (.. "Invalid filename: " filename))))

</pre><h4><b>OTHER</b></h4><pre>
   <b>:</b> method call
       Looks up a function in a table and calls it with the table as its first argument.  This is a common idiom
       in many Lua APIs, including some built-in ones.

       Just like Lua, you can perform a method call by calling a function name where <b>:</b> separates the table vari‐
       able and method name.

       Example:

              (let [f (assert (io.open "hello" "w"))]
                (f:write "world")
                (f:close))

       In the example above, <b>f:write</b> is a single multisym.  If the name of the method or the table containing it
       isn't fixed, you can use <b>:</b> followed by the table and then the method's name to allow it to be  a  dynamic
       string instead:

       Example:

              (let [f (assert (io.open "hello" "w"))
                    method1 :write
                    method2 :close]
                (: f method1 "world")
                (: f method2))

       Both of these examples are equivalent to the following:

              (let [f (assert (io.open "hello" "w"))]
                (f.write f "world")
                (f.close f))

       Unlike  Lua,  there's  nothing special about defining functions that get called this way; typically it is
       given an extra argument called <b>self</b> but this is just a convention; you can name it anything.

              (local t {})

              (fn t.enable [self]
                (set self.enabled? true))

              (t:enable)

   <b>-&gt;</b>, <b>-&gt;&gt;</b>, <b>-?&gt;</b> and <b>-?&gt;&gt;</b> threading macros
       The <b>-&gt;</b> macro takes its first value and splices it into the second form as the first argument.  The result
       of evaluating the second form gets spliced into the first argument of the third form, and so on.

       Example:

              (-&gt; 52
                  (+ 91 2) ; (+ 52 91 2)
                  (- 8)    ; (- (+ 52 91 2) 8)
                  (print "is the answer")) ; (print (- (+ 52 91 2) 8) "is the answer")

       The <b>-&gt;&gt;</b> macro works the same, except it splices it into the last position of each  form  instead  of  the
       first.

       <b>-?&gt;</b> and <b>-?&gt;&gt;</b>, the thread maybe macros, are similar to <b>-&gt;</b> &amp; <b>-&gt;&gt;</b> but they also do checking after the evalu‐
       ation  of  each  threaded form.  If the result is false or nil then the threading stops and the result is
       returned.  <b>-?&gt;</b> splices the threaded value as the first argument, like <b>-&gt;</b>, and <b>-?&gt;&gt;</b> splices  it  into  the
       last position, like <b>-&gt;&gt;</b>.

       This example shows how to use them to avoid accidentally indexing a nil value:

              (-?&gt; {:a {:b {:c 42}}}
                   (. :a)
                   (. :missing)
                   (. :c)) ; -&gt; nil
              (-?&gt;&gt; :a
                    (. {:a :b})
                    (. {:b :missing})
                    (. {:c 42})) ; -&gt; nil

       While  <b>-&gt;</b>  and  <b>-&gt;&gt;</b> pass multiple values thru without any trouble, the checks in <b>-?&gt;</b> and <b>-?&gt;&gt;</b> prevent the
       same from happening there without performance overhead, so these pipelines are limited to a single value.

              Note that these have nothing to do with "threads" used for concurrency; they are named  after  the
              thread which is used in sewing.  This is similar to the way that <b>|&gt;</b> works in OCaml and Elixir.

   <b>doto</b>
       Similarly, the <b>doto</b> macro splices the first value into subsequent forms.  However, it keeps the same val‐
       ue  and  continually splices the same thing in rather than using the value from the previous form for the
       next form.

              (doto (io.open "/tmp/err.log")
                (: :write contents)
                (: :close))

              ;; equivalent to:
              (let [x (io.open "/tmp/err.log")]
                (: x :write contents)
                (: x :close)
                x)

       The first form becomes the return value for the whole expression,  and  subsequent  forms  are  evaluated
       solely for side-effects.

   <b>tail!</b>
       Tail  calls will be optimized automatically.  However, the <b>tail!</b> form asserts that its argument is called
       in a tail position.  You can use this when the code depends on tail call optimization; that  way  if  the
       code is changed so that the recursive call is no longer in the tail position, it will cause a compile er‐
       ror instead of overflowing the stack later on large data sets.

              (fn process-all [data i]
                (case (process (. data i))
                  :done (print "Process completed.")
                  :next (process-all data (+ i 1))
                  :skip (do (tail! (process-all data (+ i 2)))
              ;;             ^^^^^ Compile error: Must be in tail position
                            (print "Skipped" (+ i 1)))))

   <b>include</b>
              (include :my.embedded.module)

       Loads  Fennel/Lua module code at compile time and embeds it in the compiled output.  The module name must
       resolve to a string literal during compilation.  The bundled code will be wrapped in a  function  invoca‐
       tion  in  the  emitted Lua and set on <b>package.preload[modulename]</b>; a normal <b>require</b> is then emitted where
       <b>include</b> was used to load it on demand as a normal module.

       In most cases it's better to use <b>require</b> in your code and use the <b>requireAsInclude</b> option in the API doc‐
       umentation and the <b>--require-as-include</b> CLI flag (<b>fennel</b> <b>--help</b>) to accomplish this.

       The <b>require</b> function is not part of Fennel; it comes from Lua.  However, it works to  load  Fennel  code.
       See   the   Modules   and   multiple   files   section   in   the   tutorial   and   Programming  in  Lua
       (https://www.lua.org/pil/8.1.html) for details about <b>require</b>.

       Starting from version 0.10.0 <b>include</b> and hence  <b>--require-as-include</b>  support  semi-dynamic  compile-time
       resolution  of module paths similarly to <b>import-macros</b>.  See the relative require section in the tutorial
       for more information.

   <b>assert-repl</b>
       <u>(Since</u> <u>1.4.0)</u>

       Sometimes it's helpful for debugging purposes to drop a repl right into the middle of your  code  to  see
       what's really going on.  You can use the <b>assert-repl</b> macro to do this:

              (let [input (get-input)
                    value []]
                (fn helper [x]
                  (table.insert value (calculate x)))
                (assert-repl (transform helper value) "could not transform"))

       This  works as a drop-in replacement for the built-in <b>assert</b> function, but when the condition is false or
       nil, instead of an error, it drops into a repl which has access to all the locals that are in scope  (<b>in‐</b>
       <b>put</b>, <b>value</b>, and <b>helper</b> in the example above).

       Note  that  this  is meant for use in development and will not work with ahead-of-time compilation unless
       your build also includes Fennel as a library.

       If you use the <b>--assert-as-repl</b> flag when running Fennel, calls to <b>assert</b> will be replaced  with  <b>assert-</b>
       <b>repl</b> automatically.

       <b>Note:</b>  In  Fennel 1.4.0, <b>assert-repl</b> accepted an options table for <b>fennel.repl</b> as an optional third argu‐
       ment.  This was removed as a bug in 1.4.1, as it broke compatibility with <b>assert</b>.

       The REPL spawned by <b>assert-repl</b> applies the same default options as <b>fennel.repl</b>, which as of Fennel 1.4.1
       can be configured from the API.  See the Fennel API reference for details.

   <b>Recovering</b> <b>from</b> <b>failed</b> <b>assertions</b>
       You can <b>,return</b> <b>EXPRESSION</b> from the repl to replace the original failing condition with a different arbi‐
       trary value.  Returning false or nil will trigger a regular <b>assert</b> failure.

       <b>Note:</b> Currently, only a single value can be returned from the REPL this way.  While <b>,return</b> can  be  used
       to  make a failed assertion recover, if the calling code expects multiple return values, it may cause un‐
       specified behavior.

</pre><h4><b>MACROS</b></h4><pre>
       All forms which introduce macros do so inside the current scope.  This is usually the  top  level  for  a
       given file, but you can introduce macros into nested scopes as well.  Note that macros are a compile-time
       construct;  they  do  not  exist at runtime.  As such macros cannot be exported at the bottom of a module
       like functions and other values.

   <b>import-macros</b> load macros from a separate module
       Loads a module at compile-time and binds its functions as local macros.

       A macro module exports any number of functions which take code forms as arguments  at  compile  time  and
       emit  lists which are fed back into the compiler as code.  The module calling <b>import-macros</b> gets whatever
       functions have been exported to use as macros.  For instance, here is a  macro  module  which  implements
       <b>when2</b> in terms of <b>if</b> and <b>do</b>:

              (fn when2 [condition body1 &amp; rest-body]
                (assert body1 "expected body")
                `(if ,condition
                   (do ,body1 ,(unpack rest-body))))

              {:when2 when2}

       For  a full explanation of how this works see the macro guide.  All forms in Fennel are normal tables you
       can use <b>table.insert</b>, <b>ipairs</b>, destructuring, etc on.  The backtick on the third line creates  a  template
       list  for  the code emitted by the macro, and the comma serves as "unquote" which splices values into the
       template.

       Assuming the code above is in the file "my-macros.fnl" then it turns this input:

              (import-macros {: when2} :my-macros)

              (when2 (= 3 (+ 2 a))
                (print "yes")
                (finish-calculation))

       and transforms it into this code at compile time by splicing the arguments into the backtick template:

              (if (= 3 (+ 2 a))
                (do
                  (print "yes")
                  (finish-calculation)))

       The <b>import-macros</b> macro can take any number of binding/module-name pairs.  It can also  bind  the  entire
       macro  module  to a single name rather than destructuring it.  In this case you can use a dot to call the
       individual macros inside the module:

              (import-macros mine :my-macros)

              (mine.when2 (= 3 (+ 2 a))
                (print "yes")
                (finish-calculation))

       Note that all macro code runs at compile time, which happens before runtime.  Locals which are  in  scope
       at runtime are not visible during compile-time.  So this code will not work:

              (local (module-name file-name) ...)
              (import-macros mymacros (.. module-name ".macros"))

       However, this code will work, provided the module in question exists:

              (import-macros mymacros (.. ... ".macros"))

       See  "Compiler  API"  below  for  details  about additional functions visible inside compiler scope which
       macros run in.

   <b>Macro</b> <b>module</b> <b>searching</b>
       By default, Fennel will search for macro modules similarly to how it searches for normal runtime modules:
       by walking thru entries on <b>fennel.macro-path</b> and checking the filesystem for matches.  However,  in  some
       cases this might not be suitable, for instance if your Fennel program is packaged in some kind of archive
       file and the modules do not exist as distinct files on disk.

       To support this case you can add your own searcher function to the <b>fennel.macro-searchers</b> table.  For ex‐
       ample, assuming <b>find-in-archive</b> is a function which can look up strings from the archive given a path:

              (local fennel (require :fennel))

              (fn my-searcher [module-name]
                (let [filename (.. "src/" module-name ".fnl")]
                  (match (find-in-archive filename)
                    code (values (partial fennel.eval code {:env :_COMPILER})
                                 filename))))

              (table.insert fennel.macro-searchers my-searcher)

       The  searcher  function  should  take  a module name as a string and return two values if it can find the
       macro module: a loader function which will return the macro table when called, and an optional  filename.
       The loader function will receive the module name and the filename as arguments.

   <b>macros</b> define several macros
       Defines a table of macros.  Note that inside the macro definitions, you cannot access variables and bind‐
       ings  from  the surrounding code.  The macros are essentially compiled in their own compiler environment.
       Again, see the "Compiler API" section for more details about the functions available here.

              (macros {:my-max (fn [x y]
                                 `(let [x# ,x y# ,y]
                                    (if (&lt; x# y#) y# x#)))})

              (print (my-max 10 20))
              (print (my-max 20 10))
              (print (my-max 20 20))

   <b>macro</b> define a single macro
              (macro my-max [x y]
                `(let [x# ,x y# ,y]
                   (if (&lt; x# y#) y# x#)))

       If you are only defining a single macro, this is equivalent to the previous example.  The  syntax  mimics
       <b>fn</b>.

   <b>macrodebug</b> print the expansion of a macro
              (macrodebug (-&gt; abc
                              (+ 99)
                              (&lt; 0)
                              (when (os.exit))))
              ; -&gt; (if (&lt; (+ abc 99) 0) (do (os.exit)))

       Call  the  <b>macrodebug</b>  macro  with a form and it will repeatedly expand top-level macros in that form and
       print out the resulting form.  Note that the resulting form will usually not be sensibly indented, so you
       might need to copy it and reformat it into something more readable.

       Note that this prints at compile-time since <b>macrodebug</b> is a macro.

   <b>Macro</b> <b>gotchas</b>
       It's easy to make macros which accidentally evaluate their arguments more than once.   This  is  fine  if
       they  are passed literal values, but if they are passed a form which has side-effects, the result will be
       unexpected:

              (var v 1)
              (macros {:my-max (fn [x y]
                                 `(if (&lt; ,x ,y) ,y ,x))})

              (fn f [] (set v (+ v 1)) v)

              (print (my-max (f) 2)) ; -&gt; 3 since (f) is called twice in the macro body above

       In order to prevent accidental symbol capture  (https://gist.github.com/nimaai/2f98cc421c9a51930e16#vari‐
       able-capture),  you  may not bind a bare symbol inside a backtick as an identifier.  Appending a <b>#</b> on the
       end of the identifier name as above invokes "auto gensym" which guarantees the local name is unique.

              (macros {:my-max (fn [x y]
                                 `(let [x2 ,x y2 ,y]
                                    (if (&lt; x2 y2) y2 x2)))})

              (print (my-max 10 20))
              ; Compile error in 'x2' unknown:?: macro tried to bind x2 without gensym; try x2# instead

       <b>macros</b> is useful for one-off, quick macros, or even some more complicated macros, but be careful.  It may
       be tempting to try and use some function you have previously defined, but if you need such functionality,
       you should probably use <b>import-macros</b>.

       For example, this will not compile in strict mode!  Even when it does allow the macro to  be  called,  it
       will fail trying to call a global <b>my-fn</b> when the code is run:

              (fn my-fn [] (print "hi!"))

              (macros {:my-max (fn [x y]
                                 (my-fn)
                                 `(let [x# ,x y# ,y]
                                    (if (&lt; x# y#) y# x#)))})
              ; Compile error in 'my-max': attempt to call global '__fnl_global__my_2dfn' (a nil value)

   <b>eval-compiler</b>
       Evaluate a block of code during compile-time with access to compiler scope.  This gives you a superset of
       the features you can get with macros, but you should use macros if you can.

       Example:

              (eval-compiler
                (each [name (pairs _G)]
                  (print name)))

       This prints all the functions available in compiler scope.

   <b>Compiler</b> <b>Environment</b>
       Inside <b>eval-compiler</b>, <b>macros</b>, or <b>macro</b> blocks, as well as <b>import-macros</b> modules, the functions listed be‐
       low are visible to your code.

       • <b>list</b> - return a list, which is a special kind of table used for code.

       • <b>sym</b> - turn a string into a symbol.

       • <b>gensym</b> - generates a unique symbol for use in macros, accepts an optional prefix string.

       • <b>list?</b> - is the argument a list?  Returns the argument or <b>false</b>.

       • <b>sym?</b> - is the argument a symbol?  Returns the argument or <b>false</b>.

       • <b>table?</b> - is the argument a non-list table?  Returns the argument or <b>false</b>.

       • <b>sequence?</b>  -  is the argument a non-list <u>sequential</u> table (created with <b>[]</b>, as opposed to <b>{}</b>)?  Returns
         the argument or <b>false</b>.

       • <b>varg?</b> - is this a <b>...</b> symbol which indicates var args?  Returns a special table describing the type  or
         <b>false</b>.

       • <b>multi-sym?</b>  - a multi-sym is a dotted symbol which refers to a table's field.  Returns a table contain‐
         ing each separate symbol, or <b>false</b>.

       • <b>comment?</b> - is the argument a comment?  Comments are only included when <b>opts.comments</b> is truthy.

       • <b>view</b> - <b>fennel.view</b> table serializer.

       • <b>get-scope</b> - return the scope table for the current macro call site.

       • <b>assert-compile</b> - works like <b>assert</b> but takes a list/symbol as its third argument in  order  to  provide
         pinpointed error messages.

       The following functions standardize Lua globals that change between 5.1-5.4.  To limit common Lua-compat‐
       ibility  boilerplate  such  as  <b>(local</b> <b>unpack</b> <b>(or</b> <b>_G.unpack</b> <b>table.unpack))</b> from macro code, the following
       helpers are present in the macro environment:

       • <b>unpack</b> - <b>_G.unpack</b> in Lua 5.1/LuaJit, <b>table.unpack</b> in Lua &gt;= 5.2

       • <b>pack</b> - Equivalent to <b>table.pack</b> available in Lua 5.2 and up.  <b>(pack</b> <b>:a</b> <b>nil</b> <b>:c</b> <b>nil</b> <b>nil)</b> -&gt; <b>{1</b> <b>:a</b> <b>3</b> <b>:c</b> <b>:n</b>
         <b>5}</b>.  Useful for reliably storing and correctly reproducing multi-values that contain <b>nil</b>.

       These functions can be used from within macros only, not from any <b>eval-compiler</b> call:

       • <b>in-scope?</b> - does the symbol refer to an in-scope local?  Returns the symbol or <b>nil</b>.

       • <b>macroexpand</b> - performs macroexpansion on its argument form; returns an AST.

   <b>Note:</b> <b>Compile-time</b> <b>List</b> <b>implementation</b>
       Note that lists are compile-time concepts that don't exist at runtime; they  are  implemented  as  tables
       which  have  a  special  metatable  to  distinguish them from regular tables defined with square or curly
       brackets.  Similarly symbols are tables with a string entry for their name and a marker  metatable.   You
       can use <b>tostring</b> to get the name of a symbol.

   <b>Sandboxing</b>
       As  of  1.0.0 the compiler will not allow access to the outside world (<b>os</b>, <b>io</b>, etc) from macros.  The one
       exception is <b>print</b> which is included for debugging purposes.  You can disable this by providing the  com‐
       mand-line argument <b>--no-compiler-sandbox</b> or by passing <b>{:compiler-env</b> <b>_G}</b> in the options table when using
       the compiler API to get full access.

       Please  note that the sandbox is not suitable to be used as a robust security mechanism.  It has not been
       audited and should not be relied upon to protect you from running untrusted code.

       Note that other internals of the compiler exposed in compiler scope but not listed above are  subject  to
       change.

<b>lua</b> ESCAPE HATCH
       There  are  some cases when you need to emit Lua output from Fennel in ways that don't match Fennel's se‐
       mantics.  For instance, if you are porting an algorithm from Lua that uses early returns, you may want to
       do the port as literally as possible first, and then come back to it later to make it idiomatic.  You can
       use the <b>lua</b> special form to accomplish this:

              (fn find [tbl pred]
                (each [key val (pairs tbl)]
                  (when (pred val)
                    (lua "return key"))))

       Lua code inside the string can refer to locals which are in scope; however note that it must refer to the
       names after mangling has been done, because the identifiers must be valid Lua.  The Fennel compiler  will
       change  <b>foo-bar</b>  to  <b>foo_bar</b>  in the Lua output in order for it to be valid, as well as other transforma‐
       tions.  When in doubt, inspect the compiler output to see what it looks like.  For example the  following
       Fennel code:

              (local foo-bar 3)
              (let [foo-bar :hello]
                (lua "print(foo_bar0 .. \" world\")"))

       will produce this Lua code:

              local foo_bar = 3
              local foo_bar0 = "hello"
              print(foo_bar0 .. " world")
              return nil

       Normally  in these cases you would want to emit a statement, in which case you would pass a string of Lua
       code as the first argument.  But you can also use it to emit an expression if you pass in a string as the
       second argument.

       Note that this should only be used in exceptional circumstances, and if you are able  to  avoid  it,  you
       should.

</pre><h4><b>DEPRECATED</b> <b>FORMS</b></h4><pre>
       The  <b>#</b>  form  is a deprecated alias for <b>length</b>, and <b>~=</b> is a deprecated alias for <b>not=</b>, kept for backwards
       compatibility.

   <b>require-macros</b> load macros with less flexibility
       <u>(Deprecated</u> <u>in</u> <u>0.4.0)</u>

       The <b>require-macros</b> form is like <b>import-macros</b>, except it imports all macros without making it clear  what
       new identifiers are brought into scope.  It is strongly recommended to use <b>import-macros</b> instead.

   <b>pick-args</b> create a function of fixed arity
       <u>(Deprecated</u> <u>0.10.0)</u>

       Like  <b>pick-values</b>,  but takes an integer <b>n</b> and a function/operator <b>f</b>, and creates a new function that ap‐
       plies exactly <b>n</b> arguments to <b>f</b>.

   <b>global</b> set global variable
       <u>(Deprecated</u> <u>in</u> <u>1.1.0)</u>

       Sets a global variable to a new value.  Note that there is no distinction between introducing a new glob‐
       al and changing the value of an existing one.  This supports destructuring and multiple-value binding.

       Example:

              (global prettyprint (fn [x] (print (fennel.view x))))

       Using <b>global</b> adds the identifier in question to the list of allowed globals so that referring to it later
       on will not cause a compiler error.  However, globals are also available in the <b>_G</b> table,  and  accessing
       them that way instead is recommended for clarity.

   <b>Rest</b> <b>destructuring</b> <b>metamethod</b>
       <u>(Deprecated</u> <u>in</u> <u>1.4.1,</u> <u>will</u> <u>be</u> <u>removed</u> <u>in</u> <u>future</u> <u>versions)</u>

       If  a  table implements <b>__fennelrest</b> metamethod it is used to capture the remainder of the table.  It can
       be used with custom data structures implemented in terms of tables, which wish to provide custom rest de‐
       structuring.  The metamethod receives the table as the first argument, and the amount of values it  needs
       to drop from the beginning of the table, much like table.unpack

       Example:

              (local t [1 2 3 4 5 6])
              (setmetatable
               t
               {:__fennelrest (fn [t k]
                                (let [res {}]
                                  (for [i k (length t)]
                                    (tset res (tostring (. t i)) (. t i)))
                                res))})
              (let [[a b &amp; c] t]
                c) ;; =&gt; {:3 3 :4 4 :5 5 :6 6}

</pre><h4><b>AUTHORS</b></h4><pre>
       Fennel Maintainers.

fennel 1.5.3                                       2025-02-16                                <u><a href="../man5/fennel-reference.5.html">fennel-reference</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>