<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rc_keymap - toml file describing remote control keymap</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ir-keytable">ir-keytable_1.30.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rc_keymap - toml file describing remote control keymap

</pre><h4><b>DESCRIPTION</b></h4><pre>
       An  rc_keymap  describes a remote control. It list the protocols used, and the mapping from decoded IR to
       linux input keycodes. This file is used by <a href="../man1/ir-keytable.1.html">ir-keytable</a>(1) for IR decoding, and by <a href="../man1/ir-ctl.1.html">ir-ctl</a>(1)  for  sending
       IR.

       The  file format is toml. Since a remote control can use multiple protocols, the top level is an array of
       protocols. The vast majority of remotes only use one protocol.

</pre><h4><b>KEYMAP</b> <b>PROTOCOL</b> <b>ENTRY</b></h4><pre>
       For each protocol the remote uses, there should be one entry in the top level <b>protocols</b> array.

   <b>Name</b> <b>Field</b>
       Each protocols entry has a <b>name</b> field. The name is not used by ir-keytable or ir-ctl, but can be used  to
       give the remote control a more descriptive name than the file name, e.g. the model number.

   <b>Protocol</b> <b>Field</b>
       The  <b>protocol</b> field specifies the protocol. This can either be one of the linux kernel decoders, in which
       case it is <b>nec</b>, <b>rc-5</b>, <b>rc-6</b>, <b>jvc</b>, <b>sony</b>, <b>sanyo</b>,  <b>rc-5-sz</b>,  <b>sharp</b>,  <b>mce-kbd</b>,  <b>xmp</b>,  <b>imon</b>,  <b>rc-mm</b>,  <b>other</b>  or
       <b>unknown</b>.  If  it  does  not match any of these entries, then it is assumed to be a BPF based decoder. The
       <b>unknown</b> and <b>other</b> are protocols decoded by specific RC devices where the protocol is  either  unknown  or
       proprietary, respectively.

       There    are    some    pre-defined    BPF    protocol    decoders,   which   are   listed   below.   See
       https://lwn.net/Articles/759188/ for how to write your own.

   <b>Variant</b> <b>Field</b>
       The <b>variant</b> field specifies which variant a particular protocol uses.  The  <b>sony</b>,  <b>rc-5</b>,  <b>rc-6</b>  protocols
       have different bit length variants, for example. This field is used by ir-ctl when sending IR.

       The following variants are currently defined:

       Protocol <b>rc-5</b> has variants <b>rc-5</b>, <b>rc-5x-20</b>, <b>rc-5-sz</b>.

       Protocol <b>nec</b> has variants <b>nec</b>, <b>nec-x</b>, <b>nec-32</b>.

       Protocol <b>sony</b> has variants <b>sony-12</b>, <b>sony-15</b>, <b>sony-20</b>.

       Protocol <b>rc-6</b> has variants <b>rc-6-0</b>, <b>rc-6-6a-20</b>, <b>rc-6-6a-24</b>, <b>rc-6-6a-32</b>, <b>rc-6-mce</b>.

       Protocol <b>rc-mm</b> has variants <b>rc-mm-12</b>, <b>rc-mm-24</b>, and <b>rc-mm-32</b>.

   <b>Scancodes</b> <b>field</b>
       The <b>scancodes</b> table list the scancodes and the mapping to linux input keycode. Multiple scancodes can map
       to the same keycode. The scancodes field is not present for <b>raw</b> protocols.

       If  the  scancode  start with 0x, it is interpreted as a hexadecimal number. If it starts with a 0, it is
       interpreted as an octal number.

       Valid keycodes are listed in the <b>input-event-codes.h</b> header file.  Examples  are  <b>KEY_ENTER</b>,  <b>KEY_ESC</b>  or
       <b>BTN_LEFT</b>  for  the  left  mouse button. Note that if the keymap is only used for sending IR, then the key
       does not have to be a valid linux keycode. It can be any string without whitespace.

   <b>Raw</b> <b>field</b>
       If the protocol is <b>raw</b>, the <b>raw</b> field is an array of keycode to raw mapping. For each entry, there  is  a
       <b>keycode</b>  field  and  <b>raw</b> field. The <b>keycode</b> is a linux input keycode, as explained in the scancodes field
       above.

       The <b>raw</b> field is an string, which lists pulse and space values, separated by whitespace. The first  is  a
       pulse value microseconds, and the second a space, third pulse, etc. The space values can be preceded by a
       -  sign  and  the pulse value can be preceded by a +sign.  There should be an odd number of value so that
       the last entry is a pulse.

   <b>Remaining</b> <b>fields</b> <b>(BPF</b> <b>parameters)</b>
       If the protocol is a BPF based decoder, it may have any number of numeric  parameters.  These  parameters
       are  used  to  support protocols with non-standard signaling lengths for standard IR protocols. Any other
       field specified here which is required by the selected BPF decoder will be used.  All  other  fields  are
       ignored.

       Kernel based non-BPF protocol decoders do not have any parameters.

</pre><h4><b>BPF</b> <b>PROTOCOLS</b></h4><pre>
       Some  of  the  BPF protocol decoders are generic and will need parameters to work. Other are for specific
       remotes and should work without any parameters.  The timing parameters are all in microseconds (Âµs).

   <b>raw</b>
       This decoder must be used when the keymap is raw; for each key, there is an entry in raw array  with  the
       pulse  and  space values for that key. No decoding is done, the incoming IR is simply matched against the
       different pulse and space values.

   <b>imon_rsc</b>
       This decoder is specifically for the iMON RSC remote, which was packaged with the iMON  Station  (amongst
       others).  The  decoder  is  for  the  directional  stick  in  the  middle; it will decode them into mouse
       movements. The buttons are all encoded using nec-x so the keymap needs two protocols to work correctly.

       This is unrelated to the <b>imon</b> protocol.

       <b>margin</b> Define how much tolerance there is for message length. Default 200.

   <b>grundig</b>
       This decoder is specifically for old grundig remotes.

       <b>header_pulse</b>
              Length of first pulse, default 900.

       <b>header_space</b>
              Length of following space, default 2900.

       <b>leader_pulse</b>
              Length of second pulse, default 1300.

   <b>xbox</b>
       This decoder is specifically for the XBox Remote DVD, which is for the first generation XBox.

       <b>margin</b> Define how much tolerance there is for message length. Default 200.

   <b>manchester</b>
       Most manchester encoded remote controls are either rc-5, rc-6, or rc-mm.  Some  remote  use  a  different
       variant  (e.g.  they might have a header pulse) and that is what the decoder is for. Some parameters must
       be specified, by default it is set up for rc-5.

       <b>margin</b> Define how much tolerance there is for message length. Default 200.

       <b>header_pulse</b>
              Define how long a leading pulse is. This is not always present. Default 0.

       <b>header_space</b>
              Define how long the space is after the leading pulse. Must be set if <b>header_pulse</b> is set.

       <b>zero_pulse</b>, <b>zero_space</b>, <b>one_pulse</b>, <b>one_space</b>
              Signally lengths for bits. See https://clearwater.com.au/code/rc5 for these are defined.

       <b>bits</b>   Number of bits. Default 14.

       <b>scancode_mask</b>
              Bits to mask out of resulting scancode.

       <b>toggle_bit</b>
              Bit that specifies the toggle. If this value is greater than the number  of  bits,  no  toggle  is
              defined.

   <b>pulse_distance</b>
       This  is  a generic decoder for protocols that define bits by distance between pulses, and the pulses are
       always of the same length. The most well known protocol like this is <b>nec</b>. This decoder is cases where <b>nec</b>
       is not used. The parameters must be set.

       <b>margin</b> Define how much tolerance there is for message length. Default 200.

       <b>header_pulse</b>
              Length of the first leading pulse. Default 2125.

       <b>header_space</b>
              Length of the space after the leading pulse. Default 1875.

       <b>repeat_pulse</b>
              Length of the leading pulse for key repeat. Default 0.

       <b>repeat_space</b>
              Length of the space after the leading pulse for key repeat. Default 0.

       <b>bit_pulse</b>
              Length of the pulse for each bit. Default 625.

       <b>bit_0_space</b>
              Length of the space for a zero bit. Default 375.

       <b>bit_1_space</b>
              Length of the space for a one bit. Default 1625.

       <b>trailer_pulse</b>
              Length of the pulse after the last bit. Needed to bookend the last bit.  Default 625.

       <b>bits</b>   Number of bits. Default 4.

       <b>reverse</b>
              Should the bits be read in least significant bit first. Set to non-zero to enable. Default 0.

       <b>header_optional</b>
              Some remotes do not send the header pulse and space for key repeats, so set this  to  non-zero  to
              make the header optional. Default 0.

              An alternative implementation might only allow missing headers for repeat messages, but this would
              fail  to  decode  key presses if the first message with the header did not decode correctly to due
              interference.

   <b>pulse_length</b>
       This is a generic decoder for protocols that define bits by length of pulses, and the spaces  are  always
       the  same. The <b>sony</b> protocol is the most well-known protocol, but this decoder is for protocols which are
       not <b>sony</b>.

       <b>margin</b> Define how much tolerance there is for message length. Default 200.

       <b>header_pulse</b>
              Length of the first leading pulse. Default 2125.

       <b>header_space</b>
              Length of the space after the leading pulse. Default 1875.

       <b>repeat_pulse</b>
              Length of the leading pulse for key repeat. Default 0.

       <b>repeat_space</b>
              Length of the space after the leading pulse for key repeat. Default 0.

       <b>bit_space</b>
              Length of the space for each bit. Default 625.

       <b>bit_0_pulse</b>
              Length of the pulse for a zero bit. Default 375.

       <b>bit_1_pulse</b>
              Length of the pulse for a one bit. Default 1625.

       <b>trailer_pulse</b>
              Length of the pulse after the last bit. Optional. Default 0.

       <b>bits</b>   Number of bits. Default 4.

       <b>reverse</b>
              Should the bits be read in least significant bit first. Set to non-zero to enable. Default 0.

       <b>header_optional</b>
              Some remotes do not send the header pulse and space for key repeats, so set this  to  non-zero  to
              make the header optional. Default 0.

              An alternative implementation might only allow missing headers for repeat messages, but this would
              fail to decode key presses if only the first message did not decode correctly to due interference.

</pre><h4><b>EXAMPLE</b></h4><pre>
       [[protocols]]
       name = "iMON Station RSC"
       protocol = "nec"
       variant = "necx"
       [protocols.scancodes]
       0x801010 = "KEY_EXIT"
       0x80102f = "KEY_POWER"
       0x80104a = "KEY_SCREENSAVER"
       0x801049 = "KEY_TIME"
       0x801054 = "KEY_NUMERIC_1"
       0x801055 = "KEY_NUMERIC_2"
       0x801056 = "KEY_NUMERIC_3"
       0x801057 = "KEY_NUMERIC_4"
       0x801058 = "KEY_NUMERIC_5"
       0x801059 = "KEY_NUMERIC_6"
       0x80105a = "KEY_NUMERIC_7"
       0x80105b = "KEY_NUMERIC_8"
       0x80105c = "KEY_NUMERIC_9"
       0x801081 = "KEY_SCREEN"
       0x80105d = "KEY_NUMERIC_0"
       0x801082 = "KEY_MAX"
       0x801048 = "KEY_ESC"
       0x80104b = "KEY_MEDIA"
       0x801083 = "KEY_MENU"
       0x801045 = "KEY_APPSELECT"
       0x801084 = "KEY_STOP"
       0x801046 = "KEY_CYCLEWINDOWS"
       0x801085 = "KEY_BACKSPACE"
       0x801086 = "KEY_KEYBOARD"
       0x801087 = "KEY_SPACE"
       0x80101e = "KEY_RESERVED"
       0x801098 = "BTN_0"
       0x80101f = "KEY_TAB"
       0x80101b = "BTN_LEFT"
       0x80101d = "BTN_RIGHT"
       0x801016 = "BTN_MIDDLE"
       0x801088 = "KEY_MUTE"
       0x80105e = "KEY_VOLUMEDOWN"
       0x80105f = "KEY_VOLUMEUP"
       0x80104c = "KEY_PLAY"
       0x80104d = "KEY_PAUSE"
       0x80104f = "KEY_EJECTCD"
       0x801050 = "KEY_PREVIOUS"
       0x801051 = "KEY_NEXT"
       0x80104e = "KEY_STOP"
       0x801052 = "KEY_REWIND"
       0x801053 = "KEY_FASTFORWARD"
       0x801089 = "KEY_ZOOM"
       [[protocols]]
       protocol = "imon_rsc"

</pre><h4><b>BUGS</b></h4><pre>
       Report bugs to <b>Linux</b> <b>Media</b> <b>Mailing</b> <b>List</b> <b>&lt;<a href="mailto:linux-media@vger.kernel.org">linux-media@vger.kernel.org</a>&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2019 by Sean Young &lt;<a href="mailto:sean@mess.org">sean@mess.org</a>&gt;

       License GPLv2: GNU GPL version 2 &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.
       This  is  free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent
       permitted by law.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/ir-keytable.1.html">ir-keytable</a>(1) and <a href="../man1/ir-ctl.1.html">ir-ctl</a>(1)

       https://lwn.net/Articles/759188/

       https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/input-event-
       codes.h#n64

v4l-utils 1.30.1                                 Thu Mar 7 2019                                     <u><a href="../man5/RC_KEYMAP.5.html">RC_KEYMAP</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>