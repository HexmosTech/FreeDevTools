<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>org.freedesktop.login1 - The D-Bus interface of systemd-logind</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/systemd">systemd_257.7-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       org.freedesktop.login1 - The D-Bus interface of systemd-logind

</pre><h4><b>INTRODUCTION</b></h4><pre>
       <b><a href="../man8/systemd-logind.service.8.html">systemd-logind.service</a></b>(8) is a system service that keeps track of user logins and seats.

       The daemon provides both a C library interface as well as a D-Bus interface. The library interface may be
       used to introspect and watch the state of user logins and seats. The bus interface provides the same
       functionality but in addition may also be used to make changes to the system state. For more information
       please consult <b><a href="../man3/sd-login.3.html">sd-login</a></b>(3).

</pre><h4><b>THE</b> <b>MANAGER</b> <b>OBJECT</b></h4><pre>
       The service exposes the following interfaces on the Manager object on the bus:

           node /org/freedesktop/login1 {
             interface org.freedesktop.login1.Manager {
               methods:
                 GetSession(in  s session_id,
                            out o object_path);
                 GetSessionByPID(in  u pid,
                                 out o object_path);
                 GetUser(in  u uid,
                         out o object_path);
                 GetUserByPID(in  u pid,
                              out o object_path);
                 GetSeat(in  s seat_id,
                         out o object_path);
                 ListSessions(out a(susso) sessions);
                 ListSessionsEx(out a(sussussbto) sessions);
                 ListUsers(out a(uso) users);
                 ListSeats(out a(so) seats);
                 ListInhibitors(out a(ssssuu) inhibitors);
                 @org.freedesktop.systemd1.Privileged("true")
                 CreateSession(in  u uid,
                               in  u pid,
                               in  s service,
                               in  s type,
                               in  s class,
                               in  s desktop,
                               in  s seat_id,
                               in  u vtnr,
                               in  s tty,
                               in  s display,
                               in  b remote,
                               in  s remote_user,
                               in  s remote_host,
                               in  a(sv) properties,
                               out s session_id,
                               out o object_path,
                               out s runtime_path,
                               out h fifo_fd,
                               out u uid,
                               out s seat_id,
                               out u vtnr,
                               out b existing);
                 @org.freedesktop.systemd1.Privileged("true")
                 CreateSessionWithPIDFD(in  u uid,
                                        in  h pidfd,
                                        in  s service,
                                        in  s type,
                                        in  s class,
                                        in  s desktop,
                                        in  s seat_id,
                                        in  u vtnr,
                                        in  s tty,
                                        in  s display,
                                        in  b remote,
                                        in  s remote_user,
                                        in  s remote_host,
                                        in  t flags,
                                        in  a(sv) properties,
                                        out s session_id,
                                        out o object_path,
                                        out s runtime_path,
                                        out h fifo_fd,
                                        out u uid,
                                        out s seat_id,
                                        out u vtnr,
                                        out b existing);
                 ReleaseSession(in  s session_id);
                 ActivateSession(in  s session_id);
                 ActivateSessionOnSeat(in  s session_id,
                                       in  s seat_id);
                 LockSession(in  s session_id);
                 UnlockSession(in  s session_id);
                 LockSessions();
                 UnlockSessions();
                 KillSession(in  s session_id,
                             in  s whom,
                             in  i signal_number);
                 KillUser(in  u uid,
                          in  i signal_number);
                 TerminateSession(in  s session_id);
                 TerminateUser(in  u uid);
                 TerminateSeat(in  s seat_id);
                 SetUserLinger(in  u uid,
                               in  b enable,
                               in  b interactive);
                 AttachDevice(in  s seat_id,
                              in  s sysfs_path,
                              in  b interactive);
                 FlushDevices(in  b interactive);
                 PowerOff(in  b interactive);
                 PowerOffWithFlags(in  t flags);
                 Reboot(in  b interactive);
                 RebootWithFlags(in  t flags);
                 Halt(in  b interactive);
                 HaltWithFlags(in  t flags);
                 Suspend(in  b interactive);
                 SuspendWithFlags(in  t flags);
                 Hibernate(in  b interactive);
                 HibernateWithFlags(in  t flags);
                 HybridSleep(in  b interactive);
                 HybridSleepWithFlags(in  t flags);
                 SuspendThenHibernate(in  b interactive);
                 SuspendThenHibernateWithFlags(in  t flags);
                 Sleep(in  t flags);
                 CanPowerOff(out s result);
                 CanReboot(out s result);
                 CanHalt(out s result);
                 CanSuspend(out s result);
                 CanHibernate(out s result);
                 CanHybridSleep(out s result);
                 CanSuspendThenHibernate(out s result);
                 CanSleep(out s result);
                 ScheduleShutdown(in  s type,
                                  in  t usec);
                 CancelScheduledShutdown(out b cancelled);
                 Inhibit(in  s what,
                         in  s who,
                         in  s why,
                         in  s mode,
                         out h pipe_fd);
                 CanRebootParameter(out s result);
                 SetRebootParameter(in  s parameter);
                 CanRebootToFirmwareSetup(out s result);
                 SetRebootToFirmwareSetup(in  b enable);
                 CanRebootToBootLoaderMenu(out s result);
                 SetRebootToBootLoaderMenu(in  t timeout);
                 CanRebootToBootLoaderEntry(out s result);
                 SetRebootToBootLoaderEntry(in  s boot_loader_entry);
                 SetWallMessage(in  s wall_message,
                                in  b enable);
               signals:
                 SecureAttentionKey(s seat_id,
                                    o object_path);
                 SessionNew(s session_id,
                            o object_path);
                 SessionRemoved(s session_id,
                                o object_path);
                 UserNew(u uid,
                         o object_path);
                 UserRemoved(u uid,
                             o object_path);
                 SeatNew(s seat_id,
                         o object_path);
                 SeatRemoved(s seat_id,
                             o object_path);
                 PrepareForShutdown(b start);
                 PrepareForShutdownWithMetadata(b start,
                                                a{sv} metadata);
                 PrepareForSleep(b start);
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 @org.freedesktop.systemd1.Privileged("true")
                 readwrite b EnableWallMessages = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 @org.freedesktop.systemd1.Privileged("true")
                 readwrite s WallMessage = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u NAutoVTs = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as KillOnlyUsers = ['...', ...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as KillExcludeUsers = ['...', ...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b KillUserProcesses = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly s RebootParameter = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b RebootToFirmwareSetup = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly t RebootToBootLoaderMenu = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly s RebootToBootLoaderEntry = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as BootLoaderEntries = ['...', ...];
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
                 readonly s BlockInhibited = '...';
                 readonly s BlockWeakInhibited = '...';
                 readonly s DelayInhibited = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t InhibitDelayMaxUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t UserStopDelayUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly as SleepOperation = ['...', ...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandlePowerKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandlePowerKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleRebootKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleRebootKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleSuspendKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleSuspendKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleHibernateKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleHibernateKeyLongPress = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleLidSwitch = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleLidSwitchExternalPower = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleLidSwitchDocked = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s HandleSecureAttentionKey = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t HoldoffTimeoutUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s IdleAction = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t IdleActionUSec = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b PreparingForShutdown = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly a{sv} PreparingForShutdownWithMetadata = [...];
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b PreparingForSleep = ...;
                 readonly (st) ScheduledShutdown = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s DesignatedMaintenanceTime = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b Docked = ...;
                 readonly b LidClosed = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b OnExternalPower = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b RemoveIPC = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t RuntimeDirectorySize = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t RuntimeDirectoryInodesMax = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t InhibitorsMax = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly t NCurrentInhibitors = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t SessionsMax = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly t NCurrentSessions = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t StopIdleSessionUSec = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>GetSession()</b> may be used to get the session object path for the session with the specified ID. Similarly,
       <b>GetUser()</b> and <b>GetSeat()</b> get the user and seat objects, respectively.  <b>GetSessionByPID()</b> and
       <b>GetUserByPID()</b> get the session/user object the specified PID belongs to if there is any.

       <b>ListSessions()</b> returns an array of all current sessions. The structures in the array consist of the
       following fields: <u>session</u> <u>id</u>, <u>user</u> <u>id</u>, <u>user</u> <u>name</u>, <u>seat</u> <u>id</u>, and <u>session</u> <u>object</u> <u>path</u>. If a session does not
       have a seat attached, the seat id field will be an empty string.

       <b>ListSessionsEx()</b> returns an array of all current sessions with more metadata than <b>ListSessions()</b>. The
       structures in the array consist of the following fields: <u>session</u> <u>id</u>, <u>user</u> <u>id</u>, <u>user</u> <u>name</u>, <u>seat</u> <u>id</u>, <u>leader</u>
       <u>pid</u>, <u>session</u> <u>class</u>, <u>tty</u> <u>name</u>, <u>idle</u> <u>hint</u>, <u>idle</u> <u>hint</u> <u>monotonic</u> <u>timestamp</u>, and <u>session</u> <u>object</u> <u>path</u>.  <u>tty</u> and
       <u>seat</u> <u>id</u> fields could be empty, if the session has no associated tty or session has no seat attached,
       respectively.

       <b>ListUsers()</b> returns an array of all currently logged in users. The structures in the array consist of the
       following fields: user id, user name, user object path.

       <b>ListSeats()</b> returns an array of all currently available seats. The structure in the array consists of the
       following fields: seat id, seat object path.

       <b>ListInhibitors()</b> lists all currently active inhibitors. It returns an array of structures consisting of
       <u>what</u>, <u>who</u>, <u>why</u>, <u>mode</u>, <u>uid</u> (user ID), and <u>pid</u> (process ID).

       <b>CreateSession()</b>, <b>CreateSessionWithPIDFD()</b>, and <b>ReleaseSession()</b> may be used to open or close login
       sessions. These calls should <u>never</u> be invoked directly by clients. Creating/closing sessions is
       exclusively the job of PAM and its <b><a href="../man8/pam_systemd.8.html">pam_systemd</a></b>(8) module.

       <b>ActivateSession()</b> brings the session with the specified ID into the foreground.  <b>ActivateSessionOnSeat()</b>
       does the same, but only if the seat id matches.

       <b>LockSession()</b> asks the session with the specified ID to activate the screen lock.  <b>UnlockSession()</b> asks
       the session with the specified ID to remove an active screen lock, if there is any. This is implemented
       by sending out the Lock() and Unlock() signals from the respective session object which session managers
       are supposed to listen on.

       <b>LockSessions()</b> asks all sessions to activate their screen locks. This may be used to lock access to the
       entire machine in one action. Similarly, <b>UnlockSessions()</b> asks all sessions to deactivate their screen
       locks.

       <b>KillSession()</b> may be used to send a Unix signal to one or all processes of a session. As arguments it
       takes the session id, either the string "leader" or "all" and a signal number. If "leader" is passed only
       the session "leader" is killed. If "all" is passed all processes of the session are killed.

       <b>KillUser()</b> may be used to send a Unix signal to all processes of a user. As arguments it takes the user
       id and a signal number.

       <b>TerminateSession()</b>, <b>TerminateUser()</b>, <b>TerminateSeat()</b> may be used to forcibly terminate one specific
       session, all processes of a user, and all sessions attached to a specific seat, respectively. The
       session, user, and seat are identified by their respective IDs.

       <b>SetUserLinger()</b> enables or disables user lingering. If enabled, the runtime directory of a user is kept
       around and they may continue to run processes while logged out. If disabled, the runtime directory goes
       away as soon as they log out.  <b>SetUserLinger()</b> expects three arguments: the UID, a boolean whether to
       enable/disable and a boolean controlling the <b>polkit</b>[1] authorization interactivity (see below). Note that
       the user linger state is persistently stored on disk.

       <b>AttachDevice()</b> may be used to assign a specific device to a specific seat. The device is identified by
       its <a href="file:/sys/">/sys/</a> path and must be eligible for seat assignments.  <b>AttachDevice()</b> takes three arguments: the seat
       id, the sysfs path, and a boolean for controlling polkit interactivity (see below). Device assignments
       are persistently stored on disk. To create a new seat, simply specify a previously unused seat id. For
       more information about the seat assignment logic see <b><a href="../man3/sd-login.3.html">sd-login</a></b>(3).

       <b>FlushDevices()</b> removes all explicit seat assignments for devices, resetting all assignments to the
       automatic defaults. The only argument it takes is the polkit interactivity boolean (see below).

       <b>PowerOff()</b>, <b>Reboot()</b>, <b>Halt()</b>, <b>Suspend()</b>, and <b>Hibernate()</b> result in the system being powered off,
       rebooted, halted (shut down without turning off power), suspended (the system state is saved to RAM and
       the CPU is turned off), or hibernated (the system state is saved to disk and the machine is powered
       down).  <b>HybridSleep()</b> results in the system entering a hybrid-sleep mode, i.e. the system is both
       hibernated and suspended.  <b>SuspendThenHibernate()</b> results in the system being suspended, then later woken
       using an RTC timer and hibernated. The only argument is the polkit interactivity boolean <u>interactive</u> (see
       below). The main purpose of these calls is that they enforce polkit policy and hence allow powering
       off/rebooting/suspending/hibernating even by unprivileged users. They also enforce inhibition locks for
       non-privileged users.  <b>Sleep()</b> automatically selects the most suitable sleep operation supported by the
       machine. The candidate sleep operations to check for support can be configured through <u>SleepOperation=</u>
       setting in <b><a href="../man5/logind.conf.5.html">logind.conf</a></b>(5). UIs should expose these calls as the primary mechanism to
       poweroff/reboot/suspend/hibernate the machine. Methods <b>PowerOffWithFlags()</b>, <b>RebootWithFlags()</b>,
       <b>HaltWithFlags()</b>, <b>SuspendWithFlags()</b>, <b>HibernateWithFlags()</b>, <b>HybridSleepWithFlags()</b>,
       <b>SuspendThenHibernateWithFlags()</b>, and <b>Sleep()</b> take <u>flags</u> to allow for extendability, defined as follows:

           #define SD_LOGIND_ROOT_CHECK_INHIBITORS          (<a href="../man1/UINT64_C.1.html">UINT64_C</a>(1) &lt;&lt; 0)
           #define SD_LOGIND_KEXEC_REBOOT                   (<a href="../man1/UINT64_C.1.html">UINT64_C</a>(1) &lt;&lt; 1)
           #define SD_LOGIND_SOFT_REBOOT                    (<a href="../man1/UINT64_C.1.html">UINT64_C</a>(1) &lt;&lt; 2)
           #define SD_LOGIND_SOFT_REBOOT_IF_NEXTROOT_SET_UP (<a href="../man1/UINT64_C.1.html">UINT64_C</a>(1) &lt;&lt; 3)
           #define SD_LOGIND_SKIP_INHIBITORS                (<a href="../man1/UINT64_C.1.html">UINT64_C</a>(1) &lt;&lt; 4)

       When the <u>flags</u> is 0 then these methods behave just like the versions without flags. Since systemd version
       257 active inhibitors are honoured by default for privileged users too.  <b>SD_LOGIND_ROOT_CHECK_INHIBITORS</b>
       (0x01) now only applies to weak inhibitors, to request that they honoured for privileged users too, since
       they ignore them by default. A new flag <b>SD_LOGIND_SKIP_INHIBITORS</b> (0x04) can be specified to bypass all
       types of inhibitors. When <b>SD_LOGIND_KEXEC_REBOOT</b> (0x02) is set, then <b>RebootWithFlags()</b> performs a kexec
       reboot if kexec kernel is loaded. When <b>SD_LOGIND_SOFT_REBOOT</b> (0x04) is set, or
       <b>SD_LOGIND_SOFT_REBOOT_IF_NEXTROOT_SET_UP</b> (0x08) is set and a new root file system has been set up on
       "/run/nextroot/", then <b>RebootWithFlags()</b> performs a userspace reboot only.
       <b>SD_LOGIND_SOFT_REBOOT_IF_NEXTROOT_SET_UP</b> and <b>SD_LOGIND_KEXEC_REBOOT</b> can be combined, with soft-reboot
       having precedence.

       <b>SetRebootParameter()</b> sets a parameter for a subsequent reboot operation. See the description of <b>reboot</b> in
       <b><a href="../man1/systemctl.1.html">systemctl</a></b>(1) and <b><a href="../man2/reboot.2.html">reboot</a></b>(2) for more information.

       <b>SetRebootToFirmwareSetup()</b>, <b>SetRebootToBootLoaderMenu()</b>, and <b>SetRebootToBootLoaderEntry()</b> configure the
       action to be taken from the boot loader after a reboot: respectively entering firmware setup mode, the
       boot loader menu, or a specific boot loader entry. See <b><a href="../man1/systemctl.1.html">systemctl</a></b>(1) for the corresponding command line
       interface.

       <b>CanPowerOff()</b>, <b>CanReboot()</b>, <b>CanHalt()</b>, <b>CanSuspend()</b>, <b>CanHibernate()</b>, <b>CanHybridSleep()</b>,
       <b>CanSuspendThenHibernate()</b>, <b>CanSleep()</b>, <b>CanRebootParameter()</b>, <b>CanRebootToFirmwareSetup()</b>,
       <b>CanRebootToBootLoaderMenu()</b>, and <b>CanRebootToBootLoaderEntry()</b> test whether the system supports the
       respective operation and whether the calling user is allowed to execute it. Returns one of "na", "yes",
       "no", and "challenge". If "na" is returned, the operation is not available because hardware, kernel, or
       drivers do not support it. If "yes" is returned, the operation is supported and the user may execute the
       operation without further authentication. If "no" is returned, the operation is available but the user is
       not allowed to execute the operation. If "challenge" is returned, the operation is available but only
       after authorization.

       <b>ScheduleShutdown()</b> schedules a shutdown operation <u>type</u> at time <u>usec</u> in microseconds since the UNIX epoch.
       Alternatively, if <u>usec</u> "UINT64_MAX" and a maintenance window is configured, systemd-logind will use the
       next time of the maintenance window instead.  <u>type</u> can be one of "poweroff", "dry-poweroff", "reboot",
       "dry-reboot", "halt", and "dry-halt". (The "dry-" variants do not actually execute the shutdown action.)
       <b>CancelScheduledShutdown()</b> cancels a scheduled shutdown. The output parameter <u>cancelled</u> is true if a
       shutdown operation was scheduled.

       <b>SetWallMessage()</b> sets the wall message (the message that will be sent out to all terminals and stored in
       a <b><a href="../man5/utmp.5.html">utmp</a></b>(5) record) for a subsequent scheduled shutdown operation. The parameter <u>wall_message</u> specifies the
       shutdown reason (and may be empty) which will be included in the shutdown message. The parameter <u>enable</u>
       specifies whether to print a wall message on shutdown.

       <b>Inhibit()</b> creates an inhibition lock. It takes four parameters: <u>what</u>, <u>who</u>, <u>why</u>, and <u>mode</u>.  <u>what</u> is one or
       more of "shutdown", "sleep", "idle", "handle-power-key", "handle-suspend-key", "handle-hibernate-key",
       "handle-lid-switch", separated by colons, for inhibiting poweroff/reboot, suspend/hibernate, the
       automatic idle logic, or hardware key handling.  <u>who</u> should be a short human readable string identifying
       the application taking the lock.  <u>why</u> should be a short human readable string identifying the reason why
       the lock is taken. Finally, <u>mode</u> is either "block" or "delay" which encodes whether the inhibit shall be
       consider mandatory or whether it should just delay the operation to a certain maximum time, while the
       "block-weak" and variants will create an inhibitor that is automatically ignored in some circumstances.
       The method returns a file descriptor. The lock is released the moment this file descriptor and all its
       duplicates are closed. For more information on the inhibition logic see <b>Inhibitor</b> <b>Locks</b>[2].

   <b>Signals</b>
       Whenever the inhibition state or idle hint changes, <b>PropertyChanged</b> signals are sent out to clients which
       have subscribed.

       The <b>SecureAttentionKey()</b> signal is sent when the user presses Ctrl+Alt+Shift+Esc to request the login
       manager to display the greeter, for instance in the case of a deadlocked compositor.

       The <b>SessionNew()</b>, <b>SessionRemoved()</b>, <b>UserNew()</b>, <b>UserRemoved()</b>, <b>SeatNew()</b>, and <b>SeatRemoved()</b> signals are
       sent each time a session is created or removed, a user logs in or out, or a seat is added or removed.
       They each contain the ID of the object plus the object path.

       The <b>PrepareForShutdown()</b>, <b>PrepareForShutdownWithMetadata()</b>, and <b>PrepareForSleep()</b> signals are sent right
       before (with the argument "true") or after (with the argument "false") the system goes down for
       reboot/poweroff and suspend/hibernate, respectively. This may be used by applications to save data on
       disk, release memory, or do other jobs that should be done shortly before shutdown/sleep, in conjunction
       with delay inhibitor locks. After completion of this work they should release their inhibition locks in
       order to not delay the operation any further. For more information see <b>Inhibitor</b> <b>Locks</b>[2]. The
       <b>PrepareForShutdownWithMetadata()</b> signal additionally sends a list of key/value pair metadata fields.
       Currently it sends a <u>type</u> string which defines the type of shutdown. The type can be one of "power-off",
       "reboot", "halt", "kexec" or "soft-reboot". This signal is sent first, followed by <b>PrepareForShutdown()</b>
       (for backward compatibility).

   <b>Properties</b>
       Most properties simply reflect the configuration, see <b><a href="../man5/logind.conf.5.html">logind.conf</a></b>(5). This includes: <u>NAutoVTs</u>,
       <u>KillOnlyUsers</u>, <u>KillExcludeUsers</u>, <u>KillUserProcesses</u>, <u>IdleAction</u>, <u>InhibitDelayMaxUSec</u>, <u>InhibitorsMax</u>,
       <u>UserStopDelayUSec</u>, <u>HandlePowerKey</u>, <u>HandleSuspendKey</u>, <u>HandleHibernateKey</u>, <u>HandleLidSwitch</u>,
       <u>HandleLidSwitchExternalPower</u>, <u>HandleLidSwitchDocked</u>, <u>IdleActionUSec</u>, <u>HoldoffTimeoutUSec</u>, <u>RemoveIPC</u>,
       <u>RuntimeDirectorySize</u>, <u>RuntimeDirectoryInodesMax</u>, <u>InhibitorsMax</u>, and <u>SessionsMax</u>.

       The <u>IdleHint</u> property reflects the idle hint state of the system. If the system is idle it might get into
       automatic suspend or shutdown depending on the configuration.

       <u>IdleSinceHint</u> and <u>IdleSinceHintMonotonic</u> encode the timestamps of the last change of the idle hint
       boolean, in <b>CLOCK_REALTIME</b> and <b>CLOCK_MONOTONIC</b> timestamps, respectively, in microseconds since the epoch.

       The <u>BlockInhibited</u>, <u>BlockWeakInhibited</u>, and <u>DelayInhibited</u> properties encode the currently active locks
       of the respective modes. They are colon separated lists of "shutdown", "sleep", and "idle" (see above).

       <u>NCurrentSessions</u> and <u>NCurrentInhibitors</u> contain the number of currently registered sessions and
       inhibitors.

       The <u>BootLoaderEntries</u> property contains a list of boot loader entries. This includes boot loader entries
       defined in configuration and any additional loader entries reported by the boot loader. See <b><a href="../man7/systemdboot.7.html">systemd-</a></b>
       <b><a href="../man7/systemdboot.7.html">boot</a></b>(7) for more information.

       The <u>PreparingForShutdown</u> and <u>PreparingForSleep</u> boolean properties are true during the interval between
       the two <b>PrepareForShutdown()</b> and <b>PrepareForSleep()</b> signals respectively. The
       <u>PreparingForShutdownWithMetadata</u> property provides a list of key/value pair metadata fields. Currently it
       lists a <u>preparing</u> boolean that corresponds to the <u>PreparingForShutdown</u> property, and, if a shutdown is
       being prepared, it will also contain a <u>type</u> string which defines the type of shutdown. The type can be
       one of "power-off", "reboot", "halt", "kexec" or "soft-reboot". Note that these properties do not send
       out <b>PropertyChanged</b> signals.

       The <u>RebootParameter</u> property shows the value set with the <b>SetRebootParameter()</b> method described above.

       <u>ScheduledShutdown</u> shows the value pair set with the <b>ScheduleShutdown()</b> method described above.

       <u>RebootToFirmwareSetup</u>, <u>RebootToBootLoaderMenu</u>, and <u>RebootToBootLoaderEntry</u> are true when the resprective
       post-reboot operation was selected with <b>SetRebootToFirmwareSetup()</b>, <b>SetRebootToBootLoaderMenu()</b>, or
       <b>SetRebootToBootLoaderEntry()</b>.

       The <u>WallMessage</u> and <u>EnableWallMessages</u> properties reflect the shutdown reason and wall message enablement
       switch which can be set with the <b>SetWallMessage()</b> method described above.

       <u>Docked</u> is true if the machine is connected to a dock.  <u>LidClosed</u> is true when the lid (of a laptop) is
       closed.  <u>OnExternalPower</u> is true when the machine is connected to an external power supply.

   <b>Security</b>
       A number of operations are protected via the polkit privilege system.  <b>SetUserLinger()</b> requires the
       org.freedesktop.login1.set-user-linger privilege.  <b>AttachDevice()</b> requires
       org.freedesktop.login1.attach-device and <b>FlushDevices()</b> requires org.freedesktop.login1.flush-devices.
       <b>PowerOff()</b>, <b>Reboot()</b>, <b>Halt()</b>, <b>Suspend()</b>, <b>Hibernate()</b> require org.freedesktop.login1.power-off,
       org.freedesktop.login1.power-off-multiple-sessions, org.freedesktop.login1.power-off-ignore-inhibit,
       org.freedesktop.login1.reboot, org.freedesktop.login1.reboot-multiple-sessions,
       org.freedesktop.login1.reboot-ignore-inhibit, org.freedesktop.login1.halt,
       org.freedesktop.login1.halt-multiple-sessions, org.freedesktop.login1.halt-ignore-inhibit,
       org.freedesktop.login1.suspend, org.freedesktop.login1.suspend-multiple-sessions,
       org.freedesktop.login1.suspend-ignore-inhibit, org.freedesktop.login1.hibernate,
       org.freedesktop.login1.hibernate-multiple-sessions, org.freedesktop.login1.hibernate-ignore-inhibit,
       respectively depending on whether there are other sessions around or active inhibits are present.
       <b>HybridSleep()</b> and <b>SuspendThenHibernate()</b> use the same privileges as <b>Hibernate()</b>.  <b>Sleep()</b> uses the
       inhibits of the auto-selected sleep operation.  <b>SetRebootParameter()</b> requires
       org.freedesktop.login1.set-reboot-parameter.

       <b>SetRebootToFirmwareSetup()</b> requires org.freedesktop.login1.set-reboot-to-firmware-setup.
       <b>SetRebootToBootLoaderMenu()</b> requires org.freedesktop.login1.set-reboot-to-boot-loader-menu.
       <b>SetRebootToBootLoaderEntry()</b> requires org.freedesktop.login1.set-reboot-to-boot-loader-entry.

       <b>ScheduleShutdown()</b> and <b>CancelScheduledShutdown()</b> require the same privileges (listed above) as the
       immediate poweroff/reboot/halt operations.

       <b>Inhibit()</b> is protected via one of org.freedesktop.login1.inhibit-block-shutdown,
       org.freedesktop.login1.inhibit-delay-shutdown, org.freedesktop.login1.inhibit-block-sleep,
       org.freedesktop.login1.inhibit-delay-sleep, org.freedesktop.login1.inhibit-block-idle,
       org.freedesktop.login1.inhibit-handle-power-key, org.freedesktop.login1.inhibit-handle-suspend-key,
       org.freedesktop.login1.inhibit-handle-hibernate-key, org.freedesktop.login1.inhibit-handle-lid-switch
       depending on the lock type and mode taken.

       The <u>interactive</u> boolean parameters can be used to control whether polkit should interactively ask the
       user for authentication credentials if required.

</pre><h4><b>SEAT</b> <b>OBJECTS</b></h4><pre>
           node /org/freedesktop/login1/seat/seat0 {
             interface org.freedesktop.login1.Seat {
               methods:
                 Terminate();
                 ActivateSession(in  s session_id);
                 SwitchTo(in  u vtnr);
                 SwitchToNext();
                 SwitchToPrevious();
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Id = '...';
                 readonly (so) ActiveSession = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b CanTTY = ...;
                 readonly b CanGraphical = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly a(so) Sessions = [...];
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>Terminate()</b> and <b>ActivateSession()</b> work similarly to <b>TerminateSeat()</b> and <b>ActivationSessionOnSeat()</b> on the
       Manager object.

       <b>SwitchTo()</b> switches to the session on the virtual terminal <u>vtnr</u>.  <b>SwitchToNext()</b> and <b>SwitchToPrevious()</b>
       switch to, respectively, the next and previous sessions on the seat in the order of virtual terminals. If
       there is no active session, they switch to, respectively, the first and last session on the seat.

   <b>Signals</b>
       Whenever <b>ActiveSession</b>, <b>Sessions</b>, <b>CanGraphical</b>, <b>CanTTY</b>, or the idle state changes, <b>PropertyChanged</b>
       signals are sent out to clients which have subscribed.

       Signals are only emitted on objects referencing a specific seat ID, not on the
       "/org/freedesktop/login1/seat/self" or "/org/freedesktop/login1/seat/auto" convenience objects, as they
       can only be dereferenced relative to a method caller.

   <b>Properties</b>
       The <u>Id</u> property encodes the ID of the seat.

       <u>ActiveSession</u> encodes the currently active session if there is one. It is a structure consisting of the
       session id and the object path.

       <u>CanTTY</u> encodes whether the session is suitable for text logins, and <u>CanGraphical</u> whether it is suitable
       for graphical sessions.

       The <u>Sessions</u> property is an array of all current sessions of this seat, each encoded in a structure
       consisting of the ID and the object path.

       The <u>IdleHint</u>, <u>IdleSinceHint</u>, and <u>IdleSinceHintMonotonic</u> properties encode the idle state, similarly to
       the ones exposed on the Manager object, but specific for this seat.

</pre><h4><b>USER</b> <b>OBJECTS</b></h4><pre>
           node /org/freedesktop/login1/user/_1000 {
             interface org.freedesktop.login1.User {
               methods:
                 Terminate();
                 Kill(in  i signal_number);
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u UID = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u GID = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Name = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t Timestamp = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t TimestampMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s RuntimePath = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Service = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Slice = '...';
                 readonly (so) Display = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly s State = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly a(so) Sessions = [...];
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
                 readonly b Linger = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>Terminate()</b> and <b>Kill()</b> work similarly to the <b>TerminateUser()</b> and <b>KillUser()</b> methods on the manager
       object.

   <b>Signals</b>
       Whenever <u>Sessions</u> or the idle state changes, <b>PropertyChanged</b> signals are sent out to clients which have
       subscribed.

       Signals are only emitted on objects referencing a specific UID, not on the
       "/org/freedesktop/login1/user/self" convenience object, as <u>self</u> can only be dereferenced relative to a
       method caller.

   <b>Properties</b>
       The <u>UID</u> and <u>GID</u> properties encode the Unix UID and primary GID of the user.

       The <u>Name</u> property encodes the user name.

       <u>Timestamp</u> and <u>TimestampMonotonic</u> encode the login time of the user in microseconds since the epoch, in
       the <b>CLOCK_REALTIME</b> and <b>CLOCK_MONOTONIC</b> clocks, respectively.

       <u>RuntimePath</u> encodes the runtime path of the user, i.e.  <u>$XDG_RUNTIME_DIR</u>. For details see the <b>XDG</b> <b>Basedir</b>
       <b>Specification</b>[3].

       <u>Service</u> contains the unit name of the user systemd service of this user. Each logged in user is assigned
       a user service that runs a user systemd instance. This is usually an instance of user@.service.

       <u>Slice</u> contains the unit name of the user systemd slice of this user. Each logged in user gets a private
       slice.

       <u>Display</u> encodes which graphical session should be used as the primary UI display for the user. It is a
       structure encoding the session ID and the object path of the session to use.

       <u>State</u> encodes the user state and is one of "offline", "lingering", "online", "active", or "closing". See
       <b><a href="../man3/sd_uid_get_state.3.html">sd_uid_get_state</a></b>(3) for more information about the states.

       <u>Sessions</u> is an array of structures encoding all current sessions of the user. Each structure consists of
       the ID and object path.

       The <u>IdleHint</u>, <u>IdleSinceHint</u>, and <u>IdleSinceHintMonotonic</u> properties encode the idle hint state of the
       user, similarly to the Manager's properties, but specific for this user.

       The <u>Linger</u> property shows whether lingering is enabled for this user.

</pre><h4><b>SESSION</b> <b>OBJECTS</b></h4><pre>
           node /org/freedesktop/login1/session/1 {
             interface org.freedesktop.login1.Session {
               methods:
                 Terminate();
                 Activate();
                 Lock();
                 Unlock();
                 SetIdleHint(in  b idle);
                 SetLockedHint(in  b locked);
                 Kill(in  s whom,
                      in  i signal_number);
                 TakeControl(in  b force);
                 ReleaseControl();
                 SetType(in  s type);
                 SetClass(in  s class);
                 SetDisplay(in  s display);
                 SetTTY(in  h tty_fd);
                 TakeDevice(in  u major,
                            in  u minor,
                            out h fd,
                            out b inactive);
                 ReleaseDevice(in  u major,
                               in  u minor);
                 PauseDeviceComplete(in  u major,
                                     in  u minor);
                 SetBrightness(in  s subsystem,
                               in  s name,
                               in  u brightness);
               signals:
                 PauseDevice(u major,
                             u minor,
                             s type);
                 ResumeDevice(u major,
                              u minor,
                              h fd);
                 Lock();
                 Unlock();
               properties:
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Id = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly (uo) User = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Name = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t Timestamp = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly t TimestampMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u VTNr = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly (so) Seat = ...;
                 readonly s TTY = '...';
                 readonly s Display = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b Remote = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s RemoteHost = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s RemoteUser = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Service = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Desktop = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly s Scope = '...';
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u Leader = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly u Audit = ...;
                 readonly s Type = '...';
                 readonly s Class = '...';
                 readonly b Active = ...;
                 readonly s State = '...';
                 readonly b IdleHint = ...;
                 readonly t IdleSinceHint = ...;
                 readonly t IdleSinceHintMonotonic = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b CanIdle = ...;
                 @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
                 readonly b CanLock = ...;
                 readonly b LockedHint = ...;
             };
             interface org.freedesktop.DBus.Peer { ... };
             interface org.freedesktop.DBus.Introspectable { ... };
             interface org.freedesktop.DBus.Properties { ... };
           };

   <b>Methods</b>
       <b>Terminate()</b>, <b>Activate()</b>, <b>Lock()</b>, <b>Unlock()</b>, and <b>Kill()</b> work similarly to the respective calls on the
       Manager object.

       <b>SetIdleHint()</b> is called by the session object to update the idle state of the session whenever it
       changes.

       <b>TakeControl()</b> allows a process to take exclusive managed device access-control for that session. Only one
       D-Bus connection can be a controller for a given session at any time. If the <u>force</u> argument is set (root
       only), an existing controller is kicked out and replaced. Otherwise, this method fails if there is
       already a controller. Note that this method is limited to D-Bus users with the effective UID set to the
       user of the session or root.

       <b>ReleaseControl()</b> drops control of a given session. Closing the D-Bus connection implicitly releases
       control as well. See <b>TakeControl()</b> for more information. This method also releases all devices for which
       the controller requested ownership via <b>TakeDevice()</b>.

       <b>SetType()</b> allows the type of the session to be changed dynamically. It can only be called by session's
       current controller. If <b>TakeControl()</b> has not been called, this method will fail. In addition, the session
       type will be reset to its original value once control is released, either by calling <b>ReleaseControl()</b> or
       closing the D-Bus connection. This should help prevent a session from entering an inconsistent state, for
       example if the controller crashes. The only argument <u>type</u> is the new session type.

       <b>SetClass()</b> allows the caller to change the class of the session dynamically. It may only be called by
       session's owening user. Currently, this call may be exclusively used to change the class from
       "user-incomplete" to "user". The call is synchronous, and will return only once the user's service
       manager has successfully been started, if necessary. The only argument <u>type</u> is the new session type.

       <b>SetDisplay()</b> allows the display name of the graphical session to be changed. This is useful if the
       display server is started as part of the session. It can only be called by session's current controller.
       If <b>TakeControl()</b> has not been called, this method will fail. The only argument <u>display</u> is the new display
       name.

       <b>SetTTY()</b> allows the device name of the session to be changed. This is useful if the tty device is only
       known after authentication. It can only be called by session's current controller. If <b>TakeControl()</b> has
       not been called, this method will fail. The only argument <u>tty_fd</u> is a file handle to the new tty device.

       <b>TakeDevice()</b> allows a session controller to get a file descriptor for a specific device. Pass in the
       major and minor numbers of the character device and systemd-logind will return a file descriptor for the
       device. Only a limited set of device-types is currently supported (but may be extended).  systemd-logind
       automatically mutes the file descriptor if the session is inactive and resumes it once the session is
       activated again. This guarantees that a session can only access session devices if the session is active.
       Note that this revoke/resume mechanism is asynchronous and may happen at any given time. This only works
       on devices that are attached to the seat of the given session. A process is not required to have direct
       access to the device node.  systemd-logind only requires you to be the active session controller (see
       <b>TakeControl()</b>). Also note that any device can only be requested once. As long as you do not release it,
       further <b>TakeDevice()</b> calls will fail.

       <b>ReleaseDevice()</b> releases a device again (see <b>TakeDevice()</b>). This is also implicitly done by
       <b>ReleaseControl()</b> or when closing the D-Bus connection.

       <b>PauseDeviceComplete()</b> allows a session controller to synchronously pause a device after receiving a
       <b>PauseDevice("pause")</b> signal. Forced signals (or after an internal timeout) are automatically completed by
       systemd-logind asynchronously.

       <b>SetLockedHint()</b> may be used to set the "locked hint" to <u>locked</u>, i.e. information whether the session is
       locked. This is intended to be used by the desktop environment to tell <b>systemd-logind</b> when the session is
       locked and unlocked.

       <b>SetBrightness()</b> may be used to set the display brightness. This is intended to be used by the desktop
       environment and allows unprivileged programs to access hardware settings in a controlled way. The
       <u>subsystem</u> parameter specifies a kernel subsystem, either "backlight" or "leds". The <u>name</u> parameter
       specifies a device name under the specified subsystem. The <u>brightness</u> parameter specifies the brightness.
       The range is defined by individual drivers, see <a href="file:/sys/class/">/sys/class/</a><u>subsystem</u>/<u>name</u>/max_brightness.

   <b>Signals</b>
       The active session controller exclusively gets <b>PauseDevice()</b> and <b>ResumeDevice()</b> events for any device it
       requested via <b>TakeDevice()</b>. They notify the controller whenever a device is paused or resumed. A device
       is never resumed if its session is inactive. Also note that <b>PauseDevice()</b> signals are sent before the
       <b>PropertyChanged</b> signal for the <b>Active</b> state. The inverse is true for <b>ResumeDevice()</b>. A device may remain
       paused for unknown reasons even though the Session is active.

       A <b>PauseDevice()</b> signal carries the major and minor numbers and a string describing the type as arguments.
       <b>force</b> means the device was already paused by systemd-logind and the signal is only an asynchronous
       notification.  <b>pause</b> means systemd-logind grants you a limited amount of time to pause the device. You
       must respond to this via <b>PauseDeviceComplete()</b>. This synchronous pausing mechanism is used for
       backwards-compatibility to VTs and systemd-logind is free to not make use of it. It is also free to send
       a forced <b>PauseDevice()</b> if you do not respond in a timely manner (or for any other reason).  <b>gone</b> means
       the device was unplugged from the system and you will no longer get any notifications about it. There is
       no need to call <b>ReleaseDevice()</b>. You may call <b>TakeDevice()</b> again if a new device is assigned the
       major+minor combination.

       <b>ResumeDevice()</b> is sent whenever a session is active and a device is resumed. It carries the major/minor
       numbers as arguments and provides a new open file descriptor. You should switch to the new descriptor and
       close the old one. They are not guaranteed to have the same underlying open file descriptor in the kernel
       (except for a limited set of device types).

       Whenever <b>Active</b> or the idle state changes, <b>PropertyChanged</b> signals are sent out to clients which have
       subscribed.

       <b>Lock()</b>/<b>Unlock()</b> is sent when the session is asked to be screen-locked/unlocked. A session manager of the
       session should listen to this signal and act accordingly. This signal is sent out as a result of the
       <b>Lock()</b> and <b>Unlock()</b> methods, respectively.

       Signals are only emitted on objects referencing a specific session ID, not on the
       "/org/freedesktop/login1/session/self" or "/org/freedesktop/login1/session/auto" convenience objects, as
       they can only be dereferenced relative to a method caller.

   <b>Properties</b>
       <u>Id</u> encodes the session ID.

       <u>User</u> encodes the user ID of the user this session belongs to. This is a structure consisting of the Unix
       UID and the object path.

       <u>Name</u> encodes the user name.

       <u>Timestamp</u> and <u>TimestampMonotonic</u> encode the microseconds since the epoch when the session was created, in
       <b>CLOCK_REALTIME</b> or <b>CLOCK_MONOTONIC</b>, respectively.

       <u>VTNr</u> encodes the virtual terminal number of the session if there is any, 0 otherwise.

       <u>Seat</u> encodes the seat this session belongs to if there is any. This is a structure consisting of the ID
       and the seat object path.

       <u>TTY</u> encodes the kernel TTY path of the session if this is a text login. If not this is an empty string.

       <u>Display</u> encodes the X11 display name if this is a graphical login. If not, this is an empty string.

       <u>Remote</u> encodes whether the session is local or remote.

       <u>RemoteHost</u> and <u>RemoteUser</u> encode the remote host and user if this is a remote session, or an empty string
       otherwise.

       <u>Service</u> encodes the PAM service name that registered the session.

       <u>Desktop</u> describes the desktop environment running in the session (if known).

       <u>Scope</u> contains the systemd scope unit name of this session.

       <u>Leader</u> encodes the PID of the process that registered the session.

       <u>Audit</u> encodes the Kernel Audit session ID of the session if auditing is available.

       <u>Type</u> encodes the session type. It's one of "unspecified" (for cron PAM sessions and suchlike), "tty" (for
       text logins), "web" (for web-based logins), or "x11"/"mir"/"wayland" (for graphical logins).

       <u>Class</u> encodes the session class. It's one of "user" (for normal user sessions), "greeter" (for display
       manager pseudo-sessions), or "lock-screen" (for display lock screens).

       <u>Active</u> is a boolean that is true if the session is active, i.e. currently in the foreground. This field
       is semi-redundant due to <u>State</u>.

       <u>State</u> encodes the session state and one of "online", "active", or "closing". See <b><a href="../man3/sd_session_get_state.3.html">sd_session_get_state</a></b>(3)
       for more information about the states.

       <u>IdleHint</u>, <u>IdleSinceHint</u>, and <u>IdleSinceHintMonotonic</u> encapsulate the idle hint state of this session,
       similarly to how the respective properties on the manager object do it for the whole system.

       <u>LockedHint</u> shows the locked hint state of this session, as set by the <b>SetLockedHint()</b> method described
       above.

       <u>CanIdle</u> indicates whether the session supports the idle hint concept. Similarly, <u>CanLock</u> indicates
       whether the session supports the screen lock concept.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>Example</b> <b>1.</b> <b>Introspect</b> <b>the</b> <b>logind</b> <b>manager</b> <b>on</b> <b>the</b> <b>bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
             --object-path /org/freedesktop/login1

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1

       <b>Example</b> <b>2.</b> <b>Introspect</b> <b>the</b> <b>default</b> <b>seat</b> <b>on</b> <b>the</b> <b>bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
            --object-path /org/freedesktop/login1/seat/seat0

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/seat/seat0

       Seat "seat0" is the default seat, so it'll be present unless local configuration is made to reassign all
       devices to a different seat. The list of seats and users can be acquired with <b>loginctl</b> <b>list-sessions</b>.

       <b>Example</b> <b>3.</b> <b>Introspect</b> <b>a</b> <b>single</b> <b>user</b> <b>on</b> <b>the</b> <b>bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
             --object-path /org/freedesktop/login1/user/_1000

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/user/_1000

       <b>Example</b> <b>4.</b> <b>Introspect</b> <b>org.freedesktop.login1.Session</b> <b>on</b> <b>the</b> <b>bus</b>

           $ gdbus introspect --system --dest org.freedesktop.login1 \
             --object-path /org/freedesktop/login1/session/45

       or

           $ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/session/45

</pre><h4><b>VERSIONING</b></h4><pre>
       These D-Bus interfaces follow <b>the</b> <b>usual</b> <b>interface</b> <b>versioning</b> <b>guidelines</b>[4].

</pre><h4><b>HISTORY</b></h4><pre>
   <b>The</b> <b>Manager</b> <b>Object</b>
       <u>HandlePowerKeyLongPress</u>, <u>HandleRebootKey</u>, <u>HandleRebootKeyLongPress</u>, <u>HandleSuspendKeyLongPress</u>, and
       <u>HandleHibernateKeyLongPress</u> were added in version 251.

       <u>StopIdleSessionUSec</u> was added in version 252.

       <b>PrepareForShutdownWithMetadata()</b> and <b>CreateSessionWithPIDFD()</b> were added in version 255.

       <b>Sleep()</b>, <b>CanSleep()</b>, <u>SleepOperation</u>, and <b>ListSessionsEx()</b> were added in version 256.

       <u>HandleSecureAttentionKey</u>, <b>SecureAttentionKey()</b>, <u>PreparingForShutdownWithMetadata</u>,
       <u>DesignatedMaintenanceTime</u>, <u>CanIdle</u>, <u>CanLock</u>, and <u>BlockWeakInhibited</u> were added in version 257.

   <b>Session</b> <b>Objects</b>
       <b>SetDisplay()</b> was added in version 252.

       <b>SetTTY()</b> was added in version 254.

       <b>SetClass()</b> was added in version 256.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man8/systemd-logind.service.8.html">systemd-logind.service</a></b>(8), <b><a href="../man1/loginctl.1.html">loginctl</a></b>(1)

</pre><h4><b>NOTES</b></h4><pre>
        1. polkit
           https://www.freedesktop.org/software/polkit/docs/latest/

        2. Inhibitor Locks
           https://systemd.io/INHIBITOR_LOCKS

        3. XDG Basedir Specification
           https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html

        4. the usual interface versioning guidelines
           https://0pointer.de/blog/projects/versioning-dbus.html

systemd 257.7                                                                          <u><a href="../man5/ORG.FREEDESKTOP.LOGIN1.5.html">ORG.FREEDESKTOP.LOGIN1</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>