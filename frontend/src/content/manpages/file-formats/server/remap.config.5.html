<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>remap.config - Traffic Server remap rules configuration file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/trafficserver">trafficserver_9.2.5+ds-1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       remap.config - Traffic Server remap rules configuration file

       The  <u>remap.config</u> file (by default, located in <b>/usr/local/etc/trafficserver/</b>) contains mapping rules that
       Traffic Server uses to perform the following actions:

       • Map URL requests for a specific origin server to  the  appropriate  location  on  Traffic  Server  when
         Traffic Server acts as a reverse proxy for that particular origin server

       • Reverse-map  server  location  headers so that when origin servers respond to a request with a location
         header that redirects the client to another location, the clients do not bypass Traffic Server

       • Redirect HTTP requests permanently or temporarily without Traffic Server having to contact  any  origin
         servers

       Refer  to   <u>Reverse</u>  <u>Proxy</u>  <u>and</u> <u>HTTP</u> <u>Redirects</u>, for information about redirecting HTTP requests and using
       reverse proxy.

       After you modify the <u>remap.config</u> run the <u>traffic_ctl</u> <u>config</u> <u>reload</u> to apply the changes.

</pre><h4><b>FORMAT</b></h4><pre>
       Each line in the <u>remap.config</u> file must contain a mapping rule. Empty lines, or lines starting with <b>#</b> are
       ignored. Each line can be broken up into multiple lines for better readability by using <b>\</b> as continuation
       marker.

       Traffic Server recognizes three space-delimited fields: <b>type</b>, <b>target</b>, and <b>replacement</b>. The following list
       describes the format of each field.

       <b>type</b>   Enter one of the following:

              • <b>map</b> --translates an incoming request URL to the appropriate origin server URL.

              • <b>map_with_recv_port</b> --exactly like 'map' except that it uses the port at which  the  request  was
                received  to perform the mapping instead of the port present in the request. The regex qualifier
                can also be used for this type. When present, 'map_with_recv_port' mappings are  checked  first.
                If there is a match, then it is chosen without evaluating the "regular" forward mapping rules.

              • <b>map_with_referer</b>  --  extended  version  of  'map',  which can be used to activate "deep linking
                protection", where target URLs are only accessible when the Referer header is set to a URL  that
                is allowed to link to the target.

              • <b>reverse_map</b>  --translates  the  URL  in origin server redirect responses to point to the Traffic
                Server.

              • <b>redirect</b> --redirects HTTP requests permanently without having  to  contact  the  origin  server.
                Permanent  redirects notify the browser of the URL change (by returning an HTTP status code 301)
                so that the browser can update bookmarks.

              • <b>redirect_temporary</b> --redirects HTTP requests temporarily without having to  contact  the  origin
                server.  Temporary  redirects  notify the browser of the URL change for the current request only
                (by returning an HTTP status code 307).

                <b>NOTE:</b>
                   use the <b>regex_</b> prefix to indicate that the line has a regular expression (regex).

       <b>target</b> Enter the request ("from") URL. You can enter up to four components:

                 scheme://host:port/path_prefix

              where <b>scheme</b> is <b>http</b>, <b>https</b>, <b>ws</b> or <b>wss</b>.

       <b>replacement</b>
                 Enter the origin ("to") URL. You can enter up to four components:

                     scheme://host:port/path_prefix

                 where <b>scheme</b> is <b>http</b>, <b>https</b>, <b>ws</b> or <b>wss</b>.

              <b>NOTE:</b>
                 A remap rule for requests that upgrade from HTTP to WebSocket still require a remap  rule  with
                 the <b>ws</b> or <b>wss</b> scheme.

</pre><h4><b>PRECEDENCE</b></h4><pre>
       Remap  rules are not processed top-down, but based on an internal priority. Once these rules are executed
       we pick the first match based on configuration file parse order.

       1. <b>map_with_recv_port</b> and <b>regex_map_with_recv_port</b>

       2. <b>map</b> and <b>regex_map</b> and <b>reverse_map</b>

       3. <b>redirect</b> and <b>redirect_temporary</b>

       4. <b>regex_redirect</b> and <b>regex_redirect_temporary</b>

       For each precedence group the rules are checked in two phases. If the first phase fails to find  a  match
       then  the  second  phase  is  performed against the same group of rules. In the first phase the rules are
       checked using the host name of the request. Only rules that specify a host name can match.  If  there  is
       no  match in that phase, then the rules are checked again with no host name and only rules without a host
       will match. The result is that rules with an explicit host take precedence over rules without.

</pre><h4><b>MATCH-ALL</b></h4><pre>
       A map rule with a single <b>/</b> acts as a wildcard, it will match any request. This should be use  with  care,
       and certainly only once at the end of the remap.config file. E.g.

          map / <a href="http://all.example.com">http://all.example.com</a>

   <b>Examples</b>
       The following section shows example mapping rules in the <u>remap.config</u> file.

   <b>Reverse</b> <b>Proxy</b> <b>Mapping</b> <b>Rules</b>
       The following example shows a map rule that does not specify a path prefix in the target or replacement:

          map <a href="http://www.x.com/">http://www.x.com/</a> <a href="http://server.hoster.com/">http://server.hoster.com/</a>
          reverse_map <a href="http://server.hoster.com/">http://server.hoster.com/</a> <a href="http://www.x.com/">http://www.x.com/</a>

       This rule results in the following translations:
       ┌──────────────────────────────────────────────┬──────────────────────────────────────────────────────┐
       │ Client Request                               │ Translated Request                                   │
       ├──────────────────────────────────────────────┼──────────────────────────────────────────────────────┤
       │ <b><a href="http://www.x.com/Widgets/index.html">http://www.x.com/Widgets/index.html</a></b>          │ <b><a href="http://server.hoster.com/Widgets/index.html">http://server.hoster.com/Widgets/index.html</a></b>          │
       ├──────────────────────────────────────────────┼──────────────────────────────────────────────────────┤
       │ <b><a href="http://www.x.com/cgi/form/submit.sh">http://www.x.com/cgi/form/submit.sh</a>?arg=true</b> │ <b><a href="http://server.hoster.com/cgi/form/submit.sh">http://server.hoster.com/cgi/form/submit.sh</a>?arg=true</b> │
       └──────────────────────────────────────────────┴──────────────────────────────────────────────────────┘

       The following example shows a map rule with path prefixes specified in the target:

          map <a href="http://www.y.com/marketing/">http://www.y.com/marketing/</a> <a href="http://marketing.y.com/">http://marketing.y.com/</a>
          reverse_map <a href="http://marketing.y.com/">http://marketing.y.com/</a> <a href="http://www.y.com/marketing/">http://www.y.com/marketing/</a>
          map <a href="http://www.y.com/sales/">http://www.y.com/sales/</a> <a href="http://sales.y.com/">http://sales.y.com/</a>
          reverse_map <a href="http://sales.y.com/">http://sales.y.com/</a> <a href="http://www.y.com/sales/">http://www.y.com/sales/</a>
          map <a href="http://www.y.com/engineering/">http://www.y.com/engineering/</a> <a href="http://engineering.y.com/">http://engineering.y.com/</a>
          reverse_map <a href="http://engineering.y.com/">http://engineering.y.com/</a> <a href="http://www.y.com/engineering/">http://www.y.com/engineering/</a>
          map <a href="http://www.y.com/stuff/">http://www.y.com/stuff/</a> <a href="http://info.y.com/">http://info.y.com/</a>
          reverse_map <a href="http://info.y.com/">http://info.y.com/</a> <a href="http://www.y.com/stuff/">http://www.y.com/stuff/</a>

       These rules result in the following translations:
┌─────────────────────────────────────────────────────────────┬────────────────────────────────────────────────────────┐
├─────────────────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│ <b><a href="http://www.y.com/marketing/projects/manhattan/specs.html">http://www.y.com/marketing/projects/manhattan/specs.html</a></b>    │ <b><a href="http://marketing.y.com/projects/manhattan/specs.html">http://marketing.y.com/projects/manhattan/specs.html</a></b>   │
├─────────────────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│ <b><a href="http://www.y.com/stuff/marketing/projects/boston/specs.html">http://www.y.com/stuff/marketing/projects/boston/specs.html</a></b> │ <b><a href="http://info.y.com/marketing/projects/boston/specs.html">http://info.y.com/marketing/projects/boston/specs.html</a></b> │
├─────────────────────────────────────────────────────────────┼────────────────────────────────────────────────────────┤
│ <b><a href="http://www.y.com/engineering/marketing/requirements.html">http://www.y.com/engineering/marketing/requirements.html</a></b>    │ <b><a href="http://engineering.y.com/marketing/requirements.html">http://engineering.y.com/marketing/requirements.html</a></b>   │
└─────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────┘

       The following example shows that the order of the rules matters:

          map <a href="http://www.g.com/">http://www.g.com/</a> <a href="http://external.g.com/">http://external.g.com/</a>
          reverse_map <a href="http://external.g.com/">http://external.g.com/</a> <a href="http://www.g.com/">http://www.g.com/</a>
          map <a href="http://www.g.com/stuff/">http://www.g.com/stuff/</a> <a href="http://stuff.g.com/">http://stuff.g.com/</a>
          reverse_map <a href="http://stuff.g.com/">http://stuff.g.com/</a> <a href="http://www.g.com/stuff/">http://www.g.com/stuff/</a>

       These rules result in the following translation.
                         ┌──────────────────────────────┬───────────────────────────────────┐
                         │ Client Request               │ Translated Request                │
                         ├──────────────────────────────┼───────────────────────────────────┤
                         │ <b><a href="http://www.g.com/stuff/a.gif">http://www.g.com/stuff/a.gif</a></b> │ <b><a href="http://external.g.com/stuff/a.gif">http://external.g.com/stuff/a.gif</a></b> │
                         └──────────────────────────────┴───────────────────────────────────┘

       In  the above examples, the second rule is never applied because all URLs that match the second rule also
       match the first rule. The first rule takes precedence because it  appears  earlier  in  the  <u>remap.config</u>
       file.

       This  is different if one rule does not have a host. For example consider these rules using the <u>Match-All</u>
       rule:

          map / <a href="http://127.0.0.1">http://127.0.0.1</a>:8001/
          map <a href="http://example.com/dist_get_user">http://example.com/dist_get_user</a> <a href="http://127.0.0.1">http://127.0.0.1</a>:8001/denied.html

       These rules are set up to redirect requests to another local process. Using them will result in
                       ┌──────────────────────────────────┬───────────────────────────────────┐
                       │ Client Request                   │ Translated Request                │
                       ├──────────────────────────────────┼───────────────────────────────────┤
                       │ <b><a href="http://example.com/a.gif">http://example.com/a.gif</a></b>         │ <b><a href="http://127.0.0.1">http://127.0.0.1</a>:8001/a.gif</b>       │
                       ├──────────────────────────────────┼───────────────────────────────────┤
                       │ <b><a href="http://example.com/dist_get_user">http://example.com/dist_get_user</a></b> │ <b><a href="http://127.0.0.1">http://127.0.0.1</a>:8001/denied.html</b> │
                       └──────────────────────────────────┴───────────────────────────────────┘

       For the first request the second rule host matches but the path does not and so the second  rule  is  not
       selected.  The  first  rule is then matched in the second phase when the rules are checked without a host
       value.

       The second request is matched by the second rule even though the rules have  the  same  base  precedence.
       Because  the  first  rule does not have a host it will not match in the first phase. The second rule does
       have a host that matches the host in the second request along with the other parts  of  the  URL  and  is
       therefore selected in the first phase.

       This  will  yield  the  same  results  if  the  rules  are reversed because the rule selection happens in
       different phases making the order irrelevant.

          map <a href="http://example.com/dist_get_user">http://example.com/dist_get_user</a> <a href="http://127.0.0.1">http://127.0.0.1</a>:8001/denied.html
          map / <a href="http://127.0.0.1">http://127.0.0.1</a>:8001/

       The following example shows a mapping with a path prefix specified in the target and replacement:

          map <a href="http://www.h.com/a/b/">http://www.h.com/a/b/</a> <a href="http://server.h.com/customers/x/y">http://server.h.com/customers/x/y</a>
          reverse_map <a href="http://server.h.com/customers/x/y/">http://server.h.com/customers/x/y/</a> <a href="http://www.h.com/a/b/">http://www.h.com/a/b/</a>

       This rule results in the following translation.
                ┌───────────────────────────────────┬────────────────────────────────────────────────┐
                │ Client Request                    │ Translated Request                             │
                ├───────────────────────────────────┼────────────────────────────────────────────────┤
                │ <b><a href="http://www.h.com/a/b/c/d/doc.html">http://www.h.com/a/b/c/d/doc.html</a></b> │ <b><a href="http://server.h.com/customers/x/y/c/d/doc.html">http://server.h.com/customers/x/y/c/d/doc.html</a></b> │
                ├───────────────────────────────────┼────────────────────────────────────────────────┤
                │ <b><a href="http://www.h.com/a/index.html">http://www.h.com/a/index.html</a></b>     │ <b>Translation</b> <b>fails</b>                              │
                └───────────────────────────────────┴────────────────────────────────────────────────┘

       The following example shows reverse-map rules:

          map <a href="http://www.x.com/">http://www.x.com/</a> <a href="http://server.hoster.com/x/">http://server.hoster.com/x/</a>
          reverse_map <a href="http://server.hoster.com/x/">http://server.hoster.com/x/</a> <a href="http://www.x.com/">http://www.x.com/</a>

       These rules result in the following translations.
                          ┌──────────────────────────┬────────────────────────────────────┐
                          │ Client Request           │ Translated Request                 │
                          ├──────────────────────────┼────────────────────────────────────┤
                          │ <b><a href="http://www.x.com/Widgets">http://www.x.com/Widgets</a></b> │ <b><a href="http://server.hoster.com/x/Widgets">http://server.hoster.com/x/Widgets</a></b> │
                          └──────────────────────────┴────────────────────────────────────┘
            ┌──────────────────────────┬─────────────────────────────────────┬───────────────────────────┐
            │ Client Request           │ Origin Server Header                │ Translated Request        │
            ├──────────────────────────┼─────────────────────────────────────┼───────────────────────────┤
            │ <b><a href="http://www.x.com/Widgets">http://www.x.com/Widgets</a></b> │ <b><a href="http://server.hoster.com/x/Widgets/">http://server.hoster.com/x/Widgets/</a></b> │ <b><a href="http://www.x.com/Widgets/">http://www.x.com/Widgets/</a></b> │
            └──────────────────────────┴─────────────────────────────────────┴───────────────────────────┘

       When acting as a reverse proxy for multiple servers, Traffic Server is unable to route to URLs from older
       browsers   that   do   not   send   the   <b>Host:</b>   header.   As   a    solution,    set    the    variable
       <u>proxy.config.header.parse.no_host_url_redirect</u>  in  the  <u>records.config</u>  file to the URL to which Traffic
       Server will redirect requests without host headers.

   <b>Redirect</b> <b>Mapping</b> <b>Rules</b>
       The following rule permanently redirects all HTTP requests for <b>www.company.com</b> to <b>www.company2.com</b>:

          redirect <a href="http://www.company.com/">http://www.company.com/</a> <a href="http://www.company2.com/">http://www.company2.com/</a>

       The following rule <u>temporarily</u> redirects all HTTP requests for <b>www.company1.com</b> to <b>www.company2.com</b>:

          redirect_temporary <a href="http://www.company1.com/">http://www.company1.com/</a> <a href="http://www.company2.com/">http://www.company2.com/</a>

</pre><h4><b>REGULAR</b> <b>EXPRESSION</b> <b>(REGEX)</b> <b>REMAP</b> <b>SUPPORT</b></h4><pre>
       Regular expressions can be specified in remapping rules, with the limitations below:

       • Only the <b>host</b> field can contain  a  regex;  the  <b>scheme</b>,  <b>port</b>,  and  other  fields  cannot.  For  path
         manipulation via regexes, use the <u>Regex</u> <u>Remap</u> <u>Plugin</u>.

       • The  number  of  capturing  subpatterns  is  limited to 9. This means that <b>$0</b> through <b>$9</b> can be used as
         subtraction placeholders (<b>$0</b> will be the entire input string).

       • The number of substitutions in the expansion string is limited to 10.

       • There is no <b>regex_</b> equivalent to <b>reverse_remap</b>, so when  using  <b>regex_map</b>  you  should  make  sure  the
         reverse path is clear by setting (<u>proxy.config.url_remap.pristine_host_hdr</u>)

   <b>Examples</b>
          regex_map http://x([0-9]+).z.com/ <a href="http://real-x">http://real-x</a>$1.z.com/
          regex_redirect <a href="http://old">http://old</a>.(.*).z.com <a href="http://new">http://new</a>.$1.z.com

</pre><h4><b>MAP_WITH_REFERER</b></h4><pre>
       the format of is the following:

          map_with_referer client-URL origin-server-URL redirect-URL regex1 [regex2 ...]

       'redirect-URL'  is  a  redirection URL specified according to <u>RFC</u> <u>2616</u> and can contain special formatting
       instructions for run-time modifications of the resulting redirection URL.  All  regexes  Perl  compatible
       regular  expressions, which describes the content of the "Referer" header which must be verified. In case
       an actual request does not have "Referer" header or it does not match with  referer  regular  expression,
       the HTTP request will be redirected to 'redirect-URL'.

       At least one regular expressions must be specified in order to activate 'deep linking protection'.  There
       are  limitations  for  the  number  of referer regular expression strings - 2048.  In order to enable the
       'deep linking protection' feature in Traffic Server, configure records.config with:

          CONFIG proxy.config.http.referer_filter INT 1

       In order to enable run-time formatting for redirect URL, configure:

          CONFIG proxy.config.http.referer_format_redirect INT 1

       When run-time formatting for redirect-URL was enabled the following format symbols can be used:

          %r - to substitute original "Referer" header string
          %f - to substitute client-URL from 'map_with_referer' record
          %t - to substitute origin-server-URL from 'map_with_referer' record
          %o - to substitute request URL to origin server, which was created a
               the result of a mapping operation

       Note: There is a special referer type "~*" that can be used in order to specify that the  Referer  header
       is  optional  in  the  request.  If "~*" referer was used in map_with_referer mapping, only requests with
       Referer header will be verified for validity.  If the "~" symbol was  specified  before  referer  regular
       expression,  it  means that the request with a matching referer header will be redirected to redirectURL.
       It can be used to create a so-called negative referer list.   If  "*"  was  used  as  a  referer  regular
       expression  -  all  referrers  are allowed.  Various combinations of "*" and "~" in a referer list can be
       used to create different filtering rules.

   <b>map_with_referer</b> <b>Examples</b>
          map_with_referer <a href="http://y.foo.bar.com/x/yy/">http://y.foo.bar.com/x/yy/</a>  <a href="http://foo.bar.com/x/yy/">http://foo.bar.com/x/yy/</a> <a href="http://games.bar.com/new_games">http://games.bar.com/new_games</a> .*\.bar\.com www.bar-friends.com

       Explanation: Referer header must be in the  request,  only  ".*.bar.com"  and  "www.bar-friends.com"  are
       allowed.

          map_with_referer <a href="http://y.foo.bar.com/x/yy/">http://y.foo.bar.com/x/yy/</a>  <a href="http://foo.bar.com/x/yy/">http://foo.bar.com/x/yy/</a> <a href="http://games.bar.com/new_games">http://games.bar.com/new_games</a> * ~.*\.evil\.com

       Explanation: Referer header must be in the request but all referrers are allowed except ".*.evil.com".

          map_with_referer <a href="http://y.foo.bar.com/x/yy/">http://y.foo.bar.com/x/yy/</a>  <a href="http://foo.bar.com/x/yy/">http://foo.bar.com/x/yy/</a> <a href="http://games.bar.com/error">http://games.bar.com/error</a> ~* * ~.*\.evil\.com

       Explanation:  Referer  header  is  optional.  However,  if  Referer  header  exists,  only  request  from
       ".*.evil.com" will be redirected to redirect-URL.

</pre><h4><b>PLUGIN</b> <b>CHAINING</b></h4><pre>
       Plugins can be configured to be evaluated in a specific order, passing the results from  one  in  to  the
       next (unless a plugin returns 0, then the "chain" is broken).

   <b>Examples</b>
          map <a href="http://url/path">http://url/path</a> <a href="http://url/path">http://url/path</a> \
              @plugin=/etc/traffic_server/config/plugins/plugin1.so @pparam=1 @pparam=2 \
              @plugin=/etc/traffic_server/config/plugins/plugin2.so @pparam=3

       will pass "1" and "2" to plugin1.so and "3" to plugin2.so.

       This will pass "1" and "2" to plugin1.so and "3" to plugin2.so

</pre><h4><b>ACL</b> <b>FILTERS</b></h4><pre>
       Acl  filters can be created to control access of specific remap lines. The markup is very similar to that
       of <u>ip_allow.yaml</u>, with slight changes to accommodate remap markup

   <b>Examples</b>
          map <a href="http://foo.example.com/neverpost">http://foo.example.com/neverpost</a>  <a href="http://foo.example.com/neverpost">http://foo.example.com/neverpost</a> @action=deny @method=post
          map <a href="http://foo.example.com/onlypost">http://foo.example.com/onlypost</a>  <a href="http://foo.example.com/onlypost">http://foo.example.com/onlypost</a> @action=allow @method=post

          map <a href="http://foo.example.com/">http://foo.example.com/</a>  <a href="http://foo.example.com/">http://foo.example.com/</a> @action=deny @src_ip=1.2.3.4
          map <a href="http://foo.example.com/">http://foo.example.com/</a>  <a href="http://foo.example.com/">http://foo.example.com/</a> @action=allow @src_ip=127.0.0.1

          map <a href="http://foo.example.com/">http://foo.example.com/</a>  <a href="http://foo.example.com/">http://foo.example.com/</a> @action=allow @src_ip=10.5.2.1 @in_ip=72.209.23.4

          map <a href="http://foo.example.com/">http://foo.example.com/</a>  <a href="http://foo.example.com/">http://foo.example.com/</a> @action=allow @src_ip=127.0.0.1 @method=post @method=get @method=head

       Note that these Acl filters will return a 403 response if the resource is restricted.

       The difference between <b>@src_ip</b> and <b>@in_ip</b> is that the <b>@src_ip</b> is the client ip and the <b>in_ip</b>  is  the  ip
       address the client is connecting to (the incoming address).

</pre><h4><b>NAMED</b> <b>FILTERS</b></h4><pre>
       Named  filters can be created and applied to blocks of mappings using the <b>.definefilter</b>, <b>.activatefilter</b>,
       and <b>.deactivatefilter</b> directives. Named filters must be defined using <b>.definefilter</b>  before  being  used.
       Once  defined,  <b>.activatefilter</b>  can  used  to  activate  a  filter  for  all  mappings that follow until
       deactivated with <b>.deactivatefilter</b>.

       The <b>@internal</b> operator can be used to filter on whether a request is generated by Traffic Server  itself,
       usually by a plugin.  This operator is helpful for remapping internal requests without allowing access to
       external users. By default both internal and external requests are allowed.

   <b>Examples</b>
          .definefilter disable_delete_purge @action=deny @method=delete @method=purge
          .definefilter local_only @action=allow @src_ip=192.168.0.1-192.168.0.254 @src_ip=10.0.0.1-10.0.0.254

          .activatefilter disable_delete_purge

          map <a href="http://foo.example.com/">http://foo.example.com/</a> <a href="http://bar.example.com/">http://bar.example.com/</a>

          .activatefilter local_only
          map <a href="http://www.example.com/admin">http://www.example.com/admin</a> <a href="http://internal.example.com/admin">http://internal.example.com/admin</a>
          .deactivatefilter local_only

          map <a href="http://www.example.com/">http://www.example.com/</a> <a href="http://internal.example.com/">http://internal.example.com/</a>
          map <a href="http://auth.example.com/">http://auth.example.com/</a> <a href="http://auth.internal.example.com/">http://auth.internal.example.com/</a> @action=allow @internal

       The  filter <u>disable_delete_purge</u> will be applied to all of the mapping rules. (It is activated before any
       mappings and is never deactivated.) The filter <u>local_only</u> will only be applied to the second mapping.

</pre><h4><b>IMPLICT</b> <b>IPALLOW</b> <b>FILTER</b></h4><pre>
       To allow control of <u>IP</u> <u>Allow</u> it is treated as an implicitly active and named filter. When this filter  is
       active  IP  Allow  checks  are  done before remap. To prevent this for specific remap rules, this filter,
       named "ip_allow", must be disabled. The common way of doing this would be

          .deactivatefilter ip_allow
          map ...
          map ...
          .activateefilter ip_allow

       Note this entirely disables IP Allow checks for those remap rules.

</pre><h4><b>NEXTHOP</b> <b>SELECTION</b> <b>STRATEGIES</b></h4><pre>
       You may configure Nexthop or Parent hierarchical caching rules by remap using  the  <b>@strategy</b>  tag.   See
       <u>Hierarchical</u> <u>Caching</u> and <u>strategies.yaml</u> for configuration details and examples.

</pre><h4><b>INCLUDING</b> <b>ADDITIONAL</b> <b>REMAP</b> <b>FILES</b></h4><pre>
       The  <b>.include</b>  directive  allows  mapping  rules  to be spread across multiple files. The argument to the
       <b>.include</b> directive is a list of file names to be parsed for additional mapping rules.  Unless  the  names
       are absolute paths, they are resolved relative to the Traffic Server configuration directory.

       The  effect of the <b>.include</b> directive is as if the contents of the listed files is included in the parent
       and parsing restarted at the point of inclusion. This means that and filters named in the included  files
       are global in scope, and that additional <b>.include</b> directives are allowed.

       <b>NOTE:</b>
          Included  remap  files  are  not currently tracked by the configuration subsystem. Changes to included
          remap files will not be noticed by online configuration changes applied by <u>traffic_ctl</u>  <u>config</u>  <u>reload</u>
          unless <u>remap.config</u> has also changed.

   <b>Examples</b>
       In this example, a top-level <u>remap.config</u> file simply references additional mapping rules files

          .include filters.config
          .include one.example.com.config two.example.com.config

       The file <u>filters.config</u> contains

          .definefilter deny_purge @action=deny @method=purge
          .definefilter allow_purge @action=allow @method=purge

       The file <u>one.example.com.config</u> contains:

          .activatefilter deny_purge
          map <a href="http://one.example.com">http://one.example.com</a> <a href="http://origin-one.example.com">http://origin-one.example.com</a>
          .deactivatefilter deny_purge

       The file <u>two.example.com.config</u> contains:

          .activatefilter allow_purge
          map <a href="http://two.example.com">http://two.example.com</a> <a href="http://origin-two.example.com">http://origin-two.example.com</a>
          .deactivatefilter allow_purge

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2025, <a href="mailto:dev@trafficserver.apache.org">dev@trafficserver.apache.org</a>

9.2                                               May 22, 2025                                   <u><a href="../man5/REMAP.CONFIG.5.html">REMAP.CONFIG</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>