<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>crypt — storage format for hashed passphrases and available hashing methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcrypt-dev">libcrypt-dev_4.4.38-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       crypt — storage format for hashed passphrases and available hashing methods

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The hashing methods implemented by <u><a href="../man3/crypt.3.html">crypt</a></u>(3) are designed only to process user passphrases for storage and
       authentication; they are not suitable for use as general-purpose cryptographic hashes.

       Passphrase  hashing  is  not a replacement for strong passphrases.  It is always possible for an attacker
       with access to the hashed passphrases to guess and check possible cleartext passphrases.  However, with a
       strong hashing method, guessing will be too slow for the attacker to discover a strong passphrase.

       Most of the hashing methods use a “salt” to perturb the hash function, so that the  same  passphrase  may
       produce  many  possible  hashes.  Newer methods accept longer salt strings.  The salt should be chosen at
       random for each user.  Salt defeats a number of attacks:

       1.   It is not possible to hash a passphrase once and then test it against each  account's  stored  hash;
            the hash calculation must be repeated for each account.

       2.   It  is  not  possible  to  tell  whether  two  accounts use the same passphrase without successfully
            guessing one of the phrases.

       3.   Tables of precalculated hashes of commonly used passphrases must have an  entry  for  each  possible
            salt, which makes them impractically large.

       Most  of  the hashing methods are also deliberately engineered to be slow; they use many iterations of an
       underlying cryptographic primitive to increase the cost of each guess.  The newer hashing  methods  allow
       the  number of iterations to be adjusted, using the “processing cost” parameter to <u><a href="../man3/crypt_gensalt.3.html">crypt_gensalt</a></u>(3).  For
       memory-hard hashing methods such as yescrypt, this parameter also adjusts the amount of memory needed  to
       compute a hash.  Having this configurable makes it possible to keep password guessing attacks against the
       hashes slow and costly as hardware improves.

</pre><h4><b>FORMAT</b> <b>OF</b> <b>HASHED</b> <b>PASSPHRASES</b></h4><pre>
       All  of  the  hashing  methods  supported  by <u><a href="../man3/crypt.3.html">crypt</a></u>(3) produce a hashed passphrase which consists of four
       components: <u>prefix</u>, <u>options</u>, <u>salt</u>, and <u>hash</u>.  The prefix controls which hashing method is to be used, and
       is the appropriate string to pass to <u><a href="../man3/crypt_gensalt.3.html">crypt_gensalt</a></u>(3) to select that method.  The  contents  of  <u>options</u>,
       <u>salt</u>,  and  <u>hash</u> are up to the method.  Depending on the method, the <u>prefix</u> and <u>options</u> components may be
       empty.

       The <u>setting</u> argument to <u><a href="../man3/crypt.3.html">crypt</a></u>(3) must begin with the first three components of a valid hashed passphrase,
       but anything after that is ignored.  This makes authentication simple: hash the  input  passphrase  using
       the stored hashed passphrase as the setting, and then compare the result to the stored hashed passphrase.

       Hashed  passphrases  are  always  entirely  printable  ASCII,  and  do  not contain any whitespace or the
       characters ‘<b>:</b>’, ‘<b>;</b>’, ‘<b>*</b>’, ‘<b>!</b>’, or ‘<b>\</b>’.  (These characters are used as delimiters and special  markers  in
       the <u><a href="../man5/passwd.5.html">passwd</a></u>(5) and <u><a href="../man5/shadow.5.html">shadow</a></u>(5) files.)

       The  syntax of each component of a hashed passphrase is up to the hashing method.  ‘<b>$</b>’ characters usually
       delimit components, and the salt and hash are usually encoded as numerals in base  64.   The  details  of
       this  base-64 encoding vary among hashing methods.  The common “base64” encoding specified by RFC 4648 is
       usually <u>not</u> used.

</pre><h4><b>AVAILABLE</b> <b>HASHING</b> <b>METHODS</b></h4><pre>
       This is a list of <u>all</u> the hashing methods supported by <u><a href="../man3/crypt.3.html">crypt</a></u>(3), roughly in decreasing order of strength.
       Many of the older methods are now considered too weak to use for new passphrases.  The hashed  passphrase
       format  is expressed with extended regular expressions (see <u><a href="../man7/regex.7.html">regex</a></u>(7)) and does not show the division into
       prefix, options, salt, and hash.

   <b>yescrypt</b>
       yescrypt is a scalable passphrase hashing scheme designed by Solar Designer,  which  is  based  on  Colin
       Percival's  scrypt.  While yescrypt's strength against password guessing attacks comes from its algorithm
       design, its cryptographic security is guaranteed by its use of SHA-256 on the outer layer.   The  SHA-256
       hash function has been published by NIST in FIPS PUB 180-2 (and its subsequent revisions such as FIPS PUB
       180-4) and by the IETF as RFC 4634 (and subsequently RFC 6234).  Recommended for new hashes.

       <b>Prefix</b>
           <b>"$y$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$y\$[./A-Za-z0-9]+\$[./A-Za-z0-9]{,86}\$[./A-Za-z0-9]{43}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           256 bits

       <b>Salt</b> <b>size</b>
           up to 512 (128+ recommended) bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1 to 11 (logarithmic, also affects memory usage)

   <b>gost-yescrypt</b>
       gost-yescrypt  uses  the  output  from  yescrypt  as  an input message to HMAC with the GOST R 34.11-2012
       (Streebog) hash function with a 256-bit digest.  Thus, yescrypt's cryptographic properties are superseded
       by those of the GOST hash function.  This hashing method is  useful  in  applications  that  need  modern
       passphrase  hashing, but have to rely on GOST algorithms.  The GOST R 34.11-2012 (Streebog) hash function
       has been published by the IETF as RFC 6986.  Acceptable for new hashes where required.

       <b>Prefix</b>
           <b>"$gy$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$gy\$[./A-Za-z0-9]+\$[./A-Za-z0-9]{,86}\$[./A-Za-z0-9]{43}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           256 bits

       <b>Salt</b> <b>size</b>
           up to 512 (128+ recommended) bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1 to 11 (logarithmic, also affects memory usage)

   <b>scrypt</b>
       scrypt is a password-based key derivation function created by Colin Percival, originally for the  Tarsnap
       online  backup service.  The algorithm was specifically designed to make it costly to perform large-scale
       custom hardware attacks by requiring large  amounts  of  memory.   In  2016,  the  scrypt  algorithm  was
       published by IETF as RFC 7914.

       <b>Prefix</b>
           <b>"$7$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$7\$[./A-Za-z0-9]{11,97}\$[./A-Za-z0-9]{43}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           256 bits

       <b>Salt</b> <b>size</b>
           up to 512 (128+ recommended) bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           6 to 11 (logarithmic, also affects memory usage)

   <b>bcrypt</b>
       A  hash based on the Blowfish block cipher, modified to have an extra-expensive key schedule.  Originally
       developed by Niels Provos and David Mazieres for OpenBSD and also supported on recent versions of FreeBSD
       and NetBSD, on Solaris 10 and newer, and on several GNU/*/Linux distributions.

       <b>Prefix</b>
           <b>"$2b$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$2[abxy]\$[0-9]{2}\$[./A-Za-z0-9]{53}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           72 characters

       <b>Hash</b> <b>size</b>
           184 bits

       <b>Salt</b> <b>size</b>
           128 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           4 to 31 (logarithmic)

       The alternative prefix "$2y$" is equivalent to "$2b$".  It  exists  for  historical  reasons  only.   The
       alternative  prefixes  "$2a$" and "$2x$" provide bug-compatibility with crypt_blowfish 1.0.4 and earlier,
       which incorrectly processed characters with the 8th bit set.

   <b>sha512crypt</b>
       A hash based on SHA-2 with  512-bit  output,  originally  developed  by  Ulrich  Drepper  for  GNU  libc.
       Supported  on  Linux  but  not common elsewhere.  Acceptable for new hashes.  The default processing cost
       parameter is 5000, which is too low for modern hardware.

       <b>Prefix</b>
           <b>"$6$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$6\$(rounds=[1-9][0-9]+\$)?[^$:\n]{1,16}\$[./0-9A-Za-z]{86}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           512 bits

       <b>Salt</b> <b>size</b>
           6 to 96 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1000 to 999,999,999

   <b>sha256crypt</b>
       A hash based on SHA-2 with  256-bit  output,  originally  developed  by  Ulrich  Drepper  for  GNU  libc.
       Supported  on  Linux  but  not common elsewhere.  Acceptable for new hashes.  The default processing cost
       parameter is 5000, which is too low for modern hardware.

       <b>Prefix</b>
           <b>"$5$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$5\$(rounds=[1-9][0-9]+\$)?[^$:\n]{1,16}\$[./0-9A-Za-z]{43}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           256 bits

       <b>Salt</b> <b>size</b>
           6 to 96 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1000 to 999,999,999

   <b>sha1crypt</b>
       A hash based on HMAC-SHA1.  Originally developed by Simon Gerraty for NetBSD.  Not as weak  as  the  DES-
       based hashes below, but SHA-1 is so cheap on modern hardware that it should not be used for new hashes.

       <b>Prefix</b>
           <b>"$sha1"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$sha1\$[1-9][0-9]+\$[./0-9A-Za-z]{1,64}\$[./0-9A-Za-z]{8,64}[./0-9A-Za-z]{32}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           160 bits

       <b>Salt</b> <b>size</b>
           6 to 384 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           4 to 4,294,967,295

   <b>SunMD5</b>
       A  hash  based on the MD5 algorithm, originally developed by Alec David Muffett for Solaris.  Not adopted
       elsewhere, to our knowledge.  Not as weak as the DES-based hashes below, but MD5 is so  cheap  on  modern
       hardware that it should not be used for new hashes.

       <b>Prefix</b>
           <b>"$md5"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$md5(,rounds=[1-9][0-9]+)?\$[./0-9A-Za-z]{8}\${1,2}[./0-9A-Za-z]{22}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           128 bits

       <b>Salt</b> <b>size</b>
           48 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           4096 to 4,294,963,199

   <b>md5crypt</b>
       A  hash  based on the MD5 algorithm, originally developed by Poul-Henning Kamp for FreeBSD.  Supported on
       most free Unixes and newer versions of Solaris.  Not as weak as the DES-based hashes below, but MD5 is so
       cheap on modern hardware that it should not be used for new hashes.  Processing cost is not adjustable.

       <b>Prefix</b>
           <b>"$1$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$1\$[^$:\n]{1,8}\$[./0-9A-Za-z]{22}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           128 bits

       <b>Salt</b> <b>size</b>
           6 to 48 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1000

   <b>bsdicrypt</b> <b>(BSDI</b> <b>extended</b> <b>DES)</b>
       An extension of traditional DES, which eliminates the length limit, increases the salt  size,  and  makes
       the time cost tunable.  It originates with BSDI BSD/OS and is also available on at least NetBSD, OpenBSD,
       and FreeBSD due to the use of David Burren's FreeSec library.  It is much better than traditional DES and
       bigcrypt, but still should not be used for new hashes.

       <b>Prefix</b>
           <b>"_"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>_[./0-9A-Za-z]{19}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited (ignores 8th bit)

       <b>Hash</b> <b>size</b>
           64 bits

       <b>Effective</b> <b>key</b> <b>size</b>
           up to 56 bits

       <b>Salt</b> <b>size</b>
           24 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1 to 16,777,215 (must be odd)

   <b>descrypt</b> <b>(Traditional</b> <b>DES)</b>
       The  original hashing method from Unix V7, based on the DES block cipher.  Because DES is cheap on modern
       hardware, because there are only 4096 possible salts and 2**56 distinct passphrases, which  it  truncates
       to  8  characters,  it is feasible to discover <u>any</u> passphrase hashed with this method.  It should only be
       used if you absolutely have to generate hashes that will work on an old operating  system  that  supports
       nothing else.

       <b>Prefix</b>
           <b>""</b> (empty string)

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>[./0-9A-Za-z]{13}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           8 characters (ignores 8th bit)

       <b>Hash</b> <b>size</b>
           64 bits

       <b>Effective</b> <b>key</b> <b>size</b>
           up to 56 bits

       <b>Salt</b> <b>size</b>
           12 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           25

   <b>bigcrypt</b>
       A  weak  extension  of  traditional  DES,  available on some commercial Unixes.  All it does is raise the
       length limit from 8 to 128 characters, and it does this in a crude way that  allows  attackers  to  guess
       chunks  of  a  long  passphrase  separately and in parallel, which may make guessing even easier than for
       traditional DES above.  It should not be used for new hashes.

       <b>Prefix</b>
           <b>""</b> (empty string)

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>[./0-9A-Za-z]{13,178}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           128 characters (ignores 8th bit)

       <b>Hash</b> <b>size</b>
           up to 1024 bits

       <b>Effective</b> <b>key</b> <b>size</b>
           up to 56 bits

       <b>Salt</b> <b>size</b>
           12 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           25

   <b>NT</b>
       The hashing method used for network authentication in some versions of the SMB/CIFS protocol.  Available,
       for cross-compatibility's sake, on FreeBSD.  Based on MD4.  Has no salt or tunable cost parameter.  It is
       so weak that almost <u>any</u> human-chosen passphrase hashed with this method is guessable.  It should only  be
       used  if  you  absolutely have to generate hashes that will work on an old operating system that supports
       nothing else.

       <b>Prefix</b>
           <b>"$3$"</b>

       <b>Hashed</b> <b>passphrase</b> <b>format</b>
           <b>\$3\$\$[0-9a-f]{32}</b>

       <b>Maximum</b> <b>passphrase</b> <b>length</b>
           unlimited

       <b>Hash</b> <b>size</b>
           256 bits

       <b>Salt</b> <b>size</b>
           0 bits

       <b>Processing</b> <b>cost</b> <b>parameter</b>
           1

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/crypt.3.html">crypt</a></u>(3), <u><a href="../man3/crypt_gensalt.3.html">crypt_gensalt</a></u>(3), <u><a href="../man3/getpwent.3.html">getpwent</a></u>(3), <u><a href="../man5/passwd.5.html">passwd</a></u>(5), <u><a href="../man5/shadow.5.html">shadow</a></u>(5), <u><a href="../man8/pam.8.html">pam</a></u>(8)

       Niels Provos and David Mazieres, “A Future-Adaptable Password Scheme”, <u>Proceedings</u>  <u>of</u>  <u>the</u>  <u>1999</u>  <u>USENIX</u>
       <u>Annual</u> <u>Technical</u> <u>Conference</u>, https://www.usenix.org/events/usenix99/provos.html, June 1999.

       Robert  Morris  and Ken Thompson, “Password Security: A Case History”, <u>Communications</u> <u>of</u> <u>the</u> <u>ACM</u>, 11, 22,
       <a href="http://wolfram.schneider.org/bsd/7thEdManVol2/password/password.pdf">http://wolfram.schneider.org/bsd/7thEdManVol2/password/password.pdf</a>, 1979.

Openwall Project                                 March 27, 2024                                         <u><a href="../man5/CRYPT.5.html">CRYPT</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>