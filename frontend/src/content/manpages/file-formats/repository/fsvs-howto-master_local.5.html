<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HOWTO: Master/Local repositories -</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/fsvs">fsvs_1.2.12-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HOWTO: Master/Local repositories -

       This HOWTO describes how to use a single working copy with multiple repositories.  This HOWTO describes
       how to use a single working copy with multiple repositories.

       Please read the <b>HOWTO:</b> <b>Backup</b> first, to know about basic steps using FSVS.

</pre><h4><b>Rationale</b></h4><pre>
       If you manage a lot of machines with similar or identical software, you might notice that it's a bit of
       work keeping them all up-to-date. Sure, automating distribution via rsync or similar is easy; but then
       you get identical machines, or you have to play with lots of exclude patterns to keep the needed
       differences.

       Here another way is presented; and even if you don't want to use FSVS for distributing your files, the
       ideas presented here might help you keep your machines under control.

</pre><h4><b>Preparation,</b> <b>repository</b> <b>layout</b></h4><pre>
       In this document the basic assumption is that there is a group of (more or less identical) machines, that
       share most of their filesystems.

       Some planning should be done beforehand; while the ideas presented here might suffice for simple
       versioning, your setup can require a bit of thinking ahead.

       This example uses some distinct repositories, to achieve a bit more clarity; of course these can simply
       be different paths in a single repository (see <b>Using</b> <b>a</b> <b>single</b> <b>repository</b> for an example configuration).

       Repository in URL base:

         trunk/
           bin/
             ls
             true
           lib/
             libc6.so
             modules/
           sbin/
             mkfs
           usr/
             local/
             bin/
             sbin/
         tags/
         branches/

       Repository in URL machine1 (similar for machine2):

         trunk/
           etc/
             HOSTNAME
             adjtime
             network/
               interfaces
             passwd
             resolv.conf
             shadow
           var/
             log/
               auth.log
               messages
         tags/
         branches/

   <b>User</b> <b>data</b> <b>versioning</b>
       If you want to keep the user data versioned, too, a idea might be to start a new working copy in <b>every</b>
       home directory; this way

       • the system- and (several) user-commits can be run in parallel,

       • the intermediate home directory in the repository is not needed, and

       • you get a bit more isolation (against FSVS failures, out-of-space errors and similar).

       • Furthermore FSVS can work with smaller file sets, which helps performance a bit (less dentries to cache
         at once, less memory used, etc.).

         A/
             Andrew/
                   .bashrc
                   .ssh/
                   .kde/
           Alexander/
                   .bashrc
                   .ssh/
                   .kde/
         B/
             Bertram/

       A  cronjob  could  simply loop over the directories in <a href="file:/home">/home</a>, and call fsvs for each one; giving a target
       URL name is not necessary if every home-directory is its own working copy.

       <b>Note:</b>
           URL names can include a forward slash / in their  name,  so  you  might  give  the  URLs  names  like
           home/Andrew - although that should not be needed, if every home directory is a distinct working copy.

</pre><h4><b>Using</b> <b>master/local</b> <b>repositories</b></h4><pre>
       Imagine having 10 similar machines with the same base-installation.

       Then  you  install  one  machine,  commit  that  into  the  repository  as base/trunk, and make a copy as
       base/released.

       The other machines get base/released as checkout source, and another (overlaid) from eg. machine1/trunk.
        Per-machine changes are always committed into the machineX/trunk of  the  per-machine  repository;  this
       would be the host name, IP address, and similar things.

       On the development machine all changes are stored into base/trunk; if you're satisfied with your changes,
       you  merge  them  (see  <b>Branching,</b> <b>tagging,</b> <b>merging</b>) into base/released, whereupon all other machines can
       update to this latest version.

       So by looking at machine1/trunk you  can  see  the  history  of  the  machine-specific  changes;  and  in
       base/released you can check out every old version to verify problems and bugs.

       <b>Note:</b>
           You can take this system a bit further: optional software packages could be stored in other subtrees.
           They  should  be  of  lower priority than the base tree, so that in case of conflicts the base should
           always be preferred (but see <b>1</b>).

       Here is a small example; machine1 is the development machine, machine2 is a <u>client</u>.

         machine1$ fsvs urls name:local,P:200,svn+ssh://lserver/per-machine/machine1/trunk
         machine1$ fsvs urls name:base,P:100,<a href="http://bserver/base-install1/trunk">http://bserver/base-install1/trunk</a>
           # Determine differences, and commit them
         machine1$ fsvs ci -o commit_to=local /etc/HOSTNAME /etc/network/interfaces <a href="file:/var/log">/var/log</a>
         machine1$ fsvs ci -o commit_to=base /

       Now you've got a base-install in your repository, and can use that on the other machine:

         machine2$ fsvs urls name:local,P:200,svn+ssh://lserver/per-machine/machine2/trunk
         machine2$ fsvs urls name:base,P:100,<a href="http://bserver/base-install1/trunk">http://bserver/base-install1/trunk</a>
         machine2$ fsvs sync-repos
           # Now you see differences of this machines' installation against the other:
         machine2$ fsvs st
           # You can see what is different:
         machine2$ fsvs diff /etc/X11/xorg.conf
           # You can take the base installations files:
         machine2$ fsvs revert <a href="file:/bin/ls">/bin/ls</a>
           # And put the files specific to this machine into its repository:
         machine2$ fsvs ci -o commit_to=local /etc/HOSTNAME /etc/network/interfaces <a href="file:/var/log">/var/log</a>

       Now, if this machine has a harddisk failure or needs setup for any other reason, you  boot  it  (eg.  via
       PXE, Knoppix or whatever), and do (<b>3</b>)

         # Re-partition and create filesystems (if necessary)
         machine2-knoppix$ fdisk ...
         machine2-knoppix$ mkfs ...
           # Mount everything below <a href="file:/mnt">/mnt</a>
         machine2-knoppix$ mount &lt;partition[s]&gt; <a href="file:/mnt/">/mnt/</a>[...]
         machine2-knoppix$ cd <a href="file:/mnt">/mnt</a>
           # Do a checkout below <a href="file:/mnt">/mnt</a>
         machine2-knoppix$ fsvs co -o softroot=<a href="file:/mnt">/mnt</a> &lt;urls&gt;

</pre><h4><b>Branching,</b> <b>tagging,</b> <b>merging</b></h4><pre>
       Other  names  for  your  branches  (instead  of trunk, tags and branches) could be unstable, testing, and
       stable; your production machines would use stable, your testing  environment  testing,  and  in  unstable
       you'd commit all your daily changes.

       <b>Note:</b>
           Please  note  that there's no merging mechanism in FSVS; and as far as I'm concerned, there won't be.
           Subversion just gets automated merging mechanisms, and these should be fine for this usage too. (<b>4</b>)

   <b>Thoughts</b> <b>about</b> <b>tagging</b>
       Tagging works just like normally; although you need to remember to tag more than a single  branch.  Maybe
       FSVS  should  get  some  knowledge  about  the  subversion repository layout, so a fsvs tag would tag all
       repositories at once? It would have to check for duplicate tag-names (eg. on the base -branch), and  just
       keep it if it had the same copyfrom-source.

       But how would tags be used? Define them as source URL, and checkout? Would be a possible case.

       Or  should  fsvs  tag  do  a <u>merge</u> into the repository, so that a single URL contains all files currently
       checked out, with copyfrom-pointers to the original locations? Would require using a  single  repository,
       as  such  pointers  cannot  be  across  different  repositories.  If  the  committed  data  includes  the
       $FSVS_CONF/.../Urls file, the original layout would be known, too - although to use it a <b>sync-repos</b> would
       be necessary.

</pre><h4><b>Using</b> <b>a</b> <b>single</b> <b>repository</b></h4><pre>
       A single repository would have to be partitioned in the various branches that are needed for bookkeeping;
       see these examples.

       Depending on the number of machines it might make sense to put them in a 1- or 2  level  deep  hierarchy;
       named by the first character, like

         machines/
           A/
             Axel/
             Andreas/
           B/
             Berta/
           G/
             Gandalf/

   <b>Simple</b> <b>layout</b>
       Here  only  the base system gets branched and tagged; the machines simply backup their specific/localized
       data into the repository.

       # For the base-system:
         trunk/
           bin/
           usr/
           sbin/
         tags/
           tag-1/
         branches/
           branch-1/
       # For the machines:
         machines/
           machine1/
             etc/
               passwd
               HOSTNAME
           machine2/
             etc/
               passwd
               HOSTNAME

   <b>Per-area</b>
       Here every part gets its trunk, branches and tags:

         base/
           trunk/
             bin/
             sbin/
             usr/
           tags/
             tag-1/
           branches/
             branch-1/
         machine1/
           trunk/
             etc/
              passwd
              HOSTNAME
           tags/
             tag-1/
           branches/
         machine2/
           trunk/
             etc/
              passwd
              HOSTNAME
           tags/
           branches/

   <b>Common</b> <b>trunk,</b> <b>tags,</b> <b>and</b> <b>branches</b>
       Here the base-paths trunk, tags and branches are shared:

         trunk/
           base/
             bin/
             sbin/
             usr/
           machine2/
             etc/
               passwd
               HOSTNAME
           machine1/
             etc/
               passwd
               HOSTNAME
         tags/
            tag-1/
         branches/
            branch-1/

</pre><h4><b>Other</b> <b>notes</b></h4><pre>
   <b>1</b>
       Conflicts should not be automatically merged. If two or more trees bring the same file, the file from the
       <u>highest</u> tree wins - this way you always know the file data on your machines.  It's  better  if  a  single
       software  doesn't  work,  compared  to  a machine that no longer boots or is no longer accessible (eg. by
       SSH)).

       So keep your base installation at highest priority, and you've got good  chances  that  you  won't  loose
       control in case of conflicting files.

   <b>2</b>
       If you don't know which files are different in your installs,

       • install two machines,

       • commit the first into fsvs,

       • do a <b>sync-repos</b> on the second,

       • and look at the <b>status</b> output.

   <b>3</b>
       As debian includes FSVS in the near future, it could be included on the next KNOPPIX, too!

       Until  then  you'd  need  a  custom boot CD, or copy the absolute minimum of files to the harddisk before
       recovery.

       There's a utility svntar available; it allows you to take a snapshot of a subversion repository  directly
       into a .tar -file, which you can easily export to destination machine. (Yes, it knows about the meta-data
       properties FSVS uses, and stores them into the archive.)

   <b>4</b>
       Why  no  file merging? Because all real differences are in the per-machine files -- the files that are in
       the base repository are changed only on a single machine, and so there's an unidirectional flow.

       BTW, how would you merge your binaries, eg. <a href="file:/bin/ls">/bin/ls</a>?

</pre><h4><b>Feedback</b></h4><pre>
       If you've got any questions, ideas, wishes or other feedback, please tell us in the  mailing  list  users
       [at] fsvs.tigris.org.

       Thank you!

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for fsvs from the source code.

Version trunk:2424                                 11 Mar 2010                      <u>FSVS</u> <u>-</u> <u>Master/Local</u> <u><a href="../man5/HOWTO.5.html">HOWTO</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>