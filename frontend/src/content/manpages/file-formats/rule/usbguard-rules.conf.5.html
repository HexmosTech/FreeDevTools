<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>usbguard-rules.conf - USBGuard rule set file.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/usbguard">usbguard_1.1.4+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       usbguard-rules.conf - USBGuard rule set file.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>usbguard-rules.conf</b> file is loaded by the USBGuard daemon after it parses the main configuration
       file, <a href="../man5/usbguard-daemon.conf.5.html">usbguard-daemon.conf</a>(5). The daemon expects the file to contain rules written in a language which
       is described in the Rule Language section below.

</pre><h4><b>RULE</b> <b>LANGUAGE</b></h4><pre>
       The USBGuard daemon decides which USB device to authorize based on a policy defined by a set of rules.
       When a USB device is inserted into the system, the daemon scans the existing rules sequentially. If a
       matching rule is found, it either authorizes (<b>allows</b>), deauthorizes (<b>blocks</b>) or removes (<b>rejects</b>) the
       device, based on the rule target. If no matching rule is found, the decision is based on an implicit
       default target. This implicit default is to block the device until a decision is made by the user. The
       rule language grammar, expressed in a BNF-like syntax, is the following:

               rule ::= target attributes.

               target ::= "allow" | "block" | "reject".

               attributes ::= attributes | attribute.
               attributes ::= .

       Rule attributes specify which devices to match or what condition have to be met for the rule to be
       applicable. See the Device Specification section for the list of available attributes and Conditions for
       the list of supported rule rule conditions.

   <b>Targets</b>
       The target of a rule specifies whether the device will be authorized for use or not. Three types of
       target are recognized:

       •   <b>allow</b> - Authorize the device. The device and its interfaces will be allowed to communicate with the
           system.

       •   <b>block</b> - Deauthorize the device. The device will remain in a blocked state until it is authorized.

       •   <b>reject</b> - Deauthorize and Remove the device from the system. The device will have to be re-inserted to
           become visible to the system again.

   <b>Device</b> <b>Specification</b>
       Except the target, all the other fields of a rule are optional. A rule where only the target is specified
       will match any device. That allows the policy administrator to write an explicit default target. If no
       rule from the policy is applicable to the device, an implicit target configured in
       <a href="../man5/usbguard-daemon.conf.5.html">usbguard-daemon.conf</a>(5) will be used. However, if one wants to narrow the applicability of a rule to a
       set of devices or one device only, it’s possible to do so with device attributes and rule conditions.

       <b>Device</b> <b>Attributes</b>

           Device attributes are specific values read from the USB device after it’s inserted to the system.
           Which attributes are available is defined below. Some of the attributes are derived and some are
           based on attributes read directly from the device. All attributes support two forms:

           •   <b>single-valued</b> with a syntax:

                       name value

           •   <b>multi-valued</b> with a syntax:

                       name [operator] { value1 value2 ... }

           where the optional <u>operator</u> is one of:

           <b>all-of</b>
               The device attribute set must contain all of the specified values for the rule to match.

           <b>one-of</b>
               The device attribute set must contain at least one of the specified values for the rule to match.

           <b>none-of</b>
               The device attribute set must not contain any of the specified values for the rule to match.

           <b>equals</b>
               The device attribute set must contain exactly the same set of values for the rule to match.

           <b>equals-ordered</b>
               The device attribute set must contain exactly the same set of values in the same order for the
               rule to match.

           <b>match-all</b>
               The device attribute set must be a subset of the specified values for the rule to match.

           If the operator is not specified it is set to <b>equals</b>.

           List of attributes:

           <b>id</b> usb-device-id
               Match a USB device ID.

           <b>id</b> [operator] { usb-device-id ... }
               Match a set of USB device IDs.

           <b>hash</b> "value"
               Match a hash computed from the device attribute values and the USB descriptor data. The hash is
               computed for every device by USBGuard.

           <b>hash</b> [operator] { "value" ... }
               Match a set of device hashes.

           <b>parent-hash</b> "value"
               Match a hash of the parent device.

           <b>parent-hash</b> [operator] { "value" ... }
               Match a set of parent device hashes.

           <b>name</b> "device-name"
               Match the USB device name attribute.

           <b>name</b> [operator] { "device-name" ... }
               Match a set of USB device names.

           <b>serial</b> "serial-number"
               Match the USB iSerial device attribute.

           <b>serial</b> [operator] { "serial-number" ... }
               Match a set of USB iSerial device attributes.

           <b>via-port</b> "port-id"
               Match the USB port through which the device is connected. Note that some systems have unstable
               port numbering. The port might change after the system reboots or when certain kernel modules are
               reloaded. Use the <b>parent-hash</b> attribute if you want to ensure that a device is connected via a
               specific parent device.

           <b>via-port</b> [operator] { "port-id" ... }
               Match a set of USB ports.

           <b>with-interface</b> interface-type
               Match an interface type that the USB device provides.

           <b>with-interface</b> [operator] { interface-type ... }
               Match a set of interface types against the set of interfaces that the USB device provides.

           <b>with-connect-type</b> "connect-type"
               Match the USB port/connect_type device attribute.

           <b>with-connect-type</b> [operator] { "connect-type" ... }
               Match a set of USB port/connect_type device attributes.

           <b>label</b> "label"
               Associates arbitrary string with a rule. Label is useful for storing some contextual information
               about rule or for filtering rules by label. This attribute is not used when testing if a rule
               applies to a device.

           The <u>usb-device-id</u> is a colon delimited pair in the form <u>vendor_id:product_id</u>. All USB devices have
           this ID assigned by the manufacturer and it should uniquely identify a USB product type. Both
           <u>vendor_id</u> and <u>product_id</u> are 16-bit numbers represented in hexadecimal base. It’s possible to use an
           asterisk character to match either any device ID *:* or any product ID from a specific vendor, e.g.
           1234:*.

           The <u>port-id</u> value is a platform specific USB port identification. On Linux it’s in the form of "usbN"
           in case of a USB controller (more accurately a "root hub") or "bus-port[.port[.port ...]]" (e.g. 1-2,
           1-2.1, ...) in case of a USB device.

           The <u>interface-type</u> represents a USB interface and should be formatted as three 8-bit numbers in
           hexadecimal base delimited by a colon character, i.e. <u>cc:ss:pp</u>. The numbers represent the interface
           class (<u>cc</u>), subclass (<u>ss</u>) and protocol (<u>pp</u>) as assigned by the USB-IF. See the list of assigned
           classes, subclasses and protocols for details. Instead of the subclass and protocol number, you may
           write an asterisk character (*) to match all subclasses or protocols. Matching a specific class and a
           specific protocol is not allowed, i.e. if you use an asterisk as the subclass number, you have to use
           an asterisk for the protocol too.

   <b>Conditions</b>
       Whether a rule that matches a device will be applied or not can be further restricted using rule
       conditions. If the condition expression is met at the rule evaluation time, then the rule target is
       applied for the device. A condition expression is met if it evaluates to true. Otherwise, the rule
       evaluation continues with the next rule. A rule conditions has the following syntax:

                if [!]condition
                if [operator] { [!]conditionA [!]conditionB ... }

       Optionally, an exclamation mark (!) can be used to negate the result of a condition.

       Interpretation of the set operator:

       <b>all-of</b>
           Evaluate to true if all of the specified conditions evaluated to true.

       <b>one-of</b>
           Evaluate to true if one of the specified conditions evaluated to true.

       <b>none-of</b>
           Evaluate to true if none of the specified conditions evaluated to true.

       <b>equals</b>
           Same as <b>all-of</b>.

       <b>equals-ordered</b>
           Same as <b>all-of</b>.

       List of conditions:

       <b>localtime(time_range)</b>
           Evaluates to true if the local time is in the specified time range.  <u>time_range</u> can be written either
           as HH:MM[:SS] or HH:MM[:SS]-HH:MM[:SS].

       <b>allowed-matches(query)</b>
           Evaluates to true if an allowed device matches the specified <u>query</u>. The query uses the rule syntax.
           <b>Conditions</b> <b>in</b> <b>the</b> <b>query</b> <b>are</b> <b>not</b> <b>evaluated</b>.

       <b>rule-applied</b>
           Evaluates to true if the rule currently being evaluated ever matched a device.

       <b>rule-applied(past_duration)</b>
           Evaluates to true if the rule currently being evaluated matched a device in the past duration of time
           specified by the parameter.  <u>past_duration</u> can be written as HH:MM:SS, HH:MM, or SS.

       <b>rule-evaluated</b>
           Evaluates to true if the rule currently being evaluated was ever evaluated before.

       <b>rule-evaluated(past_duration)</b>
           Evaluates to true if the rule currently being evaluated was evaluated in the pas duration of time
           specified by the parameter.  <u>past_duration</u> can be written as HH:MM:SS, HH:MM, or SS.

       <b>random</b>
           Evaluates to true/false with a probability of p(true)=0.5.

       <b>random(p_true)</b>
           Evaluates to true with the specified probability p(true)=p_true.

       <b>true</b>
           Evaluates always to true.

       <b>false</b>
           Evaluates always to false.

   <b>Partial</b> <b>rule</b>
       Partial rule is a rule without a rule target. Partial rules may by used by some commands of <b>usbguard</b> CLI
       tool.

   <b>Comments</b>
       In order to easily understand the meaning of each rule, comments can be used. Everything after the "#"
       character is ignored by the rule parser.

</pre><h4><b>INITIAL</b> <b>POLICY</b></h4><pre>
       Using the <b>usbguard</b> CLI tool and its <b>generate-policy</b> subcommand, you can generate an initial policy for
       your system instead of writing one from scratch. The tool generates an <b>allow</b> policy for all devices
       connected to the system at the time of execution. It has several options to tweak the resulting policy,
       see <a href="../man1/usbguard.1.html">usbguard</a>(1) for further details.

       The policy will be printed out on the standard output. It’s a good idea to review the generated rules
       before using them on a system. The typical workflow for generating an initial policy could look like
       this:

               $ sudo usbguard generate-policy &gt; rules.conf
               $ vi rules.conf
               (review/modify the rule set)
               $ sudo install -m 0600 -o root -g root rules.conf /etc/usbguard/rules.conf
               $ sudo systemctl restart usbguard

</pre><h4><b>EXAMPLE</b> <b>POLICIES</b></h4><pre>
       The following examples show what to put into the <b>rules.conf</b> file in order to implement the given policy.

        1. <b>Allow</b> <b>USB</b> <b>mass</b> <b>storage</b> <b>devices</b> <b>(USB</b> <b>flash</b> <b>disks)</b> <b>and</b> <b>block</b> <b>everything</b> <b>else</b>

           This policy will block any device that isn’t just a mass storage device. Devices with a hidden
           keyboard interface in a USB flash disk will be blocked. Only devices with a single mass storage
           interface will be allowed to interact with the operating system. The policy consists of a single
           rule:

                   allow with-interface equals { 08:*:* }

           The blocking is implicit in this case because we didn’t write a block rule. Implicit blocking is
           useful to desktop users. A desktop applet listening to USBGuard events can ask the user for a
           decision if an implicit target was applied.

        2. <b>Allow</b> <b>a</b> <b>specific</b> <b>Yubikey</b> <b>device</b> <b>to</b> <b>be</b> <b>connected</b> <b>via</b> <b>a</b> <b>specific</b> <b>port</b> <b>(and</b> <b>reject</b> <b>everything</b> <b>else</b> <b>on</b>
           <b>that</b> <b>port)</b>

                   allow 1050:0011 name "Yubico Yubikey II" serial "0001234567" via-port "1-2" hash "044b5e168d40ee0245478416caf3d998"
                   reject via-port "1-2"

           We could use just the hash to match the device. However, using the name and serial attributes provide
           an useful hint for later inspection of the policy. On the other hand, the hash is the most specific
           value we can use to identify a device. It’s the best attribute to use if you want a rule to match
           just one device.

        3. <b>Reject</b> <b>devices</b> <b>with</b> <b>suspicious</b> <b>combination</b> <b>of</b> <b>interfaces</b>

           A USB flash disk which implements a keyboard or a network interface is very suspicious. The following
           set of rules forms a policy that allows USB flash disks and explicitly rejects devices with an
           additional and suspicious (as defined before) interface.

                   allow with-interface equals { 08:*:* }
                   reject with-interface all-of { 08:*:* 03:00:* }
                   reject with-interface all-of { 08:*:* 03:01:* }
                   reject with-interface all-of { 08:*:* e0:*:* }
                   reject with-interface all-of { 08:*:* 02:*:* }

           The policy rejects all USB flash disk devices with an interface from the HID/Keyboard, Communications
           and Wireless classes. Note that default allow is the wrong approach and you shouldn’t just reject a
           set of devices and allow the rest. The policy above assumes that blocking is the default. Rejecting a
           set of devices considered as "bad" is a good approach how to limit the exposure of the OS to such
           devices as much as possible.

        4. <b>Allow</b> <b>a</b> <b>keyboard-only</b> <b>USB</b> <b>device</b> <b>only</b> <b>if</b> <b>there</b> <b>isn’t</b> <b>already</b> <b>a</b> <b>USB</b> <b>device</b> <b>with</b> <b>a</b> <b>keyboard</b> <b>interface</b>
           <b>allowed</b>

                   allow with-interface one-of { 03:00:01 03:01:01 } if !allowed-matches(with-interface one-of { 03:00:01 03:01:01 })

        5. <b>Play</b> <b>"Russian</b> <b>roulette"</b> <b>with</b> <b>USB</b> <b>devices</b>

                   allow if random(0.1666)
                   reject

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/usbguard-daemon.8.html">usbguard-daemon</a>(8), <a href="../man5/usbguard-daemon.conf.5.html">usbguard-daemon.conf</a>(5)

</pre><h4><b>BUGS</b></h4><pre>
       If you find a bug in this software or if you’d like to request a feature to be implemented, please file a
       ticket at https://github.com/USBGuard/usbguard/issues/new.

</pre><h4><b>AUTHOR</b></h4><pre>
       USBGuard was originally written by Daniel Kopeček. Many people have contributed to it.

</pre><h4><b>RESOURCES</b></h4><pre>
       Main web site: https://usbguard.github.io/

</pre><h4><b>COPYING</b></h4><pre>
       License GPLv2+: GNU GPL version 2 or later <a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>. This is free software: you
       are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.

                                                   08/19/2025                               <u><a href="../man5/USBGUARD-RULES.CO.5.html">USBGUARD-RULES.CO</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>