<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>powerman.dev - PowerMan device specification files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/powerman">powerman_2.4.4-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       powerman.dev - PowerMan device specification files

</pre><h4><b>DESCRIPTION</b></h4><pre>
       PowerMan  device specifications are rather weird.  For this reason, we suggest that you leave the writing
       of these scripts to the PowerMan authors.  However, if you insist, here is how they work.

       Note: the authors do not guarantee that the PowerMan specification language will not change,  however  we
       are  open to taking on maintenance of scripts submitted by PowerMan users.  We can't guarantee that we'll
       be able to test new releases against all devices but we'll do our best not to break anything.  NOTE:  the
       best  way  to  help  us  in  this  endeavor  is  to provide a ``simulator'' for your power controller and
       associated tests in the <u>test</u> subdirectory of  the  powerman  source  code.   See  the  examples  in  that
       directory.

       By  convention,  device  scripts  are one device per file and are included as needed from a powerman.conf
       file, like this:

              include "/etc/powerman/icebox3.dev"

       A device script is surrounded by an outer block:

              specification "my_device_name" {
                  # configuration settings
                  # script blocks
              }

       The possible configuration settings are:

       <u>timeout</u> <u>&lt;float&gt;</u>
              (optional) device script timeout in seconds - applies to each script, the whole thing, not just  a
              particular "expect".

       <u>plug</u> <u>name</u> <u>{</u> <u>&lt;string</u> <u>list&gt;</u> <u>}</u>
              (optional)  if plug names are static, they should be defined.  Any reference to a plug name in the
              powerman.conf must match one of the defined plug names.

       <u>pingperiod</u> <u>&lt;float&gt;</u>
              (optional) if a ping script is defined, and  pingperiod  is  nonzero,  the  ping  script  will  be
              executed periodically, every &lt;float&gt; seconds.

       Script blocks have the form:

              script &lt;script_name&gt; {
                  # statements
              }

       Script blocks should all be grouped together with no config lines in between.  Scripts are for performing
       particular  operations  such  as  power  on,  get power status, etc.  The various script names are listed
       below.  Those marked with [%s] are called with a plug name "argument", which can be included  in  a  send
       statements by including a %s (printf style).  Warning: all the send strings are processed with printf and
       you  can  cause powermand to segfault if you include any printf tokens other than the appropriate zero or
       one %s.

       <u>login</u>  Executed immediately on (re-)connect.  If you need to login to the box, do it here.  This is  also
              a  good place to descend through a first layer of menus.  Caveat: % occurring in passwords must be
              escaped as %%.  Caveat: occurs outside of client session so cannot be debugged with -T.   A  trick
              when  debugging  is  to  move  this code into the status script temporarily so you can see what is
              going on.

       <u>logout</u> Executed prior to disconnect.  Get device in a state so login script will work  (though  hopefully
              disconnecting will do that too).

       <u>status_all,</u> <u>status[%s]</u>
              Obtain  plug state for all plugs or only the specified plug.  In most cases, only one script needs
              to be specified.  In some  hardware  where  unpopulated  plugs  may  be  problematic,  it  may  be
              beneficial  to  specify both.  If both scripts are specified, the status_all script will be called
              only when all plug are requested.

       <u>on_all,</u> <u>on_ranged[%s],</u> <u>on[%s]</u>
              Power on all plugs, a range of plugs, or the specified plug.

       <u>off_all,</u> <u>off_ranged[%s],</u> <u>off[%s]</u>
              Power off all plugs, a range of plugs, or the specified plug.

       <u>cycle_all,</u> <u>cycle_ranged[%s],</u> <u>cycle[%s]</u>
              Power cycle all plugs, a range of plugs, or the specified plug.  The intent of this command was to
              map to the RPC's cycle command; however, device script are increasingly implementing this in terms
              of a power off/delay/power so the off time can be controlled by the script.

       <u>status_soft_all,</u> <u>status_soft[%s]</u>
              Obtain soft power state for all plugs or only the  specified  plug.   Soft  Power  refers  to  the
              "standby  state"  of  the  node.   On  means the node is powered up.  Off means either the node is
              powered off at the plug or is powered on at the plug and in standby mode.   This  is  really  only
              useful  on  devices  that  include  both a plug relay and a probe into the node attached to a non-
              standby power source.

       <u>status_temp_all,</u> <u>status_temp[%s]</u>
              Obtain temperature reading for all plugs or only the specified plug.  Temperature is  obtained  by
              sampling  a  thermocouple in the node.  Results are reported as a text string - not interpreted by
              Powerman beyond any regex chopping done by the script.  In most cases, only one script needs to be
              specified.  In some hardware where unpopulated plugs may be problematic, it may be  beneficial  to
              specify  both.   If both scripts are specified, the status_all script will be called only when all
              plug are requested.

       <u>status_beacon_all,</u> <u>status_beacon[%s]</u>
              Obtain beacon state for all plugs or only the specified plug.  Some RPC's include a way to flash a
              light on a node.  In most cases, only one script needs to be specified.  In  some  hardware  where
              unpopulated  plugs  may be problematic, it may be beneficial to specify both.  If both scripts are
              specified, the status_all script will be called only when all plugs are requested.

       <u>beacon_on[%s]</u>
              Flash beacon on the specified plug.

       <u>beacon_off[%s]</u>
              Clear beacon on the specified plug.

       <u>reset_all,</u> <u>reset_ranged[%s],</u> <u>reset[%s]</u>
              Reset all plugs, a range of plugs, or only the  specified  plug.   Reset  refers  to  signaling  a
              motherboard reset butten header, not a plug cycle.

       Within a script, the following statements can be used:

       <u>send</u> <u>&lt;string&gt;</u>
              Send &lt;string&gt; to the device.

       <u>delay</u> <u>&lt;float&gt;</u>
              Pause script for &lt;float&gt; seconds.

       <u>expect</u> <u>&lt;string&gt;</u>
              &lt;string&gt;  is  compiled as a regular expression with <a href="../man3/regcomp.3.html">regcomp</a>(3).  The regular expression is matched
              against device input.  The script blocks until the regex is matched or the device  timeout  occurs
              (in which case the script is aborted).  Upon matching, any parenthesized expressiones are assigned
              to  variables:  $1  for  the  first  match,  $2  for  the  second match, and so on.  Warning: some
              implementations of <a href="../man3/regex.3.html">regex</a>(3) silently fail if  the  regular  expression  exceeds  available  static
              storage.

       <u>setplugstate</u> <u>[&lt;string&gt;|&lt;regmatch&gt;]</u>  <u>&lt;regmatch&gt;</u> <u>[off=&lt;string&gt;]</u> <u>[on=&lt;string&gt;]</u>
              Set the plug state.  The first argument, if present, is the literal plug name or a &lt;regmatch&gt; from
              the previous expect which contains the plug name.  If omitted, the plug name is presumed to be the
              script  argument.   The  off  and  on strings are compiled regexes, which if matched by the second
              argument, result in the plug state being set to off  or  on.   Yes  we  are  applying  regexes  to
              regmatches!  If no off or on strings are provided, state will be unknown.

       <u>setresult</u> <u>&lt;regmatch&gt;</u> <u>&lt;regmatch&gt;</u> <u>success=&lt;string&gt;</u>
              Set  the  result  state.  The first argument, a &lt;regmatch&gt; from the previous expect which contains
              the plug name.  The success string is a compiled regex, which if it matches the  second  argument,
              results in the power operation being successful for this plug.

       <u>ifoff,</u> <u>ifon</u>
              Script  statements  enclosed in an ifon/ifoff block are conditional executed based on the state of
              the plug passed in as an argument.  Ifon/ifoff blocks can only be used in single plug scripts that
              take an argument.

       <u>foreachplug</u>
              Script statements enclosed in a foreachplug block are executed  iteratively  with  a  %s  argument
              defined  for  each target plug.  Foreachplug blocks can only be used in all plug scripts that take
              no argument.

       Script terminals are  defined as follows:

       <u>&lt;float&gt;</u>
              decimal number - exponent forms not supported

       <u>&lt;string&gt;</u>
              Text surrounded by double quotes.  May contain C  style  backslash-escaped  characters,  including
              three digit octal values, and most common backslash-escaped single character values.

       <u>&lt;string</u> <u>list&gt;</u>
              Multiple &lt;string&gt; values separated by white space.

       <u>&lt;script_name&gt;</u>
              Name of script (see above).

       <u>&lt;regmatch&gt;</u>
              Results of a parenthesized regular expression match are assigned to $1, $2, ... $N.

</pre><h4><b>FILES</b></h4><pre>
       /etc/powerman/*.dev

</pre><h4><b>ORIGIN</b></h4><pre>
       PowerMan  was  originally  developed  by  Andrew Uselton on LLNL's Linux clusters.  This software is open
       source and distributed under the terms of the GNU GPL.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/powerman.1.html">powerman</a></b>(1), <b><a href="../man8/powermand.8.html">powermand</a></b>(8), <b><a href="../man8/httppower.8.html">httppower</a></b>(8), <b><a href="../man8/plmpower.8.html">plmpower</a></b>(8), <b><a href="../man8/vpcd.8.html">vpcd</a></b>(8), <b><a href="../man5/powerman.conf.5.html">powerman.conf</a></b>(5), <b><a href="../man5/powerman.dev.5.html">powerman.dev</a></b>(5).

       <b><a href="http://github.com/chaos/powerman">http://github.com/chaos/powerman</a></b>

powerman-2.4.4                                   13 January 2012                                 <u><a href="../man5/powerman.dev.5.html">powerman.dev</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>