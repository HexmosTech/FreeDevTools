<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The  ipmi_sim  emulation  is set up using these commands.  They can be read from a command file, run from</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openipmi">openipmi_2.0.37-1_amd64</a> <br><br><pre>
</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>ipmi_sim</b>  emulation  is set up using these commands.  They can be read from a command file, run from
       the command line, or executed inside the simulator after it is started.

       This may be a little confusing, but the network interfaces are configured by the  ipmi_lan  configuration
       file,  and  the  various management controllers, sensors, etc. are specified using this file.  Plus, this
       can be used to configure the simulator after it is up, set sensor values, inject events,  and  things  of
       that nature.

</pre><h4><b>GENERAL</b> <b>COMMANDS</b></h4><pre>
       Blank  lines and lines starting with `#' are ignored.  Long lines may be broken up by putting a 'Â´ at the
       end of the line to be continued.

       <b>quit</b>   Exit the simulator

       <b>include</b> <u>"file"</u>
              Include the given file.

       <b>define</b> <u>name</u> <u>"value"</u>

              Define the given name as a variable with the given value.  This variable  may  be  used  later  by
              doing  <u>$name</u>.   This  cannot  be  used in quotes, but quotes may be broken up and the variable put
              between them.  For instance, if you say:

              define MCNUM "40"

              you can use it later as in

              mc_add $MCNUM 1 no-device-sdrs 00  00  00  0xc9  0x009000 0x0002

              or

              sensor_add $MCNUM 0 21 12 0x6f poll 1000 file "/sys/dev/sens1-"$MCNUM"-1"

       <b>sleep</b> <u>time</u>
              Pause the command interface for the given number of seconds.  This does not affect  the  execution
              of the simulator.

       <b>debug</b> <u>options</u>
              Set the debugging output.  Valid options are:

              <u>msg</u> Dump messages.

              <u>raw</u> Dump raw I/O

              Entering nothing turns of debugging.

       <b>read_cmds</b> <u>filename</u>
              Execute the commands in the given file.

</pre><h4><b>MC</b> <b>COMMANDS</b></h4><pre>
       <b>mc_add</b> <u>IPMBAddress</u> <u>DeviceID</u> <u>HasDeviceSDRs</u> <u>DeviceRevision</u> <u>MajorFWRev</u> <u>MinorFWRev</u> <u>DeviceSupport</u>
       <u>ManufacturerID</u> <u>ProductID</u>
              Add  an  MC  to the simulator.  All values are hexadecimal.  These are mostly values for the ``Get
              Device ID'' command, see the spec for details.  Note that the MC is not enabled after being added,
              you must add it.

              Note that some of these values control the capabilities of the MC.   For  instance,  HasDeviceSDRs
              sets whether device SDR repository commands will work.

              You may use has-device-sdrs or no-device-sdrs in the HasDeviceSDRs field.

       <b>mc_add_fru_data</b> <u>mc-addr</u> <u>DeviceID</u> <u>FRUSize</u> (data [<u>byte1</u> [<u>byte2</u> [...]]] | <u>file</u> <u>offset</u> <u>filename)</u>
              Set  the  FRU data for a given MC and device id.  Data may be supplied directly here, or it may be
              given as a file.  The offset is the start from the beginning of the file where the data is kept.

       <b>mc_dump_fru_data</b> <u>mc-addr</u> <u>DeviceID</u>
              Dump the FRU data for a given MC and device id.

       <b>mc_delete</b> <u>mc-addr</u>
              Remove the MC from the system.

       <b>mc_disable</b> <u>mc-addr</u>
              Disable the MC, but don't remove it.

       <b>mc_enable</b> <u>mc-addr</u>
              Enable the given MC.

       <b>mc_setbmc</b> <u>mc-addr</u>
              Set the BMC's address.

       <b>mc_set_guid</b> <u>mc-addr</u> <u>guid</u>
              Set the GUID value.  The guid may be a string (in quotes) or a hexadecimal string.

       <b>sel_enable</b> <u>mc-addr</u> <u>max-entries</u> <u>flags</u>
              Enable the System Event Log on the given MC.  The flags is a byte this is returned from the  ``Get
              SEL Info'' command; it controls various aspects of the SEL.  See the spec for details.

       <b>sel_add</b> <u>mc-addr</u> <u>RecordType</u> <u>byte1</u> <u>byte2</u> ... <u>byte13</u>
              Add an entry to the MC's SEL.

       <b>main_sdr_add</b> <u>mc-addr</u> <u>byte1</u> [<u>byte2</u> [...]]
              Add an entry to the main SDR of the MC.

       <b>device_sdr_add</b> <u>mc-addr</u> <u>LUN</u> <u>byte1</u> [<u>byte2</u> [...]]
              Add an entry to the device SDR of the MC.

</pre><h4><b>SENSOR</b> <b>COMMANDS</b></h4><pre>
       <b>sensor_add</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>sensor-type</u> <u>event-reading-code</u> [<u>poll</u> <u>poll_rate</u> <u>poll_type</u>
       <u>poll_type_options</u>] [event-only]

              Add a sensor to the given MC and LUN.  The type of sensor is set by the event reading code.

              If  <u>poll</u>  is  specified,  then  the  sensor  will  be polled for data.  Only the <u>file</u> poll type is
              currently supported.  The value is a number read from a file.  It has the following  options,  all
              optional:

              <u>div=val</u>  will  divide  the  read  value  by  the  given  number.   This is done after the multiply
              operation.

              <u>mult=val</u> will multiply the read value by the given number.  This is done after the subtraction.

              <u>sub=val</u> will subtract the value by the given number.  This is done after the mask.

              <u>mask=val</u> will mask (bitwise and) the value by the given number.

              <u>base=value</u> Specify the base of the value read from the file.  By default this is zero, meaning "C"
              conventions are used.

              <u>initstate=value</u> sets what the event state is initially  set  to.   This  is  useful  for  discrete
              sensors  with  bits  that  should normally be set to "1", like a presence bit, to keep the program
              from issuing an event every time the program starts.

              <u>raw</u> specifies that the data from the file is a raw value.  Only <u>length</u> bytes are read from <u>offset</u>.

              <u>ascii</u> specifies that the data from the file is in ASCII.  This is the default.  The  <u>offset</u>  value
              is used, but no the <u>length</u>.

              <u>length=val</u>  specifies  the  length  of the data to read from the file.  The maximum value is 4,and
              this is only used for raw data.

              <u>depends=&lt;mc_addr&gt;,&lt;lun&gt;,&lt;sensor_number&gt;,&lt;bit&gt;</u> specifies a discrete sensor bit that must be set  to
              1  for  the  sensor to be active.  Generally, you use the presence bit of a sensor to mark whether
              other sensors on the device are actually present.  Each of the other sensors  would  have  one  of
              these pointing to the presence bit.

              <u>event-only</u> specifies that the sensor will not be readable, it will only generate events (specified
              with a type 3 SDR).

       <b>sensor_set_bit</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>bit-to-set</u> <u>bit-value</u> <u>generate-event</u>
              Set  the  given  bit  to bit-value (0 or 1) for the sensor by bit number, either the threshold for
              analog or the discrete sensor bit.  If generate-event  is  non-zero  and  the  sensor  has  events
              enabled for that bit, then generate an event.

       <b>sensor_set_bit_clr_rest</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>bit-to-set</u> <u>bit-value</u> <u>generate-event</u>
              Like sensor_set_bit, but automatically clears all other bits.

       <b>sensor_set_value</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>value</u> <u>generate-event</u>
              Set the byte value for an analog sensor.  If the sensor exceeds a threshold, the sensor has events
              enabled, and generate-event is non-zero, then generate an event for the condition.

       <b>sensor_set_hysteresis</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>support</u> <u>positive</u> <u>negative</u>
              Set the hysteresis capabilities of the sensor.  It must be an analog sensor.  The support value is
              the  hysteresis  capability,  the  same  as  the  hysteresis support value in the sensor SDR.  The
              positive and negative hysteresis values are also set by this command.

              The support value may also be none, readable, settable, or fixed instead of the numbers.

       <b>sensor_set_threshold</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>threshold-support</u> <u>threshold-enabled</u> [<u>value5</u> [<u>value4</u> [...
       [<u>value0</u>]]]]

              Set the threshold support for a sensor.  It must be an analog sensor.  The threshold-support value
              is the same as the threshold access support value in the sensor SDR.  The threshold-enabled values
              is a string of ``0'' and  ``1''  characters  that  enable  the  6  corresponding  thresholds;  the
              rightmost  value  is  value  0,  the leftmost is value 5.  Optionally, the threshold values may be
              specified as their byte values.

              The threshold-support value may also be none, readable, settable, or fixed to make it a  bit  more
              readable.  The thresholds are:

              <u>0</u> - lower non critical

              <u>1</u> - lower critical

              <u>2</u> - lower non recoverable

              <u>3</u> - upper non critical

              <u>4</u> - upper critical

              <u>5</u> - upper non recoverable

       <b>sensor_set_event_support</b> <u>mc-addr</u> <u>LUN</u> <u>sensor-num</u> <u>events-enable</u> <u>scanning</u> <u>event-support</u> <u>assert-support</u>
       <u>deassert-support</u> <u>assert-enabled</u> <u>deassert-enabled</u>

              Set  the  event support of a sensor.  The events-enable will enable global events on the sensor if
              non-zero, otherwise they are disabled.  The scanning values set the scanning value for the sensor.
              The event-support value sets the event capabilities in  the  sensor,  this  is  the  same  as  the
              ``sensor  event  message control support'' value in the sensor SDR.  The assert-support, deassert-
              support, assert-enabled, and deassert-enabled are all  bitmasks  (a  string  of  ``0''  and  ``1''
              characters)  that set their corresponding sensor bit's capability to generate events (support) and
              whether it will generate events now (enabled).

              Note that all bitmasks have the rightmost digit as the zeroth bit, and the leftmost digit  as  the
              highest order bit.  Note that you must specify 15 bits here, even if you don't use all of them.

              Note  that  you  may use enable or disable in the events-enable field, and you may use scanning or
              no-scanning in the scanning field.

              For event-support, you may use per-state, entire-sensor, global or none instead of a number.

              For a threshold sensor, the values are:

              <u>0</u>
               - lower non-critical going low

              <u>1</u>
               - lower non-critical going high

              <u>2</u>
               - lower critical going low

              <u>3</u>
               - lower critical going high

              <u>4</u>
               - lower non-recoverable going low

              <u>5</u>
               - lower non-recoverable going high

              <u>6</u>
               - upper non-critical going low

              <u>7</u>
               - upper non-critical going high

              <u>8</u>
               - upper critical going low

              <u>9</u>
               - upper critical going high

              <u>1</u>
               - upper non-recoverable going low

              <u>1</u>
               - upper non-recoverable going high

              Note that the "lower going high" and "upper going low" values are not supported,  since  they  are
              simply stupid.

</pre><h4><b>ATCA</b> <b>OEM</b> <b>COMMANDS</b></h4><pre>
       These are for emulation of special ATCA capabilities.

       <b>atca_enable</b>
              The system is an ATCA system, enables the other ATCA capabilities.

              Note  that  you should do this *before* creating any MCs (this should really be first) because the
              MCs are set up a little differently for ATCA mode.  This causes the MCs to be able to handle PICMG
              commands properly, sets up 2 LEDs by default, and enables proper hot-swap handling, including  the
              blue LED.  By default the blue LED supports local control and the other LEDs do not and are red.

              In  ATCA  mode, to drive the hot-swap state machine, you should use sensor_set_bit_clr_rest to set
              the hot-swap state.

       <b>atca_set_site</b> <u>hardware-address</u> <u>site-type</u> <u>site-number</u>
              Sets the given values for an ATCA system, the values returned by the get address commands.

       <b>mc_set_num_leds</b> <u>mc-addr</u> <u>count</u>
              Set the number of ATCA LEDs the MC has.

       <b>mc_set_power</b> <u>mc-addr</u> <u>power</u> <u>gen-event</u>
              Set the ATCA power setting for the MC as its numeric value.  If gen-event is non-zero, generate an
              event for the change.

</pre><h4><b>FILES</b></h4><pre>
       /etc/ipmi/lan.conf

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ipmi_sim.1.html">ipmi_sim</a></b>(1)

</pre><h4><b>KNOWN</b> <b>PROBLEMS</b></h4><pre>
       IPMI is unnecessarily complicated.  Hords of capabilities are not yet implemented.

</pre><h4><b>AUTHOR</b></h4><pre>
       Corey Minyard &lt;<a href="mailto:cminyard@mvista.com">cminyard@mvista.com</a>&gt;

OpenIPMI                                            06/26/12                                     <u><a href="../man5/ipmi_sim_cmd.5.html">ipmi_sim_cmd</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>