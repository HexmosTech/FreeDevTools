<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dtrace_tcp — a DTrace provider for tracing events related to the tcp(4) protocol</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dtrace_tcp — a DTrace provider for tracing events related to the <u><a href="../man4/tcp.4.html">tcp</a></u>(4) protocol

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tcp:::accept-established</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::accept-refused</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::connect-established</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::connect-refused</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::connect-request</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::receive</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::send</b>(<u>pktinfo_t</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>ipinfo_t</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>tcpinfo_t</u> <u>*</u>);

       <b>tcp:::state-change</b>(<u>void</u> <u>*</u>, <u>csinfo_t</u> <u>*</u>, <u>void</u> <u>*</u>, <u>tcpsinfo_t</u> <u>*</u>, <u>void</u> <u>*</u>, <u>tcplsinfo_t</u> <u>*</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  DTrace  <b>tcp</b>  provider  allows  users  to  trace  events in the <u><a href="../man4/tcp.4.html">tcp</a></u>(4) protocol implementation.  This
       provider is similar to the <u><a href="../man4/dtrace_ip.4.html">dtrace_ip</a></u>(4) and <u><a href="../man4/dtrace_udp.4.html">dtrace_udp</a></u>(4) providers,  but  additionally  contains  probes
       corresponding  to  protocol  events  at  a  level higher than packet reception and transmission.  All <b>tcp</b>
       probes except for <b>tcp:::state-change</b>() have the same number  and  type  of  arguments.   The  last  three
       arguments  are  used to describe a TCP segment: the <u>ipinfo_t</u> argument exposes the version-agnostic fields
       of the IP header, while the <u>tcpinfo_t</u> argument exposes  the  TCP  header,  and  the  <u>tcpsinfo_t</u>  argument
       describes  details  of the corresponding TCP connection state, if any.  Their fields are described in the
       ARGUMENTS section.

       The <b>tcp:::accept-established</b>() probe fires when a remotely-initiated active TCP open succeeds.   At  this
       point  the  new  connection  is  in  the  ESTABLISHED  state,  and the probe arguments expose the headers
       associated with the final ACK of the three-way handshake.  The <b>tcp:::accept-refused</b>() probe fires when  a
       SYN arrives on a port without a listening socket.  The probe arguments expose the headers associated with
       the RST to be transmitted to the remote host in response to the SYN segment.

       The  <b>tcp:::connect-established</b>(), <b>tcp:::connect-refused</b>(), and <b>tcp:::connect-request</b>() probes are similar
       to the  ‘accept’  probes,  except  that  they  correspond  to  locally-initiated  TCP  connections.   The
       <b>tcp:::connect-established</b>()  probe  fires  when  the SYN-ACK segment of a three-way handshake is received
       from the remote host and a final ACK is prepared for transmission.  This  occurs  immediately  after  the
       local  connection  state  transitions  from  SYN-SENT  to  ESTABLISHED.  The probe arguments describe the
       headers associated with the received SYN-ACK segment.  The <b>tcp:::connect-refused</b>() probe fires  when  the
       local  host  receives a RST segment in response to a SYN segment, indicating that the remote host refused
       to open a connection.  The probe arguments describe the IP and TCP headers associated with  the  received
       RST  segment.  The <b>tcp:::connect-request</b>() probe fires as the kernel prepares to transmit the initial SYN
       segment of a three-way handshake.

       The <b>tcp:::send</b>() and <b>tcp:::receive</b>()  probes  fire  when  the  host  sends  or  receives  a  TCP  packet,
       respectively.   As  with  the  <u><a href="../man4/dtrace_udp.4.html">dtrace_udp</a></u>(4) provider, <b>tcp</b> probes fire only for packets sent by or to the
       local host; forwarded packets are handled in the IP layer  and  are  only  visible  to  the  <u><a href="../man4/dtrace_ip.4.html">dtrace_ip</a></u>(4)
       provider.

       The  <b>tcp:::state-change</b>()  probe fires upon local TCP connection state transitions.  Its first, third and
       fifth arguments are currently always NULL.  Its last argument describes the from-state in the transition,
       and the to-state can be obtained from args[3]-&gt;tcps_state.

</pre><h4><b>ARGUMENTS</b></h4><pre>
       The <u>pktinfo_t</u>  argument  is  currently  unimplemented  and  is  included  for  compatibility  with  other
       implementations of this provider.  Its fields are:

             <u>uinptr_t</u> <u>pkt_addr</u>  Always set to 0.

       The  <u>csinfo_t</u>  argument  is  currently  unimplemented  and  is  included  for  compatibility  with  other
       implementations of this provider.  Its fields are:

             <u>uintptr_t</u> <u>cs_addr</u>  Always set to 0.

             <u>uint64_t</u> <u>cs_cid</u>    A pointer to the <u>struct</u> <u>inpcb</u> for this packet, or NULL.

             <u>pid_t</u> <u>cs_pid</u>       Always set to 0.

       The <u>ipinfo_t</u> type is a version-agnostic representation of fields from  an  IP  header.   Its  fields  are
       described in the <u><a href="../man4/dtrace_ip.4.html">dtrace_ip</a></u>(4) manual page.

       The <u>tcpsinfo_t</u> type is used to provide a stable representation of TCP connection state.  Some <b>tcp</b> probes,
       such as <b>tcp:::accept-refused</b>(), fire in a context where there is no TCP connection; this argument is NULL
       in that case.  Its fields are:

             <u>uintptr_t</u> <u>tcps_addr</u>  The  address  of  the  corresponding  TCP  control block.  This is currently a
                                  pointer to a <u>struct</u> <u>tcpcb</u>.

             <u>int</u> <u>tcps_local</u>       A boolean indicating whether the connection is local to the  host.   Currently
                                  unimplemented and always set to -1.

             <u>int</u> <u>tcps_active</u>      A  boolean  indicating whether the connection was initiated by the local host.
                                  Currently unimplemented and always set to -1.

             <u>uint16_t</u> <u>tcps_lport</u>  Local TCP port.

             <u>uint16_t</u> <u>tcps_rport</u>  Remote TCP port.

             <u>string</u> <u>tcps_laddr</u>    Local address.

             <u>string</u> <u>tcps_raddr</u>    Remote address.

             <u>int32_t</u> <u>tcps_state</u>   Current TCP state.  The valid TCP state values  are  given  by  the  constants
                                  prefixed with ‘TCPS_’ in <u>/usr/lib/dtrace/tcp.d</u>.

             <u>uint32_t</u> <u>tcps_iss</u>    Initial send sequence number.

             <u>uint32_t</u> <u>tcps_suna</u>   Initial sequence number of sent but unacknowledged data.

             <u>uint32_t</u> <u>tcps_snxt</u>   Next sequence number for send.

             <u>uint32_t</u> <u>tcps_rack</u>   Sequence number of received and acknowledged data.

             <u>uint32_t</u> <u>tcps_rnxt</u>   Next expected sequence number for receive.

             <u>u_long</u> <u>tcps_swnd</u>     TCP send window size.

             <u>int32_t</u> <u>tcps_snd_ws</u>  Window scaling factor for the TCP send window.

             <u>u_long</u> <u>tcps_rwnd</u>     TCP receive window size.

             <u>int32_t</u> <u>tcps_rcv_ws</u>  Window scaling factor for the TCP receive window.

             <u>u_long</u> <u>tcps_cwnd</u>     TCP congestion window size.

             <u>u_long</u> <u>tcps_cwnd_ssthresh</u>
                                  Congestion  window threshold at which slow start ends and congestion avoidance
                                  begins.

             <u>uint32_t</u> <u>tcps_sack_fack</u>
                                  Last sequence number selectively acknowledged by the receiver.

             <u>uint32_t</u> <u>tcps_sack_snxt</u>
                                  Next selectively acknowledge sequence number at which to begin retransmitting.

             <u>uint32_t</u> <u>tcps_rto</u>    Round-trip timeout, in milliseconds.

             <u>uint32_t</u> <u>tcps_mss</u>    Maximum segment size.

             <u>int</u> <u>tcps_retransmit</u>  A boolean indicating that the local sender is retransmitting data.

             <u>int</u> <u>tcps_srtt</u>        Smoothed round-trip time.

       The <u>tcpinfo_t</u> type exposes the fields in a TCP segment header in host order.  Its fields are:

             <u>uint16_t</u> <u>tcp_sport</u>      Source TCP port.

             <u>uint16_t</u> <u>tcp_dport</u>      Destination TCP port.

             <u>uint32_t</u> <u>tcp_seq</u>        Sequence number.

             <u>uint32_t</u> <u>tcp_ack</u>        Acknowledgement number.

             <u>uint8_t</u> <u>tcp_offset</u>      Data offset, in bytes.

             <u>uint8_t</u> <u>tcp_flags</u>       TCP flags.

             <u>uint16_t</u> <u>tcp_window</u>     TCP window size.

             <u>uint16_t</u> <u>tcp_checksum</u>   Checksum.

             <u>uint16_t</u> <u>tcp_urgent</u>     Urgent data pointer.

             <u>struct</u> <u>tcphdr</u> <u>*tcp_hdr</u>  A pointer to the raw TCP header.

       The <u>tcplsinfo_t</u> type is used by the <b>tcp:::state-change</b>() probe to provide the from-state of a transition.
       Its fields are:

             <u>int32_t</u> <u>tcps_state</u>  A TCP state.  The valid TCP state values are given by  the  constants  prefixed
                                 with ‘TCPS_’ in <u>/usr/lib/dtrace/tcp.d</u>.

</pre><h4><b>FILES</b></h4><pre>
       <u>/usr/lib/dtrace/tcp.d</u>  DTrace type and translator definitions for the <b>tcp</b> provider.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following script logs TCP segments in real time:

             #pragma D option quiet
             #pragma D option switchrate=10hz

             dtrace:::BEGIN
             {
                     printf(" %3s %15s:%-5s      %15s:%-5s %6s  %s\n", "CPU",
                         "LADDR", "LPORT", "RADDR", "RPORT", "BYTES", "FLAGS");
             }

             tcp:::send
             {
                     this-&gt;length = args[2]-&gt;ip_plength - args[4]-&gt;tcp_offset;
                     printf(" %3d %16s:%-5d -&gt; %16s:%-5d %6d  (", cpu, args[2]-&gt;ip_saddr,
                         args[4]-&gt;tcp_sport, args[2]-&gt;ip_daddr, args[4]-&gt;tcp_dport,
                         this-&gt;length);
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_FIN ? "FIN|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_SYN ? "SYN|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_RST ? "RST|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_PUSH ? "PUSH|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_ACK ? "ACK|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_URG ? "URG|" : "");
                     printf("\s", args[4]-&gt;tcp_flags == 0 ? "null " : "");
                     printf("n;
             }               "

             tcp:::receive
             {
                     this-&gt;length = args[2]-&gt;ip_plength - args[4]-&gt;tcp_offset;
                     printf(" %3d %16s:%-5d &lt;- %16s:%-5d %6d  (", cpu,
                         args[2]-&gt;ip_daddr, args[4]-&gt;tcp_dport, args[2]-&gt;ip_saddr,
                         args[4]-&gt;tcp_sport, this-&gt;length);
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_FIN ? "FIN|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_SYN ? "SYN|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_RST ? "RST|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_PUSH ? "PUSH|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_ACK ? "ACK|" : "");
                     printf("%s", args[4]-&gt;tcp_flags &amp; TH_URG ? "URG|" : "");
                     printf("\s", args[4]-&gt;tcp_flags == 0 ? "null " : "");
                     printf("n;
             }               "
       The following script logs TCP connection state changes as they occur:

             #pragma D option quiet
             #pragma D option switchrate=25hz

             int last[int];

             dtrace:::BEGIN
             {
                     printf("   %12s %-20s    %-20s %s\n",
                         "DELTA(us)", "OLD", "NEW", "TIMESTAMP");
             }

             tcp:::state-change
             {
                     this-&gt;elapsed = (timestamp - last[args[1]-&gt;cs_cid]) / 1000;
                     printf("   %12d %-20s -&gt; %-20s %d\n", this-&gt;elapsed,
                         tcp_state_string[args[5]-&gt;tcps_state],
                         tcp_state_string[args[3]-&gt;tcps_state], timestamp);
                     last[args[1]-&gt;cs_cid] = timestamp;
             }

             tcp:::state-change
             /last[args[1]-&gt;cs_cid] == 0/
             {
                     printf("   %12s %-20s -&gt; %-20s %d\n", "-",
                         tcp_state_string[args[5]-&gt;tcps_state],
                         tcp_state_string[args[3]-&gt;tcps_state], timestamp);
                     last[args[1]-&gt;cs_cid] = timestamp;
             }

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       This provider is compatible with the <b>tcp</b> provider in Solaris.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1), <u><a href="../man4/dtrace_ip.4.html">dtrace_ip</a></u>(4), <u><a href="../man4/dtrace_sctp.4.html">dtrace_sctp</a></u>(4), <u><a href="../man4/dtrace_udp.4.html">dtrace_udp</a></u>(4), <u><a href="../man4/dtrace_udplite.4.html">dtrace_udplite</a></u>(4), <u><a href="../man4/tcp.4.html">tcp</a></u>(4), <u><a href="../man9/SDT.9.html">SDT</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>tcp</b> provider first appeared in FreeBSD 10.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Mark Johnston &lt;<u><a href="mailto:markj@FreeBSD.org">markj@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The <u>tcps_local</u> and <u>tcps_active</u> fields of <u>tcpsinfo_t</u> are not filled in by the translator.

Debian                                           August 1, 2018                                    <u><a href="../man4/DTRACE_TCP.4.html">DTRACE_TCP</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>