<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>solver - direct and iterative solver (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/librheolef-dev">librheolef-dev_7.2-3build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       solver - direct and iterative solver (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The class implements the numerical resolution of a linear system. Let a be a square and invertible matrix
       in the <b><a href="../man4/csr.4.html">csr</a>(4)</b> sparse format. The construction of a solver writes:

           solver sa (a);

        and the resolution of a*x = b expresses simply:

           vec&lt;Float&gt; x = sa.solve(b);

        When the matrix is modified in a computation loop, the solver could be re-initialized by:

           sa.update_values (new_a);
           vec&lt;Float&gt; x = sa.solve(b);

</pre><h4><b>DIRECT</b> <b>VERSUS</b> <b>ITERATIVE</b></h4><pre>
       The choice between a direct or an iterative method for solving the linear system is by default performed
       automatically: it depends upon the sparsity pattern of the matrix, in order to achieve the best
       performances. The <b><a href="../man4/solver_option.4.html">solver_option</a>(4)</b> class allows one to change this default behavior.

           solver_option sopt;
           sopt.iterative = true;
           solver sa (a, sopt);
           vec&lt;Float&gt; x = sa.solve(b);

        The direct approach bases on the Choleski factorization for a symmetric definite positive matrix, and on
       the LU one otherwise. Conversely, the iterative approach bases on the <b><a href="../man5/cg.5.html">cg</a>(5)</b> conjugate gradient algorithm
       for a symmetric definite positive matrix, and on the <b><a href="../man5/gmres.5.html">gmres</a>(5)</b> algorithm otherwise.

</pre><h4><b>COMPUTING</b> <b>THE</b> <b>DETERMINANT</b></h4><pre>
       This feature is useful e.g. when tracking a change of sign in the determinant of a matrix, e.g. during
       the <b><a href="../man3/continuation.3.html">continuation</a>(3)</b> algorithm. When using a direct method, the determinant of the matrix can be computed
       as:

           solver_option sopt;
           sopt.iterative = false;
           solver sa (a, sopt);
           cout &lt;&lt; sa.det().mantissa &lt;&lt; '*'
                &lt;&lt; sa.det().base &lt;&lt; '^'
                &lt;&lt; sa.det().exponant &lt;&lt; endl;

        The sa.det() method returns an object of type solver::determinant_type that contains a mantissa and an
       exponent in a given base (generally 2 or 10). For some rare direct solvers, the computation of the
       determinant is not yet fully supported: it is the case for the Cholesky factorization from the eigen
       library. In you find such a problem, please switch to another solver library, see the <b><a href="../man4/solver_option.4.html">solver_option</a>(4)</b>
       class.

</pre><h4><b>AUTOMATIC</b> <b>CHOICE</b> <b>AND</b> <b>CUSTOMIZATION</b></h4><pre>
       When the matrix is obtained from the finite element discretization of 3D partial differential problems,
       the iterative solver is the default choice. Otherwise, the direct solver is selected.

       More precisely, the choice between direct or iterative solver depends upon the a.pattern_dimension()
       property of the <b><a href="../man4/csr.4.html">csr</a>(4)</b> sparse matrix. When this pattern dimension is 3, an iterative method is faster and
       less memory consuming than a direct one. See <b>usersguide</b> for a discussion on this subject.

       The symmetry-positive-definiteness of the matrix is tested via the a.is_symmetric() and
       a.is_definite_positive() properties of the <b><a href="../man4/csr.4.html">csr</a>(4)</b> sparse matrix. These properties determine the choices
       between Cholesky/LU methods for the direct case, and between cg/gmres algorithms for the iterative one.
       Most of the time, these properties are automatically well initialized by the finite element assembly
       procedure, via the <b><a href="../man3/integrate.3.html">integrate</a>(3)</b> function.

       Nevertheless, in some special cases, e.g. a linear combination of matrix, or when the matrix has been
       read from a file, it could be necessary to force either the symmetry or the positive-definiteness
       property by the appropriate <b><a href="../man4/csr.4.html">csr</a>(4)</b> member function before to send the matrix to the solver.

</pre><h4><b>PRECONDITIONNERS</b> <b>FOR</b> <b>ITERATIVE</b> <b>SOLVERS</b></h4><pre>
       When using an iterative method, the default is to perform no preconditionning. Several preconditionners
       are available: the <b><a href="../man5/mic.5.html">mic</a>(5)</b> modified incomplete Cholesky for symmetric matrix and the <b><a href="../man5/ilut.5.html">ilut</a>(5)</b> incomplete LU
       one for unsymmetric matrix and the do-nothing <b><a href="../man5/eye.5.html">eye</a>(5)</b> identity preconditionner. A preconditionner can be
       supplied via:

           solver_option sopt;
           sopt.iterative = true;
           solver sa (a, sopt);
           sa.set_preconditionner (ilut(a));
           vec&lt;Float&gt; x = sa.solve(b);

        Note also the <b><a href="../man5/eye.5.html">eye</a>(5)</b> that returns the solver for the identity matrix: it could be be used for specifying
       that we do not use a preconditionner. This is the default behavior. The set_preconditionner member
       function should be called before the first call to the solve method: if no preconditioner has been
       defined at the first call to solve, the default <b><a href="../man5/eye.5.html">eye</a>(5)</b> preconditionner is selected.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file linalg/lib/solver.h

       The solver class is simply an alias to the <b>solver_basic</b> <b>class</b>

       typedef solver_basic&lt;Float&gt; solver;

       The <b>solver_basic</b> <b>class</b> <b>provides</b> <b>an</b> <b>interface</b> <b>to</b> <b>a</b> <b>data</b> <b>container:</b>

       template &lt;class T, class M = rheo_default_memory_model&gt;
       class solver_basic: public smart_pointer_clone&lt;solver_abstract_rep&lt;T,M&gt; &gt; {
       public:
       // typedefs:

         typedef solver_abstract_rep&lt;T,M&gt;        rep;
         typedef smart_pointer_clone&lt;rep&gt;        base;
         typedef typename rep::size_type         size_type;
         typedef typename rep::determinant_type  determinant_type;

       // allocators:

         solver_basic ();
         explicit solver_basic (const csr&lt;T,M&gt;&amp; a, const solver_option&amp; opt = solver_option());
         void update_values (const csr&lt;T,M&gt;&amp; a);

       // accessors:

         vec&lt;T,M&gt; trans_solve (const vec&lt;T,M&gt;&amp; b) const;
         vec&lt;T,M&gt; solve       (const vec&lt;T,M&gt;&amp; b) const;
         determinant_type det() const;
         const solver_option&amp; option() const;
         void set_preconditioner (const solver_basic&lt;T,M&gt;&amp;);
         bool initialized() const;
         std::string name() const;
       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                  <u><a href="../man4rheolef/solver.4rheolef.html">solver</a></u>(4rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>