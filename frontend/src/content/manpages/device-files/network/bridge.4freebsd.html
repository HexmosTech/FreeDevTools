<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>if_bridge — network bridge device</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       if_bridge — network bridge device

</pre><h4><b>SYNOPSIS</b></h4><pre>
       To compile this driver into the kernel, place the following line in your kernel configuration file:

             <b>device</b> <b>if_bridge</b>

       Alternatively, to load the driver as a module at boot time, place the following lines in <u><a href="../man5/loader.conf.5.html">loader.conf</a></u>(5):

             if_bridge_load="YES"
             bridgestp_load="YES"

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>if_bridge</b>  driver creates a logical link between two or more IEEE 802 networks that use the same (or
       “similar enough”) framing format.  For example, it is possible to bridge  Ethernet  and  802.11  networks
       together, but it is not possible to bridge Ethernet and Token Ring together.

       Each  <b>if_bridge</b>  interface  is created at runtime using interface cloning.  This is most easily done with
       the <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8) <b>create</b> command or using the <u>cloned_interfaces</u> variable in <u><a href="../man5/rc.conf.5.html">rc.conf</a></u>(5).

       The <b>if_bridge</b> interface randomly chooses  a  link  (MAC)  address  in  the  range  reserved  for  locally
       administered  addresses  when  it  is  created.   This address is guaranteed to be unique <u>only</u> across all
       <b>if_bridge</b> interfaces on the local machine.  Thus you can theoretically have two bridges on the  different
       machines  with the same link addresses.  The address can be changed by assigning the desired link address
       using <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8).

       If <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) node <u>net.link.bridge.inherit_mac</u> has non-zero value, newly created bridge will  inherit  MAC
       address  from  its  first  member  instead of choosing random link-level address.  This will provide more
       predictable bridge MAC without any additional configuration, but currently this feature is known to break
       some L2 protocols, for example PPPoE that is provided by <u><a href="../man4/ng_pppoe.4.html">ng_pppoe</a></u>(4) and <u><a href="../man8/ppp.8.html">ppp</a></u>(8).   Now  this  feature  is
       considered as experimental and is turned off by-default.

       A bridge can be used to provide several services, such as a simple 802.11-to-Ethernet bridge for wireless
       hosts, and traffic isolation.

       A  bridge works like a switch, forwarding traffic from one interface to another.  Multicast and broadcast
       packets are always forwarded to all interfaces that are part of the bridge.   For  unicast  traffic,  the
       bridge  learns  which  MAC  addresses  are  associated with which interfaces and will forward the traffic
       selectively.

       All the bridged member interfaces need to be up in order to pass network traffic.  These can  be  enabled
       using <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8) or <u>ifconfig</u><b>_</b>⟨<u>interface</u>⟩<b>="up"</b> in <u><a href="../man5/rc.conf.5.html">rc.conf</a></u>(5).

       The  MTU of the first member interface to be added is used as the bridge MTU.  All additional members are
       required to have exactly the same value.

       The TOE, TSO, TXCSUM and TXCSUM6 capabilities on all interfaces added to the bridge are disabled  if  any
       of  the  interfaces  doesn't  support/enable  them.   The  LRO  capability  is  always disabled.  All the
       capabilities are restored when the interface is removed from bridge.  Changing capabilities in  run  time
       may cause NIC reinit and the link flap.

       The  bridge supports “monitor mode”, where the packets are discarded after <u><a href="../man4/bpf.4.html">bpf</a></u>(4) processing, and are not
       processed or forwarded further.  This can be used to multiplex the input of two or more interfaces into a
       single <u><a href="../man4/bpf.4.html">bpf</a></u>(4) stream.  This is useful for reconstructing the traffic for network taps that  transmit  the
       RX/TX signals out through two separate interfaces.

</pre><h4><b>IPV6</b> <b>SUPPORT</b></h4><pre>
       <b>if_bridge</b>  supports  the <b>AF_INET6</b> address family on bridge interfaces.  The following <u><a href="../man5/rc.conf.5.html">rc.conf</a></u>(5) variable
       configures an IPv6 link-local address on <b>bridge0</b> interface:

             ifconfig_bridge0_ipv6="up"

       or in a more explicit manner:

             ifconfig_bridge0_ipv6="inet6 auto_linklocal"

       However, the <b>AF_INET6</b> address family has a concept of scope zone.  Bridging  multiple  interfaces  change
       the  zone  configuration because multiple links are merged to each other and form a new single link while
       the member interfaces still work individually.  This means each member interface  still  has  a  separate
       link-local scope zone and the <b>if_bridge</b> interface has another single, aggregated link-local scope zone at
       the  same  time.   This  situation  is  clearly  against  the description "zones of the same scope cannot
       overlap" in Section 5, RFC 4007.  Although it works in most cases, it can cause some  conterintuitive  or
       undesirable  behavior  in  some  edge  cases  when  both of the <b>if_bridge</b> interface and one of the member
       interface have an IPv6 address and applications use both of them.

       To prevent this situation, <b>if_bridge</b> checks whether a link-local scoped IPv6 address is configured  on  a
       member  interface  to  be  added  and  the  <b>if_bridge</b>  interface.   When the <b>if_bridge</b> interface has IPv6
       addresses, IPv6 addresses on the member interface will be automatically removed before the  interface  is
       added.

       This behavior can be disabled by setting <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) variable <u>net.link.bridge.allow_llz_overlap</u> to <b>1</b>.

       Note  that  <b>ACCEPT_RTADV</b>  and  <b>AUTO_LINKLOCAL</b>  interface  flag  are  not  enabled by default on <b>if_bridge</b>
       interface even when <u>net.inet6.ip6.accept_rtadv</u> and/or <u>net.inet6.ip6.auto_linklocal</u> is set to <b>1</b>.

</pre><h4><b>SPANNING</b> <b>TREE</b></h4><pre>
       The <b>if_bridge</b> driver implements the  Rapid  Spanning  Tree  Protocol  (RSTP  or  802.1w)  with  backwards
       compatibility  with  the legacy Spanning Tree Protocol (STP).  Spanning Tree is used to detect and remove
       loops in a network topology.

       RSTP provides faster spanning tree convergence than legacy STP, the protocol  will  exchange  information
       with neighbouring switches to quickly transition to forwarding without creating loops.

       The  code  will  default to RSTP mode but will downgrade any port connected to a legacy STP network so is
       fully backward compatible.  A bridge can be forced to operate in STP mode without rapid state transitions
       via the <u>proto</u> command in <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8).

       The bridge can log STP port changes to <u><a href="../man3/syslog.3.html">syslog</a></u>(3) by enabling the <u>net.link.bridge.log_stp</u>  variable  using
       <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8).

</pre><h4><b>PACKET</b> <b>FILTERING</b></h4><pre>
       Packet  filtering  can  be  used with any firewall package that hooks in via the <u><a href="../man9/pfil.9.html">pfil</a></u>(9) framework.  When
       filtering is enabled, bridged packets will pass through the filter inbound on the originating  interface,
       on  the  bridge interface and outbound on the appropriate interfaces.  Either stage can be disabled.  The
       filtering behaviour can be controlled using <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8):

       <u>net.link.bridge.pfil_onlyip</u>  Controls the handling of non-IP packets which are  not  passed  to  <u><a href="../man9/pfil.9.html">pfil</a></u>(9).
                                    Set  to  <b>1</b> to only allow IP packets to pass (subject to firewall rules), set
                                    to <b>0</b> to unconditionally pass all non-IP Ethernet frames.

       <u>net.link.bridge.pfil_member</u>  Set to <b>1</b> to enable filtering on the incoming and outgoing member interfaces,
                                    set to <b>0</b> to disable it.

       <u>net.link.bridge.pfil_bridge</u>  Set to <b>1</b> to enable filtering on the bridge interface, set to  <b>0</b>  to  disable
                                    it.

       <u>net.link.bridge.pfil_local_phys</u>
                                    Set  to  <b>1</b>  to  additionally  filter  on  the physical interface for locally
                                    destined packets.  Set to <b>0</b> to disable this feature.

       <u>net.link.bridge.ipfw</u>         Set to <b>1</b> to enable layer2 filtering with <u><a href="../man4/ipfirewall.4.html">ipfirewall</a></u>(4), set to <b>0</b> to  disable
                                    it.   This  needs  to  be  enabled  for  <u><a href="../man4/dummynet.4.html">dummynet</a></u>(4)  support.  When <u>ipfw</u> is
                                    enabled, <u>pfil_bridge</u> and <u>pfil_member</u> will be disabled so that  IPFW  is  not
                                    run twice; these can be re-enabled if desired.

       <u>net.link.bridge.ipfw_arp</u>     Set  to  <b>1</b>  to  enable  layer2 ARP filtering with <u><a href="../man4/ipfirewall.4.html">ipfirewall</a></u>(4), set to <b>0</b> to
                                    disable it.  Requires <u>ipfw</u> to be enabled.

       ARP and REVARP packets are forwarded without being filtered and others that are not IP nor  IPv6  packets
       are  not  forwarded  when  <u>pfil_onlyip</u>  is enabled.  IPFW can filter Ethernet types using <b>mac-type</b> so all
       packets are passed to the filter for processing.

       The packets originating from the bridging host will be seen by the filter on the interface that is looked
       up in the routing table.

       The packets destined to the bridging host will be seen by the  filter  on  the  interface  with  the  MAC
       address  equal to the packet's destination MAC.  There are situations when some of the bridge members are
       sharing the same MAC address (for example the <u><a href="../man4/vlan.4.html">vlan</a></u>(4) interfaces: they  are  currently  sharing  the  MAC
       address  of  the  parent physical interface).  It is not possible to distinguish between these interfaces
       using their MAC address, excluding the case when the packet's destination MAC address is equal to the MAC
       address of the interface on which the packet was entered to the system.  In this case the filter will see
       the incoming packet on this interface.  In all other cases the interface seen by  the  packet  filter  is
       chosen  from  the list of bridge members with the same MAC address and the result strongly depends on the
       member addition sequence and the actual implementation of <b>if_bridge</b>.  It is not recommended  to  rely  on
       the order chosen by the current <b>if_bridge</b> implementation: it can be changed in the future.

       The previous paragraph is best illustrated with the following pictures.  Let

       <b>•</b>   the MAC address of the incoming packet's destination is <b>nn:nn:nn:nn:nn:nn</b>,

       <b>•</b>   the interface on which packet entered the system is <b>ifX</b>,

       <b>•</b>   <b>ifX</b> MAC address is <b>xx:xx:xx:xx:xx:xx</b>,

       <b>•</b>   there are possibly other bridge members with the same MAC address <b>xx:xx:xx:xx:xx:xx</b>,

       <b>•</b>   the  bridge  has  more than one interface that are sharing the same MAC address <b>yy:yy:yy:yy:yy:yy</b>; we
           will call them <b>vlanY1</b>, <b>vlanY2</b>, etc.

       Then if the MAC address <b>nn:nn:nn:nn:nn:nn</b> is equal to the <b>xx:xx:xx:xx:xx:xx</b> then the filter will see  the
       packet  on  the  interface  <b>ifX</b>  no  matter  if  there are any other bridge members carrying the same MAC
       address.  But if the MAC address <b>nn:nn:nn:nn:nn:nn</b> is equal to the <b>yy:yy:yy:yy:yy:yy</b> then  the  interface
       that  will  be  seen  by  the filter is one of the <b>vlanYn</b>.  It is not possible to predict the name of the
       actual interface without the knowledge of the system state and the <b>if_bridge</b> implementation details.

       This problem arises for any bridge members that are sharing the same MAC address, not only to the <u><a href="../man4/vlan.4.html">vlan</a></u>(4)
       ones: they we taken just as the example of such situation.  So  if  one  wants  the  filter  the  locally
       destined  packets  based on their interface name, one should be aware of this implication.  The described
       situation will appear at least on the filtering bridges that are doing IP-forwarding;  in  some  of  such
       cases  it  is  better  to  assign  the  IP  address only to the <b>if_bridge</b> interface and not to the bridge
       members.  Enabling <u>net.link.bridge.pfil_local_phys</u> will let  you  do  the  additional  filtering  on  the
       physical interface.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  when  placed in the file <u>/etc/rc.conf</u> will cause a bridge called “<b>bridge0</b>” to be created,
       and will add the interfaces “<b>wlan0</b>” and “<b>fxp0</b>” to the bridge, and then enable packet forwarding.  Such  a
       configuration  could  be  used  to  implement  a  simple  802.11-to-Ethernet  bridge (assuming the 802.11
       interface is in ad-hoc mode).

             cloned_interfaces="bridge0"
             ifconfig_bridge0="addm wlan0 addm fxp0 up"

       For the bridge to forward packets, all member interfaces and the bridge need to be up.  The above example
       would also require:

             create_args_wlan0="wlanmode hostap"
             ifconfig_wlan0="up ssid my_ap mode 11g"
             ifconfig_fxp0="up"

       Consider a system with two 4-port Ethernet boards.  The following will cause a bridge consisting of all 8
       ports with Rapid Spanning Tree enabled to be created:

             ifconfig bridge0 create
             ifconfig bridge0 \
                 addm fxp0 stp fxp0 \
                 addm fxp1 stp fxp1 \
                 addm fxp2 stp fxp2 \
                 addm fxp3 stp fxp3 \
                 addm fxp4 stp fxp4 \
                 addm fxp5 stp fxp5 \
                 addm fxp6 stp fxp6 \
                 addm fxp7 stp fxp7 \
                 up

       The bridge can be used as a regular host interface at the same time as bridging between its member ports.
       In this example, the bridge connects em0 and em1, and will receive its IP address through DHCP:

             cloned_interfaces="bridge0"
             ifconfig_bridge0="addm em0 addm em1 DHCP"
             ifconfig_em0="up"
             ifconfig_em1="up"

       The bridge can tunnel Ethernet across an IP internet using the EtherIP protocol.  This  can  be  combined
       with <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4) to provide an encrypted connection.  Create a <u><a href="../man4/gif.4.html">gif</a></u>(4) interface and set the local and remote
       IP addresses for the tunnel, these are reversed on the remote bridge.

             ifconfig gif0 create
             ifconfig gif0 tunnel 1.2.3.4 5.6.7.8 up
             ifconfig bridge0 create
             ifconfig bridge0 addm fxp0 addm gif0 up

       Note  that FreeBSD 6.1, 6.2, 6.3, 7.0, 7.1, and 7.2 have a bug in the EtherIP protocol.  For more details
       and workaround, see <u><a href="../man4/gif.4.html">gif</a></u>(4) manual page.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/gif.4.html">gif</a></u>(4), <u><a href="../man4/ipf.4.html">ipf</a></u>(4), <u><a href="../man4/ipfw.4.html">ipfw</a></u>(4), <u><a href="../man4/pf.4.html">pf</a></u>(4), <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>if_bridge</b> driver first appeared in FreeBSD 6.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>bridge</b> driver  was  originally  written  by  Jason  L.  Wright  &lt;<u><a href="mailto:jason@thought.net">jason@thought.net</a></u>&gt;  as  part  of  an
       undergraduate independent study at the University of North Carolina at Greensboro.

       This  version  of  the  <b>if_bridge</b>  driver has been heavily modified from the original version by Jason R.
       Thorpe &lt;<u><a href="mailto:thorpej@wasabisystems.com">thorpej@wasabisystems.com</a></u>&gt;.

       Rapid Spanning Tree Protocol (RSTP) support was added by Andrew Thompson &lt;<u><a href="mailto:thompsa@FreeBSD.org">thompsa@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The <b>if_bridge</b> driver currently supports only Ethernet and Ethernet-like (e.g., 802.11)  network  devices,
       with exactly the same interface MTU size as the bridge device.

Debian                                          October 16, 2017                                    <u><a href="../man4/IF_BRIDGE.4.html">IF_BRIDGE</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>