<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unix — UNIX-domain protocol family</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unix — UNIX-domain protocol family

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/un.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  Unix-domain  protocol  family  is  a  collection  of  protocols  that  provides  local  (on-machine)
       interprocess communication through the normal <u><a href="../man2/socket.2.html">socket</a></u>(2) mechanisms.  The Unix-domain family supports  the
       SOCK_STREAM, SOCK_SEQPACKET, and SOCK_DGRAM socket types and uses file system pathnames for addressing.

</pre><h4><b>ADDRESSING</b></h4><pre>
       Unix-domain  addresses  are variable-length file system pathnames of at most 104 characters.  The include
       file &lt;<u>sys/un.h</u>&gt; defines this address:

             struct sockaddr_un {
                     u_char  sun_len;
                     u_char  sun_family;
                     char    sun_path[104];
             };

       Binding a name to a Unix-domain socket with <u><a href="../man2/bind.2.html">bind</a></u>(2) causes a socket  file  to  be  created  in  the  file
       system.  This file is <u>not</u> removed when the socket is closed — <u><a href="../man2/unlink.2.html">unlink</a></u>(2) must be used to remove the file.

       The  length  of  Unix-domain  address, required by <u><a href="../man2/bind.2.html">bind</a></u>(2) and <u><a href="../man2/connect.2.html">connect</a></u>(2), can be calculated by the macro
       <b>SUN_LEN</b>() defined in &lt;<u>sys/un.h</u>&gt;.  The <u>sun_path</u> field must be terminated by a NUL  character  to  be  used
       with <b>SUN_LEN</b>(), but the terminating NUL is <u>not</u> part of the address.

       The  Unix-domain protocol family does not support broadcast addressing or any form of “wildcard” matching
       on incoming messages.  All addresses are absolute- or relative-pathnames of  other  Unix-domain  sockets.
       Normal  file  system  access-control  mechanisms  are  also applied when referencing pathnames; e.g., the
       destination of a <u><a href="../man2/connect.2.html">connect</a></u>(2) or <u><a href="../man2/sendto.2.html">sendto</a></u>(2) must be writable.

</pre><h4><b>CONTROL</b> <b>MESSAGES</b></h4><pre>
       The Unix-domain sockets support the communication  of  Unix  file  descriptors  and  process  credentials
       through  the use of the <u>msg_control</u> field in the <u>msg</u> argument to <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2) and <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2).  The items to
       be passed are described using a <u>struct</u> <u>cmsghdr</u> that is defined in the include file &lt;<u>sys/socket.h</u>&gt;.

       To send file descriptors, the type of the message is SCM_RIGHTS, and the data portion of the messages  is
       an  array  of  integers  representing the file descriptors to be passed.  The number of descriptors being
       passed is defined by the length field of the message; the length field is the sum  of  the  size  of  the
       header plus the size of the array of file descriptors.

       The  received  descriptor is a <u>duplicate</u> of the sender's descriptor, as if it were created via <b>dup(fd)</b> or
       <b>fcntl(fd,</b> <b>F_DUPFD_CLOEXEC,</b> <b>0)</b> depending on whether MSG_CMSG_CLOEXEC is passed  in  the  <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2)  call.
       Descriptors  that  are awaiting delivery, or that are purposely not received, are automatically closed by
       the system when the destination socket is closed.

       Credentials of the sending process can  be  transmitted  explicitly  using  a  control  message  of  type
       SCM_CREDS with a data portion of type <u>struct</u> <u>cmsgcred</u>, defined in &lt;<u>sys/socket.h</u>&gt; as follows:

       struct cmsgcred {
         pid_t cmcred_pid;             /* PID of sending process */
         uid_t cmcred_uid;             /* real UID of sending process */
         uid_t cmcred_euid;            /* effective UID of sending process */
         gid_t cmcred_gid;             /* real GID of sending process */
         short cmcred_ngroups;         /* number of groups */
         gid_t cmcred_groups[CMGROUP_MAX];     /* groups */
       };

       The sender should pass a zeroed buffer which will be filled in by the system.

       The group list is truncated to at most CMGROUP_MAX GIDs.

       The  process  ID  <u>cmcred_pid</u>  should  not  be looked up (such as via the KERN_PROC_PID sysctl) for making
       security decisions.  The sending process could have exited and its process ID already been reused  for  a
       new process.

</pre><h4><b>SOCKET</b> <b>OPTIONS</b></h4><pre>
       UNIX  domain sockets support a number of socket options for the options level SOL_LOCAL, which can be set
       with <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2) and tested with <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2):

       LOCAL_CREDS     This option may be enabled on SOCK_DGRAM, SOCK_SEQPACKET, or a SOCK_STREAM socket.   This
                       option  provides  a  mechanism for the receiver to receive the credentials of the process
                       calling <u><a href="../man2/write.2.html">write</a></u>(2), <u><a href="../man2/send.2.html">send</a></u>(2), <u><a href="../man2/sendto.2.html">sendto</a></u>(2) or <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2) as a <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) control message.   The
                       <u>msg_control</u>  field  in  the  <u>msghdr</u>  structure points to a buffer that contains a <u>cmsghdr</u>
                       structure followed by a variable length <u>sockcred</u> structure, defined in &lt;<u>sys/socket.h</u>&gt;  as
                       follows:

                       struct sockcred {
                         uid_t sc_uid;         /* real user id */
                         uid_t sc_euid;        /* effective user id */
                         gid_t sc_gid;         /* real group id */
                         gid_t sc_egid;        /* effective group id */
                         int   sc_ngroups;     /* number of supplemental groups */
                         gid_t sc_groups[1];   /* variable length */
                       };

                       The current implementation truncates the group list to at most CMGROUP_MAX groups.

                       The  <b>SOCKCREDSIZE</b>()  macro  computes  the  size of the <u>sockcred</u> structure for a specified
                       number of groups.  The <u>cmsghdr</u> fields have the following values:

                       cmsg_len = CMSG_LEN(SOCKCREDSIZE(ngroups))
                       cmsg_level = SOL_SOCKET
                       cmsg_type = SCM_CREDS

                       On SOCK_STREAM and SOCK_SEQPACKET sockets credentials are passed only on the  first  read
                       from a socket, then the system clears the option on the socket.

                       This  option and the above explicit <u>struct</u> <u>cmsgcred</u> both use the same value SCM_CREDS but
                       incompatible control messages.  If this option is  enabled  and  the  sender  attached  a
                       SCM_CREDS  control  message  with  a  <u>struct</u>  <u>cmsgcred</u>, it will be discarded and a <u>struct</u>
                       <u>sockcred</u> will be included.

                       Many setuid programs will <u><a href="../man2/write.2.html">write</a></u>(2) data at least partially  controlled  by  the  invoker,
                       such  as  error messages.  Therefore, a message accompanied by a particular <u>sc_euid</u> value
                       should not be trusted as being from that user.

       LOCAL_CONNWAIT  Used with SOCK_STREAM sockets, this option causes the <u><a href="../man2/connect.2.html">connect</a></u>(2) function to block  until
                       <u><a href="../man2/accept.2.html">accept</a></u>(2) has been called on the listening socket.

       LOCAL_PEERCRED  Requested  via  <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2)  on  a SOCK_STREAM socket returns credentials of the remote
                       side.  These will arrive in the  form  of  a  filled  in  <u>xucred</u>  structure,  defined  in
                       &lt;<u>sys/ucred.h</u>&gt; as follows:

                       struct xucred {
                         u_int cr_version;             /* structure layout version */
                         uid_t cr_uid;                 /* effective user id */
                         short cr_ngroups;             /* number of groups */
                         gid_t cr_groups[XU_NGROUPS];  /* groups */
                       };
                       The <u>cr_version</u> fields should be checked against XUCRED_VERSION define.

                       The  credentials  presented  to the server (the <u><a href="../man2/listen.2.html">listen</a></u>(2) caller) are those of the client
                       when it called <u><a href="../man2/connect.2.html">connect</a></u>(2); the  credentials  presented  to  the  client  (the  <u><a href="../man2/connect.2.html">connect</a></u>(2)
                       caller)  are  those  of the server when it called <u><a href="../man2/listen.2.html">listen</a></u>(2).  This mechanism is reliable;
                       there is no way for either party to influence  the  credentials  presented  to  its  peer
                       except  by  calling  the  appropriate  system  call (e.g., <u><a href="../man2/connect.2.html">connect</a></u>(2) or <u><a href="../man2/listen.2.html">listen</a></u>(2)) under
                       different effective credentials.

                       To reliably obtain peer credentials on a  SOCK_DGRAM  socket  refer  to  the  LOCAL_CREDS
                       socket option.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/connect.2.html">connect</a></u>(2),  <u><a href="../man2/dup.2.html">dup</a></u>(2), <u><a href="../man2/fcntl.2.html">fcntl</a></u>(2), <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2), <u><a href="../man2/listen.2.html">listen</a></u>(2), <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2), <u><a href="../man2/sendto.2.html">sendto</a></u>(2), <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2), <u><a href="../man2/socket.2.html">socket</a></u>(2),
       <u><a href="../man3/CMSG_DATA.3.html">CMSG_DATA</a></u>(3), <u><a href="../man4/intro.4.html">intro</a></u>(4)

       “An Introductory 4.3 BSD Interprocess Communication Tutorial”, <u>PS1</u>, 7.

       “An Advanced 4.3 BSD Interprocess Communication Tutorial”, <u>PS1</u>, 8.

Debian                                           August 3, 2020                                          <u><a href="../man4/UNIX.4.html">UNIX</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>