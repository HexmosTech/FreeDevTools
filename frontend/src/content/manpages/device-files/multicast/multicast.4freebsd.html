<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>multicast — Multicast Routing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       multicast — Multicast Routing

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>options</b> <b>MROUTING</b>

       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;</b>
       <b>#include</b> <b>&lt;netinet/ip_mroute.h&gt;</b>
       <b>#include</b> <b>&lt;netinet6/ip6_mroute.h&gt;</b>

       <u>int</u>
       <b>getsockopt</b>(<u>int</u> <u>s</u>, <u>IPPROTO_IP</u>, <u>MRT_INIT</u>, <u>void</u> <u>*optval</u>, <u>socklen_t</u> <u>*optlen</u>);

       <u>int</u>
       <b>setsockopt</b>(<u>int</u> <u>s</u>, <u>IPPROTO_IP</u>, <u>MRT_INIT</u>, <u>const</u> <u>void</u> <u>*optval</u>, <u>socklen_t</u> <u>optlen</u>);

       <u>int</u>
       <b>getsockopt</b>(<u>int</u> <u>s</u>, <u>IPPROTO_IPV6</u>, <u>MRT6_INIT</u>, <u>void</u> <u>*optval</u>, <u>socklen_t</u> <u>*optlen</u>);

       <u>int</u>
       <b>setsockopt</b>(<u>int</u> <u>s</u>, <u>IPPROTO_IPV6</u>, <u>MRT6_INIT</u>, <u>const</u> <u>void</u> <u>*optval</u>, <u>socklen_t</u> <u>optlen</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Multicast  routing  is  used  to  efficiently  propagate  data packets to a set of multicast listeners in
       multipoint networks.  If unicast is used to replicate the data to all listeners, then some of the network
       links may carry multiple copies of the same data  packets.   With  multicast  routing,  the  overhead  is
       reduced to one copy (at most) per network link.

       All  multicast-capable  routers  must  run  a  common multicast routing protocol.  It is recommended that
       either Protocol Independent Multicast - Sparse Mode (PIM-SM), or Protocol Independent Multicast  -  Dense
       Mode (PIM-DM) are used, as these are now the generally accepted protocols in the Internet community.  The
       “HISTORY” section discusses previous multicast routing protocols.

       To start multicast routing, the user must enable multicast forwarding in the kernel (see “SYNOPSIS” about
       the  kernel  configuration  options),  and must run a multicast routing capable user-level process.  From
       developer's point of view, the programming guide described in the “Programming Guide” section  should  be
       used to control the multicast forwarding in the kernel.

   <b>Programming</b> <b>Guide</b>
       This  section  provides  information  about  the  basic  multicast  routing API.  The so-called “advanced
       multicast API” is described in the “Advanced Multicast API Programming Guide” section.

       First, a multicast routing socket must be open.  That socket would  be  used  to  control  the  multicast
       forwarding  in  the  kernel.   Note  that  most  operations  below  require certain privilege (i.e., root
       privilege):

       /* IPv4 */
       int mrouter_s4;
       mrouter_s4 = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);

       int mrouter_s6;
       mrouter_s6 = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);

       Note that if the router needs to open an IGMP or ICMPv6 socket (in case of IPv4  and  IPv6  respectively)
       for  sending or receiving of IGMP or MLD multicast group membership messages, then the same <u>mrouter_s4</u> or
       <u>mrouter_s6</u> sockets should be used for sending and receiving respectively IGMP or MLD messages.   In  case
       of  BSD-derived  kernel,  it  may  be  possible  to  open separate sockets for IGMP or MLD messages only.
       However, some other kernels (e.g., Linux) require that the multicast routing  socket  must  be  used  for
       sending  and  receiving of IGMP or MLD messages.  Therefore, for portability reason the multicast routing
       socket should be reused for IGMP and MLD messages as well.

       After the multicast routing socket is open, it can be used to enable or disable multicast  forwarding  in
       the kernel:

       /* IPv4 */
       int v = 1;        /* 1 to enable, or 0 to disable */
       setsockopt(mrouter_s4, IPPROTO_IP, MRT_INIT, (void *)&amp;v, sizeof(v));

       /* IPv6 */
       int v = 1;        /* 1 to enable, or 0 to disable */
       setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_INIT, (void *)&amp;v, sizeof(v));
       ...
       /* If necessary, filter all ICMPv6 messages */
       struct icmp6_filter filter;
       ICMP6_FILTER_SETBLOCKALL(&amp;filter);
       setsockopt(mrouter_s6, IPPROTO_ICMPV6, ICMP6_FILTER, (void *)&amp;filter,
                  sizeof(filter));

       After  multicast forwarding is enabled, the multicast routing socket can be used to enable PIM processing
       in the kernel if we are running PIM-SM or PIM-DM (see <u><a href="../man4/pim.4.html">pim</a></u>(4)).

       For each network interface (e.g., physical or  a  virtual  tunnel)  that  would  be  used  for  multicast
       forwarding, a corresponding multicast interface must be added to the kernel:

       /* IPv4 */
       struct vifctl vc;
       memset(&amp;vc, 0, sizeof(vc));
       /* Assign all vifctl fields as appropriate */
       vc.vifc_vifi = vif_index;
       vc.vifc_flags = vif_flags;
       vc.vifc_threshold = min_ttl_threshold;
       vc.vifc_rate_limit = 0;
       memcpy(&amp;vc.vifc_lcl_addr, &amp;vif_local_address, sizeof(vc.vifc_lcl_addr));
       setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_VIF, (void *)&amp;vc,
                  sizeof(vc));

       The  <u>vif_index</u>  must  be  unique  per  vif.   The  <u>vif_flags</u>  contains  the  VIFF_*  flags  as defined in
       &lt;<u>netinet/ip_mroute.h</u>&gt;.  The VIFF_TUNNEL flag is no longer  supported  by  FreeBSD.   Users  who  wish  to
       forward multicast datagrams over a tunnel should consider configuring a <u><a href="../man4/gif.4.html">gif</a></u>(4) or <u><a href="../man4/gre.4.html">gre</a></u>(4) tunnel and using
       it as a physical interface.

       The  <u>min_ttl_threshold</u> contains the minimum TTL a multicast data packet must have to be forwarded on that
       vif.  Typically, it would have value of 1.

       The <u>max_rate_limit</u> argument is no longer supported in FreeBSD and should be set to 0.  Users who wish  to
       rate-limit multicast datagrams should consider the use of <u><a href="../man4/dummynet.4.html">dummynet</a></u>(4) or <u><a href="../man4/altq.4.html">altq</a></u>(4).

       The  <u>vif_local_address</u>  contains  the  local  IP  address  of  the  corresponding  local  interface.  The
       <u>vif_remote_address</u> contains the remote IP address in case of DVMRP multicast tunnels.

       /* IPv6 */
       struct mif6ctl mc;
       memset(&amp;mc, 0, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));
       /* Assign all mif6ctl fields as appropriate */
       mc.mif6c_mifi = mif_index;
       mc.mif6c_flags = mif_flags;
       mc.mif6c_pifi = pif_index;
       setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_ADD_MIF, (void *)&amp;mc,
                  <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));

       The <u>mif_index</u> must  be  unique  per  vif.   The  <u>mif_flags</u>  contains  the  MIFF_*  flags  as  defined  in
       &lt;<u>netinet6/ip6_mroute.h</u>&gt;.   The  <u>pif_index</u>  is  the  physical  interface  index of the corresponding local
       interface.

       A multicast interface is deleted by:

       /* IPv4 */
       vifi_t vifi = vif_index;
       setsockopt(mrouter_s4, IPPROTO_IP, MRT_DEL_VIF, (void *)&amp;vifi,
                  sizeof(vifi));

       /* IPv6 */
       mifi_t mifi = mif_index;
       setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_DEL_MIF, (void *)&amp;mifi,
                  <a href="../manmifi/sizeof.mifi.html">sizeof</a>(mifi));

       After the multicast forwarding is enabled, and the multicast virtual interfaces are added, the kernel may
       deliver upcall messages (also called signals later in this text) on the multicast routing socket that was
       open  earlier  with  MRT_INIT  or  MRT6_INIT.   The  IPv4  upcalls  have  <u>struct</u>  <u>igmpmsg</u>   header   (see
       &lt;<u>netinet/ip_mroute.h</u>&gt;)  with  field  <u>im_mbz</u>  set to zero.  Note that this header follows the structure of
       <u>struct</u> <u>ip</u> with the protocol field <u>ip_p</u> set to zero.  The IPv6 upcalls have  <u>struct</u>  <u>mrt6msg</u>  header  (see
       &lt;<u>netinet6/ip6_mroute.h</u>&gt;)  with field <u>im6_mbz</u> set to zero.  Note that this header follows the structure of
       <u>struct</u> <u>ip6_hdr</u> with the next header field <u>ip6_nxt</u> set to zero.

       The upcall header contains field <u>im_msgtype</u> and <u>im6_msgtype</u> with the type of  the  upcall  IGMPMSG_*  and
       MRT6MSG_*  for  IPv4  and  IPv6 respectively.  The values of the rest of the upcall header fields and the
       body of the upcall message depend on the particular upcall type.

       If the upcall message type is IGMPMSG_NOCACHE or MRT6MSG_NOCACHE, this is an indication that a  multicast
       packet  has  reached  the  multicast  router,  but  the  router  has no forwarding state for that packet.
       Typically, the upcall would be a signal for the multicast  routing  user-level  process  to  install  the
       appropriate Multicast Forwarding Cache (MFC) entry in the kernel.

       An MFC entry is added by:

       /* IPv4 */
       struct mfcctl mc;
       memset(&amp;mc, 0, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));
       memcpy(&amp;mc.mfcc_origin, &amp;source_addr, sizeof(mc.mfcc_origin));
       memcpy(&amp;mc.mfcc_mcastgrp, &amp;group_addr, sizeof(mc.mfcc_mcastgrp));
       mc.mfcc_parent = iif_index;
       for (i = 0; i &lt; maxvifs; i++)
           mc.mfcc_ttls[i] = oifs_ttl[i];
       setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_MFC,
                  (void *)&amp;mc, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));

       /* IPv6 */
       struct mf6cctl mc;
       memset(&amp;mc, 0, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));
       memcpy(&amp;mc.mf6cc_origin, &amp;source_addr, sizeof(mc.mf6cc_origin));
       memcpy(&amp;mc.mf6cc_mcastgrp, &amp;group_addr, <a href="../manmf6cc_mcastgrp/sizeof.mf6cc_mcastgrp.html">sizeof</a>(mf6cc_mcastgrp));
       mc.mf6cc_parent = iif_index;
       for (i = 0; i &lt; maxvifs; i++)
           if (oifs_ttl[i] &gt; 0)
               IF_SET(i, &amp;mc.mf6cc_ifset);
       setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_ADD_MFC,
                  (void *)&amp;mc, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));

       The  <u>source_addr</u>  and  <u>group_addr</u> are the source and group address of the multicast packet (as set in the
       upcall message).  The <u>iif_index</u> is the virtual interface index of the multicast interface  the  multicast
       packets  for this specific source and group address should be received on.  The <u>oifs_ttl[]</u> array contains
       the minimum TTL (per interface) a multicast packet should have to be forwarded on an outgoing  interface.
       If  the TTL value is zero, the corresponding interface is not included in the set of outgoing interfaces.
       Note that in case of IPv6 only the set of outgoing interfaces can be specified.

       An MFC entry is deleted by:

       /* IPv4 */
       struct mfcctl mc;
       memset(&amp;mc, 0, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));
       memcpy(&amp;mc.mfcc_origin, &amp;source_addr, sizeof(mc.mfcc_origin));
       memcpy(&amp;mc.mfcc_mcastgrp, &amp;group_addr, sizeof(mc.mfcc_mcastgrp));
       setsockopt(mrouter_s4, IPPROTO_IP, MRT_DEL_MFC,
                  (void *)&amp;mc, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));

       /* IPv6 */
       struct mf6cctl mc;
       memset(&amp;mc, 0, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));
       memcpy(&amp;mc.mf6cc_origin, &amp;source_addr, sizeof(mc.mf6cc_origin));
       memcpy(&amp;mc.mf6cc_mcastgrp, &amp;group_addr, <a href="../manmf6cc_mcastgrp/sizeof.mf6cc_mcastgrp.html">sizeof</a>(mf6cc_mcastgrp));
       setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_DEL_MFC,
                  (void *)&amp;mc, <a href="../manmc/sizeof.mc.html">sizeof</a>(mc));

       The following method can be used to get various statistics per installed MFC entry in the  kernel  (e.g.,
       the number of forwarded packets per source and group address):

       /* IPv4 */
       struct sioc_sg_req sgreq;
       memset(&amp;sgreq, 0, sizeof(sgreq));
       memcpy(&amp;sgreq.src, &amp;source_addr, sizeof(sgreq.src));
       memcpy(&amp;sgreq.grp, &amp;group_addr, sizeof(sgreq.grp));
       ioctl(mrouter_s4, SIOCGETSGCNT, &amp;sgreq);

       /* IPv6 */
       struct sioc_sg_req6 sgreq;
       memset(&amp;sgreq, 0, sizeof(sgreq));
       memcpy(&amp;sgreq.src, &amp;source_addr, sizeof(sgreq.src));
       memcpy(&amp;sgreq.grp, &amp;group_addr, sizeof(sgreq.grp));
       ioctl(mrouter_s6, SIOCGETSGCNT_IN6, &amp;sgreq);

       The  following method can be used to get various statistics per multicast virtual interface in the kernel
       (e.g., the number of forwarded packets per interface):

       /* IPv4 */
       struct sioc_vif_req vreq;
       memset(&amp;vreq, 0, sizeof(vreq));
       vreq.vifi = vif_index;
       ioctl(mrouter_s4, SIOCGETVIFCNT, &amp;vreq);

       /* IPv6 */
       struct sioc_mif_req6 mreq;
       memset(&amp;mreq, 0, <a href="../manmreq/sizeof.mreq.html">sizeof</a>(mreq));
       mreq.mifi = vif_index;
       ioctl(mrouter_s6, SIOCGETMIFCNT_IN6, &amp;mreq);

   <b>Advanced</b> <b>Multicast</b> <b>API</b> <b>Programming</b> <b>Guide</b>
       If we want to add new features in the kernel, it becomes difficult  to  preserve  backward  compatibility
       (binary  and  API),  and  at  the  same  time  to allow user-level processes to take advantage of the new
       features (if the kernel supports them).

       One of the mechanisms that allows us to preserve the backward compatibility  is  a  sort  of  negotiation
       between the user-level process and the kernel:

       1.   The  user-level process tries to enable in the kernel the set of new features (and the corresponding
            API) it would like to use.

       2.   The kernel returns the (sub)set of features it knows about and is willing to be enabled.

       3.   The user-level process uses only that set of features the kernel has agreed on.

       To support backward compatibility, if the user-level process does not  ask  for  any  new  features,  the
       kernel  defaults  to  the  basic  multicast  API  (see  the “Programming Guide” section).  Currently, the
       advanced multicast API exists only for IPv4; in the future there will be IPv6 support as well.

       Below is a summary of the expandable API solution.  Note that all new options and structures are  defined
       in &lt;<u>netinet/ip_mroute.h</u>&gt; and &lt;<u>netinet6/ip6_mroute.h</u>&gt;, unless stated otherwise.

       The user-level process uses new <b>getsockopt</b>()/<b>setsockopt</b>() options to perform the API features negotiation
       with  the  kernel.   This negotiation must be performed right after the multicast routing socket is open.
       The set of desired/allowed features is stored in a bitset (currently, in <u>uint32_t</u>; i.e.,  maximum  of  32
       new  features).   The  new  <b>getsockopt</b>()/<b>setsockopt</b>()  options  are  MRT_API_SUPPORT  and MRT_API_CONFIG.
       Example:

       uint32_t v;
       getsockopt(sock, IPPROTO_IP, MRT_API_SUPPORT, (void *)&amp;v, sizeof(v));

       would set in <u>v</u> the pre-defined bits that the kernel API supports.  The eight least  significant  bits  in
       <u>uint32_t</u>  are  same as the eight possible flags MRT_MFC_FLAGS_* that can be used in <u>mfcc_flags</u> as part of
       the new definition of <u>struct</u> <u>mfcctl</u> (see below about those flags), which leaves 24 flags  for  other  new
       features.    The   value   returned   by   <b>getsockopt</b>(<u>MRT_API_SUPPORT</u>)  is  read-only;  in  other  words,
       <b>setsockopt</b>(<u>MRT_API_SUPPORT</u>) would fail.

       To modify the API, and to set some specific feature in the kernel, then:

       uint32_t v = MRT_MFC_FLAGS_DISABLE_WRONGVIF;
       if (setsockopt(sock, IPPROTO_IP, MRT_API_CONFIG, (void *)&amp;v, sizeof(v))
           != 0) {
           return (ERROR);
       }
       if (v &amp; MRT_MFC_FLAGS_DISABLE_WRONGVIF)
           return (OK);        /* Success */
       else
           return (ERROR);

       In other words, when <b>setsockopt</b>(<u>MRT_API_CONFIG</u>) is called, the argument to it specifies the  desired  set
       of  features  to  be  enabled in the API and the kernel.  The return value in <u>v</u> is the actual (sub)set of
       features that were enabled in the kernel.  To obtain later the same set of features  that  were  enabled,
       then:

       getsockopt(sock, IPPROTO_IP, MRT_API_CONFIG, (void *)&amp;v, sizeof(v));

       The set of enabled features is global.  In other words, <b>setsockopt</b>(<u>MRT_API_CONFIG</u>) should be called right
       after <b>setsockopt</b>(<u>MRT_INIT</u>).

       Currently, the following set of new features is defined:

       #define MRT_MFC_FLAGS_DISABLE_WRONGVIF (1 &lt;&lt; 0) /* disable WRONGVIF signals */
       #define MRT_MFC_FLAGS_BORDER_VIF   (1 &lt;&lt; 1)  /* border vif              */
       #define MRT_MFC_RP                 (1 &lt;&lt; 8)  /* enable RP address       */
       #define MRT_MFC_BW_UPCALL          (1 &lt;&lt; 9)  /* enable bw upcalls       */

       The  advanced multicast API uses a newly defined <u>struct</u> <u>mfcctl2</u> instead of the traditional <u>struct</u> <u>mfcctl</u>.
       The original <u>struct</u> <u>mfcctl</u> is kept as is.  The new <u>struct</u> <u>mfcctl2</u> is:

       /*
        * The new argument structure for MRT_ADD_MFC and MRT_DEL_MFC overlays
        * and extends the old struct mfcctl.
        */
       struct mfcctl2 {
               /* the mfcctl fields */
               struct in_addr  mfcc_origin;       /* ip origin of mcasts       */
               struct in_addr  mfcc_mcastgrp;     /* multicast group associated*/
               vifi_t          mfcc_parent;       /* incoming vif              */
               u_char          mfcc_ttls[MAXVIFS];/* forwarding ttls on vifs   */

               /* extension fields */
               uint8_t         mfcc_flags[MAXVIFS];/* the MRT_MFC_FLAGS_* flags*/
               struct in_addr  mfcc_rp;            /* the RP address           */
       };

       The new fields are <u>mfcc_flags[MAXVIFS]</u> and <u>mfcc_rp</u>.  Note that for compatibility reasons they  are  added
       at the end.

       The <u>mfcc_flags[MAXVIFS]</u> field is used to set various flags per interface per (S,G) entry.  Currently, the
       defined flags are:

       #define MRT_MFC_FLAGS_DISABLE_WRONGVIF (1 &lt;&lt; 0) /* disable WRONGVIF signals */
       #define MRT_MFC_FLAGS_BORDER_VIF       (1 &lt;&lt; 1) /* border vif          */

       The  MRT_MFC_FLAGS_DISABLE_WRONGVIF flag is used to explicitly disable the IGMPMSG_WRONGVIF kernel signal
       at the (S,G) granularity if a multicast data packet arrives on the wrong interface.  Usually, this signal
       is used to complete the shortest-path switch in case of PIM-SM multicast routing, or  to  trigger  a  PIM
       assert  message.   However,  it  should  not  be  delivered  for  interfaces that are not in the outgoing
       interface  set,  and  that  are  not  expecting  to  become  an  incoming  interface.   Hence,   if   the
       MRT_MFC_FLAGS_DISABLE_WRONGVIF flag is set for some of the interfaces, then a data packet that arrives on
       that  interface  for  that MFC entry will NOT trigger a WRONGVIF signal.  If that flag is not set, then a
       signal is triggered (the default action).

       The MRT_MFC_FLAGS_BORDER_VIF flag is used to specify whether the  Border-bit  in  PIM  Register  messages
       should be set (in case when the Register encapsulation is performed inside the kernel).  If it is set for
       the  special  PIM Register kernel virtual interface (see <u><a href="../man4/pim.4.html">pim</a></u>(4)), the Border-bit in the Register messages
       sent to the RP will be set.

       The remaining six bits are reserved for future usage.

       The <u>mfcc_rp</u> field is used to specify the RP address (in case of PIM-SM multicast routing) for a multicast
       group G if we want to perform kernel-level PIM Register encapsulation.  The <u>mfcc_rp</u> field is used only if
       the MRT_MFC_RP advanced API flag/capability has been successfully set by <b>setsockopt</b>(<u>MRT_API_CONFIG</u>).

       If the MRT_MFC_RP flag was successfully set by <b>setsockopt</b>(<u>MRT_API_CONFIG</u>), then the kernel  will  attempt
       to  perform  the  PIM Register encapsulation itself instead of sending the multicast data packets to user
       level (inside IGMPMSG_WHOLEPKT upcalls) for user-level encapsulation.  The RP address would be taken from
       the <u>mfcc_rp</u> field inside the new <u>struct</u> <u>mfcctl2</u>.  However, even if the MRT_MFC_RP flag  was  successfully
       set,  if  the <u>mfcc_rp</u> field was set to INADDR_ANY, then the kernel will still deliver an IGMPMSG_WHOLEPKT
       upcall with the multicast data packet to the user-level process.

       In addition, if the multicast data packet is too large to fit within a single IP  packet  after  the  PIM
       Register  encapsulation  (e.g.,  if  its  size  was on the order of 65500 bytes), the data packet will be
       fragmented, and then each of the fragments will  be  encapsulated  separately.   Note  that  typically  a
       multicast  data  packet  can  be  that  large  only if it was originated locally from the same hosts that
       performs the encapsulation; otherwise the transmission of the multicast data  packet  over  Ethernet  for
       example would have fragmented it into much smaller pieces.

       Typically,  a  multicast  routing user-level process would need to know the forwarding bandwidth for some
       data flow.  For example, the multicast routing process may want to timeout idle MFC entries, or  in  case
       of  PIM-SM  it  can  initiate  (S,G)  shortest-path switch if the bandwidth rate is above a threshold for
       example.

       The original solution for measuring the bandwidth of a dataflow  was  that  a  user-level  process  would
       periodically  query  the  kernel about the number of forwarded packets/bytes per (S,G), and then based on
       those numbers it would estimate whether a source has been idle,  or  whether  the  source's  transmission
       bandwidth  is  above  a  threshold.   That  solution is far from being scalable, hence the need for a new
       mechanism for bandwidth monitoring.

       Below is a description of the bandwidth monitoring mechanism.

       <b>•</b>   If the bandwidth of a data flow satisfies some pre-defined filter, the kernel delivers an  upcall  on
           the multicast routing socket to the multicast routing process that has installed that filter.

       <b>•</b>   The bandwidth-upcall filters are installed per (S,G).  There can be more than one filter per (S,G).

       <b>•</b>   Instead  of  supporting all possible comparison operations (i.e., &lt; &lt;= == != &gt; &gt;= ), there is support
           only for the &lt;= and &gt;= operations, because this makes the kernel-level  implementation  simpler,  and
           because  practically  we  need  only  those two.  Further, the missing operations can be simulated by
           secondary user-level filtering of those &lt;= and &gt;= filters.  For example, to simulate !=, then we need
           to install filter “bw &lt;= 0xffffffff”, and after an upcall is  received,  we  need  to  check  whether
           “measured_bw != expected_bw”.

       <b>•</b>   The  bandwidth-upcall  mechanism  is  enabled by <b>setsockopt</b>(<u>MRT_API_CONFIG</u>) for the MRT_MFC_BW_UPCALL
           flag.

       <b>•</b>   The  bandwidth-upcall  filters  are  added/deleted  by  the  new  <b>setsockopt</b>(<u>MRT_ADD_BW_UPCALL</u>)   and
           <b>setsockopt</b>(<u>MRT_DEL_BW_UPCALL</u>)  respectively  (with  the  appropriate  <u>struct</u>  <u>bw_upcall</u>  argument  of
           course).

       From application point of view, a developer needs to know about the following:

       /*
        * Structure for installing or delivering an upcall if the
        * measured bandwidth is above or below a threshold.
        *
        * User programs (e.g. daemons) may have a need to know when the
        * bandwidth used by some data flow is above or below some threshold.
        * This interface allows the userland to specify the threshold (in
        * bytes and/or packets) and the measurement interval. Flows are
        * all packet with the same source and destination IP address.
        * At the moment the code is only used for multicast destinations
        * but there is nothing that prevents its use for unicast.
        *
        * The measurement interval cannot be shorter than some Tmin (currently, 3s).
        * The threshold is set in packets and/or bytes per_interval.
        *
        * Measurement works as follows:
        *
        * For &gt;= measurements:
        * The first packet marks the start of a measurement interval.
        * During an interval we count packets and bytes, and when we
        * pass the threshold we deliver an upcall and we are done.
        * The first packet after the end of the interval resets the
        * count and restarts the measurement.
        *
        * For &lt;= measurement:
        * We start a timer to fire at the end of the interval, and
        * then for each incoming packet we count packets and bytes.
        * When the timer fires, we compare the value with the threshold,
        * schedule an upcall if we are below, and restart the measurement
        * (reschedule timer and zero counters).
        */

       struct bw_data {
               struct timeval  b_time;
               uint64_t        b_packets;
               uint64_t        b_bytes;
       };

       struct bw_upcall {
               struct in_addr  bu_src;         /* source address            */
               struct in_addr  bu_dst;         /* destination address       */
               uint32_t        bu_flags;       /* misc flags (see below)    */
       #define BW_UPCALL_UNIT_PACKETS (1 &lt;&lt; 0) /* threshold (in packets)    */
       #define BW_UPCALL_UNIT_BYTES   (1 &lt;&lt; 1) /* threshold (in bytes)      */
       #define BW_UPCALL_GEQ          (1 &lt;&lt; 2) /* upcall if bw &gt;= threshold */
       #define BW_UPCALL_LEQ          (1 &lt;&lt; 3) /* upcall if bw &lt;= threshold */
       #define BW_UPCALL_DELETE_ALL   (1 &lt;&lt; 4) /* delete all upcalls for s,d*/
               struct bw_data  bu_threshold;   /* the bw threshold          */
               struct bw_data  bu_measured;    /* the measured bw           */
       };

       /* max. number of upcalls to deliver together */
       #define BW_UPCALLS_MAX                          128
       /* min. threshold time interval for bandwidth measurement */
       #define BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC    3
       #define BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC   0

       The   <u>bw_upcall</u>   structure   is   used   as   an   argument   to    <b>setsockopt</b>(<u>MRT_ADD_BW_UPCALL</u>)    and
       <b>setsockopt</b>(<u>MRT_DEL_BW_UPCALL</u>).   Each  <b>setsockopt</b>(<u>MRT_ADD_BW_UPCALL</u>)  installs a filter in the kernel for
       the source and destination address in the <u>bw_upcall</u> argument, and that  filter  will  trigger  an  upcall
       according to the following pseudo-algorithm:

        if (bw_upcall_oper IS "&gt;=") {
           if (((bw_upcall_unit &amp; PACKETS == PACKETS) &amp;&amp;
                (measured_packets &gt;= threshold_packets)) ||
               ((bw_upcall_unit &amp; BYTES == BYTES) &amp;&amp;
                (measured_bytes &gt;= threshold_bytes)))
              SEND_UPCALL("measured bandwidth is &gt;= threshold");
         }
         if (bw_upcall_oper IS "&lt;=" &amp;&amp; measured_interval &gt;= threshold_interval) {
           if (((bw_upcall_unit &amp; PACKETS == PACKETS) &amp;&amp;
                (measured_packets &lt;= threshold_packets)) ||
               ((bw_upcall_unit &amp; BYTES == BYTES) &amp;&amp;
                (measured_bytes &lt;= threshold_bytes)))
              SEND_UPCALL("measured bandwidth is &lt;= threshold");
         }

       In  the  same  <u>bw_upcall</u>  the  unit can be specified in both BYTES and PACKETS.  However, the GEQ and LEQ
       flags are mutually exclusive.

       Basically, an upcall is delivered if the measured bandwidth is &gt;= or &lt;= the threshold  bandwidth  (within
       the  specified  measurement  interval).   For  practical  reasons, the smallest value for the measurement
       interval is 3 seconds.  If smaller values  are  allowed,  then  the  bandwidth  estimation  may  be  less
       accurate,  or  the  potentially  very  high  frequency  of  the  generated upcalls may introduce too much
       overhead.  For the &gt;= operation, the answer may be known before the end of <u>threshold_interval</u>,  therefore
       the  upcall  may  be  delivered  earlier.  For the &lt;= operation however, we must wait until the threshold
       interval has expired to know the answer.

       Example of usage:

       struct bw_upcall bw_upcall;
       /* Assign all bw_upcall fields as appropriate */
       memset(&amp;bw_upcall, 0, sizeof(bw_upcall));
       memcpy(&amp;bw_upcall.bu_src, &amp;source, sizeof(bw_upcall.bu_src));
       memcpy(&amp;bw_upcall.bu_dst, &amp;group, sizeof(bw_upcall.bu_dst));
       bw_upcall.bu_threshold.b_data = threshold_interval;
       bw_upcall.bu_threshold.b_packets = threshold_packets;
       bw_upcall.bu_threshold.b_bytes = threshold_bytes;
       if (is_threshold_in_packets)
           bw_upcall.bu_flags |= BW_UPCALL_UNIT_PACKETS;
       if (is_threshold_in_bytes)
           bw_upcall.bu_flags |= BW_UPCALL_UNIT_BYTES;
       do {
           if (is_geq_upcall) {
               bw_upcall.bu_flags |= BW_UPCALL_GEQ;
               break;
           }
           if (is_leq_upcall) {
               bw_upcall.bu_flags |= BW_UPCALL_LEQ;
               break;
           }
           return (ERROR);
       } while (0);
       setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_BW_UPCALL,
                 (void *)&amp;bw_upcall, sizeof(bw_upcall));

       To delete a single filter, then use MRT_DEL_BW_UPCALL, and the fields of bw_upcall must  be  set  exactly
       same as when MRT_ADD_BW_UPCALL was called.

       To  delete  all  bandwidth  filters  for  a given (S,G), then only the <u>bu_src</u> and <u>bu_dst</u> fields in <u>struct</u>
       <u>bw_upcall</u>  need  to  be  set,  and  then  just  set  only  the  BW_UPCALL_DELETE_ALL  flag  inside  field
       <u>bw_upcall.bu_flags</u>.

       The bandwidth upcalls are received by aggregating them in the new upcall message:

       #define IGMPMSG_BW_UPCALL  4  /* BW monitoring upcall */

       This  message  is  an  array  of <u>struct</u> <u>bw_upcall</u> elements (up to BW_UPCALLS_MAX = 128).  The upcalls are
       delivered when there are 128 pending upcalls, or when 1 second has  expired  since  the  previous  upcall
       (whichever comes first).  In an <u>struct</u> <u>upcall</u> element, the <u>bu_measured</u> field is filled-in to indicate the
       particular  measured values.  However, because of the way the particular intervals are measured, the user
       should be careful how <u>bu_measured.b_time</u> is used.  For example, if the filter is installed to trigger  an
       upcall  if  the number of packets is &gt;= 1, then <u>bu_measured</u> may have a value of zero in the upcalls after
       the first one, because the measured interval for &gt;=  filters  is  “clocked”  by  the  forwarded  packets.
       Hence,  this  upcall  mechanism  should not be used for measuring the exact value of the bandwidth of the
       forwarded data.  To measure the exact bandwidth, the  user  would  need  to  get  the  forwarded  packets
       statistics with the <b>ioctl</b>(<u>SIOCGETSGCNT</u>) mechanism (see the “Programming Guide” section) .

       Note  that  the  upcalls  for  a  filter  are delivered until the specific filter is deleted, but no more
       frequently than once per <u>bu_threshold.b_time</u>.  For example, if the  filter  is  specified  to  deliver  a
       signal  if  bw &gt;= 1 packet, the first packet will trigger a signal, but the next upcall will be triggered
       no earlier than <u>bu_threshold.b_time</u> after the previous upcall.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2), <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2), <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2), <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2), <u><a href="../man2/socket.2.html">socket</a></u>(2), <u><a href="../man3/sourcefilter.3.html">sourcefilter</a></u>(3), <u><a href="../man4/altq.4.html">altq</a></u>(4),  <u><a href="../man4/dummynet.4.html">dummynet</a></u>(4),
       <u><a href="../man4/gif.4.html">gif</a></u>(4), <u><a href="../man4/gre.4.html">gre</a></u>(4), <u><a href="../man4/icmp6.4.html">icmp6</a></u>(4), <u><a href="../man4/igmp.4.html">igmp</a></u>(4), <u><a href="../man4/inet.4.html">inet</a></u>(4), <u><a href="../man4/inet6.4.html">inet6</a></u>(4), <u><a href="../man4/intro.4.html">intro</a></u>(4), <u><a href="../man4/ip.4.html">ip</a></u>(4), <u><a href="../man4/ip6.4.html">ip6</a></u>(4), <u><a href="../man4/mld.4.html">mld</a></u>(4), <u><a href="../man4/pim.4.html">pim</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The  Distance  Vector  Multicast  Routing  Protocol  (DVMRP)  was  the  first developed multicast routing
       protocol.  Later, other protocols such as Multicast Extensions to  OSPF  (MOSPF)  and  Core  Based  Trees
       (CBT), were developed as well.  Routers at autonomous system boundaries may now exchange multicast routes
       with  peers via the Border Gateway Protocol (BGP).  Many other routing protocols are able to redistribute
       multicast routes for use with PIM-SM and PIM-DM.

</pre><h4><b>AUTHORS</b></h4><pre>
       The original multicast code was written by David Waitzman (BBN Labs), and later modified by the following
       individuals: Steve Deering (Stanford), Mark J. Steiglitz (Stanford), Van Jacobson (LBL), Ajit Thyagarajan
       (PARC),  Bill  Fenner  (PARC).   The  IPv6  multicast  support  was  implemented  by  the  KAME   project
       (<u><a href="http://www.kame.net">http://www.kame.net</a></u>),  and  was  based  on  the IPv4 multicast code.  The advanced multicast API and the
       multicast bandwidth monitoring were implemented by Pavlin Radoslavov (ICSI) in collaboration  with  Chris
       Brown (NextHop).  The IGMPv3 and MLDv2 multicast support was implemented by Bruce Simpson.

       This manual page was written by Pavlin Radoslavov (ICSI).

Debian                                            May 27, 2009                                      <u><a href="../man4/MULTICAST.4.html">MULTICAST</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>