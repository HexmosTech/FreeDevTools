<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tty — general terminal interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tty — general terminal interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/ioctl.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This section describes the interface to the terminal drivers in the system.

   <b>Terminal</b> <b>Special</b> <b>Files</b>
       Each  hardware  terminal port on the system usually has a terminal special device file associated with it
       in the directory ``<a href="file:/dev/">/dev/</a>'' (for example, ``/dev/tty03'').  When a user logs into the  system  on  one  of
       these  hardware terminal ports, the system has already opened the associated device and prepared the line
       for normal interactive use (see <u><a href="../man8/getty.8.html">getty</a></u>(8).)  There is also a special case of a terminal file that connects
       not to a hardware terminal port, but to another program  on  the  other  side.   These  special  terminal
       devices  are  called  <u>ptys</u>  and  provide  the mechanism necessary to give users the same interface to the
       system when logging in over a network (using <u><a href="../man1/telnet.1.html">telnet</a></u>(1) for example).  Even in these cases the details  of
       how  the terminal file was opened and set up is already handled by special software in the system.  Thus,
       users do not normally need to worry about the details of how these lines are opened or used.  Also, these
       lines are often used for dialing out of a system (through an out-calling modem),  but  again  the  system
       provides programs that hide the details of accessing these terminal special files (see <u><a href="../man1/tip.1.html">tip</a></u>(1)).

       When  an interactive user logs in, the system prepares the line to behave in a certain way (called a <u>line</u>
       <u>discipline</u>), the particular details of which is described  in  <u><a href="../man1/stty.1.html">stty</a></u>(1)  at  the  command  level,  and  in
       <u><a href="../man4/termios.4.html">termios</a></u>(4)  at the programming level.  A user may be concerned with changing settings associated with his
       particular login terminal and should refer to  the  preceding  man  pages  for  the  common  cases.   The
       remainder of this man page is concerned with describing details of using and controlling terminal devices
       at  a low level, such as that possibly required by a program wishing to provide features similar to those
       provided by the system.

   <b>Terminal</b> <b>File</b> <b>Operations</b>
       All of the following operations are invoked using the <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) system call.  Refer to that man page for a
       description of the <u>request</u> and <u>argp</u> parameters.  In addition to the  ioctl  <u>requests</u>  defined  here,  the
       specific line discipline in effect will define other <u>requests</u> specific to it (actually <u><a href="../man4/termios.4.html">termios</a></u>(4) defines
       them  as  function calls, not ioctl <u>requests</u>.)  The following section lists the available ioctl requests.
       The name of the request, a description of its purpose, and the typed <u>argp</u> parameter (if any) are  listed.
       For example, the first entry says

             <u>TIOCSPGRP</u> <u>int</u> <u>*tpgrp</u>

       and would be called on the terminal associated with file descriptor zero by the following code fragment:

               int pgrp;

               pgrp = getpgrp();
               ioctl(0, TIOCSPGRP, &amp;pgrp);

   <b>Terminal</b> <b>File</b> <b>Request</b> <b>Descriptions</b>
       TIOCSETD <u>int</u> <u>*ldisc</u>
                   This call is obsolete but left for compatibility.  Before FreeBSD 8.0, it would change to the
                   new line discipline pointed to by <u>ldisc</u>.

       TIOCGETD <u>int</u> <u>*ldisc</u>
                   Return the current line discipline in the integer pointed to by <u>ldisc</u>.

       TIOCSBRK <u>void</u>
                   Set the terminal hardware into BREAK condition.

       TIOCCBRK <u>void</u>
                   Clear the terminal hardware BREAK condition.

       TIOCSDTR <u>void</u>
                   Assert data terminal ready (DTR).

       TIOCCDTR <u>void</u>
                   Clear data terminal ready (DTR).

       TIOCGPGRP <u>int</u> <u>*tpgrp</u>
                   Return the current process group with which the terminal is associated in the integer pointed
                   to by <u>tpgrp</u>.  This is the underlying call that implements the <u><a href="../man4/termios.4.html">termios</a></u>(4) <b>tcgetattr</b>() call.

       TIOCSPGRP <u>int</u> <u>*tpgrp</u>
                   Associate  the  terminal with the process group (as an integer) pointed to by <u>tpgrp</u>.  This is
                   the underlying call that implements the <u><a href="../man4/termios.4.html">termios</a></u>(4) <b>tcsetattr</b>() call.

       TIOCGETA <u>struct</u> <u>termios</u> <u>*term</u>
                   Place the current value of the termios state  associated  with  the  device  in  the  termios
                   structure  pointed  to  by  <u>term</u>.  This is the underlying call that implements the <u><a href="../man4/termios.4.html">termios</a></u>(4)
                   <b>tcgetattr</b>() call.

       TIOCSETA <u>struct</u> <u>termios</u> <u>*term</u>
                   Set the termios state associated with the device immediately.  This is  the  underlying  call
                   that implements the <u><a href="../man4/termios.4.html">termios</a></u>(4) <b>tcsetattr</b>() call with the TCSANOW option.

       TIOCSETAW <u>struct</u> <u>termios</u> <u>*term</u>
                   First wait for any output to complete, then set the termios state associated with the device.
                   This  is  the  underlying  call  that  implements  the  <u><a href="../man4/termios.4.html">termios</a></u>(4)  <b>tcsetattr</b>() call with the
                   TCSADRAIN option.

       TIOCSETAF <u>struct</u> <u>termios</u> <u>*term</u>
                   First wait for any output to complete, clear any pending input, then set  the  termios  state
                   associated  with  the  device.   This  is  the underlying call that implements the <u><a href="../man4/termios.4.html">termios</a></u>(4)
                   <b>tcsetattr</b>() call with the TCSAFLUSH option.

       TIOCOUTQ <u>int</u> <u>*num</u>
                   Place the current number of characters in the output queue in the integer pointed to by <u>num</u>.

       TIOCSTI <u>char</u> <u>*cp</u>
                   Simulate typed input.  Pretend as if the terminal received the character pointed to by <u>cp</u>.

       TIOCNOTTY <u>void</u>
                   In the past, when a process that did not have a controlling  terminal  (see  <u>The</u>  <u>Controlling</u>
                   <u>Terminal</u>  in  <u><a href="../man4/termios.4.html">termios</a></u>(4))  first  opened  a terminal device, it acquired that terminal as its
                   controlling terminal.  For some programs this was a hazard as they did not want a controlling
                   terminal in the first place, and this provides a mechanism to  disassociate  the  controlling
                   terminal  from  the  calling  process.   It  <u>must</u>  be called by opening the file <u>/dev/tty</u> and
                   calling TIOCNOTTY on that file descriptor.

                   The current system does not allocate a controlling terminal to a process on an  <b>open</b>()  call:
                   there  is  a specific ioctl called TIOCSCTTY to make a terminal the controlling terminal.  In
                   addition, a program can <b>fork</b>() and call the <b>setsid</b>() system call which will place the process
                   into its own session - which has  the  effect  of  disassociating  it  from  the  controlling
                   terminal.   This  is  the  new  and  preferred  method for programs to lose their controlling
                   terminal.

                   However, environmental restrictions may prohibit the process from being able  to  <b>fork</b>()  and
                   call  the  <b>setsid</b>()  system  call  to disassociate it from the controlling terminal.  In this
                   case, it must use TIOCNOTTY.

       TIOCSTOP <u>void</u>
                   Stop output on the terminal (like typing ^S at the keyboard).

       TIOCSTART <u>void</u>
                   Start output on the terminal (like typing ^Q at the keyboard).

       TIOCSCTTY <u>void</u>
                   Make the terminal the controlling terminal for the process (the process  must  not  currently
                   have a controlling terminal).

       TIOCDRAIN <u>void</u>
                   Wait until all output is drained, or until the drain wait timeout expires.

       TIOCGDRAINWAIT <u>int</u> <u>*timeout</u>
                   Return the current drain wait timeout in seconds.

       TIOCSDRAINWAIT <u>int</u> <u>*timeout</u>
                   Set the drain wait timeout in seconds.  A value of zero disables timeouts.  The default drain
                   wait timeout is controlled by the tunable <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) OID <u>kern.tty_drainwait</u>.

       TIOCEXCL <u>void</u>
                   Set  exclusive  use  on  the  terminal.   No  further opens are permitted except by root.  Of
                   course, this means that programs that are run by root (or setuid) will not obey the exclusive
                   setting - which limits the usefulness of this feature.

       TIOCNXCL <u>void</u>
                   Clear exclusive use of the terminal.  Further opens are permitted.

       TIOCFLUSH <u>int</u> <u>*what</u>
                   If the value of the int pointed to by <u>what</u> contains the FREAD bit as defined in &lt;<u>sys/file.h</u>&gt;,
                   then all characters in the input queue are cleared.  If it contains the FWRITE bit, then  all
                   characters  in  the  output  queue are cleared.  If the value of the integer is zero, then it
                   behaves as if both the FREAD and FWRITE bits were set (i.e., clears both queues).

       TIOCGWINSZ <u>struct</u> <u>winsize</u> <u>*ws</u>
                   Put the window size information associated with the terminal in the <u>winsize</u> structure pointed
                   to by <u>ws</u>.  The window size structure contains the number of rows and columns (and  pixels  if
                   appropriate)  of the devices attached to the terminal.  It is set by user software and is the
                   means by which most full-screen oriented programs determine the  screen  size.   The  <u>winsize</u>
                   structure is defined in &lt;<u>sys/ioctl.h</u>&gt;.

       TIOCSWINSZ <u>struct</u> <u>winsize</u> <u>*ws</u>
                   Set  the  window  size  associated with the terminal to be the value in the <u>winsize</u> structure
                   pointed to by <u>ws</u> (see above).

       TIOCCONS <u>int</u> <u>*on</u>
                   If <u>on</u> points to a non-zero integer, redirect kernel console output (kernel printf's) to  this
                   terminal.   If <u>on</u> points to a zero integer, redirect kernel console output back to the normal
                   console.  This is usually used on workstations to redirect kernel messages  to  a  particular
                   window.

       TIOCMSET <u>int</u> <u>*state</u>
                   The integer pointed to by <u>state</u> contains bits that correspond to modem state.  Following is a
                   list of defined variables and the modem state they represent:

                   TIOCM_LE   Line Enable.
                   TIOCM_DTR  Data Terminal Ready.
                   TIOCM_RTS  Request To Send.
                   TIOCM_ST   Secondary Transmit.
                   TIOCM_SR   Secondary Receive.
                   TIOCM_CTS  Clear To Send.
                   TIOCM_CAR  Carrier Detect.
                   TIOCM_CD   Carrier Detect (synonym).
                   TIOCM_RNG  Ring Indication.
                   TIOCM_RI   Ring Indication (synonym).
                   TIOCM_DSR  Data Set Ready.

                   This  call sets the terminal modem state to that represented by <u>state</u>.  Not all terminals may
                   support this.

       TIOCMGET <u>int</u> <u>*state</u>
                   Return the current state of the terminal modem lines as  represented  above  in  the  integer
                   pointed to by <u>state</u>.

       TIOCMBIS <u>int</u> <u>*state</u>
                   The bits in the integer pointed to by <u>state</u> represent modem state as described above, however
                   the state is OR-ed in with the current state.

       TIOCMBIC <u>int</u> <u>*state</u>
                   The bits in the integer pointed to by <u>state</u> represent modem state as described above, however
                   each bit which is on in <u>state</u> is cleared in the terminal.

</pre><h4><b>IMPLEMENTATION</b> <b>NOTES</b></h4><pre>
       The  total  number  of  input  and  output  bytes  through  all  terminal  devices  are available via the
       <u>kern.tty_nin</u> and <u>kern.tty_nout</u> read-only <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) variables.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/stty.1.html">stty</a></u>(1), <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man4/ng_tty.4.html">ng_tty</a></u>(4), <u><a href="../man4/pty.4.html">pty</a></u>(4), <u><a href="../man4/termios.4.html">termios</a></u>(4), <u><a href="../man8/getty.8.html">getty</a></u>(8)

Debian                                          November 27, 2019                                         <u><a href="../man4/TTY.4.html">TTY</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>