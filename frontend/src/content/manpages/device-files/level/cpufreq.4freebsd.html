<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cpufreq — CPU frequency control framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cpufreq — CPU frequency control framework

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>cpufreq</b>

       <b>#include</b> <b>&lt;sys/cpu.h&gt;</b>

       <u>int</u>
       <b>cpufreq_levels</b>(<u>device_t</u> <u>dev</u>, <u>struct</u> <u>cf_level</u> <u>*levels</u>, <u>int</u> <u>*count</u>);

       <u>int</u>
       <b>cpufreq_set</b>(<u>device_t</u> <u>dev</u>, <u>const</u> <u>struct</u> <u>cf_level</u> <u>*level</u>, <u>int</u> <u>priority</u>);

       <u>int</u>
       <b>cpufreq_get</b>(<u>device_t</u> <u>dev</u>, <u>struct</u> <u>cf_level</u> <u>*level</u>);

       <u>int</u>
       <b>cpufreq_drv_settings</b>(<u>device_t</u> <u>dev</u>, <u>struct</u> <u>cf_setting</u> <u>*sets</u>, <u>int</u> <u>*count</u>);

       <u>int</u>
       <b>cpufreq_drv_type</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>*type</u>);

       <u>int</u>
       <b>cpufreq_drv_set</b>(<u>device_t</u> <u>dev</u>, <u>const</u> <u>struct</u> <u>cf_setting</u> <u>*set</u>);

       <u>int</u>
       <b>cpufreq_drv_get</b>(<u>device_t</u> <u>dev</u>, <u>struct</u> <u>cf_setting</u> <u>*set</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>cpufreq</b>  driver  provides  a unified kernel and user interface to CPU frequency control drivers.  It
       combines multiple drivers offering different settings into a single interface  of  all  possible  levels.
       Users  can  access this interface directly via <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) or by indicating to <u>/etc/rc.d/power_profile</u> that
       it should switch settings when the AC line state changes via <u><a href="../man5/rc.conf.5.html">rc.conf</a></u>(5).

</pre><h4><b>SYSCTL</b> <b>VARIABLES</b></h4><pre>
       These settings may be overridden by kernel drivers requesting alternate settings.  If  this  occurs,  the
       original  values  will  be  restored  once  the  condition  has  passed  (e.g.,  the  system  has  cooled
       sufficiently).  If a sysctl cannot be set due to an override condition, it will return EPERM.

       The frequency cannot be changed if TSC is in use as the timecounter.  This  is  because  the  timecounter
       system  needs  to  use a source that has a constant rate.  The timecounter source can be changed with the
       <u>kern.timecounter.hardware</u> sysctl.  Available modes are in <u>kern.timecounter.choice</u> sysctl entry.

       <u>dev.cpu.%d.freq</u>
               Current active CPU frequency in MHz.

       <u>dev.cpu.%d.freq_levels</u>
               Currently available levels for the CPU (frequency/power usage).  Values are in units of  MHz  and
               milliwatts.

       <u>dev.DEVICE.%d.freq_settings</u>
               Currently  available settings for the driver (frequency/power usage).  Values are in units of MHz
               and milliwatts.  This is helpful for understanding which settings are offered by which driver for
               debugging purposes.

       <u>debug.cpufreq.lowest</u>
               Lowest CPU frequency in MHz to offer to users.  This setting is also  accessible  via  a  tunable
               with  the  same  name.   This can be used to disable very low levels that may be unusable on some
               systems.

       <u>debug.cpufreq.verbose</u>
               Print verbose messages.  This setting is also accessible via a tunable with the same name.

</pre><h4><b>SUPPORTED</b> <b>DRIVERS</b></h4><pre>
       The following device drivers offer absolute frequency control via the <b>cpufreq</b> interface.   Usually,  only
       one of these can be active at a time.

       <u>acpi_perf</u>  ACPI CPU performance states
       <u>est</u>        Intel Enhanced SpeedStep
       <u>ichss</u>      Intel SpeedStep for ICH
       <u>powernow</u>   AMD PowerNow! and Cool'n'Quiet for K7 and K8
       <u>smist</u>      Intel SMI-based SpeedStep for PIIX4

       The following device drivers offer relative frequency control and have an additive effect:

       <u>acpi_throttle</u>  ACPI CPU throttling
       <u>p4tcc</u>          Pentium 4 Thermal Control Circuitry

</pre><h4><b>KERNEL</b> <b>INTERFACE</b></h4><pre>
       Kernel  components can query and set CPU frequencies through the <b>cpufreq</b> kernel interface.  This involves
       obtaining a <b>cpufreq</b> device, calling <b>cpufreq_levels</b>() to get the  currently  available  frequency  levels,
       checking  the  current  level with <b>cpufreq_get</b>(), and setting a new one from the list with <b>cpufreq_set</b>().
       Each level may actually reference more than one <b>cpufreq</b> driver but kernel components do not  need  to  be
       aware  of  this.   The <u>total_set</u> element of <u>struct</u> <u>cf_level</u> provides a summary of the frequency and power
       for this level.  Unknown or irrelevant values are set to CPUFREQ_VAL_UNKNOWN.

       The <b>cpufreq_levels</b>() method takes a <b>cpufreq</b> device and an empty array of <u>levels</u>.  The <u>count</u> value  should
       be  set  to  the  number  of levels available and after the function completes, will be set to the actual
       number of levels returned.  If there are more levels than <u>count</u> will allow, it should return E2BIG.

       The <b>cpufreq_get</b>() method takes a pointer to space to store a <u>level</u>.   After  successful  completion,  the
       output will be the current active level and is equal to one of the levels returned by <b>cpufreq_levels</b>().

       The  <b>cpufreq_set</b>()  method  takes  a  pointer  a  <u>level</u> and attempts to activate it.  The <u>priority</u> (i.e.,
       CPUFREQ_PRIO_KERN) tells <b>cpufreq</b> whether to override previous settings while activating this  level.   If
       <u>priority</u>  is  higher  than the current active level, that level will be saved and overridden with the new
       level.  If a level is already saved, the new level is set without overwriting the older saved level.   If
       <b>cpufreq_set</b>() is called with a NULL <u>level</u>, the saved level will be restored.  If there is no saved level,
       <b>cpufreq_set</b>()  will  return  ENXIO.   If <u>priority</u> is lower than the current active level's priority, this
       method returns EPERM.

</pre><h4><b>DRIVER</b> <b>INTERFACE</b></h4><pre>
       Kernel drivers offering hardware-specific CPU frequency control export their individual settings  through
       the  <b>cpufreq</b>  driver  interface.   This  involves  implementing  these  methods:  <b>cpufreq_drv_settings</b>(),
       <b>cpufreq_drv_type</b>(), <b>cpufreq_drv_set</b>(), and <b>cpufreq_drv_get</b>().  Additionally, the  driver  must  attach  a
       device as a child of a CPU device so that these methods can be called by the <b>cpufreq</b> framework.

       The  <b>cpufreq_drv_settings</b>()  method returns an array of currently available settings, each of type <u>struct</u>
       <u>cf_setting</u>.  The driver should  set  unknown  or  irrelevant  values  to  CPUFREQ_VAL_UNKNOWN.   All  the
       following elements for each setting should be returned:

       struct cf_setting {
               int     freq;   /* CPU clock in MHz or 100ths of a percent. */
               int     volts;  /* Voltage in mV. */
               int     power;  /* Power consumed in mW. */
               int     lat;    /* Transition latency in us. */
               device_t dev;   /* Driver providing this setting. */
       };

       On  entry  to  this  method,  <u>count</u>  contains the number of settings that can be returned.  On successful
       completion, the driver sets it to the actual number of settings returned.   If  the  driver  offers  more
       settings than <u>count</u> will allow, it should return E2BIG.

       The  <b>cpufreq_drv_type</b>()  method indicates the type of settings it offers, either CPUFREQ_TYPE_ABSOLUTE or
       CPUFREQ_TYPE_RELATIVE.  Additionally, the driver may set the CPUFREQ_FLAG_INFO_ONLY flag if the  settings
       it  provides are information for other drivers only and cannot be passed to <b>cpufreq_drv_set</b>() to activate
       them.

       The <b>cpufreq_drv_set</b>() method takes a driver setting and makes it active.  If the setting  is  invalid  or
       not currently available, it should return EINVAL.

       The <b>cpufreq_drv_get</b>() method returns the currently-active driver setting.  The <u>struct</u> <u>cf_setting</u> returned
       must  be  valid  for passing to <b>cpufreq_drv_set</b>(), including all elements being filled out correctly.  If
       the driver cannot infer the current setting (even by estimating  it  with  <b>cpu_est_clockrate</b>())  then  it
       should set all elements to CPUFREQ_VAL_UNKNOWN.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/acpi.4.html">acpi</a></u>(4), <u><a href="../man4/est.4.html">est</a></u>(4), <u><a href="../man4/timecounters.4.html">timecounters</a></u>(4), <u><a href="../man8/powerd.8.html">powerd</a></u>(8), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)

</pre><h4><b>AUTHORS</b></h4><pre>
       Nate Lawson
       Bruno Ducrot contributed the <u>powernow</u> driver.

</pre><h4><b>BUGS</b></h4><pre>
       The following drivers have not yet been converted to the <b>cpufreq</b> interface: <u><a href="../man4/longrun.4.html">longrun</a></u>(4).

       Notification of CPU and bus frequency changes is not implemented yet.

       When multiple CPUs offer frequency control, they cannot be set to different levels and must all offer the
       same frequency settings.

Debian                                            March 3, 2006                                       <u><a href="../man4/CPUFREQ.4.html">CPUFREQ</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>