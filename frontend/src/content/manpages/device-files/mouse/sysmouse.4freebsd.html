<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sysmouse — virtualized mouse driver</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sysmouse — virtualized mouse driver

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/mouse.h&gt;</b>
       <b>#include</b> <b>&lt;sys/consio.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  console  driver,  in  conjunction  with  the mouse daemon <u><a href="../man8/moused.8.html">moused</a></u>(8), supplies mouse data to the user
       process in the standardized way via the <b>sysmouse</b> driver.  This arrangement  makes  it  possible  for  the
       console and the user process (such as the X Window System) to share the mouse.

       The  user  process  which wants to utilize mouse operation simply opens <u>/dev/sysmouse</u> with a <u><a href="../man2/open.2.html">open</a></u>(2) call
       and reads mouse data from the device via <u><a href="../man2/read.2.html">read</a></u>(2).  Make sure that <u><a href="../man8/moused.8.html">moused</a></u>(8)  is  running,  otherwise  the
       user process will not see any data coming from the mouse.

   <b>Operation</b> <b>Levels</b>
       The  <b>sysmouse</b>  driver  has  two  levels of operation.  The current operation level can be referred to and
       changed via ioctl calls.

       The level zero, the basic level, is the lowest level at which the driver offers the basic service to user
       programs.  The <b>sysmouse</b> driver provides horizontal and vertical movement of the mouse and state of up  to
       three buttons in the MouseSystems format as follows.

       Byte 1
               bit 7  Always one.
               bit 6..3
                      Always zero.
               bit 2  Left button status; cleared if pressed, otherwise set.
               bit 1  Middle  button  status; cleared if pressed, otherwise set.  Always one, if the device does
                      not have the middle button.
               bit 0  Right button status; cleared if pressed, otherwise set.
       Byte 2  The first half of horizontal movement count in two's complement; -128 through 127.
       Byte 3  The first half of vertical movement count in two's complement; -128 through 127.
       Byte 4  The second half of the horizontal movement count in  two's  complement;  -128  through  127.   To
               obtain the full horizontal movement count, add the byte 2 and 4.
       Byte 5  The  second half of the vertical movement count in two's complement; -128 through 127.  To obtain
               the full vertical movement count, add the byte 3 and 5.

       At the level one, the extended level, mouse data is encoded in the standard  format  MOUSE_PROTO_SYSMOUSE
       as defined in <u><a href="../man4/mouse.4.html">mouse</a></u>(4).

</pre><h4><b>IOCTLS</b></h4><pre>
       This  section  describes  two  classes of <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) commands: commands for the <b>sysmouse</b> driver itself, and
       commands for the console and the console control drivers.

   <b>Sysmouse</b> <b>Ioctls</b>
       There are a few commands for mouse drivers.  General description of the commands is  given  in  <u><a href="../man4/mouse.4.html">mouse</a></u>(4).
       Following are the features specific to the <b>sysmouse</b> driver.

       MOUSE_GETLEVEL <u>int</u> <u>*level</u>
       MOUSE_SETLEVEL <u>int</u> <u>*level</u>
              These commands manipulate the operation level of the mouse driver.

       MOUSE_GETHWINFO <u>mousehw_t</u> <u>*hw</u>
              Returns  the  hardware  information  of  the attached device in the following structure.  Only the
              <u>iftype</u> field is guaranteed to be filled with the correct value  in  the  current  version  of  the
              <b>sysmouse</b> driver.

              typedef struct mousehw {
                  int buttons;    /* number of buttons */
                  int iftype;     /* I/F type */
                  int type;       /* mouse/track ball/pad... */
                  int model;      /* I/F dependent model ID */
                  int hwid;       /* I/F dependent hardware ID */
              } mousehw_t;

              The <u>buttons</u> field holds the number of buttons detected by the driver.

              The <u>iftype</u> is always MOUSE_IF_SYSMOUSE.

              The  <u>type</u>  tells  the  device  type:  MOUSE_MOUSE,  MOUSE_TRACKBALL,  MOUSE_STICK,  MOUSE_PAD,  or
              MOUSE_UNKNOWN.

              The <u>model</u> is always MOUSE_MODEL_GENERIC at the operation level 0.  It may  be  MOUSE_MODEL_GENERIC
              or one of MOUSE_MODEL_XXX constants at higher operation levels.

              The <u>hwid</u> is always zero.

       MOUSE_GETMODE <u>mousemode_t</u> <u>*mode</u>
              The command gets the current operation parameters of the mouse driver.

              typedef struct mousemode {
                  int protocol;    /* MOUSE_PROTO_XXX */
                  int rate;        /* report rate (per sec) */
                  int resolution;  /* MOUSE_RES_XXX, -1 if unknown */
                  int accelfactor; /* acceleration factor */
                  int level;       /* driver operation level */
                  int packetsize;  /* the length of the data packet */
                  unsigned char syncmask[2]; /* sync. bits */
              } mousemode_t;

              The  <u>protocol</u> field tells the format in which the device status is returned when the mouse data is
              read  by  the  user   program.    It   is   MOUSE_PROTO_MSC   at   the   operation   level   zero.
              MOUSE_PROTO_SYSMOUSE at the operation level one.

              The <u>rate</u> is always set to -1.

              The <u>resolution</u> is always set to -1.

              The <u>accelfactor</u> is always 0.

              The <u>packetsize</u> field specifies the length of the data packet.  It depends on the operation level.

              <u>level</u> <u>0</u>    5 bytes
              <u>level</u> <u>1</u>    8 bytes

              The  array  <u>syncmask</u>  holds  a  bit  mask and pattern to detect the first byte of the data packet.
              <u>syncmask[0]</u> is the bit mask to be ANDed with a byte.  If the result is equal to  <u>syncmask[1]</u>,  the
              byte  is  likely  to be the first byte of the data packet.  Note that this method of detecting the
              first byte is not 100% reliable; thus, it should be taken only as an advisory measure.

       MOUSE_SETMODE <u>mousemode_t</u> <u>*mode</u>
              The command changes the current operation parameters of the mouse driver  as  specified  in  <u>mode</u>.
              Only  <u>level</u>  may be modifiable.  Setting values in the other field does not generate error and has
              no effect.

       MOUSE_READDATA <u>mousedata_t</u> <u>*data</u>
       MOUSE_READSTATE <u>mousedata_t</u> <u>*state</u>
              These commands are not supported by the <b>sysmouse</b> driver.

       MOUSE_GETSTATUS <u>mousestatus_t</u> <u>*status</u>
              The command returns the current state of buttons and movement counts in the structure  as  defined
              in <u><a href="../man4/mouse.4.html">mouse</a></u>(4).

   <b>Console</b> <b>and</b> <b>Consolectl</b> <b>Ioctls</b>
       The  user  process  issues  console  <b>ioctl</b>() calls to the current virtual console in order to control the
       mouse pointer.  The console <b>ioctl</b>() also provides a method for the user process to  receive  a  <u><a href="../man3/signal.3.html">signal</a></u>(3)
       when a button is pressed.

       The mouse daemon <u><a href="../man8/moused.8.html">moused</a></u>(8) uses <b>ioctl</b>() calls to the console control device <u>/dev/consolectl</u> to inform the
       console of mouse actions including mouse movement and button status.

       Both classes of <b>ioctl</b>() commands are defined as CONS_MOUSECTL which takes the following argument.

       struct mouse_info {
           int operation;
           union {
               struct mouse_data data;
               struct mouse_mode mode;
               struct mouse_event event;
           } u;
       };

       <u>operation</u>  This can be one of

                  MOUSE_SHOW     Enables and displays mouse cursor.
                  MOUSE_HIDE     Disables and hides mouse cursor.
                  MOUSE_MOVEABS  Moves mouse cursor to position supplied in <u>u.data</u>.
                  MOUSE_MOVEREL  Adds position supplied in <u>u.data</u> to current position.
                  MOUSE_GETINFO  Returns current mouse position in the current virtual console and button status
                                 in <u>u.data</u>.
                  MOUSE_MODE     This sets the <u><a href="../man3/signal.3.html">signal</a></u>(3) to be delivered to the current process when a button is
                                 pressed.  The signal to be delivered is set in <u>u.mode</u>.

                  The  above  operations  are  for  virtual  consoles.  The operations defined below are for the
                  console control device and are used by <u><a href="../man8/moused.8.html">moused</a></u>(8) to pass mouse data to the console driver.

                  MOUSE_ACTION
                  MOUSE_MOTION_EVENT
                                 These operations take the information in <u>u.data</u> and act upon  it.   Mouse  data
                                 will be sent to the <b>sysmouse</b> driver if it is open.  MOUSE_ACTION also processes
                                 button  press  actions and sends signal to the process if requested or performs
                                 cut and paste operations if the current console is a text interface.
                  MOUSE_BUTTON_EVENT
                                 <u>u.data</u> specifies a button and its click count.  The  console  driver  will  use
                                 this  information  for  signal  delivery  if  requested  or  for  cut and paste
                                 operations if the console is in text mode.

                  MOUSE_MOTION_EVENT and MOUSE_BUTTON_EVENT are newer interface and  are  designed  to  be  used
                  together.  They are intended to replace functions performed by MOUSE_ACTION alone.

       <u>u</u>          This union is one of

                  <u>data</u>

                        struct mouse_data {
                            int x;
                            int y;
                            int z;
                            int buttons;
                        };

                        <u>x</u>,  <u>y</u>  and <u>z</u> represent movement of the mouse along respective directions.  <u>buttons</u> tells
                        the state of buttons.  It encodes up to 31 buttons in the bit 0 though the bit 30.  If a
                        button is held down, the corresponding bit is set.

                  <u>mode</u>

                        struct mouse_mode {
                            int mode;
                            int signal;
                        };

                        The <u>signal</u> field specifies the signal to be delivered to the process.  It must be one of
                        the values defined in &lt;<u>signal.h</u>&gt;.  The <u>mode</u> field is currently unused.

                  <u>event</u>

                        struct mouse_event {
                            int id;
                            int value;
                        };

                        The <u>id</u> field specifies a button number as in <u>u.data.buttons</u>.   Only  one  bit/button  is
                        set.   The  <u>value</u>  field holds the click count: the number of times the user has clicked
                        the button successively.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/consolectl</u>  device to control the console
       <u>/dev/sysmouse</u>    virtualized mouse driver
       <u>/dev/ttyv%d</u>      virtual consoles

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/vidcontrol.1.html">vidcontrol</a></u>(1), <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man3/signal.3.html">signal</a></u>(3), <u><a href="../man4/mouse.4.html">mouse</a></u>(4), <u><a href="../man8/moused.8.html">moused</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>sysmouse</b> driver first appeared in FreeBSD 2.2.

</pre><h4><b>AUTHORS</b></h4><pre>
       This  manual  page  was   written   by   John-Mark   Gurney   &lt;<u><a href="mailto:jmg@FreeBSD.org">jmg@FreeBSD.org</a></u>&gt;   and   Kazutaka   Yokota
       &lt;<u><a href="mailto:yokota@FreeBSD.org">yokota@FreeBSD.org</a></u>&gt;.

Debian                                           March 25, 2014                                      <u><a href="../man4/SYSMOUSE.4.html">SYSMOUSE</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>