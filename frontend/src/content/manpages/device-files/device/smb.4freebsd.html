<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>smb — SMB generic I/O device driver</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       smb — SMB generic I/O device driver

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>smb</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>smb</u>  character device driver provides generic I/O to any <u><a href="../man4/smbus.4.html">smbus</a></u>(4) instance.  To control SMB devices,
       use <u>/dev/smb?</u> with the ioctls described below.  Any of these ioctl commands takes  a  pointer  to  <u>struct</u>
       <u>smbcmd</u> as its argument.

       #include &lt;sys/types.h&gt;

       struct smbcmd {
               u_char cmd;
               u_char reserved;
               u_short op;
               union {
                       char    byte;
                       char    buf[2];
                       short   word;
               } wdata;
               union {
                       char    byte;
                       char    buf[2];
                       short   word;
               } rdata;
               int  slave;
               char *wbuf;     /* use wdata if NULL */
               int  wcount;
               char *rbuf;     /* use rdata if NULL */
               int  rcount;
       };

       The <u>slave</u> field is always used, and provides the address of the SMBus slave device.  The slave address is
       specified  in the seven most significant bits (i.e., “left-justified”).  The least significant bit of the
       slave address must be zero.

       <u>Ioctl</u>              <u>Description</u>

       SMB_QUICK_WRITE    <u>QuickWrite</u> does not transfer any data.  It just issues the device address  with  write
                          intent to the bus.
       SMB_QUICK_READ     <u>QuickRead</u>  does  not  transfer  any data.  It just issues the device address with read
                          intent to the bus.
       SMB_SENDB          <u>SendByte</u> sends the byte provided in <u>cmd</u> to the device.
       SMB_RECVB          <u>ReceiveByte</u> reads a single byte from the device which is returned in <u>cmd</u>.
       SMB_WRITEB         <u>WriteByte</u> first sends the byte from <u>cmd</u> to the device, followed by the byte  given  in
                          <u>wdata.byte</u>.
       SMB_WRITEW         <u>WriteWord</u>  first  sends the byte from <u>cmd</u> to the device, followed by the word given in
                          <u>wdata.word</u>.  Note that the SMBus byte-order is little-endian by definition.
       SMB_READB          <u>ReadByte</u> first sends the byte from <u>cmd</u> to the device, then reads one byte of data from
                          the device.  Returned data is stored in <u>rdata.byte</u>.
       SMB_READW          <u>ReadWord</u> first sends the byte from <u>cmd</u> to the device, then reads one word of data from
                          the device.  Returned data is stored in <u>rdata.word</u>.
       SMB_PCALL          <u>ProcedureCall</u> first sends the byte from <u>cmd</u>  to  the  device,  followed  by  the  word
                          provided in <u>wdata.word</u>.  It then reads one word of data from the device and returns it
                          in <u>rdata.word</u>.
       SMB_BWRITE         <u>BlockWrite</u>  first  sends  the  byte  from <u>cmd</u> to the device, then the byte from <u>wcount</u>
                          followed by <u>wcount</u> bytes of data that are taken from the buffer pointed  to  by  <u>wbuf</u>.
                          The SMBus specification mandates that no more than 32 bytes of data can be transferred
                          in  a  single  block  read or write command.  This value can be read from the constant
                          SMB_MAXBLOCKSIZE.
       SMB_BREAD          <u>BlockRead</u> first sends the byte from <u>cmd</u> to the device, then  reads  a  count  of  data
                          bytes  that  the device is going to provide and then reads that many bytes.  The count
                          is returned in <u>rcount.</u> The data is returned in the buffer pointed to by <u>rbuf</u>.

       The <u><a href="../man2/read.2.html">read</a></u>(2) and <u><a href="../man2/write.2.html">write</a></u>(2) system calls are not implemented by this driver.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) commands can cause the following driver-specific errors:

       [ENXIO]            Device did not respond to selection.

       [EBUSY]            Device still in use.

       [ENODEV]           Operation not supported by device (not supposed to happen).

       [EINVAL]           General argument error.

       [EWOULDBLOCK]      SMBus transaction timed out.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man4/smbus.4.html">smbus</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>smb</b> manual page first appeared in FreeBSD 3.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Nicolas Souchu and extended by
       Michael Gmelin &lt;<a href="mailto:freebsd@grem.de">freebsd@grem.de</a>&gt;.

Debian                                           April 25, 2015                                           <u><a href="../man4/SMB.4.html">SMB</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>