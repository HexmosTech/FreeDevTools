<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pf — packet filter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pf — packet filter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>pf</b>
       <b>options</b> <b>PF_DEFAULT_TO_DROP</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Packet  filtering  takes  place  in  the  kernel.  A pseudo-device, <u>/dev/pf</u>, allows userland processes to
       control the behavior of the packet filter through an <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) interface.  There are  commands  to  enable
       and  disable  the  filter,  load  rulesets,  add  and remove individual rules or state table entries, and
       retrieve statistics.  The most commonly used functions are covered by <u><a href="../man8/pfctl.8.html">pfctl</a></u>(8).

       Manipulations like loading a ruleset that involve more than a single <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) call  require  a  so-called
       <u>ticket</u>, which prevents the occurrence of multiple concurrent manipulations.

       Fields  of  <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2)  parameter  structures  that  refer  to  packet  data (like addresses and ports) are
       generally expected in network byte-order.

       Rules and address tables are contained in so-called <u>anchors</u>.  When servicing an <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) request, if  the
       anchor  field  of the argument structure is empty, the kernel will use the default anchor (i.e., the main
       ruleset) in operations.  Anchors are specified by name and may be nested, with  components  separated  by
       ‘/’  characters,  similar to how file system hierarchies are laid out.  The final component of the anchor
       path is the anchor under which operations will be performed.

</pre><h4><b>SYSCTL</b> <b>VARIABLES</b> <b>AND</b> <b>LOADER</b> <b>TUNABLES</b></h4><pre>
       The following <u><a href="../man8/loader.8.html">loader</a></u>(8) tunables are available.

       <u>net.pf.states_hashsize</u>
               Size of hash tables that store states.  Should be power of 2.  Default value is 131072.

       <u>net.pf.source_nodes_hashsize</u>
               Size of hash table that store source nodes.  Should be power of 2.  Default value is 32768.

       Read only <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) variables with matching names are provided to obtain current values at runtime.

</pre><h4><b>KERNEL</b> <b>OPTIONS</b></h4><pre>
       The following options in the kernel configuration file are related to <b>pf</b> operation:

       PF_DEFAULT_TO_DROP  Change default policy to drop by default

</pre><h4><b>IOCTL</b> <b>INTERFACE</b></h4><pre>
       <b>pf</b> supports the following <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) commands, available through ⟨<u>net/pfvar.h</u>⟩:

       DIOCSTART
               Start the packet filter.

       DIOCSTOP
               Stop the packet filter.

       DIOCSTARTALTQ
               Start the ALTQ bandwidth control system (see <u><a href="../man9/altq.9.html">altq</a></u>(9)).

       DIOCSTOPALTQ
               Stop the ALTQ bandwidth control system.

       DIOCBEGINADDRS <u>struct</u> <u>pfioc_pooladdr</u> <u>*pp</u>

               struct pfioc_pooladdr {
                       u_int32_t               action;
                       u_int32_t               ticket;
                       u_int32_t               nr;
                       u_int32_t               r_num;
                       u_int8_t                r_action;
                       u_int8_t                r_last;
                       u_int8_t                af;
                       char                    anchor[MAXPATHLEN];
                       struct pf_pooladdr      addr;
               };

               Clear the buffer address pool and get a  <u>ticket</u>  for  subsequent  DIOCADDADDR,  DIOCADDRULE,  and
               DIOCCHANGERULE calls.

       DIOCADDADDR <u>struct</u> <u>pfioc_pooladdr</u> <u>*pp</u>

               Add  the  pool address <u>addr</u> to the buffer address pool to be used in the following DIOCADDRULE or
               DIOCCHANGERULE call.  All other members of the structure are ignored.

       DIOCADDRULE <u>struct</u> <u>pfioc_rule</u> <u>*pr</u>

               struct pfioc_rule {
                       u_int32_t       action;
                       u_int32_t       ticket;
                       u_int32_t       pool_ticket;
                       u_int32_t       nr;
                       char            anchor[MAXPATHLEN];
                       char            anchor_call[MAXPATHLEN];
                       struct pf_rule  rule;
               };

               Add <u>rule</u> at the end of the inactive ruleset.  This call requires  a  <u>ticket</u>  obtained  through  a
               preceding  DIOCXBEGIN call and a <u>pool_ticket</u> obtained through a DIOCBEGINADDRS call.  DIOCADDADDR
               must also be called if any pool addresses are required.  The optional <u>anchor</u> name  indicates  the
               anchor in which to append the rule.  <u>nr</u> and <u>action</u> are ignored.

       DIOCADDALTQ <u>struct</u> <u>pfioc_altq</u> <u>*pa</u>
               Add an ALTQ discipline or queue.

               struct pfioc_altq {
                       u_int32_t       action;
                       u_int32_t       ticket;
                       u_int32_t       nr;
                       struct pf_altq  altq;
               };

       DIOCGETRULES <u>struct</u> <u>pfioc_rule</u> <u>*pr</u>
               Get a <u>ticket</u> for subsequent DIOCGETRULE calls and the number <u>nr</u> of rules in the active ruleset.

       DIOCGETRULE <u>struct</u> <u>pfioc_rule</u> <u>*pr</u>
               Get  a <u>rule</u> by its number <u>nr</u> using the <u>ticket</u> obtained through a preceding DIOCGETRULES call.  If
               <u>action</u> is set to PF_GET_CLR_CNTR, the per-rule statistics on the requested rule are cleared.

       DIOCGETADDRS <u>struct</u> <u>pfioc_pooladdr</u> <u>*pp</u>
               Get a <u>ticket</u> for subsequent DIOCGETADDR calls and the number <u>nr</u> of pool  addresses  in  the  rule
               specified with <u>r_action</u>, <u>r_num</u>, and <u>anchor</u>.

       DIOCGETADDR <u>struct</u> <u>pfioc_pooladdr</u> <u>*pp</u>
               Get  the  pool  address  <u>addr</u>  by its number <u>nr</u> from the rule specified with <u>r_action</u>, <u>r_num</u>, and
               <u>anchor</u> using the <u>ticket</u> obtained through a preceding DIOCGETADDRS call.

       DIOCGETALTQS <u>struct</u> <u>pfioc_altq</u> <u>*pa</u>
               Get a <u>ticket</u> for subsequent DIOCGETALTQ calls and the number <u>nr</u> of queues in the active list.

       DIOCGETALTQ <u>struct</u> <u>pfioc_altq</u> <u>*pa</u>
               Get the queueing discipline <u>altq</u> by its number <u>nr</u> using the <u>ticket</u> obtained through  a  preceding
               DIOCGETALTQS call.

       DIOCGETQSTATS <u>struct</u> <u>pfioc_qstats</u> <u>*pq</u>
               Get the statistics on a queue.

               struct pfioc_qstats {
                       u_int32_t        ticket;
                       u_int32_t        nr;
                       void            *buf;
                       int              nbytes;
                       u_int8_t         scheduler;
               };

               This  call  fills  in  a pointer to the buffer of statistics <u>buf</u>, of length <u>nbytes</u>, for the queue
               specified by <u>nr</u>.

       DIOCGETRULESETS <u>struct</u> <u>pfioc_ruleset</u> <u>*pr</u>

               struct pfioc_ruleset {
                       u_int32_t        nr;
                       char             path[MAXPATHLEN];
                       char             name[PF_ANCHOR_NAME_SIZE];
               };

               Get the number <u>nr</u> of rulesets (i.e., anchors) directly attached to the anchor named by  <u>path</u>  for
               use  in subsequent DIOCGETRULESET calls.  Nested anchors, since they are not directly attached to
               the given anchor, will not be included.  This ioctl returns EINVAL if the given anchor  does  not
               exist.

       DIOCGETRULESET <u>struct</u> <u>pfioc_ruleset</u> <u>*pr</u>
               Get  a  ruleset  (i.e.,  an anchor) <u>name</u> by its number <u>nr</u> from the given anchor <u>path</u>, the maximum
               number of which can be obtained from a preceding DIOCGETRULESETS call.  This ioctl returns EINVAL
               if the given anchor does not exist or  EBUSY  if  another  process  is  concurrently  updating  a
               ruleset.

       DIOCADDSTATE <u>struct</u> <u>pfioc_state</u> <u>*ps</u>
               Add a state entry.

               struct pfioc_state {
                       struct pfsync_state     state;
               };

       DIOCGETSTATE <u>struct</u> <u>pfioc_state</u> <u>*ps</u>
               Extract the entry identified by the <u>id</u> and <u>creatorid</u> fields of the <u>state</u> structure from the state
               table.

       DIOCKILLSTATES <u>struct</u> <u>pfioc_state_kill</u> <u>*psk</u>
               Remove  matching entries from the state table.  This ioctl returns the number of killed states in
               <u>psk_killed</u>.

               struct pfioc_state_kill {
                       struct pf_state_cmp     psk_pfcmp;
                       sa_family_t             psk_af;
                       int                     psk_proto;
                       struct pf_rule_addr     psk_src;
                       struct pf_rule_addr     psk_dst;
                       char                    psk_ifname[IFNAMSIZ];
                       char                    psk_label[PF_RULE_LABEL_SIZE];
                       u_int                   psk_killed;
               };

       DIOCCLRSTATES <u>struct</u> <u>pfioc_state_kill</u> <u>*psk</u>
               Clear all states.  It works like DIOCKILLSTATES, but ignores the <u>psk_af</u>, <u>psk_proto</u>, <u>psk_src</u>,  and
               <u>psk_dst</u> fields of the <u>pfioc_state_kill</u> structure.

       DIOCSETSTATUSIF <u>struct</u> <u>pfioc_if</u> <u>*pi</u>
               Specify the interface for which statistics are accumulated.

               struct pfioc_if {
                       char             ifname[IFNAMSIZ];
               };

       DIOCGETSTATUS <u>struct</u> <u>pf_status</u> <u>*s</u>
               Get the internal packet filter statistics.

               struct pf_status {
                       u_int64_t       counters[PFRES_MAX];
                       u_int64_t       lcounters[LCNT_MAX];
                       u_int64_t       fcounters[FCNT_MAX];
                       u_int64_t       scounters[SCNT_MAX];
                       u_int64_t       pcounters[2][2][3];
                       u_int64_t       bcounters[2][2];
                       u_int32_t       running;
                       u_int32_t       states;
                       u_int32_t       src_nodes;
                       u_int32_t       since;
                       u_int32_t       debug;
                       u_int32_t       hostid;
                       char            ifname[IFNAMSIZ];
                       u_int8_t        pf_chksum[MD5_DIGEST_LENGTH];
               };

       DIOCCLRSTATUS
               Clear the internal packet filter statistics.

       DIOCNATLOOK <u>struct</u> <u>pfioc_natlook</u> <u>*pnl</u>
               Look up a state table entry by source and destination addresses and ports.

               struct pfioc_natlook {
                       struct pf_addr   saddr;
                       struct pf_addr   daddr;
                       struct pf_addr   rsaddr;
                       struct pf_addr   rdaddr;
                       u_int16_t        sport;
                       u_int16_t        dport;
                       u_int16_t        rsport;
                       u_int16_t        rdport;
                       sa_family_t      af;
                       u_int8_t         proto;
                       u_int8_t         direction;
               };

       DIOCSETDEBUG <u>u_int32_t</u> <u>*level</u>
               Set the debug level.

               enum    { PF_DEBUG_NONE, PF_DEBUG_URGENT, PF_DEBUG_MISC,
                         PF_DEBUG_NOISY };

       DIOCGETSTATES <u>struct</u> <u>pfioc_states</u> <u>*ps</u>
               Get state table entries.

               struct pfioc_states {
                       int     ps_len;
                       union {
                               caddr_t          psu_buf;
                               struct pf_state *psu_states;
                       } ps_u;
               #define ps_buf          ps_u.psu_buf
               #define ps_states       ps_u.psu_states
               };

               If  <u>ps_len</u>  is  non-zero on entry, as many states as possible that can fit into this size will be
               copied into the supplied buffer <u>ps_states</u>.  On exit, <u>ps_len</u> is  always  set  to  the  total  size
               required to hold all state table entries (i.e., it is set to <b>sizeof(struct</b> <b>pf_state)</b> <b>*</b> <b>nr</b>).

       DIOCCHANGERULE <u>struct</u> <u>pfioc_rule</u> <u>*pcr</u>
               Add or remove the <u>rule</u> in the ruleset specified by <u>rule.action</u>.

               The type of operation to be performed is indicated by <u>action</u>, which can be any of the following:

               enum    { PF_CHANGE_NONE, PF_CHANGE_ADD_HEAD, PF_CHANGE_ADD_TAIL,
                         PF_CHANGE_ADD_BEFORE, PF_CHANGE_ADD_AFTER,
                         PF_CHANGE_REMOVE, PF_CHANGE_GET_TICKET };

               <u>ticket</u>  must  be  set  to  the  value  obtained  with PF_CHANGE_GET_TICKET for all actions except
               PF_CHANGE_GET_TICKET.  <u>pool_ticket</u> must be set to the value obtained with the DIOCBEGINADDRS call
               for all actions except PF_CHANGE_REMOVE and  PF_CHANGE_GET_TICKET.   <u>anchor</u>  indicates  to  which
               anchor  the  operation applies.  <u>nr</u> indicates the rule number against which PF_CHANGE_ADD_BEFORE,
               PF_CHANGE_ADD_AFTER, or PF_CHANGE_REMOVE actions are applied.

       DIOCCHANGEADDR <u>struct</u> <u>pfioc_pooladdr</u> <u>*pca</u>
               Add or remove the pool address <u>addr</u> from the rule specified by <u>r_action</u>, <u>r_num</u>, and <u>anchor</u>.

       DIOCSETTIMEOUT <u>struct</u> <u>pfioc_tm</u> <u>*pt</u>

               struct pfioc_tm {
                       int              timeout;
                       int              seconds;
               };

               Set the state timeout of <u>timeout</u> to <u>seconds</u>.  The old value will be  placed  into  <u>seconds</u>.   For
               possible values of <u>timeout</u>, consult the PFTM_* values in ⟨<u>net/pfvar.h</u>⟩.

       DIOCGETTIMEOUT <u>struct</u> <u>pfioc_tm</u> <u>*pt</u>
               Get the state timeout of <u>timeout</u>.  The value will be placed into the <u>seconds</u> field.

       DIOCCLRRULECTRS
               Clear per-rule statistics.

       DIOCSETLIMIT <u>struct</u> <u>pfioc_limit</u> <u>*pl</u>
               Set the hard limits on the memory pools used by the packet filter.

               struct pfioc_limit {
                       int             index;
                       unsigned        limit;
               };

               enum    { PF_LIMIT_STATES, PF_LIMIT_SRC_NODES, PF_LIMIT_FRAGS,
                         PF_LIMIT_TABLE_ENTRIES, PF_LIMIT_MAX };

       DIOCGETLIMIT <u>struct</u> <u>pfioc_limit</u> <u>*pl</u>
               Get the hard <u>limit</u> for the memory pool indicated by <u>index</u>.

       DIOCRCLRTABLES <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Clear  all  tables.  All the ioctls that manipulate radix tables use the same structure described
               below.  For DIOCRCLRTABLES, <u>pfrio_ndel</u> contains on exit the number of tables deleted.

               struct pfioc_table {
                       struct pfr_table         pfrio_table;
                       void                    *pfrio_buffer;
                       int                      pfrio_esize;
                       int                      pfrio_size;
                       int                      pfrio_size2;
                       int                      pfrio_nadd;
                       int                      pfrio_ndel;
                       int                      pfrio_nchange;
                       int                      pfrio_flags;
                       u_int32_t                pfrio_ticket;
               };
               #define pfrio_exists    pfrio_nadd
               #define pfrio_nzero     pfrio_nadd
               #define pfrio_nmatch    pfrio_nadd
               #define pfrio_naddr     pfrio_size2
               #define pfrio_setflag   pfrio_size2
               #define pfrio_clrflag   pfrio_nadd

       DIOCRADDTABLES <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Create one or more tables.  On entry, <u>pfrio_buffer</u> must point to an  array  of  <u>struct</u>  <u>pfr_table</u>
               containing  at  least <u>pfrio_size</u> elements.  <u>pfrio_esize</u> must be the size of <u>struct</u> <u>pfr_table</u>.  On
               exit, <u>pfrio_nadd</u> contains the number of tables effectively created.

               struct pfr_table {
                       char            pfrt_anchor[MAXPATHLEN];
                       char            pfrt_name[PF_TABLE_NAME_SIZE];
                       u_int32_t       pfrt_flags;
                       u_int8_t        pfrt_fback;
               };

       DIOCRDELTABLES <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Delete one or more tables.  On entry, <u>pfrio_buffer</u> must point to an  array  of  <u>struct</u>  <u>pfr_table</u>
               containing  at  least <u>pfrio_size</u> elements.  <u>pfrio_esize</u> must be the size of <u>struct</u> <u>pfr_table</u>.  On
               exit, <u>pfrio_ndel</u> contains the number of tables effectively deleted.

       DIOCRGETTABLES <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Get the list of all tables.  On entry, <u>pfrio_buffer[pfrio_size]</u> contains a valid writeable buffer
               for <u>pfr_table</u> structures.  On exit, <u>pfrio_size</u> contains the number of  tables  written  into  the
               buffer.   If  the  buffer  is  too small, the kernel does not store anything but just returns the
               required buffer size, without error.

       DIOCRGETTSTATS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               This call is like DIOCRGETTABLES but is used to get an array of <u>pfr_tstats</u> structures.

               struct pfr_tstats {
                       struct pfr_table pfrts_t;
                       u_int64_t        pfrts_packets
                                            [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
                       u_int64_t        pfrts_bytes
                                            [PFR_DIR_MAX][PFR_OP_TABLE_MAX];
                       u_int64_t        pfrts_match;
                       u_int64_t        pfrts_nomatch;
                       long             pfrts_tzero;
                       int              pfrts_cnt;
                       int              pfrts_refcnt[PFR_REFCNT_MAX];
               };
               #define pfrts_name       pfrts_t.pfrt_name
               #define pfrts_flags      pfrts_t.pfrt_flags

       DIOCRCLRTSTATS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Clear the statistics of one or more tables.  On entry, <u>pfrio_buffer</u> must point  to  an  array  of
               <u>struct</u> <u>pfr_table</u> containing at least <u>pfrio_size</u> elements.  <u>pfrio_esize</u> must be the size of <u>struct</u>
               <u>pfr_table</u>.  On exit, <u>pfrio_nzero</u> contains the number of tables effectively cleared.

       DIOCRCLRADDRS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Clear  all  addresses  in  a table.  On entry, <u>pfrio_table</u> contains the table to clear.  On exit,
               <u>pfrio_ndel</u> contains the number of addresses removed.

       DIOCRADDADDRS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Add one or more addresses  to  a  table.   On  entry,  <u>pfrio_table</u>  contains  the  table  ID  and
               <u>pfrio_buffer</u> must point to an array of <u>struct</u> <u>pfr_addr</u> containing at least <u>pfrio_size</u> elements to
               add to the table.  <u>pfrio_esize</u> must be the size of <u>struct</u> <u>pfr_addr</u>.  On exit, <u>pfrio_nadd</u> contains
               the number of addresses effectively added.

               struct pfr_addr {
                       union {
                               struct in_addr   _pfra_ip4addr;
                               struct in6_addr  _pfra_ip6addr;
                       }                pfra_u;
                       u_int8_t         pfra_af;
                       u_int8_t         pfra_net;
                       u_int8_t         pfra_not;
                       u_int8_t         pfra_fback;
               };
               #define pfra_ip4addr    pfra_u._pfra_ip4addr
               #define pfra_ip6addr    pfra_u._pfra_ip6addr

       DIOCRDELADDRS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Delete  one  or  more  addresses  from  a table.  On entry, <u>pfrio_table</u> contains the table ID and
               <u>pfrio_buffer</u> must point to an array of <u>struct</u> <u>pfr_addr</u> containing at least <u>pfrio_size</u> elements to
               delete from the table.  <u>pfrio_esize</u> must be the size of <u>struct</u>  <u>pfr_addr</u>.   On  exit,  <u>pfrio_ndel</u>
               contains the number of addresses effectively deleted.

       DIOCRSETADDRS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Replace  the  content  of  a  table by a new address list.  This is the most complicated command,
               which uses all the structure members.

               On entry, <u>pfrio_table</u> contains the table ID and <u>pfrio_buffer</u> must point to  an  array  of  <u>struct</u>
               <u>pfr_addr</u>  containing  at  least  <u>pfrio_size</u>  elements which become the new contents of the table.
               <u>pfrio_esize</u> must be the size of <u>struct</u>  <u>pfr_addr</u>.   Additionally,  if  <u>pfrio_size2</u>  is  non-zero,
               <u>pfrio_buffer[pfrio_size..pfrio_size2]</u>  must be a writeable buffer, into which the kernel can copy
               the addresses that have  been  deleted  during  the  replace  operation.   On  exit,  <u>pfrio_ndel</u>,
               <u>pfrio_nadd</u>,  and <u>pfrio_nchange</u> contain the number of addresses deleted, added, and changed by the
               kernel.  If <u>pfrio_size2</u> was set on entry, <u>pfrio_size2</u> will point to the size of the buffer  used,
               exactly like DIOCRGETADDRS.

       DIOCRGETADDRS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Get   all  the  addresses  of  a  table.   On  entry,  <u>pfrio_table</u>  contains  the  table  ID  and
               <u>pfrio_buffer[pfrio_size]</u> contains a valid writeable buffer for  <u>pfr_addr</u>  structures.   On  exit,
               <u>pfrio_size</u>  contains  the  number  of  addresses  written into the buffer.  If the buffer was too
               small, the kernel does not store anything but just returns  the  required  buffer  size,  without
               returning an error.

       DIOCRGETASTATS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               This call is like DIOCRGETADDRS but is used to get an array of <u>pfr_astats</u> structures.

               struct pfr_astats {
                       struct pfr_addr  pfras_a;
                       u_int64_t        pfras_packets
                                            [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
                       u_int64_t        pfras_bytes
                                            [PFR_DIR_MAX][PFR_OP_ADDR_MAX];
                       long             pfras_tzero;
               };

       DIOCRCLRASTATS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Clear  the  statistics of one or more addresses.  On entry, <u>pfrio_table</u> contains the table ID and
               <u>pfrio_buffer</u> must point to an array of <u>struct</u> <u>pfr_addr</u> containing at least <u>pfrio_size</u> elements to
               be cleared from the  table.   <u>pfrio_esize</u>  must  be  the  size  of  <u>struct</u>  <u>pfr_addr</u>.   On  exit,
               <u>pfrio_nzero</u> contains the number of addresses effectively cleared.

       DIOCRTSTADDRS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Test  if  the  given  addresses  match  a table.  On entry, <u>pfrio_table</u> contains the table ID and
               <u>pfrio_buffer</u> must point to an array of <u>struct</u> <u>pfr_addr</u> containing at least  <u>pfrio_size</u>  elements,
               each  of  which  will be tested for a match in the table.  <u>pfrio_esize</u> must be the size of <u>struct</u>
               <u>pfr_addr</u>.  On exit, the kernel updates the  <u>pfr_addr</u>  array  by  setting  the  <u>pfra_fback</u>  member
               appropriately.

       DIOCRSETTFLAGS <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Change  the  PFR_TFLAG_CONST  or PFR_TFLAG_PERSIST flags of a table.  On entry, <u>pfrio_buffer</u> must
               point to an array of <u>struct</u> <u>pfr_table</u> containing at least <u>pfrio_size</u> elements.  <u>pfrio_esize</u>  must
               be  the  size  of  <u>struct</u>  <u>pfr_table</u>.   <u>pfrio_setflag</u>  must  contain  the  flags  to  add,  while
               <u>pfrio_clrflag</u> must contain the flags to remove.  On exit, <u>pfrio_nchange</u>  and  <u>pfrio_ndel</u>  contain
               the number of tables altered or deleted by the kernel.  Yes, tables can be deleted if one removes
               the PFR_TFLAG_PERSIST flag of an unreferenced table.

       DIOCRINADEFINE <u>struct</u> <u>pfioc_table</u> <u>*io</u>
               Defines  a  table  in  the  inactive  set.   On  entry,  <u>pfrio_table</u>  contains  the  table ID and
               <u>pfrio_buffer[pfrio_size]</u> contains an array of <u>pfr_addr</u> structures to put in the table.   A  valid
               ticket  must  also  be supplied to <u>pfrio_ticket</u>.  On exit, <u>pfrio_nadd</u> contains 0 if the table was
               already defined in the inactive list or 1 if a new table has been created.  <u>pfrio_naddr</u>  contains
               the number of addresses effectively put in the table.

       DIOCXBEGIN <u>struct</u> <u>pfioc_trans</u> <u>*io</u>

               struct pfioc_trans {
                       int              size;  /* number of elements */
                       int              esize; /* size of each element in bytes */
                       struct pfioc_trans_e {
                               int             rs_num;
                               char            anchor[MAXPATHLEN];
                               u_int32_t       ticket;
                       }               *array;
               };

               Clear all the inactive rulesets specified in the <u>pfioc_trans_e</u> array.  For each ruleset, a ticket
               is  returned  for  subsequent "add rule" ioctls, as well as for the DIOCXCOMMIT and DIOCXROLLBACK
               calls.

               Ruleset types, identified by <u>rs_num</u>, include the following:

                  PF_RULESET_SCRUB   Scrub (packet normalization) rules.
                  PF_RULESET_FILTER  Filter rules.
                  PF_RULESET_NAT     NAT (Network Address Translation) rules.
                  PF_RULESET_BINAT   Bidirectional NAT rules.
                  PF_RULESET_RDR     Redirect rules.
                  PF_RULESET_ALTQ    ALTQ disciplines.
                  PF_RULESET_TABLE   Address tables.

       DIOCXCOMMIT <u>struct</u> <u>pfioc_trans</u> <u>*io</u>
               Atomically switch a vector of inactive rulesets to the active rulesets.  This call is implemented
               as a standard two-phase commit, which will either fail for all rulesets  or  completely  succeed.
               All  tickets  need  to  be  valid.   This  ioctl returns EBUSY if another process is concurrently
               updating some of the same rulesets.

       DIOCXROLLBACK <u>struct</u> <u>pfioc_trans</u> <u>*io</u>
               Clean up the kernel by undoing all changes that have taken place on the inactive  rulesets  since
               the  last  DIOCXBEGIN.   DIOCXROLLBACK  will  silently  ignore  rulesets  for which the ticket is
               invalid.

       DIOCSETHOSTID <u>u_int32_t</u> <u>*hostid</u>
               Set the host ID, which is used by <u><a href="../man4/pfsync.4.html">pfsync</a></u>(4) to identify which host created state table entries.

       DIOCOSFPFLUSH
               Flush the passive OS fingerprint table.

       DIOCOSFPADD <u>struct</u> <u>pf_osfp_ioctl</u> <u>*io</u>

               struct pf_osfp_ioctl {
                       struct pf_osfp_entry {
                               SLIST_ENTRY(pf_osfp_entry) fp_entry;
                               pf_osfp_t               fp_os;
                               char                    fp_class_nm[PF_OSFP_LEN];
                               char                    fp_version_nm[PF_OSFP_LEN];
                               char                    fp_subtype_nm[PF_OSFP_LEN];
                       }                       fp_os;
                       pf_tcpopts_t            fp_tcpopts;
                       u_int16_t               fp_wsize;
                       u_int16_t               fp_psize;
                       u_int16_t               fp_mss;
                       u_int16_t               fp_flags;
                       u_int8_t                fp_optcnt;
                       u_int8_t                fp_wscale;
                       u_int8_t                fp_ttl;
                       int                     fp_getnum;
               };

               Add a passive  OS  fingerprint  to  the  table.   Set  <u>fp_os.fp_os</u>  to  the  packed  fingerprint,
               <u>fp_os.fp_class_nm</u> to the name of the class (Linux, Windows, etc), <u>fp_os.fp_version_nm</u> to the name
               of  the  version  (NT, 95, 98), and <u>fp_os.fp_subtype_nm</u> to the name of the subtype or patchlevel.
               The members <u>fp_mss</u>, <u>fp_wsize</u>, <u>fp_psize</u>, <u>fp_ttl</u>, <u>fp_optcnt</u>, and <u>fp_wscale</u> are set to the TCP  MSS,
               the  TCP  window  size,  the IP length, the IP TTL, the number of TCP options, and the TCP window
               scaling constant of the TCP SYN packet, respectively.

               The <u>fp_flags</u> member is filled according to the ⟨<u>net/pfvar.h</u>⟩ include file PF_OSFP_* defines.  The
               <u>fp_tcpopts</u> member contains packed TCP options.  Each option uses PF_OSFP_TCPOPT_BITS bits in  the
               packed    value.     Options    include    any    of   PF_OSFP_TCPOPT_NOP,   PF_OSFP_TCPOPT_SACK,
               PF_OSFP_TCPOPT_WSCALE, PF_OSFP_TCPOPT_MSS, or PF_OSFP_TCPOPT_TS.

               The <u>fp_getnum</u> member is not used with this ioctl.

               The structure's slack space must be zeroed for correct operation; <u><a href="../man3/memset.3.html">memset</a></u>(3) the  whole  structure
               to zero before filling and sending to the kernel.

       DIOCOSFPGET <u>struct</u> <u>pf_osfp_ioctl</u> <u>*io</u>
               Get  the passive OS fingerprint number <u>fp_getnum</u> from the kernel's fingerprint list.  The rest of
               the structure members will come back filled.  Get the whole list by repeatedly  incrementing  the
               <u>fp_getnum</u> number until the ioctl returns EBUSY.

       DIOCGETSRCNODES <u>struct</u> <u>pfioc_src_nodes</u> <u>*psn</u>

               struct pfioc_src_nodes {
                       int     psn_len;
                       union {
                               caddr_t         psu_buf;
                               struct pf_src_node      *psu_src_nodes;
                       } psn_u;
               #define psn_buf         psn_u.psu_buf
               #define psn_src_nodes   psn_u.psu_src_nodes
               };

               Get  the  list  of  source nodes kept by sticky addresses and source tracking.  The ioctl must be
               called once with <u>psn_len</u> set to 0.  If the ioctl returns without error, <u>psn_len</u> will  be  set  to
               the  size  of  the  buffer  required to hold all the <u>pf_src_node</u> structures held in the table.  A
               buffer of this size should then be allocated, and a pointer to this  buffer  placed  in  <u>psn_buf</u>.
               The  ioctl must then be called again to fill this buffer with the actual source node data.  After
               that call, <u>psn_len</u> will be set to the length of the buffer actually used.

       DIOCCLRSRCNODES
               Clear the tree of source tracking nodes.

       DIOCIGETIFACES <u>struct</u> <u>pfioc_iface</u> <u>*io</u>
               Get the list of interfaces and interface drivers known to <b>pf</b>.  All  the  ioctls  that  manipulate
               interfaces use the same structure described below:

               struct pfioc_iface {
                       char                     pfiio_name[IFNAMSIZ];
                       void                    *pfiio_buffer;
                       int                      pfiio_esize;
                       int                      pfiio_size;
                       int                      pfiio_nzero;
                       int                      pfiio_flags;
               };

               If  not  empty,  <u>pfiio_name</u> can be used to restrict the search to a specific interface or driver.
               <u>pfiio_buffer[pfiio_size]</u>  is  the  user-supplied  buffer  for  returning  the  data.   On  entry,
               <u>pfiio_size</u>  contains the number of <u>pfi_kif</u> entries that can fit into the buffer.  The kernel will
               replace this value by the real number of entries it wants to return.  <u>pfiio_esize</u> should  be  set
               to <b>sizeof(struct</b> <b>pfi_kif)</b>.

               The data is returned in the <u>pfi_kif</u> structure described below:

               struct pfi_kif {
                       RB_ENTRY(pfi_kif)                pfik_tree;
                       char                             pfik_name[IFNAMSIZ];
                       u_int64_t                        pfik_packets[2][2][2];
                       u_int64_t                        pfik_bytes[2][2][2];
                       u_int32_t                        pfik_tzero;
                       int                              pfik_flags;
                       struct pf_state_tree_lan_ext     pfik_lan_ext;
                       struct pf_state_tree_ext_gwy     pfik_ext_gwy;
                       TAILQ_ENTRY(pfi_kif)             pfik_w_states;
                       void                            *pfik_ah_cookie;
                       struct ifnet                    *pfik_ifp;
                       struct ifg_group                *pfik_group;
                       int                              pfik_states;
                       int                              pfik_rules;
                       TAILQ_HEAD(, pfi_dynaddr)        pfik_dynaddrs;
               };

       DIOCSETIFFLAG <u>struct</u> <u>pfioc_iface</u> <u>*io</u>
               Set  the  user  settable  flags  (described above) of the <b>pf</b> internal interface description.  The
               filtering process is the same as for DIOCIGETIFACES.

               #define PFI_IFLAG_SKIP  0x0100  /* skip filtering on interface */

       DIOCCLRIFFLAG <u>struct</u> <u>pfioc_iface</u> <u>*io</u>
               Works as DIOCSETIFFLAG above but clears the flags.

       DIOCKILLSRCNODES <u>struct</u> <u>pfioc_iface</u> <u>*io</u>
               Explicitly remove source tracking nodes.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/pf</u>  packet filtering device.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example demonstrates how to use the DIOCNATLOOK command to find the internal host/port of a
       NATed connection:

       #include &lt;sys/types.h&gt;
       #include &lt;sys/socket.h&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;sys/fcntl.h&gt;
       #include &lt;<a href="file:/usr/include/net/if.h">net/if.h</a>&gt;
       #include &lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;
       #include &lt;net/pfvar.h&gt;
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       u_int32_t
       read_address(const char *s)
       {
               int a, b, c, d;

               sscanf(s, "%i.%i.%i.%i", &amp;a, &amp;b, &amp;c, &amp;d);
               return htonl(a &lt;&lt; 24 | b &lt;&lt; 16 | c &lt;&lt; 8 | d);
       }

       void
       print_address(u_int32_t a)
       {
               a = ntohl(a);
               printf("%d.%d.%d.%d", a &gt;&gt; 24 &amp; 255, a &gt;&gt; 16 &amp; 255,
                   a &gt;&gt; 8 &amp; 255, a &amp; 255);
       }

       int
       main(int argc, char *argv[])
       {
               struct pfioc_natlook nl;
               int dev;

               if (argc != 5) {
                       printf("%s &lt;gwy addr&gt; &lt;gwy port&gt; &lt;ext addr&gt; &lt;ext port&gt;\n",
                           argv[0]);
                       return 1;
               }

               dev = open("/dev/pf", O_RDWR);
               if (dev == -1)
                       err(1, "open(\"/dev/pf\") failed");

               memset(&amp;nl, 0, sizeof(struct pfioc_natlook));
               nl.saddr.v4.s_addr      = read_address(argv[1]);
               nl.sport                = htons(atoi(argv[2]));
               nl.daddr.v4.s_addr      = read_address(argv[3]);
               nl.dport                = htons(atoi(argv[4]));
               nl.af                   = AF_INET;
               nl.proto                = IPPROTO_TCP;
               nl.direction            = PF_IN;

               if (ioctl(dev, DIOCNATLOOK, &amp;nl))
                       err(1, "DIOCNATLOOK");

               printf("internal host ");
               print_address(nl.rsaddr.v4.s_addr);
               printf(":%u\n", ntohs(nl.rsport));
               return 0;
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man4/altq.4.html">altq</a></u>(4), <u><a href="../man4/if_bridge.4.html">if_bridge</a></u>(4), <u><a href="../man4/pflog.4.html">pflog</a></u>(4), <u><a href="../man4/pfsync.4.html">pfsync</a></u>(4), <u><a href="../man8/pfctl.8.html">pfctl</a></u>(8), <u><a href="../man9/altq.9.html">altq</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>pf</b> packet filtering mechanism first appeared in OpenBSD 3.0 and then FreeBSD 5.2.

       This implementation is derived from OpenBSD 4.5.  It has been heavily modified to be capable  of  running
       in multithreaded FreeBSD kernel and scale its performance on multiple CPUs.

Debian                                           August 5, 2018                                            <u><a href="../man4/PF.4.html">PF</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>