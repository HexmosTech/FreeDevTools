<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>loop, loop-control - loop devices</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       loop, loop-control - loop devices

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/linux/loop.h">linux/loop.h</a>&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  loop device is a block device that maps its data blocks not to a physical device such as a hard disk
       or optical disk drive, but to the blocks of a regular file in a filesystem or to  another  block  device.
       This can be useful for example to provide a block device for a filesystem image stored in a file, so that
       it can be mounted with the <b><a href="../man8/mount.8.html">mount</a></b>(8) command.  You could do

           $ <b>dd</b> <b>if=/dev/zero</b> <b>of=file.img</b> <b>bs=1MiB</b> <b>count=10</b>
           $ <b>sudo</b> <b>losetup</b> <b>/dev/loop4</b> <b>file.img</b>
           $ <b>sudo</b> <b>mkfs</b> <b>-t</b> <b>ext4</b> <b>/dev/loop4</b>
           $ <b>sudo</b> <b>mkdir</b> <b>/myloopdev</b>
           $ <b>sudo</b> <b>mount</b> <b>/dev/loop4</b> <b>/myloopdev</b>

       See <b><a href="../man8/losetup.8.html">losetup</a></b>(8) for another example.

       A transfer function can be specified for each loop device for encryption and decryption purposes.

       The following <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operations are provided by the loop block device:

       <b>LOOP_SET_FD</b>
              Associate  the  loop  device  with  the  open  file whose file descriptor is passed as the (third)
              <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument.

       <b>LOOP_CLR_FD</b>
              Disassociate the loop device from any file descriptor.

       <b>LOOP_SET_STATUS</b>
              Set the status of the loop device using the (third) <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument.  This argument is a pointer
              to a <u>loop_info</u> structure, defined in <u>&lt;linux/loop.h&gt;</u> as:

                  struct loop_info {
                      int           lo_number;      /* ioctl r/o */
                      dev_t         lo_device;      /* ioctl r/o */
                      unsigned long lo_inode;       /* ioctl r/o */
                      dev_t         lo_rdevice;     /* ioctl r/o */
                      int           lo_offset;
                      int           lo_encrypt_type;
                      int           lo_encrypt_key_size;  /* ioctl w/o */
                      int           lo_flags;       /* ioctl r/w (r/o before
                                                       Linux 2.6.25) */
                      char          lo_name[LO_NAME_SIZE];
                      unsigned char lo_encrypt_key[LO_KEY_SIZE];
                                                    /* ioctl w/o */
                      unsigned long lo_init[2];
                      char          reserved[4];
                  };

              The encryption type (<u>lo_encrypt_type</u>) should be one of <b>LO_CRYPT_NONE</b>, <b>LO_CRYPT_XOR</b>,  <b>LO_CRYPT_DES</b>,
              <b>LO_CRYPT_FISH2</b>, <b>LO_CRYPT_BLOW</b>, <b>LO_CRYPT_CAST128</b>, <b>LO_CRYPT_IDEA</b>, <b>LO_CRYPT_DUMMY</b>, <b>LO_CRYPT_SKIPJACK</b>,
              or (since Linux 2.6.0) <b>LO_CRYPT_CRYPTOAPI</b>.

              The <u>lo_flags</u> field is a bit mask that can include zero or more of the following:

              <b>LO_FLAGS_READ_ONLY</b>
                     The loopback device is read-only.

              <b>LO_FLAGS_AUTOCLEAR</b> (since Linux 2.6.25)
                     The loopback device will autodestruct on last close.

              <b>LO_FLAGS_PARTSCAN</b> (since Linux 3.2)
                     Allow automatic partition scanning.

              <b>LO_FLAGS_DIRECT_IO</b> (since Linux 4.10)
                     Use direct I/O mode to access the backing file.

              The   only   <u>lo_flags</u>   that  can  be  modified  by  <b>LOOP_SET_STATUS</b>  are  <b>LO_FLAGS_AUTOCLEAR</b>  and
              <b>LO_FLAGS_PARTSCAN</b>.

       <b>LOOP_GET_STATUS</b>
              Get the status of the loop device.  The (third) <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument must be a pointer  to  a  <u>struct</u>
              <u>loop_info</u>.

       <b>LOOP_CHANGE_FD</b> (since Linux 2.6.5)
              Switch  the  backing store of the loop device to the new file identified file descriptor specified
              in the (third) <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument, which is an integer.  This operation is  possible  only  if  the
              loop  device  is  read-only and the new backing store is the same size and type as the old backing
              store.

       <b>LOOP_SET_CAPACITY</b> (since Linux 2.6.30)
              Resize a live loop device.  One can change the size of the underlying backing store and  then  use
              this  operation  so  that  the  loop  driver  learns  about the new size.  This operation takes no
              argument.

       <b>LOOP_SET_DIRECT_IO</b> (since Linux 4.10)
              Set DIRECT I/O mode on the loop device, so that it can be used to open backing file.  The  (third)
              <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument is an unsigned long value.  A nonzero represents direct I/O mode.

       <b>LOOP_SET_BLOCK_SIZE</b> (since Linux 4.14)
              Set  the  block size of the loop device.  The (third) <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument is an unsigned long value.
              This value must be a power of two in the range [512,pagesize]; otherwise, an <b>EINVAL</b> error results.

       <b>LOOP_CONFIGURE</b> (since Linux 5.8)
              Setup and configure all loop device parameters  in  a  single  step  using  the  (third)  <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)
              argument.  This argument is a pointer to a <u>loop_config</u> structure, defined in <u>&lt;linux/loop.h&gt;</u> as:

                  struct loop_config {
                      __u32               fd;
                      __u32               block_size;
                      struct loop_info64  info;
                      __u64               __reserved[8];
                  };

              In  addition  to  doing  what  <b>LOOP_SET_STATUS</b>  can  do, <b>LOOP_CONFIGURE</b> can also be used to do the
              following:

              •  set the correct block size immediately by setting <u>loop_config.block_size</u>;

              •  explicitly request direct I/O mode by setting <b>LO_FLAGS_DIRECT_IO</b> in  <u>loop_config.info.lo_flags</u>;
                 and

              •  explicitly request read-only mode by setting <b>LO_FLAGS_READ_ONLY</b> in <u>loop_config.info.lo_flags</u>.

       Since Linux 2.6, there are two new <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operations:

       <b>LOOP_SET_STATUS64</b>
       <b>LOOP_GET_STATUS64</b>
              These  are  similar to <b>LOOP_SET_STATUS</b> and <b>LOOP_GET_STATUS</b> described above but use the <u>loop_info64</u>
              structure, which has some additional fields and a larger range for some other fields:

                  struct loop_info64 {
                      uint64_t lo_device;           /* ioctl r/o */
                      uint64_t lo_inode;            /* ioctl r/o */
                      uint64_t lo_rdevice;          /* ioctl r/o */
                      uint64_t lo_offset;
                      uint64_t lo_sizelimit;  /* bytes, 0 == max available */
                      uint32_t lo_number;           /* ioctl r/o */
                      uint32_t lo_encrypt_type;
                      uint32_t lo_encrypt_key_size; /* ioctl w/o */
                      uint32_t lo_flags; i          /* ioctl r/w (r/o before
                                                       Linux 2.6.25) */
                      uint8_t  lo_file_name[LO_NAME_SIZE];
                      uint8_t  lo_crypt_name[LO_NAME_SIZE];
                      uint8_t  lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */
                      uint64_t lo_init[2];
                  };

   <b>/dev/loop-control</b>
       Since Linux 3.1, the kernel provides the  <u>/dev/loop-control</u>  device,  which  permits  an  application  to
       dynamically  find  a  free  device, and to add and remove loop devices from the system.  To perform these
       operations, one first opens <u>/dev/loop-control</u> and then employs one of the following <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operations:

       <b>LOOP_CTL_GET_FREE</b>
              Allocate or find a free loop device for use.  On success, the device number  is  returned  as  the
              result of the call.  This operation takes no argument.

       <b>LOOP_CTL_ADD</b>
              Add  the  new loop device whose device number is specified as a long integer in the third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)
              argument.  On success, the device index is returned as the result of the call.  If the  device  is
              already allocated, the call fails with the error <b>EEXIST</b>.

       <b>LOOP_CTL_REMOVE</b>
              Remove  the  loop  device whose device number is specified as a long integer in the third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)
              argument.  On success, the device number is returned as the result of the call.  If the device  is
              in use, the call fails with the error <b>EBUSY</b>.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/loop*</u>
              The loop block special device files.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below  uses the <u>/dev/loop-control</u> device to find a free loop device, opens the loop device,
       opens a file to be used as the underlying storage for the device, and then  associates  the  loop  device
       with the backing store.  The following shell session demonstrates the use of the program:

           $ <b>dd</b> <b>if=/dev/zero</b> <b>of=file.img</b> <b>bs=1MiB</b> <b>count=10</b>
           10+0 records in
           10+0 records out
           10485760 bytes (10 MB) copied, 0.00609385 s, 1.7 GB/s
           $ <b>sudo</b> <b>./mnt_loop</b> <b>file.img</b>
           loopname = /dev/loop5

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/linux/loop.h">linux/loop.h</a>&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define <a href="../manmsg/errExit.msg.html">errExit</a>(msg)    do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); \
                               } while (0)

       int
       main(int argc, char *argv[])
       {
           int loopctlfd, loopfd, backingfile;
           long devnr;
           char loopname[4096];

           if (argc != 2) {
               fprintf(stderr, "Usage: %s backing-file\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           loopctlfd = open("/dev/loop-control", O_RDWR);
           if (loopctlfd == -1)
               errExit("open: /dev/loop-control");

           devnr = ioctl(loopctlfd, LOOP_CTL_GET_FREE);
           if (devnr == -1)
               errExit("ioctl-LOOP_CTL_GET_FREE");

           sprintf(loopname, "/dev/loop%ld", devnr);
           printf("loopname = %s\n", loopname);

           loopfd = open(loopname, O_RDWR);
           if (loopfd == -1)
               errExit("open: loopname");

           backingfile = open(argv[1], O_RDWR);
           if (backingfile == -1)
               errExit("open: backing-file");

           if (ioctl(loopfd, LOOP_SET_FD, backingfile) == -1)
               errExit("ioctl-LOOP_SET_FD");

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/losetup.8.html">losetup</a></b>(8), <b><a href="../man8/mount.8.html">mount</a></b>(8)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man4/loop.4.html">loop</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>