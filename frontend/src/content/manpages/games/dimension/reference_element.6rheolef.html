<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reference_element - reference element (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       reference_element - reference element (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>reference_element</b> class defines all supported types of geometrical elements in zero, one, two and
       three dimensions. Each supported element is represented by a letter:

       • p: <b><a href="../man6/point.6.html">point</a>(6)</b> (dimension 0)

       • e: <b><a href="../man6/edge.6.html">edge</a>(6)</b> (dimension 1)

       • t: <b><a href="../man6/triangle.6.html">triangle</a>(6)</b> (dimension 2)

       • q: <b><a href="../man6/quadrangle.6.html">quadrangle</a>(6)</b> (dimension 2)

       • T: <b><a href="../man6/tetrahedron.6.html">tetrahedron</a>(6)</b> (dimension 3)

       • P: <b><a href="../man6/prism.6.html">prism</a>(6)</b> (dimension 3)

       • H: <b><a href="../man6/hexahedron.6.html">hexahedron</a>(6)</b> (dimension 3)

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file fem/geo_element/reference_element.h

       class reference_element {
       public:

       // typedefs:

           typedef std::vector&lt;int&gt;::size_type size_type;
           typedef size_type                   variant_type;

           static const variant_type
               p = 0,
               e = 1,
               t = 2,
               q = 3,
               T = 4,
               P = 5,
               H = 6,
               max_variant = 7;

           static const size_type max_side_by_variant = 6;

       // allocators/deallocators:

           reference_element (variant_type x = max_variant)
             : _x(x) { assert_macro (x &gt;= 0 &amp;&amp; x &lt;= max_variant, "invalid type " &lt;&lt; x); }

       // initializers:

           void set_variant (variant_type x) { _x = x; }
           void set_variant (size_type n_vertex, size_type dim) { _x = variant (n_vertex, dim); }
           void set_name    (char name);

       // accessors:

           variant_type variant() const { return _x; }
           char name() const { return _name[_x % max_variant]; }
           size_type dimension() const { return _dimension[_x]; }
           size_type size()     const { return _n_vertex[_x]; }
           size_type n_vertex() const { return _n_vertex[_x]; }
           size_type n_side() const { return dimension() &gt; 0 ? n_subgeo (variant(), dimension()-1) : 0; }
           size_type n_edge() const { return <a href="../man1/n_subgeo.1.html">n_subgeo</a>(1); }
           size_type n_face() const { return <a href="../man2/n_subgeo.2.html">n_subgeo</a>(2); }
           size_type n_subgeo_by_variant (size_type subgeo_variant) const {
               return n_subgeo_by_variant(variant(), subgeo_variant); }

           size_type n_subgeo(size_type subgeo_dim) const { return n_subgeo (variant(), subgeo_dim); }
           reference_element subgeo (size_type subgeo_dim, size_type loc_isid) const {
               if (dimension() == 0) return reference_element(reference_element::p);
               if (dimension() == subgeo_dim) return *this;
               reference_element hat_S;
               size_type subgeo_n_vertex = subgeo_size (subgeo_dim, loc_isid);
               hat_S.set_variant (subgeo_n_vertex, subgeo_dim);
               return hat_S;
           }
           reference_element side (size_type loc_isid) const { return subgeo (dimension()-1, loc_isid); }
           size_type subgeo_size (size_type subgeo_dim, size_type loc_isid) const {
               return subgeo_n_node (_x, 1, subgeo_dim, loc_isid); }
           size_type subgeo_local_vertex(size_type subgeo_dim, size_type loc_isid, size_type loc_jsidvert) const {
               return subgeo_local_node (_x, 1, subgeo_dim, loc_isid, loc_jsidvert); }
           size_type local_subgeo_index2index_by_variant (size_type subgeo_variant, size_type i) const {
             return (variant() == P &amp;&amp; subgeo_variant == q) ? i-2 : i; }

           // TODO: use template&lt;class T&gt; instead of Float
           const point_basic&lt;Float&gt;&amp; vertex (size_type iloc) const;
           friend Float measure (reference_element hat_K);
           Float side_measure (size_type loc_isid) const;
           void side_normal (size_type loc_isid, point_basic&lt;Float&gt;&amp; hat_n) const;

       // helpers:

           static variant_type variant  (char name);
           static variant_type variant  (size_type n_vertex, size_type dim);
           static char         name     (variant_type variant) { return _name     [variant]; }
           static size_type dimension   (variant_type variant) { return _dimension[variant]; }
           static size_type n_vertex    (variant_type variant) { return _n_vertex [variant]; }
           static size_type n_node      (variant_type variant, size_type order);

           static size_type n_sub_edge    (variant_type variant);
           static size_type n_sub_face    (variant_type variant);
           static size_type n_subgeo      (variant_type variant, size_type subgeo_dim);
           static size_type subgeo_n_node (variant_type variant, size_type order, size_type subgeo_dim, size_type loc_isid);
           static size_type subgeo_local_node (variant_type variant, size_type order, size_type subgeo_dim, size_type loc_isid, size_type loc_jsidnod);

           static variant_type first_variant_by_dimension (size_type dim) {
                       return _first_variant_by_dimension[dim]; }
           static variant_type  last_variant_by_dimension (size_type dim) {
                       return _first_variant_by_dimension[dim+1]; }

           static size_type first_inod_by_variant (variant_type variant, size_type order, variant_type subgeo_variant);
           static size_type  last_inod_by_variant (variant_type variant, size_type order, variant_type subgeo_variant)
              { return first_inod_by_variant (variant, order, subgeo_variant+1); }
           static size_type first_inod (variant_type variant, size_type order, size_type subgeo_dim)
              { return first_inod_by_variant (variant, order, first_variant_by_dimension(subgeo_dim)); }
           static size_type  last_inod (variant_type variant, size_type order, size_type subgeo_dim)
              { return first_inod_by_variant (variant, order,  last_variant_by_dimension(subgeo_dim)); }
           static void init_local_nnode_by_variant (size_type order, std::array&lt;size_type,reference_element::max_variant&gt;&amp; loc_nnod_by_variant);

           static size_type n_subgeo_by_variant (size_type variant, size_type subgeo_variant)
             { return _n_subgeo_by_variant [variant] [subgeo_variant]; }

       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright    (C)   2000-2018   Pierre   Saramito   &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free   software:   you   are  free  to  change  and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                       <u><a href="../man6rheolef/reference_element.6rheolef.html">reference_element</a></u>(6rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>