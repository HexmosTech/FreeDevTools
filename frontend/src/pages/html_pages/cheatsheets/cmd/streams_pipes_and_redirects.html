<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Linux Streams, Pipes, and Redirects Explained | Online Free DevTools by
      Hexmos
    </title>
    <meta
      name="description"
      content="Master Linux streams, pipes, and redirects with clear explanations and examples. Learn to manage command-line input/output effectively."
    />
    <meta
      name="keywords"
      content="linux, shell, bash, streams, pipes, redirects, stdout, stderr, stdin, xargs, tee, command line, terminal, devtools"
    />
    <link
      rel="canonical"
      href="https://yourwebsite.com/cmd/streams_pipes_and_redirects.html"
    />
    <meta name="robots" content="index, follow" />
    <meta
      property="og:title"
      content="Linux Streams, Pipes, and Redirects Explained | Online Free DevTools by Hexmos"
    />
    <meta
      property="og:description"
      content="Master Linux streams, pipes, and redirects with clear explanations and examples. Learn to manage command-line input/output effectively."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://yourwebsite.com/cmd/streams_pipes_and_redirects.html"
    />
    <meta
      property="og:image"
      content="https://yourwebsite.com/images/streams_pipes_redirects_og.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="Linux Streams, Pipes, and Redirects Explained | Online Free DevTools by Hexmos"
    />
    <meta
      name="twitter:description"
      content="Master Linux streams, pipes, and redirects with clear explanations and examples. Learn to manage command-line input/output effectively."
    />
    <meta
      name="twitter:image"
      content="https://yourwebsite.com/images/streams_pipes_redirects_twitter.png"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
    />
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        line-height: 1.6;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f8f9fa;
      }
      .container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      .header {
        background: #2c3e50;
        color: white;
        padding: 20px;
        border-bottom: 1px solid #34495e;
      }
      .header h1 {
        margin: 0;
        font-size: 1.5em;
      }
      .content {
        padding: 20px;
      }
      pre {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 16px;
        overflow-x: auto;
        margin: 0;
      }
      code {
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 14px;
      }
      .markdown-content {
        line-height: 1.7;
      }
      .markdown-content h1,
      .markdown-content h2,
      .markdown-content h3 {
        color: #2c3e50;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 8px;
      }
      .markdown-content pre {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 16px;
        overflow-x: auto;
      }
      .markdown-content code {
        background: #f1f3f4;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 0.9em;
      }
      .markdown-content pre code {
        background: none;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Linux Streams, Pipes, and Redirects</h1>
      </div>
      <div class="content">
        <div class="markdown-content">
          <h2>Understanding Linux Streams, Pipes, and Redirects</h2>
          <p>
            In the Linux command-line environment, understanding how data flows
            is crucial for efficient task management. This involves mastering
            the concepts of streams, pipes, and redirects. Streams represent
            sequences of characters for input and output, while pipes and
            redirects allow you to control and manipulate this data flow between
            commands and files.
          </p>

          <h2>3.1. Standard I/O Streams</h2>
          <p>
            A Linux shell's inputs and outputs are sequences of characters
            called streams. There are three standard I/O streams:
          </p>
          <table>
            <thead>
              <tr>
                <th>Stream Name</th>
                <th>Description</th>
                <th>File Descriptor</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>stdout</code></td>
                <td>
                  Standard output stream, used to display command results.
                </td>
                <td>1</td>
              </tr>
              <tr>
                <td><code>stderr</code></td>
                <td>
                  Standard error stream, used to display error messages from
                  commands.
                </td>
                <td>2</td>
              </tr>
              <tr>
                <td><code>stdin</code></td>
                <td>
                  Standard input stream, used to provide input to commands.
                </td>
                <td>0</td>
              </tr>
            </tbody>
          </table>

          <h2>3.2. Input and Output Redirections</h2>
          <p>
            Input and output redirections are fundamental operations performed
            using angular brackets (&lt;&gt;) to control where command output
            goes and where command input comes from.
          </p>
          <h3>3.2.1. Types of Redirection</h3>
          <table>
            <thead>
              <tr>
                <th>Bracket Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>&gt;</code></td>
                <td>
                  Redirects a stream to a file, overwriting the file if it
                  exists. E.g., <code>ls a &gt; o.txt</code>
                </td>
              </tr>
              <tr>
                <td><code>&gt;&gt;</code></td>
                <td>
                  Appends a stream to a file. E.g.,
                  <code>ls b &gt;&gt; o.txt</code>
                </td>
              </tr>
              <tr>
                <td><code>&gt;&amp;</code></td>
                <td>
                  Redirects one stream to another. E.g.,
                  <code>ls c &gt; o2.txt 2&gt;&amp;1</code> (redirects stderr to
                  stdout)
                </td>
              </tr>
              <tr>
                <td><code>&lt;</code></td>
                <td>
                  Redirects input from a file. E.g., <code>wc &lt; o.txt</code>
                </td>
              </tr>
              <tr>
                <td><code>&lt;&lt;</code></td>
                <td>
                  Here Document: Embeds text directly into a script to be fed as
                  standard input. <br />Example:
                  <pre><code>cat &lt;&lt; EOF &gt; output.txt
line 1
line 2
line 3
EOF
echo done</code></pre>
                  This is also known as a heredoc.
                </td>
              </tr>
              <tr>
                <td><code>&lt;&lt;&lt;</code></td>
                <td>
                  Here String: Expands a variable and feeds its content into the
                  standard input of a command. <br />Example:
                  <pre><code>wc &lt;&lt;&lt; $word</code></pre>
                  This is also known as a herestring.
                </td>
              </tr>
            </tbody>
          </table>
          <h3>3.2.2. Additional Redirection Examples</h3>
          <h4>3.2.2.1. Separate Standard Output and Standard Error</h4>
          <p>
            Send standard output to <code>sout.txt</code> and standard error to
            <code>serr.txt</code>:
          </p>
          <p><code>command1 &gt; sout.txt 2&gt; serr.txt</code></p>
          <h4>3.2.2.2. Combine Standard Output and Standard Error</h4>
          <p>
            Send both standard output and standard error streams to the same
            file <code>sone.txt</code>:
          </p>
          <p><code>command1 &gt; sone.txt 2&gt;&amp;1</code></p>
          <p>Alternatively, using Bash 4+:</p>
          <p><code>command1 &amp;&gt; sone.txt</code></p>
          <h4>3.2.2.3. Check for String Presence in a Variable</h4>
          <p>
            Use <code>grep</code> with a herestring to check if a string is
            present in a shell variable:
          </p>
          <p><code>grep "ABC" &lt;&lt;&lt; $var</code></p>
          <h4>3.2.2.4. Discarding All Output</h4>
          <p>
            Ignore both standard output and standard error by redirecting them
            to <code>/dev/null</code>:
          </p>
          <p><code>command1 &amp;&gt; /dev/null</code></p>
          <p>
            <em
              ><code>/dev/null</code> is a special null device file. Anything
              written to it is discarded, and reading from it returns an
              end-of-file (EOF) immediately.</em
            >
          </p>

          <h2>3.3. Command Piping</h2>
          <p>
            Piping allows you to redirect the standard output of one command to
            the standard input of another command, creating a chain of
            operations.
          </p>
          <p>
            <code
              >command1 | command2 parameter1 | command3 parameter1 parameter2 |
              command4</code
            >
          </p>
          <p>Examples:</p>
          <ul>
            <li>
              <p>Sort a file and remove duplicate records:</p>
              <p><code>sort file1 | uniq</code></p>
            </li>
            <li>
              <p>Print the 5 most frequently used commands:</p>
              <p>
                <code
                  >history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' |
                  sort -rn | head -5</code
                >
              </p>
            </li>
            <li>
              <p>Print file types and their frequencies:</p>
              <p>
                <code
                  >ls | rev | cut -f1 -d'.' | rev | sort | uniq -c | sort
                  -n</code
                >
              </p>
            </li>
          </ul>

          <h2>3.4. The <code>xargs</code> Command</h2>
          <ul>
            <li><code>xargs</code> is short for "extended arguments."</li>
            <li>
              It is used to build and execute command lines from standard input.
              Some commands can accept arguments from both standard input and as
              command-line arguments, while others only accept arguments. For
              the latter, <code>xargs</code> is essential.
            </li>
            <li>
              <code>xargs</code> converts input from standard input into
              arguments for a specified command. It can divide the input into
              manageable chunks and run the command repeatedly for each group of
              arguments.
            </li>
            <li>
              The <code>-n</code> option allows you to specify the number of
              arguments per command execution. <br />Example:
              <code>find . | xargs -n1 basename</code>
            </li>
            <li>
              To assign standard input to a placeholder within a command, use
              the <code>-I</code> option. This is useful when you need to place
              the input in the middle of a command. <br />Example:
              <code>ls | xargs -I{} echo "File {} was found"</code>
            </li>
            <li>
              By default, <code>xargs</code> uses whitespace to delimit
              arguments. When the <code>-0</code> option is used,
              <code>xargs</code> uses null termination to identify arguments,
              which is safer for filenames containing spaces or special
              characters.
            </li>
          </ul>
          <p>Examples:</p>
          <ul>
            <li>
              Print the number of lines, words, and characters in files within a
              directory (note: <code>ls | wc</code> is not the typical use case
              for <code>xargs</code>, but demonstrates piping):
            </li>
            <li>
              Print file types and their frequencies using <code>find</code> and
              <code>xargs</code>: <br /><code
                >find . -type f | xargs basename -a | grep "\." | rev | cut -f1
                -d'.' | rev | sort | uniq -c | sort -n</code
              >
            </li>
            <li>
              Rename all files in a directory by appending <code>.bkp</code>:
              <br /><code>ls | xargs -I{} mv {} {}.bkp</code>
            </li>
            <li>
              Copy all <code>.c</code> files to a specific directory using null
              termination for safety: <br /><code
                >find . -name "*.c" -print0 | xargs -0 -n1 -I{} cp {}
                some/folder/</code
              >
              <br /><em
                >The <code>-print0</code> option of the
                <code>find</code> command prints filenames terminated by a null
                character. Using the <code>-0</code> option with
                <code>xargs</code> tells it to expect null-terminated input,
                ensuring correct handling of filenames with spaces or special
                characters.</em
              >
            </li>
          </ul>

          <h2>3.5. The <code>tee</code> Command</h2>
          <ul>
            <li>
              The <code>tee</code> command reads from standard input and writes
              it to both standard output and one or more files simultaneously.
            </li>
            <li>
              This is extremely useful when you want to view the output of a
              command on the screen in real-time while also saving that output
              to a file for later analysis or logging.
            </li>
          </ul>
          <p>Examples:</p>
          <ul>
            <li>
              Display the output of <code>ls</code> on the screen and save it to
              <code>fileList.txt</code>: <br /><code
                >ls | tee fileList.txt</code
              >
            </li>
          </ul>

          <h2>Further Reading and Resources</h2>
          <ul>
            <li>
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"
                target="_blank"
                rel="noopener noreferrer"
                >MDN Web Docs: MIME types</a
              >
              (Related to data handling)
            </li>
            <li>
              <a
                href="https://www.gnu.org/software/bash/manual/bash.html#Redirection-Builtins"
                target="_blank"
                rel="noopener noreferrer"
                >Bash Manual: Redirection Builtins</a
              >
            </li>
            <li>
              <a
                href="https://www.gnu.org/software/bash/manual/bash.html#Pipelines"
                target="_blank"
                rel="noopener noreferrer"
                >Bash Manual: Pipelines</a
              >
            </li>
            <li>
              <a
                href="https://man7.org/linux/man-pages/man1/xargs.1.html"
                target="_blank"
                rel="noopener noreferrer"
                ><code>xargs</code> man page</a
              >
            </li>
            <li>
              <a
                href="https://man7.org/linux/man-pages/man1/tee.1.html"
                target="_blank"
                rel="noopener noreferrer"
                ><code>tee</code> man page</a
              >
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>
