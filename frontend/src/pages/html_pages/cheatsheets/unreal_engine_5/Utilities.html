<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unreal Engine 5 Utilities - C++ Equivalents for Blueprint Nodes</title>
    <meta name="description" content="Explore C++ implementations for common Unreal Engine 5 Blueprint nodes, covering utilities like Delay, Print String, Actor manipulation, and more. Enhance your UE5 development with these code examples.">
    <meta name="keywords" content="Unreal Engine 5, UE5, C++, Blueprint, Utilities, Delay, Print String, Get Player Controller, Spawn Actor, Line Trace, Debug Draw, Game Mode, Game State, Open Level, Quit Game, Particle System, Decal, Sound">
    <link rel="canonical" href="https://your-website.com/unreal_engine_5/Utilities.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Unreal Engine 5 Utilities - C++ Equivalents for Blueprint Nodes">
    <meta property="og:description" content="Explore C++ implementations for common Unreal Engine 5 Blueprint nodes, covering utilities like Delay, Print String, Actor manipulation, and more. Enhance your UE5 development with these code examples.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://your-website.com/unreal_engine_5/Utilities.html">
    <meta property="og:image" content="https://your-website.com/path/to/your/og-image.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Unreal Engine 5 Utilities - C++ Equivalents for Blueprint Nodes">
    <meta name="twitter:description" content="Explore C++ implementations for common Unreal Engine 5 Blueprint nodes, covering utilities like Delay, Print String, Actor manipulation, and more. Enhance your UE5 development with these code examples.">
    <meta name="twitter:image" content="https://your-website.com/path/to/your/twitter-image.jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Unreal Engine 5 Utilities</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>UE5 C++ Utilities: Blueprint Node Equivalents</h2>
                <p>This section provides C++ code examples for common Unreal Engine 5 utility nodes found in Blueprints. Understanding these C++ equivalents is crucial for developers who need to implement complex logic or optimize performance within their UE5 projects.</p>

                <h2>Delay Node Equivalent</h2>
                <p>There is no direct equivalent to the Blueprint <code>Delay</code> node in C++. Instead, timers are used to achieve similar functionality. To execute code after a specific delay, you can place that code within a function and then start a timer using <code>Set Timer by Function Name</code>.</p>
                <p><strong>Usage:</strong> Implement a function containing the delayed logic and use <code>GetWorldTimerManager().SetTimer()</code> to schedule its execution.</p>

                <h2>Print String Node Equivalent</h2>
                <p>The <code>PrintString</code> node is frequently used for debugging. In C++, you can achieve this using <code>GEngine-&gt;AddOnScreenDebugMessage</code> for on-screen messages or the <code>UKismetSystemLibrary::PrintString</code> function for more direct Blueprint-like behavior.</p>
                <p><strong>On-Screen Debug Message:</strong></p>
                <pre><code class="language-cpp">if (GEngine)
{
    GEngine-&gt;AddOnScreenDebugMessage(
        -1,                        // Key: -1 for unique message
        2.0f,                      // Duration: How long the message stays on screen
        FColor::Cyan,              // Color: The color of the message
        TEXT("Hello from C++!")    // Message: The string to display
    );
}</code></pre>
                <p><strong>Using <code>UKismetSystemLibrary::PrintString</code>:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/KismetSystemLibrary.h&quot;

// In a UObject context (like an Actor or Component)
UKismetSystemLibrary::PrintString(
    this,                                    // World context object
    TEXT("Hello from KismetSystemLibrary!"), // Message
    true,                                    // Print to screen?
    true,                                    // Print to console?
    FLinearColor(0.0f, 0.66f, 1.0f, 1.0f),   // Color
    2.0f                                     // Duration
);</code></pre>

                <h2>Get Player Controller</h2>
                <p>Retrieves the player controller for a given player index. This is essential for interacting with player input and camera.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0); // 0 for the first player</code></pre>

                <h2>Get Player Camera Manager</h2>
                <p>Accesses the camera manager associated with a specific player, allowing control over camera properties and behavior.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

APlayerCameraManager* PlayerCameraManager = UGameplayStatics::GetPlayerCameraManager(this, 0); // 0 for the first player</code></pre>

                <h2>Spawn Emitter at Location</h2>
                <p>Spawns a particle system effect at a specified world location. Requires a <code>UParticleSystem</code> asset to be assigned.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign this UPROPERTY in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Effects")
    UParticleSystem* ExampleEmitter;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

UParticleSystemComponent* SpawnedEmitter;
FTransform SpawnTransform; // Define your desired spawn transform

if (ExampleEmitter)
{
    SpawnedEmitter = UGameplayStatics::SpawnEmitterAtLocation(
        GetWorld(),        // World object
        ExampleEmitter,    // The particle system asset
        SpawnTransform     // Transform where the emitter will spawn
    );
}</code></pre>

                <h2>Line Trace By Channel</h2>
                <p>Performs a single raycast (line trace) along a specified collision channel to detect what it hits.</p>
                <pre><code class="language-cpp">FVector StartLocation; // Define the start of the trace
FVector EndLocation;   // Define the end of the trace

FHitResult HitResult; // Structure to store hit information

bool bHit = GetWorld()-&gt;LineTraceSingleByChannel(
    HitResult,                                   // Output: Stores hit information
    StartLocation,                               // Start point of the trace
    EndLocation,                                 // End point of the trace
    ECollisionChannel::ECC_Visibility            // The collision channel to trace against
);

if (bHit)
{
    // Actor that was hit: HitResult.GetActor()
    // Location of the hit: HitResult.Location
}</code></pre>

                <h2>Multi Line Trace By Channel</h2>
                <p>Performs multiple raycasts along a specified collision channel, returning all actors hit.</p>
                <pre><code class="language-cpp">FVector StartLocation; // Define the start of the trace
FVector EndLocation;   // Define the end of the trace

TArray&lt;FHitResult&gt; HitResults; // Array to store hit information

bool bHit = GetWorld()-&gt;LineTraceMultiByChannel(
    HitResults,                                  // Output: Stores hit information for multiple hits
    StartLocation,                               // Start point of the trace
    EndLocation,                                 // End point of the trace
    ECollisionChannel::ECC_Visibility            // The collision channel to trace against
);

if (bHit)
{
    for (const FHitResult&amp; Hit : HitResults)
    {
        // Process each hit actor: Hit.GetActor()
    }
}</code></pre>

                <h2>Get Actor Of Class</h2>
                <p>Finds and returns the first actor of a specified class in the world. Requires a <code>TSubclassOf&lt;AActor&gt;</code> to be assigned.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign the desired Actor class in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Actor Finding")
    TSubclassOf&lt;AActor&gt; ActorClassToFind;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

AActor* FoundActor = nullptr;

if (ActorClassToFind)
{
    FoundActor = UGameplayStatics::GetActorOfClass(
        this,                               // World context object
        ActorClassToFind                    // The class of actor to search for
    );
}

if (FoundActor)
{
    // Use the found actor
}</code></pre>

                <h2>Get All Actors Of Class</h2>
                <p>Retrieves an array containing all actors of a specified class currently present in the world.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign the desired Actor class in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Actor Finding")
    TSubclassOf&lt;AActor&gt; ActorClassToFind;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

TArray&lt;AActor*&gt; FoundActors;

if (ActorClassToFind)
{
    UGameplayStatics::GetAllActorsOfClass(
        this,                           // World context object
        ActorClassToFind,               // The class of actors to find
        FoundActors                     // Output: Array to store the found actors
    );
}

// Iterate through FoundActors to process each one
for (AActor* Actor : FoundActors)
{
    // Do something with each actor
}</code></pre>

                <h2>Get All Actors With Tag</h2>
                <p>Finds all actors in the world that have a specific tag assigned to them.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

TArray&lt;AActor*&gt; ActorsWithTag;
FName TagToFind = FName("YourTag"); // Define the tag you are looking for

UGameplayStatics::GetAllActorsWithTag(
    this,                           // World context object
    TagToFind,                      // The tag name to search for
    ActorsWithTag                   // Output: Array to store actors with the tag
);

// Process the ActorsWithTag array
for (AActor* Actor : ActorsWithTag)
{
    // Actor has the specified tag
}</code></pre>

                <h2>Spawn Actor from Class</h2>
                <p>Spawns a new actor of a specified class at a given location and rotation. Requires a <code>TSubclassOf&lt;AActor&gt;</code> to be assigned.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign the Actor class to spawn in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Spawning")
    TSubclassOf&lt;AActor&gt; ActorClassToSpawn;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">AActor* SpawnedActor = nullptr;
FVector SpawnLocation; // Define the desired spawn location
FRotator SpawnRotation; // Define the desired spawn rotation
FActorSpawnParameters SpawnParameters; // Optional: Configure spawn parameters

if (ActorClassToSpawn)
{
    SpawnedActor = GetWorld()-&gt;SpawnActor&lt;AActor&gt;(
        ActorClassToSpawn,               // The class of actor to spawn
        SpawnLocation,                   // Location to spawn the actor
        SpawnRotation,                   // Rotation to spawn the actor
        SpawnParameters                  // Spawn parameters (e.g., owner, collision handling)
    );
}

if (SpawnedActor)
{
    // Actor successfully spawned
}</code></pre>

                <h2>Play Sound 2D</h2>
                <p>Plays a sound effect that is not attached to any specific location in the world (e.g., UI sounds, background music). Requires a <code>USoundBase</code> asset.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign the Sound Base asset in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Audio")
    USoundBase* SoundToPlay2D;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

if (SoundToPlay2D)
{
    UGameplayStatics::PlaySound2D(
        this,                   // World context object
        SoundToPlay2D,          // The sound asset to play
        1.0f,                   // Volume multiplier (0.0 to 1.0)
        1.0f                    // Pitch multiplier (0.5 to 2.0)
    );
}</code></pre>

                <h2>Play Sound at Location</h2>
                <p>Plays a sound effect originating from a specific point in the 3D world. Requires a <code>USoundBase</code> asset.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign the Sound Base asset in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Audio")
    USoundBase* SoundToPlayAtLocation;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

FVector SoundLocation; // Define the location where the sound will originate

if (SoundToPlayAtLocation)
{
    UGameplayStatics::PlaySoundAtLocation(
        this,                           // World context object
        SoundToPlayAtLocation,          // The sound asset to play
        SoundLocation,                  // The world location of the sound source
        1.0f,                           // Volume multiplier
        1.0f                            // Pitch multiplier
    );
}</code></pre>

                <h2>Apply Damage</h2>
                <p>Applies a specified amount of damage to an actor. This function handles damage calculations and notifications.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

AActor* TargetActor;              // The actor to damage
AController* InstigatorController; // The controller that caused the damage
AActor* DamageCauser;             // The specific actor that caused the damage (can be self)

float DamageAmount = 100.0f;

UGameplayStatics::ApplyDamage(
    TargetActor,                  // The actor receiving damage
    DamageAmount,                 // The amount of damage to apply
    InstigatorController,         // The instigator of the damage
    DamageCauser,                 // The actor that caused the damage
    UDamageType::StaticClass()    // The damage type class (e.g., UDamageType::StaticClass() for generic damage)
);</code></pre>

                <h2>Apply Radial Damage</h2>
                <p>Applies damage in a spherical radius around a specified location. Useful for explosions or area-of-effect attacks.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

FVector DamageOrigin;             // The center of the damage radius
float DamageRadius = 200.0f;      // The radius of the damage effect
AActor* DamageCauser;             // The actor that caused the damage
AController* InstigatorController; // The controller that caused the damage

UGameplayStatics::ApplyRadialDamage(
    this,                          // World context object
    100.0f,                        // Base damage amount
    DamageOrigin,                  // Center location of the damage
    DamageRadius,                  // Radius within which damage is applied
    UDamageType::StaticClass(),    // The damage type class
    TArray&lt;AActor*&gt;(),             // Array of actors to ignore (can be empty)
    DamageCauser,                  // The actor that caused the damage
    InstigatorController,          // The instigator of the damage
    false                          // bDoFullDamage: If true, all actors within radius take full damage
);</code></pre>

                <h2>Get Game Mode</h2>
                <p>Retrieves the current game mode instance for the world. This is fundamental for accessing game rules and state.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

AGameModeBase* GameMode = UGameplayStatics::GetGameMode(this);
if (GameMode)
{
    // Cast to your specific GameMode class if needed
    // AMyGameMode* MyGameMode = Cast&lt;AMyGameMode&gt;(GameMode);
}</code></pre>

                <h2>Get Game State</h2>
                <p>Retrieves the current game state instance for the world. Contains information about the current state of the game.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

AGameStateBase* GameState = UGameplayStatics::GetGameState(this);
if (GameState)
{
    // Cast to your specific GameState class if needed
    // AMyGameState* MyGameState = Cast&lt;AMyGameState&gt;(GameState);
}</code></pre>

                <h2>Project World to Screen</h2>
                <p>Converts a 3D world coordinate into a 2D screen coordinate, useful for UI elements or overlays.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0); // Get the player controller

FVector WorldPosition; // The 3D world coordinate to convert

FVector2D ScreenPosition; // Output: The resulting 2D screen coordinate

if (PlayerController)
{
    UGameplayStatics::ProjectWorldToScreen(
        PlayerController,                  // The player controller to use for projection
        WorldPosition,                     // The world position to project
        ScreenPosition,                    // Output: The calculated screen position
        false                              // bPlayerViewportRelative: If true, coordinates are relative to the player's viewport
    );
    // ScreenPosition now holds the 2D coordinates on the screen
}</code></pre>

                <h2>Deproject Screen to World</h2>
                <p>Converts a 2D screen coordinate into a 3D world coordinate and direction. Essential for mouse interactions or placing objects based on screen input.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0); // Get the player controller

FVector2D ScreenPosition; // The 2D screen coordinate to deproject

FVector WorldPosition;    // Output: The calculated 3D world position
FVector WorldDirection;   // Output: The direction from the camera through the screen point

if (PlayerController)
{
    UGameplayStatics::DeprojectScreenToWorld(
        PlayerController,                  // The player controller to use for deprojection
        ScreenPosition,                    // The screen position to deproject
        WorldPosition,                     // Output: The calculated world position
        WorldDirection                     // Output: The direction vector from the camera
    );
    // WorldPosition and WorldDirection can now be used for raycasts or placement
}</code></pre>

                <h2>Open Level (by Name)</h2>
                <p>Loads and transitions the game to a different level. Requires the exact name of the target level.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

// The name of the level to open (e.g., "MyNewLevel", "ThirdPersonMap")
FName LevelNameToOpen = TEXT("ExampleMap");

UGameplayStatics::OpenLevel(
    this,                    // World context object
    LevelNameToOpen          // The name of the level to load
);</code></pre>

                <h2>Set Game Paused</h2>
                <p>Toggles the paused state of the game. This affects gameplay simulation and ticking.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

bool bShouldPauseGame = true; // Set to true to pause, false to unpause

UGameplayStatics::SetGamePaused(this, bShouldPauseGame);</code></pre>

                <h2>Spawn Decal at Location</h2>
                <p>Spawns a decal actor at a specific world location. Requires a <code>UMaterialInterface</code> that is set up as a decal material.</p>
                <p><strong>.h File Declaration:</strong></p>
                <pre><code class="language-cpp">private:
    // Assign a Decal Material in the Blueprint editor
    UPROPERTY(EditAnywhere, Category = "Decals")
    UMaterialInterface* DecalMaterial;</code></pre>
                <p><strong>.cpp File Implementation:</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;

UDecalComponent* SpawnedDecalComponent = nullptr;
FVector DecalSize;       // Define the size of the decal
FVector DecalLocation;   // Define the location for the decal
FRotator DecalRotation;  // Define the rotation for the decal
float DecalLifeSpan = 0.0f; // 0.0f means the decal lasts indefinitely

if (DecalMaterial)
{
    SpawnedDecalComponent = UGameplayStatics::SpawnDecalAtLocation(
        this,                 // World context object
        DecalMaterial,        // The material to use for the decal
        DecalSize,            // The size of the decal
        DecalLocation,        // The world location to spawn the decal
        DecalRotation,        // The rotation of the decal
        DecalLifeSpan         // How long the decal should exist (0 for infinite)
    );
}

if (SpawnedDecalComponent)
{
    // Decal spawned successfully
}</code></pre>

                <h2>Draw Debug Line</h2>
                <p>Draws a line in the world for debugging purposes. This line is visible in the editor and potentially in-game builds if enabled.</p>
                <pre><code class="language-cpp">FVector LineStart; // Start point of the line
FVector LineEnd;   // End point of the line

DrawDebugLine(
    GetWorld(),        // The world object
    LineStart,         // Start point of the line
    LineEnd,           // End point of the line
    FColor::Red,       // Color of the line
    false,             // Persistent: If true, the line stays until explicitly removed
    5.0f,              // Duration: How long the line stays visible (if not persistent)
    0,                 // Depth priority: For rendering order
    1.0f               // Line thickness
);</code></pre>

                <h2>Draw Debug Box</h2>
                <p>Draws a wireframe box in the world for debugging. Useful for visualizing collision volumes or areas.</p>
                <pre><code class="language-cpp">FVector BoxCenter; // The center of the box
FVector BoxExtent; // The half-size of the box along each axis (e.g., FVector(100, 100, 100) for a 200x200x200 box)

DrawDebugBox(
    GetWorld(),        // The world object
    BoxCenter,         // Center of the box
    BoxExtent,         // Extent (half-size) of the box
    FColor::Red,       // Color of the box
    false,             // Persistent: If true, the box stays until explicitly removed
    5.0f,              // Duration: How long the box stays visible (if not persistent)
    0,                 // Depth priority: For rendering order
    1.0f               // Line thickness
);</code></pre>

                <h2>Is Valid Check</h2>
                <p>Checks if an object pointer is valid (i.e., not null and not pending destruction). This is a fundamental safety check.</p>
                <p><strong>Common C++ Check:</strong></p>
                <pre><code class="language-cpp">AActor* ExampleActor = nullptr; // Assume this might be null or invalid

if (ExampleActor) // This implicitly checks if ExampleActor is not null
{
    // Actor is valid and can be used
}
else
{
    // Actor is null or invalid
}</code></pre>
                <p><strong>Using <code>UKismetSystemLibrary::IsValid</code> (closer to Blueprint):</strong></p>
                <pre><code class="language-cpp">#include &quot;Kismet/KismetSystemLibrary.h&quot;

AActor* ExampleActor = nullptr;

if (UKismetSystemLibrary::IsValid(ExampleActor))
{
    // Actor is valid
}
else
{
    // Actor is not valid
}</code></pre>

                <h2>Quit Game</h2>
                <p>Exits the game application. Can be used to close the game gracefully.</p>
                <pre><code class="language-cpp">#include &quot;Kismet/GameplayStatics.h&quot;
#include &quot;Kismet/KismetSystemLibrary.h&quot;

APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0); // Get the player controller

UKismetSystemLibrary::QuitGame(
    this,                        // World context object
    PlayerController,            // The player controller initiating the quit (can be null)
    EQuitPreference::Quit,       // EQuitPreference::Quit to exit, EQuitPreference::Background to background
    false                        // Ignore platform restrictions: Set to true to force quit on platforms that might prevent it
);</code></pre>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>
