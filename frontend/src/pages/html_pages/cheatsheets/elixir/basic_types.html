<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elixir Basic Types - Understand Core Data Structures</title>
    <meta name="description" content="Explore Elixir's fundamental data types including Integers, Floats, Atoms, Booleans, Nil, Binaries, Strings, and Regular Expressions. Learn their syntax and usage.">
    <meta name="keywords" content="Elixir basic types, Elixir data types, Elixir integers, Elixir floats, Elixir atoms, Elixir booleans, Elixir nil, Elixir binaries, Elixir strings, Elixir regex, Elixir programming, Elixir tutorial">
    <link rel="canonical" href="https://yourdomain.com/elixir/basic_types.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Elixir Basic Types - Understand Core Data Structures">
    <meta property="og:description" content="Explore Elixir's fundamental data types including Integers, Floats, Atoms, Booleans, Nil, Binaries, Strings, and Regular Expressions. Learn their syntax and usage.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://yourdomain.com/elixir/basic_types.html">
    <meta property="og:image" content="https://yourdomain.com/images/elixir-basic-types-og.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Elixir Basic Types - Understand Core Data Structures">
    <meta name="twitter:description" content="Explore Elixir's fundamental data types including Integers, Floats, Atoms, Booleans, Nil, Binaries, Strings, and Regular Expressions. Learn their syntax and usage.">
    <meta name="twitter:image" content="https://yourdomain.com/images/elixir-basic-types-twitter.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elixir Basic Types</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>Understanding Elixir's Basic Data Types</h2>
                <p>Elixir provides a rich set of fundamental data types that form the building blocks for any program. Understanding these types is crucial for effective Elixir development. This section details the core types, their syntax, and common usage patterns.</p>

                <h3>Integer Types</h3>
                <p>Integers in Elixir can be represented in various bases: decimal (base 10), hexadecimal (base 16), and binary (base 2). Regardless of how they are specified, all integers are stored internally as base 10 values. Underscores can be used for readability in large numbers.</p>
                <pre><code class="language-elixir">1234567 == 1_234_567                    # true
0xcafe  == 0xCAFE                       # true
0b10101 == 65793                        # true
0xCafe  == 0b1100101011111110           # true
0xCafe  == 51_966                       # true
Integer.to_string(51_966, 16) == "CAFE" # true
Integer.to_string(0xcafe) == "51996"    # true
</code></pre>

                <h3>Float Types</h3>
                <p>Elixir uses 64-bit double-precision floating-point numbers. Floats can be specified with an exponent using the <code>e</code> notation. Note that a float literal cannot begin or end with a decimal point.</p>
                <pre><code class="language-elixir">&gt; 1.2345
&gt; 0.001 == 1.0e-3 # true
&gt; .001            # syntax error!
</code></pre>

                <h3>Atom Types</h3>
                <p>Atoms are constants whose name is their value. They are typically used to represent fixed values or states. Atoms are named using a colon followed by characters that typically include letters, numbers, underscores, and sometimes question marks or exclamation points at the end. For atoms with special characters or spaces, they must be enclosed in double quotes.</p>
                <p>Atoms are stored in a global table and are never de-allocated, so it's advisable to avoid programmatic creation of atoms to prevent memory leaks. Use them for fixed identifiers and keys.</p>
                <p><img alt="Atom Naming Conventions" src="https://rawgit.com/itsgreggreg/elixir_quick_reference/80954a5e9bd06d5a009857a97bfad640d3cbd31a/images/atom-naming.png" /><br>
                To use other characters, you must quote the atom.</p>
                <pre><code class="language-elixir">&gt; :something
&gt; :_some_thing
&gt; :allowed?
&gt; :Some@Thing@12345
&gt; :"√ú√±√Æ√ß√∏d√© and Spaces"
&gt; Atom.to_string(:Yay!)  # "Yay!"
&gt; :123                   # syntax error!
</code></pre>

                <h3>Boolean Types</h3>
                <p>Elixir's boolean values, <code>true</code> and <code>false</code>, are actually syntactic sugar for the atoms <code>:true</code> and <code>:false</code>, respectively. They are not a distinct type but rather specific atoms.</p>
                <pre><code class="language-elixir">&gt; true  == :true     # true
&gt; false == :false    # true
&gt; is_boolean(:true)  # true
&gt; is_atom(false)     # true
&gt; is_boolean(:True)  # false!
</code></pre>

                <h3>Nil Type</h3>
                <p>Similar to booleans, <code>nil</code> in Elixir is syntactic sugar for the atom <code>:nil</code>. It represents the absence of a value and is not a special type but an atom.</p>
                <pre><code class="language-elixir">&gt; nil == :nil  # true
&gt; is_atom(nil) # true
</code></pre>

                <h3>Binary Types</h3>
                <p>Binaries are sequences of bytes enclosed in <code>&lt;&lt; &gt;&gt;</code> and separated by commas. By default, each number within a binary is treated as an 8-bit value. You can explicitly specify the size of each element using <code>::size(n)</code>, <code>::n</code>, or specific type specifiers like <code>::utf8</code>, <code>::utf16</code>, <code>::utf32</code>, or <code>::float</code>. If the total number of bits in a binary is not divisible by 8, it is considered a bitstring. Binaries can be concatenated using the <code>&lt;&gt;</code> operator.</p>
                <pre><code class="language-elixir">&gt; &lt;&lt;0,1,2,3&gt;&gt;
&gt; &lt;&lt;100&gt;&gt; == &lt;&lt;100::size(8)&gt;&gt;        # true
&gt; &lt;&lt;4::float&gt;&gt; == &lt;&lt;64, 16, 0, 0, 0, 0, 0, 0&gt;&gt;  # true
&gt; &lt;&lt;65::utf32&gt;&gt; == &lt;&lt;0, 0, 0, 65&gt;&gt;   # true
&gt; &lt;&lt;0::2, 1::2&gt;&gt; == &lt;&lt;1::4&gt;&gt;         # true
&gt; &lt;&lt;1,2&gt;&gt; &lt;&gt; &lt;&lt;3,4&gt;&gt; == &lt;&lt;1,2,3,4&gt;&gt;  # true
&gt; is_binary(&lt;&lt;1,2,3,4&gt;&gt;)             # true
&gt; is_binary(&lt;&lt;1::size(4)&gt;&gt;)          # false!, num of bits not devisible by 8
&gt; is_bitstring(&lt;&lt;1::size(4)&gt;&gt;)       # true
</code></pre>

                <h3>String Types</h3>
                <p>Strings in Elixir are UTF-8 encoded binaries, enclosed in double quotes (<code>"</code>). They can span multiple lines and support string interpolation using <code>#{}</code>, which can contain any valid Elixir expression. Like binaries, strings are concatenated using the <code>&lt;&gt;</code> operator.</p>
                <pre><code class="language-elixir">&gt; "This is a string."
&gt; "‚òÄ‚òÖ‚òÇ‚òª‚ôû‚òØ‚ò≠‚ò¢‚Ç¨‚Üí‚òé‚ô´‚ôé‚áß‚òÆ‚ôª‚åò‚åõ‚òò‚òä‚ôî‚ôï‚ôñ‚ò¶‚ô†‚ô£‚ô•‚ô¶‚ôÇ‚ôÄ"  # no problem :)
&gt; "This is an #{ Atom.to_string(:interpolated) } string."
&gt; "Where is " &lt;&gt; "my other half?"
&gt; "multi\nline" == "multi
line"                                    # true
&gt; &lt;&lt;69,108,105,120,105,114&gt;&gt; == "Elixir" # true
&gt; String.length("üé©")               # 1
&gt; byte_size("üé©")                   # 4
&gt; is_binary("any string")           # true
&gt; String.valid?("„Åì„Çì„Å´„Å°„ÅØ")         # true
&gt; String.valid?("hello" &lt;&gt; &lt;&lt;255&gt;&gt;) # false!
&gt; String.valid?(&lt;&lt;4&gt;&gt;)              # true
&gt; String.printable?(&lt;&lt;4&gt;&gt;)          # false! 4 is a valid UTF-8 codepoint, but is not printable.
</code></pre>

                <h4>Escape Sequences in Strings</h4>
                <p>Elixir strings support various escape sequences for special characters, including whitespace and control sequences.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Characters</th>
                            <th>Whitespace</th>
                            <th>Control Sequences</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>\"</code> ‚Äì double quote</td>
                            <td><code>\b</code> ‚Äì backspace</td>
                            <td><code>\a</code> ‚Äì bell/alert</td>
                        </tr>
                        <tr>
                            <td><code>\'</code> ‚Äì single quote</td>
                            <td><code>\f</code> - form feed</td>
                            <td><code>\d</code> - delete</td>
                        </tr>
                        <tr>
                            <td><code>\\</code> ‚Äì single backslash</td>
                            <td><code>\n</code> ‚Äì newline</td>
                            <td><code>\e</code> - escape</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>\s</code> ‚Äì space</td>
                            <td><code>\r</code> ‚Äì carriage return</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>\t</code> - tab</td>
                            <td><code>\0</code> - null byte</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>\v</code> ‚Äì vertical tab</td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
                <p>Additionally, <code>\x...</code> represents a character with its hexadecimal representation, and <code>\x{...}</code> allows for hexadecimal representations with one or more digits.</p>
                <pre><code class="language-elixir">&gt; "\x3f" == "?"      # true
&gt; "\x{266B}" == "‚ô´" # true
&gt; "\x{2660}" == "‚ô†" # true
</code></pre>

                <h3>Regular Expression Types</h3>
                <p>Regular expressions in Elixir are inherited from Erlang's <code>re</code> module and are Perl-compatible. They are defined using the <code>~r</code> sigil and can span multiple lines. Various modifiers can be appended to alter their behavior.</p>
                <p><strong>Modifiers</strong>:
                 - <code>u</code>: Enables Unicode-specific patterns and treats escapes like <code>\w</code>, <code>\W</code>, <code>\s</code> accordingly for Unicode.
                 - <code>i</code>: Ignores case during matching.
                 - <code>s</code>: Allows the dot (<code>.</code>) to match newline characters.
                 - <code>m</code>: Makes <code>^</code> and <code>$</code> match the start and end of each line, respectively. Use <code>\A</code> and <code>\z</code> for the start and end of the entire string.
                 - <code>x</code>: Ignores whitespace characters unless escaped, and <code>#</code> starts comments.
                 - <code>f</code>: Forces an unanchored pattern to match at the first possible position, even if it spans across a newline.
                 - <code>r</code>: Inverts the "greediness" of the regular expression.</p>
                <p><strong>To override newline treatment, start the pattern with</strong>:
                 - <code>(*CR)</code>: Carriage return
                 - <code>(*LF)</code>: Line feed
                 - <code>(*CRLF)</code>: Carriage return followed by line feed
                 - <code>(*ANYCRLF)</code>: Any of the three above
                 - <code>(*ANY)</code>: All Unicode newline sequences</p>
                <pre><code class="language-elixir">&gt; Regex.compile!("caf[e√©]") == ~r/caf[e√©]/ # true
&gt; Regex.match?(~r/caf[e√©]/, "caf√©")        # true
&gt; Regex.regex?(~r"caf[e√©]")                # true
&gt; Regex.regex?("caf[e√©]")                  # false! string not compiled regex
&gt; Regex.run(~r/hat: (.*)/, "hat: üé©", [capture: :all_but_first]) == ["üé©"]  # true
# Modifiers
&gt; Regex.match?(~r/mr. bojangles/i, "Mr. Bojangles") # true
&gt; Regex.compile!("mr. bojangles", "sxi")            # ~r/mr. bojangles/sxi
# Newline overrides
&gt; ~r/(*ANY)some\npattern/
</code></pre>
                <p>For more in-depth information on Elixir's data types and their usage, refer to the official <a href="https://hexdocs.pm/elixir/typespecs.html" target="_blank">Elixir documentation</a> and the <a href="https://www.regular-expressions.info/" target="_blank">Regular-Expressions.info</a> website for comprehensive regex resources.</p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>
