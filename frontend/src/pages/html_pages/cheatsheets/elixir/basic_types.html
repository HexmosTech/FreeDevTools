<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic Types</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Basic Types</h1>
        </div>
        <div class="content">
            <div class="markdown-content"><h2>Basic Types</h2>
<h3>Integer</h3>
<p>Can be specified in base 10, hex, or binary. All are stored as base 10.</p>
<p>```elixir</p>
<blockquote>
<p>1234567 == 1_234_567                    # true
0xcafe  == 0xCAFE                       # true
0b10101 == 65793                        # true
0xCafe  == 0b1100101011111110           # true
0xCafe  == 51_966                       # true
Integer.to_string(51_966, 16) == "CAFE" # true
Integer.to_string(0xcafe) == "51996"    # true
 ```</p>
</blockquote>
<h3>Float</h3>
<p>64bit double precision. Can be specified with an exponent. Cannot begin or end with <code>.</code>.</p>
<pre class="codehilite"><code class="language-elixir">&gt; 1.2345
&gt; 0.001 == 1.0e-3 # true
&gt; .001            # syntax error!
</code></pre>

<h3>Atom</h3>
<p>Constants whose name is their value. <br>
Are named in this format:</p>
<!-- :[_a-zA-z][a-zA-Z0-9@_]*[!?]{0,1} -->
<p><img alt="Atom Naming" src="https://rawgit.com/itsgreggreg/elixir_quick_reference/80954a5e9bd06d5a009857a97bfad640d3cbd31a/images/atom-naming.png" /><br>
To use other characters you must quote the atom.<br>
TODO: Note which characters can be used when quoted.<br>
Stored in a global table once used and never de-allocated so avoid programmatic creation.<br></p>
<pre class="codehilite"><code class="language-elixir">&gt; :something
&gt; :_some_thing
&gt; :allowed?
&gt; :Some@Thing@12345
&gt; :&quot;√ú√±√Æ√ß√∏d√© and Spaces&quot;
&gt; Atom.to_string(:Yay!)  # &quot;Yay!&quot;
&gt; :123                   # syntax error!
</code></pre>

<h3>Boolean</h3>
<p><code>true</code> and <code>false</code> are just syntactic sugar for <code>:true</code> and <code>:false</code> and not a special type.</p>
<pre class="codehilite"><code class="language-elixir">&gt; true  == :true     # true
&gt; false == :false    # true
&gt; is_boolean(:true)  # true
&gt; is_atom(false)     # true
&gt; is_boolean(:True)  # false!
</code></pre>

<h3>Nil</h3>
<p><code>nil</code> is syntactic sugar for <code>:nil</code> and is not a special type.</p>
<pre class="codehilite"><code class="language-elixir">&gt; nil == :nil  # true
&gt; is_atom(nil) # true
</code></pre>

<h3>Binary</h3>
<p>A binary is a sequence of bytes enclosed in <code>&lt;&lt; &gt;&gt;</code> and separated with <code>,</code>.<br>
By default each number is 8 bits though size can be specified with:<br>
<code>::size(n)</code>, <code>::n</code>, <code>::utf8</code>, <code>::utf16</code>, <code>::utf32</code> or <code>::float</code><br>
If the number of bits in a binary is not divisible by 8, it is considered a bitstring.<br>
Binaries are concatenated with <code>&lt;&gt;</code>.</p>
<pre class="codehilite"><code class="language-elixir">&gt; &lt;&lt;0,1,2,3&gt;&gt;
&gt; &lt;&lt;100&gt;&gt; == &lt;&lt;100::size(8)&gt;&gt;        # true
&gt; &lt;&lt;4::float&gt;&gt; == &lt;&lt;64, 16, 0, 0, 0, 0, 0, 0&gt;&gt;  # true
&gt; &lt;&lt;65::utf32&gt;&gt; == &lt;&lt;0, 0, 0, 65&gt;&gt;   # true
&gt; &lt;&lt;0::2, 1::2&gt;&gt; == &lt;&lt;1::4&gt;&gt;         # true
&gt; &lt;&lt;1,2&gt;&gt; &lt;&gt; &lt;&lt;3,4&gt;&gt; == &lt;&lt;1,2,3,4&gt;&gt;  # true
&gt; is_binary(&lt;&lt;1,2,3,4&gt;&gt;)             # true
&gt; is_binary(&lt;&lt;1::size(4)&gt;&gt;)          # false!, num of bits not devisible by 8
&gt; is_bitstring(&lt;&lt;1::size(4)&gt;&gt;)       # true
</code></pre>

<h3>String</h3>
<p>Strings are UTF-8 encoded binaries. They are enclosed in double quotes(<code>"</code>).<br>
They can span multiple lines and contain interpolations.<br>
Interpolations are enclosed in <code>#{}</code> and can contain any expression.<br>
Strings, being binaries, are concatenated with <code>&lt;&gt;</code>.</p>
<pre class="codehilite"><code class="language-elixir">&gt; &quot;This is a string.&quot;
&gt; &quot;‚òÄ‚òÖ‚òÇ‚òª‚ôû‚òØ‚ò≠‚ò¢‚Ç¨‚Üí‚òé‚ô´‚ôé‚áß‚òÆ‚ôª‚åò‚åõ‚òò‚òä‚ôî‚ôï‚ôñ‚ò¶‚ô†‚ô£‚ô•‚ô¶‚ôÇ‚ôÄ&quot;  # no problem :)
&gt; &quot;This is an #{ Atom.to_string(:interpolated) } string.&quot;
&gt; &quot;Where is &quot; &lt;&gt; &quot;my other half?&quot;
&gt; &quot;multi\nline&quot; == &quot;multi
line&quot;                                    # true
&gt; &lt;&lt;69,108,105,120,105,114&gt;&gt; == &quot;Elixir&quot; # true
&gt; String.length(&quot;üé©&quot;)               # 1
&gt; byte_size(&quot;üé©&quot;)                   # 4
&gt; is_binary(&quot;any string&quot;)           # true
&gt; String.valid?(&quot;„Åì„Çì„Å´„Å°„ÅØ&quot;)         # true
&gt; String.valid?(&quot;hello&quot; &lt;&gt; &lt;&lt;255&gt;&gt;) # false!
&gt; String.valid?(&lt;&lt;4&gt;&gt;)              # true
&gt; String.printable?(&lt;&lt;4&gt;&gt;)          # false! 4 is a valid UTF-8 codepoint, but is not printable.
</code></pre>

<h4>Escape Sequences</h4>
<table>
<thead>
<tr>
<th>characters</th>
<th>whitespace</th>
<th>control sequences</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\"</code> ‚Äì double quote</td>
<td><code>\b</code> ‚Äì backspace</td>
<td><code>\a</code> ‚Äì bell/alert</td>
</tr>
<tr>
<td><code>\'</code> ‚Äì single quote</td>
<td><code>\f</code> - form feed</td>
<td><code>\d</code> - delete</td>
</tr>
<tr>
<td><code>\\</code> ‚Äì single backslash</td>
<td><code>\n</code> ‚Äì newline</td>
<td><code>\e</code> - escape</td>
</tr>
<tr>
<td></td>
<td><code>\s</code> ‚Äì space</td>
<td><code>\r</code> ‚Äì carriage return</td>
</tr>
<tr>
<td></td>
<td><code>\t</code> - tab</td>
<td><code>\0</code> - null byte</td>
</tr>
<tr>
<td></td>
<td><code>\v</code> ‚Äì vertical tab</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>\x...</code> - character with hexadecimal representation. <br>
<code>\x{...}</code> - character with hexadecimal representation with one or more hexadecimal digits.<br></p>
<pre class="codehilite"><code class="language-elixir">&gt; &quot;\x3f&quot; == &quot;?&quot;      # true
&gt; &quot;\x{266B}&quot; == &quot;‚ô´&quot; # true
&gt; &quot;\x{2660}&quot; == &quot;‚ô†&quot; # true
</code></pre>

<h3>Regular Expression</h3>
<p>Inherited from Erlang's <code>re</code> module and are Perl compatible.<br>
Written literally with the <code>~r</code> <a href="#sigils">Sigil</a> and can span multiple lines.<br>
Can have a number of modifiers specified directly after the pattern.<br>
Many functions take a captures option that limits captures.</p>
<p><strong>Modifiers</strong>:
 - <code>u</code> enables unicode specific patterns like \p and changes escapes like \w, \W, \s and friends to also match on unicode. It expects valid unicode strings to be given on match
 - <code>i</code> ignore case
 - <code>s</code> dot matches newlines and also set newline to anycrlf.
 - <code>m</code> ^ and $ match the start and end of each line; use \A and \z to match the end or start of the string
 - <code>x</code> whitespace characters are ignored except when escaped and <code>#</code> delimits comments
 - <code>f</code> forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline
r - inverts the ‚Äúgreediness‚Äù of the regexp</p>
<p><strong>To override newline treatment start the pattern with</strong>:
 - <code>(*CR)</code> carriage return
 - <code>(*LF)</code> line feed
 - <code>(*CRLF)</code> carriage return, followed by linefeed
 - <code>(*ANYCRLF)</code> any of the three above
 - <code>(*ANY)</code> all Unicode newline sequences</p>
<pre class="codehilite"><code class="language-elixir">&gt; Regex.compile!(&quot;caf[e√©]&quot;) == ~r/caf[e√©]/ # true
&gt; Regex.match?(~r/caf[e√©]/, &quot;caf√©&quot;)        # true
&gt; Regex.regex?(~r&quot;caf[e√©]&quot;)                # true
&gt; Regex.regex?(&quot;caf[e√©]&quot;)                  # false! string not compiled regex
&gt; Regex.run(~r/hat: (.*)/, &quot;hat: üé©&quot;, [capture: :all_but_first]) == [&quot;üé©&quot;]  # true
# Modifiers
&gt; Regex.match?(~r/mr. bojangles/i, &quot;Mr. Bojangles&quot;) # true
&gt; Regex.compile!(&quot;mr. bojangles&quot;, &quot;sxi&quot;)            # ~r/mr. bojangles/sxi
# Newline overrides
&gt; ~r/(*ANY)some\npattern/
</code></pre></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>