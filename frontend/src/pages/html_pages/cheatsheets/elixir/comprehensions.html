<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elixir Comprehensions - Generate Lists and More</title>
    <meta name="description" content="Learn how to use Elixir comprehensions to efficiently generate lists, maps, and strings from enumerables and bitstrings with generators and filters.">
    <meta name="keywords" content="Elixir comprehensions, Elixir generators, Elixir filters, Elixir list generation, Elixir map generation, Elixir string generation, Elixir bitstrings, Elixir programming, functional programming">
    <link rel="canonical" href="https://example.com/elixir/comprehensions.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Elixir Comprehensions - Generate Lists and More">
    <meta property="og:description" content="Learn how to use Elixir comprehensions to efficiently generate lists, maps, and strings from enumerables and bitstrings with generators and filters.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/elixir/comprehensions.html">
    <meta property="og:image" content="https://example.com/images/elixir-comprehensions-og.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Elixir Comprehensions - Generate Lists and More">
    <meta name="twitter:description" content="Learn how to use Elixir comprehensions to efficiently generate lists, maps, and strings from enumerables and bitstrings with generators and filters.">
    <meta name="twitter:image" content="https://example.com/images/elixir-comprehensions-twitter.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elixir Comprehensions</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>Understanding Elixir Comprehensions</h2>
                <p>Elixir comprehensions provide a powerful and concise way to iterate over any enumerable or bitstring and construct new data structures. They are a fundamental tool for functional programming in Elixir, allowing for expressive data transformation.</p>

                <h2>Basic Comprehension Structure</h2>
                <p>The basic form of an Elixir comprehension involves a generator and a block of code to execute for each element. By default, comprehensions build lists. The syntax uses <code>for</code>, followed by generators, optional filters, and a <code>do</code> block.</p>
                <pre class="codehilite"><code class="language-elixir"># Basic list generation
&gt; for num &lt;- [1, 2, 3, 4], do: num * num
[1, 4, 9, 16]
</code></pre>

                <h2>Adding Filters to Comprehensions</h2>
                <p>Comprehensions can include filters to selectively process elements. Filters are boolean expressions that, if false, cause the current iteration to be skipped. This allows for conditional data inclusion.</p>
                <pre class="codehilite"><code class="language-elixir"># Comprehension with a filter for even numbers
&gt; for num &lt;- [1, 2, 3, 4], rem(num, 2) == 0, do: num * num
[4, 16]
</code></pre>

                <h2>Multiple Generators and Filters</h2>
                <p>Elixir comprehensions support multiple generators, enabling nested iteration. You can also combine multiple filters to create more complex selection criteria.</p>
                <pre class="codehilite"><code class="language-elixir"># Multiple generators for combining numbers and strings
&gt; for num &lt;- [1,2,3], str &lt;- [&quot;a&quot;, &quot;b&quot;], do: &quot;#{num}#{str}&quot;
[&quot;1a&quot;, &quot;1b&quot;, &quot;2a&quot;, &quot;2b&quot;, &quot;3a&quot;, &quot;3b&quot;]

# Multiple filters to refine results
&gt; for num &lt;- [1,2,3], str &lt;- [&quot;a&quot;, &quot;b&quot;], num !== 3, str !== &quot;a&quot;, do: &quot;#{num}#{str}&quot;
[&quot;1b&quot;, &quot;2b&quot;]
</code></pre>

                <h2>Pattern Matching in Generators</h2>
                <p>Generators can utilize pattern matching, which is particularly useful when working with maps or tuples. This allows you to extract specific values directly.</p>
                <pre class="codehilite"><code class="language-elixir"># Pattern matching to extract ages from a map
&gt; for {_, age} &lt;- %{doug: 4, lucy: 6, ralf: 10}, do: age
[4, 6, 10]
</code></pre>

                <h2>Building Different Data Structures with <code>into:</code></h2>
                <p>The <code>into:</code> option allows you to specify the target data structure, enabling the creation of maps, strings, or other Enumerable types directly from a comprehension.</p>
                <pre class="codehilite"><code class="language-elixir"># Building a map from a comprehension
&gt; for num &lt;- [1, 2, 3, 4], into: %{}, do: {num, num*num}
%{1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9, 4 =&gt; 16}

# Building a string from a comprehension
&gt; for num &lt;- [1, 2, 3, 4], into: &quot;&quot;, do: &quot;the square of #{num} is #{num * num}. &quot;
&quot;the square of 1 is 1. the square of 2 is 4. the square of 3 is 9. the square of 4 is 16. &quot;
</code></pre>

                <h2>Working with Bitstrings</h2>
                <p>Comprehensions offer a streamlined syntax for iterating over bitstrings, allowing you to extract individual bytes or bits, and even perform pattern matching on bit sizes.</p>
                <pre class="codehilite"><code class="language-elixir"># Iterating over bytes in a bitstring
&gt; for &lt;&lt;byte &lt;- &lt;&lt;255, 12, 55, 89&gt;&gt; &gt;&gt;, do: byte
[255, 12, 55, 89]

# Pattern matching on bit size
&gt; for &lt;&lt;bit::size(1) &lt;- &lt;&lt;42, 12&gt;&gt; &gt;&gt;, do: bit
[0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0]

# Shorthand for extracting RGB components
&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels &gt;&gt;, do: {r, g, b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
</code></pre>

                <h2>Comprehensions with Streams</h2>
                <p>Comprehensions integrate seamlessly with streams, allowing for lazy processing of large datasets without loading everything into memory at once. This is crucial for efficient handling of I/O operations.</p>
                <pre class="codehilite"><code class="language-elixir"># Processing a stream of input lines
stream = IO.stream(:stdio, :line)
for line &lt;- Enum.take(stream, 5), into: stream do
  String.upcase(line)
end
</code></pre>

                <h2>Further Reading</h2>
                <ul>
                    <li><a href="https://elixir-lang.org/getting-started/enumerables-and-streams.html#comprehensions" target="_blank" rel="noopener noreferrer">Elixir Documentation on Comprehensions</a></li>
                    <li><a href="https://learnyousomeelixir.com/enumerables-and-protocols#comprehensions" target="_blank" rel="noopener noreferrer">Learn You Some Elixir - Comprehensions</a></li>
                </ul>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>