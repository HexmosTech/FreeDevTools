<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modules</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Modules</h1>
        </div>
        <div class="content">
            <div class="markdown-content"><h2>Modules</h2>
<p>Modules organize code under a namespace.<br>
They can be meta-programmed but are defined at compile time and cannot be changed after, only replaced .<br>
Named according to the following format:<br></p>
<!-- [A-Z][_a-zA-Z0-9]*(?:\.[A-Z][_a-zA-Z0-9]*)* -->
<p><img alt="Module Naming" src="https://rawgit.com/itsgreggreg/elixir_quick_reference/75b339df6f6592dd123a8afad0449faae7bd36cc/images/module-naming.png" /></p>
<h3>Declaration</h3>
<pre class="codehilite"><code class="language-elixir">defmodule MyModule do
end
</code></pre>

<h3>Module Functions</h3>
<p>Names must begin with <code>a-z</code>.<br>
Names can contain <code>a-Z</code>, <code>A-Z</code>, <code>0-9</code> and <code>_</code>.<br>
May end with <code>?</code> or <code>!</code>.<br></p>
<pre class="codehilite"><code class="language-elixir">defmodule MyModule do
  def my_function do
    IO.puts(&quot;Hello from my function&quot;)
  end
end
</code></pre>

<p><code>def</code> is actually a macro, and like calling any macro, <a href="#do-end">do ... end</a> can be written as a one liner:</p>
<pre class="codehilite"><code class="language-elixir">defmodule MyModule do
  def my_function, do: IO.puts(&quot;Hello from my function&quot;)
end
</code></pre>

<p>Inside of the defining module, functions may be called by name. Outside they must be called with the defining Module's name and a <code>.</code>. Eg: <code>IO.puts()</code></p>
<pre class="codehilite"><code class="language-elixir">defmodule MyModule do
  def function1 do
    IO.puts &quot;func 1&quot;
  end
  def function2 do
    function1
    IO.puts &quot;funct 2&quot;
  end
end

&gt; MyModule.function2
</code></pre>

<p>Arguments are passed to functions positionally and can have default arguments.<br>
Arguments can be of any Type.</p>
<pre class="codehilite"><code class="language-elixir">defmodule MyModule do
#                         ⇣ indicates &quot;earthlings&quot; to be the default for who
  def greet(greeting, who \\ &quot;earthlings&quot;) do
    IO.puts(&quot;#{greeting} #{who}&quot;)
  end
end

&gt; MyModule.greet(&quot;'sup&quot;, &quot;y'all?&quot;)  # &quot;'sup y'all?&quot;
&gt; MyModule.greet(&quot;greetings&quot;)       # &quot;greetings earthlings&quot;
</code></pre>

<p>Module functions can be defined multiple times to support different configurations of arguments.</p>
<pre class="codehilite"><code class="language-elixir">defmodule MyModule do
  def greet() do
    greet(&quot;hello&quot;, &quot;you&quot;)
  end
  def greet(greeting, who) do
    IO.puts(&quot;#{greeting} #{who}&quot;)
  end
end

&gt; MyModule.printer(&quot;hello&quot;)  # &quot;hello&quot;
&gt; MyModule.printer([1,2,3])  # [1,2,3]
&gt; MyModule.printer()         # &quot;nothing passed&quot;
</code></pre>

<p>They can also be defined multiple times to Pattern Match on arguments passed.</p>
<pre class="codehilite"><code class="language-elixir">def is_it_the_number_2?(2) do
  true
end
def is_it_the_number_2(value) do
  false
end
</code></pre>

<p>You can ignore arguments with <code>_</code> and our previous example is better written as</p>
<pre class="codehilite"><code class="language-elixir">def is_it_the_number_2?(2) do
  true
end
#                      ⇣ underscore ignores argument
def is_it_the_number_2(_) do
  false
end
</code></pre>

<p>Module function definitions can have <a href="#guards">Guards</a>.</p>
<pre class="codehilite"><code class="language-elixir">def square(n) when is_number(n), do: n * n
def square(_), do: raise &quot;not a number&quot;
</code></pre>

<h3>Private Functions</h3>
<p>To make a function private to a module use <code>defp</code> instead of <code>def</code>.</p>
<pre class="codehilite"><code class="language-elixir">defmodule ModA do
  defp hi, do: IO.puts &quot;Hello from ModA&quot;
  def say_hi, do: hi
end
ModA.say_hi
# Hello from ModA
ModA.hi
# ** (UndefinedFunctionError) undefined function ModA.hi/0 ModA.hi()
</code></pre>

<h3>Working with other modules</h3>
<p>Inside of a module you can use one of the 4 directives to interact with other modules.</p>
<h4>import</h4>
<p><code>import SomeModule</code> brings all modules and macros of SomeModule into the enclosing module so you can use them un-namespaced<br>
<code>import</code> can take either an <code>only:</code> or <code>except:</code> list in which you specify functions and macros to include.<br>
Alternatively <code>import SomeModule, only:</code> can take <code>:functions</code> or <code>:macros</code> to specify only those.</p>
<pre class="codehilite"><code class="language-elixir">def ModA do
  import ModB  # All Functions and Macros in ModB
  import ModB, except: [destroy_planet: 1] # All Functions and Macros except destroy_planet/1
  import ModB, only: :functions # All functions, no macros
  import ModB, only: [say_hi: 0, fibonacci: 1] # Only the specified functions or macros
end
</code></pre>

<h4>require</h4>
<p><code>require SomeModule</code> allows you to use macros of SomeModule. It also makes sure that SomeModule is compiled before the enclosing module.</p>
<h4>use</h4>
<p><code>use SomeModule</code> first <strong>requires SomeModule</strong> and then calls the macro SomeModule.__using__. It is often used to perform setup for metaprogramming.</p>
<h4>alias</h4>
<p><code>alias SomeVery.Long.ModuleName, as: SVLMN</code> is used simply to shorten a module name to cut down on typing.</p>
<h3>Attributes</h3>
<p>Pieces of data that can be thought of as metadata or constants for a module.<br>
They are inlined by the compiler and cannot be changed at runtime.<br>
They can be set multiple times and the value used will be the value set when the function is defined.</p>
<pre class="codehilite"><code class="language-elixir">defmodule ModA do
  @name &quot;April&quot;
  def first, do: @name
  @name &quot;O'Neal&quot;
  def last, do: @name
end
</code></pre>

<p>TODO:
 - @external_resource
 - Better explanation of attributes in relation to metaprogramming</p>
<h3>Documentation</h3>
<p>Elixir has documentation built in and you can document your modules and functions with Attributes. <br>
<code>@moduledoc</code> describes your module. <br>
<code>@doc</code> describes module functions.</p>
<pre class="codehilite"><code class="language-elixir">defmodule MathUtils do
  @moduledoc &quot;&quot;&quot;
  Random math related functions
  &quot;&quot;&quot;

  @doc &quot;Squares the given number.&quot;
  def square(n), do: n*n
end
</code></pre>

<h3>Introspection</h3>
<ul>
<li><code>__info__(:functions)</code></li>
</ul></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>