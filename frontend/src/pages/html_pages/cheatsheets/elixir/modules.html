<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elixir Modules Explained - Organize and Structure Your Code</title>
    <meta name="description" content="Learn how to use Elixir modules to organize your code, define functions, and manage namespaces effectively. Understand module declarations, function definitions, private functions, and more.">
    <meta name="keywords" content="Elixir modules, Elixir code organization, Elixir namespaces, Elixir functions, Elixir defmodule, Elixir defp, Elixir import, Elixir require, Elixir use, Elixir alias, Elixir attributes, Elixir documentation, Elixir introspection">
    <link rel="canonical" href="https://example.com/elixir/modules.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Elixir Modules Explained - Organize and Structure Your Code">
    <meta property="og:description" content="Learn how to use Elixir modules to organize your code, define functions, and manage namespaces effectively. Understand module declarations, function definitions, private functions, and more.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/elixir/modules.html">
    <meta property="og:image" content="https://example.com/images/elixir-modules-og.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Elixir Modules Explained - Organize and Structure Your Code">
    <meta name="twitter:description" content="Learn how to use Elixir modules to organize your code, define functions, and manage namespaces effectively. Understand module declarations, function definitions, private functions, and more.">
    <meta name="twitter:image" content="https://example.com/images/elixir-modules-twitter.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elixir Modules</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>Understanding Elixir Modules</h2>
                <p>Elixir modules are fundamental for organizing code under a namespace. They allow developers to group related functions and data, promoting modularity and maintainability. While modules can be meta-programmed, their definitions are fixed at compile time and cannot be altered during runtime; they can only be replaced.</p>
                <p>Modules are named according to a specific convention to ensure clarity and avoid conflicts. The standard format for module names is:</p>
                <!-- [A-Z][_a-zA-Z0-9]*(?:\.[A-Z][_a-zA-Z0-9]*)* -->
                <p><img alt="Elixir Module Naming Convention" src="https://rawgit.com/itsgreggreg/elixir_quick_reference/75b339df6f6592dd123a8afad0449faae7bd36cc/images/module-naming.png" /></p>

                <h2>Declaring and Defining Module Functions</h2>
                <p>A module is declared using the <code>defmodule</code> keyword, followed by the module name and a <code>do...end</code> block. Inside this block, functions are defined using <code>def</code>. Function names must start with a lowercase letter (<code>a-z</code>) and can include uppercase letters, numbers, and underscores. They may optionally end with a question mark (<code>?</code>) for predicates or an exclamation mark (<code>!</code>) for functions that may have side effects or raise errors.</p>
                <pre><code class="language-elixir">defmodule MyModule do
end
</code></pre>

                <h3>Defining Module Functions</h3>
                <p>Functions within a module are defined using <code>def</code>. The <code>def</code> keyword is actually a macro. Similar to other macro calls, the <code>do...end</code> block for a function definition can be written concisely on a single line using <code>do:</code>.</p>
                <pre><code class="language-elixir">defmodule MyModule do
  def my_function do
    IO.puts("Hello from my function")
  end
end
</code></pre>

                <p>A one-liner definition:</p>
                <pre><code class="language-elixir">defmodule MyModule do
  def my_function, do: IO.puts("Hello from my function")
end
</code></pre>

                <h3>Calling Module Functions</h3>
                <p>Functions defined within a module can be called directly by their name if the call is made from within the same module. However, when calling a function from outside its defining module, you must qualify the function name with the module's name, separated by a dot (<code>.</code>). For example, <code>IO.puts()</code> is called from outside the <code>IO</code> module.</p>
                <pre><code class="language-elixir">defmodule MyModule do
  def function1 do
    IO.puts "func 1"
  end
  def function2 do
    function1
    IO.puts "funct 2"
  end
end

# Calling function2 from outside MyModule
# &gt; MyModule.function2
</code></pre>

                <h3>Function Arguments and Defaults</h3>
                <p>Arguments are passed to Elixir functions positionally. Default values can be assigned to arguments, making them optional. Arguments can be of any data type.</p>
                <pre><code class="language-elixir">defmodule MyModule do
  # The 'who' argument defaults to "earthlings" if not provided
  def greet(greeting, who \\ "earthlings") do
    IO.puts("#{greeting} #{who}")
  end
end

# Calling with both arguments
# &gt; MyModule.greet("'sup", "y'all?")  # Output: "'sup y'all?"

# Calling with only the required argument
# &gt; MyModule.greet("greetings")       # Output: "greetings earthlings"
</code></pre>

                <h3>Function Overloading with Pattern Matching</h3>
                <p>Elixir supports defining multiple function clauses with the same name but different argument patterns. This allows for a form of overloading, where the most specific matching clause is executed. This is particularly useful for handling different input types or states.</p>
                <pre><code class="language-elixir">defmodule MyModule do
  # Default function clause
  def greet() do
    greet("hello", "you")
  end

  # Function clause with specific arguments
  def greet(greeting, who) do
    IO.puts("#{greeting} #{who}")
  end
end

# Example usage:
# &gt; MyModule.greet("hello")  # Output: "hello you"
# &gt; MyModule.greet()         # Output: "hello you" (calls the default greet)
</code></pre>

                <p>Pattern matching can also be used to handle specific values or ignore arguments.</p>
                <pre><code class="language-elixir">def is_it_the_number_2?(2) do
  true
end

# The underscore '_' ignores the argument value
def is_it_the_number_2?(_) do
  false
end
</code></pre>

                <h3>Guards in Function Definitions</h3>
                <p>Function definitions can be augmented with guards using the <code>when</code> keyword. Guards provide additional conditions that must be met for a function clause to be selected. This allows for more precise control over function execution based on argument properties.</p>
                <pre><code class="language-elixir">def square(n) when is_number(n), do: n * n
def square(_), do: raise "Input must be a number"
</code></pre>

                <h2>Private Functions</h2>
                <p>To define functions that are only accessible within the defining module, use <code>defp</code> instead of <code>def</code>. This helps in encapsulating implementation details and preventing unintended external access.</p>
                <pre><code class="language-elixir">defmodule ModA do
  # Private function
  defp hi, do: IO.puts "Hello from ModA"

  # Public function that calls the private function
  def say_hi, do: hi
end

# Calling the public function works
# ModA.say_hi
# Output: Hello from ModA

# Calling the private function from outside results in an error
# ModA.hi
# ** (UndefinedFunctionError) undefined function ModA.hi/0
# ModA.hi()
</code></pre>

                <h2>Interacting with Other Modules</h2>
                <p>Elixir provides several directives to manage how modules interact with each other:</p>

                <h3><code>import</code></h3>
                <p><code>import SomeModule</code> brings all functions and macros from <code>SomeModule</code> into the current module's scope, allowing them to be called without the module name prefix. The <code>import</code> directive can be refined using <code>only:</code> or <code>except:</code> options to specify which functions or macros to include or exclude.</p>
                <pre><code class="language-elixir">defmodule ModA do
  # Import all functions and macros from ModB
  import ModB

  # Import all except destroy_planet/1
  import ModB, except: [destroy_planet: 1]

  # Import only functions from ModB, excluding macros
  import ModB, only: :functions

  # Import only specific functions or macros
  import ModB, only: [say_hi: 0, fibonacci: 1]
end
</code></pre>

                <h3><code>require</code></h3>
                <p><code>require SomeModule</code> ensures that <code>SomeModule</code> is compiled before the current module and allows you to use macros defined in <code>SomeModule</code>. This is crucial for using macro-based libraries.</p>

                <h3><code>use</code></h3>
                <p><code>use SomeModule</code> first <code>requires SomeModule</code> and then executes the <code>SomeModule.__using__/1</code> macro. This directive is commonly used for setting up metaprogramming contexts or applying predefined behaviors.</p>

                <h3><code>alias</code></h3>
                <p><code>alias SomeVery.Long.ModuleName, as: SVLMN</code> is used to create a shorter, more convenient alias for a module name. This reduces verbosity when referring to long module names repeatedly.</p>

                <h2>Module Attributes</h2>
                <p>Module attributes are pieces of data, akin to metadata or constants, associated with a module. They are inlined by the compiler and cannot be modified at runtime. If an attribute is set multiple times within a module, the value used will be the one set closest to the point of usage.</p>
                <pre><code class="language-elixir">defmodule ModA do
  @name "April"
  def first, do: @name

  @name "O'Neal"
  def last, do: @name
end

# &gt; ModA.first
# "April"
# &gt; ModA.last
# "O'Neal"
</code></pre>

                <p>TODO: Add details on <code>@external_resource</code> and provide a more in-depth explanation of attributes in relation to metaprogramming.</p>

                <h2>Documentation with Attributes</h2>
                <p>Elixir has built-in support for documentation generation. You can document modules and functions using specific attributes:</p>
                <ul>
                    <li><code>@moduledoc</code>: Describes the module itself.</li>
                    <li><code>@doc</code>: Describes a module function.</li>
                </ul>
                <pre><code class="language-elixir">defmodule MathUtils do
  @moduledoc """
  Provides various utility functions for mathematical operations.
  This module is designed to be a helpful resource for common math tasks.
  """

  @doc "Squares the given number."
  def square(n), do: n*n
end
</code></pre>

                <h2>Introspection</h2>
                <p>Modules in Elixir support introspection, allowing you to query information about them at runtime. A common introspection function is:</p>
                <ul>
                    <li><code>__info__(:functions)</code>: Returns a list of all public functions defined in the module.</li>
                </ul>
                <p>For example, <code>MyModule.__info__(:functions)</code> would return information about the functions defined in <code>MyModule</code>.</p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>