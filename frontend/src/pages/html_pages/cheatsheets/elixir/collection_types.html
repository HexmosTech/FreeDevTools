<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collection Types</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Collection Types</h1>
        </div>
        <div class="content">
            <div class="markdown-content"><h2>Collection Types</h2>
<h3>List</h3>
<p>Simple linked lists that can be of any size and can have elements of any type.<br>
They are enclosed in <code>[ ]</code> and elements are comma separated.<br>
Concatenated with <code>++</code> and subtracted with <code>--</code>.<br>
Can be constructed with the cons operator <code>|</code>.<br>
Best for sequential access, fastest when elements are added and subtracted from the head.<br>
Instead of building a list by adding to its tail, add to the head and reverse the list.<br>
List implements the enumerable protocol so we use Enum for many common operations.</p>
<pre class="codehilite"><code class="language-elixir">&gt; [1, 2, 3.4, &quot;a&quot;, &quot;b&quot;, :c, [:d]]
&gt; [ 1 | [2 | [3]]] == [1, 2, 3]   # true
&gt; [1, 2, 3.4] ++ [&quot;a&quot;, &quot;b&quot;, :c]   # [1, 2, 3.4, &quot;a&quot;, &quot;b&quot;, :c]
&gt; [1, 2, 3.4, &quot;a&quot;, &quot;b&quot;, :c, [:d]] -- [2, &quot;a&quot;, &quot;c&quot;]  # [1, 3.4, &quot;b&quot;, :c, [:d]]
&gt; hd [1, 2, 3]               # 1
&gt; tl [1, 2, 3]               # [2, 3]
&gt; length [:a, :b, :c, :d]    # 4
&gt; Enum.reverse [:a, :b, :c]  # [:c, :b, :a]
&gt; Enum.member? [:a, :b], :b  # true
&gt; Enum.join [:a, :b], &quot;_&quot;    # &quot;a_b&quot;
&gt; Enum.at [:a, :b, :c], 1    # :b
</code></pre>

<h3>Charlist</h3>
<p>A <a href="#list">List</a> of UTF-8 codepoints.<br>
Other than syntax they are exactly the same as Lists and are not a unique class.<br>
Can span multiple lines and are delimited with single quotes <code>'</code>.<br>
Have the same <a href="#escape-sequences">Escape Sequences</a> as String.<br></p>
<pre class="codehilite"><code class="language-elixir">&gt; 'char list'
&gt; [108, 105, 115, 116] == 'list'  # true
&gt; 'turbo' ++ 'pogo'               # 'turbopogo'
&gt; 'char list' -- 'a l'            # 'christ'
&gt; hd 'such list' == ?s            # true
&gt; String.to_char_list &quot;tacosalad&quot; # 'tacosalad'
&gt; List.to_string 'frijoles'       # &quot;frijoles&quot;
&gt; [?Y, ?e, ?a, ?h] == 'Yeah'      # true
</code></pre>

<h3>Tuple</h3>
<p>Can be of any size and have elements of any type.<br>
Elements are stored contiguously in memory.<br>
Enclosed in <code>{ }</code> and elements are comma separated.<br>
Fast for index-based access, slow for a large number of elements.<br></p>
<pre class="codehilite"><code class="language-elixir">&gt; { :a, 1, {:b}, [2]}
&gt; put_elem({:a}, 0, :b) # {:b}
&gt; elem({:a, :b, :c}, 1) # b
&gt; Tuple.delete_at({:a, :b, :c}, 1) # {:a, :c}
&gt; Tuple.insert_at({:a, :c}, 1, :b) # {:a, :b, :c}
&gt; Tuple.to_list({:a, :b, :c})      # [:a, :b, :c]
</code></pre>

<h3>Keyword List</h3>
<p>A List of 2 element Tuples where each Tuple's first element is an Atom.<br>
This atom is refered to as the keyword, or key.<br>
Have a special concice syntax that omits the Tuple's brackets and places the key's colon on the right.<br>
Being Lists they:
   - are order as specified
   - can have duplicate elements and multiple elements with the same key
   - are fastest when accessed at the head.
   - are concatenated with <code>++</code> and subtracted with <code>--</code>.<br></p>
<p>Elements can be accessed with <code>[:key]</code> notation. The first Element with a matching <code>:key</code> will be returned.<br>
2 Keyword Lists are only equal if all elements are equal and in the same order.</p>
<pre class="codehilite"><code class="language-elixir"># Full Syntax
&gt; [{:a, &quot;one&quot;}, {:b, 2}]
# Concice Syntax
&gt; [a: &quot;one&quot;, b: 2]
&gt; [a: 1] ++ [a: 2, b: 3] == [a: 1, a: 2, b: 3] # true
&gt; [a: 1, b: 2] == [b: 2, a: 1]         # false! elements are in different order
&gt; [a: 1, a: 2][:a] == 1                # true
&gt; Keyword.keys([a: 1, b: 2])           # [:a, :b]
&gt; Keyword.get_values([a: 1, a: 2], :a) # [1, 2]
&gt; Keyword.keyword?([{:a,1}, {:b,2}])   # true
&gt; Keyword.keyword?([{:a,1}, {&quot;b&quot;,2}])  # false! &quot;b&quot; is not an Atom
&gt; Keyword.delete([a: 1, b: 2], :a)     # [b: 2]
</code></pre>

<h3>Map</h3>
<p>Key - Value store where Keys and Values are of any type.<br>
Cannot have multiple values for the same key and are unordered.<br>
<code>Map</code>s are enclosed in <code>%{ }</code>, elements are comma seperated, and elemets have the form: key <code>=&gt;</code> value.<br>
If all keys are <code>Atom</code>s, the <code>=&gt;</code> can be omitted and the <code>Atom</code>'s <code>:</code> must be on the right.<br>
Values are accessed with <code>[key]</code> notation.<br>
Maps can be accessed with <code>.key</code> notation if key is an <code>Atom</code>.<br>
Maps can be updated by enclosing them in <code>%{}</code> and using the cons <code>|</code> operator.<br>
Maps can be of any size and are fastest for key based lookup.</p>
<pre class="codehilite"><code class="language-elixir">&gt; %{:a =&gt; 1, 1 =&gt; [&quot;list&quot;], [2,3,4] =&gt; {&quot;a&quot;, &quot;b&quot;}}
&gt; %{:a =&gt; 1, :b =&gt; 2} == %{a: 1, b: 2}              # true
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;, a: 1} == %{a: 1, b: &quot;two&quot;}  # true
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;} == %{b: &quot;two&quot;, a: &quot;one&quot;}    # true
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;}[:b]                         # &quot;two&quot;
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;}.b                           # &quot;two&quot;
&gt; %{a: &quot;one&quot;, a: 1} == %{a: 1}                      # true
&gt; %{:a =&gt; &quot;one&quot;, &quot;a&quot; =&gt; &quot;two&quot;}.&quot;a&quot; == &quot;two&quot;         # false! watchout
&gt; Map.keys( %{a: 1, b: 2} ) == [:a, :b]             # true
&gt; %{ %{a: 1, b: 2, c: 3} | :a =&gt; 4, b: 5 }          # %{a: 4, b: 5, c: 3}
&gt; Map.merge( %{a: 1, b: 2}, %{a: 4, c: 3} )         # %{a: 4, b: 2, c: 3}
&gt; Map.put( %{a: 1}, :b, 2 ) == %{a: 1, b: 2}        # true
&gt; Kernel.get_in # TODO
&gt; Kernel.put_in # TODO
</code></pre>

<h3>Struct</h3>
<p>Structs can be thought of as bare Maps with pre-defined keys, default values and where the keys must be atoms.<br>
Structs are defined at the top level of a Module and take the Module's name.<br>
Structs do not implement the Access or Enumerable protocol and can be considered bare Maps.<br>
Structs have a special field called <code>__struct__</code> that holds the name of the struct.</p>
<pre class="codehilite"><code class="language-elixir">defmodule City do
  defstruct name: &quot;New Orleans&quot;, founded: 1718
end
nola = %City{}
chi =  %City{name: &quot;Chicago&quot;, founded: 1833}
nola.name   # &quot;New Orleans&quot;
chi.founded # 1833
nola.__struct__ # City
</code></pre>

<h3>Range</h3>
<p>Used to specify the first and last elements of something.<br>
Just a Struct of type Range with a <code>first</code> field and a <code>last</code> field.<br>
Have a special <code>..</code> creation syntax but can also be created like any other struct.</p>
<pre class="codehilite"><code class="language-elixir">&gt; a = 5..10
&gt; b = Range.new(5, 10)
&gt; c = %Range{first: 5, last: 10}
&gt; Range.range?(c)   # true
&gt; Enum.each(5..10, fn(n) -&gt; n*n end) # prints all the squares of 5..10
&gt; Map.keys(5..10)   # [:__struct__, :first, :last]
&gt; (5..10).first     # 5
</code></pre>

<h3>Streams</h3>
<p>Lazy enumerables.<br>
Are created out of enumerables with functions in the <code>Stream</code> module.<br>
Elements are not computed until a method from the <code>Enum</code> module is called on them.<br></p>
<pre class="codehilite"><code class="language-elixir">&gt; a = Stream.cycle 'abc'
#Function&lt;47.29647706/2 in Stream.unfold/2&gt; # Infinate Stream created
&gt; Enum.take a, 10                           # Enum.take computes the 10 elements
'abcabcabca'
</code></pre>

<p>With <a href="http://elixir-lang.org/docs/stable/elixir/Stream.html#unfold/2">Stream.unfold/2</a> you can create an arbitrary stream.</p>
<pre class="codehilite"><code class="language-elixir">&gt; s = Stream.unfold( 5, 
  fn 0 -&gt; nil            # returning nil halts the stream
     n -&gt; {n, n-1}       # return format {next-val, rest}
  end)
&gt; Enum.to_list(s)
[5, 4, 3, 2, 1]
</code></pre></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>