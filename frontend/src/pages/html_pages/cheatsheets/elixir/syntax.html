<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syntax</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Syntax</h1>
        </div>
        <div class="content">
            <div class="markdown-content"><h2>Syntax</h2>
<h3>Variables</h3>
<p>Are declared and initialized upon use.<br>
Are named in the following format:</p>
<!-- [_a-z][_a-zA-z0-9]*[!?]? -->
<p><img alt="variable naming" src="https://rawgit.com/itsgreggreg/elixir_quick_reference/50ffe1e533896247fbb6429b72f83cdbb1186a8a/images/variable-naming.png" /><br>
Can hold any data structure and can be assigned more than once.</p>
<pre class="codehilite"><code class="language-elixir">&gt; something = :anything
&gt; something = [&quot;a&quot;, &quot;list&quot;, &quot;of&quot;, &quot;strings&quot;]
&gt; _yeeHaw1234! = %{:a =&gt; :b}
</code></pre>

<h3>Operators</h3>
<h4>Standard infix</h4>
<ul>
<li>Equality <code>==</code>, <code>!=</code></li>
<li>Strict equality <code>===</code> and <code>!==</code> do not coerce Floats to Integers. <code>1 === 1.0 #false</code></li>
<li>Comparison <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
<li>Logic, short-circuiting <code>&amp;&amp;</code> and <code>||</code></li>
<li>Boolean only Logic, short-circuiting <code>and</code> and <code>or</code>. (Only left side must be boolean)</li>
<li>Math <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
</ul>
<h4>Standard prefix</h4>
<ul>
<li>Negation, any type <code>!</code>, <code>!1 == false</code></li>
<li>Negation, boolean only <code>not</code>, <code>not is_atom(5) == true</code></li>
</ul>
<h4>= (match)</h4>
<p>left <code>=</code> right<br>
Performs a <a href="#pattern-matching">Pattern Match</a>. </p>
<h4>^ (pin)</h4>
<p>Used to pin the value of a variable in the left side of a <a href="#pattern-matching">Pattern Match</a>.</p>
<pre class="codehilite"><code class="language-elixir">a = &quot;thirty hams&quot;
{b, ^a} = {:i_need, &quot;thirty hams&quot;}            # `b` is set to `:i_need`
{^a, {^a}} = {&quot;thirty hams&quot;, {&quot;thirty hams&quot;}} # nothing is set, but the match succedes
</code></pre>

<h4>|&gt; (pipe)</h4>
<p><code>|&gt;</code><br>
Takes the result of a statement on its left and passes as the first argument to the function on its right.<br>
The statement on the left can be on the preceeding line of code.</p>
<pre class="codehilite"><code class="language-elixir">&gt; [1,2,3] |&gt; hd |&gt; Integer.to_string |&gt; IO.inspect # &quot;1&quot;
# ⇣ doesn't work in iex
hd([1,2,3])
|&gt; Integer.to_string
|&gt; IO.inspect  # &quot;1&quot;
</code></pre>

<h4>=~ (string match)</h4>
<p><code>=~</code><br>
Takes a string on the left and on the right either a string or a regular expression.<br>
If the string on the right is a substring of left, <code>true</code> is returned.<br>
If the regular expression on the right matches the string on the left, <code>true</code> is returned.<br>
Otherwise <code>false</code> is returned.</p>
<pre class="codehilite"><code class="language-elixir">&gt; &quot;abcd&quot; =~ ~r/c(d)/ # true
&gt; &quot;abcd&quot; =~ ~r/e/    # false
&gt; &quot;abcd&quot; =~ &quot;bc&quot;     # true
&gt; &quot;abcd&quot; =~ &quot;ad&quot;     # false
</code></pre>

<h4>? (codepoint)</h4>
<p><code>?</code><br>
Returns the UTF-8 codepoint of the character immediately to its right.<br>
Can only take one character, accepts <a href="#escape-sequences">Escape Sequences</a>.<br>
<strong>Remember</strong> <a href="#charlist">Charlists</a> are just lists of UTF-8 codepoints.</p>
<pre class="codehilite"><code class="language-elixir">&gt; ?a   # 97
&gt; ?♫   # 9835
&gt; ?\s  # 32
&gt; ??   # 63
&gt; [?♀, ?!] == '♀!'  # true
</code></pre>

<h4>&amp; (capture)</h4>
<ul>
<li>TODO</li>
</ul>
<h4>Ternary</h4>
<p>Elixir has no ternary operator. The same effect though can be achieved with the <code>if</code> macro.</p>
<pre class="codehilite"><code class="language-elixir">&gt; a = if true, do: &quot;True!&quot;, else: &quot;False!&quot;
&gt; a == &quot;True!&quot;  # true
</code></pre>

<h4>in</h4>
<p>left <code>in</code> right.<br>
Used to check if the <strong>enumerable</strong> on the right contains the data structure on the left.<br>
Right hand side must implement the Enumerable Protocol.</p>
<pre class="codehilite"><code class="language-elixir">&gt; :b in [:a, :b, :c] # true
&gt; [:c] in [1,3,[:c]] # true
&gt; :ok in {:ok} # ERROR: protocol Enumerable not implemented for {:ok}
</code></pre>

<h3>Comments</h3>
<p><code>#</code> indicates that itself and anything after it until a new line is a comment. That is all.</p>
<h3>Semicolons</h3>
<p>Semicolons can be used to terminate statements but in practice are rarely if ever used.<br>
The only required usage is to put more than one statement on the same line. <code>a = 1; b = 2</code><br>
This is considered bad style and placing them on seperate lines is much prefered.</p>
<h3>Do, End</h3>
<p>Blocks of code passed to macros start with <code>do</code> and end with <code>end</code>.</p>
<pre class="codehilite"><code class="language-elixir">if true do
  &quot;True!&quot;
end

if true do &quot;True!&quot; end

# inside a module
def somefunc() do
  IO.puts &quot;multi line&quot;
end

if true do
  &quot;True!&quot;
else
  &quot;False!&quot;
end
</code></pre>

<p>You can pass the block as a single line and without <code>end</code> with some extra puctuation.<br></p>
<pre class="codehilite"><code class="language-elixir">#      ⇣   ⇣         ⇣ no end keyword
if true, do: &quot;True!&quot;
#      ⇣   ⇣       ⇣     ⇣          ⇣ no end keyword
if true, do: &quot;True&quot;, else: &quot;False!&quot;
# inside a module
#             ⇣   ⇣                              ⇣ no end keyword
def someFunc(), do: IO.puts &quot;look ma, one line!&quot;
</code></pre>

<p>Syntactic sugar for</p>
<pre class="codehilite"><code class="language-elixir">if(true, [{:do, &quot;True!&quot;}, {:else, &quot;False!&quot;}])
def(someFunc(), [{:do, IO.puts &quot;look ma, one line!&quot;}])
</code></pre>

<h3>Pattern Matching</h3>
<p>A match has 2 main parts, a <strong>left</strong> side and a <strong>right</strong> side.<br></p>
<pre class="codehilite"><code class="language-elixir">#     ┌Left       ┌Right
# ┌───┴───┐   ┌───┴──────┐
  {:one, x} = {:one, :two}
#        ┌Right
#    ┌───┴──────┐  
case {:one, :two} do
#     ┌Left
# ┌───┴───┐
  {:one, x} -&gt; IO.puts x
# ┌Left
  _         -&gt; IO.puts &quot;no other match&quot;
end
</code></pre>

<p>The <strong>right</strong> side is a <strong>data structure</strong> of any kind.<br>
The <strong>left</strong> side attempts to <strong>match</strong> itself to the <strong>data structure</strong> on the right and <strong>bind</strong> any <strong>variables</strong> to <strong>substructures</strong>.</p>
<p>The simplest <strong>match</strong> has a lone <strong>variable</strong> on the <strong>left</strong> and will <strong>match</strong> anything:</p>
<pre class="codehilite"><code class="language-elixir"># in these examples `x` will be set to whatever is on the right
x = 1
x = [1,2,3,4]
x = {:any, &quot;structure&quot;, %{:whatso =&gt; :ever}}
</code></pre>

<p>But you can place the <strong>variables</strong> inside a <strong>structure</strong> so you can <strong>capture</strong> a <strong>substructure</strong>:</p>
<pre class="codehilite"><code class="language-elixir"># `x` gets set to only the `substructure` it matches
{:one, x} = {:one, :two} # `x` is set to `:two` 
[1,2,n,4] = [1,2,3,4]    # `n` is set to `3`
[:one, p] = [:one, {:apple, :orange}] # `p` is set to `{:apple, :orange}`
</code></pre>

<p>There is also a special <code>_</code> <strong>variable</strong> that works exactly like other <strong>variables</strong> but tells elixir, "Make sure something is here, but I don't care exactly what it is.":</p>
<pre class="codehilite"><code class="language-elixir"># in all of these examples, `x` gets set to `:two`
{_, x} = {:one, :two}
{_, x} = {:three, :two}
[_,_,x,_] = [1,{2},:two,3]
</code></pre>

<p>If you place a <strong>variable</strong> on the <strong>right</strong>, its <strong>value</strong> is used:</p>
<pre class="codehilite"><code class="language-elixir">#                          ┌Same as writing {&quot;twenty hams&quot;}
a = {&quot;twenty hams&quot;}        ⇣
{:i_have, {b}} = {:i_have, a} # `b` is set to &quot;twenty hams&quot;
</code></pre>

<p>In the previous example you are telling elixir: I want to <strong>match</strong> a <strong>structure</strong> that is a <strong>tuple</strong>, and this <strong>tuple's</strong> first element is going to be the atom <strong>:i_have</strong>. This <strong>tuple's</strong> second element is going to be a <strong>tuple</strong>. This <strong>second tuple</strong> is going to have one element and whatever it is I want you to bind it to the variable <strong>b</strong>.</p>
<p>If you want to use the <strong>value</strong> of a <strong>variable</strong> in your structure on the <strong>left</strong> you use the <code>^</code> operator:</p>
<pre class="codehilite"><code class="language-elixir">a = &quot;thirty hams&quot;
{b, ^a} = {:i_need, &quot;thirty hams&quot;}            # `b` is set to `:i_need`
{^a, {^a}} = {&quot;thirty hams&quot;, {&quot;thirty hams&quot;}} # nothing is set, but the match succedes
</code></pre>

<h4>Maps</h4>
<p>Individual keys can be matched in Maps like so:</p>
<pre class="codehilite"><code class="language-elixir">nola = %{ name: &quot;New Orleans&quot;, founded: 1718 }
%{name: city_name} = nola # city_name now equals &quot;New Orleans&quot;
%{name: _, founded: city_founded} = nola # Map must have both a name and a founded key
</code></pre>

<p>You can use the pin operator (^) to match on variables:</p>
<pre class="codehilite"><code class="language-elixir">field = &quot;founded&quot;
%{^field: city_founded} = nola # city_founded now equals 1718
</code></pre>

<h4>Binaries</h4>
<ul>
<li><code>&lt;&lt; size::8, rest::binary&gt;&gt; = &lt;&lt;3,0,25,1,1,2,1,6,4,3&gt;&gt;</code></li>
<li><code>&lt;&lt; data::size(size)-unit(16)-binary, rest::binary&gt;&gt; = rest</code></li>
<li>TODO</li>
</ul>
<h4>Ranges</h4>
<p>Ranges can be pattern matched if both their values are integers.</p>
<pre class="codehilite"><code class="language-elixir">min..max = 20..5000
min == 20    # true
max == 5000  # true
min..max == 1..10.0 # Thats an Argument Error
</code></pre>

<h3>Reserved words</h3>
<p>These words are reserved for the language and cannot be used as variables, module or method names.</p>
<p><code>nil</code>, <code>true</code>, <code>false</code>, <code>__MODULE__</code>,<code>__FILE__</code>,<code>__DIR__</code>,<code>__ENV__</code>,<code>__CALLER__</code></p></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>