<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bios_sigsearch, bios32_SDlookup, bios32, bios_oem_strings — interact with PC BIOS</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bios_sigsearch, bios32_SDlookup, bios32, bios_oem_strings — interact with PC BIOS

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;vm/vm.h&gt;</b>
       <b>#include</b> <b>&lt;vm/pmap.h&gt;</b>
       <b>#include</b> <b>&lt;machine/pc/bios.h&gt;</b>

       <u>uint32_t</u>
       <b>bios_sigsearch</b>(<u>uint32_t</u> <u>start</u>, <u>u_char</u> <u>*sig</u>, <u>int</u> <u>siglen</u>, <u>int</u> <u>paralen</u>, <u>int</u> <u>sigofs</u>);

       <u>int</u>
       <b>bios32_SDlookup</b>(<u>struct</u> <u>bios32_SDentry</u> <u>*ent</u>);

       <u>int</u>
       <b>bios32</b>(<u>struct</u> <u>bios_regs</u> <u>*br</u>, <u>u_int</u> <u>offset</u>, <u>u_short</u> <u>segment</u>);

       <b>BIOS_PADDRTOVADDR</b>(<u>addr</u>);

       <b>BIOS_VADDRTOPADDR</b>(<u>addr</u>);

       <u>extern</u> <u>struct</u> <u>bios32_SDentry</u> <u>PCIbios</u>;
       <u>extern</u> <u>struct</u> <u>SMBIOS_table</u> <u>SMBIOStable</u>;
       <u>extern</u> <u>struct</u> <u>DMI_table</u> <u>DMItable</u>;

       <u>int</u>
       <b>bios_oem_strings</b>(<u>struct</u> <u>bios_oem</u> <u>*oem</u>, <u>u_char</u> <u>*buffer</u>, <u>size_t</u> <u>maxlen</u>);

       struct bios_oem_signature {
               char * anchor;          /* search anchor string in BIOS memory */
               size_t offset;          /* offset from anchor (may be negative) */
               size_t totlen;          /* total length of BIOS string to copy */
       };
       struct bios_oem_range {
               u_int from;             /* shouldn't be below 0xe0000 */
               u_int to;               /* shouldn't be above 0xfffff */
       };
       struct bios_oem {
               struct bios_oem_range range;
               struct bios_oem_signature signature[];
       };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide  a  general-purpose  interface  for  dealing  with  the BIOS functions and data
       encountered on x86 PC-architecture systems.

       <b>bios_sigsearch</b>()      Searches the BIOS address space for a service signature, usually an uppercase ASCII
                             sequence surrounded by  underscores.   The  search  begins  at  <u>start</u>,  or  at  the
                             beginning of the BIOS if <u>start</u> is zero.  <u>siglen</u> bytes of the BIOS image and <u>sig</u> are
                             compared  at  <u>sigofs</u> bytes offset from the current location.  If no match is found,
                             the current location is incremented by <u>paralen</u> bytes and the search  repeated.   If
                             the  signature  is  found,  its  effective  physical  address  is  returned.  If no
                             signature is found, zero is returned.

       <b>bios_oem_strings</b>()    Searches a given BIOS memory  range  for  one  or  more  strings,  and  composes  a
                             printable concatenation of those found.  The routine expects a structure describing
                             the BIOS address <u>range</u> (within <b>0xe0000</b> - <b>0xfffff</b>), and a { NULL, <b>0</b>, <b>0</b> } -terminated
                             array  of  <u>bios_oem_signature</u>  structures which define the <u>anchor</u> string, an <u>offset</u>
                             from the beginning of the match (which may be negative), and <u>totlen</u> number of bytes
                             to be collected from BIOS memory starting at that offset.   Unmatched  anchors  are
                             ignored,   whereas   matches   are  copied  from  BIOS  memory  starting  at  their
                             corresponding <u>offset</u> with unprintable characters being  replaced  with  space,  and
                             consecutive  spaces  being suppressed.  This composed string is stored in <u>buffer</u> up
                             to the given  <u>maxlen</u>  bytes  (including  trailing  ‘\0’,  and  any  trailing  space
                             suppressed).   If  an  error  is  encountered, i.e. trying to read out of said BIOS
                             range, other invalid input, or <u>buffer</u> overflow, a  negative  integer  is  returned,
                             otherwise  the  length of the composed string is returned.  In particular, a return
                             value of 0 means that none of the given anchor strings were found in the  specified
                             BIOS memory range.

       <b>BIOS_VADDRTOPADDR</b>()   Returns  the  effective  physical  address  which corresponds to the kernel virtual
                             address <u>addr</u>.

       <b>BIOS_PADDRTOVADDR</b>()   Returns the kernel virtual address which  corresponds  to  the  effective  physical
                             address <u>addr</u>.

       SMBIOStable           If  not NULL, points to a <u>struct</u> <u>SMBIOS_table</u> structure containing information read
                             from the System Management BIOS table during system startup.

       DMItable              If not NULL, points to a <u>struct</u> <u>DMI_table</u>  structure  containing  information  read
                             from the Desktop Management Interface parameter table during system startup.

</pre><h4><b>BIOS32</b></h4><pre>
       At  system startup, the BIOS is scanned for the BIOS32 Service Directory (part of the PCI specification),
       and the existence of the directory is recorded.  This can then be used to locate other services.

       <b>bios32_SDlookup</b>()     Attempts to locate the BIOS32 service matching the 4-byte identifier passed in  the
                             <u>ident</u> field of the <u>ent</u> argument.

       <b>bios32</b>()              Calls  a  bios32  function.   This presumes that the function is capable of working
                             within the kernel  segment  (normally  the  case).   The  virtual  address  of  the
                             entrypoint  is  supplied  in  <u>entry</u>  and the register arguments to the function are
                             supplied in <u>args</u>.

       PCIbios               If not NULL, points to a <u>struct</u> <u>bios32_SDentry</u> structure describing  the  PCI  BIOS
                             entrypoint which was found during system startup.

Debian                                           August 9, 2005                                          <u><a href="../man9/BIOS.9.html">BIOS</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>