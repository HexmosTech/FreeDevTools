<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KFAIL_POINT_CODE,        KFAIL_POINT_CODE_FLAGS,        KFAIL_POINT_CODE_COND,        KFAIL_POINT_RETURN,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       KFAIL_POINT_CODE,        KFAIL_POINT_CODE_FLAGS,        KFAIL_POINT_CODE_COND,        KFAIL_POINT_RETURN,
       KFAIL_POINT_RETURN_VOID, KFAIL_POINT_ERROR,  KFAIL_POINT_GOTO,  KFAIL_POINT_SLEEP_CALLBACKS,  fail_point,
       DEBUG_FP — fail points

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/fail.h&gt;</b>

       <b>KFAIL_POINT_CODE</b>(<u>parent</u>, <u>name</u>, <u>code</u>);

       <b>KFAIL_POINT_CODE_FLAGS</b>(<u>parent</u>, <u>name</u>, <u>flags</u>, <u>code</u>);

       <b>KFAIL_POINT_CODE_COND</b>(<u>parent</u>, <u>name</u>, <u>cond</u>, <u>flags</u>, <u>code</u>);

       <b>KFAIL_POINT_RETURN</b>(<u>parent</u>, <u>name</u>);

       <b>KFAIL_POINT_RETURN_VOID</b>(<u>parent</u>, <u>name</u>);

       <b>KFAIL_POINT_ERROR</b>(<u>parent</u>, <u>name</u>, <u>error_var</u>);

       <b>KFAIL_POINT_GOTO</b>(<u>parent</u>, <u>name</u>, <u>error_var</u>, <u>label</u>);

       <b>KFAIL_POINT_SLEEP_CALLBACKS</b>(<u>parent</u>, <u>name</u>, <u>pre_func</u>, <u>pre_arg</u>, <u>post_func</u>, <u>post_arg</u>, <u>code</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Fail  points are used to add code points where errors may be injected in a user controlled fashion.  Fail
       points provide a convenient wrapper around user-provided error injection code, providing a <u><a href="../man9/sysctl.9.html">sysctl</a></u>(9) MIB,
       and a parser for that MIB that describes how the error injection code should fire.

       The base fail point macro is <b>KFAIL_POINT_CODE</b>() where <u>parent</u> is a sysctl tree  (frequently  <b>DEBUG_FP</b>  for
       kernel  fail  points, but various subsystems may wish to provide their own fail point trees), and <u>name</u> is
       the name of the MIB in that tree, and <u>code</u> is the error injection  code.   The  <u>code</u>  argument  does  not
       require  braces, but it is considered good style to use braces for any multi-line code arguments.  Inside
       the <u>code</u> argument, the evaluation of <b>RETURN_VALUE</b> is derived from the <b>return</b>() value set  in  the  sysctl
       MIB.

       Additionally,  <b>KFAIL_POINT_CODE_FLAGS</b>()  provides  a  <u>flags</u>  argument  which  controls  the  fail point's
       behaviour.  This can be used to e.g., mark the fail point's context as non-sleepable,  which  causes  the
       <b>sleep</b> action to be coerced to a busy wait.  The supported flags are:

             FAIL_POINT_USE_TIMEOUT_PATH
             Rather than sleeping on a <b>sleep</b>() call, just fire the post-sleep function after a timeout fires.

             FAIL_POINT_NONSLEEPABLE
             Mark  the  fail  point  as being in a non-sleepable context, which coerces <b>sleep</b>() calls to <b>delay</b>()
             calls.

       Likewise, <b>KFAIL_POINT_CODE_COND</b>() supplies a <u>cond</u> argument, which allows you to set the  condition  under
       which the fail point's code may fire.  This is equivalent to:

               if (cond)
                       KFAIL_POINT_CODE_FLAGS(...);

       See “SYSCTL VARIABLES” below.

       The remaining <b>KFAIL_POINT_*</b>() macros are wrappers around common error injection paths:

       <b>KFAIL_POINT_RETURN</b>(<u>parent</u>, <u>name</u>) is the equivalent of <b>KFAIL_POINT_CODE(...,</b> <b>return</b> <b>RETURN_VALUE)</b>

       <b>KFAIL_POINT_RETURN_VOID</b>(<u>parent</u>, <u>name</u>) is the equivalent of <b>KFAIL_POINT_CODE(...,</b> <b>return)</b>

       <b>KFAIL_POINT_ERROR</b>(<u>parent</u>,  <u>name</u>,  <u>error_var</u>)  is  the  equivalent  of  <b>KFAIL_POINT_CODE(...,</b>  <b>error_var</b> <b>=</b>
       <b>RETURN_VALUE)</b>

       <b>KFAIL_POINT_GOTO</b>(<u>parent</u>, <u>name</u>, <u>error_var</u>, <u>label</u>) is the equivalent of <b>KFAIL_POINT_CODE(...,</b> <b>{</b> <b>error_var</b> <b>=</b>
       <b>RETURN_VALUE;</b> <b>goto</b> <b>label;})</b>

</pre><h4><b>SYSCTL</b> <b>VARIABLES</b></h4><pre>
       The <b>KFAIL_POINT_*</b>() macros add sysctl MIBs where specified.  Many base kernel MIBs can be  found  in  the
       <b>debug.fail_point</b> tree (referenced in code by <b>DEBUG_FP</b>).

       The sysctl variable may be set in a number of ways:

         [&lt;pct&gt;%][&lt;cnt&gt;*]&lt;type&gt;[(args...)][-&gt;&lt;more terms&gt;]

       The &lt;type&gt; argument specifies which action to take; it can be one of:

       <b>off</b>     Take no action (does not trigger fail point code)

       <b>return</b>  Trigger fail point code with specified argument

       <b>sleep</b>   Sleep the specified number of milliseconds

       <b>panic</b>   Panic

       <b>break</b>   Break into the debugger, or trap if there is no debugger support

       <b>print</b>   Print that the fail point executed

       <b>pause</b>   Threads sleep at the fail point until the fail point is set to <b>off</b>

       <b>yield</b>   Thread yields the cpu when the fail point is evaluated

       <b>delay</b>   Similar to sleep, but busy waits the cpu.  (Useful in non-sleepable contexts.)

       The  &lt;pct&gt;%  and &lt;cnt&gt;* modifiers prior to &lt;type&gt; control when &lt;type&gt; is executed.  The &lt;pct&gt;% form (e.g.
       "1.2%") can be used to specify a probability that &lt;type&gt; will execute.  This is a decimal  in  the  range
       (0, 100] which can specify up to 1/10,000% precision.  The &lt;cnt&gt;* form (e.g. "5*") can be used to specify
       the  number of times &lt;type&gt; should be executed before this &lt;term&gt; is disabled.  Only the last probability
       and the last count are used if multiple are specified, i.e. "1.2%2%" is the same as "2%".   When  both  a
       probability  and  a count are specified, the probability is evaluated before the count, i.e. "2%5*" means
       "2% of the time, but only 5 times total".

       The operator -&gt; can be used to express cascading terms.  If you specify &lt;term1&gt;-&gt;&lt;term2&gt;, it  means  that
       if  &lt;term1&gt; does not ‘execute’, &lt;term2&gt; is evaluated.  For the purpose of this operator, the return() and
       print() operators are the only types that cascade.  A return() term only cascades if the  code  executes,
       and  a  print()  term  only cascades when passed a non-zero argument.  A pid can optionally be specified.
       The fail point term is only executed when invoked by a process with a matching p_pid.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>sysctl</b> <b>debug.fail_point.foobar="2.1%<a href="../man5/return.5.html">return</a>(5)"</b>
               21/1000ths of the time, execute <u>code</u> with RETURN_VALUE set to 5.

       <b>sysctl</b> <b>debug.fail_point.foobar="2%<a href="../man5/return.5.html">return</a>(5)-&gt;5%<a href="../man22/return.22.html">return</a>(22)"</b>
               2/100ths of the time, execute <u>code</u> with RETURN_VALUE set to 5.  If that does not  happen,  5%  of
               the time execute <u>code</u> with RETURN_VALUE set to 22.

       <b>sysctl</b> <b>debug.fail_point.foobar="5*<a href="../man5/return.5.html">return</a>(5)-&gt;0.1%<a href="../man22/return.22.html">return</a>(22)"</b>
               For 5 times, return 5.  After that, 1/1000th of the time, return 22.

       <b>sysctl</b> <b>debug.fail_point.foobar="0.1%5*<a href="../man5/return.5.html">return</a>(5)"</b>
               Return 5 for 1 in 1000 executions, but only 5 times total.

       <b>sysctl</b> <b>debug.fail_point.foobar="1%*<a href="../man50/sleep.50.html">sleep</a>(50)"</b>
               1/100th of the time, sleep 50ms.

       <b>sysctl</b> <b>debug.fail_point.foobar="1*<a href="../man5/return.5.html">return</a>(5)[pid</b> <b>1234]"</b>
               Return 5 once, when pid 1234 executes the fail point.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by

       Matthew Bryan &lt;<u><a href="mailto:matthew.bryan@isilon.com">matthew.bryan@isilon.com</a></u>&gt; and

       Zach Loafman &lt;<u><a href="mailto:zml@FreeBSD.org">zml@FreeBSD.org</a></u>&gt;.

</pre><h4><b>CAVEATS</b></h4><pre>
       It  is  easy to shoot yourself in the foot by setting fail points too aggressively or setting too many in
       combination.  For example, forcing <b>malloc</b>() to fail consistently is potentially harmful to uptime.

       The <b>sleep</b>() sysctl setting may not be appropriate in all situations.  Currently,  <b>fail_point_eval</b>()  does
       not verify whether the context is appropriate for calling <b>msleep</b>().  You can force it to evaluate a <b>sleep</b>
       action  as  a  <b>delay</b> action by specifying the <b>FAIL_POINT_NONSLEEPABLE</b> flag at the point the fail point is
       declared.

Debian                                           March 15, 2016                                          <u><a href="../man9/FAIL.9.html">FAIL</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>