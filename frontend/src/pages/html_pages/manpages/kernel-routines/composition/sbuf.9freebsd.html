<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sbuf,   sbuf_new,   sbuf_new_auto,   sbuf_new_for_sysctl,   sbuf_clear,  sbuf_get_flags,  sbuf_set_flags,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sbuf,   sbuf_new,   sbuf_new_auto,   sbuf_new_for_sysctl,   sbuf_clear,  sbuf_get_flags,  sbuf_set_flags,
       sbuf_clear_flags, sbuf_setpos,  sbuf_bcat,  sbuf_bcopyin,  sbuf_bcpy,  sbuf_cat,  sbuf_copyin,  sbuf_cpy,
       sbuf_printf,  sbuf_vprintf,  sbuf_putc,  sbuf_set_drain,  sbuf_trim,  sbuf_error, sbuf_finish, sbuf_data,
       sbuf_len, sbuf_done, sbuf_delete, sbuf_start_section, sbuf_end_section, sbuf_hexdump, sbuf_putbuf —  safe
       string composition

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sbuf.h&gt;</b>

       <u>typedef</u> <u>int</u> (<u>sbuf_drain_func</u>) (<u>void</u> <u>*arg,</u> <u>const</u> <u>char</u> <u>*data,</u> <u>int</u> <u>len</u>);

       <u>struct</u> <u>sbuf</u> <u>*</u>
       <b>sbuf_new</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>char</u> <u>*buf</u>, <u>int</u> <u>length</u>, <u>int</u> <u>flags</u>);

       <u>struct</u> <u>sbuf</u> <u>*</u>
       <b>sbuf_new_auto</b>(<u>void</u>);

       <u>void</u>
       <b>sbuf_clear</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>int</u>
       <b>sbuf_get_flags</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>void</u>
       <b>sbuf_set_flags</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>sbuf_clear_flags</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>sbuf_setpos</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>int</u> <u>pos</u>);

       <u>int</u>
       <b>sbuf_bcat</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sbuf_bcpy</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sbuf_cat</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>char</u> <u>*str</u>);

       <u>int</u>
       <b>sbuf_cpy</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>char</u> <u>*str</u>);

       <u>int</u>
       <b>sbuf_printf</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>char</u> <u>*fmt</u>, <u>...</u>);

       <u>int</u>
       <b>sbuf_vprintf</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>char</u> <u>*fmt</u>, <u>va_list</u> <u>ap</u>);

       <u>int</u>
       <b>sbuf_putc</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>int</u> <u>c</u>);

       <u>void</u>
       <b>sbuf_set_drain</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>sbuf_drain_func</u> <u>*func</u>, <u>void</u> <u>*arg</u>);

       <u>int</u>
       <b>sbuf_trim</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>int</u>
       <b>sbuf_error</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>int</u>
       <b>sbuf_finish</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>char</u> <u>*</u>
       <b>sbuf_data</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>ssize_t</u>
       <b>sbuf_len</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>int</u>
       <b>sbuf_done</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>void</u>
       <b>sbuf_delete</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <u>void</u>
       <b>sbuf_start_section</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>ssize_t</u> <u>*old_lenp</u>);

       <u>ssize_t</u>
       <b>sbuf_end_section</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>ssize_t</u> <u>old_len</u>, <u>size_t</u> <u>pad</u>, <u>int</u> <u>c</u>);

       <u>void</u>
       <b>sbuf_hexdump</b>(<u>struct</u> <u>sbuf</u> <u>*sb</u>, <u>void</u> <u>*ptr</u>, <u>int</u> <u>length</u>, <u>const</u> <u>char</u> <u>*hdr</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>sbuf_putbuf</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>);

       <b>#ifdef</b> <b>_KERNEL</b>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sbuf.h&gt;</b>

       <u>int</u>
       <b>sbuf_bcopyin</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>void</u> <u>*uaddr</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sbuf_copyin</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>const</u> <u>void</u> <u>*uaddr</u>, <u>size_t</u> <u>len</u>);

       <b>#include</b> <b>&lt;sys/sysctl.h&gt;</b>

       <u>struct</u> <u>sbuf</u> <u>*</u>
       <b>sbuf_new_for_sysctl</b>(<u>struct</u> <u>sbuf</u> <u>*s</u>, <u>char</u> <u>*buf</u>, <u>int</u> <u>length</u>, <u>struct</u> <u>sysctl_req</u> <u>*req</u>);

       <b>#endif</b>    <b>/*</b> <b>_KERNEL</b> <b>*/</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>sbuf</b> family of functions allows one to safely allocate, compose and release strings in kernel or user
       space.

       Instead  of  arrays  of  characters,  these  functions  operate  on  structures  called <u>sbufs</u>, defined in
       &lt;<u>sys/sbuf.h</u>&gt;.

       Any errors encountered during the allocation or composition of the string will be  latched  in  the  data
       structure,  making  a  single error test at the end of the composition sufficient to determine success or
       failure of the entire process.

       The <b>sbuf_new</b>() function initializes the <u>sbuf</u> pointed to by its first argument.  If that pointer is  NULL,
       <b>sbuf_new</b>()  allocates  a <u>struct</u> <u>sbuf</u> using <u><a href="../man9/malloc.9.html">malloc</a></u>(9).  The <u>buf</u> argument is a pointer to a buffer in which
       to store the actual string; if it is NULL, <b>sbuf_new</b>() will allocate one using <u><a href="../man9/malloc.9.html">malloc</a></u>(9).  The  <u>length</u>  is
       the  initial  size  of the storage buffer.  The fourth argument, <u>flags</u>, may be comprised of the following
       flags:

       SBUF_FIXEDLEN    The storage buffer is fixed at its initial size.  Attempting to extend the  sbuf  beyond
                        this size results in an overflow condition.

       SBUF_AUTOEXTEND  This  indicates  that  the  storage  buffer  may  be  extended  as necessary, so long as
                        resources allow, to hold additional data.

       SBUF_INCLUDENUL  This causes the final nulterm byte to be counted in the length of the data.

       SBUF_DRAINTOEOR  Treat top-level sections started with <b>sbuf_start_section</b>() as a record  boundary  marker
                        that  will  be  used  during drain operations to avoid records being split.  If a record
                        grows sufficiently large such that it fills the <u>sbuf</u> and  therefore  cannot  be  drained
                        without being split, an error of EDEADLK is set.

       Note  that  if  <u>buf</u>  is not NULL, it must point to an array of at least <u>length</u> characters.  The result of
       accessing that array directly while it is in use by the sbuf is undefined.

       The <b>sbuf_new_auto</b>() function is a shortcut for creating a completely dynamic <b>sbuf</b>.  It is the  equivalent
       of calling <b>sbuf_new</b>() with values NULL, NULL, 0, and SBUF_AUTOEXTEND.

       The <b>sbuf_new_for_sysctl</b>() function will set up an sbuf with a drain function to use <b>SYSCTL_OUT</b>() when the
       internal  buffer fills.  Note that if the various functions which append to an sbuf are used while a non-
       sleepable lock is held, the user buffer should be wired using <b>sysctl_wire_old_buffer</b>().

       The <b>sbuf_delete</b>() function clears the <u>sbuf</u> and frees any memory allocated for it.  There must be  a  call
       to  <b>sbuf_delete</b>() for every call to <b>sbuf_new</b>().  Any attempt to access the sbuf after it has been deleted
       will fail.

       The <b>sbuf_clear</b>() function invalidates the contents of the <u>sbuf</u> and resets its position to zero.

       The <b>sbuf_get_flags</b>() function returns the current user flags.  The <b>sbuf_set_flags</b>() and  <b>sbuf_get_flags</b>()
       functions  set  or  clear  one  or more user flags, respectively.  The user flags are described under the
       <b>sbuf_new</b>() function.

       The <b>sbuf_setpos</b>() function sets the <u>sbuf</u>'s end position to <u>pos</u>, which is a value  between  zero  and  the
       current position in the buffer.  It can only truncate the sbuf to the new position.

       The <b>sbuf_bcat</b>() function appends the first <u>len</u> bytes from the buffer <u>buf</u> to the <u>sbuf</u>.

       The <b>sbuf_bcopyin</b>() function copies <u>len</u> bytes from the specified userland address into the <u>sbuf</u>.

       The <b>sbuf_bcpy</b>() function replaces the contents of the <u>sbuf</u> with the first <u>len</u> bytes from the buffer <u>buf</u>.

       The <b>sbuf_cat</b>() function appends the NUL-terminated string <u>str</u> to the <u>sbuf</u> at the current position.

       The  <b>sbuf_set_drain</b>()  function  sets a drain function <u>func</u> for the <u>sbuf</u>, and records a pointer <u>arg</u> to be
       passed to the drain on callback.  The drain function cannot be changed while <u>sbuf_len</u> is non-zero.

       The registered drain  function  <u>sbuf_drain_func</u>  will  be  called  with  the  argument  <u>arg</u>  provided  to
       <b>sbuf_set_drain</b>(), a pointer <u>data</u> to a byte string that is the contents of the sbuf, and the length <u>len</u> of
       the  data.   If the drain function exists, it will be called when the sbuf internal buffer is full, or on
       behalf of <b>sbuf_finish</b>().  The drain function may drain some or all of the data, but must drain at least 1
       byte.  The return value from the drain function, if positive, indicates how many bytes were drained.   If
       negative,  the return value indicates the negative error code which will be returned from this or a later
       call to <b>sbuf_finish</b>().  The  returned  drained  length  cannot  be  zero.   To  do  unbuffered  draining,
       initialize  the  sbuf with a two-byte buffer.  The drain will be called for every byte added to the sbuf.
       The <b>sbuf_bcopyin</b>(), <b>sbuf_copyin</b>(), <b>sbuf_trim</b>(), and <b>sbuf_data</b>() functions cannot be used on an sbuf  with
       a drain.

       The  <b>sbuf_copyin</b>()  function  copies a NUL-terminated string from the specified userland address into the
       <u>sbuf</u>.  If the <u>len</u> argument is non-zero, no more than <u>len</u> characters (not counting  the  terminating  NUL)
       are copied; otherwise the entire string, or as much of it as can fit in the <u>sbuf</u>, is copied.

       The  <b>sbuf_cpy</b>()  function  replaces the contents of the <u>sbuf</u> with those of the NUL-terminated string <u>str</u>.
       This is equivalent to calling <b>sbuf_cat</b>() with a fresh <u>sbuf</u> or one which position has been reset  to  zero
       with <b>sbuf_clear</b>() or <b>sbuf_setpos</b>().

       The  <b>sbuf_printf</b>()  function  formats  its arguments according to the format string pointed to by <u>fmt</u> and
       appends the resulting string to the <u>sbuf</u> at the current position.

       The <b>sbuf_vprintf</b>() function behaves the same as <b>sbuf_printf</b>() except that the arguments are obtained from
       the variable-length argument list <u>ap</u>.

       The <b>sbuf_putc</b>() function appends the character <u>c</u> to the <u>sbuf</u> at the current position.

       The <b>sbuf_trim</b>() function removes trailing whitespace from the <u>sbuf</u>.

       The <b>sbuf_error</b>() function returns any error value that the <u>sbuf</u> may have  accumulated,  either  from  the
       drain  function, or ENOMEM if the <u>sbuf</u> overflowed.  This function is generally not needed and instead the
       error code from <b>sbuf_finish</b>() is the preferred way to discover whether an sbuf had an error.

       The <b>sbuf_finish</b>() function will call the attached drain function if one exists until all the data in  the
       <u>sbuf</u>  is  flushed.  If there is no attached drain, <b>sbuf_finish</b>() NUL-terminates the <u>sbuf</u>.  In either case
       it marks the <u>sbuf</u> as finished, which means that  it  may  no  longer  be  modified  using  <b>sbuf_setpos</b>(),
       <b>sbuf_cat</b>(), <b>sbuf_cpy</b>(), <b>sbuf_printf</b>() or <b>sbuf_putc</b>(), until <b>sbuf_clear</b>() is used to reset the sbuf.

       The  <b>sbuf_data</b>()  function  returns  the  actual  string; <b>sbuf_data</b>() only works on a finished <u>sbuf</u>.  The
       <b>sbuf_len</b>() function returns the length of the string.  For an <u>sbuf</u> with  an  attached  drain,  <b>sbuf_len</b>()
       returns the length of the un-drained data.  <b>sbuf_done</b>() returns non-zero if the <u>sbuf</u> is finished.

       The  <b>sbuf_start_section</b>()  and  <b>sbuf_end_section</b>() functions may be used for automatic section alignment.
       The arguments <u>pad</u> and <u>c</u> specify the padding size  and  a  character  used  for  padding.   The  arguments
       <u>old_lenp</u>  and  <u>old_len</u>  are to save and restore the current section length when nested sections are used.
       For the top level section NULL and -1 can be specified for <u>old_lenp</u> and <u>old_len</u> respectively.

       The <b>sbuf_hexdump</b>() function prints an  array  of  bytes  to  the  supplied  sbuf,  along  with  an  ASCII
       representation of the bytes if possible.  See the <u><a href="../man3/hexdump.3.html">hexdump</a></u>(3) man page for more details on the interface.

       The  <b>sbuf_putbuf</b>()  function  printfs the sbuf to stdout if in userland, and to the console and log if in
       the kernel.  It does not drain the buffer or update any pointers.

</pre><h4><b>NOTES</b></h4><pre>
       If an operation caused an <u>sbuf</u> to overflow, most subsequent operations on it will fail until the <u>sbuf</u>  is
       finished  using  <b>sbuf_finish</b>() or reset using <b>sbuf_clear</b>(), or its position is reset to a value between 0
       and one less than the size of its storage buffer  using  <b>sbuf_setpos</b>(),  or  it  is  reinitialized  to  a
       sufficiently short string using <b>sbuf_cpy</b>().

       Drains  in  user-space  will  not  always function as indicated.  While the drain function will be called
       immediately on overflow from the <u>sbuf_putc</u>, <u>sbuf_bcat</u>, <u>sbuf_cat</u> functions, <u>sbuf_printf</u>  and  <u>sbuf_vprintf</u>
       currently have no way to determine whether there will be an overflow until after it occurs, and cannot do
       a  partial  expansion  of the format string.  Thus when using libsbuf the buffer may be extended to allow
       completion of a single printf call, even though a drain is attached.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>sbuf_new</b>() function returns NULL if it failed to allocate a storage buffer, and a pointer to the  new
       <u>sbuf</u> otherwise.

       The <b>sbuf_setpos</b>() function returns -1 if <u>pos</u> was invalid, and zero otherwise.

       The <b>sbuf_bcat</b>(), <b>sbuf_cat</b>(), <b>sbuf_cpy</b>(), <b>sbuf_printf</b>(), <b>sbuf_putc</b>(), and <b>sbuf_trim</b>() functions all return
       -1 if the buffer overflowed, and zero otherwise.

       The <b>sbuf_error</b>() function returns a non-zero value if the buffer has an overflow or drain error, and zero
       otherwise.

       The <b>sbuf_len</b>() function returns -1 if the buffer overflowed.

       The  <b>sbuf_copyin</b>() function returns -1 if copying string from userland failed, and number of bytes copied
       otherwise.

       The <b>sbuf_end_section</b>() function returns the section length or -1 if the buffer has an error.

       The <b>sbuf_finish</b>(<u>9</u>) function (the kernel version) returns ENOMEM  if  the  sbuf  overflowed  before  being
       finished, or returns the error code from the drain if one is attached.

       The  <b>sbuf_finish</b>(<u>3</u>)  function (the userland version) will return zero for success and -1 and set errno on
       error.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;sys/types.h&gt;
       #include &lt;sys/sbuf.h&gt;

       struct sbuf *sb;

       sb = sbuf_new_auto();
       sbuf_cat(sb, "Customers found:\n");
       TAILQ_FOREACH(foo, &amp;foolist, list) {
               sbuf_printf(sb, "   %4d %s\n", foo-&gt;index, foo-&gt;name);
               sbuf_printf(sb, "      Address: %s\n", foo-&gt;address);
               sbuf_printf(sb, "      Zip: %s\n", foo-&gt;zipcode);
       }
       if (sbuf_finish(sb) != 0) /* Check for any and all errors */
               err(1, "Could not generate message");
       transmit_msg(sbuf_data(sb), sbuf_len(sb));
       sbuf_delete(sb);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/hexdump.3.html">hexdump</a></u>(3), <u><a href="../man3/printf.3.html">printf</a></u>(3), <u><a href="../man3/strcat.3.html">strcat</a></u>(3), <u><a href="../man3/strcpy.3.html">strcpy</a></u>(3), <u><a href="../man9/copyin.9.html">copyin</a></u>(9), <u><a href="../man9/copyinstr.9.html">copyinstr</a></u>(9), <u><a href="../man9/printf.9.html">printf</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>sbuf</b> family of functions first appeared in FreeBSD 4.4.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>sbuf</b> family of functions was designed by  Poul-Henning  Kamp  &lt;<u><a href="mailto:phk@FreeBSD.org">phk@FreeBSD.org</a></u>&gt;  and  implemented  by
       Dag-Erling  Smørgrav  &lt;<u><a href="mailto:des@FreeBSD.org">des@FreeBSD.org</a></u>&gt;.   Additional  improvements  were  suggested  by  Justin T. Gibbs
       &lt;<u><a href="mailto:gibbs@FreeBSD.org">gibbs@FreeBSD.org</a></u>&gt;.   Auto-extend  support  added   by   Kelly   Yancey   &lt;<u><a href="mailto:kbyanc@FreeBSD.org">kbyanc@FreeBSD.org</a></u>&gt;.    Drain
       functionality added by Matthew Fleming &lt;<u><a href="mailto:mdf@FreeBSD.org">mdf@FreeBSD.org</a></u>&gt;.

       This manual page was written by Dag-Erling Smørgrav &lt;<u><a href="mailto:des@FreeBSD.org">des@FreeBSD.org</a></u>&gt;.

Debian                                           August 26, 2020                                         <u><a href="../man9/SBUF.9.html">SBUF</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>