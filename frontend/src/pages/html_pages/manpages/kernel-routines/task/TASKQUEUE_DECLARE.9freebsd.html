<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>taskqueue — asynchronous task execution</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       taskqueue — asynchronous task execution

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/kernel.h&gt;</b>
       <b>#include</b> <b>&lt;sys/malloc.h&gt;</b>
       <b>#include</b> <b>&lt;sys/queue.h&gt;</b>
       <b>#include</b> <b>&lt;sys/taskqueue.h&gt;</b>

       typedef void (*task_fn_t)(void *context, int pending);

       typedef void (*taskqueue_enqueue_fn)(void *context);

       struct task {
               STAILQ_ENTRY(task)      ta_link;        /* link for queue */
               u_short                 ta_pending;     /* count times queued */
               u_short                 ta_priority;    /* priority of task in queue */
               task_fn_t               ta_func;        /* task handler */
               void                    *ta_context;    /* argument for handler */
       };

       enum taskqueue_callback_type {
               TASKQUEUE_CALLBACK_TYPE_INIT,
               TASKQUEUE_CALLBACK_TYPE_SHUTDOWN,
       };

       typedef void (*taskqueue_callback_fn)(void *context);

       struct timeout_task;

       <u>struct</u> <u>taskqueue</u> <u>*</u>
       <b>taskqueue_create</b>(<u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>mflags</u>, <u>taskqueue_enqueue_fn</u> <u>enqueue</u>, <u>void</u> <u>*context</u>);

       <u>struct</u> <u>taskqueue</u> <u>*</u>
       <b>taskqueue_create_fast</b>(<u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>mflags</u>, <u>taskqueue_enqueue_fn</u> <u>enqueue</u>, <u>void</u> <u>*context</u>);

       <u>int</u>
       <b>taskqueue_start_threads</b>(<u>struct</u> <u>taskqueue</u> <u>**tqp</u>, <u>int</u> <u>count</u>, <u>int</u> <u>pri</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>...</u>);

       <u>int</u>
       <b>taskqueue_start_threads_cpuset</b>(<u>struct</u> <u>taskqueue</u> <u>**tqp</u>,      <u>int</u> <u>count</u>,      <u>int</u> <u>pri</u>,      <u>cpuset_t</u> <u>*mask</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>...</u>);

       <u>int</u>
       <b>taskqueue_start_threads_in_proc</b>(<u>struct</u> <u>taskqueue</u> <u>**tqp</u>,    <u>int</u> <u>count</u>,     <u>int</u> <u>pri</u>,     <u>struct</u> <u>proc</u> <u>*proc</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>...</u>);

       <u>void</u>
       <b>taskqueue_set_callback</b>(<u>struct</u>     <u>taskqueue</u>     <u>*queue</u>,     <u>enum</u>     <u>taskqueue_callback_type</u>     <u>cb_type</u>,
           <u>taskqueue_callback_fn</u> <u>callback</u>, <u>void</u> <u>*context</u>);

       <u>void</u>
       <b>taskqueue_free</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>);

       <u>int</u>
       <b>taskqueue_enqueue</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>task</u> <u>*task</u>);

       <u>int</u>
       <b>taskqueue_enqueue_timeout</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>timeout_task</u> <u>*timeout_task</u>, <u>int</u> <u>ticks</u>);

       <u>int</u>
       <b>taskqueue_enqueue_timeout_sbt</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>timeout_task</u> <u>*timeout_task</u>, <u>sbintime_t</u> <u>sbt</u>,
           <u>sbintime_t</u> <u>pr</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>taskqueue_cancel</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>task</u> <u>*task</u>, <u>u_int</u> <u>*pendp</u>);

       <u>int</u>
       <b>taskqueue_cancel_timeout</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>timeout_task</u> <u>*timeout_task</u>, <u>u_int</u> <u>*pendp</u>);

       <u>void</u>
       <b>taskqueue_drain</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>task</u> <u>*task</u>);

       <u>void</u>
       <b>taskqueue_drain_timeout</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>timeout_task</u> <u>*timeout_task</u>);

       <u>void</u>
       <b>taskqueue_drain_all</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>);

       <u>void</u>
       <b>taskqueue_quiesce</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>);

       <u>void</u>
       <b>taskqueue_block</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>);

       <u>void</u>
       <b>taskqueue_unblock</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>);

       <u>int</u>
       <b>taskqueue_member</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>, <u>struct</u> <u>thread</u> <u>*td</u>);

       <u>void</u>
       <b>taskqueue_run</b>(<u>struct</u> <u>taskqueue</u> <u>*queue</u>);

       <b>TASK_INIT</b>(<u>struct</u> <u>task</u> <u>*task</u>, <u>int</u> <u>priority</u>, <u>task_fn_t</u> <u>func</u>, <u>void</u> <u>*context</u>);

       <b>TASK_INITIALIZER</b>(<u>int</u> <u>priority</u>, <u>task_fn_t</u> <u>func</u>, <u>void</u> <u>*context</u>);

       <b>TASKQUEUE_DECLARE</b>(<u>name</u>);

       <b>TASKQUEUE_DEFINE</b>(<u>name</u>, <u>taskqueue_enqueue_fn</u> <u>enqueue</u>, <u>void</u> <u>*context</u>, <u>init</u>);

       <b>TASKQUEUE_FAST_DEFINE</b>(<u>name</u>, <u>taskqueue_enqueue_fn</u> <u>enqueue</u>, <u>void</u> <u>*context</u>, <u>init</u>);

       <b>TASKQUEUE_DEFINE_THREAD</b>(<u>name</u>);

       <b>TASKQUEUE_FAST_DEFINE_THREAD</b>(<u>name</u>);

       <b>TIMEOUT_TASK_INIT</b>(<u>struct</u>   <u>taskqueue</u>   <u>*queue</u>,   <u>struct</u>   <u>timeout_task</u>   <u>*timeout_task</u>,   <u>int</u>   <u>priority</u>,
           <u>task_fn_t</u> <u>func</u>, <u>void</u> <u>*context</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions provide a simple interface for asynchronous execution of code.

       The  function  <b>taskqueue_create</b>()  is  used  to  create  new queues.  The arguments to <b>taskqueue_create</b>()
       include a name that should be unique, a set of <u><a href="../man9/malloc.9.html">malloc</a></u>(9) flags that specify whether the call to  <b>malloc</b>()
       is  allowed  to  sleep,  a  function  that is called from <b>taskqueue_enqueue</b>() when a task is added to the
       queue, and a pointer to the memory location where the identity of the thread that services the  queue  is
       recorded.   The  function called from <b>taskqueue_enqueue</b>() must arrange for the queue to be processed (for
       instance by scheduling a software interrupt or waking a kernel thread).  The memory  location  where  the
       thread  identity is recorded is used to signal the service thread(s) to terminate--when this value is set
       to zero and the thread is signaled it will terminate.  If the queue is intended for use in fast interrupt
       handlers <b>taskqueue_create_fast</b>() should be used in place of <b>taskqueue_create</b>().

       The function <b>taskqueue_free</b>() should be used to free the memory used by the queue.  Any tasks that are on
       the queue will be executed at this time after which the thread servicing the queue will be signaled  that
       it should exit.

       Once  a  taskqueue  has  been  created,  its  threads  should be started using <b>taskqueue_start_threads</b>(),
       <b>taskqueue_start_threads_cpuset</b>() or <b>taskqueue_start_threads_in_proc</b>().   <b>taskqueue_start_threads_cpuset</b>()
       takes a <u>cpuset</u> argument which will cause the threads which are started for the taskqueue to be restricted
       to  run  on the given CPUs.  <b>taskqueue_start_threads_in_proc</b>() takes a <u>proc</u> argument which will cause the
       threads which are started for the taskqueue to be assigned to the given kernel  process.   Callbacks  may
       optionally  be registered using <b>taskqueue_set_callback</b>().  Currently, callbacks may be registered for the
       following purposes:

       TASKQUEUE_CALLBACK_TYPE_INIT      This callback is called by every thread in  the  taskqueue,  before  it
                                         executes  any  tasks.  This callback must be set before the taskqueue's
                                         threads are started.

       TASKQUEUE_CALLBACK_TYPE_SHUTDOWN  This callback is called by every thread  in  the  taskqueue,  after  it
                                         executes its last task.  This callback will always be called before the
                                         taskqueue structure is reclaimed.

       To  add  a task to the list of tasks queued on a taskqueue, call <b>taskqueue_enqueue</b>() with pointers to the
       queue and task.  If the task's <u>ta_pending</u> field is non-zero, then it is simply incremented to reflect the
       number of times the task was enqueued, up to a cap of USHRT_MAX.  Otherwise, the task  is  added  to  the
       list before the first task which has a lower <u>ta_priority</u> value or at the end of the list if no tasks have
       a  lower  priority.  Enqueueing a task does not perform any memory allocation which makes it suitable for
       calling from an interrupt handler.  This function will return EPIPE if the queue is being freed.

       When a task is executed, first it is removed from the queue, the value of <u>ta_pending</u> is recorded and then
       the field is zeroed.  The function <u>ta_func</u> from the task structure is called with the value of the  field
       <u>ta_context</u>  as its first argument and the value of <u>ta_pending</u> as its second argument.  After the function
       <u>ta_func</u> returns, <u><a href="../man9/wakeup.9.html">wakeup</a></u>(9) is called on the task pointer passed to <b>taskqueue_enqueue</b>().

       The <b>taskqueue_enqueue_timeout</b>() function is used to schedule the enqueue after the  specified  number  of
       <u>ticks</u>.   The <b>taskqueue_enqueue_timeout_sbt</b>() function provides finer control over the scheduling based on
       <u>sbt</u>, <u>pr</u>, and <u>flags</u>, as detailed in <u><a href="../man9/timeout.9.html">timeout</a></u>(9).  Only non-fast task queues can be  used  for  <u>timeout_task</u>
       scheduling.   If  the  <u>ticks</u>  argument is negative, the already scheduled enqueueing is not re-scheduled.
       Otherwise, the task is scheduled for enqueueing in the future, after  the  absolute  value  of  <u>ticks</u>  is
       passed.   This  function returns -1 if the task is being drained.  Otherwise, the number of pending calls
       is returned.

       The <b>taskqueue_cancel</b>() function is used to cancel a task.  The <u>ta_pending</u> count is cleared, and  the  old
       value  returned  in  the reference parameter <u>pendp</u>, if it is non-NULL.  If the task is currently running,
       EBUSY is returned, otherwise 0.  To implement a blocking <b>taskqueue_cancel</b>() that waits for a running task
       to finish, it could look like:

             while (taskqueue_cancel(tq, task, NULL) != 0)
                     taskqueue_drain(tq, task);

       Note that, as with <b>taskqueue_drain</b>(), the caller is responsible for ensuring that the  task  is  not  re-
       enqueued after being canceled.

       Similarly, the <b>taskqueue_cancel_timeout</b>() function is used to cancel the scheduled task execution.

       The  <b>taskqueue_drain</b>() function is used to wait for the task to finish, and the <b>taskqueue_drain_timeout</b>()
       function is used to wait for the scheduled task to finish.  There is no guarantee that the task will  not
       be  enqueued  after  call  to <b>taskqueue_drain</b>().  If the caller wants to put the task into a known state,
       then before calling <b>taskqueue_drain</b>() the caller should use out-of-band means to  ensure  that  the  task
       would  not  be enqueued.  For example, if the task is enqueued by an interrupt filter, then the interrupt
       could be disabled.

       The <b>taskqueue_drain_all</b>() function is used to wait for all pending and running tasks that are enqueued on
       the taskqueue to finish.  Tasks posted to the taskqueue after  <b>taskqueue_drain_all</b>()  begins  processing,
       including pending enqueues scheduled by a previous call to <b>taskqueue_enqueue_timeout</b>(), do not extend the
       wait   time   of  <b>taskqueue_drain_all</b>()  and  may  complete  after  <b>taskqueue_drain_all</b>()  returns.   The
       <b>taskqueue_quiesce</b>() function is used to wait for the queue to become empty and for all running  tasks  to
       finish.   To  avoid  blocking  indefinitely,  the  caller  must  ensure by some mechanism that tasks will
       eventually stop being posted to the queue.

       The <b>taskqueue_block</b>() function blocks the taskqueue.  It prevents any enqueued but not running tasks from
       being executed.  Future calls to <b>taskqueue_enqueue</b>() will enqueue tasks, but the tasks will  not  be  run
       until  <b>taskqueue_unblock</b>() is called.  Please note that <b>taskqueue_block</b>() does not wait for any currently
       running tasks to finish.  Thus, the <b>taskqueue_block</b>() does not provide a guarantee  that  <b>taskqueue_run</b>()
       is not running after <b>taskqueue_block</b>() returns, but it does provide a guarantee that <b>taskqueue_run</b>() will
       not  be  called  again  until  <b>taskqueue_unblock</b>()  is  called.   If the caller requires a guarantee that
       <b>taskqueue_run</b>() is not running, then this must be arranged by the caller.  Note that if <b>taskqueue_drain</b>()
       is called on a task that  is  enqueued  on  a  taskqueue  that  is  blocked  by  <b>taskqueue_block</b>(),  then
       <b>taskqueue_drain</b>()  can not return until the taskqueue is unblocked.  This can result in a deadlock if the
       thread blocked in <b>taskqueue_drain</b>() is the thread that is supposed to  call  <b>taskqueue_unblock</b>().   Thus,
       use of <b>taskqueue_drain</b>() after <b>taskqueue_block</b>() is discouraged, because the state of the task can not be
       known in advance.  The same caveat applies to <b>taskqueue_drain_all</b>().

       The  <b>taskqueue_unblock</b>()  function  unblocks the previously blocked taskqueue.  All enqueued tasks can be
       run after this call.

       The <b>taskqueue_member</b>() function returns 1 if the given thread <u>td</u> is part of the given taskqueue <u>queue</u> and
       0 otherwise.

       The <b>taskqueue_run</b>() function will run all pending tasks in the specified <u>queue</u>.  Normally  this  function
       is only used internally.

       A convenience macro, <b>TASK_INIT</b>(<u>task</u>, <u>priority</u>, <u>func</u>, <u>context</u>) is provided to initialise a <u>task</u> structure.
       The   <b>TASK_INITIALIZER</b>()   macro   generates   an   initializer   for   a   task   structure.    A  macro
       <b>TIMEOUT_TASK_INIT</b>(<u>queue</u>, <u>timeout_task</u>, <u>priority</u>, <u>func</u>, <u>context</u>) initializes the  <u>timeout_task</u>  structure.
       The  values  of  <u>priority</u>,  <u>func</u>,  and  <u>context</u>  are simply copied into the task structure fields and the
       <u>ta_pending</u> field is cleared.

       Five    macros    <b>TASKQUEUE_DECLARE</b>(<u>name</u>),    <b>TASKQUEUE_DEFINE</b>(<u>name</u>,     <u>enqueue</u>,     <u>context</u>,     <u>init</u>),
       <b>TASKQUEUE_FAST_DEFINE</b>(<u>name</u>,     <u>enqueue</u>,     <u>context</u>,     <u>init</u>),     and    <b>TASKQUEUE_DEFINE_THREAD</b>(<u>name</u>)
       <b>TASKQUEUE_FAST_DEFINE_THREAD</b>(<u>name</u>) are used to declare a reference to  a  global  queue,  to  define  the
       implementation  of the queue, and declare a queue that uses its own thread.  The <b>TASKQUEUE_DEFINE</b>() macro
       arranges to call <b>taskqueue_create</b>() with the values of its <u>name</u>, <u>enqueue</u>  and  <u>context</u>  arguments  during
       system initialisation.  After calling <b>taskqueue_create</b>(), the <u>init</u> argument to the macro is executed as a
       C  statement,  allowing  any  further  initialisation  to  be performed (such as registering an interrupt
       handler, etc.).

       The <b>TASKQUEUE_DEFINE_THREAD</b>() macro defines a new taskqueue with its own kernel thread  to  serve  tasks.
       The variable <u>struct</u> <u>taskqueue</u> <u>*taskqueue_name</u> is used to enqueue tasks onto the queue.

       <b>TASKQUEUE_FAST_DEFINE</b>()   and   <b>TASKQUEUE_FAST_DEFINE_THREAD</b>()   act  just  like  <b>TASKQUEUE_DEFINE</b>()  and
       <b>TASKQUEUE_DEFINE_THREAD</b>() respectively but taskqueue is created with <b>taskqueue_create_fast</b>().

   <b>Predefined</b> <b>Task</b> <b>Queues</b>
       The system provides four  global  taskqueues,  <u>taskqueue_fast</u>,  <u>taskqueue_swi</u>,  <u>taskqueue_swi_giant</u>,  and
       <u>taskqueue_thread</u>.   The <u>taskqueue_fast</u> queue is for swi handlers dispatched from fast interrupt handlers,
       where sleep mutexes cannot be used.  The swi taskqueues are run via a software interrupt mechanism.   The
       <u>taskqueue_swi</u>  queue  runs  without  the protection of the <u>Giant</u> kernel lock, and the <u>taskqueue_swi_giant</u>
       queue runs with the protection of the <u>Giant</u> kernel lock.  The thread taskqueue <u>taskqueue_thread</u> runs in a
       kernel thread context, and tasks run from this thread do not run under the <u>Giant</u>  kernel  lock.   If  the
       caller  wants to run under <u>Giant</u>, he should explicitly acquire and release <u>Giant</u> in his taskqueue handler
       routine.

       To use these queues, call <b>taskqueue_enqueue</b>() with the value of the global  taskqueue  variable  for  the
       queue you wish to use.

       The  software  interrupt queues can be used, for instance, for implementing interrupt handlers which must
       perform a significant amount of processing in the handler.  The hardware interrupt handler would  perform
       minimal  processing  of  the  interrupt  and  then  enqueue a task to finish the work.  This reduces to a
       minimum the amount of time spent with interrupts disabled.

       The thread queue can be used, for instance,  by  interrupt  level  routines  that  need  to  call  kernel
       functions  that  do  things  that  can  only  be done from a thread context.  (e.g., call malloc with the
       M_WAITOK flag.)

       Note that tasks queued on shared taskqueues such as <u>taskqueue_swi</u> may be delayed an indeterminate  amount
       of  time  before  execution.   If  queueing delays cannot be tolerated then a private taskqueue should be
       created with a dedicated processing thread.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/ithread.9.html">ithread</a></u>(9), <u><a href="../man9/kthread.9.html">kthread</a></u>(9), <u><a href="../man9/swi.9.html">swi</a></u>(9) <u><a href="../man9/timeout.9.html">timeout</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       This interface first appeared in FreeBSD 5.0.  There is a similar facility called work_queue in the Linux
       kernel.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Doug Rabson.

Debian                                          October 17, 2019                                    <u><a href="../man9/TASKQUEUE.9.html">TASKQUEUE</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>