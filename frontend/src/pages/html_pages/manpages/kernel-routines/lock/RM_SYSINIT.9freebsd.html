<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rmlock,  rm_init,  rm_init_flags,  rm_destroy,  rm_rlock, rm_try_rlock, rm_wlock, rm_runlock, rm_wunlock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rmlock,  rm_init,  rm_init_flags,  rm_destroy,  rm_rlock, rm_try_rlock, rm_wlock, rm_runlock, rm_wunlock,
       rm_wowned, rm_sleep, rm_assert, RM_SYSINIT, RM_SYSINIT_FLAGS â€” kernel reader/writer  lock  optimized  for
       read-mostly access patterns

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/lock.h&gt;</b>
       <b>#include</b> <b>&lt;sys/rmlock.h&gt;</b>

       <u>void</u>
       <b>rm_init</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>rm_init_flags</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>opts</u>);

       <u>void</u>
       <b>rm_destroy</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>);

       <u>void</u>
       <b>rm_rlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>struct</u> <u>rm_priotracker*</u> <u>tracker</u>);

       <u>int</u>
       <b>rm_try_rlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>struct</u> <u>rm_priotracker*</u> <u>tracker</u>);

       <u>void</u>
       <b>rm_wlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>);

       <u>void</u>
       <b>rm_runlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>struct</u> <u>rm_priotracker*</u> <u>tracker</u>);

       <u>void</u>
       <b>rm_wunlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>);

       <u>int</u>
       <b>rm_wowned</b>(<u>const</u> <u>struct</u> <u>rmlock</u> <u>*rm</u>);

       <u>int</u>
       <b>rm_sleep</b>(<u>void</u> <u>*wchan</u>, <u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>int</u> <u>priority</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>timo</u>);

       <b>options</b> <b>INVARIANTS</b>
       <b>options</b> <b>INVARIANT_SUPPORT</b>

       <u>void</u>
       <b>rm_assert</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>int</u> <u>what</u>);

       <b>#include</b> <b>&lt;sys/kernel.h&gt;</b>

       <b>RM_SYSINIT</b>(<u>name</u>, <u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>const</u> <u>char</u> <u>*desc</u>);

       <b>RM_SYSINIT_FLAGS</b>(<u>name</u>, <u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>const</u> <u>char</u> <u>*desc</u>, <u>int</u> <u>flags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Read-mostly  locks  allow  shared  access to protected data by multiple threads, or exclusive access by a
       single thread.  The threads with shared access are known as <u>readers</u> since they only  read  the  protected
       data.  A thread with exclusive access is known as a <u>writer</u> since it can modify protected data.

       Read-mostly  locks  are designed to be efficient for locks almost exclusively used as reader locks and as
       such should be used for protecting data that rarely changes.  Acquiring an exclusive lock after the  lock
       has been locked for shared access is an expensive operation.

       Normal  read-mostly  locks  are  similar  to  <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9)  locks and follow the same lock ordering rules as
       <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9) locks.  Read-mostly locks have full priority propagation like mutexes.  Unlike <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9), read-
       mostly locks propagate priority to both readers and writers.  This is implemented via the  <u>rm_priotracker</u>
       structure  argument  supplied  to  <b>rm_rlock</b>()  and  <b>rm_runlock</b>().   Readers  can  recurse  if the lock is
       initialized with the RM_RECURSE option; however, writers are never allowed to recurse.

       Sleepable read-mostly locks are created by passing RM_SLEEPABLE to <b>rm_init_flags</b>().  Unlike normal  read-
       mostly  locks, sleepable read-mostly locks follow the same lock ordering rules as <u><a href="../man9/sx.9.html">sx</a></u>(9) locks.  Sleepable
       read-mostly locks do not propagate priority to writers,  but  they  do  propagate  priority  to  readers.
       Writers  are  permitted  to  sleep  while  holding a read-mostly lock, but readers are not.  Unlike other
       sleepable locks such as <u><a href="../man9/sx.9.html">sx</a></u>(9) locks, readers must use try operations on other sleepable  locks  to  avoid
       sleeping.

   <b>Macros</b> <b>and</b> <b>Functions</b>
       <b>rm_init</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>const</u> <u>char</u> <u>*name</u>)
               Initialize  the read-mostly lock <u>rm</u>.  The <u>name</u> description is used solely for debugging purposes.
               This function must be called before any other operations on the lock.

       <b>rm_init_flags</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>opts</u>)
               Similar to <b>rm_init</b>(), initialize the read-mostly lock <u>rm</u> with a set of optional flags.  The  <u>opts</u>
               arguments contains one or more of the following flags:

               RM_NOWITNESS  Instruct <u><a href="../man4/witness.4.html">witness</a></u>(4) to ignore this lock.

               RM_RECURSE    Allow threads to recursively acquire shared locks for <u>rm</u>.

               RM_SLEEPABLE  Create a sleepable read-mostly lock.

               RM_NEW        If the kernel has been compiled with <b>option</b> <b>INVARIANTS</b>, <b>rm_init_flags</b>() will assert
                             that  the  <u>rm</u>  has not been initialized multiple times without intervening calls to
                             <b>rm_destroy</b>() unless this option is specified.

       <b>rm_rlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>struct</u> <u>rm_priotracker*</u> <u>tracker</u>)
               Lock <u>rm</u> as a reader using <u>tracker</u> to track read owners of a lock for priority propagation.   This
               data  structure  is  only  used internally by <b>rmlock</b> and must persist until <b>rm_runlock</b>() has been
               called.  This data structure can be allocated on the stack since readers cannot  sleep.   If  any
               thread  holds this lock exclusively, the current thread blocks, and its priority is propagated to
               the exclusive holder.  If the lock was initialized with  the  RM_RECURSE  option  the  <b>rm_rlock</b>()
               function can be called when the current thread has already acquired reader access on <u>rm</u>.

       <b>rm_try_rlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>struct</u> <u>rm_priotracker*</u> <u>tracker</u>)
               Try  to  lock  <u>rm</u>  as  a  reader.   <b>rm_try_rlock</b>()  will  return 0 if the lock cannot be acquired
               immediately; otherwise, the lock will be acquired and a non-zero value will  be  returned.   Note
               that  <b>rm_try_rlock</b>() may fail even while the lock is not currently held by a writer.  If the lock
               was initialized with the RM_RECURSE option, <b>rm_try_rlock</b>() will succeed if the current thread has
               already acquired reader access.

       <b>rm_wlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>)
               Lock <u>rm</u> as a writer.  If there are any shared owners of the lock, the current thread blocks.  The
               <b>rm_wlock</b>() function cannot be called recursively.

       <b>rm_runlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>struct</u> <u>rm_priotracker*</u> <u>tracker</u>)
               This function releases a shared lock previously acquired by  <b>rm_rlock</b>().   The  <u>tracker</u>  argument
               must match the <u>tracker</u> argument used for acquiring the shared lock

       <b>rm_wunlock</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>)
               This function releases an exclusive lock previously acquired by <b>rm_wlock</b>().

       <b>rm_destroy</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>)
               This  functions  destroys  a  lock  previously  initialized  with <b>rm_init</b>().  The <u>rm</u> lock must be
               unlocked.

       <b>rm_wowned</b>(<u>const</u> <u>struct</u> <u>rmlock</u> <u>*rm</u>)
               This function returns a non-zero value if the current thread owns an exclusive lock on <u>rm</u>.

       <b>rm_sleep</b>(<u>void</u> <u>*wchan</u>, <u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>int</u> <u>priority</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>timo</u>)
               This function atomically releases <u>rm</u> while waiting for an event.  The <u>rm</u> lock must be exclusively
               locked.  For more details on the parameters to this function, see <u><a href="../man9/sleep.9.html">sleep</a></u>(9).

       <b>rm_assert</b>(<u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>int</u> <u>what</u>)
               This function asserts that the <u>rm</u> lock is in the state specified by <u>what</u>.  If the assertions  are
               not  true  and  the kernel is compiled with <b>options</b> <b>INVARIANTS</b> and <b>options</b> <b>INVARIANT_SUPPORT</b>, the
               kernel will panic.  Currently the following base assertions are supported:

               RA_LOCKED    Assert that current thread holds either a shared or exclusive lock of <u>rm</u>.

               RA_RLOCKED   Assert that current thread holds a shared lock of <u>rm</u>.

               RA_WLOCKED   Assert that current thread holds an exclusive lock of <u>rm</u>.

               RA_UNLOCKED  Assert that current thread holds neither a shared nor exclusive lock of <u>rm</u>.

               In addition, one of the following optional flags may be specified with RA_LOCKED, RA_RLOCKED,  or
               RA_WLOCKED:

               RA_RECURSED     Assert that the current thread holds a recursive lock of <u>rm</u>.

               RA_NOTRECURSED  Assert that the current thread does not hold a recursive lock of <u>rm</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/locking.9.html">locking</a></u>(9), <u><a href="../man9/mutex.9.html">mutex</a></u>(9), <u><a href="../man9/panic.9.html">panic</a></u>(9), <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9), <u><a href="../man9/sema.9.html">sema</a></u>(9), <u><a href="../man9/sleep.9.html">sleep</a></u>(9), <u><a href="../man9/sx.9.html">sx</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       These functions appeared in FreeBSD 7.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  <b>rmlock</b>  facility  was  written by Stephan Uphoff.  This manual page was written by Gleb Smirnoff for
       rwlock and modified to reflect rmlock by Stephan Uphoff.

</pre><h4><b>BUGS</b></h4><pre>
       The <b>rmlock</b> implementation is currently not optimized for single processor systems.

       <b>rm_try_rlock</b>() can fail transiently even when there is no writer, while another reader updates the  state
       on the local CPU.

       The  <b>rmlock</b>  implementation  uses  a single per CPU list shared by all rmlocks in the system.  If rmlocks
       become popular, hashing to multiple per CPU queues may be needed to speed up the writer lock process.

Debian                                          November 11, 2017                                      <u><a href="../man9/RMLOCK.9.html">RMLOCK</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>