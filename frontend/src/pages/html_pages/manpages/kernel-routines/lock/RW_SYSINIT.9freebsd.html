<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rwlock,  rw_init,  rw_init_flags,  rw_destroy,  rw_rlock,  rw_wlock,  rw_runlock,  rw_wunlock, rw_unlock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rwlock,  rw_init,  rw_init_flags,  rw_destroy,  rw_rlock,  rw_wlock,  rw_runlock,  rw_wunlock, rw_unlock,
       rw_try_rlock, rw_try_upgrade, rw_try_wlock, rw_downgrade, rw_sleep, rw_initialized, rw_wowned, rw_assert,
       RW_SYSINIT, RW_SYSINIT_FLAGS — kernel reader/writer lock

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/lock.h&gt;</b>
       <b>#include</b> <b>&lt;sys/rwlock.h&gt;</b>

       <u>void</u>
       <b>rw_init</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>rw_init_flags</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>opts</u>);

       <u>void</u>
       <b>rw_destroy</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>void</u>
       <b>rw_rlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>void</u>
       <b>rw_wlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>int</u>
       <b>rw_try_rlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>int</u>
       <b>rw_try_wlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>void</u>
       <b>rw_runlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>void</u>
       <b>rw_wunlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>void</u>
       <b>rw_unlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>int</u>
       <b>rw_try_upgrade</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>void</u>
       <b>rw_downgrade</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>int</u>
       <b>rw_sleep</b>(<u>void</u> <u>*chan</u>, <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>int</u> <u>priority</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>timo</u>);

       <u>int</u>
       <b>rw_initialized</b>(<u>const</u> <u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <u>int</u>
       <b>rw_wowned</b>(<u>const</u> <u>struct</u> <u>rwlock</u> <u>*rw</u>);

       <b>options</b> <b>INVARIANTS</b>
       <b>options</b> <b>INVARIANT_SUPPORT</b>

       <u>void</u>
       <b>rw_assert</b>(<u>const</u> <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>int</u> <u>what</u>);

       <b>#include</b> <b>&lt;sys/kernel.h&gt;</b>

       <b>RW_SYSINIT</b>(<u>name</u>, <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>const</u> <u>char</u> <u>*desc</u>);

       <b>RW_SYSINIT_FLAGS</b>(<u>name</u>, <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>const</u> <u>char</u> <u>*desc</u>, <u>int</u> <u>flags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Reader/writer locks allow shared access to protected data by multiple threads, or exclusive access  by  a
       single  thread.   The  threads with shared access are known as <u>readers</u> since they only read the protected
       data.  A thread with exclusive access is known as a <u>writer</u> since it can modify protected data.

       Although reader/writer locks look very  similar  to  <u><a href="../man9/sx.9.html">sx</a></u>(9)  locks,  their  usage  pattern  is  different.
       Reader/writer  locks  can  be  treated as mutexes (see <u><a href="../man9/mutex.9.html">mutex</a></u>(9)) with shared/exclusive semantics.  Unlike
       <u><a href="../man9/sx.9.html">sx</a></u>(9), an <b>rwlock</b> can be locked while holding a non-spin  mutex,  and  an  <b>rwlock</b>  cannot  be  held  while
       sleeping.   The  <b>rwlock</b> locks have priority propagation like mutexes, but priority can be propagated only
       to writers.  This limitation comes from the fact that readers are anonymous.  Another important  property
       is that readers can always recurse, and exclusive locks can be made recursive selectively.

   <b>Macros</b> <b>and</b> <b>Functions</b>
       <b>rw_init</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>const</u> <u>char</u> <u>*name</u>)
               Initialize  structure  located  at  <u>rw</u>  as  reader/writer  lock,  described  by  name  <u>name</u>.  The
               description is used solely for debugging purposes.  This function must be called before any other
               operations on the lock.

       <b>rw_init_flags</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>opts</u>)
               Initialize the rw lock just like the <b>rw_init</b>() function, but specifying a set of  optional  flags
               to  alter  the  behaviour  of  <u>rw</u>,  through  the  <u>opts</u>  argument.  It contains one or more of the
               following flags:

               RW_DUPOK      Witness should not log messages about duplicate locks being acquired.

               RW_NOPROFILE  Do not profile this lock.

               RW_NOWITNESS  Instruct <u><a href="../man4/witness.4.html">witness</a></u>(4) to ignore this lock.

               RW_QUIET      Do not log any operations for this lock via <u><a href="../man4/ktr.4.html">ktr</a></u>(4).

               RW_RECURSE    Allow threads to recursively acquire exclusive locks for <u>rw</u>.

               RW_NEW        If the kernel has been compiled with <b>option</b> <b>INVARIANTS</b>, <b>rw_init_flags</b>() will assert
                             that the <u>rw</u> has not been initialized multiple times without  intervening  calls  to
                             <b>rw_destroy</b>() unless this option is specified.

       <b>rw_rlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               Lock  <u>rw</u>  as a reader.  If any thread holds this lock exclusively, the current thread blocks, and
               its priority is propagated to the exclusive holder.  The <b>rw_rlock</b>() function can be  called  when
               the thread has already acquired reader access on <u>rw</u>.  This is called “recursing on a lock”.

       <b>rw_wlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               Lock <u>rw</u> as a writer.  If there are any shared owners of the lock, the current thread blocks.  The
               <b>rw_wlock</b>() function can be called recursively only if <u>rw</u> has been initialized with the RW_RECURSE
               option enabled.

       <b>rw_try_rlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               Try  to lock <u>rw</u> as a reader.  This function will return true if the operation succeeds, otherwise
               0 will be returned.

       <b>rw_try_wlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               Try to lock <u>rw</u> as a writer.  This function will return true if the operation succeeds,  otherwise
               0 will be returned.

       <b>rw_runlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               This function releases a shared lock previously acquired by <b>rw_rlock</b>().

       <b>rw_wunlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               This function releases an exclusive lock previously acquired by <b>rw_wlock</b>().

       <b>rw_unlock</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               This  function  releases  a  shared  lock  previously acquired by <b>rw_rlock</b>() or an exclusive lock
               previously acquired by <b>rw_wlock</b>().

       <b>rw_try_upgrade</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               Attempt to upgrade a single shared lock to an exclusive lock.  The current  thread  must  hold  a
               shared  lock  of  <u>rw</u>.  This will only succeed if the current thread holds the only shared lock on
               <u>rw</u>, and it only holds a single shared lock.  If the attempt succeeds <b>rw_try_upgrade</b>() will return
               a non-zero value, and the current thread will hold an  exclusive  lock.   If  the  attempt  fails
               <b>rw_try_upgrade</b>() will return zero, and the current thread will still hold a shared lock.

       <b>rw_downgrade</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               Convert  an  exclusive lock into a single shared lock.  The current thread must hold an exclusive
               lock of <u>rw</u>.

       <b>rw_sleep</b>(<u>void</u> <u>*chan</u>, <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>int</u> <u>priority</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>timo</u>)
               Atomically release <u>rw</u> while waiting for an event.  For more details on  the  parameters  to  this
               function, see <u><a href="../man9/sleep.9.html">sleep</a></u>(9).

       <b>rw_initialized</b>(<u>const</u> <u>struct</u> <u>rwlock</u> <u>*rw</u>)
               This function returns non-zero if <u>rw</u> has been initialized, and zero otherwise.

       <b>rw_destroy</b>(<u>struct</u> <u>rwlock</u> <u>*rw</u>)
               This  functions  destroys  a  lock  previously  initialized  with <b>rw_init</b>().  The <u>rw</u> lock must be
               unlocked.

       <b>rw_wowned</b>(<u>const</u> <u>struct</u> <u>rwlock</u> <u>*rw</u>)
               This function returns a non-zero value if the current thread owns an exclusive lock on <u>rw</u>.

       <b>rw_assert</b>(<u>const</u> <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>int</u> <u>what</u>)
               This function allows assertions specified in <u>what</u> to be made about <u>rw</u>.  If the assertions are not
               true and the kernel is compiled with <b>options</b> <b>INVARIANTS</b> and <b>options</b> <b>INVARIANT_SUPPORT</b>, the kernel
               will panic.  Currently the following base assertions are supported:

               RA_LOCKED    Assert that current thread holds either a shared or exclusive lock of <u>rw</u>.

               RA_RLOCKED   Assert that current thread holds a shared lock of <u>rw</u>.

               RA_WLOCKED   Assert that current thread holds an exclusive lock of <u>rw</u>.

               RA_UNLOCKED  Assert that current thread holds neither a shared nor exclusive lock of <u>rw</u>.

               In addition, one of the following optional flags may be specified with RA_LOCKED, RA_RLOCKED,  or
               RA_WLOCKED:

               RA_RECURSED     Assert that the current thread holds a recursive lock of <u>rw</u>.

               RA_NOTRECURSED  Assert that the current thread does not hold a recursive lock of <u>rw</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/locking.9.html">locking</a></u>(9), <u><a href="../man9/mutex.9.html">mutex</a></u>(9), <u><a href="../man9/panic.9.html">panic</a></u>(9), <u><a href="../man9/sema.9.html">sema</a></u>(9), <u><a href="../man9/sx.9.html">sx</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       These functions appeared in FreeBSD 7.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>rwlock</b> facility was written by John Baldwin.  This manual page was written by Gleb Smirnoff.

</pre><h4><b>BUGS</b></h4><pre>
       A  kernel  without  WITNESS  cannot  assert whether the current thread does or does not hold a read lock.
       RA_LOCKED and RA_RLOCKED can only assert that <u>any</u> thread holds a read lock.  They cannot ensure that  the
       current  thread holds a read lock.  Further, RA_UNLOCKED can only assert that the current thread does not
       hold a write lock.

       Reader/writer is a bit of an awkward name.  An <b>rwlock</b> can also  be  called  a  “Robert  Watson”  lock  if
       desired.

Debian                                          November 11, 2017                                      <u><a href="../man9/RWLOCK.9.html">RWLOCK</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>