<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iflibdd — Device Dependent Configuration Functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       iflibdd — Device Dependent Configuration Functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ifdi_if.h&gt;</b>

   <b>Soft</b> <b>Queue</b> <b>Setup</b> <b>and</b> <b>Teardown</b> <b>Functions</b>
   <b>Mandatory</b> <b>Functions</b>
       <u>int</u>
       <b>ifdi_tx_queues_alloc</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>caddr_t</u> <u>*vaddrs</u>, <u>uint64_t</u> <u>*paddrs</u>, <u>int</u> <u>ntxqs</u>, <u>int</u> <u>ntxqsets</u>);

       <u>int</u>
       <b>ifdi_rx_queues_alloc</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>caddr_t</u> <u>*vaddrs</u>, <u>uint64_t</u> <u>*paddrs</u>, <u>int</u> <u>nrxqs</u>, <u>int</u> <u>nrxqsets</u>);

       <u>int</u>
       <b>ifdi_queues_free</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Optional</b> <b>Functions</b>
       <u>int</u>
       <b>ifdi_txq_setup</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>qid</u>);

       <u>int</u>
       <b>ifdi_rxq_setup</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>qid</u>);

   <b>Device</b> <b>Setup</b> <b>and</b> <b>Teardown</b> <b>Functions</b>
   <b>Mandatory</b> <b>Functions</b>
       <u>int</u>
       <b>ifdi_attach_pre</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>int</u>
       <b>ifdi_attach_post</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>int</u>
       <b>ifdi_detach</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Optional</b> <b>Functions</b>
       <u>void</u>
       <b>ifdi_vlan_register</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>vtag</u>);

       <u>void</u>
       <b>ifdi_vlan_unregister</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>vtag</u>);

       <u>int</u>
       <b>ifdi_suspend</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>int</u>
       <b>ifdi_resume</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Device</b> <b>Configuration</b> <b>Functions</b>
   <b>Mandatory</b> <b>Functions</b>
       <u>void</u>
       <b>ifdi_init</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>void</u>
       <b>ifdi_stop</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>void</u>
       <b>ifdi_multi_set</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>int</u>
       <b>ifdi_mtu_set</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint32_t</u> <u>mtu</u>);

       <u>void</u>
       <b>ifdi_media_status</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>struct</u> <u>ifmediareq</u> <u>*ifr</u>);

       <u>int</u>
       <b>ifdi_media_change</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>void</u>
       <b>ifdi_promisc_set</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>int</u> <u>flags</u>);

       <u>uint64_t</u>
       <b>ifdi_get_counter</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>ift_counter</u> <u>cnt</u>);

       <u>void</u>
       <b>ifdi_update_admin_status</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Optional</b> <b>Functions</b>
       <u>void</u>
       <b>ifdi_media_set</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Interrupt</b> <b>enable/disable</b>
   <b>Mandatory</b> <b>Functions</b>
       <u>void</u>
       <b>ifdi_intr_enable</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>void</u>
       <b>ifdi_queue_intr_enable</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>qid</u>);

       <u>void</u>
       <b>ifdi_intr_disable</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>IOV</b> <b>Support</b>
       <u>init</u>
       <b>iov_init</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>num_vfs</u>, <u>const</u> <u>nvlist_t</u> <u>*params</u>);

       <u>void</u>
       <b>iov_uinit</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>void</u>
       <b>ifdi_vflr_handle</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>int</u>
       <b>ifdi_vf_add</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>uint16_t</u> <u>vfnum</u>, <u>const</u> <u>nvlist_t</u> <u>*params</u>);

   <b>Optional</b> <b>Functions</b>
       <u>void</u>
       <b>ifdi_link_intr_enable</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Optional</b> <b>Service</b> <b>Routines</b>
       <u>void</u>
       <b>ifdi_timer</b>(<u>if_ctx_t</u> <u>ctx</u>);

       <u>void</u>
       <b>ifdi_watchdog_reset</b>(<u>if_ctx_t</u> <u>ctx</u>);

   <b>Additional</b> <b>Functions</b>
       <u>void</u>
       <b>ifdi_led_func</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>int</u> <u>onoff</u>);

       <u>int</u>
       <b>ifdi_sysctl_int_delay</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>if_int_delay_info_t</u> <u>iidi</u>);

       <u>int</u>
       <b>ifdi_i2c_req</b>(<u>if_ctx_t</u> <u>ctx</u>, <u>struct</u> <u>ifi2creq</u> <u>*req</u>);

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The  above  named  functions are device dependent configuration functions.  These routines are registered
       with iflib by the driver and are called  from  the  corresponding  iflib  function  to  configure  device
       specific functions and registers.

   <b>Device</b> <b>Dependent</b> <b>Functions</b>
   <b>Soft</b> <b>Queue</b> <b>Setup</b> <b>and</b> <b>Teardown</b>
             <b>ifdi_tx_queues_alloc</b>()
             Mandatory  function  that  is  called  during iflib_attach to allocate transmit queues.  vaddrs and
             paddrs are arrays of virtual and physical addresses respectively of the hardware  transmit  queues.
             ntxqs is the number of queues per qset.  ntxqsets is the number of qsets.

             <b>ifdi_rx_queues_alloc</b>()
             Mandatory  function  that  is  called  during  iflib_attach to allocate receive queues.  vaddrs and
             paddrs are arrays of virtual and physical addresses respectively of the  hardware  receive  queues.
             nrxqs is the number of queues per qset.  nrxqsets is the number of qsets.

             <b>ifdi_queues_free</b>()
             Mandatory function that frees the allocated queues and associated transmit buffers.

             <b>ifdi_txq_setup</b>()
             Optional function for each transmit queue that handles device specific initialization.

             <b>ifdi_rxq_setup</b>()
             Optional function for each receive queue that handles device specific initialization.

   <b>Device</b> <b>Setup</b> <b>and</b> <b>Teardown</b>
             <b>ifdi_attach_pre</b>()
             Mandatory  function  implemented  by the driver to perform any attach logic that procedes interrupt
             and queue allocation, queue setup, and interrupt assignment.

             <b>ifdi_attach_post</b>()
             Mandatory function implemented by the  driver  to  perform  any  attach  logic  that  occurs  after
             ifdi_attach_pre, and iflib's queue setup and MSI/MSIX(X) or legacy interrupt assignment.

             <b>ifdi_detach</b>()
             Mandatory  function  that  frees  any  resources  allocated  by  the  driver in ifdi_attach_pre and
             ifdi_attach_post.

             <b>ifdi_vlan_register</b>()
             Optional function called by the VLAN config eventhandler.  <u>vtag</u> is the new VLAN tag.

             <b>ifdi_vlan_unregister</b>()
             Optional function called by the VLAN unconfig eventhandler.

             <b>ifdi_suspend</b>()
             Optional function that suspends the driver.

             <b>ifdi_resume</b>()
             Optional function that resumes a driver.

   <b>Device</b> <b>Configuration</b> <b>Functions</b>
             <b>ifdi_init</b>()
             Mandatory function that will initialize and bring up the hardware.  For example, it will reset  the
             chip  and  enable  the  receiver  unit.   It  should  mark  the interface running, but not active (
             IFF_DRV_RUNNING, ~IIF_DRV_OACTIVE ).

             <b>ifdi_stop</b>()
             Mandatory function that should disable all traffic on the interface by issuing a  global  reset  on
             the MAC and deallocating the TX and RX buffers.

             <b>ifdi_multi_set</b>()
             Programs the interfaces multicast addresses

             <b>ifdi_media_status</b>()
             Media  Ioctl  Callback.   Function  is called whenever the user queries the status of the interface
             using <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8).  The driver sets the appropriate link type and speed in ifmr-&gt;ifm_active.

             <b>ifdi_mtu_set</b>()
             Sets the mtu interface to the value of the second function parameter mtu.

             <b>ifdi_media_change</b>()
             Function is called when  the  user  changes  speed/duplex  using  the  media/mediaopt  option  with
             <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8).

             <b>ifdi_promisc_set</b>()
             Enables  or  disables  promisc  settings  depending  upon  the  flags  value.   <u>flags</u>  contains the
             interface's <u><a href="../man9/ifnet.9.html">ifnet</a></u>(9) flags.

             <b>ifdi_get_counter</b>()
             Returns the value for counter cnt depending upon counter type.

             <b>ifdi_update_admin_status</b>()
             Sets the link_up state to TRUE or FALSE depending upon the OS link state.   A  real  check  of  the
             hardware only happens with a link interrupt.

             <b>ifdi_media_set</b>()
             Need to define

   <b>Interrupt</b> <b>Enable/Disable</b>
             <b>ifdi_intr_enable</b>()
             Mandatory function that enables all interrupts.

             <b>ifdi_intr_disable</b>()
             Mandatory function that disables all interrupts.

             <b>ifdi_queue_intr_enable</b>()
             Mandatory function that enables interrupts on queue qid.

             <b>iov_init</b>()
             Initialize num_vfs VFs.

             <b>io_uninit</b>()
             Tear down the context for all VFs.

             <b>ifdi_vflr_handle</b>()
             Handle any VFs that have reset themselves via a Function Level Reset (FLR).

             <b>ifdi_vf_add</b>()
             Set parameters in params in VF vfnum.

   <b>Service</b> <b>Routines</b>
             <b>ifdi_timer</b>()
             Optional timer routine that will be run every 500ms.

             <b>ifdi_watchdog_reset</b>()
             Optional function to run when a transmit queue is hung.

   <b>Additional</b> <b>Functions</b>
             <b>ifdi_led_func</b>()

             <b>ifdi_sysctl_int_delay</b>()

             <b>ifdi_i2c_req</b>()

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8), <u><a href="../man9/iflibdi.9.html">iflibdi</a></u>(9), <u><a href="../man9/iflibtxrx.9.html">iflibtxrx</a></u>(9), <u><a href="../man9/ifnet.9.html">ifnet</a></u>(9)

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Nicole Graziano

Debian                                             May 3, 2018                                        <u><a href="../man9/IFLIBDD.9.html">IFLIBDD</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>