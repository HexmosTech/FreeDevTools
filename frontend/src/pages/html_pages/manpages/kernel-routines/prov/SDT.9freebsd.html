<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDT — a DTrace framework for adding statically-defined tracing probes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SDT — a DTrace framework for adding statically-defined tracing probes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/queue.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sdt.h&gt;</b>

       <b>SDT_PROVIDER_DECLARE</b>(<u>prov</u>);

       <b>SDT_PROVIDER_DEFINE</b>(<u>prov</u>);

       <b>SDT_PROBE_DECLARE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>);

       <b>SDT_PROBE_DEFINE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>);

       <b>SDT_PROBE_DEFINE0</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>);

       <b>SDT_PROBE_DEFINE1</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>);

       <b>SDT_PROBE_DEFINE2</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>);

       <b>SDT_PROBE_DEFINE3</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>);

       <b>SDT_PROBE_DEFINE4</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>);

       <b>SDT_PROBE_DEFINE5</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>, <u>arg4</u>);

       <b>SDT_PROBE_DEFINE6</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>, <u>arg4</u>, <u>arg5</u>);

       <b>SDT_PROBE_DEFINE7</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>, <u>arg4</u>, <u>arg5</u>, <u>arg6</u>);

       <b>SDT_PROBE_DEFINE0_XLATE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>);

       <b>SDT_PROBE_DEFINE1_XLATE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>);

       <b>SDT_PROBE_DEFINE2_XLATE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>, <u>arg1</u>, <u>xarg1</u>);

       <b>SDT_PROBE_DEFINE3_XLATE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>, <u>arg1</u>, <u>xarg1</u>, <u>arg2</u>, <u>xarg2</u>);

       <b>SDT_PROBE_DEFINE4_XLATE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>, <u>arg1</u>, <u>xarg1</u>, <u>arg2</u>, <u>xarg2</u>, <u>arg3</u>, <u>xarg3</u>);

       <b>SDT_PROBE_DEFINE5_XLATE</b>(<u>prov</u>,  <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>, <u>arg1</u>, <u>xarg1</u>, <u>arg2</u>, <u>xarg2</u>, <u>arg3</u>, <u>xarg3</u>, <u>arg4</u>,
           <u>xarg4</u>);

       <b>SDT_PROBE_DEFINE6_XLATE</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>, <u>arg1</u>, <u>xarg1</u>, <u>arg2</u>, <u>xarg2</u>, <u>arg3</u>, <u>xarg3</u>,  <u>arg4</u>,
           <u>xarg4</u>, <u>arg5</u>, <u>xarg5</u>);

       <b>SDT_PROBE_DEFINE7_XLATE</b>(<u>prov</u>,  <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>xarg0</u>, <u>arg1</u>, <u>xarg1</u>, <u>arg2</u>, <u>xarg2</u>, <u>arg3</u>, <u>xarg3</u>, <u>arg4</u>,
           <u>xarg4</u>, <u>arg5</u>, <u>xarg5</u>, <u>arg6</u>, <u>xarg6</u>);

       <b>SDT_PROBE0</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>);

       <b>SDT_PROBE1</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>);

       <b>SDT_PROBE2</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>);

       <b>SDT_PROBE3</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>);

       <b>SDT_PROBE4</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>);

       <b>SDT_PROBE5</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>, <u>arg4</u>);

       <b>SDT_PROBE6</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>, <u>arg4</u>, <u>arg5</u>);

       <b>SDT_PROBE7</b>(<u>prov</u>, <u>mod</u>, <u>func</u>, <u>name</u>, <u>arg0</u>, <u>arg1</u>, <u>arg2</u>, <u>arg3</u>, <u>arg4</u>, <u>arg5</u>, <u>arg6</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>SDT</b> macros allow programmers to define static trace points in kernel code.  These  trace  points  are
       used  by the <b>SDT</b> framework to create DTrace probes, allowing the code to be instrumented using <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1).
       By default, <b>SDT</b> trace points are disabled and have no effect on the  surrounding  code.   When  a  DTrace
       probe  corresponding  to a given trace point is enabled, threads that execute the trace point will call a
       handler and cause the probe to fire.  Moreover, trace points can take arguments, making  it  possible  to
       pass data to the DTrace framework when an enabled probe fires.

       Multiple  trace  points  may  correspond  to a single DTrace probe, allowing programmers to create DTrace
       probes that correspond to logical system events rather than  tying  probes  to  specific  code  execution
       paths.   For instance, a DTrace probe corresponding to the arrival of an IP packet into the network stack
       may be defined using two <b>SDT</b> trace points: one for IPv4 packets and one for IPv6 packets.

       In addition to defining DTrace probes, the <b>SDT</b> macros allow programmers to define new  DTrace  providers,
       making  it  possible to namespace logically-related probes.  An example is FreeBSD's sctp provider, which
       contains <b>SDT</b> probes for FreeBSD's <u><a href="../man4/sctp.4.html">sctp</a></u>(4) implementation.

       The <b>SDT_PROVIDER_DECLARE</b>() and <b>SDT_PROVIDER_DEFINE</b>() macros are used respectively to declare and define a
       DTrace provider named <u>prov</u> with the <b>SDT</b> framework.  A provider need only be defined  once;  however,  the
       provider must be declared before defining any <b>SDT</b> probes belonging to that provider.

       Similarly,  the  <b>SDT_PROBE_DECLARE</b>() and <b>SDT_PROBE_DEFINE*</b>() macros are used to declare and define DTrace
       probes using the <b>SDT</b> framework.  Once a probe has been defined, trace points for that probe may be  added
       to  kernel code.  DTrace probe identifiers consist of a provider, module, function and name, all of which
       may be specified in the <b>SDT</b> probe definition.  Note that probes should not specify  a  module  name:  the
       module name of a probe is used to determine whether or not it should be destroyed when a kernel module is
       unloaded.   See  the  “BUGS” section.  Note in particular that probes must not be defined across multiple
       kernel modules.

       If ‘-’ character (dash) is wanted in a probe  name,  then  it  should  be  represented  as  ‘__’  (double
       underscore) in the probe <u>name</u> parameter passed to various <b>SDT_*</b>() macros, because of technical reasons (a
       dash is not valid in C identifiers).

       The  <b>SDT_PROBE_DEFINE*</b>()  macros  also  allow  programmers to declare the types of the arguments that are
       passed  to  probes.   This  is  optional;  if  the  argument  types  are  omitted  (through  use  of  the
       <b>SDT_PROBE_DEFINE</b>()  macro), users wishing to make use of the arguments will have to manually cast them to
       the correct types in their D scripts.  It is  strongly  recommended  that  probe  definitions  include  a
       declaration of their argument types.

       The  <b>SDT_PROBE_DEFINE*_XLATE</b>()  macros  are  used  for  probes whose argument types are to be dynamically
       translated to the types specified by the corresponding  <u>xarg</u>  arguments.   This  is  mainly  useful  when
       porting  probe  definitions from other operating systems.  As seen by <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1), the arguments of a probe
       defined using these macros will have types which match the <u>xarg</u> types in the probe definition.   However,
       the  arguments  passed  in  at  the trace point will have types matching the native argument types in the
       probe definition, and thus the native type is dynamically translated to the translated type.  So long  as
       an appropriate translator is defined in <u>/usr/lib/dtrace</u>, scripts making use of the probe need not concern
       themselves with the underlying type of a given <b>SDT</b> probe argument.

       The  <b>SDT_PROBE*</b>()  macros  are used to create <b>SDT</b> trace points.  They are meant to be added to executable
       code and can be used to instrument the code in which they are called.

</pre><h4><b>PROVIDERS</b></h4><pre>
       A number of kernel DTrace providers are available.  In general, these providers define stable  interfaces
       and  should  be  treated as such: existing D scripts may be broken if a probe is renamed or its arguments
       are modified.  However, it is often useful to define ad-hoc <b>SDT</b>  probes  for  debugging  a  subsystem  or
       driver.   Similarly,  a  developer  may wish to provide a group of <b>SDT</b> probes without committing to their
       future stability.  Such probes should be added to the ‘sdt’ provider instead of defining a new provider.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The DTrace providers available on the current system can be listed with

             dtrace -l | sed 1d | awk '{print $2}' | sort -u

       A detailed list of the probes offered by a given provider can be  obtained  by  specifying  the  provider
       using the <b>-P</b> flag.  For example, to view the probes and argument types for the ‘sched’ provider, run

             dtrace -lv -P sched

       The  following  probe  definition  will  create a DTrace probe called ‘icmp:::receive-unreachable’, which
       would hypothetically  be  triggered  when  the  kernel  receives  an  ICMP  packet  of  type  Destination
       Unreachable:

             SDT_PROVIDER_DECLARE(icmp);

             SDT_PROBE_DEFINE1(icmp, , , receive__unreachable,
                 "struct icmp *");

       This  particular  probe  would take a single argument: a pointer to the struct containing the ICMP header
       for the packet.  Note that the module name of this probe is not specified.

       Consider a DTrace probe which fires when the network stack receives an IP packet.  Such a probe would  be
       defined by multiple tracepoints:

             SDT_PROBE_DEFINE3(ip, , , receive, "struct ifnet *",
                 "struct ip *", "struct ip6_hdr *");

             int
             ip_input(struct mbuf *m)
             {
                     struct ip *ip;
                     ...
                     ip = mtod(m, struct ip *);
                     SDT_PROBE3(ip, , , receive, m-&gt;m_pkthdr.rcvif, ip, NULL);
                     ...
             }

             int
             ip6_input(struct mbuf *m)
             {
                     struct ip6_hdr *ip6;
                     ...
                     ip6 = mtod(m, struct ip6_hdr *);
                     SDT_PROBE3(ip, , , receive, m-&gt;m_pkthdr.rcvif, NULL, ip6);
                     ...
             }

       In particular, the probe should fire when the kernel receives either an IPv4 packet or an IPv6 packet.

       Consider  the ICMP probe discussed above.  We note that its second argument is of type <u>struct</u> <u>icmp</u>, which
       is a type defined in the FreeBSD kernel to represent the ICMP header of an ICMP packet,  defined  in  RFC
       792.   Linux  has  a corresponding type, <u>struct</u> <u>icmphdr</u>, for the same purpose, but its field names differ
       from FreeBSD's <u>struct</u> <u>icmp</u>.  Similarly, illumos defines the <u>icmph_t</u>  type,  again  with  different  field
       names.  Even with the ‘icmp:::pkt-receive’ probes defined in all three operating systems, one would still
       have to write OS-specific scripts to extract a given field out of the ICMP header argument.  Dynamically-
       translated  types  solve  this problem: one can define an OS-independent <u><a href="../man7/c.7.html">c</a></u>(7) struct to represent an ICMP
       header, say <u>struct</u> <u>icmp_hdr_dt</u>, and define translators from each of the three OS-specific types to <u>struct</u>
       <u>icmp_hdr_dt</u>, all in the <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1) library path.  Then the FreeBSD probe above can be defined with:

             SDT_PROBE_DEFINE1_XLATE(ip, , , receive, "struct icmp *",
                 "struct icmp_hdr_dt *");

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1), <u><a href="../man4/dtrace_io.4.html">dtrace_io</a></u>(4), <u><a href="../man4/dtrace_ip.4.html">dtrace_ip</a></u>(4), <u><a href="../man4/dtrace_proc.4.html">dtrace_proc</a></u>(4), <u><a href="../man4/dtrace_sched.4.html">dtrace_sched</a></u>(4), <u><a href="../man4/dtrace_tcp.4.html">dtrace_tcp</a></u>(4), <u><a href="../man4/dtrace_udp.4.html">dtrace_udp</a></u>(4)

</pre><h4><b>AUTHORS</b></h4><pre>
       DTrace  and  the  <b>SDT</b>  framework  were  originally  ported  to  FreeBSD  from  Solaris  by  John  Birrell
       &lt;<u><a href="mailto:jb@FreeBSD.org">jb@FreeBSD.org</a></u>&gt;.  This manual page was written by Mark Johnston &lt;<u><a href="mailto:markj@FreeBSD.org">markj@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The  <b>SDT</b>  macros  allow  the  module  and  function  names  of a probe to be specified as part of a probe
       definition.  The DTrace framework uses the module name of probes to  determine  which  probes  should  be
       destroyed  when  a  kernel module is unloaded, so the module name of a probe should match the name of the
       module in which its defined.  <b>SDT</b> will set the module name properly if it  is  left  unspecified  in  the
       probe definition; see the “EXAMPLES” section.

       One  of  the  goals  of  the  original  <b>SDT</b>  implementation (and by extension, of FreeBSD's port) is that
       inactive <b>SDT</b> probes should have no performance impact.  This is unfortunately not  the  case;  <b>SDT</b>  trace
       points  will  add  a  small but non-zero amount of latency to the code in which they are defined.  A more
       sophisticated implementation of the probes will help alleviate this problem.

Debian                                           April 18, 2015                                           <u><a href="../man9/SDT.9.html">SDT</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>