<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cpuset(9) — CPUSET_T_INITIALIZER, CPUSET_FSET, CPU_CLR, CPU_COPY, CPU_ISSET, CPU_SET, CPU_ZERO, CPU_FILL,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <a href="../man9/cpuset.9.html">cpuset</a>(9) — CPUSET_T_INITIALIZER, CPUSET_FSET, CPU_CLR, CPU_COPY, CPU_ISSET, CPU_SET, CPU_ZERO, CPU_FILL,
       CPU_SETOF,  CPU_EMPTY,  CPU_ISFULLSET,  CPU_FFS,  CPU_COUNT,  CPU_SUBSET,  CPU_OVERLAP,  CPU_CMP, CPU_OR,
       CPU_AND, CPU_NAND, CPU_CLR_ATOMIC,  CPU_SET_ATOMIC,  CPU_SET_ATOMIC_ACQ,  CPU_AND_ATOMIC,  CPU_OR_ATOMIC,
       CPU_COPY_STORE_REL — cpuset manipulation macros

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/_cpuset.h&gt;</b>
       <b>#include</b> <b>&lt;sys/cpuset.h&gt;</b>

       <b>CPUSET_T_INITIALIZER</b>(<u>ARRAY_CONTENTS</u>);

       <u>CPUSET_FSET</u>

       <b>CPU_CLR</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_COPY</b>(<u>cpuset_t</u> <u>*from</u>, <u>cpuset_t</u> <u>*to</u>);

       <u>bool</u>
       <b>CPU_ISSET</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_SET</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_ZERO</b>(<u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_FILL</b>(<u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_SETOF</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <u>bool</u>
       <b>CPU_EMPTY</b>(<u>cpuset_t</u> <u>*cpuset</u>);

       <u>bool</u>
       <b>CPU_ISFULLSET</b>(<u>cpuset_t</u> <u>*cpuset</u>);

       <u>int</u>
       <b>CPU_FFS</b>(<u>cpuset_t</u> <u>*cpuset</u>);

       <u>int</u>
       <b>CPU_COUNT</b>(<u>cpuset_t</u> <u>*cpuset</u>);

       <u>bool</u>
       <b>CPU_SUBSET</b>(<u>cpuset_t</u> <u>*haystack</u>, <u>cpuset_t</u> <u>*needle</u>);

       <u>bool</u>
       <b>CPU_OVERLAP</b>(<u>cpuset_t</u> <u>*cpuset1</u>, <u>cpuset_t</u> <u>*cpuset2</u>);

       <u>bool</u>
       <b>CPU_CMP</b>(<u>cpuset_t</u> <u>*cpuset1</u>, <u>cpuset_t</u> <u>*cpuset2</u>);

       <b>CPU_OR</b>(<u>cpuset_t</u> <u>*dst</u>, <u>cpuset_t</u> <u>*src</u>);

       <b>CPU_AND</b>(<u>cpuset_t</u> <u>*dst</u>, <u>cpuset_t</u> <u>*src</u>);

       <b>CPU_NAND</b>(<u>cpuset_t</u> <u>*dst</u>, <u>cpuset_t</u> <u>*src</u>);

       <b>CPU_CLR_ATOMIC</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_SET_ATOMIC</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_SET_ATOMIC_ACQ</b>(<u>size_t</u> <u>cpu_idx</u>, <u>cpuset_t</u> <u>*cpuset</u>);

       <b>CPU_AND_ATOMIC</b>(<u>cpuset_t</u> <u>*dst</u>, <u>cpuset_t</u> <u>*src</u>);

       <b>CPU_OR_ATOMIC</b>(<u>cpuset_t</u> <u>*dst</u>, <u>cpuset_t</u> <u>*src</u>);

       <b>CPU_COPY_STORE_REL</b>(<u>cpuset_t</u> <u>*from</u>, <u>cpuset_t</u> <u>*to</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b><a href="../man9/cpuset.9.html">cpuset</a>(9)</b>  family  of  macros provide a flexible and efficient CPU set implementation, backed by the
       <u><a href="../man9/bitset.9.html">bitset</a></u>(9) macros.  Each CPU is represented by a single bit.  The maximum number of CPUs representable  by
       <u>cpuset_t</u> is <u>MAXCPU</u>.  Individual CPUs in cpusets are referenced with indices zero through <u>MAXCPU</u> <u>-</u> <u>1</u>.

       The <b>CPUSET_T_INITIALIZER</b>() macro allows one to initialize a <u>cpuset_t</u> with a compile time literal value.

       The  <b>CPUSET_FSET</b>() macro defines a compile time literal, usable by <b>CPUSET_T_INITIALIZER</b>(), representing a
       full cpuset (all CPUs present).  For examples of <b>CPUSET_T_INITIALIZER</b>() and <b>CPUSET_FSET</b>() usage, see  the
       “CPUSET_T_INITIALIZER EXAMPLE” section.

       The <b>CPU_CLR</b>() macro removes CPU <u>cpu_idx</u> from the cpuset pointed to by <u>cpuset</u>.  The <b>CPU_CLR_ATOMIC</b>() macro
       is identical, but the bit representing the CPU is cleared with atomic machine instructions.

       The  <b>CPU_COPY</b>()  macro  copies the contents of the cpuset <u>from</u> to the cpuset <u>to</u>.  <b>CPU_COPY_STORE_REL</b>() is
       similar, but copies component machine words from <u>from</u> and writes  them  to  <u>to</u>  with  atomic  store  with
       release  semantics.  (That is, if <u>to</u> is composed of multiple machine words, <b>CPU_COPY_STORE_REL</b>() performs
       multiple individually atomic operations.)

       The <b>CPU_SET</b>() macro adds CPU <u>cpu_idx</u> to the cpuset pointed to by <u>cpuset</u>, if it is  not  already  present.
       The  <b>CPU_SET_ATOMIC</b>()  macro  is  identical,  but the bit representing the CPU is set with atomic machine
       instructions.  The <b>CPU_SET_ATOMIC_ACQ</b>() macro sets the bit  representing  the  CPU  with  atomic  acquire
       semantics.

       The <b>CPU_ZERO</b>() macro removes all CPUs from <u>cpuset</u>.

       The <b>CPU_FILL</b>() macro adds all CPUs to <u>cpuset</u>.

       The <b>CPU_SETOF</b>() macro removes all CPUs in <u>cpuset</u> before adding only CPU <u>cpu_idx</u>.

       The <b>CPU_EMPTY</b>() macro returns true if <u>cpuset</u> is empty.

       The <b>CPU_ISFULLSET</b>() macro returns true if <u>cpuset</u> is full (the set of all CPUs).

       The  <b>CPU_FFS</b>() macro returns the 1-index of the first (lowest) CPU in <u>cpuset</u>, or zero if <u>cpuset</u> is empty.
       Like with <u><a href="../man3/ffs.3.html">ffs</a></u>(3), to use the non-zero result of <b>CPU_FFS</b>() as a  <u>cpu_idx</u>  index  parameter  to  any  other
       <b><a href="../man9/cpuset.9.html">cpuset</a>(9)</b> macro, you must subtract one from the result.

       The <b>CPU_COUNT</b>() macro returns the total number of CPUs in <u>cpuset</u>.

       The <b>CPU_SUBSET</b>() macro returns true if <u>needle</u> is a subset of <u>haystack</u>.

       The  <b>CPU_OVERLAP</b>()  macro returns true if <u>cpuset1</u> and <u>cpuset2</u> have any common CPUs.  (That is, if <u>cpuset1</u>
       AND <u>cpuset2</u> is not the empty set.)

       The <b>CPU_CMP</b>() macro returns true if <u>cpuset1</u> is NOT equal to <u>cpuset2</u>.

       The <b>CPU_OR</b>() macro adds CPUs present in <u>src</u> to <u>dst</u>.  (It is the <b><a href="../man9/cpuset.9.html">cpuset</a>(9)</b> equivalent of the  scalar:  <u>dst</u>
       |=  <u>src</u>.)  <b>CPU_OR_ATOMIC</b>() is similar, but sets the bits representing CPUs in the component machine words
       in <u>dst</u> with atomic machine instructions.  (That is,  if  <u>dst</u>  is  composed  of  multiple  machine  words,
       <b>CPU_OR_ATOMIC</b>() performs multiple individually atomic operations.)

       The  <b>CPU_AND</b>()  macro  removes  CPUs  absent  from  <u>src</u> from <u>dst</u>.  (It is the <b><a href="../man9/cpuset.9.html">cpuset</a>(9)</b> equivalent of the
       scalar: <u>dst</u> &amp;= <u>src</u>.)  <b>CPU_AND_ATOMIC</b>() is similar, with the same atomic semantics as <b>CPU_OR_ATOMIC</b>().

       The <b>CPU_NAND</b>() macro removes CPUs in <u>src</u> from <u>dst</u>.  (It is the <b><a href="../man9/cpuset.9.html">cpuset</a>(9)</b> equivalent of the scalar: <u>dst</u> &amp;=
       <u>~</u> <u>src</u>.)

</pre><h4><b>CPUSET_T_INITIALIZER</b> <b>EXAMPLE</b></h4><pre>
       cpuset_t myset;

       /* Initialize myset to filled (all CPUs) */
       myset = CPUSET_T_INITIALIZER(CPUSET_FSET);

       /* Initialize myset to only the lowest CPU */
       myset = <a href="../man0x1/CPUSET_T_INITIALIZER.0x1.html">CPUSET_T_INITIALIZER</a>(0x1);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/cpuset.1.html">cpuset</a></u>(1), <u><a href="../man2/cpuset.2.html">cpuset</a></u>(2), <u><a href="../man9/bitset.9.html">bitset</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       &lt;<u>sys/cpuset.h</u>&gt; first appeared in FreeBSD 7.1, released in January 2009, and in FreeBSD 8.0,  released  in
       November 2009.

       This manual page first appeared in FreeBSD 11.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  <b><a href="../man9/cpuset.9.html">cpuset</a>(9)</b>  macros were written by Jeff Roberson &lt;<u><a href="mailto:jeff@FreeBSD.org">jeff@FreeBSD.org</a></u>&gt;.  This manual page was written by
       Conrad Meyer &lt;<u><a href="mailto:cem@FreeBSD.org">cem@FreeBSD.org</a></u>&gt;.

</pre><h4><b>CAVEATS</b></h4><pre>
       Unlike every other reference to individual set members, which are zero-indexed, <b>CPU_FFS</b>() returns a  one-
       indexed result (or zero if the cpuset is empty).

Debian                                            July 29, 2016                                        <u><a href="../man9/CPUSET.9.html">CPUSET</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>