<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mac — TrustedBSD Mandatory Access Control framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mac — TrustedBSD Mandatory Access Control framework

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/mac.h&gt;</b>

       In the kernel configuration file:
       <b>options</b> <b>MAC</b>
       <b>options</b> <b>MAC_DEBUG</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Introduction</b>
       The  TrustedBSD mandatory access control framework permits dynamically introduced system security modules
       to modify system security functionality.  This can be used to support a variety of new security services,
       including traditional labeled mandatory access control models.  The framework provides a series of  entry
       points  which  must  be  called  by  code supporting various kernel services, especially with respects to
       access control points and object creation.  The framework then calls out to  security  modules  to  offer
       them  the  opportunity  to modify security behavior at those MAC API entry points.  Both consumers of the
       API (normal kernel services) and security modules must be aware  of  the  semantics  of  the  API  calls,
       particularly with respect to synchronization primitives (such as locking).

   <b>Kernel</b> <b>Objects</b> <b>Supported</b> <b>by</b> <b>the</b> <b>Framework</b>
       The  MAC  framework  manages  labels  on  a  variety  of  types  of  in-kernel objects, including process
       credentials, vnodes, devfs_dirents, mount points, sockets, mbufs, bpf descriptors, network interfaces, IP
       fragment queues, and pipes.  Label data on kernel  objects,  represented  by  <u>struct</u>  <u>label</u>,  is  policy-
       unaware, and may be used in the manner seen fit by policy modules.

   <b>API</b> <b>for</b> <b>Consumers</b>
       The  MAC  API provides a large set of entry points, too broad to specifically document here.  In general,
       these entry points represent an access control check or other MAC-relevant operations, accept one or more
       subjects (credentials) authorizing the activity, a set of  objects  on  which  the  operation  is  to  be
       performed,  and  a  set  of  operation  arguments providing information about the type of operation being
       requested.

   <b>Locking</b> <b>for</b> <b>Consumers</b>
       Consumers of the MAC API must be aware of the locking requirements for each API entry  point:  generally,
       appropriate  locks  must  be  held  over  each  subject or object being passed into the call, so that MAC
       modules may make use of various aspects of the object for access control purposes.   For  example,  vnode
       locks  are  frequently  required in order that the MAC framework and modules may retrieve security labels
       and attributes from the vnodes for the purposes of access control.  Similarly, the caller must  be  aware
       of  the  reference counting semantics of any subject or object passed into the MAC API: all calls require
       that a valid reference to the object be held for the duration of the (potentially lengthy) MAC API  call.
       Under some circumstances, objects must be held in either a shared or exclusive manner.

   <b>API</b> <b>for</b> <b>Module</b> <b>Writers</b>
       Each  module  exports a structure describing the MAC API operations that the module chooses to implement,
       including initialization and destruction API entry points, a variety of object creation  and  destruction
       calls, and a large set of access control check points.  In the future, additional audit entry points will
       also  be  present.  Module authors may choose to only implement a subset of the entry points, setting API
       function pointers in the description structure to NULL, permitting the framework to  avoid  calling  into
       the module.

   <b>Locking</b> <b>for</b> <b>Module</b> <b>Writers</b>
       Module  writers must be aware of the locking semantics of entry points that they implement: MAC API entry
       points will have specific locking or reference counting semantics for each  argument,  and  modules  must
       follow  the  locking  and  reference counting protocol or risk a variety of failure modes (including race
       conditions, inappropriate pointer dereferences, etc).

       MAC module writers must also be aware that MAC API entry points will frequently be invoked from deep in a
       kernel stack, and as such must be careful to avoid violating more global locking  requirements,  such  as
       global  lock  order  requirements.   For  example, it may be inappropriate to lock additional objects not
       specifically maintained and ordered by the policy module, or the policy module  might  violate  a  global
       ordering requirement relating to those additional objects.

       Finally,  MAC  API module implementors must be careful to avoid inappropriately calling back into the MAC
       framework: the framework makes use of locking to prevent inconsistencies during policy module  attachment
       and  detachment.   MAC API modules should avoid producing scenarios in which deadlocks or inconsistencies
       might occur.

   <b>Adding</b> <b>New</b> <b>MAC</b> <b>Entry</b> <b>Points</b>
       The MAC API is intended to be easily expandable as new services are added to the kernel.  In  order  that
       policies  may  be  guaranteed  the opportunity to ubiquitously protect system subjects and objects, it is
       important that kernel developers maintain awareness of when security checks or relevant subject or object
       operations occur in newly written or modified kernel code.  New entry points must be carefully documented
       so as to prevent any confusion regarding  lock  orders  and  semantics.   Introducing  new  entry  points
       requires  four  distinct  pieces  of  work:  introducing  new  MAC  API  entries reflecting the operation
       arguments, scattering these MAC API entry points throughout the new or modified kernel service, extending
       the front-end implementation of the  MAC  API  framework,  and  modifying  appropriate  modules  to  take
       advantage of the new entry points so that they may consistently enforce their policies.

</pre><h4><b>ENTRY</b> <b>POINTS</b></h4><pre>
       System  service  and module authors should reference the <u>FreeBSD</u> <u>Architecture</u> <u>Handbook</u> for information on
       the MAC Framework APIs.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/acl.3.html">acl</a></u>(3), <u><a href="../man3/mac.3.html">mac</a></u>(3), <u><a href="../man3/posix1e.3.html">posix1e</a></u>(3),  <u><a href="../man4/mac_biba.4.html">mac_biba</a></u>(4),  <u><a href="../man4/mac_bsdextended.4.html">mac_bsdextended</a></u>(4),  <u><a href="../man4/mac_ifoff.4.html">mac_ifoff</a></u>(4),  <u><a href="../man4/mac_lomac.4.html">mac_lomac</a></u>(4),  <u><a href="../man4/mac_mls.4.html">mac_mls</a></u>(4),
       <u><a href="../man4/mac_none.4.html">mac_none</a></u>(4),     <u><a href="../man4/mac_partition.4.html">mac_partition</a></u>(4),     <u><a href="../man4/mac_seeotheruids.4.html">mac_seeotheruids</a></u>(4),     <u><a href="../man4/mac_test.4.html">mac_test</a></u>(4),     <u><a href="../man9/ucred.9.html">ucred</a></u>(9),    <u><a href="../man9/vaccess.9.html">vaccess</a></u>(9),
       <u><a href="../man9/vaccess_acl_posix1e.9.html">vaccess_acl_posix1e</a></u>(9), <u><a href="../man9/VFS.9.html">VFS</a></u>(9)

       <u>The</u> <u>FreeBSD</u> <u>Architecture</u> <u>Handbook</u>, https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/arch-handbook/.

</pre><h4><b>HISTORY</b></h4><pre>
       The TrustedBSD MAC Framework first appeared in FreeBSD 5.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Robert Watson.  This software was contributed to the FreeBSD  Project  by
       Network  Associates  Laboratories,  the  Security  Research  Division  of  Network  Associates Inc. under
       DARPA/SPAWAR contract N66001-01-C-8035 (“CBOSS”), as part of the DARPA CHATS research program.

       The TrustedBSD MAC Framework was designed by Robert Watson, and implemented  by  the  Network  Associates
       Laboratories  Network Security (NETSEC), Secure Execution Environment (SEE), and Adaptive Network Defense
       research groups.  Network Associates Laboratory staff contributing  to  the  CBOSS  Project  include  (in
       alphabetical  order): Lee Badger, Brian Feldman, Hrishikesh Dandekar, Tim Fraser, Doug Kilpatrick, Suresh
       Krishnaswamy, Adam Migus, Wayne Morrison, Andrew Reisse, Chris Vance, and Robert Watson.

       Sub-contracted  staff  include:  Chris  Costello,  Poul-Henning  Kamp,  Jonathan  Lemon,  Kirk  McKusick,
       Dag-Erling Smørgrav.

       Additional  contributors  include: Pawel Dawidek, Chris Faulhaber, Ilmar Habibulin, Mike Halderman, Bosko
       Milekic, Thomas Moestl, Andrew Reiter, and Tim Robbins.

</pre><h4><b>BUGS</b></h4><pre>
       While the MAC Framework design is intended to support the containment of the root user,  not  all  attack
       channels  are  currently  protected by entry point checks.  As such, MAC Framework policies should not be
       relied on, in isolation, to protect against a malicious privileged user.

Debian                                            July 25, 2015                                           <u><a href="../man9/MAC.9.html">MAC</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>