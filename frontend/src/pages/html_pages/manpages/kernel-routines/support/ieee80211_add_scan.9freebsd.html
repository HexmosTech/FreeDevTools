<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ieee80211_scan — 802.11 scanning support</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ieee80211_scan — 802.11 scanning support

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;net80211/ieee80211_var.h&gt;</b>

       <u>int</u>
       <b>ieee80211_start_scan</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>,  <u>int</u> <u>flags</u>,  <u>u_int</u> <u>duration</u>,  <u>u_int</u> <u>mindwell</u>, <u>u_int</u> <u>maxdwell</u>,
           <u>u_int</u> <u>nssid</u>, <u>const</u> <u>struct</u> <u>ieee80211_scan_ssid</u> <u>ssids[]</u>);

       <u>int</u>
       <b>ieee80211_check_scan</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>int</u> <u>flags</u>,  <u>u_int</u> <u>duration</u>,  <u>u_int</u> <u>mindwell</u>,  <u>u_int</u> <u>maxdwell</u>,
           <u>u_int</u> <u>nssid</u>, <u>const</u> <u>struct</u> <u>ieee80211_scan_ssid</u> <u>ssids[]</u>);

       <u>int</u>
       <b>ieee80211_check_scan_current</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_bg_scan</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>int</u>);

       <u>int</u>
       <b>ieee80211_cancel_scan</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_cancel_scan_any</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_scan_next</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_scan_done</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_probe_curchan</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>int</u>);

       <u>void</u>
       <b>ieee80211_add_scan</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>,                            <u>const</u> <u>struct</u> <u>ieee80211_scanparams</u> <u>*</u>,
           <u>const</u> <u>struct</u> <u>ieee80211_frame</u> <u>*</u>, <u>int</u> <u>subtype</u>, <u>int</u> <u>rssi</u>, <u>int</u> <u>noise</u>);

       <u>void</u>
       <b>ieee80211_scan_timeout</b>(<u>struct</u> <u>ieee80211com</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_scan_assoc_fail</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>const</u> <u>uint8_t</u> <u>mac[IEEE80211_ADDR_LEN]</u>, <u>int</u> <u>reason</u>);

       <u>void</u>
       <b>ieee80211_scan_flush</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_scan_iterate</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>ieee80211_scan_iter_func</u>, <u>void</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_scan_dump_channels</b>(<u>const</u> <u>struct</u> <u>ieee80211_scan_state</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_scanner_register</b>(<u>enum</u> <u>ieee80211_opmode</u>, <u>const</u> <u>struct</u> <u>ieee80211_scanner</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_scanner_unregister</b>(<u>enum</u> <u>ieee80211_opmode</u>, <u>const</u> <u>struct</u> <u>ieee80211_scanner</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_scanner_unregister_all</b>(<u>const</u> <u>struct</u> <u>ieee80211_scanner</u> <u>*</u>);

       <u>const</u> <u>struct</u> <u>ieee80211_scanner</u> <u>*</u>
       <b>ieee80211_scanner_get</b>(<u>enum</u> <u>ieee80211_opmode</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>net80211</b> software layer provides an extensible framework for scanning.  Scanning is the procedure  by
       which  a  station  locates  a  BSS  to  join (in infrastructure and IBSS mode), or a channel to use (when
       operating as an AP or an IBSS master).  Scans are either “active” or “passive”.  An  active  scan  causes
       one  or  more  ProbeRequest  frames  to  be sent on visiting each channel.  A passive request causes each
       channel in the scan set to be visited but no frames to be  transmitted;  the  station  only  listens  for
       traffic.   Note  that  active  scanning  may still need to listen for traffic before sending ProbeRequest
       frames depending on regulatory constraints.

       A scan operation involves constructing a set of channels to inspect (the scan set), visiting each channel
       and collecting information (e.g. what BSS are present), and then analyzing the results to make  decisions
       such  as  which  BSS  to join.  This process needs to be as fast as possible so <b>net80211</b> does things like
       intelligently construct scan sets and dwell on a channel only as long as  necessary.   Scan  results  are
       cached  and  the  scan cache is used to avoid scanning when possible and to enable roaming between access
       points when operating in infrastructure mode.

       Scanning is handled by pluggable modules that implement <u>policy</u> per-operating  mode.   The  core  scanning
       support  provides  an infrastructure to support these modules and exports a common API to the rest of the
       <b>net80211</b> layer.  Policy modules decide what channels to visit, what state to record  to  make  decisions,
       and selects the final station/channel to return as the result of a scan.

       Scanning  is  done  synchronously when initially bringing a vap to an operational state and optionally in
       the background to maintain the scan cache for doing roaming and rogue AP  monitoring.   Scanning  is  not
       tied  to  the  <b>net80211</b> state machine that governs vaps except for linkage to the IEEE80211_S_SCAN state.
       Only one vap at a time may be scanning; this scheduling policy is handled in <b>ieee80211_new_state</b>() and is
       transparent to scanning code.

       Scanning is controlled by a set of parameters that (potentially)  constrains  the  channel  set  and  any
       desired  SSID's and BSSID's.  <b>net80211</b> comes with a standard scanner module that works with all available
       operating modes and supports “background scanning” and “roaming” operation.

</pre><h4><b>SCANNER</b> <b>MODULES</b></h4><pre>
       Scanning  modules  use   a   registration   mechanism   to   hook   into   the   <b>net80211</b>   layer.    Use
       <b>ieee80211_scanner_register</b>()   to   register   a   scan  module  for  a  particular  operating  mode  and
       <b>ieee80211_scanner_unregister</b>() or  <b>ieee80211_scanner_unregister_all</b>()  to  clear  entries  (typically  on
       module unload).  Only one scanner module can be registered at any time for an operating mode.

</pre><h4><b>DRIVER</b> <b>SUPPORT</b></h4><pre>
       Scanning  operations  are  usually managed by the <b>net80211</b> layer.  Drivers must provide <u>ic_scan_start</u> and
       <u>ic_scan_stop</u> methods that are called at the start of a scan and when  the  work  is  done;  these  should
       handle  work  such as enabling receive of Beacon and ProbeResponse frames and disable any BSSID matching.
       The <u>ic_set_channel</u> method is used to change channels while scanning.  <b>net80211</b> will generate ProbeRequest
       frames and transmit them using the <b>ic_raw_xmit</b> method.  Frames received while scanning are dispatched  to
       <b>net80211</b>  using  the  normal  receive path.  Devices that off-load scan work to firmware most easily mesh
       with <b>net80211</b> by operating on a channel-at-a-time basis as this defers control to <b>net80211's</b> scan machine
       scheduler.  But multi-channel scanning is supported if  the  driver  manually  dispatches  results  using
       <b>ieee80211_add_scan</b>() routine to enter results into the scan cache.

</pre><h4><b>SCAN</b> <b>REQUESTS</b></h4><pre>
       Scan  requests  occur  by  way  of  the IEEE80211_SCAN_REQUEST ioctl or through a change in a vap's state
       machine that requires scanning.  In both cases the scan cache can be checked first and, if it  is  deemed
       suitably “warm” then it's contents are used without leaving the current channel.  To start a scan without
       checking  the cache <b>ieee80211_start_scan</b>() can be called; otherwise <b>ieee80211_check_scan</b>() can be used to
       first check the scan cache, kicking off a scan if the cache contents are out  of  date.   There  is  also
       <b>ieee80211_check_scan_current</b>() which is a shorthand for using previously set scan parameters for checking
       the scan cache and then scanning.

       Background  scanning  is  done using <b>ieee80211_bg_scan</b>() in a co-routine fashion.  The first call to this
       routine will start a background scan that runs for a limited period of time before returning to  the  BSS
       channel.   Subsequent calls advance through the scan set until all channels are visited.  Typically these
       later calls are timed to allow receipt of frames buffered by an access point for the station.

       A scan operation can be canceled using <b>ieee80211_cancel_scan</b>() if it was initiated by the specified  vap,
       or  <b>ieee80211_cancel_scan_any</b>() to force termination regardless which vap started it.  These requests are
       mostly used by <b>net80211</b> in the transmit path to cancel background scans  when  frames  are  to  be  sent.
       Drivers should not need to use these calls (or most of the calls described on this page).

       The  <b>ieee80211_scan_next</b>()  and <b>ieee80211_scan_done</b>() routines do explicit iteration through the scan set
       and should not normally be used by drivers.  <b>ieee80211_probe_curchan</b>() handles the work  of  transmitting
       ProbeRequest  frames  when  visiting  a  channel  during an active scan.  When the channel attributes are
       marked with IEEE80211_CHAN_PASSIVE this function will arrange that before any frame is transmitted 802.11
       traffic is first received (in order to comply with regulatory constraints).

       Min/max dwell time parameters are used to constrain time spent visiting a  channel.   The  maximum  dwell
       time  constrains  the  time  spent  listening for traffic.  The minimum dwell time is used to reduce this
       time--when it is reached and one or more frames have been received then an immediate channel change  will
       be done.  Drivers can override this behaviour through the <u>iv_scan_mindwell</u> method.

</pre><h4><b>SCAN</b> <b>CACHE</b> <b>MANAGEMENT</b></h4><pre>
       The  scan  cache  contents are managed by the scan policy module and are opaque outside this module.  The
       <b>net80211</b> scan framework defines API's for interacting.  The validity  of  the  scan  cache  contents  are
       controlled by <u>iv_scanvalid</u> which is exported to user space through the IEEE80211_SCAN_VALID request.

       The   cache   contents   can  be  explicitly  flushed  with  <b>ieee80211_scan_flush</b>()  or  by  setting  the
       IEEE80211_SCAN_FLUSH flag when starting a scan operation.

       Scan cache entries are created with the <b>ieee80211_add_scan</b>() routine; usually on  receipt  of  Beacon  or
       ProbeResponse frames.  Existing entries are typically updated based on the latest information though some
       information such as RSSI and noise floor readings may be combined to present an average.

       The  cache contents is aged through <b>ieee80211_scan_timeout</b>() calls.  Typically these happen together with
       other station table activity; every IEEE80211_INACT_WAIT seconds (default 15).

       Individual  cache  entries  are  marked  usable  with  <b>ieee80211_scan_assoc_success</b>()  and  faulty   with
       <b>ieee80211_scan_assoc_fail</b>()  with  the  latter taking an argument to identify if there was no response to
       Authentication/Association requests or if a negative response was  received  (which  might  hasten  cache
       eviction or blacklist the entry).

       The  cache contents can be viewed using the <b>ieee80211_scan_iterate</b>() call.  Cache entries are exported in
       a public format that is exported to user applications through the IEEE80211_SCAN_RESULTS request.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man9/ieee80211.9.html">ieee80211</a></u>(9), <u><a href="../man9/ieee80211_proto.9.html">ieee80211_proto</a></u>(9)

Debian                                           March 29, 2010                                <u><a href="../man9/IEEE80211_SCAN.9.html">IEEE80211_SCAN</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>