<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bus_dma, bus_dma_tag_create, bus_dma_tag_destroy, bus_dmamap_create, bus_dmamap_destroy, bus_dmamap_load,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bus_dma, bus_dma_tag_create, bus_dma_tag_destroy, bus_dmamap_create, bus_dmamap_destroy, bus_dmamap_load,
       bus_dmamap_load_bio,       bus_dmamap_load_ccb,       bus_dmamap_load_mbuf,      bus_dmamap_load_mbuf_sg,
       bus_dmamap_load_uio, bus_dmamap_unload, bus_dmamap_sync,  bus_dmamem_alloc,  bus_dmamem_free  —  Bus  and
       Machine Independent DMA Mapping Interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;machine/bus.h&gt;</b>

       <u>int</u>
       <b>bus_dma_tag_create</b>(<u>bus_dma_tag_t</u>  <u>parent</u>,  <u>bus_size_t</u> <u>alignment</u>, <u>bus_addr_t</u> <u>boundary</u>, <u>bus_addr_t</u> <u>lowaddr</u>,
           <u>bus_addr_t</u>   <u>highaddr</u>,   <u>bus_dma_filter_t</u>   <u>*filtfunc</u>,   <u>void</u>   <u>*filtfuncarg</u>,   <u>bus_size_t</u>   <u>maxsize</u>,
           <u>int</u>   <u>nsegments</u>,  <u>bus_size_t</u>  <u>maxsegsz</u>,  <u>int</u>  <u>flags</u>,  <u>bus_dma_lock_t</u>  <u>*lockfunc</u>,  <u>void</u>  <u>*lockfuncarg</u>,
           <u>bus_dma_tag_t</u> <u>*dmat</u>);

       <u>int</u>
       <b>bus_dma_tag_destroy</b>(<u>bus_dma_tag_t</u> <u>dmat</u>);

       <u>int</u>
       <b>bus_dmamap_create</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>int</u> <u>flags</u>, <u>bus_dmamap_t</u> <u>*mapp</u>);

       <u>int</u>
       <b>bus_dmamap_destroy</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>bus_dmamap_t</u> <u>map</u>);

       <u>int</u>
       <b>bus_dmamap_load</b>(<u>bus_dma_tag_t</u>    <u>dmat</u>,    <u>bus_dmamap_t</u>    <u>map</u>,    <u>void</u>    <u>*buf</u>,    <u>bus_size_t</u>     <u>buflen</u>,
           <u>bus_dmamap_callback_t</u> <u>*callback</u>, <u>void</u> <u>*callback_arg</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>bus_dmamap_load_bio</b>(<u>bus_dma_tag_t</u>       <u>dmat</u>,      <u>bus_dmamap_t</u>      <u>map</u>,      <u>struct</u>      <u>bio</u>      <u>*bio</u>,
           <u>bus_dmamap_callback_t</u> <u>*callback</u>, <u>void</u> <u>*callback_arg</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>bus_dmamap_load_ccb</b>(<u>bus_dma_tag_t</u>      <u>dmat</u>,      <u>bus_dmamap_t</u>      <u>map</u>,      <u>union</u>       <u>ccb</u>       <u>*ccb</u>,
           <u>bus_dmamap_callback_t</u> <u>*callback</u>, <u>void</u> <u>*callback_arg</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>bus_dmamap_load_mbuf</b>(<u>bus_dma_tag_t</u>      <u>dmat</u>,      <u>bus_dmamap_t</u>      <u>map</u>,      <u>struct</u>     <u>mbuf</u>     <u>*mbuf</u>,
           <u>bus_dmamap_callback2_t</u> <u>*callback</u>, <u>void</u> <u>*callback_arg</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>bus_dmamap_load_mbuf_sg</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>bus_dmamap_t</u> <u>map</u>, <u>struct</u> <u>mbuf</u> <u>*mbuf</u>, <u>bus_dma_segment_t</u> <u>*segs</u>,
           <u>int</u> <u>*nsegs</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>bus_dmamap_load_uio</b>(<u>bus_dma_tag_t</u>      <u>dmat</u>,      <u>bus_dmamap_t</u>      <u>map</u>,      <u>struct</u>      <u>uio</u>       <u>*uio</u>,
           <u>bus_dmamap_callback2_t</u> <u>*callback</u>, <u>void</u> <u>*callback_arg</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>bus_dmamap_unload</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>bus_dmamap_t</u> <u>map</u>);

       <u>void</u>
       <b>bus_dmamap_sync</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>bus_dmamap_t</u> <u>map</u>, <u>op</u>);

       <u>int</u>
       <b>bus_dmamem_alloc</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>void</u> <u>**vaddr</u>, <u>int</u> <u>flags</u>, <u>bus_dmamap_t</u> <u>*mapp</u>);

       <u>void</u>
       <b>bus_dmamem_free</b>(<u>bus_dma_tag_t</u> <u>dmat</u>, <u>void</u> <u>*vaddr</u>, <u>bus_dmamap_t</u> <u>map</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Direct  Memory  Access  (DMA)  is a method of transferring data without involving the CPU, thus providing
       higher performance.  A DMA transaction can be achieved between device to memory,  device  to  device,  or
       memory to memory.

       The  <b>bus_dma</b> API is a bus, device, and machine-independent (MI) interface to DMA mechanisms.  It provides
       the client with flexibility and simplicity by abstracting machine dependent issues like  setting  up  DMA
       mappings, handling cache issues, bus specific features and limitations.

</pre><h4><b>OVERVIEW</b></h4><pre>
       A  tag  structure  (<u>bus_dma_tag_t</u>)  is  used  to  describe  the  properties  of  a  group  of related DMA
       transactions.  One way to view this is that a tag  describes  the  limitations  of  a  DMA  engine.   For
       example,  if  a  DMA engine in a device is limited to 32-bit addresses, that limitation is specified by a
       parameter when creating the tag for that device.  Similarly, a tag can be  marked  as  requiring  buffers
       whose addresses are aligned to a specific boundary.

       Some  devices  may  require  multiple  tags  to describe DMA transactions with differing properties.  For
       example, a device might require 16-byte alignment of  its  descriptor  ring  while  permitting  arbitrary
       alignment  of  I/O  buffers.   In this case, the driver must create one tag for the descriptor ring and a
       separate tag for I/O buffers.  If a device has restrictions that are common to all  DMA  transactions  in
       addition  to  restrictions  that  differ  between  unrelated groups of transactions, the driver can first
       create a “parent” tag that decribes the common restrictions.  The per-group tags can then  inherit  these
       restrictions  from  this  “parent”  tag rather than having to list them explicitly when creating the per-
       group tags.

       A mapping structure (<u>bus_dmamap_t</u>) represents a mapping of a memory region for DMA.  On systems with  I/O
       MMUs,  the mapping structure tracks any I/O MMU entries used by a request.  For DMA requests that require
       bounce pages, the mapping tracks the bounce pages used.

       To prepare for one or more DMA transactions, a mapping must be bound to a memory region by calling one of
       the <b>bus_dmamap_load</b>() functions.  These functions configure the mapping  which  can  include  programming
       entries  in  an I/O MMU and/or allocating bounce pages.  An output of these functions (either directly or
       indirectly by invoking a callback routine) is the list of scatter/gather address ranges  a  consumer  can
       pass  to  a DMA engine to access the memory region.  When a mapping is no longer needed, the mapping must
       be unloaded via <b>bus_dmamap_unload</b>().

       Before and after each DMA transaction, <b>bus_dmamap_sync</b>() must be used to ensure that the correct data  is
       used  by  the  DMA  engine  and  the  CPU.  If a mapping uses bounce pages, the sync operations copy data
       between the bounce pages and the memory region  bound  to  the  mapping.   Sync  operations  also  handle
       architecture-specific details such as CPU cache flushing and CPU memory operation ordering.

</pre><h4><b>STATIC</b> <b>VS</b> <b>DYNAMIC</b></h4><pre>
       <b>bus_dma</b>  handles  two types of DMA transactions: static and dynamic.  Static transactions are used with a
       long-lived memory region that is reused for  many  transactions  such  as  a  descriptor  ring.   Dynamic
       transactions  are  used  for transfers to or from transient buffers such as I/O buffers holding a network
       packet or disk block.  Each transaction type uses a different subset of the <b>bus_dma</b> API.

   <b>Static</b> <b>Transactions</b>
       Static transactions use memory regions allocated by <b>bus_dma</b>.  Each static memory region is  allocated  by
       calling  <b>bus_dmamem_alloc</b>().   This  function  requires  a valid tag describing the properties of the DMA
       transactions to this region such as alignment or address restrictions.   Multiple  regions  can  share  a
       single tag if they share the same restrictions.

       <b>bus_dmamem_alloc</b>()  allocates  a  memory  region along with a mapping object.  The associated tag, memory
       region, and mapping object must then be passed to <b>bus_dmamap_load</b>() to bind the mapping to the  allocated
       region and obtain the scatter/gather list.

       It  is  expected  that  <b>bus_dmamem_alloc</b>()  will attempt to allocate memory requiring less expensive sync
       operations (for example, implementations should not allocate regions requiring bounce  pages),  but  sync
       operations  should  still  be  used.   For example, a driver should use <b>bus_dmamap_sync</b>() in an interrupt
       handler before reading descriptor ring entries written by the device prior to the interrupt.

       When a consumer is finished with a memory region, it should unload the  mapping  via  <b>bus_dmamap_unload</b>()
       and then release the memory region and mapping object via <b>bus_dmamem_free</b>().

   <b>Dynamic</b> <b>Transactions</b>
       Dynamic transactions map memory regions provided by other parts of the system.  A tag must be created via
       <b>bus_dma_tag_create</b>()  to  describe  the  DMA transactions to and from these memory regions, and a pool of
       mapping objects must be allocated  via  <b>bus_dmamap_create</b>()  to  track  the  mappings  of  any  in-flight
       transactions.

       When  a  consumer wishes to schedule a transaction for a memory region, the consumer must first obtain an
       unused mapping object from its pool of mapping objects.  The memory region must be bound to  the  mapping
       object  via  one  of  the  <b>bus_dmamap_load</b>()  functions.  Before scheduling the transaction, the consumer
       should sync the memory region via <b>bus_dmamap_sync</b>() with one or more  of  the  “PRE”  flags.   After  the
       transaction  has  completed, the consumer should sync the memory region via <b>bus_dmamap_sync</b>() with one or
       more of the “POST” flags.  The mapping can then be unloaded  via  <b>bus_dmamap_unload</b>(),  and  the  mapping
       object can be returned to the pool of unused mapping objects.

       When  a  consumer  is  no  longer  scheduling  DMA  transactions, the mapping objects should be freed via
       <b>bus_dmamap_destroy</b>(), and the tag should be freed via <b>bus_dma_tag_destroy</b>().

</pre><h4><b>STRUCTURES</b> <b>AND</b> <b>TYPES</b></h4><pre>
       <u>bus_dma_tag_t</u>
               A machine-dependent (MD) opaque type that  describes  the  characteristics  of  a  group  of  DMA
               transactions.   DMA  tags  are  organized  into  a  hierarchy, with each child tag inheriting the
               restrictions of its parent.  This allows all devices  along  the  path  of  DMA  transactions  to
               contribute to the constraints of those transactions.

       <u>bus_dma_filter_t</u>
               Client specified address filter having the format:

               <u>int</u>     <b>client_filter</b>(<u>void</u> <u>*filtarg</u>, <u>bus_addr_t</u> <u>testaddr</u>)

               Address  filters  can  be  specified  during  tag creation to allow for devices whose DMA address
               restrictions cannot be specified by a single window.  The <u>filtarg</u> argument is  specified  by  the
               client  during  tag  creation  to  be  passed  to  all invocations of the callback.  The <u>testaddr</u>
               argument contains a potential starting address of a DMA mapping.  The filter function operates on
               the set of addresses from <u>testaddr</u> to ‘trunc_page(testaddr) + PAGE_SIZE  -  1’,  inclusive.   The
               filter function should return zero if any mapping in this range can be accommodated by the device
               and non-zero otherwise.

       <u>bus_dma_segment_t</u>
               A  machine-dependent  type  that  describes  individual  DMA segments.  It contains the following
               fields:

                       bus_addr_t      ds_addr;
                       bus_size_t      ds_len;

               The <u>ds_addr</u> field contains the device visible address of the DMA segment, and <u>ds_len</u> contains the
               length of the DMA segment.  Although the DMA segments returned by a mapping call will  adhere  to
               all  restrictions  necessary  for  a successful DMA operation, some conversion (e.g. a conversion
               from host byte order to the device's byte  order)  is  almost  always  required  when  presenting
               segment information to the device.

       <u>bus_dmamap_t</u>
               A  machine-dependent  opaque  type  describing  an  individual mapping.  One map is used for each
               memory allocation that will be loaded.   Maps  can  be  reused  once  they  have  been  unloaded.
               Multiple  maps  can  be  associated with one DMA tag.  While the value of the map may evaluate to
               NULL on some platforms under certain conditions, it should never be assumed that it will be  NULL
               in all cases.

       <u>bus_dmamap_callback_t</u>
               Client  specified  callback  for  receiving  mapping  information  resulting  from  the load of a
               <u>bus_dmamap_t</u> via <b>bus_dmamap_load</b>(), <b>bus_dmamap_load_bio</b>()  or  <b>bus_dmamap_load_ccb</b>().   Callbacks
               are of the format:

               <u>void</u>    <b>client_callback</b>(<u>void</u> <u>*callback_arg</u>, <u>bus_dma_segment_t</u> <u>*segs</u>, <u>int</u> <u>nseg</u>, <u>int</u> <u>error</u>)

               The  <u>callback_arg</u>  is  the  callback argument passed to dmamap load functions.  The <u>segs</u> and <u>nseg</u>
               arguments describe an array of <u>bus_dma_segment_t</u> structures that  represent  the  mapping.   This
               array  is  only  valid  within the scope of the callback function.  The success or failure of the
               mapping is indicated by the <u>error</u> argument.  More information on the  use  of  callbacks  can  be
               found in the description of the individual dmamap load functions.

       <u>bus_dmamap_callback2_t</u>
               Client  specified  callback  for  receiving  mapping  information  resulting  from  the load of a
               <u>bus_dmamap_t</u> via <b>bus_dmamap_load_uio</b>() or <b>bus_dmamap_load_mbuf</b>().

               Callback2s are of the format:

               <u>void</u>    <b>client_callback2</b>(<u>void</u>  <u>*callback_arg</u>,  <u>bus_dma_segment_t</u>  <u>*segs</u>,  <u>int</u>  <u>nseg</u>,   <u>bus_size_t</u>
                       <u>mapsize</u>, <u>int</u> <u>error</u>)

               Callback2's  behavior  is  the same as <u>bus_dmamap_callback_t</u> with the addition that the length of
               the data mapped is provided via <u>mapsize</u>.

       <u>bus_dmasync_op_t</u>
               Memory synchronization operation specifier.  Bus DMA requires explicit synchronization of  memory
               with  its  device  visible  mapping in order to guarantee memory coherency.  The <u>bus_dmasync_op_t</u>
               allows the type of DMA operation that will be or has been performed to  be  communicated  to  the
               system  so  that  the  correct  coherency  measures are taken.  The operations are represented as
               bitfield flags that can be combined together, though it only makes sense to combine PRE flags  or
               POST flags, not both.  See the <b>bus_dmamap_sync</b>() description below for more details on how to use
               these operations.

               All  operations  specified  below  are performed from the host memory point of view, where a read
               implies data coming from the device to the host memory, and a write implies data going  from  the
               host  memory  to  the device.  Alternatively, the operations can be thought of in terms of driver
               operations, where reading a network packet or storage sector corresponds to a read  operation  in
               <b>bus_dma</b>.

               BUS_DMASYNC_PREREAD    Perform  any synchronization required prior to an update of host memory by
                                      the device.

               BUS_DMASYNC_PREWRITE   Perform any synchronization required after an update of host memory by the
                                      CPU and prior to device access to host memory.

               BUS_DMASYNC_POSTREAD   Perform any synchronization required after an update of host memory by the
                                      device and prior to CPU access to host memory.

               BUS_DMASYNC_POSTWRITE  Perform any synchronization required after device access to host memory.

       <u>bus_dma_lock_t</u>
               Client specified lock/mutex manipulation method.  This will be called from within busdma whenever
               a client lock needs to be manipulated.   In  its  current  form,  the  function  will  be  called
               immediately before the callback for a DMA load operation that has been deferred with BUS_DMA_LOCK
               and  immediately  after with BUS_DMA_UNLOCK.  If the load operation does not need to be deferred,
               then it will not be called since the function loading the map should be holding  the  appropriate
               locks.  This method is of the format:

               <u>void</u>    <b>lockfunc</b>(<u>void</u> <u>*lockfunc_arg</u>, <u>bus_dma_lock_op_t</u> <u>op</u>)

               The  <u>lockfuncarg</u>  argument  is  specified  by  the client during tag creation to be passed to all
               invocations of the callback.  The <u>op</u> argument specifies the lock operation to perform.

               Two <u>lockfunc</u> implementations are provided for convenience.  <b>busdma_lock_mutex</b>() performs standard
               mutex operations on the sleep mutex provided via <u>lockfuncarg</u>.  <b>dflt_lock</b>() will generate a system
               panic if it is called.  It is substituted into the  tag  when  <u>lockfunc</u>  is  passed  as  NULL  to
               <b>bus_dma_tag_create</b>()  and  is  useful  for  tags  that  should  not  be  used  with deferred load
               operations.

       <u>bus_dma_lock_op_t</u>
               Operations to be performed by the client-specified <b>lockfunc</b>().

               BUS_DMA_LOCK    Acquires and/or locks the client locking primitive.

               BUS_DMA_UNLOCK  Releases and/or unlocks the client locking primitive.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>bus_dma_tag_create</b>(<u>parent</u>, <u>alignment</u>, <u>boundary</u>,  <u>lowaddr</u>,  <u>highaddr</u>,  <u>*filtfunc</u>,  <u>*filtfuncarg</u>,  <u>maxsize</u>,
               <u>nsegments</u>, <u>maxsegsz</u>, <u>flags</u>, <u>lockfunc</u>, <u>lockfuncarg</u>, <u>*dmat</u>)
               Allocates a DMA tag, and initializes it according to the arguments provided:

               <u>parent</u>       A  parent  tag from which to inherit restrictions.  The restrictions passed in other
                            arguments can only further tighten the restrictions inherited from the parent tag.

                            All tags created  by  a  device  driver  must  inherit  from  the  tag  returned  by
                            <b>bus_get_dma_tag</b>()  to  honor restrictions between the parent bridge, CPU memory, and
                            the device.

               <u>alignment</u>    Alignment constraint, in bytes,  of  any  mappings  created  using  this  tag.   The
                            alignment must be a power of 2.  Hardware that can DMA starting at any address would
                            specify  <u>1</u>  for  byte  alignment.   Hardware  requiring  DMA transfers to start on a
                            multiple of 4K would specify <u>4096</u>.

               <u>boundary</u>     Boundary constraint, in bytes, of  the  target  DMA  memory  region.   The  boundary
                            indicates  the set of addresses, all multiples of the boundary argument, that cannot
                            be crossed by a single <u>bus_dma_segment_t</u>.  The boundary must be a  power  of  2  and
                            must  be  no smaller than the maximum segment size.  ‘0’ indicates that there are no
                            boundary restrictions.

               <u>lowaddr</u>, <u>highaddr</u>
                            Bounds of the window of bus address space that <u>cannot</u> be directly  accessed  by  the
                            device.   The  window  contains  all addresses greater than <u>lowaddr</u> and less than or
                            equal to <u>highaddr</u>.  For example, a device incapable of DMA above 4GB, would  specify
                            a <u>highaddr</u> of BUS_SPACE_MAXADDR and a <u>lowaddr</u> of BUS_SPACE_MAXADDR_32BIT.  Similarly
                            a  device that can only perform DMA to addresses below 16MB would specify a <u>highaddr</u>
                            of BUS_SPACE_MAXADDR and a <u>lowaddr</u> of BUS_SPACE_MAXADDR_24BIT.  Some implementations
                            require that some region of device visible address space, overlapping available host
                            memory, be outside the window.  This  area  of  ‘safe  memory’  is  used  to  bounce
                            requests that would otherwise conflict with the exclusion window.

               <u>filtfunc</u>     Optional  filter  function  (may be NULL) to be called for any attempt to map memory
                            into the window described by <u>lowaddr</u>  and  <u>highaddr</u>.   A  filter  function  is  only
                            required  when the single window described by <u>lowaddr</u> and <u>highaddr</u> cannot adequately
                            describe the constraints of the device.  The filter  function  will  be  called  for
                            every machine page that overlaps the exclusion window.

               <u>filtfuncarg</u>  Argument passed to all calls to the filter function for this tag.  May be NULL.

               <u>maxsize</u>      Maximum  size,  in  bytes,  of the sum of all segment lengths in a given DMA mapping
                            associated with this tag.

               <u>nsegments</u>    Number of discontinuities (scatter/gather segments) allowed in a DMA mapped  region.
                            If there is no restriction, BUS_SPACE_UNRESTRICTED may be specified.

               <u>maxsegsz</u>     Maximum size, in bytes, of a segment in any DMA mapped region associated with <u>dmat</u>.

               <u>flags</u>        Are as follows:

                            BUS_DMA_ALLOCNOW  Pre-allocate  enough  resources  to  handle  at least one map load
                                              operation on this tag.  If sufficient resources are not available,
                                              ENOMEM is returned.  This should not be used for  tags  that  only
                                              describe  buffers  that will be allocated with <b>bus_dmamem_alloc</b>().
                                              Also, due to resource sharing with other tags, this flag does  not
                                              guarantee that resources will be allocated or reserved exclusively
                                              for this tag.  It should be treated only as a minor optimization.

                            BUS_DMA_COHERENT  Indicate  that  the DMA engine and CPU are cache-coherent.  Cached
                                              memory   may   be   used   to   back   allocations   created    by
                                              <b>bus_dmamem_alloc</b>().        For      <b>bus_dma_tag_create</b>(),      the
                                              BUS_DMA_COHERENT flag is currently implemented on arm64.

               <u>lockfunc</u>     Optional lock manipulation function (may be NULL) to be called when busdma needs  to
                            manipulate  a  lock  on  behalf of the client.  If NULL is specified, <b>dflt_lock</b>() is
                            used.

               <u>lockfuncarg</u>  Optional argument to be passed to the function specified by <u>lockfunc</u>.

               <u>dmat</u>         Pointer to a bus_dma_tag_t where the resulting DMA tag will be stored.

               Returns ENOMEM if sufficient memory is not available  for  tag  creation  or  allocating  mapping
               resources.

       <b>bus_dma_tag_destroy</b>(<u>dmat</u>)
               Deallocate the DMA tag <u>dmat</u> that was created by <b>bus_dma_tag_create</b>().

               Returns EBUSY if any DMA maps remain associated with <u>dmat</u> or ‘0’ on success.

       <b>bus_dmamap_create</b>(<u>dmat</u>, <u>flags</u>, <u>*mapp</u>)
               Allocates and initializes a DMA map.  Arguments are as follows:

               <u>dmat</u>       DMA tag.

               <u>flags</u>      Are as follows:

                          BUS_DMA_COHERENT  Attempt  to map the memory loaded with this map such that cache sync
                                            operations are as cheap as possible.  This flag is typically set  on
                                            maps  when  the  memory loaded with these will be accessed by both a
                                            CPU and a DMA engine, frequently such as control data and as opposed
                                            to streamable data such as receive and  transmit  buffers.   Use  of
                                            this    flag    does   not   remove   the   requirement   of   using
                                            <b>bus_dmamap_sync</b>(), but it may reduce the cost  of  performing  these
                                            operations.   For  <b>bus_dmamap_create</b>(), the BUS_DMA_COHERENT flag is
                                            currently implemented on sparc64.

               <u>mapp</u>       Pointer to a <u>bus_dmamap_t</u> where the resulting DMA map will be stored.

               Returns ENOMEM if sufficient memory is not available for creating the map or  allocating  mapping
               resources.

       <b>bus_dmamap_destroy</b>(<u>dmat</u>, <u>map</u>)
               Frees all resources associated with a given DMA map.  Arguments are as follows:

               <u>dmat</u>  DMA tag used to allocate <u>map</u>.

               <u>map</u>   The DMA map to destroy.

               Returns EBUSY if a mapping is still active for <u>map</u>.

       <b>bus_dmamap_load</b>(<u>dmat</u>, <u>map</u>, <u>buf</u>, <u>buflen</u>, <u>*callback</u>, <u>callback_arg</u>, <u>flags</u>)
               Creates a mapping in device visible address space of <u>buflen</u> bytes of <u>buf</u>, associated with the DMA
               map  <u>map</u>.  This call will always return immediately and will not block for any reason.  Arguments
               are as follows:

               <u>dmat</u>    DMA tag used to allocate <u>map</u>.

               <u>map</u>     A DMA map without a currently active mapping.

               <u>buf</u>     A kernel virtual address pointer to a contiguous (in  KVA)  buffer,  to  be  mapped  into
                       device visible address space.

               <u>buflen</u>  The size of the buffer.

               <u>callback</u> <u>callback_arg</u>
                       The callback function, and its argument.  This function is called once sufficient mapping
                       resources are available for the DMA operation.  If resources are temporarily unavailable,
                       this  function  will  be  deferred  until later, but the load operation will still return
                       immediately to the caller.  Thus, callers should not assume that  the  callback  will  be
                       called  before  the  load  returns, and code should be structured appropriately to handle
                       this.  See below for specific flags and error codes that control this behavior.

               <u>flags</u>   Are as follows:

                       BUS_DMA_NOWAIT  The  load  should  not  be  deferred  in  case  of  insufficient  mapping
                                       resources,  and  instead  should  return  immediately with an appropriate
                                       error.

                       BUS_DMA_NOCACHE
                                       The generated  transactions  to  and  from  the  virtual  page  are  non-
                                       cacheable.   For <b>bus_dmamap_load</b>(), the BUS_DMA_NOCACHE flag is currently
                                       implemented on sparc64.

               Return values to the caller are as follows:

               0            The callback has been called and completed.  The status  of  the  mapping  has  been
                            delivered to the callback.

               EINPROGRESS  The mapping has been deferred for lack of resources.  The callback will be called as
                            soon as resources are available.  Callbacks are serviced in FIFO order.

                            Note  that  subsequent  load  operations  for the same tag that do not require extra
                            resources will still  succeed.   This  may  result  in  out-of-order  processing  of
                            requests.   If  the  caller requires the order of requests to be preserved, then the
                            caller is required to stall subsequent requests until a pending  request's  callback
                            is invoked.

               ENOMEM       The  load  request  has  failed  due  to  insufficient  resources,  and  the  caller
                            specifically used the BUS_DMA_NOWAIT flag.

               EINVAL       The load request was invalid.  The callback has been called and  has  been  provided
                            the same error.  This error value may indicate that <u>dmat</u>, <u>map</u>, <u>buf</u>, or <u>callback</u> were
                            invalid,  or  <u>buflen</u> was larger than the <u>maxsize</u> argument used to create the dma tag
                            <u>dmat</u>.

               When the callback is called, it is presented with an error value indicating  the  disposition  of
               the mapping.  Error may be one of the following:

               0            The  mapping  was  successful and the <u>dm_segs</u> callback argument contains an array of
                            <u>bus_dma_segment_t</u> elements describing the mapping.  This array is only valid  during
                            the scope of the callback function.

               EFBIG        A  mapping  could not be achieved within the segment constraints provided in the tag
                            even though the requested allocation size was less than maxsize.

       <b>bus_dmamap_load_bio</b>(<u>dmat</u>, <u>map</u>, <u>bio</u>, <u>callback</u>, <u>callback_arg</u>, <u>flags</u>)
               This is a variation of <b>bus_dmamap_load</b>() which maps buffers pointed to by <u>bio</u> for DMA  transfers.
               <u>bio</u> may point to either a mapped or unmapped buffer.

       <b>bus_dmamap_load_ccb</b>(<u>dmat</u>, <u>map</u>, <u>ccb</u>, <u>callback</u>, <u>callback_arg</u>, <u>flags</u>)
               This  is  a  variation  of <b>bus_dmamap_load</b>() which maps data pointed to by <u>ccb</u> for DMA transfers.
               The data for <u>ccb</u> may be any of the following types:

               CAM_DATA_VADDR     The data is a single KVA buffer.

               CAM_DATA_PADDR     The data is a single bus address range.

               CAM_DATA_SG        The data is a scatter/gather list of KVA buffers.

               CAM_DATA_SG_PADDR  The data is a scatter/gather list of bus address ranges.

               CAM_DATA_BIO       The data is contained in a <u>struct</u> <u>bio</u> attached to the CCB.

               <b>bus_dmamap_load_ccb</b>() supports the following CCB XPT function codes:

                     XPT_ATA_IO
                     XPT_CONT_TARGET_IO
                     XPT_SCSI_IO

       <b>bus_dmamap_load_mbuf</b>(<u>dmat</u>, <u>map</u>, <u>mbuf</u>, <u>callback2</u>, <u>callback_arg</u>, <u>flags</u>)
               This is a variation of <b>bus_dmamap_load</b>() which maps mbuf chains for DMA transfers.  A  <u>bus_size_t</u>
               argument  is  also  passed to the callback routine, which contains the mbuf chain's packet header
               length.  The BUS_DMA_NOWAIT flag is implied, thus no callback deferral will happen.

               Mbuf chains are assumed to be in kernel virtual address space.

               Beside the error values listed for <b>bus_dmamap_load</b>(), EINVAL will be returned if the size of  the
               mbuf chain exceeds the maximum limit of the DMA tag.

       <b>bus_dmamap_load_mbuf_sg</b>(<u>dmat</u>, <u>map</u>, <u>mbuf</u>, <u>segs</u>, <u>nsegs</u>, <u>flags</u>)
               This  is  just  like  <b>bus_dmamap_load_mbuf</b>() except that it returns immediately without calling a
               callback function.  It is provided for efficiency.  The  scatter/gather  segment  array  <u>segs</u>  is
               provided  by  the  caller and filled in directly by the function.  The <u>nsegs</u> argument is returned
               with the number of segments filled in.  Returns the same errors as <b>bus_dmamap_load_mbuf</b>().

       <b>bus_dmamap_load_uio</b>(<u>dmat</u>, <u>map</u>, <u>uio</u>, <u>callback2</u>, <u>callback_arg</u>, <u>flags</u>)
               This is a variation of <b>bus_dmamap_load</b>() which maps buffers pointed to by <u>uio</u> for DMA  transfers.
               A  <u>bus_size_t</u>  argument  is  also passed to the callback routine, which contains the size of <u>uio</u>,
               i.e.  <u>uio-&gt;uio_resid</u>.  The BUS_DMA_NOWAIT flag is implied, thus no callback deferral will happen.
               Returns the same errors as <b>bus_dmamap_load</b>().

               If  <u>uio-&gt;uio_segflg</u>  is  UIO_USERSPACE,  then  it  is  assumed  that  the  buffer,  <u>uio</u>   is   in
               <u>uio-&gt;uio_td-&gt;td_proc</u>'s  address  space.   User  space  memory  must be in-core and wired prior to
               attempting a map load operation.  Pages may be locked using <u><a href="../man9/vslock.9.html">vslock</a></u>(9).

       <b>bus_dmamap_unload</b>(<u>dmat</u>, <u>map</u>)
               Unloads a DMA map.  Arguments are as follows:

               <u>dmat</u>  DMA tag used to allocate <u>map</u>.

               <u>map</u>   The DMA map that is to be unloaded.

               <b>bus_dmamap_unload</b>() will not perform any implicit synchronization of DMA buffers.  This  must  be
               done explicitly by a call to <b>bus_dmamap_sync</b>() prior to unloading the map.

       <b>bus_dmamap_sync</b>(<u>dmat</u>, <u>map</u>, <u>op</u>)
               Performs  synchronization  of  a device visible mapping with the CPU visible memory referenced by
               that mapping.  Arguments are as follows:

               <u>dmat</u>  DMA tag used to allocate <u>map</u>.

               <u>map</u>   The DMA mapping to be synchronized.

               <u>op</u>    Type of synchronization operation to perform.  See the definition of <u>bus_dmasync_op_t</u> for a
                     description of the acceptable values for <u>op</u>.

               The <b>bus_dmamap_sync</b>() function is the method used to ensure that CPU's and device's direct memory
               access (DMA) to shared memory is coherent.  For example, the CPU might be  used  to  set  up  the
               contents  of  a  buffer  that  is  to be made available to a device.  To ensure that the data are
               visible via the device's mapping of that memory, the  buffer  must  be  loaded  and  a  DMA  sync
               operation  of  BUS_DMASYNC_PREWRITE  must  be  performed after the CPU has updated the buffer and
               before the device access is initiated.  If the CPU modifies  this  buffer  again  later,  another
               BUS_DMASYNC_PREWRITE  sync  operation  must  be  performed  before  an  additional device access.
               Conversely, suppose a device updates memory that is to be read by  a  CPU.   In  this  case,  the
               buffer  must  be loaded, and a DMA sync operation of BUS_DMASYNC_PREREAD must be performed before
               the device access is initiated.  The CPU will only be able to see  the  results  of  this  memory
               update  once  the  DMA operation has completed and a BUS_DMASYNC_POSTREAD sync operation has been
               performed.

               If read and write operations are not preceded and followed  by  the  appropriate  synchronization
               operations, behavior is undefined.

       <b>bus_dmamem_alloc</b>(<u>dmat</u>, <u>**vaddr</u>, <u>flags</u>, <u>*mapp</u>)
               Allocates memory that is mapped into KVA at the address returned in <u>vaddr</u> and that is permanently
               loaded into the newly created <u>bus_dmamap_t</u> returned via <u>mapp</u>.  Arguments are as follows:

               <u>dmat</u>       DMA tag describing the constraints of the DMA mapping.

               <u>vaddr</u>      Pointer to a pointer that will hold the returned KVA mapping of the allocated region.

               <u>flags</u>      Flags are defined as follows:

                          BUS_DMA_WAITOK  The routine can safely wait (sleep) for resources.

                          BUS_DMA_NOWAIT  The  routine  is  not allowed to wait for resources.  If resources are
                                          not available, ENOMEM is returned.

                          BUS_DMA_COHERENT
                                          Attempt  to  map   this   memory   in   a   coherent   fashion.    See
                                          <b>bus_dmamap_create</b>()  above  for  a  description  of  this  flag.   For
                                          <b>bus_dmamem_alloc</b>(), the BUS_DMA_COHERENT flag is currently implemented
                                          on arm, arm64 and sparc64.

                          BUS_DMA_ZERO    Causes the allocated memory to be set to all zeros.

                          BUS_DMA_NOCACHE
                                          The allocated memory will not be cached in the processor caches.   All
                                          memory accesses appear on the bus and are executed without reordering.
                                          For   <b>bus_dmamem_alloc</b>(),   the   BUS_DMA_NOCACHE  flag  is  currently
                                          implemented  on  amd64  and  i386  where  it  results  in  the  Strong
                                          Uncacheable PAT to be set for the allocated virtual address range.

               <u>mapp</u>       Pointer to a <u>bus_dmamap_t</u> where the resulting DMA map will be stored.

               The  size  of  memory to be allocated is <u>maxsize</u> as specified in the call to <b>bus_dma_tag_create</b>()
               for <u>dmat</u>.

               The current implementation of <b>bus_dmamem_alloc</b>() will allocate all requests as a single segment.

               An initial load operation is required to obtain the bus address of the allocated memory,  and  an
               unload  operation is required before freeing the memory, as described below in <b>bus_dmamem_free</b>().
               Maps are automatically handled by this  function  and  should  not  be  explicitly  allocated  or
               destroyed.

               Although  an  explicit  load  is  not  required  for  each access to the memory referenced by the
               returned map, the synchronization requirements as  described  in  the  <b>bus_dmamap_sync</b>()  section
               still apply and should be used to achieve portability on architectures without coherent buses.

               Returns ENOMEM if sufficient memory is not available for completing the operation.

       <b>bus_dmamem_free</b>(<u>dmat</u>, <u>*vaddr</u>, <u>map</u>)
               Frees  memory  previously  allocated  by  <b>bus_dmamem_alloc</b>().   Any mappings will be invalidated.
               Arguments are as follows:

               <u>dmat</u>   DMA tag.

               <u>vaddr</u>  Kernel virtual address of the memory.

               <u>map</u>    DMA map to be invalidated.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Behavior is undefined if invalid arguments are passed to any  of  the  above  functions.   If  sufficient
       resources  cannot be allocated for a given transaction, ENOMEM is returned.  All routines that are not of
       type <u>void</u> will return 0 on success or an error code on failure as discussed above.

       All <u>void</u> routines will succeed if provided with valid arguments.

</pre><h4><b>LOCKING</b></h4><pre>
       Two locking protocols are used by <b>bus_dma</b>.   The  first  is  a  private  global  lock  that  is  used  to
       synchronize  access  to  the bounce buffer pool on the architectures that make use of them.  This lock is
       strictly a leaf lock that is only used internally to <b>bus_dma</b> and is not exposed to clients of the API.

       The second protocol involves protecting various resources stored in the tag.  Since  almost  all  <b>bus_dma</b>
       operations  are  done  through  requests  from the driver that created the tag, the most efficient way to
       protect the tag resources is through the lock that the driver uses.  In cases where <b>bus_dma</b> acts  on  its
       own  without being called by the driver, the lock primitive specified in the tag is acquired and released
       automatically.  An example of this is when the <b>bus_dmamap_load</b>()  callback  function  is  called  from  a
       deferred context instead of the driver context.  This means that certain <b>bus_dma</b> functions must always be
       called with the same lock held that is specified in the tag.  These functions include:

             <b>bus_dmamap_load</b>()
             <b>bus_dmamap_load_bio</b>()
             <b>bus_dmamap_load_ccb</b>()
             <b>bus_dmamap_load_mbuf</b>()
             <b>bus_dmamap_load_mbuf_sg</b>()
             <b>bus_dmamap_load_uio</b>()
             <b>bus_dmamap_unload</b>()
             <b>bus_dmamap_sync</b>()

       There is one exception to this rule.  It is common practice to call some of these functions during driver
       start-up  without  any  locks held.  So long as there is a guarantee of no possible concurrent use of the
       tag by different threads during this operation, it is safe to not hold a lock for these functions.

       Certain <b>bus_dma</b> operations should not be called with the  driver  lock  held,  either  because  they  are
       already  protected by an internal lock, or because they might sleep due to memory or resource allocation.
       The following functions must not be called with any non-sleepable locks held:

             <b>bus_dma_tag_create</b>()
             <b>bus_dmamap_create</b>()
             <b>bus_dmamem_alloc</b>()

       All other functions do not have a locking protocol and can thus be called with or without any  system  or
       driver locks held.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/devclass.9.html">devclass</a></u>(9), <u><a href="../man9/device.9.html">device</a></u>(9), <u><a href="../man9/driver.9.html">driver</a></u>(9), <u><a href="../man9/rman.9.html">rman</a></u>(9), <u><a href="../man9/vslock.9.html">vslock</a></u>(9)

       Jason  R. Thorpe, “A Machine-Independent DMA Framework for NetBSD”, <u>Proceedings</u> <u>of</u> <u>the</u> <u>Summer</u> <u>1998</u> <u>USENIX</u>
       <u>Technical</u> <u>Conference</u>, USENIX Association, June 1998.

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>bus_dma</b> interface first appeared in NetBSD 1.3.

       The <b>bus_dma</b> API was adopted from NetBSD for use in the  CAM  SCSI  subsystem.   The  alterations  to  the
       original  API  were  aimed  to  remove the need for a <u>bus_dma_segment_t</u> array stored in each <u>bus_dmamap_t</u>
       while allowing callers to queue up on scarce resources.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>bus_dma</b> interface was designed and  implemented  by  Jason  R.  Thorpe  of  the  Numerical  Aerospace
       Simulation  Facility,  NASA Ames Research Center.  Additional input on the <b>bus_dma</b> design was provided by
       Chris Demetriou, Charles Hannum, Ross Harvey, Matthew Jacob, Jonathan Stone, and Matt Thomas.

       The <b>bus_dma</b> interface in FreeBSD benefits from the contributions of Justin T.  Gibbs,  Peter  Wemm,  Doug
       Rabson,  Matthew  N.  Dodd, Sam Leffler, Maxime Henrion, Jake Burkholder, Takahashi Yoshihiro, Scott Long
       and many others.

       This manual page was written by Hiten M. Pandya and Justin T. Gibbs.

Debian                                           August 11, 2018                                      <u><a href="../man9/BUS_DMA.9.html">BUS_DMA</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>