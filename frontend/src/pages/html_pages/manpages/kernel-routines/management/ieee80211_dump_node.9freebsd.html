<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ieee80211_node — software 802.11 stack node management functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ieee80211_node — software 802.11 stack node management functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;net80211/ieee80211_var.h&gt;</b>

       <u>struct</u> <u>ieee80211_node</u> <u>*</u>
       <b>ieee80211_find_rxnode</b>(<u>struct</u> <u>ieee80211com</u> <u>*</u>, <u>const</u> <u>struct</u> <u>ieee80211_frame_min</u> <u>*</u>);

       <u>struct</u> <u>ieee80211_node</u> <u>*</u>
       <b>ieee80211_find_rxnode_withkey</b>(<u>struct</u> <u>ieee80211com</u> <u>*</u>,                  <u>const</u> <u>struct</u> <u>ieee80211_frame_min</u> <u>*</u>,
           <u>ieee80211_keyix</u>);

       <u>struct</u> <u>ieee80211_node</u> <u>*</u>
       <b>ieee80211_ref_node</b>(<u>struct</u> <u>ieee80211_node</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_unref_node</b>(<u>struct</u> <u>ieee80211_node</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_free_node</b>(<u>struct</u> <u>ieee80211_node</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_iterate_nodes</b>(<u>struct</u> <u>ieee80211_node_table</u> <u>*</u>, <u>ieee80211_iter_func</u> <u>*f</u>, <u>void</u> <u>*arg</u>);

       <u>void</u>
       <b>ieee80211_dump_nodes</b>(<u>struct</u> <u>ieee80211_node_table</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_dump_node</b>(<u>struct</u> <u>ieee80211_node</u> <u>*</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>net80211</b> layer that supports 802.11 device drivers maintains a database of peer stations  called  the
       “node  table”  in  the <u>ic_sta</u> entry of the <u>ieee80211com</u> structure.  Station mode vaps create an entry for
       the access point the station is associated to.  AP mode vaps  create  entries  for  associated  stations.
       Adhoc  and  mesh  mode  vaps create entries for neighbor stations.  WDS mode vaps create an entry for the
       peer station.  Stations for all vaps reside in the same table; each node entry has a  <u>ni_vap</u>  field  that
       identifies  the  vap  that  created  it.   In  some instances an entry is used by multiple vaps (e.g. for
       dynamic WDS a station associated to an ap vap may also be the peer of a WDS vap).

       Node table entries are reference counted.  That is, there is a count of all  long  term  references  that
       determines  when  an  entry  may  be  reclaimed.   References are held by every in-flight frame sent to a
       station to ensure the entry is not reclaimed while the frame is queued or otherwise  held  by  a  driver.
       Routines  that  lookup  a table entry return a “held reference” (i.e. a pointer to a table entry with the
       reference count incremented).   The  <b>ieee80211_ref_node</b>()  and  <b>ieee80211_unref_node</b>()  calls  explicitly
       increment/decrement  the  reference  count  of  a  node,  but  are rarely used.  Instead most callers use
       <b>ieee80211_free_node</b>() to release a reference and, if the count goes to zero, reclaim the table entry.

       The station table and its entries are exposed to drivers in several ways.  Each frame  transmitted  to  a
       station  includes a reference to the associated node in the <u>m_pkthdr.rcvif</u> field.  This reference must be
       reclaimed by the driver when transmit processing is done.  For each frame received the driver must lookup
       the table entry to use in dispatching the frame  “up  the  stack”.   This  lookup  implicitly  obtains  a
       reference  to  the  table  entry  and  the  driver  must  reclaim  the reference when frame processing is
       completed.  Otherwise drivers frequently inspect the contents of the  <u>iv_bss</u>  node  when  handling  state
       machine changes as important information is maintained in the data structure.

       The  node table is opaque to drivers.  Entries may be looked up using one of the pre-defined API's or the
       <b>ieee80211_iterate_nodes</b>() call may be used to iterate through all entries to do  per-node  processing  or
       implement  some  non-standard  search  mechanism.  Note that <b>ieee80211_iterate_nodes</b>() is single-threaded
       per-device and the effort processing involved is fairly substantial so it should be used carefully.

       Two  routines  are  provided  to  print  the  contents  of  nodes   to   the   console   for   debugging:
       <b>ieee80211_dump_node</b>()  displays  the  contents of a single node while <b>ieee80211_dump_nodes</b>() displays the
       contents of the specified node table.  Nodes may also be displayed using  <u><a href="../man4/ddb.4.html">ddb</a></u>(4)  with  the  “show  node”
       directive and the station node table can be displayed with “show statab”.

</pre><h4><b>DRIVER</b> <b>PRIVATE</b> <b>STATE</b></h4><pre>
       Node  data  structures  may  be  extended by the driver to include driver-private state.  This is done by
       overriding the <u>ic_node_alloc</u> method used to allocate a node table entry.  The driver method must allocate
       a structure that is an extension of the <u>ieee80211_node</u> structure.  For example the <u><a href="../man4/iwi.4.html">iwi</a></u>(4) driver  defines
       a private node structure as:

             struct iwi_node {
                     struct ieee80211_node   in_node;
                     int                     in_station;
             };

       and then provides a private allocation routine that does this:

             static struct ieee80211_node *
             iwi_node_alloc(struct ieee80211vap *vap,
                 const uint8_t mac[IEEE80211_ADDR_LEN])
             {
                     struct iwi_node *in;

                     in = malloc(sizeof(struct iwi_node), M_80211_NODE,
                             M_NOWAIT | M_ZERO);
                     if (in == NULL)
                             return NULL;
                     in-&gt;in_station = -1;
                     return &amp;in-&gt;in_node;
             }

       Note  that  when  reclaiming  a node allocated by the driver the “parent method” must be called to ensure
       <b>net80211</b> state is reclaimed; for example:

             static void
             iwi_node_free(struct ieee80211_node *ni)
             {
                     struct ieee80211com *ic = ni-&gt;ni_ic;
                     struct iwi_softc *sc = ic-&gt;ic_ifp-&gt;if_softc;
                     struct iwi_node *in = (struct iwi_node *)ni;

                     if (in-&gt;in_station != -1)
                             free_unr(sc-&gt;sc_unr, in-&gt;in_station);
                     sc-&gt;sc_node_free(ni);   /* invoke net80211 free handler */
             }

       Beware that care must be taken to avoid holding references that might cause nodes from  being  reclaimed.
       <b>net80211</b>  will  reclaim a node when the last reference is reclaimed in its data structures.  However if a
       driver holds additional references then <b>net80211</b> will not recognize this and table entries  will  not  be
       reclaimed.   Such  references  should  not  be  needed if the driver overrides the <u>ic_node_cleanup</u> and/or
       <u>ic_node_free</u> methods.

</pre><h4><b>KEY</b> <b>TABLE</b> <b>SUPPORT</b></h4><pre>
       Node table lookups are typically done using a hash of the stations' mac address.  When  receiving  frames
       this  is sufficient to find the node table entry for the transmitter.  But some devices also identify the
       sending station in the device state received with each frame and  this  data  can  be  used  to  optimize
       lookups on receive using a companion table called the “keytab”.  This table records a separate node table
       reference  that can be fetched without any locking using the table index.  This logic is handled with the
       <b>ieee80211_find_rxnode_withkey</b>() call: if a keytab entry is found using the specified  index  then  it  is
       returned  directly; otherwise a normal lookup is done and the keytab entry is written using the specified
       index.  If the specified index is IEEE80211_KEYIX_NONE then a normal  lookup  is  done  without  a  table
       update.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/ddb.4.html">ddb</a></u>(4), <u><a href="../man9/ieee80211.9.html">ieee80211</a></u>(9), <u><a href="../man9/ieee80211_proto.9.html">ieee80211_proto</a></u>(9)

Debian                                           April 28, 2010                                <u><a href="../man9/IEEE80211_NODE.9.html">IEEE80211_NODE</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>