<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOCK_PROFILING — kernel lock profiling support</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       LOCK_PROFILING — kernel lock profiling support

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>options</b> <b>LOCK_PROFILING</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  LOCK_PROFILING  kernel  option  adds  support  for  measuring  and reporting lock use and contention
       statistics.  These statistics are collated by  “acquisition  point”.   Acquisition  points  are  distinct
       places  in  the  kernel  source  code  (identified  by  source file name and line number) where a lock is
       acquired.

       For each acquisition point, the following statistics are accumulated:

       <b>•</b>   The longest time the lock was ever continuously held after being acquired at this point.

       <b>•</b>   The total time the lock was held after being acquired at this point.

       <b>•</b>   The total time that threads have spent waiting to acquire the lock.

       <b>•</b>   The total number of non-recursive acquisitions.

       <b>•</b>   The total number of times the lock was already held by another thread when this  point  was  reached,
           requiring a spin or a sleep.

       <b>•</b>   The  total  number  of  times another thread tried to acquire the lock while it was held after having
           been acquired at this point.

       In addition, the average hold time and average wait time are derived from the total hold time  and  total
       wait time respectively and the number of acquisitions.

       The  LOCK_PROFILING  kernel option also adds the following <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) variables to control and monitor the
       profiling code:

       <u>debug.lock.prof.enable</u>
               Enable or disable the lock profiling code.  This defaults to 0 (off).

       <u>debug.lock.prof.reset</u>
               Reset the current lock profiling buffers.

       <u>debug.lock.prof.stats</u>
               The actual profiling statistics in plain text.  The columns are as follows, from left to right:

               <u>max</u>       The longest continuous hold time in microseconds.

               <u>wait_max</u>  The longest continuous wait time in microseconds.

               <u>total</u>     The total (accumulated) hold time in microseconds.

               <u>wait_total</u>
                         The total (accumulated) wait time in microseconds.

               <u>count</u>     The total number of acquisitions.

               <u>avg</u>       The average hold time in microseconds, derived from the total hold time and the  number
                         of acquisitions.

               <u>wait_avg</u>  The  average wait time in microseconds, derived from the total wait time and the number
                         of acquisitions.

               <u>cnt_hold</u>  The number of times the lock was held and another thread attempted to acquire the lock.

               <u>cnt_lock</u>  The number of times the lock was already held when this point was reached.

               <u>name</u>      The name of the acquisition point, derived from the source file name and  line  number,
                         followed by the name of the lock in parentheses.

       <u>debug.lock.prof.rejected</u>
               The number of acquisition points that were ignored after the table filled up.

       <u>debug.lock.prof.skipspin</u>
               Disable  or  enable the lock profiling code for the spin locks.  This defaults to 0 (do profiling
               for the spin locks).

       <u>debug.lock.prof.skipcount</u>
               Do sampling approximately every N lock acquisitions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8), <u><a href="../man9/mutex.9.html">mutex</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       Mutex profiling support appeared  in  FreeBSD  5.0.   Generalized  lock  profiling  support  appeared  in
       FreeBSD 7.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  <b>MUTEX_PROFILING</b>  code  was  written  by  Eivind  Eklund  &lt;<u><a href="mailto:eivind@FreeBSD.org">eivind@FreeBSD.org</a></u>&gt;,  Dag-Erling  Smørgrav
       &lt;<u><a href="mailto:des@FreeBSD.org">des@FreeBSD.org</a></u>&gt; and Robert Watson &lt;<u><a href="mailto:rwatson@FreeBSD.org">rwatson@FreeBSD.org</a></u>&gt;.  The <b>LOCK_PROFILING</b> code was  written  by  Kip
       Macy &lt;<u><a href="mailto:kmacy@FreeBSD.org">kmacy@FreeBSD.org</a></u>&gt;.  This manual page was written by Dag-Erling Smørgrav &lt;<u><a href="mailto:des@FreeBSD.org">des@FreeBSD.org</a></u>&gt;.

</pre><h4><b>NOTES</b></h4><pre>
       The  LOCK_PROFILING  option  increases the size of <u>struct</u> <u>lock_object</u>, so a kernel built with that option
       will not work with modules built without it.

       The LOCK_PROFILING option also prevents inlining of the mutex code, which can result in a  fairly  severe
       performance  penalty.  This is, however, not always the case.  LOCK_PROFILING can introduce a substantial
       performance overhead that is easily monitorable using other profiling tools, so combining profiling tools
       with LOCK_PROFILING is not recommended.

       Measurements are  made  and  stored  in  nanoseconds  using  <u><a href="../man9/nanotime.9.html">nanotime</a></u>(9),  (on  architectures  without  a
       synchronized  TSC)  but are presented in microseconds.  This should still be sufficient for the locks one
       would be most interested in profiling (those that are held long and/or acquired often).

       LOCK_PROFILING should generally not be used in combination with other debugging options, as  the  results
       may be strongly affected by interactions between the features.  In particular, LOCK_PROFILING will report
       higher  than normal <u><a href="../man9/uma.9.html">uma</a></u>(9) lock contention when run with INVARIANTS due to extra locking that occurs when
       INVARIANTS is present; likewise, using it in combination with WITNESS will lead to much higher lock  hold
       times and contention in profiling output.

Debian                                            March 7, 2012                                <u><a href="../man9/LOCK_PROFILING.9.html">LOCK_PROFILING</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>