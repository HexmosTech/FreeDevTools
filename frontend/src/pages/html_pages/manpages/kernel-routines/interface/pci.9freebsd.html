<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pci,   pci_alloc_msi,   pci_alloc_msix,   pci_disable_busmaster,   pci_disable_io,  pci_enable_busmaster,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pci,   pci_alloc_msi,   pci_alloc_msix,   pci_disable_busmaster,   pci_disable_io,  pci_enable_busmaster,
       pci_enable_io,   pci_find_bsf,    pci_find_cap,    pci_find_dbsf,    pci_find_device,    pci_find_extcap,
       pci_find_htcap,  pci_find_next_cap,  pci_find_next_extcap,  pci_find_next_htcap, pci_find_pcie_root_port,
       pci_get_id,    pci_get_max_payload,    pci_get_max_read_req,    pci_get_powerstate,    pci_get_vpd_ident,
       pci_get_vpd_readonly, pci_iov_attach, pci_iov_attach_name, pci_iov_detach, pci_msi_count, pci_msix_count,
       pci_msix_pba_bar, pci_msix_table_bar, pci_pending_msix, pci_read_config, pci_release_msi, pci_remap_msix,
       pci_restore_state,    pci_save_state,    pci_set_max_read_req,    pci_set_powerstate,   pci_write_config,
       pcie_adjust_config,         pcie_flr,         pcie_get_max_completion_timeout,          pcie_read_config,
       pcie_wait_for_pending_transactions, pcie_write_config — PCI bus interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/bus.h&gt;</b>
       <b>#include</b> <b>&lt;dev/pci/pcireg.h&gt;</b>
       <b>#include</b> <b>&lt;dev/pci/pcivar.h&gt;</b>

       <u>int</u>
       <b>pci_alloc_msi</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>*count</u>);

       <u>int</u>
       <b>pci_alloc_msix</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>*count</u>);

       <u>int</u>
       <b>pci_disable_busmaster</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_disable_io</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>space</u>);

       <u>int</u>
       <b>pci_enable_busmaster</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_enable_io</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>space</u>);

       <u>device_t</u>
       <b>pci_find_bsf</b>(<u>uint8_t</u> <u>bus</u>, <u>uint8_t</u> <u>slot</u>, <u>uint8_t</u> <u>func</u>);

       <u>int</u>
       <b>pci_find_cap</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>capability</u>, <u>int</u> <u>*capreg</u>);

       <u>device_t</u>
       <b>pci_find_dbsf</b>(<u>uint32_t</u> <u>domain</u>, <u>uint8_t</u> <u>bus</u>, <u>uint8_t</u> <u>slot</u>, <u>uint8_t</u> <u>func</u>);

       <u>device_t</u>
       <b>pci_find_device</b>(<u>uint16_t</u> <u>vendor</u>, <u>uint16_t</u> <u>device</u>);

       <u>int</u>
       <b>pci_find_extcap</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>capability</u>, <u>int</u> <u>*capreg</u>);

       <u>int</u>
       <b>pci_find_htcap</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>capability</u>, <u>int</u> <u>*capreg</u>);

       <u>int</u>
       <b>pci_find_next_cap</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>capability</u>, <u>int</u> <u>start</u>, <u>int</u> <u>*capreg</u>);

       <u>int</u>
       <b>pci_find_next_extcap</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>capability</u>, <u>int</u> <u>start</u>, <u>int</u> <u>*capreg</u>);

       <u>int</u>
       <b>pci_find_next_htcap</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>capability</u>, <u>int</u> <u>start</u>, <u>int</u> <u>*capreg</u>);

       <u>device_t</u>
       <b>pci_find_pcie_root_port</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_get_id</b>(<u>device_t</u> <u>dev</u>, <u>enum</u> <u>pci_id_type</u> <u>type</u>, <u>uintptr_t</u> <u>*id</u>);

       <u>int</u>
       <b>pci_get_max_payload</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_get_max_read_req</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_get_powerstate</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_get_vpd_ident</b>(<u>device_t</u> <u>dev</u>, <u>const</u> <u>char</u> <u>**identptr</u>);

       <u>int</u>
       <b>pci_get_vpd_readonly</b>(<u>device_t</u> <u>dev</u>, <u>const</u> <u>char</u> <u>*kw</u>, <u>const</u> <u>char</u> <u>**vptr</u>);

       <u>int</u>
       <b>pci_msi_count</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_msix_count</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_msix_pba_bar</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_msix_table_bar</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_pending_msix</b>(<u>device_t</u> <u>dev</u>, <u>u_int</u> <u>index</u>);

       <u>uint32_t</u>
       <b>pci_read_config</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>reg</u>, <u>int</u> <u>width</u>);

       <u>int</u>
       <b>pci_release_msi</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_remap_msix</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>count</u>, <u>const</u> <u>u_int</u> <u>*vectors</u>);

       <u>void</u>
       <b>pci_restore_state</b>(<u>device_t</u> <u>dev</u>);

       <u>void</u>
       <b>pci_save_state</b>(<u>device_t</u> <u>dev</u>);

       <u>int</u>
       <b>pci_set_max_read_req</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>size</u>);

       <u>int</u>
       <b>pci_set_powerstate</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>state</u>);

       <u>void</u>
       <b>pci_write_config</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>reg</u>, <u>uint32_t</u> <u>val</u>, <u>int</u> <u>width</u>);

       <u>uint32_t</u>
       <b>pcie_adjust_config</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>reg</u>, <u>uint32_t</u> <u>mask</u>, <u>uint32_t</u> <u>val</u>, <u>int</u> <u>width</u>);

       <u>bool</u>
       <b>pcie_flr</b>(<u>device_t</u> <u>dev</u>, <u>u_int</u> <u>max_delay</u>, <u>bool</u> <u>force</u>);

       <u>int</u>
       <b>pcie_get_max_completion_timeout</b>(<u>device_t</u> <u>dev</u>);

       <u>uint32_t</u>
       <b>pcie_read_config</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>reg</u>, <u>int</u> <u>width</u>);

       <u>bool</u>
       <b>pcie_wait_for_pending_transactions</b>(<u>device_t</u> <u>dev</u>, <u>u_int</u> <u>max_delay</u>);

       <u>void</u>
       <b>pcie_write_config</b>(<u>device_t</u> <u>dev</u>, <u>int</u> <u>reg</u>, <u>uint32_t</u> <u>val</u>, <u>int</u> <u>width</u>);

       <u>void</u>
       <b>pci_event_fn</b>(<u>void</u> <u>*arg</u>, <u>device_t</u> <u>dev</u>);

       <b>EVENTHANDLER_REGISTER</b>(<u>pci_add_device</u>, <u>pci_event_fn</u>);

       <b>EVENTHANDLER_DEREGISTER</b>(<u>pci_delete_resource</u>, <u>pci_event_fn</u>);

       <b>#include</b> <b>&lt;dev/pci/pci_iov.h&gt;</b>

       <u>int</u>
       <b>pci_iov_attach</b>(<u>device_t</u> <u>dev</u>, <u>nvlist_t</u> <u>*pf_schema</u>, <u>nvlist_t</u> <u>*vf_schema</u>);

       <u>int</u>
       <b>pci_iov_attach_name</b>(<u>device_t</u> <u>dev</u>, <u>nvlist_t</u> <u>*pf_schema</u>, <u>nvlist_t</u> <u>*vf_schema</u>, <u>const</u> <u>char</u> <u>*fmt</u>, <u>...</u>);

       <u>int</u>
       <b>pci_iov_detach</b>(<u>device_t</u> <u>dev</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>pci</b> set of functions are used for managing PCI devices.  The functions are split into several groups:
       raw  configuration  access,  locating  devices,  device  information,  device  configuration, and message
       signaled interrupts.

   <b>Raw</b> <b>Configuration</b> <b>Access</b>
       The <b>pci_read_config</b>() function is used to read data from the PCI configuration space of the  device  <u>dev</u>,
       at offset <u>reg</u>, with <u>width</u> specifying the size of the access.

       The  <b>pci_write_config</b>()  function  is  used  to write the value <u>val</u> to the PCI configuration space of the
       device <u>dev</u>, at offset <u>reg</u>, with <u>width</u> specifying the size of the access.

       The <b>pcie_adjust_config</b>() function is used to modify the value of a register in the PCI-express capability
       register set of device <u>dev</u>.  The offset <u>reg</u> specifies a relative offset in the register  set  with  <u>width</u>
       specifying  the  size  of the access.  The new value of the register is computed by modifying bits set in
       <u>mask</u> to the value in <u>val</u>.  Any bits not specified in <u>mask</u> are  preserved.   The  previous  value  of  the
       register is returned.

       The  <b>pcie_read_config</b>()  function  is  used to read the value of a register in the PCI-express capability
       register set of device <u>dev</u>.  The offset <u>reg</u> specifies a relative offset in the register  set  with  <u>width</u>
       specifying the size of the access.

       The  <b>pcie_write_config</b>()  function  is  used  to  write  the  value  <u>val</u> to a register in the PCI-express
       capability register set of device <u>dev</u>.  The offset <u>reg</u> specifies a relative offset in  the  register  set
       with <u>width</u> specifying the size of the access.

       <u>NOTE</u>:  Device drivers should only use these functions for functionality that is not available via another
       <b>pci</b>() function.

   <b>Locating</b> <b>Devices</b>
       The <b>pci_find_bsf</b>() function looks up the <u>device_t</u> of a PCI device, given its <u>bus</u>, <u>slot</u>,  and  <u>func</u>.   The
       <u>slot</u>  number  actually refers to the number of the device on the bus, which does not necessarily indicate
       its geographic location in terms of a physical slot.  Note that in  case  the  system  has  multiple  PCI
       domains, the <b>pci_find_bsf</b>() function only searches the first one.  Actually, it is equivalent to:

             pci_find_dbsf(0, bus, slot, func);

       The  <b>pci_find_dbsf</b>()  function  looks  up  the <u>device_t</u> of a PCI device, given its <u>domain</u>, <u>bus</u>, <u>slot</u>, and
       <u>func</u>.  The <u>slot</u> number actually refers to the number of the device on the bus, which does not necessarily
       indicate its geographic location in terms of a physical slot.

       The <b>pci_find_device</b>() function looks up the <u>device_t</u> of a PCI device, given its <u>vendor</u>  and  <u>device</u>  IDs.
       Note  that  there  can be multiple matches for this search; this function only returns the first matching
       device.

   <b>Device</b> <b>Information</b>
       The <b>pci_find_cap</b>() function is used to locate the first instance of a PCI capability register set for the
       device <u>dev</u>.  The capability to locate is specified by ID via <u>capability</u>.  Constant  macros  of  the  form
       PCIY_xxx for standard capability IDs are defined in &lt;<u>dev/pci/pcireg.h</u>&gt;.  If the capability is found, then
       <u>*capreg</u>  is  set  to the offset in configuration space of the capability register set, and <b>pci_find_cap</b>()
       returns zero.  If the capability is not found or the device does not support capabilities, <b>pci_find_cap</b>()
       returns an error.  The <b>pci_find_next_cap</b>() function is  used  to  locate  the  next  instance  of  a  PCI
       capability  register  set  for  the  device  <u>dev</u>.   The  <u>start</u>  should be the <u>*capreg</u> returned by a prior
       <b>pci_find_cap</b>() or <b>pci_find_next_cap</b>().  When no more instances are located <b>pci_find_next_cap</b>() returns an
       error.

       The <b>pci_find_extcap</b>() function is used to locate the first instance of a PCI-express extended  capability
       register  set  for  the device <u>dev</u>.  The extended capability to locate is specified by ID via <u>capability</u>.
       Constant  macros  of  the  form  PCIZ_xxx  for  standard  extended  capability   IDs   are   defined   in
       &lt;<u>dev/pci/pcireg.h</u>&gt;.   If  the  extended  capability  is  found,  then  <u>*capreg</u>  is  set  to the offset in
       configuration space of the extended capability register set, and <b>pci_find_extcap</b>() returns zero.  If  the
       extended  capability is not found or the device is not a PCI-express device, <b>pci_find_extcap</b>() returns an
       error.  The <b>pci_find_next_extcap</b>() function is used to locate the next instance of a PCI-express extended
       capability register set for the device <u>dev</u>.  The  <u>start</u>  should  be  the  <u>*capreg</u>  returned  by  a  prior
       <b>pci_find_extcap</b>()  or  <b>pci_find_next_extcap</b>().  When no more instances are located <b>pci_find_next_extcap</b>()
       returns an error.

       The <b>pci_find_htcap</b>() function is used to  locate  the  first  instance  of  a  HyperTransport  capability
       register set for the device <u>dev</u>.  The capability to locate is specified by type via <u>capability</u>.  Constant
       macros  of  the  form  PCIM_HTCAP_xxx  for  standard  HyperTransport  capability  types  are  defined  in
       &lt;<u>dev/pci/pcireg.h</u>&gt;.  If the capability is found, then <u>*capreg</u> is set to the offset in configuration space
       of the capability register set, and <b>pci_find_htcap</b>() returns zero.  If the capability is not found or the
       device is not a HyperTransport device, <b>pci_find_htcap</b>()  returns  an  error.   The  <b>pci_find_next_htcap</b>()
       function  is  used to locate the next instance of a HyperTransport capability register set for the device
       <u>dev</u>.  The <u>start</u> should be the <u>*capreg</u> returned by  a  prior  <b>pci_find_htcap</b>()  or  <b>pci_find_next_htcap</b>().
       When no more instances are located <b>pci_find_next_htcap</b>() returns an error.

       The  <b>pci_find_pcie_root_port</b>()  function walks up the PCI device hierarchy to locate the PCI-express root
       port upstream of <u>dev</u>.  If a root port is not found, <b>pci_find_pcie_root_port</b>() returns NULL.

       The <b>pci_get_id</b>() function is used to read an identifier from a device.  The <u>type</u> flag is used to  specify
       which identifier to read.  The following flags are supported:

       PCI_ID_RID  Read the routing identifier for the device.

       PCI_ID_MSI  Read the MSI routing ID.  This is needed by some interrupt controllers to route MSI and MSI-X
                   interrupts.

       The  <b>pci_get_vpd_ident</b>() function is used to fetch a device's Vital Product Data (VPD) identifier string.
       If the device <u>dev</u> supports VPD and provides an identifier string, then <u>*identptr</u> is set  to  point  at  a
       read-only,  null-terminated  copy of the identifier string, and <b>pci_get_vpd_ident</b>() returns zero.  If the
       device does not support VPD or does not provide an identifier string, then <b>pci_get_vpd_ident</b>() returns an
       error.

       The <b>pci_get_vpd_readonly</b>() function is used to fetch the value of a single VPD read-only keyword for  the
       device  <u>dev</u>.   The keyword to fetch is identified by the two character string <u>kw</u>.  If the device supports
       VPD and provides a read-only value for the requested keyword, then <u>*vptr</u> is set to point at a  read-only,
       null-terminated  copy  of  the  value,  and  <b>pci_get_vpd_readonly</b>() returns zero.  If the device does not
       support VPD or does not provide the requested keyword, then <b>pci_get_vpd_readonly</b>() returns an error.

       The <b>pcie_get_max_completion_timeout</b>() function returns the maximum completion timeout configured for  the
       device    <u>dev</u>    in    microseconds.     If    the    <u>dev</u>   device   is   not   a   PCI-express   device,
       <b>pcie_get_max_completion_timeout</b>() returns zero.  When completion timeouts  are  disabled  for  <u>dev</u>,  this
       function returns the maxmimum timeout that would be used if timeouts were enabled.

       The <b>pcie_wait_for_pending_transactions</b>() function waits for any pending transactions initiated by the <u>dev</u>
       device  to  complete.   The  function checks for pending transactions by polling the transactions pending
       flag in the PCI-express device status register.  It returns true once the  transaction  pending  flag  is
       clear.       If      transactions     are     still     pending     after     <u>max_delay</u>     milliseconds,
       <b>pcie_wait_for_pending_transactions</b>()    returns    false.     If    <u>max_delay</u>    is    set    to    zero,
       <b>pcie_wait_for_pending_transactions</b>()  performs  a  single check; otherwise, this function may sleep while
       polling the transactions pending flag.  <b>pcie_wait_for_pending_transactions</b> returns true if <u>dev</u> is  not  a
       PCI-express device.

   <b>Device</b> <b>Configuration</b>
       The  <b>pci_enable_busmaster</b>()  function  enables  PCI  bus  mastering  for  the  device <u>dev</u>, by setting the
       PCIM_CMD_BUSMASTEREN bit in the PCIR_COMMAND register.  The <b>pci_disable_busmaster</b>() function clears  this
       bit.

       The  <b>pci_enable_io</b>()  function enables memory or I/O port address decoding for the device <u>dev</u>, by setting
       the  PCIM_CMD_MEMEN  or  PCIM_CMD_PORTEN  bit  in   the   PCIR_COMMAND   register   appropriately.    The
       <b>pci_disable_io</b>()  function  clears  the  appropriate bit.  The <u>space</u> argument specifies which resource is
       affected; this can be either SYS_RES_MEMORY or SYS_RES_IOPORT  as  appropriate.   Device  drivers  should
       generally  not  use  these  routines  directly.   The  PCI  bus will enable decoding automatically when a
       SYS_RES_MEMORY   or   SYS_RES_IOPORT    resource    is    activated    via    <u><a href="../man9/bus_alloc_resource.9.html">bus_alloc_resource</a></u>(9)    or
       <u><a href="../man9/bus_activate_resource.9.html">bus_activate_resource</a></u>(9).

       The  <b>pci_get_max_payload</b>()  function  returns  the  current  maximum TLP payload size in bytes for a PCI-
       express device.  If the <u>dev</u> device is not a PCI-express device, <b>pci_get_max_payload</b>() returns zero.

       The <b>pci_get_max_read_req</b>() function returns the current maximum read request size in  bytes  for  a  PCI-
       express device.  If the <u>dev</u> device is not a PCI-express device, <b>pci_get_max_read_req</b>() returns zero.

       The  <b>pci_set_max_read_req</b>()  sets  the PCI-express maximum read request size for <u>dev</u>.  The requested <u>size</u>
       may be adjusted, and <b>pci_set_max_read_req</b>() returns the actual size set in bytes.  If the <u>dev</u>  device  is
       not a PCI-express device, <b>pci_set_max_read_req</b>() returns zero.

       The  <b>pci_get_powerstate</b>() function returns the current power state of the device <u>dev</u>.  If the device does
       not support power management capabilities, then the default state of PCI_POWERSTATE_D0 is returned.   The
       following power states are defined by PCI:

       PCI_POWERSTATE_D0       State  in  which  device  is on and running.  It is receiving full power from the
                               system and delivering full functionality to the user.

       PCI_POWERSTATE_D1       Class-specific low-power state in which device context may or may  not  be  lost.
                               Buses  in  this  state  cannot  do  anything to the bus, to force devices to lose
                               context.

       PCI_POWERSTATE_D2       Class-specific low-power state in which device context may or may  not  be  lost.
                               Attains  greater  power  savings than PCI_POWERSTATE_D1.  Buses in this state can
                               cause devices to lose some context.  Devices <u>must</u> be prepared for the bus  to  be
                               in this state or higher.

       PCI_POWERSTATE_D3       State  in  which  the device is off and not running.  Device context is lost, and
                               power from the device can be removed.

       PCI_POWERSTATE_UNKNOWN  State of the device is unknown.

       The <b>pci_set_powerstate</b>() function is used to transition the device <u>dev</u> to the PCI power state <u>state</u>.   If
       the device does not support power management capabilities or it does not support the specific power state
       <u>state</u>, then the function will fail with EOPNOTSUPP.

       The  <b>pci_iov_attach</b>()  function is used to advertise that the given device (and associated device driver)
       supports PCI Single-Root I/O Virtualization (SR-IOV).  A driver that supports SR-IOV must  implement  the
       <u><a href="../man9/PCI_IOV_INIT.9.html">PCI_IOV_INIT</a></u>(9),  <u><a href="../man9/PCI_IOV_ADD_VF.9.html">PCI_IOV_ADD_VF</a></u>(9) and <u><a href="../man9/PCI_IOV_UNINIT.9.html">PCI_IOV_UNINIT</a></u>(9) methods.  This function should be called during
       the <u><a href="../man9/DEVICE_ATTACH.9.html">DEVICE_ATTACH</a></u>(9) method.  If this function returns an error, it is recommended that the device driver
       still successfully attaches, but runs with SR-IOV disabled.  The <u>pf_schema</u> and <u>vf_schema</u>  parameters  are
       used  to  define  what  device-specific configuration parameters the device driver accepts when SR-IOV is
       enabled for the Physical Function (PF) and for individual  Virtual  Functions  (VFs)  respectively.   See
       <u><a href="../man9/pci_iov_schema.9.html">pci_iov_schema</a></u>(9)  for  details  on how to construct the schema.  If either the <u>pf_schema</u> or <u>vf_schema</u> is
       invalid or specifies parameter names that  conflict  with  parameter  names  that  are  already  in  use,
       <b>pci_iov_attach</b>()  will  return  an  error and SR-IOV will not be available on the PF device.  If a driver
       does not accept configuration parameters for either the PF device or the VF devices, the driver must pass
       an empty schema for that device.   The  SR-IOV  infrastructure  takes  ownership  of  the  <u>pf_schema</u>  and
       <u>vf_schema</u> and is responsible for freeing them.  The driver must never free the schemas itself.

       The  <b>pci_iov_attach_name</b>()  function  is  a  variant  of  <b>pci_iov_attach</b>()  that  allows  the name of the
       associated character device in <u>/dev/iov</u> to be specified by <u>fmt</u>.  The <b>pci_iov_attach</b>() function  uses  the
       name of <u>dev</u> as the device name.

       The  <b>pci_iov_detach</b>()  function is used to advise the SR-IOV infrastructure that the driver for the given
       device is attempting to detach and that all SR-IOV resources for  the  device  must  be  released.   This
       function must be called during the <u><a href="../man9/DEVICE_DETACH.9.html">DEVICE_DETACH</a></u>(9) method if <b>pci_iov_attach</b>() was successfully called on
       the device and <b>pci_iov_detach</b>() has not subsequently been called on the device and returned no error.  If
       this  function  returns an error, the <u><a href="../man9/DEVICE_DETACH.9.html">DEVICE_DETACH</a></u>(9) method must fail and return an error, as detaching
       the PF driver while VF devices are active would cause system instability.  This function is safe to  call
       and  will  always  succeed if <b>pci_iov_attach</b>() previously failed with an error on the given device, or if
       <b>pci_iov_attach</b>() was never called on the device.

       The <b>pci_save_state</b>() and <b>pci_restore_state</b>() functions can be used by a device driver to save and restore
       standard PCI config registers.  The <b>pci_save_state</b>() function must be invoked while the device has  valid
       state  before  <b>pci_restore_state</b>()  can  be  used.   If  the  device  is  not  in the fully-powered state
       (PCI_POWERSTATE_D0) when <b>pci_restore_state</b>()  is  invoked,  then  the  device  will  be  transitioned  to
       PCI_POWERSTATE_D0 before any config registers are restored.

       The <b>pcie_flr</b>() function requests a Function Level Reset (FLR) of <u>dev</u>.  If <u>dev</u> is not a PCI-express device
       or does not support Function Level Resets via the PCI-express device control register, false is returned.
       Pending      transactions      are      drained     by     disabling     busmastering     and     calling
       <b>pcie_wait_for_pending_transactions</b>() before resetting the device.  The <u>max_delay</u> argument  specifies  the
       maximum  timeout  to wait for pending transactions as described for <b>pcie_wait_for_pending_transactions</b>().
       If <b>pcie_wait_for_pending_transactions</b>() fails with a timeout and <u>force</u>  is  false,  busmastering  is  re-
       enabled and false is returned.  If <b>pcie_wait_for_pending_transactions</b>() fails with a timeout and <u>force</u> is
       true,  the  device is reset despite the timeout.  After the reset has been requested, <b>pcie_flr</b> sleeps for
       at least 100 milliseconds before returning true.  Note that <b>pcie_flr</b> does not save and restore any  state
       around the reset.  The caller should save and restore state as needed.

   <b>Message</b> <b>Signaled</b> <b>Interrupts</b>
       Message  Signaled  Interrupts (MSI) and Enhanced Message Signaled Interrupts (MSI-X) are PCI capabilities
       that provide an alternate method for PCI devices to signal interrupts.   The  legacy  INTx  interrupt  is
       available  to PCI devices as a SYS_RES_IRQ resource with a resource ID of zero.  MSI and MSI-X interrupts
       are available to PCI devices as one or more SYS_RES_IRQ resources with resource IDs greater than zero.  A
       driver must ask the PCI bus to allocate MSI or MSI-X interrupts using <b>pci_alloc_msi</b>() or <b>pci_alloc_msix</b>()
       before it can use MSI or MSI-X SYS_RES_IRQ resources.  A driver is not allowed to  use  the  legacy  INTx
       SYS_RES_IRQ resource if MSI or MSI-X interrupts have been allocated, and attempts to allocate MSI or MSI-
       X  interrupts  will fail if the driver is currently using the legacy INTx SYS_RES_IRQ resource.  A driver
       is only allowed to use either MSI or MSI-X, but not both.

       The <b>pci_msi_count</b>() function returns the maximum number of MSI messages supported by the device <u>dev</u>.   If
       the device does not support MSI, then <b>pci_msi_count</b>() returns zero.

       The  <b>pci_alloc_msi</b>()  function  attempts  to  allocate  <u>*count</u>  MSI  messages  for  the  device <u>dev</u>.  The
       <b>pci_alloc_msi</b>() function may allocate  fewer  messages  than  requested  for  various  reasons  including
       requests for more messages than the device <u>dev</u> supports, or if the system has a shortage of available MSI
       messages.   On  success,  <u>*count</u>  is  set to the number of messages allocated and <b>pci_alloc_msi</b>() returns
       zero.  The SYS_RES_IRQ resources for the allocated messages will be available at consecutive resource IDs
       beginning with one.  If <b>pci_alloc_msi</b>() is not able to allocate any messages, it returns an error.   Note
       that  MSI  only  supports  message counts that are powers of two; requests to allocate a non-power of two
       count of messages will fail.

       The <b>pci_release_msi</b>() function is used to release any allocated MSI or MSI-X messages back to the system.
       If any MSI or MSI-X SYS_RES_IRQ resources are allocated by the driver  or  have  a  configured  interrupt
       handler,  this function will fail with EBUSY.  The <b>pci_release_msi</b>() function returns zero on success and
       an error on failure.

       The <b>pci_msix_count</b>() function returns the maximum number of MSI-X messages supported by the  device  <u>dev</u>.
       If the device does not support MSI-X, then <b>pci_msix_count</b>() returns zero.

       The  <b>pci_msix_pba_bar</b>()  function  returns the offset in configuration space of the Base Address Register
       (BAR) containing the MSI-X Pending Bit Array (PBA) for device <u>dev</u>.  The returned value can be used as the
       resource ID with <u><a href="../man9/bus_alloc_resource.9.html">bus_alloc_resource</a></u>(9) and <u><a href="../man9/bus_release_resource.9.html">bus_release_resource</a></u>(9) to allocate the BAR.   If  the  device
       does not support MSI-X, then <b>pci_msix_pba_bar</b>() returns -1.

       The  <b>pci_msix_table_bar</b>()  function  returns  the offset in configuration space of the BAR containing the
       MSI-X vector  table  for  device  <u>dev</u>.   The  returned  value  can  be  used  as  the  resource  ID  with
       <u><a href="../man9/bus_alloc_resource.9.html">bus_alloc_resource</a></u>(9)  and  <u><a href="../man9/bus_release_resource.9.html">bus_release_resource</a></u>(9)  to allocate the BAR.  If the device does not support
       MSI-X, then <b>pci_msix_table_bar</b>() returns -1.

       The <b>pci_alloc_msix</b>() function attempts to allocate  <u>*count</u>  MSI-X  messages  for  the  device  <u>dev</u>.   The
       <b>pci_alloc_msix</b>()  function  may  allocate  fewer  messages  than  requested for various reasons including
       requests for more messages than the device <u>dev</u> supports, or if the system has  a  shortage  of  available
       MSI-X  messages.   On  success,  <u>*count</u>  is  set to the number of messages allocated and <b>pci_alloc_msix</b>()
       returns zero.  For MSI-X messages, the resource ID for each SYS_RES_IRQ resource identifies the index  in
       the  MSI-X table of the corresponding message.  A resource ID of one maps to the first index of the MSI-X
       table; a resource ID two identifies the second index in the table, etc.   The  <b>pci_alloc_msix</b>()  function
       assigns the <u>*count</u> messages allocated to the first <u>*count</u> table indices.  If <b>pci_alloc_msix</b>() is not able
       to  allocate  any  messages, it returns an error.  Unlike MSI, MSI-X does not require message counts that
       are powers of two.

       The BARs containing the MSI-X vector table and PBA must be  allocated  via  <u><a href="../man9/bus_alloc_resource.9.html">bus_alloc_resource</a></u>(9)  before
       calling  <b>pci_alloc_msix</b>()  and must not be released until after calling <b>pci_release_msi</b>().  Note that the
       vector table and PBA may be stored in the same BAR or in different BARs.

       The <b>pci_pending_msix</b>() function examines the <u>dev</u> device's PBA to determine the pending status of the MSI-
       X message at table index <u>index</u>.  If the indicated message is pending, this function  returns  a  non-zero
       value;  otherwise,  it  returns zero.  Passing an invalid <u>index</u> to this function will result in undefined
       behavior.

       As mentioned in the description of <b>pci_alloc_msix</b>(), MSI-X messages are initially assigned to the first N
       table entries.  A driver may use a different distribution of available messages to table entries via  the
       <b>pci_remap_msix</b>()  function.   Note  that  this  function  must  be  called  after  a  successful  call to
       <b>pci_alloc_msix</b>() but before any  of  the  SYS_RES_IRQ  resources  are  allocated.   The  <b>pci_remap_msix</b>()
       function returns zero on success, or an error on failure.

       The  <u>vectors</u>  array  should contain <u>count</u> message vectors.  The array maps directly to the MSI-X table in
       that the first entry in the array specifies the message used for the first entry in the MSI-X table,  the
       second  entry  in the array corresponds to the second entry in the MSI-X table, etc.  The vector value in
       each array index can either be zero to indicate that no message should be assigned to  the  corresponding
       MSI-X  table  entry, or it can be a number from one to N (where N is the count returned from the previous
       call to <b>pci_alloc_msix</b>()) to indicate  which  of  the  allocated  messages  should  be  assigned  to  the
       corresponding MSI-X table entry.

       If  <b>pci_remap_msix</b>()  succeeds,  each  MSI-X  table  entry with a non-zero vector will have an associated
       SYS_RES_IRQ  resource  whose  resource  ID  corresponds  to  the  table  index  as  described  above  for
       <b>pci_alloc_msix</b>().  MSI-X table entries that with a vector of zero will not have an associated SYS_RES_IRQ
       resource.   Additionally,  if  any of the original messages allocated by <b>pci_alloc_msix</b>() are not used in
       the new distribution of messages in the MSI-X table, they will be released automatically.  Note that if a
       driver wishes to use fewer messages than were allocated  by  <b>pci_alloc_msix</b>(),  the  driver  must  use  a
       single,  contiguous  range  of messages beginning with one in the new distribution.  The <b>pci_remap_msix</b>()
       function will fail if this condition is not met.

   <b>Device</b> <b>Events</b>
       The <u>pci_add_device</u> event handler is invoked every time a new PCI device is added  to  the  system.   This
       includes the creation of Virtual Functions via SR-IOV.

       The <u>pci_delete_device</u> event handler is invoked every time a PCI device is removed from the system.

       Both event handlers pass the <u>device_t</u> object of the relevant PCI device as <u>dev</u> to each callback function.
       Both event handlers are invoked while <u>dev</u> is unattached but with valid instance variables.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/pci.4.html">pci</a></u>(4),   <u><a href="../man8/pciconf.8.html">pciconf</a></u>(8),   <u><a href="../man9/bus_alloc_resource.9.html">bus_alloc_resource</a></u>(9),  <u><a href="../man9/bus_dma.9.html">bus_dma</a></u>(9),  <u><a href="../man9/bus_release_resource.9.html">bus_release_resource</a></u>(9),  <u><a href="../man9/bus_setup_intr.9.html">bus_setup_intr</a></u>(9),
       <u><a href="../man9/bus_teardown_intr.9.html">bus_teardown_intr</a></u>(9), <u><a href="../man9/devclass.9.html">devclass</a></u>(9), <u><a href="../man9/device.9.html">device</a></u>(9), <u><a href="../man9/driver.9.html">driver</a></u>(9), <u><a href="../man9/eventhandler.9.html">eventhandler</a></u>(9), <u><a href="../man9/rman.9.html">rman</a></u>(9)

       “NewBus”,  <u>FreeBSD</u>  <u>Developers'</u>  <u>Handbook</u>,  https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/developers-
       handbook/.

       Shanley and Anderson, <u>PCI</u> <u>System</u> <u>Architecture</u>, <u>Addison-Wesley</u>, 2nd Edition, ISBN 0-201-30974-2.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Bruce M Simpson &lt;<u><a href="mailto:bms@FreeBSD.org">bms@FreeBSD.org</a></u>&gt; and John Baldwin &lt;<u><a href="mailto:jhb@FreeBSD.org">jhb@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The  kernel  PCI code has a number of references to “slot numbers”.  These do not refer to the geographic
       location of PCI devices, but to the device number assigned by the combination of the PCI IDSEL  mechanism
       and the platform firmware.  This should be taken note of when working with the kernel PCI code.

       The  PCI  bus  driver  should allocate the MSI-X vector table and PBA internally as necessary rather than
       requiring the caller to do so.

Debian                                          January 15, 2017                                          <u><a href="../man9/PCI.9.html">PCI</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>