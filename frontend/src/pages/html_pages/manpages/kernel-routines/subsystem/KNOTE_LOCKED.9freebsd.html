<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kqueue_add_filteropts, kqueue_del_filteropts, kqfd_register, knote_fdclose, knlist_init, knlist_init_mtx,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       kqueue_add_filteropts, kqueue_del_filteropts, kqfd_register, knote_fdclose, knlist_init, knlist_init_mtx,
       knlist_init_rw_reader,  knlist_add,  knlist_remove,  knlist_remove_inevent,  knlist_empty,  knlist_clear,
       knlist_delete, knlist_destroy, KNOTE_LOCKED, KNOTE_UNLOCKED â€” event delivery subsystem

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/event.h&gt;</b>

       <u>int</u>
       <b>kqueue_add_filteropts</b>(<u>int</u> <u>filt</u>, <u>struct</u> <u>filterops</u> <u>*filtops</u>);

       <u>int</u>
       <b>kqueue_del_filteropts</b>(<u>int</u> <u>filt</u>);

       <u>int</u>
       <b>kqfd_register</b>(<u>int</u> <u>fd</u>, <u>struct</u> <u>kevent</u> <u>*kev</u>, <u>struct</u> <u>thread</u> <u>*td</u>, <u>int</u> <u>waitok</u>);

       <u>void</u>
       <b>knote_fdclose</b>(<u>struct</u> <u>thread</u> <u>*td</u>, <u>int</u> <u>fd</u>);

       <u>void</u>
       <b>knlist_init</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>,    <u>void</u> <u>*lock</u>,    <u>void</u> (<u>*kl_lock</u>)(<u>void</u> <u>*</u>),     <u>void</u> (<u>*kl_unlock</u>)(<u>void</u> <u>*</u>),
           <u>int</u> (<u>*kl_locked</u>)(<u>void</u> <u>*</u>));

       <u>void</u>
       <b>knlist_init_mtx</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>struct</u> <u>mtx</u> <u>*lock</u>);

       <u>void</u>
       <b>knlist_init_rw_reader</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>struct</u> <u>rwlock</u> <u>*lock</u>);

       <u>void</u>
       <b>knlist_add</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>struct</u> <u>knote</u> <u>*kn</u>, <u>int</u> <u>islocked</u>);

       <u>void</u>
       <b>knlist_remove</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>struct</u> <u>knote</u> <u>*kn</u>, <u>int</u> <u>islocked</u>);

       <u>void</u>
       <b>knlist_remove_inevent</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>struct</u> <u>knote</u> <u>*kn</u>);

       <u>int</u>
       <b>knlist_empty</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>);

       <u>void</u>
       <b>knlist_clear</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>int</u> <u>islocked</u>);

       <u>void</u>
       <b>knlist_delete</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>struct</u> <u>thread</u> <u>*td</u>, <u>int</u> <u>islocked</u>);

       <u>void</u>
       <b>knlist_destroy</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>);

       <u>void</u>
       <b>KNOTE_LOCKED</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>long</u> <u>hint</u>);

       <u>void</u>
       <b>KNOTE_UNLOCKED</b>(<u>struct</u> <u>knlist</u> <u>*knl</u>, <u>long</u> <u>hint</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The functions <b>kqueue_add_filteropts</b>() and <b>kqueue_del_filteropts</b>() allow for the addition and removal of a
       filter   type.    The   filter   is   statically   defined   by   the   EVFILT_*  macros.   The  function
       <b>kqueue_add_filteropts</b>() will make <u>filt</u> available.  The <u>struct</u> <u>filterops</u> has the following members:

       <u>f_isfd</u>    If <u>f_isfd</u> is set, <u>ident</u> in <u>struct</u> <u>kevent</u> is taken to be a file descriptor.  In this  case,  the
                 <u>knote</u>  passed  into  <u>f_attach</u>  will have the <u>kn_fp</u> member initialized to the <u>struct</u> <u>file</u> <u>*</u> that
                 represents the file descriptor.

       <u>f_attach</u>  The <u>f_attach</u> function will be called when attaching a <u>knote</u> to the object.  The  method  should
                 call  <b>knlist_add</b>()  to  add the <u>knote</u> to the list that was initialized with <b>knlist_init</b>().  The
                 call to <b>knlist_add</b>() is only necessary if the object can have multiple <u>knotes</u>  associated  with
                 it.   If  there  is  no  <u>knlist</u> to call <b>knlist_add</b>() with, the function <u>f_attach</u> must clear the
                 KN_DETACHED bit of <u>kn_status</u> in the  <u>knote</u>.   The  function  shall  return  0  on  success,  or
                 appropriate  error  for  the  failure,  such as when the object is being destroyed, or does not
                 exist.  During <u>f_attach</u>, it is valid to change the <u>kn_fops</u>  pointer  to  a  different  pointer.
                 This will change the <u>f_event</u> and <u>f_detach</u> functions called when processing the <u>knote</u>.

       <u>f_detach</u>  The  <u>f_detach</u>  function  will  be  called to detach the <u>knote</u> if the <u>knote</u> has not already been
                 detached by a call to <b>knlist_remove</b>(), <b>knlist_remove_inevent</b>() or  <b>knlist_delete</b>().   The  list
                 <u>lock</u> will not be held when this function is called.

       <u>f_event</u>   The <u>f_event</u> function will be called to update the status of the <u>knote</u>.  If the function returns
                 0,  it  will  be assumed that the object is not ready (or no longer ready) to be woken up.  The
                 <u>hint</u> argument will be 0 when scanning <u>knotes</u> to see which are triggered.  Otherwise,  the  <u>hint</u>
                 argument  will be the value passed to either KNOTE_LOCKED or KNOTE_UNLOCKED.  The <u>kn_data</u> value
                 should be updated as necessary to reflect the current value, such as number of bytes  available
                 for  reading,  or  buffer  space  available  for  writing.   If  the  note needs to be removed,
                 <b>knlist_remove_inevent</b>() must be called.  The function <b>knlist_remove_inevent</b>() will  remove  the
                 note from the list, the <u>f_detach</u> function will not be called and the <u>knote</u> will not be returned
                 as an event.

                 Locks  <u>must</u>  <u>not</u> be acquired in <u>f_event</u>.  If a lock is required in <u>f_event</u>, it must be obtained
                 in the <u>kl_lock</u> function of the <u>knlist</u> that the <u>knote</u> was added to.

       The function <b>kqfd_register</b>() will register the <u>kevent</u> on the kqueue file descriptor <u>fd</u>.  If it is safe to
       sleep, <u>waitok</u> should be set.

       The function <b>knote_fdclose</b>() is used to delete all <u>knotes</u> associated with <u>fd</u>.  Once returned, there  will
       no  longer  be  any  <u>knotes</u>  associated  with  the  <u>fd</u>.  The <u>knotes</u> removed will never be returned from a
       <u><a href="../man2/kevent.2.html">kevent</a></u>(2) call,  so  if  userland  uses  the  <u>knote</u>  to  track  resources,  they  will  be  leaked.   The
       <b>FILEDESC_LOCK</b>()  lock  must  be  held over the call to <b>knote_fdclose</b>() so that file descriptors cannot be
       added or removed.

       The <b>knlist_*</b>() family of functions are for managing <u>knotes</u> associated with an object.  A  <u>knlist</u>  is  not
       required,  but  is  commonly  used.   If  used, the <u>knlist</u> must be initialized with either <b>knlist_init</b>(),
       <b>knlist_init_mtx</b>() or <b>knlist_init_rw_reader</b>().  The <u>knlist</u> structure  may  be  embedded  into  the  object
       structure.  The <u>lock</u> will be held over <u>f_event</u> calls.

       For  the  <b>knlist_init</b>()  function,  if  <u>lock</u> is NULL, a shared global lock will be used and the remaining
       arguments must be NULL.  The  function  pointers  <u>kl_lock</u>,  <u>kl_unlock</u>  and  <u>kl_locked</u>  will  be  used  to
       manipulate  the argument <u>lock</u>.  If any of the function pointers are NULL, a function operating on MTX_DEF
       style <u><a href="../man9/mutex.9.html">mutex</a></u>(9) locks will be used instead.

       The function <b>knlist_init_mtx</b>() may be used to initialize a <u>knlist</u> when <u>lock</u> is a MTX_DEF  style  <u><a href="../man9/mutex.9.html">mutex</a></u>(9)
       lock.

       The  function  <b>knlist_init_rw_reader</b>()  may  be used to initialize a <u>knlist</u> when <u>lock</u> is a <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9) read
       lock.  Lock is acquired via <b>rw_rlock</b>() function.

       The function <b>knlist_empty</b>() returns true when there are no <u>knotes</u> on the  list.   The  function  requires
       that the <u>lock</u> be held when called.

       The function <b>knlist_clear</b>() removes all <u>knotes</u> from the list.  The <u>islocked</u> argument declares if the <u>lock</u>
       has  been  acquired.   All <u>knotes</u> will have EV_ONESHOT set so that the <u>knote</u> will be returned and removed
       during the next scan.  The <u>f_detach</u> function will be called when the <u>knote</u> is  deleted  during  the  next
       scan.   This  function  must  not  be  used when <u>f_isfd</u> is set in <u>struct</u> <u>filterops</u>, as the <u>td</u> argument of
       <b>fdrop</b>() will be NULL.

       The function <b>knlist_delete</b>() removes and deletes all <u>knotes</u> on the list.  The function <u>f_detach</u> will  not
       be  called, and the <u>knote</u> will not be returned on the next scan.  Using this function could leak userland
       resources if a process uses the <u>knote</u> to track resources.

       Both the <b>knlist_clear</b>() and <b>knlist_delete</b>() functions may sleep.  They also may release the <u>lock</u> to  wait
       for other <u>knotes</u> to drain.

       The  <b>knlist_destroy</b>()  function is used to destroy a <u>knlist</u>.  There must be no <u>knotes</u> associated with the
       <u>knlist</u> (<b>knlist_empty</b>() returns true) and no more <u>knotes</u> may be attached to the object.  A <u>knlist</u>  may  be
       emptied by calling <b>knlist_clear</b>() or <b>knlist_delete</b>().

       The macros <b>KNOTE_LOCKED</b>() and <b>KNOTE_UNLOCKED</b>() are used to notify <u>knotes</u> about events associated with the
       object.   It  will  iterate  over all <u>knotes</u> on the list calling the <u>f_event</u> function associated with the
       <u>knote</u>.  The macro <b>KNOTE_LOCKED</b>() must be used if the lock associated with the <u>knl</u> is held.  The  function
       <b>KNOTE_UNLOCKED</b>() will acquire the lock before iterating over the list of <u>knotes</u>.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The  function <b>kqueue_add_filteropts</b>() will return zero on success, EINVAL in the case of an invalid <u>filt</u>,
       or EEXIST if the filter has already been installed.

       The function <b>kqueue_del_filteropts</b>() will return zero on success, EINVAL in the case of an invalid  <u>filt</u>,
       or EBUSY if the filter is still in use.

       The  function  <b>kqfd_register</b>() will return zero on success, EBADF if the file descriptor is not a kqueue,
       or any of the possible values returned by <u><a href="../man2/kevent.2.html">kevent</a></u>(2).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/kevent.2.html">kevent</a></u>(2), <u><a href="../man2/kqueue.2.html">kqueue</a></u>(2)

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by John-Mark Gurney &lt;<u><a href="mailto:jmg@FreeBSD.org">jmg@FreeBSD.org</a></u>&gt;.

Debian                                           March 26, 2012                                        <u><a href="../man9/KQUEUE.9.html">KQUEUE</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>