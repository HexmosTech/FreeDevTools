<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bitset(9)  —  BITSET_DEFINE,  BITSET_T_INITIALIZER,  BITSET_FSET,  BIT_CLR, BIT_COPY, BIT_ISSET, BIT_SET,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <a href="../man9/bitset.9.html">bitset</a>(9)  —  BITSET_DEFINE,  BITSET_T_INITIALIZER,  BITSET_FSET,  BIT_CLR, BIT_COPY, BIT_ISSET, BIT_SET,
       BIT_ZERO,  BIT_FILL,  BIT_SETOF,  BIT_EMPTY,  BIT_ISFULLSET,  BIT_FFS,  BIT_FLS,  BIT_COUNT,  BIT_SUBSET,
       BIT_OVERLAP,  BIT_CMP,  BIT_OR,  BIT_OR2,  BIT_AND,  BIT_AND2,  BIT_NAND,  BIT_NAND2,  BIT_XOR, BIT_XOR2,
       BIT_CLR_ATOMIC, BIT_SET_ATOMIC, BIT_SET_ATOMIC_ACQ, BIT_AND_ATOMIC, BIT_OR_ATOMIC,  BIT_COPY_STORE_REL  —
       bitset manipulation macros

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/_bitset.h&gt;</b>
       <b>#include</b> <b>&lt;sys/bitset.h&gt;</b>

       <b>BITSET_DEFINE</b>(<u>STRUCTNAME</u>, <u>const</u> <u>SETSIZE</u>);

       <b>BITSET_T_INITIALIZER</b>(<u>ARRAY_CONTENTS</u>);

       <b>BITSET_FSET</b>(<u>N_WORDS</u>);

       <b>BIT_CLR</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_COPY</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*from</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*to</u>);

       <u>bool</u>
       <b>BIT_ISSET</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_SET</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_ZERO</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_FILL</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_SETOF</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <u>bool</u>
       <b>BIT_EMPTY</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <u>bool</u>
       <b>BIT_ISFULLSET</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <u>int</u>
       <b>BIT_FFS</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <u>int</u>
       <b>BIT_FLS</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <u>int</u>
       <b>BIT_COUNT</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <u>bool</u>
       <b>BIT_SUBSET</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*haystack</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*needle</u>);

       <u>bool</u>
       <b>BIT_OVERLAP</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset1</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset2</u>);

       <u>bool</u>
       <b>BIT_CMP</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset1</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset2</u>);

       <b>BIT_OR</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src</u>);

       <b>BIT_OR2</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src1</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src2</u>);

       <b>BIT_AND</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src</u>);

       <b>BIT_AND2</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src1</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src2</u>);

       <b>BIT_NAND</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src</u>);

       <b>BIT_NAND2</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src1</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src2</u>);

       <b>BIT_XOR</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src</u>);

       <b>BIT_XOR2</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src1</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src2</u>);

       <b>BIT_CLR_ATOMIC</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_SET_ATOMIC</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_SET_ATOMIC_ACQ</b>(<u>const</u> <u>SETSIZE</u>, <u>size_t</u> <u>bit</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*bitset</u>);

       <b>BIT_AND_ATOMIC</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src</u>);

       <b>BIT_OR_ATOMIC</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*dst</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*src</u>);

       <b>BIT_COPY_STORE_REL</b>(<u>const</u> <u>SETSIZE</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*from</u>, <u>struct</u> <u>STRUCTNAME</u> <u>*to</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> family of macros provide a flexible and efficient bitset implementation if the maximum size
       of  the set is known at compilation.  Throughout this manual page, the name <u>SETSIZE</u> refers to the size of
       the bitset in bits.  Individual bits in bitsets are referenced with indices zero  through  <u>SETSIZE</u>  <u>-</u>  <u>1</u>.
       One example use of &lt;<u>sys/bitset.h</u>&gt; is &lt;<u>sys/cpuset.h</u>&gt;.

       The <b>BITSET_DEFINE</b>() macro defines a bitset struct <u>STRUCTNAME</u> with room to represent <u>SETSIZE</u> bits.

       The  <b>BITSET_T_INITIALIZER</b>()  macro  allows  one to initialize a bitset struct with a compile time literal
       value.

       The <b>BITSET_FSET</b>() macro generates a compile time literal, usable by <b>BITSET_T_INITIALIZER</b>(),  representing
       a  full  bitset  (all bits set).  For examples of <b>BITSET_T_INITIALIZER</b>() and <b>BITSET_FSET</b>() usage, see the
       “BITSET_T_INITIALIZER EXAMPLE” section.  The <u>N_WORDS</u> parameter to <b>BITSET_FSET</b>() should be:

             __bitset_words(SETSIZE)

       The <b>BIT_CLR</b>() macro clears bit <u>bit</u> in the bitset pointed to by <u>bitset</u>.   The  <b>BIT_CLR_ATOMIC</b>()  macro  is
       identical, but the bit is cleared atomically.

       The  <b>BIT_COPY</b>()  macro  copies the contents of the bitset <u>from</u> to the bitset <u>to</u>.  <b>BIT_COPY_STORE_REL</b>() is
       similar, but copies component machine words from <u>from</u> and writes  them  to  <u>to</u>  with  atomic  store  with
       release  semantics.  (That is, if <u>to</u> is composed of multiple machine words, <b>BIT_COPY_STORE_REL</b>() performs
       multiple individually atomic operations.)

       The <b>BIT_SET</b>() macro sets bit <u>bit</u> in the bitset pointed to  by  <u>bitset</u>.   The  <b>BIT_SET_ATOMIC</b>()  macro  is
       identical,  but  the  bit  is  set  atomically.  The <b>BIT_SET_ATOMIC_ACQ</b>() macro sets the bit with acquire
       semantics.

       The <b>BIT_ZERO</b>() macro clears all bits in <u>bitset</u>.

       The <b>BIT_FILL</b>() macro sets all bits in <u>bitset</u>.

       The <b>BIT_SETOF</b>() macro clears all bits in <u>bitset</u> before setting only bit <u>bit</u>.

       The <b>BIT_EMPTY</b>() macro returns true if <u>bitset</u> is empty.

       The <b>BIT_ISFULLSET</b>() macro returns true if <u>bitset</u> is full (all bits set).

       The <b>BIT_FFS</b>() macro returns the 1-index of the first (lowest) set bit in <u>bitset</u>, or  zero  if  <u>bitset</u>  is
       empty.   Like  with <u><a href="../man3/ffs.3.html">ffs</a></u>(3), to use the non-zero result of <b>BIT_FFS</b>() as a <u>bit</u> index parameter to any other
       <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> macro, you must subtract one from the result.

       The <b>BIT_FLS</b>() macro returns the 1-index of the last (highest) set bit in <u>bitset</u>, or  zero  if  <u>bitset</u>  is
       empty.   Like  with <u><a href="../man3/fls.3.html">fls</a></u>(3), to use the non-zero result of <b>BIT_FLS</b>() as a <u>bit</u> index parameter to any other
       <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> macro, you must subtract one from the result.

       The <b>BIT_COUNT</b>() macro returns the total number of set bits in <u>bitset</u>.

       The <b>BIT_SUBSET</b>() macro returns true if <u>needle</u> is a subset of <u>haystack</u>.

       The <b>BIT_OVERLAP</b>() macro returns true if <u>bitset1</u> and <u>bitset2</u> have any common bits.  (That is,  if  <u>bitset1</u>
       AND <u>bitset2</u> is not the empty set.)

       The <b>BIT_CMP</b>() macro returns true if <u>bitset1</u> is NOT equal to <u>bitset2</u>.

       The  <b>BIT_OR</b>()  macro sets bits present in <u>src</u> in <u>dst</u>.  (It is the <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> equivalent of the scalar: <u>dst</u>
       |= <u>src</u>.)  <b>BIT_OR_ATOMIC</b>() is similar, but sets bits in the component machine  words  in  <u>dst</u>  atomically.
       (That  is,  if  <u>dst</u> is composed of multiple machine words, <b>BIT_OR_ATOMIC</b>() performs multiple individually
       atomic operations.)

       The <b>BIT_OR2</b>() macro computes <u>src1</u> bitwise or <u>src2</u> and assigns the result to <u>dst</u>.  (It  is  the  <b><a href="../man9/bitset.9.html">bitset</a>(9)</b>
       equivalent of the scalar: <u>dst</u> = <u>src1</u> | <u>src2</u>.)

       The <b>BIT_AND</b>() macro clears bits absent from <u>src</u> from <u>dst</u>.  (It is the <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> equivalent of the scalar:
       <u>dst</u> &amp;= <u>src</u>.)  <b>BIT_AND_ATOMIC</b>() is similar, with the same atomic semantics as <b>BIT_OR_ATOMIC</b>().

       The  <b>BIT_AND2</b>() macro computes <u>src1</u> bitwise and <u>src2</u> and assigns the result to <u>dst</u>.  (It is the <b><a href="../man9/bitset.9.html">bitset</a>(9)</b>
       equivalent of the scalar: <u>dst</u> = <u>src1</u> &amp; <u>src2</u>.)

       The <b>BIT_NAND</b>() macro clears bits set in <u>src</u> from <u>dst</u>.  (It is the <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> equivalent of the scalar: <u>dst</u>
       &amp;= <u>~</u> <u>src</u>.)

       The <b>BIT_NAND2</b>() macro computes <u>src1</u> bitwise and not <u>src2</u> and assigns the  result  to  <u>dst</u>.   (It  is  the
       <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> equivalent of the scalar: <u>dst</u> = <u>src1</u> &amp; ~ <u>src2</u>.)

       The  <b>BIT_XOR</b>()  macro toggles bits set in <u>src</u> in <u>dst</u>.  (It is the <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> equivalent of the scalar: <u>dst</u>
       ^= <u>src</u>.)

       The <b>BIT_XOR2</b>() macro computes <u>src1</u> bitwise exclusive or <u>src2</u> and assigns the result to <u>dst</u>.  (It  is  the
       <b><a href="../man9/bitset.9.html">bitset</a>(9)</b> equivalent of the scalar: <u>dst</u> = <u>src1</u> ^ <u>src2</u>.)

</pre><h4><b>BITSET_T_INITIALIZER</b> <b>EXAMPLE</b></h4><pre>
       BITSET_DEFINE(_myset, MYSETSIZE);

       struct _myset myset;

       /* Initialize myset to filled (all bits set) */
       myset = BITSET_T_INITIALIZER(BITSET_FSET(__bitset_words(MYSETSIZE)));

       /* Initialize myset to only the lowest bit set */
       myset = <a href="../man0x1/BITSET_T_INITIALIZER.0x1.html">BITSET_T_INITIALIZER</a>(0x1);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/bitstring.3.html">bitstring</a></u>(3), <u><a href="../man9/cpuset.9.html">cpuset</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b><a href="../man9/bitset.9.html">bitset</a>(9)</b>  macros  first  appeared in FreeBSD 10.0 in January 2014.  They were MFCed to FreeBSD 9.3,
       released in July 2014.

       This manual page first appeared in FreeBSD 11.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  <b><a href="../man9/bitset.9.html">bitset</a>(9)</b>  macros  were  generalized  and  pulled  out  of  &lt;<u>sys/cpuset.h</u>&gt;  as  &lt;<u>sys/_bitset.h</u>&gt;  and
       &lt;<u>sys/bitset.h</u>&gt;  by  Attilio  Rao  &lt;<u><a href="mailto:attilio@FreeBSD.org">attilio@FreeBSD.org</a></u>&gt;.   This  manual  page was written by Conrad Meyer
       &lt;<u><a href="mailto:cem@FreeBSD.org">cem@FreeBSD.org</a></u>&gt;.

</pre><h4><b>CAVEATS</b></h4><pre>
       The <u>SETSIZE</u> argument to all of these macros must match the value given to <b>BITSET_DEFINE</b>().

       Unlike every other reference to individual set members, which are zero-indexed, <b>BIT_FFS</b>()  and  <b>BIT_FLS</b>()
       return a one-indexed result (or zero if the set is empty).

Debian                                            July 7, 2017                                         <u><a href="../man9/BITSET.9.html">BITSET</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>