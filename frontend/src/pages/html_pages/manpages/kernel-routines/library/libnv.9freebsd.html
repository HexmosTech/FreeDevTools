<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nvlist_create, nvlist_destroy, nvlist_error, nvlist_set_error, nvlist_empty, nvlist_flags, nvlist_exists,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nvlist_create, nvlist_destroy, nvlist_error, nvlist_set_error, nvlist_empty, nvlist_flags, nvlist_exists,
       nvlist_free,   nvlist_clone,   nvlist_dump,   nvlist_fdump,   nvlist_size,   nvlist_pack,  nvlist_unpack,
       nvlist_send, nvlist_recv, nvlist_xfer, nvlist_in_array, nvlist_next, nvlist_add, nvlist_move, nvlist_get,
       nvlist_take, nvlist_append — library for name/value pairs

</pre><h4><b>LIBRARY</b></h4><pre>
       library “libnv”

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/nv.h&gt;</b>

       <u>nvlist_t</u> <u>*</u>
       <b>nvlist_create</b>(<u>int</u> <u>flags</u>);

       <u>void</u>
       <b>nvlist_destroy</b>(<u>nvlist_t</u> <u>*nvl</u>);

       <u>int</u>
       <b>nvlist_error</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>void</u>
       <b>nvlist_set_error</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>int</u> <u>error</u>);

       <u>bool</u>
       <b>nvlist_empty</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>int</u>
       <b>nvlist_flags</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>bool</u>
       <b>nvlist_in_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>nvlist_t</u> <u>*</u>
       <b>nvlist_clone</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>void</u>
       <b>nvlist_dump</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>int</u> <u>fd</u>);

       <u>void</u>
       <b>nvlist_fdump</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>FILE</u> <u>*fp</u>);

       <u>size_t</u>
       <b>nvlist_size</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>void</u> <u>*</u>
       <b>nvlist_pack</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>size_t</u> <u>*sizep</u>);

       <u>nvlist_t</u> <u>*</u>
       <b>nvlist_unpack</b>(<u>const</u> <u>void</u> <u>*buf</u>, <u>size_t</u> <u>size</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>nvlist_send</b>(<u>int</u> <u>sock</u>, <u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>nvlist_t</u> <u>*</u>
       <b>nvlist_recv</b>(<u>int</u> <u>sock</u>, <u>int</u> <u>flags</u>);

       <u>nvlist_t</u> <u>*</u>
       <b>nvlist_xfer</b>(<u>int</u> <u>sock</u>, <u>nvlist_t</u> <u>*nvl</u>, <u>int</u> <u>flags</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>nvlist_next</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>int</u> <u>*typep</u>, <u>void</u> <u>**cookiep</u>);

       <u>bool</u>
       <b>nvlist_exists</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_type</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>type</u>);

       <u>bool</u>
       <b>nvlist_exists_null</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_bool</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_number</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_string</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_nvlist</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_descriptor</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_binary</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_bool_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_number_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_string_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_nvlist_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>bool</u>
       <b>nvlist_exists_descriptor_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_add_null</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_add_bool</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>bool</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_add_number</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>uint64_t</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_add_string</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*value</u>);

       <u>void</u>
       <b>nvlist_add_stringf</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*valuefmt</u>, <u>...</u>);

       <u>void</u>
       <b>nvlist_add_stringv</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*valuefmt</u>, <u>va_list</u> <u>valueap</u>);

       <u>void</u>
       <b>nvlist_add_nvlist</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>nvlist_t</u> <u>*value</u>);

       <u>void</u>
       <b>nvlist_add_descriptor</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_add_binary</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>void</u> <u>*value</u>, <u>size_t</u> <u>size</u>);

       <u>void</u>
       <b>nvlist_add_bool_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>bool</u> <u>*value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_add_number_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>uint64_t</u> <u>*value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_add_string_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*</u> <u>const</u> <u>*</u> <u>value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_add_nvlist_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>nvlist_t</u> <u>*</u> <u>const</u> <u>*</u> <u>value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_add_descriptor_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>int</u> <u>*value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_move_string</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>char</u> <u>*value</u>);

       <u>void</u>
       <b>nvlist_move_nvlist</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>nvlist_t</u> <u>*value</u>);

       <u>void</u>
       <b>nvlist_move_descriptor</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_move_binary</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>void</u> <u>*value</u>, <u>size_t</u> <u>size</u>);

       <u>void</u>
       <b>nvlist_move_bool_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>bool</u> <u>*value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_move_number_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>uint64_t</u> <u>*value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_move_string_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>char</u> <u>**value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_move_nvlist_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>nvlist_t</u> <u>**value</u>, <u>size_t</u> <u>nitems</u>);

       <u>void</u>
       <b>nvlist_move_descriptor_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>*value</u>, <u>size_t</u> <u>nitems</u>);

       <u>bool</u>
       <b>nvlist_get_bool</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>uint64_t</u>
       <b>nvlist_get_number</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>nvlist_get_string</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>const</u> <u>nvlist_t</u> <u>*</u>
       <b>nvlist_get_nvlist</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>int</u>
       <b>nvlist_get_descriptor</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>const</u> <u>void</u> <u>*</u>
       <b>nvlist_get_binary</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*sizep</u>);

       <u>const</u> <u>bool</u> <u>*</u>
       <b>nvlist_get_bool_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>const</u> <u>uint64_t</u> <u>*</u>
       <b>nvlist_get_number_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>const</u> <u>char</u> <u>*</u> <u>const</u> <u>*</u>
       <b>nvlist_get_string_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>const</u> <u>nvlist_t</u> <u>*</u> <u>const</u> <u>*</u>
       <b>nvlist_get_nvlist_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>const</u> <u>int</u> <u>*</u>
       <b>nvlist_get_descriptor_array</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>const</u> <u>nvlist_t</u> <u>*</u>
       <b>nvlist_get_parent</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>void</u> <u>**cookiep</u>);

       <u>const</u> <u>nvlist_t</u> <u>*</u>
       <b>nvlist_get_array_next</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>);

       <u>const</u> <u>nvlist_t</u> <u>*</u>
       <b>nvlist_get_pararr</b>(<u>const</u> <u>nvlist_t</u> <u>*nvl</u>, <u>void</u> <u>**cookiep</u>);

       <u>bool</u>
       <b>nvlist_take_bool</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>uint64_t</u>
       <b>nvlist_take_number</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>char</u> <u>*</u>
       <b>nvlist_take_string</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>nvlist_t</u> <u>*</u>
       <b>nvlist_take_nvlist</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>int</u>
       <b>nvlist_take_descriptor</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u> <u>*</u>
       <b>nvlist_take_binary</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*sizep</u>);

       <u>bool</u> <u>*</u>
       <b>nvlist_take_bool_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>uint64_t</u> <u>**</u>
       <b>nvlist_take_number_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>char</u> <u>**</u>
       <b>nvlist_take_string_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>nvlist_t</u> <u>**</u>
       <b>nvlist_take_nvlist_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>int</u> <u>*</u>
       <b>nvlist_take_descriptor_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>size_t</u> <u>*nitems</u>);

       <u>void</u>
       <b>nvlist_append_bool_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>bool</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_append_number_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>uint64_t</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_append_string_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*</u> <u>const</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_append_nvlist_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>nvlist_t</u> <u>*</u> <u>const</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_append_descriptor_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>value</u>);

       <u>void</u>
       <b>nvlist_free</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_type</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>type</u>);

       <u>void</u>
       <b>nvlist_free_null</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_bool</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_number</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_string</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_nvlist</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_descriptor</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_binary</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_bool_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_number_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_string_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_nvlist_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>void</u>
       <b>nvlist_free_descriptor_array</b>(<u>nvlist_t</u> <u>*nvl</u>, <u>const</u> <u>char</u> <u>*name</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>libnv</b> library allows to easily manage name value pairs as well as send and receive them over sockets.
       A group (list) of name value pairs is called an <b>nvlist</b>.  The API supports the following data types:

             <b>null</b> (<b>NV_TYPE_NULL</b>)
             There is no data associated with the name.

             <b>bool</b> (<b>NV_TYPE_BOOL</b>)
             The value can be either true or false.

             <b>number</b> (<b>NV_TYPE_NUMBER</b>)
             The value is a number stored as <u>uint64_t</u>.

             <b>string</b> (<b>NV_TYPE_STRING</b>)
             The value is a C string.

             <b>nvlist</b> (<b>NV_TYPE_NVLIST</b>)
             The value is a nested nvlist.

             <b>descriptor</b> (<b>NV_TYPE_DESCRIPTOR</b>)
             The value is a file descriptor.  Note that file descriptors can be sent only  over  <u><a href="../man4/unix.4.html">unix</a></u>(4)  domain
             sockets.

             <b>binary</b> (<b>NV_TYPE_BINARY</b>)
             The value is a binary buffer.

             <b>bool</b> <b>array</b> (<b>NV_TYPE_BOOL_ARRAY</b>)
             The value is an array of boolean values.

             <b>number</b> <b>array</b> (<b>NV_TYPE_NUMBER_ARRAY</b>)
             The value is an array of numbers, each stored as <u>uint64_t</u>.

             <b>string</b> <b>array</b> (<b>NV_TYPE_STRING_ARRAY</b>)
             The value is an array of C strings.

             <b>nvlist</b> <b>array</b> (<b>NV_TYPE_NVLIST_ARRAY</b>)
             The  value  is  an  array  of nvlists.  When an nvlist is added to an array, it becomes part of the
             primary nvlist.  Traversing  these  arrays  can  be  done  using  the  <b>nvlist_get_array_next</b>()  and
             <b>nvlist_get_pararr</b>() functions.

             <b>descriptor</b> <b>array</b> (<b>NV_TYPE_DESCRIPTOR_ARRAY</b>)
             The value is an array of files descriptors.

       The <b>nvlist_create</b>() function allocates memory and initializes an nvlist.

       The following flag can be provided:

             NV_FLAG_IGNORE_CASE  Perform case-insensitive lookups of provided names.
             NV_FLAG_NO_UNIQUE    Names in the nvlist do not have to be unique.

       The  <b>nvlist_destroy</b>()  function  destroys  the  given  nvlist.   Function  does nothing if NULL nvlist is
       provided.  Function never modifies the <u>errno</u> global variable.

       The <b>nvlist_error</b>() function returns any error value that the nvlist accumulated.  If the given nvlist  is
       NULL the ENOMEM error will be returned.

       The  <b>nvlist_set_error</b>()  function  sets  an  nvlist  to  be  in  the  error  state.   Subsequent calls to
       <b>nvlist_error</b>() will return the given error value.  This function cannot be used to clear the error  state
       from an nvlist.  This function does nothing if the nvlist is already in the error state.

       The  <b>nvlist_empty</b>()  function  returns true if the given nvlist is empty and false otherwise.  The nvlist
       must not be in error state.

       The <b>nvlist_flags</b>() function returns flags used to create the nvlist with the <b>nvlist_create</b>() function.

       The <b>nvlist_in_array</b>() function returns true if <u>nvl</u> is part of an  array  that  is  a  member  of  another
       nvlist.

       The  <b>nvlist_clone</b>()  functions  clones  the given nvlist.  The clone shares no resources with its origin.
       This also means that all file descriptors that are part of the nvlist will be duplicated with the  <u><a href="../man2/dup.2.html">dup</a></u>(2)
       system call before placing them in the clone.

       The <b>nvlist_dump</b>() dumps nvlist content for debugging purposes to the given file descriptor <u>fd</u>.

       The <b>nvlist_fdump</b>() dumps nvlist content for debugging purposes to the given file stream <u>fp</u>.

       The <b>nvlist_size</b>() function returns the size of the given nvlist after converting it to binary buffer with
       the <b>nvlist_pack</b>() function.

       The  <b>nvlist_pack</b>()  function converts the given nvlist to a binary buffer.  The function allocates memory
       for the buffer, which should be freed with the <u><a href="../man3/free.3.html">free</a></u>(3) function.  If the <u>sizep</u> argument is not NULL,  the
       size  of  the  buffer  will  be  stored there.  The function returns NULL in case of an error (allocation
       failure).  If the nvlist contains any file descriptors NULL will be returned.  The nvlist must not be  in
       error state.

       The  <b>nvlist_unpack</b>()  function  converts the given buffer to the nvlist.  The <u>flags</u> argument defines what
       type of the top level nvlist is expected to be.  Flags are set up using the <b>nvlist_create</b>() function.  If
       the nvlist flags do not match the flags passed to <b>nvlist_unpack</b>(),  the  nvlist  will  not  be  returned.
       Every  nested  nvlist list should be checked using <b>nvlist_flags</b>() function.  The function returns NULL in
       case of an error.

       The <b>nvlist_send</b>() function sends the given nvlist over the socket given by the <u>sock</u> argument.  Note  that
       nvlist that contains file descriptors can only be send over <u><a href="../man4/unix.4.html">unix</a></u>(4) domain sockets.

       The  <b>nvlist_recv</b>()  function  receives  nvlist  over  the  socket  given by the <u>sock</u> argument.  The <u>flags</u>
       argument defines what type of the top level nvlist is expected  to  be.   Flags  are  set  up  using  the
       <b>nvlist_create</b>() function.  If the nvlist flags do not match the flags passed to <b>nvlist_recv</b>(), the nvlist
       will not be returned.  Every nested nvlist list should be checked using <b>nvlist_flags</b>() function.

       The <b>nvlist_xfer</b>() function sends the given nvlist over the socket given by the <u>sock</u> argument and receives
       nvlist over the same socket.  The <u>flags</u> argument defines what type of the top level nvlist is expected to
       be.   Flags  are  set  up using the <b>nvlist_create</b>() function.  If the nvlist flags do not match the flags
       passed to <b>nvlist_xfer</b>(), the nvlist will not be returned.  Every nested nvlist  list  should  be  checked
       using <b>nvlist_flags</b>() function.  The given nvlist is always destroyed.

       The  <b>nvlist_next</b>()  function  iterates  over  the  given  nvlist  returning names and types of subsequent
       elements.  The <u>cookiep</u> argument allows the function to figure out which element should be returned  next.
       The  <u>*cookiep</u>  should  be set to NULL for the first call and should not be changed later.  Returning NULL
       means there are no more elements on the nvlist.  The <u>typep</u> argument can be NULL.   Elements  may  not  be
       removed  from  the  nvlist  while  traversing  it.   The  nvlist  must  not be in error state.  Note that
       <b>nvlist_next</b>() will handle <u>cookiep</u> being set to NULL.  In this case first element is returned or  NULL  if
       nvlist is empty.  This behavior simplifies removing the first element from the list.

       The  <b>nvlist_exists</b>()  function  returns true if element of the given name exists (besides of its type) or
       false otherwise.  The nvlist must not be in error state.

       The <b>nvlist_exists_type</b>() function returns true if element of the given name and the given type exists  or
       false otherwise.  The nvlist must not be in error state.

       The    <b>nvlist_exists_null</b>(),    <b>nvlist_exists_bool</b>(),   <b>nvlist_exists_number</b>(),   <b>nvlist_exists_string</b>(),
       <b>nvlist_exists_nvlist</b>(), <b>nvlist_exists_descriptor</b>(),  <b>nvlist_exists_binary</b>(),  <b>nvlist_exists_bool_array</b>(),
       <b>nvlist_exists_number_array</b>(),         <b>nvlist_exists_string_array</b>(),         <b>nvlist_exists_nvlist_array</b>(),
       <b>nvlist_exists_descriptor_array</b>() functions return true if element of the given name and  the  given  type
       determined by the function name exists or false otherwise.  The nvlist must not be in error state.

       The <b>nvlist_add_null</b>(), <b>nvlist_add_bool</b>(), <b>nvlist_add_number</b>(), <b>nvlist_add_string</b>(), <b>nvlist_add_stringf</b>(),
       <b>nvlist_add_stringv</b>(),       <b>nvlist_add_nvlist</b>(),       <b>nvlist_add_descriptor</b>(),      <b>nvlist_add_binary</b>(),
       <b>nvlist_add_bool_array</b>(), <b>nvlist_add_number_array</b>(), <b>nvlist_add_string_array</b>(), <b>nvlist_add_nvlist_array</b>(),
       <b>nvlist_add_descriptor_array</b>() functions add element to the given nvlist.  When adding  string  or  binary
       buffer the functions will allocate memory and copy the data over.  When adding nvlist, the nvlist will be
       cloned  and  clone  will  be  added.  When adding descriptor, the descriptor will be duplicated using the
       <u><a href="../man2/dup.2.html">dup</a></u>(2) system call and the new descriptor will be added.  The array functions will fail if there are  any
       NULL  elements  in  the  array,  or  if  the  array pointer is NULL.  If an error occurs while adding new
       element, internal error is set which can be examined using the <b>nvlist_error</b>() function.

       The   <b>nvlist_move_string</b>(),   <b>nvlist_move_nvlist</b>(),    <b>nvlist_move_descriptor</b>(),    <b>nvlist_move_binary</b>(),
       <b>nvlist_move_bool_array</b>(),             <b>nvlist_move_number_array</b>(),             <b>nvlist_move_string_array</b>(),
       <b>nvlist_move_nvlist_array</b>(), <b>nvlist_move_descriptor_array</b>() functions add new element to the given nvlist,
       but unlike <b>nvlist_add_&lt;type&gt;</b>() functions they will consume the given resource.  In the case  of  strings,
       descriptors,  or  nvlists  every  elements  must  be  unique, or it could cause a double free.  The array
       functions will fail if there are any NULL elements, or if the array pointer is NULL.  If an error  occurs
       while adding new element, the resource is destroyed and internal error is set which can be examined using
       the <b>nvlist_error</b>() function.

       The      <b>nvlist_get_bool</b>(),      <b>nvlist_get_number</b>(),      <b>nvlist_get_string</b>(),      <b>nvlist_get_nvlist</b>(),
       <b>nvlist_get_descriptor</b>(),   <b>nvlist_get_binary</b>(),    <b>nvlist_get_bool_array</b>(),    <b>nvlist_get_number_array</b>(),
       <b>nvlist_get_string_array</b>(),  <b>nvlist_get_nvlist_array</b>(), <b>nvlist_get_descriptor_array</b>() functions return the
       value that corresponds to the given key name.  In the case of strings, nvlists, descriptors,  binary,  or
       arrays, the returned resource should not be modified - they still belong to the nvlist.  If an element of
       the  given  name does not exist, the program will be aborted.  To avoid this, the caller should check for
       the existence of the name before trying to obtain the value, or use the <u><a href="../man3/dnvlist.3.html">dnvlist</a></u>(3) extension,  which  can
       provide a default value in the case of a missing element.  The nvlist must not be in error state.

       The <b>nvlist_get_parent</b>() function returns the parent nvlist of the nested nvlist.

       The <b>nvlist_get_array_next</b>() function returns the next element from the array or NULL if the nvlist is not
       in array or it is the last element.  Note that <b>nvlist_get_array_next</b>() only works if you added the nvlist
       array using the <b>nvlist_move_nvlist_array</b>() or <b>nvlist_add_nvlist_array</b>() functions.

       The <b>nvlist_get_pararr</b>() function returns the next element in the array, or if not available the parent of
       the nested nvlist.

       The     <b>nvlist_take_bool</b>(),     <b>nvlist_take_number</b>(),     <b>nvlist_take_string</b>(),     <b>nvlist_take_nvlist</b>(),
       <b>nvlist_take_descriptor</b>(),  <b>nvlist_take_binary</b>(),  <b>nvlist_take_bool_array</b>(),   <b>nvlist_take_number_array</b>(),
       <b>nvlist_take_string_array</b>(),  <b>nvlist_take_nvlist_array</b>(),  <b>nvlist_take_descriptor_array</b>() functions return
       value associated with the given name and remove the element from the  nvlist.   In  case  of  string  and
       binary values, the caller is responsible for free returned memory using the <u><a href="../man3/free.3.html">free</a></u>(3) function.  In case of
       nvlist, the caller is responsible for destroying returned nvlist using the <b>nvlist_destroy</b>() function.  In
       case  of  descriptor, the caller is responsible for closing returned descriptor using the <b>close</b>(<u>2</u>) system
       call.  If an element of the given name does not exist, the program will be aborted.  To  avoid  that  the
       caller  should  check  for  the existence of the given name before trying to obtain the value, or use the
       <u><a href="../man3/dnvlist.3.html">dnvlist</a></u>(3) extension, which can provide a default value in the case of a missing element.  In the case of
       an array of strings or binary values, the caller is responsible for freeing every element  of  the  array
       using the <u><a href="../man3/free.3.html">free</a></u>(3) function.  In the case of an array of nvlists, the caller is responsible for destroying
       every  element  of  array using the <b>nvlist_destroy</b>() function.  In the case of descriptors, the caller is
       responsible for closing every element of array using the <b>close</b>(<u>2</u>) system call.  In every  case  involving
       an array, the caller must also free the pointer to the array using the <u><a href="../man3/free.3.html">free</a></u>(3) function.  The nvlist must
       not be in error state.

       The      <b>nvlist_append_bool_array</b>(),      <b>nvlist_append_number_array</b>(),     <b>nvlist_append_string_array</b>(),
       <b>nvlist_append_nvlist_array</b>(),  <b>nvlist_append_descriptor_array</b>()  functions  append  an  element  to   the
       existing  array  using  the  same  semantics  as  the add functions (i.e. the element will be copied when
       applicable).  If the array for a given key does not exist, then it  will  be  created  as  if  using  the
       <b>nvlist_add_&lt;type&gt;_array</b>() function.  The internal error is set on append failure.

       The  <b>nvlist_free</b>()  function  removes element of the given name from the nvlist (besides of its type) and
       frees all resources associated with it.  If element of the given name does not exist, the program will be
       aborted.  The nvlist must not be in error state.

       The <b>nvlist_free_type</b>() function removes element of the given name and the given type from the nvlist  and
       frees  all resources associated with it.  If element of the given name and the given type does not exist,
       the program will be aborted.  The nvlist must not be in error state.

       The     <b>nvlist_free_null</b>(),     <b>nvlist_free_bool</b>(),      <b>nvlist_free_number</b>(),      <b>nvlist_free_string</b>(),
       <b>nvlist_free_nvlist</b>(),     <b>nvlist_free_descriptor</b>(),    <b>nvlist_free_binary</b>(),    <b>nvlist_free_bool_array</b>(),
       <b>nvlist_free_number_array</b>(),            <b>nvlist_free_string_array</b>(),            <b>nvlist_free_nvlist_array</b>(),
       <b>nvlist_free_descriptor_array</b>()  functions  remove element of the given name and the given type determined
       by the function name from the nvlist and free all resources associated with it.  If element of the  given
       name  and  the  given  type does not exist, the program will be aborted.  The nvlist must not be in error
       state.

</pre><h4><b>NOTES</b></h4><pre>
       The <b>nvlist_pack</b>() and <b>nvlist_unpack</b>() functions handle the byte-order conversions, so the  binary  buffer
       can be packed/unpacked by the hosts with the different endianness.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example demonstrates how to prepare an nvlist and send it over <u><a href="../man4/unix.4.html">unix</a></u>(4) domain socket.

       nvlist_t *nvl;
       int fd;

       fd = open("/tmp/foo", O_RDONLY);
       if (fd &lt; 0)
               err(1, "open(\"/tmp/foo\") failed");

       nvl = <a href="../man0/nvlist_create.0.html">nvlist_create</a>(0);
       /*
        * There is no need to check if nvlist_create() succeeded,
        * as the nvlist_add_&lt;type&gt;() functions can cope.
        * If it failed, nvlist_send() will fail.
        */
       nvlist_add_string(nvl, "filename", "/tmp/foo");
       nvlist_add_number(nvl, "flags", O_RDONLY);
       /*
        * We just want to send the descriptor, so we can give it
        * for the nvlist to consume (that's why we use nvlist_move
        * not nvlist_add).
        */
       nvlist_move_descriptor(nvl, "fd", fd);
       if (nvlist_send(sock, nvl) &lt; 0) {
               nvlist_destroy(nvl);
               err(1, "nvlist_send() failed");
       }
       nvlist_destroy(nvl);

       Receiving nvlist and getting data:

       nvlist_t *nvl;
       const char *command;
       char *filename;
       int fd;

       nvl = nvlist_recv(sock, 0);
       if (nvl == NULL)
               err(1, "nvlist_recv() failed");

       /* For command we take pointer to nvlist's buffer. */
       command = nvlist_get_string(nvl, "command");
       /*
        * For filename we remove it from the nvlist and take
        * ownership of the buffer.
        */
       filename = nvlist_take_string(nvl, "filename");
       /* The same for the descriptor. */
       fd = nvlist_take_descriptor(nvl, "fd");

       printf("command=%s filename=%s fd=%d0, command, filename, fd);

       nvlist_destroy(nvl);
       free(filename);
       close(fd);
       /* command was freed by nvlist_destroy() */

       Iterating over nvlist:

       nvlist_t *nvl;
       const char *name;
       void *cookie;
       int type;

       nvl = nvlist_recv(sock, 0);
       if (nvl == NULL)
               err(1, "nvlist_recv() failed");

       cookie = NULL;
       while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
               printf("%s=", name);
               switch (type) {
               case NV_TYPE_NUMBER:
                       printf("%ju", (uintmax_t)nvlist_get_number(nvl, name));
                       break;
               case NV_TYPE_STRING:
                       printf("%s", nvlist_get_string(nvl, name));
                       break;
               default:
                       printf("N/A");
                       break;
               }
               printf("\n");
       }

       Iterating over every nested nvlist:

       nvlist_t *nvl;
       const char *name;
       void *cookie;
       int type;

       nvl = nvlist_recv(sock, 0);
       if (nvl == NULL)
               err(1, "nvlist_recv() failed");

       cookie = NULL;
       do {
               while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
                       if (type == NV_TYPE_NVLIST) {
                               nvl = nvlist_get_nvlist(nvl, name);
                               cookie = NULL;
                       }
               }
       } while ((nvl = nvlist_get_parent(nvl, &amp;cookie)) != NULL);

       Iterating over every nested nvlist and every nvlist element:

       nvlist_t *nvl;
       const nvlist_t * const *array;
       const char *name;
       void *cookie;
       int type;

       nvl = nvlist_recv(sock, 0);
       if (nvl == null)
               err(1, "nvlist_recv() failed");

       cookie = null;
       do {
               while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
                       if (type == NV_TYPE_NVLIST) {
                               nvl = nvlist_get_nvlist(nvl, name);
                               cookie = NULL;
                       } else if (type == NV_TYPE_NVLIST_ARRAY) {
                               nvl = nvlist_get_nvlist_array(nvl, name, NULL)[0];
                               cookie = NULL;
                       }
               }
       } while ((nvl = nvlist_get_pararr(nvl, &amp;cookie)) != NULL);

       Or alternatively:

       nvlist_t *nvl, *tmp;
       const nvlist_t * const *array;
       const char *name;
       void *cookie;
       int type;

       nvl = nvlist_recv(sock, 0);
       if (nvl == null)
               err(1, "nvlist_recv() failed");

       cooke = NULL;
       tmp = nvl;
       do {
               do {
                       nvl = tmp;
                       while ((name = nvlist_next(nvl, &amp;type, &amp;cookie)) != NULL) {
                               if (type == NV_TYPE_NVLIST) {
                                       nvl = nvlist_get_nvlist(nvl,
                                           name);
                                       cookie = NULL;
                               } else if (type == NV_TYPE_NVLIST_ARRAY) {
                                       nvl = nvlist_get_nvlist_array(nvl, name,
                                           NULL)[0];
                                       cookie = NULL;
                               }
                       }
                       cookie = NULL;
               } while ((tmp = nvlist_get_array_next(nvl)) != NULL);
       } while ((tmp = nvlist_get_parent(nvl, &amp;cookie)) != NULL);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/close.2.html">close</a></u>(2), <u><a href="../man2/dup.2.html">dup</a></u>(2), <u><a href="../man2/open.2.html">open</a></u>(2), <u><a href="../man3/err.3.html">err</a></u>(3), <u><a href="../man3/free.3.html">free</a></u>(3), <u><a href="../man3/printf.3.html">printf</a></u>(3), <u><a href="../man4/unix.4.html">unix</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>libnv</b> library appeared in FreeBSD 11.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  <b>libnv</b>  library was implemented by Pawel Jakub Dawidek &lt;<u><a href="mailto:pawel@dawidek.net">pawel@dawidek.net</a></u>&gt; under sponsorship from the
       FreeBSD Foundation.

Debian                                            June 19, 2018                                            <u><a href="../man9/NV.9.html">NV</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>