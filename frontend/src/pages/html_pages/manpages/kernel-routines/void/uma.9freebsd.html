<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UMA — general-purpose kernel object allocator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UMA — general-purpose kernel object allocator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/queue.h&gt;</b>
       <b>#include</b> <b>&lt;vm/uma.h&gt;</b>
       <b>options</b> <b>UMA_FIRSTTOUCH</b>
       <b>options</b> <b>UMA_XDOMAIN</b>

       typedef int (*uma_ctor)(void *mem, int size, void *arg, int flags);
       typedef void (*uma_dtor)(void *mem, int size, void *arg);
       typedef int (*uma_init)(void *mem, int size, int flags);
       typedef void (*uma_fini)(void *mem, int size);
       typedef int (*uma_import)(void *arg, void **store, int count, int domain,
           int flags);
       typedef void (*uma_release)(void *arg, void **store, int count);
       typedef void *(*uma_alloc)(uma_zone_t zone, vm_size_t size, int domain,
           uint8_t *pflag, int wait);
       typedef void (*uma_free)(void *item, vm_size_t size, uint8_t pflag);

       <u>uma_zone_t</u>
       <b>uma_zcreate</b>(<u>char</u> <u>*name</u>,   <u>int</u> <u>size</u>,   <u>uma_ctor</u> <u>ctor</u>,   <u>uma_dtor</u> <u>dtor</u>,   <u>uma_init</u> <u>zinit</u>,   <u>uma_fini</u> <u>zfini</u>,
             <u>int</u> <u>align</u>, <u>uint16_t</u> <u>flags</u>);

       <u>uma_zone_t</u>
       <b>uma_zcache_create</b>(<u>char</u> <u>*name</u>, <u>int</u> <u>size</u>,  <u>uma_ctor</u> <u>ctor</u>,  <u>uma_dtor</u> <u>dtor</u>,  <u>uma_init</u> <u>zinit</u>,  <u>uma_fini</u> <u>zfini</u>,
             <u>uma_import</u> <u>zimport</u>, <u>uma_release</u> <u>zrelease</u>, <u>void</u> <u>*arg</u>, <u>int</u> <u>flags</u>);

       <u>uma_zone_t</u>
       <b>uma_zsecond_create</b>(<u>char</u> <u>*name</u>,     <u>uma_ctor</u> <u>ctor</u>,    <u>uma_dtor</u> <u>dtor</u>,    <u>uma_init</u> <u>zinit</u>,    <u>uma_fini</u> <u>zfini</u>,
             <u>uma_zone_t</u> <u>master</u>);

       <u>void</u>
       <b>uma_zdestroy</b>(<u>uma_zone_t</u> <u>zone</u>);

       <u>void</u> <u>*</u>
       <b>uma_zalloc</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>flags</u>);

       <u>void</u> <u>*</u>
       <b>uma_zalloc_arg</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*arg</u>, <u>int</u> <u>flags</u>);

       <u>void</u> <u>*</u>
       <b>uma_zalloc_domain</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*arg</u>, <u>int</u> <u>domain</u>, <u>int</u> <u>flags</u>);

       <u>void</u> <u>*</u>
       <b>uma_zalloc_pcpu</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>flags</u>);

       <u>void</u> <u>*</u>
       <b>uma_zalloc_pcpu_arg</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*arg</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>uma_zfree</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*item</u>);

       <u>void</u>
       <b>uma_zfree_arg</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*item</u>, <u>void</u> <u>*arg</u>);

       <u>void</u>
       <b>uma_zfree_domain</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*item</u>, <u>void</u> <u>*arg</u>);

       <u>void</u>
       <b>uma_zfree_pcpu</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*item</u>);

       <u>void</u>
       <b>uma_zfree_pcpu_arg</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>*item</u>, <u>void</u> <u>*arg</u>);

       <u>void</u>
       <b>uma_prealloc</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>nitems</u>);

       <u>void</u>
       <b>uma_zone_reserve</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>nitems</u>);

       <u>void</u>
       <b>uma_zone_reserve_kva</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>nitems</u>);

       <u>void</u>
       <b>uma_zone_set_allocf</b>(<u>uma_zone_t</u> <u>zone</u>, <u>uma_alloc</u> <u>allocf</u>);

       <u>void</u>
       <b>uma_zone_set_freef</b>(<u>uma_zone_t</u> <u>zone</u>, <u>uma_free</u> <u>freef</u>);

       <u>int</u>
       <b>uma_zone_set_max</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>nitems</u>);

       <u>int</u>
       <b>uma_zone_set_maxcache</b>(<u>uma_zone_t</u> <u>zone</u>, <u>int</u> <u>nitems</u>);

       <u>int</u>
       <b>uma_zone_get_max</b>(<u>uma_zone_t</u> <u>zone</u>);

       <u>int</u>
       <b>uma_zone_get_cur</b>(<u>uma_zone_t</u> <u>zone</u>);

       <u>void</u>
       <b>uma_zone_set_warning</b>(<u>uma_zone_t</u> <u>zone</u>, <u>const</u> <u>char</u> <u>*warning</u>);

       <u>void</u>
       <b>uma_zone_set_maxaction</b>(<u>uma_zone_t</u> <u>zone</u>, <u>void</u> <u>(*maxaction)(uma_zone_t)</u>);

       <u>void</u>
       <b>uma_reclaim</b>();

       <b>#include</b> <b>&lt;sys/sysctl.h&gt;</b>

       <b>SYSCTL_UMA_MAX</b>(<u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>, <u>descr</u>);

       <b>SYSCTL_ADD_UMA_MAX</b>(<u>ctx</u>, <u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>, <u>descr</u>);

       <b>SYSCTL_UMA_CUR</b>(<u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>, <u>descr</u>);

       <b>SYSCTL_ADD_UMA_CUR</b>(<u>ctx</u>, <u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>, <u>descr</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       UMA  (Universal  Memory  Allocator)  provides  an  efficient  interface  for  managing  dynamically-sized
       collections of items of identical size, referred to as zones.  Zones keep track of which items are in use
       and  which  are  not,  and UMA provides functions for allocating items from a zone and for releasing them
       back, making them available for subsequent allocation  requests.   Zones  maintain  per-CPU  caches  with
       linear  scalability on SMP systems as well as round-robin and first-touch policies for NUMA systems.  The
       number of items cached per CPU is bounded, and each zone additionally maintains  an  unbounded  cache  of
       items that is used to quickly satisfy per-CPU cache allocation misses.

       Two  types  of zones exist: regular zones and cache zones.  In a regular zone, items are allocated from a
       slab, which is one or more virtually contiguous memory pages that have been allocated from  the  kernel's
       page  allocator.   Internally,  slabs are managed by a UMA keg, which is responsible for allocating slabs
       and keeping track of their usage by one or more zones.  In typical usage, there is one keg per  zone,  so
       slabs are not shared among multiple zones.

       Normal  zones  import  items from a keg, and release items back to that keg if requested.  Cache zones do
       not have a keg, and instead use custom import and release methods.   For  example,  some  collections  of
       kernel  objects are statically allocated at boot-time, and the size of the collection does not change.  A
       cache zone can be used to implement an efficient allocator for the objects in such a collection.

       The  <b>uma_zcreate</b>()  and  <b>uma_zcache_create</b>()  functions  create  a  new  regular  zone  and  cache  zone,
       respectively.   The <b>uma_zsecond_create</b>() function creates a regular zone which shares the keg of the zone
       specified by the <u>master</u> argument.  The <u>name</u> argument is a text name of the zone for debugging and  stats;
       this memory should not be freed until the zone has been deallocated.

       The  <u>ctor</u>  and  <u>dtor</u> arguments are callback functions that are called by the UMA subsystem at the time of
       the call  to  <b>uma_zalloc</b>()  and  <b>uma_zfree</b>()  respectively.   Their  purpose  is  to  provide  hooks  for
       initializing  or  destroying  things  that  need to be done at the time of the allocation or release of a
       resource.  A good usage for the <u>ctor</u> and <u>dtor</u> callbacks might be to initialize a data structure  embedded
       in the item, such as a <u><a href="../man3/queue.3.html">queue</a></u>(3) head.

       The  <u>zinit</u>  and  <u>zfini</u>  arguments  are  used to optimize the allocation of items from the zone.  They are
       called by the UMA subsystem whenever it needs to allocate or free items to  satisfy  requests  or  memory
       pressure.   A  good  use  for  the  <u>zinit</u>  and <u>zfini</u> callbacks might be to initialize and destroy a mutex
       contained within an item.  This would allow one to avoid destroying and re-initializing  the  mutex  each
       time  the  item  is  freed  and  re-allocated.   They  are  not  called  on each call to <b>uma_zalloc</b>() and
       <b>uma_zfree</b>() but rather when an item is imported into a zone's cache, and when a zone releases an item  to
       the slab allocator, typically as a response to memory pressure.

       For  <b>uma_zcache_create</b>(), the <u>zimport</u> and <u>zrelease</u> functions are called to import items into the zone and
       to release items from the zone, respectively.  The <u>zimport</u> function should store pointers to items in the
       <u>store</u> array, which contains a maximum of <u>count</u> entries.  The function must return the number of  imported
       items,  which  may  be  less  than  the maximum.  Similarly, the <u>store</u> parameter to the <u>zrelease</u> function
       contains an array of <u>count</u> pointers to  items.   The  <u>arg</u>  parameter  passed  to  <b>uma_zcache_create</b>()  is
       provided  to  the  import and release functions.  The <u>domain</u> parameter to <u>zimport</u> specifies the requested
       <u><a href="../man4/numa.4.html">numa</a></u>(4) domain for the allocation.  It is either a NUMA domain number or the special value UMA_ANYDOMAIN.

       The <u>flags</u> argument of <b>uma_zcreate</b>() and <b>uma_zcache_create</b>() is a subset of the following flags:

       UMA_ZONE_NOFREE
            Slabs allocated to the zone's keg are never freed.

       UMA_ZONE_NODUMP
            Pages belonging to the zone will not be included in minidumps.

       UMA_ZONE_PCPU
            An allocation from zone would have <u>mp_ncpu</u> shadow copies, that are privately assigned  to  CPUs.   A
            CPU  can  address  its private copy using base the allocation address plus a multiple of the current
            CPU ID and <b>sizeof</b>(<u>struct</u> <u>pcpu</u>):

                  foo_zone = uma_zcreate(..., UMA_ZONE_PCPU);
                   ...
                  foo_base = uma_zalloc(foo_zone, ...);
                   ...
                  critical_enter();
                  foo_pcpu = (foo_t *)zpcpu_get(foo_base);
                  /* do something with foo_pcpu */
                  critical_exit();

            Note that M_ZERO cannot be used when allocating items from a PCPU zone.   To  obtain  zeroed  memory
            from a PCPU zone, use the <b>uma_zalloc_pcpu</b>() function and its variants instead, and pass M_ZERO.

       UMA_ZONE_OFFPAGE
            By  default  book-keeping  of  items  within  a  slab  is  done  in the slab page itself.  This flag
            explicitly tells subsystem that book-keeping structure should be allocated separately  from  special
            internal  zone.   This  flag  requires  either  UMA_ZONE_VTOSLAB  or  UMA_ZONE_HASH, since subsystem
            requires a mechanism to find a book-keeping structure to an item being  freed.   The  subsystem  may
            choose to prefer offpage book-keeping for certain zones implicitly.

       UMA_ZONE_ZINIT
            The  zone will have its <u>uma_init</u> method set to internal method that initializes a new allocated slab
            to all zeros.  Do not mistake <u>uma_init</u> method with <u>uma_ctor</u>.  A zone with UMA_ZONE_ZINIT flag  would
            not return zeroed memory on every <b>uma_zalloc</b>().

       UMA_ZONE_HASH
            The  zone  should use an internal hash table to find slab book-keeping structure where an allocation
            being freed belongs to.

       UMA_ZONE_VTOSLAB
            The zone should use special field  of  <u>vm_page_t</u>  to  find  slab  book-keeping  structure  where  an
            allocation being freed belongs to.

       UMA_ZONE_MALLOC
            The zone is for the <u><a href="../man9/malloc.9.html">malloc</a></u>(9) subsystem.

       UMA_ZONE_VM
            The zone is for the VM subsystem.

       UMA_ZONE_NUMA
            The  zone  should  use  a  first-touch  NUMA  policy  rather  than  the round-robin default.  If the
            UMA_FIRSTTOUCH kernel option is configured, all zones implicitly use a first-touch policy,  and  the
            UMA_ZONE_NUMA  flag has no effect.  The UMA_XDOMAIN kernel option, when configured, causes UMA to do
            the extra tracking to ensure that allocations from first-touch zones are always  local.   Otherwise,
            consumers  that  do not free memory on the same domain from which it was allocated will cause mixing
            in per-CPU caches.  See <u><a href="../man4/numa.4.html">numa</a></u>(4) for more details.

       Zones can be destroyed using <b>uma_zdestroy</b>(), freeing all memory that is cached in the  zone.   All  items
       allocated from the zone must be freed to the zone before the zone may be safely destroyed.

       To  allocate  an item from a zone, simply call <b>uma_zalloc</b>() with a pointer to that zone and set the <u>flags</u>
       argument to selected flags as documented  in  <u><a href="../man9/malloc.9.html">malloc</a></u>(9).   It  will  return  a  pointer  to  an  item  if
       successful,  or  NULL in the rare case where all items in the zone are in use and the allocator is unable
       to grow the zone and M_NOWAIT is specified.

       Items are released back to the zone from which they were allocated by calling <b>uma_zfree</b>() with a  pointer
       to the zone and a pointer to the item.  If <u>item</u> is NULL, then <b>uma_zfree</b>() does nothing.

       The  variants  <b>uma_zalloc_arg</b>() and <b>uma_zfree_arg</b>() allow callers to specify an argument for the ctor and
       dtor functions of the zone, respectively.  The <b>uma_zalloc_domain</b>() function allows callers to  specify  a
       fixed  <u><a href="../man4/numa.4.html">numa</a></u>(4)  domain  to  allocate  from.   This uses a guaranteed but slow path in the allocator which
       reduces concurrency.  The <b>uma_zfree_domain</b>() function should be used to return memory allocated  in  this
       fashion.  This function infers the domain from the pointer and does not require it as an argument.

       The  <b>uma_prealloc</b>()  function  allocates slabs for the requested number of items, typically following the
       initial creation of a zone.  Subsequent allocations from the  zone  will  be  satisfied  using  the  pre-
       allocated  slabs.   Note  that slab allocation is performed with the M_WAITOK flag, so <b>uma_prealloc</b>() may
       sleep.

       The <b>uma_zone_reserve</b>() function sets the number  of  reserved  items  for  the  zone.   <b>uma_zalloc</b>()  and
       variants  will  ensure that the zone contains at least the reserved number of free items.  Reserved items
       may be allocated by specifying M_USE_RESERVE in the allocation request  flags.   <b>uma_zone_reserve</b>()  does
       not perform any pre-allocation by itself.

       The  <b>uma_zone_reserve_kva</b>()  function pre-allocates kernel virtual address space for the requested number
       of items.  Subsequent allocations from the zone will be satisfied using the pre-allocated address  space.
       Note  that  unlike  <b>uma_zone_reserve</b>(),  <b>uma_zone_reserve_kva</b>()  does  not  restrict  the use of the pre-
       allocation to M_USE_RESERVE requests.

       The <b>uma_zone_set_allocf</b>() and <b>uma_zone_set_freef</b>() functions allow a zone's default slab  allocation  and
       free  functions  to  be  overridden.   This  is useful if the zone's items have special memory allocation
       constraints.  For example, if multi-page objects are required to  be  physically  contiguous,  an  <u>allocf</u>
       function which requests contiguous memory from the kernel's page allocator may be used.

       The  <b>uma_zone_set_max</b>()  function limits the number of items (and therefore memory) that can be allocated
       to <u>zone</u>.  The <u>nitems</u> argument specifies the requested upper limit number of items.  The  effective  limit
       is  returned  to  the  caller,  as  it  may  end up being higher than requested due to the implementation
       rounding up to ensure all memory pages allocated to the zone are utilised to capacity.  The limit applies
       to the total number of items in the zone, which includes allocated items, free items and  free  items  in
       the  per-cpu  caches.  On systems with more than one CPU it may not be possible to allocate the specified
       number of items even when there is no shortage of memory, because all of the remaining free items may  be
       in the caches of the other CPUs when the limit is hit.

       The  <b>uma_zone_set_maxcache</b>()  function  limits  the number of free items which may be cached in the zone,
       excluding the per-CPU caches, which are bounded in size.  For example,  to  implement  a  ‘pure’  per-CPU
       cache, a cache zone may be configured with a maximum cache size of 0.

       The <b>uma_zone_get_max</b>() function returns the effective upper limit number of items for a zone.

       The  <b>uma_zone_get_cur</b>() function returns an approximation of the number of items currently allocated from
       the zone.  The returned value is approximate because appropriate synchronisation to  determine  an  exact
       value  is  not  performed by the implementation.  This ensures low overhead at the expense of potentially
       stale data being used in the calculation.

       The <b>uma_zone_set_warning</b>() function sets a warning that will be printed on the system  console  when  the
       given  zone  becomes  full and fails to allocate an item.  The warning will be printed no more often than
       every five minutes.  Warnings can be turned off globally by setting the <u>vm.zone_warnings</u>  sysctl  tunable
       to <u>0</u>.

       The  <b>uma_zone_set_maxaction</b>()  function  sets  a function that will be called when the given zone becomes
       full and fails to allocate an item.  The function will  be  called  with  the  zone  locked.   Also,  the
       function  that  called  the allocation function may have held additional locks.  Therefore, this function
       should do very little work (similar to a signal handler).

       The <b>SYSCTL_UMA_MAX</b>(<u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>, <u>descr</u>) macro declares a  static  <u><a href="../man9/sysctl.9.html">sysctl</a></u>(9)  oid  that
       exports  the  effective upper limit number of items for a zone.  The <u>zone</u> argument should be a pointer to
       <u>uma_zone_t</u>.  A read of the oid returns value obtained through <b>uma_zone_get_max</b>().  A  write  to  the  oid
       sets  new  value  via  <b>uma_zone_set_max</b>().   The <b>SYSCTL_ADD_UMA_MAX</b>(<u>ctx</u>, <u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>,
       <u>descr</u>) macro is provided to create this type of oid dynamically.

       The <b>SYSCTL_UMA_CUR</b>(<u>parent</u>, <u>nbr</u>, <u>name</u>, <u>access</u>, <u>zone</u>, <u>descr</u>) macro declares a  static  read-only  <u><a href="../man9/sysctl.9.html">sysctl</a></u>(9)
       oid that exports the approximate current occupancy of the zone.  The <u>zone</u> argument should be a pointer to
       <u>uma_zone_t</u>.    A   read   of   the   oid   returns   value   obtained  through  <b>uma_zone_get_cur</b>().   The
       <b>SYSCTL_ADD_UMA_CUR</b>(<u>ctx</u>, <u>parent</u>, <u>nbr</u>, <u>name</u>, <u>zone</u>, <u>descr</u>) macro is provided to  create  this  type  of  oid
       dynamically.

</pre><h4><b>IMPLEMENTATION</b> <b>NOTES</b></h4><pre>
       The  memory  that  these  allocation  calls return is not executable.  The <b>uma_zalloc</b>() function does not
       support the M_EXEC flag to allocate executable memory.  Not all platforms enforce a  distinction  between
       executable and non-executable memory.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/numa.4.html">numa</a></u>(4), <u><a href="../man8/vmstat.8.html">vmstat</a></u>(8), <u><a href="../man9/malloc.9.html">malloc</a></u>(9)

       Jeff Bonwick, <u>The</u> <u>Slab</u> <u>Allocator:</u> <u>An</u> <u>Object-Caching</u> <u>Kernel</u> <u>Memory</u> <u>Allocator</u>, 1994.

</pre><h4><b>HISTORY</b></h4><pre>
       The zone allocator first appeared in FreeBSD 3.0.  It was radically changed in FreeBSD 5.0 to function as
       a slab allocator.

</pre><h4><b>AUTHORS</b></h4><pre>
       The zone allocator was written by John S. Dyson.  The zone allocator was rewritten in large parts by Jeff
       Roberson &lt;<u><a href="mailto:jeff@FreeBSD.org">jeff@FreeBSD.org</a></u>&gt; to function as a slab allocator.

       This manual page was written by Dag-Erling Smørgrav &lt;<u><a href="mailto:des@FreeBSD.org">des@FreeBSD.org</a></u>&gt;.  Changes for UMA by Jeroen Ruigrok
       van der Werven &lt;<u><a href="mailto:asmodai@FreeBSD.org">asmodai@FreeBSD.org</a></u>&gt;.

Debian                                           August 20, 2020                                          <u><a href="../man9/UMA.9.html">UMA</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>