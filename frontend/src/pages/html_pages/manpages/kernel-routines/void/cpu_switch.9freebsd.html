<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mi_switch, cpu_switch, cpu_throw — switch to another thread context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mi_switch, cpu_switch, cpu_throw — switch to another thread context

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/proc.h&gt;</b>

       <u>void</u>
       <b>mi_switch</b>(<u>void</u>);

       <u>void</u>
       <b>cpu_switch</b>(<u>void</u>);

       <u>void</u>
       <b>cpu_throw</b>(<u>void</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>mi_switch</b>()  function  implements the machine independent prelude to a thread context switch.  It is
       called from only a few distinguished places in the kernel code as a  result  of  the  principle  of  non-
       preemptable kernel mode execution.  The various major uses of <b>mi_switch</b> can be enumerated as follows:

             1.   From  within  a function such as <u><a href="../man9/cv_wait.9.html">cv_wait</a></u>(9), <u><a href="../man9/mtx_lock.9.html">mtx_lock</a></u>(9), or <u><a href="../man9/tsleep.9.html">tsleep</a></u>(9) when the current thread
                  voluntarily relinquishes the CPU to wait for some resource or lock to become available.

             2.   After handling a trap (e.g. a system call, device interrupt) when the kernel prepares a return
                  to user-mode execution.  This case is typically handled  by  machine  dependent  trap-handling
                  code  after  detection of a change in the signal disposition of the current process, or when a
                  higher priority thread might be available to run.  The latter event  is  communicated  by  the
                  machine independent scheduling routines by calling the machine defined <b>need_resched</b>().

             3.   In  the  signal handling code (see <u><a href="../man9/issignal.9.html">issignal</a></u>(9)) if a signal is delivered that causes a process
                  to stop.

             4.   When a thread dies in <u><a href="../man9/thread_exit.9.html">thread_exit</a></u>(9) and control of the processor can be passed  to  the  next
                  runnable thread.

             5.   In  <u><a href="../man9/thread_suspend_check.9.html">thread_suspend_check</a></u>(9) where a thread needs to stop execution due to the suspension state
                  of the process as a whole.

       <b>mi_switch</b>() records the amount of time the current thread has been running in the process structures  and
       checks this value against the CPU time limits allocated to the process (see <u><a href="../man2/getrlimit.2.html">getrlimit</a></u>(2)).  Exceeding the
       soft  limit  results in a SIGXCPU signal to be posted to the process, while exceeding the hard limit will
       cause a SIGKILL.

       If the thread is still in the TDS_RUNNING state, <b>mi_switch</b>()  will  put  it  back  onto  the  run  queue,
       assuming  that  it will want to run again soon.  If it is in one of the other states and KSE threading is
       enabled, the associated <u>KSE</u> will be made available to any higher priority threads from the same group, to
       allow them to be scheduled next.

       After these administrative tasks are done, <b>mi_switch</b>()  hands  over  control  to  the  machine  dependent
       routine <b>cpu_switch</b>(), which will perform the actual thread context switch.

       <b>cpu_switch</b>()  first  saves the context of the current thread.  Next, it calls <b>choosethread</b>() to determine
       which thread to run next.  Finally, it reads in the saved context of the new thread and starts to execute
       the new thread.

       <b>cpu_throw</b>() is similar to <b>cpu_switch</b>() except that it does not save the context of the old thread.   This
       function  is  useful when the kernel does not have an old thread context to save, such as when CPUs other
       than the boot CPU perform their first task switch, or when the kernel does not care about  the  state  of
       the  old thread, such as in <b>thread_exit</b>() when the kernel terminates the current thread and switches into
       a new thread.

       To protect the <u><a href="../man9/runqueue.9.html">runqueue</a></u>(9), all of these functions must be called with the <u>sched_lock</u> mutex held.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/cv_wait.9.html">cv_wait</a></u>(9), <u><a href="../man9/issignal.9.html">issignal</a></u>(9), <u><a href="../man9/mutex.9.html">mutex</a></u>(9), <u><a href="../man9/runqueue.9.html">runqueue</a></u>(9), <u><a href="../man9/tsleep.9.html">tsleep</a></u>(9), <u><a href="../man9/wakeup.9.html">wakeup</a></u>(9)

Debian                                          November 24, 1996                                   <u><a href="../man9/MI_SWITCH.9.html">MI_SWITCH</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>