<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEVICE_IDENTIFY — identify a device, register it</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DEVICE_IDENTIFY — identify a device, register it

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/bus.h&gt;</b>

       <u>void</u>
       <b>DEVICE_IDENTIFY</b>(<u>driver_t</u> <u>*driver</u>, <u>device_t</u> <u>parent</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  identify  function  for  a  device  is  only  needed for devices on buses that cannot identify their
       children independently, e.g. the ISA bus.  It is used to recognize the device (usually done by  accessing
       non-ambiguous  registers  in the hardware) and to tell the kernel about it and thus creating a new device
       instance.

       <u><a href="../man9/BUS_ADD_CHILD.9.html">BUS_ADD_CHILD</a></u>(9) is used to register the device as a child of the bus.  The device's resources  (such  as
       IRQ  and I/O ports) are registered with the kernel by calling <b>bus_set_resource</b>() for each resource (refer
       to <u><a href="../man9/bus_set_resource.9.html">bus_set_resource</a></u>(9) for more information).

       Since the device tree and the device driver tree are disjoint, the  <b>DEVICE_IDENTIFY</b>()  routine  needs  to
       take  this  into  account.   If you load and unload your device driver that has the identify routine, the
       child node has the potential for adding the same node multiple times unless specific measure are taken to
       preclude that possibility.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following pseudo-code shows an example of a  function  that  probes  for  a  piece  of  hardware  and
       registers it and its resource (an I/O port) with the kernel.

       void
       foo_identify(driver_t *driver, device_t parent)
       {
               device_t child;

               retrieve_device_information;
               if (devices matches one of your supported devices &amp;&amp;
                   not already in device tree) {
                       child = BUS_ADD_CHILD(parent, 0, "foo", -1);
                       bus_set_resource(child, SYS_RES_IOPORT, 0, FOO_IOADDR, 1);
               }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/BUS_ADD_CHILD.9.html">BUS_ADD_CHILD</a></u>(9),      <u><a href="../man9/bus_set_resource.9.html">bus_set_resource</a></u>(9),     <u><a href="../man9/device.9.html">device</a></u>(9),     <u><a href="../man9/device_add_child.9.html">device_add_child</a></u>(9),     <u><a href="../man9/DEVICE_ATTACH.9.html">DEVICE_ATTACH</a></u>(9),
       <u><a href="../man9/DEVICE_DETACH.9.html">DEVICE_DETACH</a></u>(9), <u><a href="../man9/DEVICE_PROBE.9.html">DEVICE_PROBE</a></u>(9), <u><a href="../man9/DEVICE_SHUTDOWN.9.html">DEVICE_SHUTDOWN</a></u>(9)

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Alexander Langer &lt;<u><a href="mailto:alex@FreeBSD.org">alex@FreeBSD.org</a></u>&gt;.

Debian                                          January 15, 2017                              <u><a href="../man9/DEVICE_IDENTIFY.9.html">DEVICE_IDENTIFY</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>