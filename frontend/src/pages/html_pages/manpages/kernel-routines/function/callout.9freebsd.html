<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>callout_active,     callout_deactivate,    callout_async_drain,    callout_drain,    callout_handle_init,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       callout_active,     callout_deactivate,    callout_async_drain,    callout_drain,    callout_handle_init,
       callout_init,  callout_init_mtx,  callout_init_rm,   callout_init_rw,   callout_pending,   callout_reset,
       callout_reset_curcpu,        callout_reset_on,        callout_reset_sbt,        callout_reset_sbt_curcpu,
       callout_reset_sbt_on,       callout_schedule,        callout_schedule_curcpu,        callout_schedule_on,
       callout_schedule_sbt,  callout_schedule_sbt_curcpu,  callout_schedule_sbt_on, callout_stop, callout_when,
       timeout, untimeout — execute a function after a specified length of time

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/callout.h&gt;</b>
       <b>#include</b> <b>&lt;sys/systm.h&gt;</b>

       typedef void callout_func_t (void *);
       typedef void timeout_t (void *);

       <u>int</u>
       <b>callout_active</b>(<u>struct</u> <u>callout</u> <u>*c</u>);

       <u>void</u>
       <b>callout_deactivate</b>(<u>struct</u> <u>callout</u> <u>*c</u>);

       <u>int</u>
       <b>callout_async_drain</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>callout_func_t</u> <u>*drain</u>);

       <u>int</u>
       <b>callout_drain</b>(<u>struct</u> <u>callout</u> <u>*c</u>);

       <u>void</u>
       <b>callout_handle_init</b>(<u>struct</u> <u>callout_handle</u> <u>*handle</u>);

       struct callout_handle handle = CALLOUT_HANDLE_INITIALIZER(&amp;handle);

       <u>void</u>
       <b>callout_init</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>mpsafe</u>);

       <u>void</u>
       <b>callout_init_mtx</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>struct</u> <u>mtx</u> <u>*mtx</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>callout_init_rm</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>struct</u> <u>rmlock</u> <u>*rm</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>callout_init_rw</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>struct</u> <u>rwlock</u> <u>*rw</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_pending</b>(<u>struct</u> <u>callout</u> <u>*c</u>);

       <u>int</u>
       <b>callout_reset</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>ticks</u>, <u>callout_func_t</u> <u>*func</u>, <u>void</u> <u>*arg</u>);

       <u>int</u>
       <b>callout_reset_curcpu</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>ticks</u>, <u>callout_func_t</u> <u>*func</u>, <u>void</u> <u>*arg</u>);

       <u>int</u>
       <b>callout_reset_on</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>ticks</u>, <u>callout_func_t</u> <u>*func</u>, <u>void</u> <u>*arg</u>, <u>int</u> <u>cpu</u>);

       <u>int</u>
       <b>callout_reset_sbt</b>(<u>struct</u> <u>callout</u> <u>*c</u>,  <u>sbintime_t</u> <u>sbt</u>,  <u>sbintime_t</u> <u>pr</u>,  <u>callout_func_t</u> <u>*func</u>,   <u>void</u> <u>*arg</u>,
           <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_reset_sbt_curcpu</b>(<u>struct</u> <u>callout</u> <u>*c</u>,    <u>sbintime_t</u> <u>sbt</u>,    <u>sbintime_t</u> <u>pr</u>,    <u>callout_func_t</u> <u>*func</u>,
           <u>void</u> <u>*arg</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_reset_sbt_on</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>sbintime_t</u> <u>sbt</u>, <u>sbintime_t</u> <u>pr</u>,  <u>callout_func_t</u> <u>*func</u>,  <u>void</u> <u>*arg</u>,
           <u>int</u> <u>cpu</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_schedule</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>ticks</u>);

       <u>int</u>
       <b>callout_schedule_curcpu</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>ticks</u>);

       <u>int</u>
       <b>callout_schedule_on</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>int</u> <u>ticks</u>, <u>int</u> <u>cpu</u>);

       <u>int</u>
       <b>callout_schedule_sbt</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>sbintime_t</u> <u>sbt</u>, <u>sbintime_t</u> <u>pr</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_schedule_sbt_curcpu</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>sbintime_t</u> <u>sbt</u>, <u>sbintime_t</u> <u>pr</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_schedule_sbt_on</b>(<u>struct</u> <u>callout</u> <u>*c</u>, <u>sbintime_t</u> <u>sbt</u>, <u>sbintime_t</u> <u>pr</u>, <u>int</u> <u>cpu</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>callout_stop</b>(<u>struct</u> <u>callout</u> <u>*c</u>);

       <u>sbintime_t</u>
       <b>callout_when</b>(<u>sbintime_t</u> <u>sbt</u>,         <u>sbintime_t</u> <u>precision</u>,         <u>int</u> <u>flags</u>,        <u>sbintime_t</u> <u>*sbt_res</u>,
           <u>sbintime_t</u> <u>*precision_res</u>);

       <u>struct</u> <u>callout_handle</u>
       <b>timeout</b>(<u>timeout_t</u> <u>*func</u>, <u>void</u> <u>*arg</u>, <u>int</u> <u>ticks</u>);

       <u>void</u>
       <b>untimeout</b>(<u>timeout_t</u> <u>*func</u>, <u>void</u> <u>*arg</u>, <u>struct</u> <u>callout_handle</u> <u>handle</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>callout</b> API is used to schedule a call to an arbitrary function at a specific  time  in  the  future.
       Consumers  of  this  API  are  required to allocate a callout structure (struct callout) for each pending
       function invocation.  This structure stores state about the pending  function  invocation  including  the
       function  to  be called and the time at which the function should be invoked.  Pending function calls can
       be cancelled or rescheduled to a different time.  In addition, a  callout  structure  may  be  reused  to
       schedule a new function call after a scheduled call is completed.

       Callouts  only  provide  a single-shot mode.  If a consumer requires a periodic timer, it must explicitly
       reschedule each function call.  This is normally done by rescheduling  the  subsequent  call  within  the
       called function.

       Callout  functions  must  not  sleep.  They may not acquire sleepable locks, wait on condition variables,
       perform blocking allocation requests, or invoke any other action that might sleep.

       Each callout structure must be initialized by <b>callout_init</b>(), <b>callout_init_mtx</b>(),  <b>callout_init_rm</b>(),  or
       <b>callout_init_rw</b>() before it is passed to any of the other callout functions.  The <b>callout_init</b>() function
       initializes a callout structure in <u>c</u> that is not associated with a specific lock.  If the <u>mpsafe</u> argument
       is zero, the callout structure is not considered to be “multi-processor safe”; and the Giant lock will be
       acquired before calling the callout function and released when the callout function returns.

       The <b>callout_init_mtx</b>(), <b>callout_init_rm</b>(), and <b>callout_init_rw</b>() functions initialize a callout structure
       in  <u>c</u>  that  is  associated with a specific lock.  The lock is specified by the <u>mtx</u>, <u>rm</u>, or <u>rw</u> parameter.
       The associated lock must be held while stopping or  rescheduling  the  callout.   The  callout  subsystem
       acquires  the  associated  lock  before  calling  the callout function and releases it after the function
       returns.  If the callout was cancelled while the callout subsystem waited for the  associated  lock,  the
       callout  function  is  not  called,  and  the associated lock is released.  This ensures that stopping or
       rescheduling the callout will abort any previously scheduled invocation.

       Only regular mutexes may be used with <b>callout_init_mtx</b>(); spin mutexes are not  supported.   A  sleepable
       read-mostly  lock  (one  initialized  with the RM_SLEEPABLE flag) may not be used with <b>callout_init_rm</b>().
       Similarly, other sleepable lock types such as <u><a href="../man9/sx.9.html">sx</a></u>(9) and <u><a href="../man9/lockmgr.9.html">lockmgr</a></u>(9) cannot be used with  callouts  because
       sleeping is not permitted in the callout subsystem.

       These <u>flags</u> may be specified for <b>callout_init_mtx</b>(), <b>callout_init_rm</b>(), or <b>callout_init_rw</b>():

       CALLOUT_RETURNUNLOCKED  The  callout  function  will  release  the associated lock itself, so the callout
                               subsystem should not attempt to unlock it after the callout function returns.

       CALLOUT_SHAREDLOCK      The lock is only acquired in read mode when running the  callout  handler.   This
                               flag is ignored by <b>callout_init_mtx</b>().

       The  function  <b>callout_stop</b>()  cancels a callout <u>c</u> if it is currently pending.  If the callout is pending
       and successfully stopped, then <b>callout_stop</b>() returns a value of one.  If the callout is not set, or  has
       already  been  serviced,  then  negative one is returned.  If the callout is currently being serviced and
       cannot be stopped, then zero will be returned.  If the callout is currently being serviced and cannot  be
       stopped,  and  at  the  same  time  a  next  invocation  of  the  same  callout  is  also scheduled, then
       <b>callout_stop</b>() unschedules the next run and returns zero.  If the callout has an  associated  lock,  then
       that lock must be held when this function is called.

       The   function   <b>callout_async_drain</b>()   is  identical  to  <b>callout_stop</b>()  with  one  difference.   When
       <b>callout_async_drain</b>() returns zero it will arrange for the function <u>drain</u> to be  called  using  the  same
       argument  given  to the <b>callout_reset</b>() function.  <b>callout_async_drain</b>() If the callout has an associated
       lock, then that lock must be held when this  function  is  called.   Note  that  when  stopping  multiple
       callouts that use the same lock it is possible to get multiple return's of zero and multiple calls to the
       <u>drain</u> function, depending upon which CPU's the callouts are running.  The <u>drain</u> function itself is called
       from the context of the completing callout i.e. softclock or hardclock, just like a callout itself.

       The function <b>callout_drain</b>() is identical to <b>callout_stop</b>() except that it will wait for the callout <u>c</u> to
       complete if it is already in progress.  This function MUST NOT be called while holding any locks on which
       the  callout  might block, or deadlock will result.  Note that if the callout subsystem has already begun
       processing this callout, then the  callout  function  may  be  invoked  before  <b>callout_drain</b>()  returns.
       However,   the  callout  subsystem  does  guarantee  that  the  callout  will  be  fully  stopped  before
       <b>callout_drain</b>() returns.

       The <b>callout_reset</b>() and <b>callout_schedule</b>() function families schedule a future  function  invocation  for
       callout  <u>c</u>.   If <u>c</u> already has a pending callout, it is cancelled before the new invocation is scheduled.
       These functions return a value of one if a pending callout was cancelled and zero if there was no pending
       callout.  If the callout has an associated lock, then that lock must be held when any of these  functions
       are called.

       The  time at which the callout function will be invoked is determined by either the <u>ticks</u> argument or the
       <u>sbt</u>, <u>pr</u>, and <u>flags</u> arguments.  When <u>ticks</u> is used, the callout is scheduled  to  execute  after  <u>ticks</u>/hz
       seconds.  Non-positive values of <u>ticks</u> are silently converted to the value ‘1’.

       The  <u>sbt</u>,  <u>pr</u>,  and  <u>flags</u>  arguments  provide more control over the scheduled time including support for
       higher resolution times, specifying the precision of the scheduled time, and setting an absolute deadline
       instead of a relative timeout.  The callout is scheduled to execute in a time window which begins at  the
       time specified in <u>sbt</u> and extends for the amount of time specified in <u>pr</u>.  If <u>sbt</u> specifies a time in the
       past,  the  window  is adjusted to start at the current time.  A non-zero value for <u>pr</u> allows the callout
       subsystem to coalesce callouts scheduled close to  each  other  into  fewer  timer  interrupts,  reducing
       processing  overhead and power consumption.  These <u>flags</u> may be specified to adjust the interpretation of
       <u>sbt</u> and <u>pr</u>:

       C_ABSOLUTE     Handle the <u>sbt</u> argument as an absolute time since boot.  By default, <u>sbt</u> is treated  as  a
                      relative amount of time, similar to <u>ticks</u>.

       C_DIRECT_EXEC  Run  the  handler  directly  from hardware interrupt context instead of from the softclock
                      thread.  This reduces latency and overhead, but  puts  more  constraints  on  the  callout
                      function.  Callout functions run in this context may use only spin mutexes for locking and
                      should be as small as possible because they run with absolute priority.

       <b>C_PREL</b>()       Specifies  relative  event  time precision as binary logarithm of time interval divided by
                      acceptable time deviation: 1 -- 1/2, 2 -- 1/4, etc.  Note that the larger of  <u>pr</u>  or  this
                      value  is  used  as the length of the time window.  Smaller values (which result in larger
                      time intervals) allow the  callout  subsystem  to  aggregate  more  events  in  one  timer
                      interrupt.

       C_PRECALC      The  <u>sbt</u>  argument specifies the absolute time at which the callout should be run, and the
                      <u>pr</u> argument specifies the requested precision, which  will  not  be  adjusted  during  the
                      scheduling  process.   The  <u>sbt</u>  and  <u>pr</u> values should be calculated by an earlier call to
                      <b>callout_when</b>() which uses the user-supplied <u>sbt</u>, <u>pr</u>, and <u>flags</u> values.

       C_HARDCLOCK    Align the timeouts to <b>hardclock</b>() calls if possible.

       The <b>callout_reset</b>() functions accept a <u>func</u> argument which identifies the function to be called when  the
       time  expires.  It must be a pointer to a function that takes a single <u>void</u> <u>*</u> argument.  Upon invocation,
       <u>func</u> will receive <u>arg</u> as its only argument.  The <b>callout_schedule</b>() functions  reuse  the  <u>func</u>  and  <u>arg</u>
       arguments  from  the  previous  callout.   Note  that one of the <b>callout_reset</b>() functions must always be
       called to initialize <u>func</u> and <u>arg</u> before one of the <b>callout_schedule</b>() functions can be used.

       The callout subsystem provides a softclock thread for each CPU in the system.  Callouts are assigned to a
       single CPU and are executed by the softclock thread for that CPU.  Initially, callouts  are  assigned  to
       CPU     0.      The     <b>callout_reset_on</b>(),     <b>callout_reset_sbt_on</b>(),     <b>callout_schedule_on</b>()     and
       <b>callout_schedule_sbt_on</b>()  functions  assign  the  callout  to  CPU  <u>cpu</u>.   The   <b>callout_reset_curcpu</b>(),
       <b>callout_reset_sbt_curpu</b>(),  <b>callout_schedule_curcpu</b>()  and <b>callout_schedule_sbt_curcpu</b>() functions assign
       the callout to  the  current  CPU.   The  <b>callout_reset</b>(),  <b>callout_reset_sbt</b>(),  <b>callout_schedule</b>()  and
       <b>callout_schedule_sbt</b>()  functions  schedule  the callout to execute in the softclock thread of the CPU to
       which it is currently assigned.

       Softclock threads are not pinned to their respective CPUs by default.  The softclock thread for CPU 0 can
       be pinned to CPU 0 by setting the <u>kern.pin_default_swi</u> loader tunable to  a  non-zero  value.   Softclock
       threads  for CPUs other than zero can be pinned to their respective CPUs by setting the <u>kern.pin_pcpu_swi</u>
       loader tunable to a non-zero value.

       The macros <b>callout_pending</b>(), <b>callout_active</b>() and <b>callout_deactivate</b>() provide  access  to  the  current
       state  of  the  callout.   The  <b>callout_pending</b>() macro checks whether a callout is <u>pending</u>; a callout is
       considered <u>pending</u> when a timeout has been set but the time has not yet  arrived.   Note  that  once  the
       timeout  time  arrives  and  the callout subsystem starts to process this callout, <b>callout_pending</b>() will
       return FALSE even though the callout function may not have  finished  (or  even  begun)  executing.   The
       <b>callout_active</b>()  macro  checks whether a callout is marked as <u>active</u>, and the <b>callout_deactivate</b>() macro
       clears the callout's <u>active</u> flag.  The callout subsystem marks a callout as <u>active</u> when a timeout is  set
       and  it  clears  the  <u>active</u>  flag in <b>callout_stop</b>() and <b>callout_drain</b>(), but it <u>does</u> <u>not</u> clear it when a
       callout expires normally via the execution of the callout function.

       The <b>callout_when</b>() function may be used to pre-calculate the absolute time at which the timeout should be
       run and the precision of the scheduled run time according to the required time <u>sbt</u>, precision  <u>precision</u>,
       and  additional  adjustments  requested  by  the  <u>flags</u>  argument.   Flags accepted by the <b>callout_when</b>()
       function are the same as flags for the <b>callout_reset</b>() function.  The resulting time is assigned  to  the
       variable  pointed  to by the <u>sbt_res</u> argument, and the resulting precision is assigned to <u>*precision_res</u>.
       When passing the results to <u>callout_reset</u>, add the <u>C_PRECALC</u>  flag  to  <u>flags</u>,  to  avoid  incorrect  re-
       adjustment.   The  function  is  intended  for situations where precise time of the callout run should be
       known  in  advance,  since  trying  to  read  this  time  from  the  callout  structure  itself  after  a
       <b>callout_reset</b>() call is racy.

   <b>Avoiding</b> <b>Race</b> <b>Conditions</b>
       The  callout  subsystem  invokes  callout  functions  from  its own thread context.  Without some kind of
       synchronization, it is possible that a callout function will be invoked concurrently with an  attempt  to
       stop  or reset the callout by another thread.  In particular, since callout functions typically acquire a
       lock as their first action, the callout function may have already been invoked, but  is  blocked  waiting
       for that lock at the time that another thread tries to reset or stop the callout.

       There  are  three  main  techniques for addressing these synchronization concerns.  The first approach is
       preferred as it is the simplest:

             1.   Callouts  can  be  associated  with  a  specific   lock   when   they   are   initialized   by
                  <b>callout_init_mtx</b>(),  <b>callout_init_rm</b>(),  or  <b>callout_init_rw</b>().   When a callout is associated
                  with a lock, the callout subsystem acquires the lock before the callout function  is  invoked.
                  This  allows the callout subsystem to transparently handle races between callout cancellation,
                  scheduling, and execution.  Note that the associated lock  must  be  acquired  before  calling
                  <b>callout_stop</b>()  or  one of the <b>callout_reset</b>() or <b>callout_schedule</b>() functions to provide this
                  safety.

                  A callout initialized via <b>callout_init</b>() with <u>mpsafe</u> set to zero is implicitly associated with
                  the <u>Giant</u> mutex.  If <u>Giant</u> is held when cancelling or rescheduling the callout, then  its  use
                  will prevent races with the callout function.

             2.   The  return  value from <b>callout_stop</b>() (or the <b>callout_reset</b>() and <b>callout_schedule</b>() function
                  families) indicates whether or not the callout was removed.  If it is known that  the  callout
                  was  set and the callout function has not yet executed, then a return value of FALSE indicates
                  that the callout function is about to be called.  For example:

                        if (sc-&gt;sc_flags &amp; SCFLG_CALLOUT_RUNNING) {
                                if (callout_stop(&amp;sc-&gt;sc_callout)) {
                                        sc-&gt;sc_flags &amp;= ~SCFLG_CALLOUT_RUNNING;
                                        /* successfully stopped */
                                } else {
                                        /*
                                         * callout has expired and callout
                                         * function is about to be executed
                                         */
                                }
                        }

             3.   The <b>callout_pending</b>(), <b>callout_active</b>() and <b>callout_deactivate</b>() macros can be  used  together
                  to  work  around  the race conditions.  When a callout's timeout is set, the callout subsystem
                  marks the callout as both <u>active</u> and <u>pending</u>.  When the  timeout  time  arrives,  the  callout
                  subsystem  begins  processing the callout by first clearing the <u>pending</u> flag.  It then invokes
                  the callout function without changing the <u>active</u> flag, and does not clear the <u>active</u> flag even
                  after the callout function  returns.   The  mechanism  described  here  requires  the  callout
                  function  itself  to  clear  the  <u>active</u>  flag  using  the  <b>callout_deactivate</b>()  macro.   The
                  <b>callout_stop</b>() and <b>callout_drain</b>() functions always clear both the <u>active</u>  and  <u>pending</u>  flags
                  before returning.

                  The  callout  function  should  first  check  the  <u>pending</u>  flag  and return without action if
                  <b>callout_pending</b>() returns TRUE.   This  indicates  that  the  callout  was  rescheduled  using
                  <b>callout_reset</b>()  just  before  the  callout function was invoked.  If <b>callout_active</b>() returns
                  FALSE then the callout function should also return without action.  This  indicates  that  the
                  callout  has  been stopped.  Finally, the callout function should call <b>callout_deactivate</b>() to
                  clear the <u>active</u> flag.  For example:

                        mtx_lock(&amp;sc-&gt;sc_mtx);
                        if (callout_pending(&amp;sc-&gt;sc_callout)) {
                                /* callout was reset */
                                mtx_unlock(&amp;sc-&gt;sc_mtx);
                                return;
                        }
                        if (!callout_active(&amp;sc-&gt;sc_callout)) {
                                /* callout was stopped */
                                mtx_unlock(&amp;sc-&gt;sc_mtx);
                                return;
                        }
                        callout_deactivate(&amp;sc-&gt;sc_callout);
                        /* rest of callout function */

                  Together with appropriate synchronization, such as the mutex used above, this approach permits
                  the <b>callout_stop</b>() and <b>callout_reset</b>() functions to be used at any time  without  races.   For
                  example:

                        mtx_lock(&amp;sc-&gt;sc_mtx);
                        callout_stop(&amp;sc-&gt;sc_callout);
                        /* The callout is effectively stopped now. */

                  If  the  callout  is still pending then these functions operate normally, but if processing of
                  the callout has already begun then the tests in  the  callout  function  cause  it  to  return
                  without  further  action.  Synchronization between the callout function and other code ensures
                  that stopping or resetting the callout will never be attempted while the callout  function  is
                  past the <b>callout_deactivate</b>() call.

                  The  above  technique  additionally  ensures  that the <u>active</u> flag always reflects whether the
                  callout is effectively enabled or disabled.   If  <b>callout_active</b>()  returns  false,  then  the
                  callout is effectively disabled, since even if the callout subsystem is actually just about to
                  invoke the callout function, the callout function will return without action.

       There  is  one  final race condition that must be considered when a callout is being stopped for the last
       time.  In this case it may not be safe to let the callout function itself detect  that  the  callout  was
       stopped,  since  it  may  need  to  access data objects that have already been destroyed or recycled.  To
       ensure that the callout is completely finished, a call to <b>callout_drain</b>() should be used.  In particular,
       a callout should always be drained prior to destroying its associated lock or releasing the  storage  for
       the callout structure.

</pre><h4><b>LEGACY</b> <b>API</b></h4><pre>
       <b>The</b>  <b>functions</b>  <b>below</b> <b>are</b> <b>a</b> <b>legacy</b> <b>API</b> <b>that</b> <b>will</b> <b>be</b> <b>removed</b> <b>in</b> <b>a</b> <b>future</b> <b>release.</b>  <b>New</b> <b>code</b> <b>should</b> <b>not</b> <b>use</b>
       <b>these</b> <b>routines.</b>

       The function <b>timeout</b>() schedules a call to the function given by the argument <u>func</u> to  take  place  after
       <u>ticks</u>/hz  seconds.  Non-positive values of <u>ticks</u> are silently converted to the value ‘1’.  <u>func</u> should be
       a pointer to a function that takes a <u>void</u> <u>*</u> argument.  Upon invocation, <u>func</u> will receive <u>arg</u> as its only
       argument.  The return value from <b>timeout</b>() is a <u>struct</u> <u>callout_handle</u> which can be  used  in  conjunction
       with the <b>untimeout</b>() function to request that a scheduled timeout be canceled.

       The  function  <b>callout_handle_init</b>()  can  be used to initialize a handle to a state which will cause any
       calls to <b>untimeout</b>() with that handle to return with no side effects.

       Assigning a callout handle the value  of  <b>CALLOUT_HANDLE_INITIALIZER</b>()  performs  the  same  function  as
       <b>callout_handle_init</b>() and is provided for use on statically declared or global callout handles.

       The  function  <b>untimeout</b>() cancels the timeout associated with <u>handle</u> using the <u>func</u> and <u>arg</u> arguments to
       validate the handle.  If the handle does not correspond to a timeout with the function  <u>func</u>  taking  the
       argument  <u>arg</u>  no  action  is  taken.   <u>handle</u>  must  be  initialized  by  a  previous call to <b>timeout</b>(),
       <b>callout_handle_init</b>(), or assigned the value of <b>CALLOUT_HANDLE_INITIALIZER</b>(<u>&amp;handle</u>) before  being  passed
       to <b>untimeout</b>().  The behavior of calling <b>untimeout</b>() with an uninitialized handle is undefined.

       As  handles  are  recycled  by  the  system,  it  is  possible (although unlikely) that a handle from one
       invocation of <b>timeout</b>() may match the handle of another invocation of <b>timeout</b>() if both  calls  used  the
       same  function pointer and argument, and the first timeout is expired or canceled before the second call.
       The timeout facility offers <a href="../man1/O.1.html">O</a>(1) running time for <b>timeout</b>() and <b>untimeout</b>().  Timeouts are executed  from
       <b>softclock</b>() with the <u>Giant</u> lock held.  Thus they are protected from re-entrancy.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>callout_active</b>() macro returns the state of a callout's <u>active</u> flag.

       The <b>callout_pending</b>() macro returns the state of a callout's <u>pending</u> flag.

       The  <b>callout_reset</b>()  and  <b>callout_schedule</b>()  function families return a value of one if the callout was
       pending before the new function invocation was scheduled.

       The <b>callout_stop</b>() and <b>callout_drain</b>() functions return a value of one if the callout was  still  pending
       when  it  was  called, a zero if the callout could not be stopped and a negative one is it was either not
       running or has already completed.  The <b>timeout</b>() function returns a <u>struct</u>  <u>callout_handle</u>  that  can  be
       passed to <b>untimeout</b>().

</pre><h4><b>HISTORY</b></h4><pre>
       The current timeout and untimeout routines are based on the work of Adam M. Costello and George Varghese,
       published  in  a  technical report entitled <u>Redesigning</u> <u>the</u> <u>BSD</u> <u>Callout</u> <u>and</u> <u>Timer</u> <u>Facilities</u> and modified
       slightly for inclusion in FreeBSD by Justin T. Gibbs.  The original work on the data structures  used  in
       this implementation was published by G. Varghese and A. Lauck in the paper <u>Hashed</u> <u>and</u> <u>Hierarchical</u> <u>Timing</u>
       <u>Wheels:</u>  <u>Data</u>  <u>Structures</u>  <u>for</u> <u>the</u> <u>Efficient</u> <u>Implementation</u> <u>of</u> <u>a</u> <u>Timer</u> <u>Facility</u> in the <u>Proceedings</u> <u>of</u> <u>the</u>
       <u>11th</u> <u>ACM</u> <u>Annual</u> <u>Symposium</u> <u>on</u> <u>Operating</u> <u>Systems</u> <u>Principles</u>.  The current implementation replaces the  long
       standing  BSD linked list callout mechanism which offered O(n) insertion and removal running time but did
       not generate or require handles for untimeout operations.

Debian                                          December 10, 2019                                     <u><a href="../man9/TIMEOUT.9.html">TIMEOUT</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>