<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEFINE_IFUNC — define a kernel function with an implementation selected at run-time</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DEFINE_IFUNC — define a kernel function with an implementation selected at run-time

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;machine/ifunc.h&gt;</b>

       <b>DEFINE_IFUNC</b>(<u>qual</u>, <u>ret_type</u>, <u>name</u>, <u>args</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       ifuncs  are  a  linker  feature  which  allows the programmer to define functions whose implementation is
       selected at boot-time or module load-time.  The <b>DEFINE_IFUNC</b> macro can be used to define an  ifunc.   The
       selection  is  performed by a resolver function, which returns a pointer to the selected function.  ifunc
       resolvers are invoked very early during the machine-dependent initialization routine, or at load time for
       dynamically loaded modules.  Resolution must occur before the first call to an ifunc.   ifunc  resolution
       is  performed  after  CPU features are enumerated and after the kernel's environment is initialized.  The
       typical use-case for an ifunc is a routine whose behavior depends on optional CPU features.  For example,
       newer generations of a given CPU architecture may provide an instruction to optimize a common  operation.
       To  avoid  the overhead of testing for the CPU feature each time the operation is performed, an ifunc can
       be used to provide two implementations  for  the  operation:  one  targeting  platforms  with  the  extra
       instruction, and one for older platforms.

       Because  <b>DEFINE_IFUNC</b>  is  a  macro  that  defines a dynamically typed function, its usage looks somewhat
       unusual.  The <u>qual</u> parameter is a list of zero or more C function qualifiers to be applied to the  ifunc.
       This  parameter  is  typically  empty or the static qualifier.  <u>ret_type</u> is the return type of the ifunc.
       <u>name</u> is the name of the ifunc.  <u>args</u> is a parenthesized, comma-separated list of the parameter  types  of
       the function, as they would appear in a C function declaration.

       The  <b>DEFINE_IFUNC</b>  usage  must  be  followed  by  the resolver function body.  The resolver must return a
       function with return type <u>ret_type</u> and parameter types <u>args</u>.  The resolver function is defined  with  the
       ‘resolver’  gcc-style  function attribute, causing the corresponding <u><a href="../man5/elf.5.html">elf</a></u>(5) function symbol to be of type
       STT_GNU_IFUNC instead of STT_FUNC.  The  kernel  linker  invokes  the  resolver  to  process  relocations
       targeting ifunc calls and PLT entries referencing such symbols.

</pre><h4><b>EXAMPLES</b></h4><pre>
       ifunc  resolvers  are  executed early during boot, before most kernel facilities are available.  They are
       effectively limited to checking CPU feature flags and tunables.

       static size_t
       fast_strlen(const char *s __unused)
       {
               size_t len;

               /* Fast, but may not be correct in all cases. */
               __asm("movq $42,%0\n" : "=r" (len));
               return (len);
       }

       static size_t
       slow_strlen(const char *s)
       {
               const char *t;

               for (t = s; *t != '\0'; t++);
               return (t - s);
       }

       DEFINE_IFUNC(, size_t, strlen, (const char *))
       {
               int enabled;

               enabled = 1;
               TUNABLE_INT_FETCH("debug.use_fast_strlen", &amp;enabled);
               if (enabled &amp;&amp; (cpu_features &amp; CPUID_FAST_STRLEN) != 0)
                       return (fast_strlen);
               else
                       return (slow_strlen);
       }

       This defines a <b>strlen</b>() function with an optimized implementation for CPUs that advertise support.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man5/elf.5.html">elf</a></u>(5)

</pre><h4><b>NOTES</b></h4><pre>
       ifuncs are not supported on all architectures.  They require both toolchain  support,  to  emit  function
       symbols  of type STT_GNU_IFUNC, and kernel linker support to invoke ifunc resolvers during boot or during
       module load.

Debian                                            May 18, 2019                                   <u><a href="../man9/DEFINE_IFUNC.9.html">DEFINE_IFUNC</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>