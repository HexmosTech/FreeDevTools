<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>crypto — API for cryptographic services in the kernel</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       crypto — API for cryptographic services in the kernel

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;opencrypto/cryptodev.h&gt;</b>

       <u>int32_t</u>
       <b>crypto_get_driverid</b>(<u>device_t</u> <u>dev</u>, <u>size_t</u> <u>session_size</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>crypto_register</b>(<u>uint32_t</u> <u>driverid</u>, <u>int</u> <u>alg</u>, <u>uint16_t</u> <u>maxoplen</u>, <u>uint32_t</u> <u>flags</u>);

       <u>int</u>
       <b>crypto_kregister</b>(<u>uint32_t</u> <u>driverid</u>, <u>int</u> <u>kalg</u>, <u>uint32_t</u> <u>flags</u>);

       <u>int</u>
       <b>crypto_unregister</b>(<u>uint32_t</u> <u>driverid</u>, <u>int</u> <u>alg</u>);

       <u>int</u>
       <b>crypto_unregister_all</b>(<u>uint32_t</u> <u>driverid</u>);

       <u>void</u>
       <b>crypto_done</b>(<u>struct</u> <u>cryptop</u> <u>*crp</u>);

       <u>void</u>
       <b>crypto_kdone</b>(<u>struct</u> <u>cryptkop</u> <u>*krp</u>);

       <u>int</u>
       <b>crypto_find_driver</b>(<u>const</u> <u>char</u> <u>*match</u>);

       <u>int</u>
       <b>crypto_newsession</b>(<u>crypto_session_t</u> <u>*cses</u>, <u>struct</u> <u>cryptoini</u> <u>*cri</u>, <u>int</u> <u>crid</u>);

       <u>int</u>
       <b>crypto_freesession</b>(<u>crypto_session_t</u> <u>cses</u>);

       <u>int</u>
       <b>crypto_dispatch</b>(<u>struct</u> <u>cryptop</u> <u>*crp</u>);

       <u>int</u>
       <b>crypto_kdispatch</b>(<u>struct</u> <u>cryptkop</u> <u>*krp</u>);

       <u>int</u>
       <b>crypto_unblock</b>(<u>uint32_t</u> <u>driverid</u>, <u>int</u> <u>what</u>);

       <u>struct</u> <u>cryptop</u> <u>*</u>
       <b>crypto_getreq</b>(<u>int</u> <u>num</u>);

       <u>void</u>
       <b>crypto_freereq</b>(<u>struct</u> <u>cryptop</u> <u>*crp</u>);

       #define CRYPTO_SYMQ     0x1
       #define CRYPTO_ASYMQ    0x2

       #define EALG_MAX_BLOCK_LEN      16

       struct cryptoini {
               int                cri_alg;
               int                cri_klen;
               int                cri_mlen;
               caddr_t            cri_key;
               uint8_t            cri_iv[EALG_MAX_BLOCK_LEN];
               struct cryptoini  *cri_next;
       };

       struct cryptodesc {
               int                crd_skip;
               int                crd_len;
               int                crd_inject;
               int                crd_flags;
               struct cryptoini   CRD_INI;
       #define crd_iv          CRD_INI.cri_iv
       #define crd_key         CRD_INI.cri_key
       #define crd_alg         CRD_INI.cri_alg
       #define crd_klen        CRD_INI.cri_klen
               struct cryptodesc *crd_next;
       };

       struct cryptop {
               TAILQ_ENTRY(cryptop) crp_next;
               crypto_session_t   crp_session;
               int                crp_ilen;
               int                crp_olen;
               int                crp_etype;
               int                crp_flags;
               caddr_t            crp_buf;
               caddr_t            crp_opaque;
               struct cryptodesc *crp_desc;
               int              (*crp_callback) (struct cryptop *);
               caddr_t            crp_mac;
       };

       struct crparam {
               caddr_t         crp_p;
               u_int           crp_nbits;
       };

       #define CRK_MAXPARAM    8

       struct cryptkop {
               TAILQ_ENTRY(cryptkop) krp_next;
               u_int              krp_op;         /* ie. CRK_MOD_EXP or other */
               u_int              krp_status;     /* return status */
               u_short            krp_iparams;    /* # of input parameters */
               u_short            krp_oparams;    /* # of output parameters */
               uint32_t           krp_hid;
               struct crparam     krp_param[CRK_MAXPARAM];
               int               (*krp_callback)(struct cryptkop *);
       };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>crypto</b>  is  a  framework for drivers of cryptographic hardware to register with the kernel so “consumers”
       (other kernel subsystems, and users through the <u>/dev/crypto</u> device) are able to make use of it.   Drivers
       register  with  the  framework  the  algorithms  they  support,  and provide entry points (functions) the
       framework may call to establish, use, and tear down sessions.  Sessions are used to  cache  cryptographic
       information  in  a particular driver (or associated hardware), so initialization is not needed with every
       request.  Consumers of cryptographic services pass a set of descriptors that instruct the framework  (and
       the  drivers  registered  with  it)  of  the operations that should be applied on the data (more than one
       cryptographic operation can be requested).

       Keying operations are  supported  as  well.   Unlike  the  symmetric  operators  described  above,  these
       sessionless commands perform mathematical operations using input and output parameters.

       Since  the  consumers may not be associated with a process, drivers may not <u><a href="../man9/sleep.9.html">sleep</a></u>(9).  The same holds for
       the framework.  Thus, a callback mechanism is used to notify a consumer that a request has been completed
       (the callback is specified by the consumer on a per-request basis).   The  callback  is  invoked  by  the
       framework  whether the request was successfully completed or not.  An error indication is provided in the
       latter case.  A specific error code, EAGAIN, is used to indicate that a session handle  has  changed  and
       that  the  request may be re-submitted immediately with the new session.  Errors are only returned to the
       invoking function if not enough information to call the callback is available (meaning, there was a fatal
       error in verifying the arguments).  For session initialization and  teardown  no  callback  mechanism  is
       used.

       The  <b>crypto_find_driver</b>() returns the driver id of the device whose name matches <u>match</u>.  <u>match</u> can either
       be the exact name of a device including the unit or the driver name without a unit.  In the latter  case,
       the  id  of  the first device with the matching driver name is returned.  If no matching device is found,
       the value -1 is returned.

       The <b>crypto_newsession</b>() routine is called by consumers of cryptographic services (such  as  the  <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4)
       stack)  that  wish to establish a new session with the framework.  The <u>cri</u> argument points to a <u>cryptoini</u>
       structure containing all the necessary information for the driver to establish  the  session.   The  <u>crid</u>
       argument  is  either  a specific driver id or a bitmask of flags.  The flags are CRYPTOCAP_F_HARDWARE, to
       select hardware devices, or CRYPTOCAP_F_SOFTWARE, to select software devices.   If  both  are  specified,
       hardware  devices  are preferred over software devices.  On success, the opaque session handle of the new
       session will be stored in <u>*cses</u>.  The <u>cryptoini</u> structure pointed to by <u>cri</u> contains these fields:

       <u>cri_alg</u>   An algorithm identifier.  Currently supported algorithms are:

                 CRYPTO_AES_128_NIST_GMAC
                 CRYPTO_AES_192_NIST_GMAC
                 CRYPTO_AES_256_NIST_GMAC
                 CRYPTO_AES_CBC
                 CRYPTO_AES_CCM_16
                 CRYPTO_AES_CCM_CBC_MAC
                 CRYPTO_AES_ICM
                 CRYPTO_AES_NIST_GCM_16
                 CRYPTO_AES_NIST_GMAC
                 CRYPTO_AES_XTS
                 CRYPTO_ARC4
                 CRYPTO_BLAKE2B
                 CRYPTO_BLAKE2S
                 CRYPTO_BLF_CBC
                 CRYPTO_CAMELLIA_CBC
                 CRYPTO_CAST_CBC
                 CRYPTO_CHACHA20
                 CRYPTO_DEFLATE_COMP
                 CRYPTO_DES_CBC
                 CRYPTO_3DES_CBC
                 CRYPTO_MD5
                 CRYPTO_MD5_HMAC
                 CRYPTO_MD5_KPDK
                 CRYPTO_NULL_HMAC
                 CRYPTO_NULL_CBC
                 CRYPTO_POLY1305
                 CRYPTO_RIPEMD160
                 CRYPTO_RIPEMD160_HMAC
                 CRYPTO_SHA1
                 CRYPTO_SHA1_HMAC
                 CRYPTO_SHA1_KPDK
                 CRYPTO_SHA2_224
                 CRYPTO_SHA2_224_HMAC
                 CRYPTO_SHA2_256
                 CRYPTO_SHA2_256_HMAC
                 CRYPTO_SHA2_384
                 CRYPTO_SHA2_384_HMAC
                 CRYPTO_SHA2_512
                 CRYPTO_SHA2_512_HMAC
                 CRYPTO_SKIPJACK_CBC

       <u>cri_klen</u>  For variable-size key algorithms, the length of the key in bits.

       <u>cri_mlen</u>  If non-zero, truncate the calculated hash to this many bytes.

       <u>cri_key</u>   The key to be used.

       <u>cri_iv</u>    An explicit initialization vector if it does not prefix the data.  This field is ignored during
                 initialization (<b>crypto_newsession</b>).  If no IV is explicitly passed (see below  on  details),  a
                 random IV is used by the device driver processing the request.

       <u>cri_next</u>  Pointer  to  another  <u>cryptoini</u>  structure.  This is used to establish dual-algorithm sessions,
                 such as combining a cipher with a MAC.

       The <u>cryptoini</u> structure and its contents will not be modified or  referenced  by  the  framework  or  any
       cryptographic drivers.  The memory associated with <u>cri</u> can be released once <b>crypto_newsession</b>() returns.

       <b>crypto_freesession</b>()  is  called  with  the  session  handle  returned by <b>crypto_newsession</b>() to free the
       session.

       <b>crypto_dispatch</b>() is called to process a request.  The various fields in the <u>cryptop</u> structure are:

       <u>crp_session</u>   The session handle.

       <u>crp_ilen</u>      The total length in bytes of the buffer to be processed.

       <u>crp_olen</u>      On return, contains the total length of the result.  For symmetric crypto operations,  this
                     will be the same as the input length.  This will be used if the framework needs to allocate
                     a new buffer for the result (or for re-formatting the input).

       <u>crp_callback</u>  Callback  routine  invoked  when  a  request  is completed via <b>crypto_done</b>().  The callback
                     routine should  inspect  the  <u>crp_etype</u>  to  determine  if  the  request  was  successfully
                     completed.

       <u>crp_etype</u>     The  error  type,  if  any errors were encountered, or zero if the request was successfully
                     processed.  If the EAGAIN error code is returned, the session handle has changed  (and  has
                     been recorded in the <u>crp_session</u> field).  The consumer should record the new session handle
                     and  use  it  in  all  subsequent  requests.  In this case, the request may be re-submitted
                     immediately.  This mechanism is used by the framework to perform session migration (move  a
                     session  from  one  driver  to  another,  because  of  availability,  performance, or other
                     considerations).

                     This field is only valid in the context of the callback routine specified by  <u>crp_callback</u>.
                     Errors  are returned to the invoker of <b>crypto_process</b>() only when enough information is not
                     present to call the callback routine (i.e., if the pointer passed is NULL or if no callback
                     routine was specified).

       <u>crp_flags</u>     A bitmask of flags associated with this request.  Currently defined flags are:

                     CRYPTO_F_IMBUF     The buffer is an mbuf chain pointed to by <u>crp_mbuf</u>.

                     CRYPTO_F_IOV       The buffer is a <u>uio</u> structure pointed to by <u>crp_uio</u>.

                     CRYPTO_F_BATCH     Batch operation if possible.

                     CRYPTO_F_CBIMM     Do callback immediately instead of doing  it  from  a  dedicated  kernel
                                        thread.

                     CRYPTO_F_DONE      Operation completed.

                     CRYPTO_F_CBIFSYNC  Do  callback  immediately  if  operation is synchronous (that the driver
                                        specified the CRYPTOCAP_F_SYNC flag).

                     CRYPTO_F_ASYNC     Try to do the crypto operation in a pool of workers if the operation  is
                                        synchronous  (that  is,  if  the  driver  specified the CRYPTOCAP_F_SYNC
                                        flag).  It aims to speed up processing by dispatching crypto  operations
                                        on different processors.

                     CRYPTO_F_ASYNC_KEEPORDER
                                        Dispatch  callbacks in the same order they are posted.  Only relevant if
                                        the CRYPTO_F_ASYNC flag is set and if the operation is synchronous.

       <u>crp_buf</u>       Data buffer unless CRYPTO_F_IMBUF or CRYPTO_F_IOV is set in <u>crp_flags</u>.  The length in bytes
                     is set in <u>crp_ilen</u>.

       <u>crp_mbuf</u>      Data buffer mbuf chain when CRYPTO_F_IMBUF is set in <u>crp_flags</u>.

       <u>crp_uio</u>       <u>struct</u> <u>uio</u> data buffer when CRYPTO_F_IOV is set in <u>crp_flags</u>.

       <u>crp_opaque</u>    Cookie passed through the crypto framework untouched.  It  is  intended  for  the  invoking
                     application's use.

       <u>crp_desc</u>      A  linked  list  of  descriptors.   Each descriptor provides information about what type of
                     cryptographic operation should be done on the input buffer.  The various fields are:

                     <u>crd_iv</u>      When the flag CRD_F_IV_EXPLICIT is set, this field contains the IV.

                     <u>crd_key</u>     When the CRD_F_KEY_EXPLICIT flag is set, the <u>crd_key</u> points to  a  buffer  with
                                 encryption or authentication key.

                     <u>crd_alg</u>     An algorithm to use.  Must be the same as the one given at newsession time.

                     <u>crd_klen</u>    The <u>crd_key</u> key length.

                     <u>crd_skip</u>    The offset in the input buffer where processing should start.

                     <u>crd_len</u>     How many bytes, after <u>crd_skip</u>, should be processed.

                     <u>crd_inject</u>  The  <u>crd_inject</u>  field  specifies  an offset in bytes from the beginning of the
                                 buffer.  For encryption algorithms, this may be where the IV will  be  inserted
                                 when  encrypting  or  where  the  IV  may  be  found for decryption (subject to
                                 <u>crd_flags</u>).  For MAC algorithms, this is where the result  of  the  keyed  hash
                                 will be inserted.

                     <u>crd_flags</u>   The following flags are defined:

                                 CRD_F_ENCRYPT
                                      For  encryption  algorithms,  this  bit is set when encryption is required
                                      (when not set, decryption is performed).

                                 CRD_F_IV_PRESENT
                                      For encryption, if this bit is not set the IV used to encrypt  the  packet
                                      will  be  written at the location pointed to by <u>crd_inject</u>.  The IV length
                                      is assumed to be equal to the blocksize of the encryption algorithm.   For
                                      encryption,  if  this  bit  is set, nothing is done.  For decryption, this
                                      flag has no meaning.  Applications that do special “IV cooking”,  such  as
                                      the  half-IV  mode  in <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4), can use this flag to indicate that the IV
                                      should not be written on the packet.   This  flag  is  typically  used  in
                                      conjunction with the CRD_F_IV_EXPLICIT flag.

                                 CRD_F_IV_EXPLICIT
                                      This  bit is set when the IV is explicitly provided by the consumer in the
                                      <u>crd_iv</u> field.  Otherwise, for encryption operations the IV is provided for
                                      by the driver used  to  perform  the  operation,  whereas  for  decryption
                                      operations the offset of the IV is provided by the <u>crd_inject</u> field.  This
                                      flag  is  typically  used  when  the  IV is calculated “on the fly” by the
                                      consumer, and does not precede the data.

                                 CRD_F_KEY_EXPLICIT
                                      For encryption and authentication (MAC) algorithms, this bit is  set  when
                                      the  key  is  explicitly provided by the consumer in the <u>crd_key</u> field for
                                      the given operation.  Otherwise, the key is taken at newsession time  from
                                      the  <u>cri_key</u>  field.  As calculating the key schedule may take a while, it
                                      is recommended that often used keys are given their own session.

                                 CRD_F_COMP
                                      For compression algorithms, this bit is set when compression  is  required
                                      (when not set, decompression is performed).

                     <u>CRD_INI</u>     This  <u>cryptoini</u>  structure  will not be modified by the framework or the device
                                 drivers.  Since this  information  accompanies  every  cryptographic  operation
                                 request,  drivers  may  re-initialize  state  on-demand (typically an expensive
                                 operation).  Furthermore, the cryptographic framework may re-route requests  as
                                 a result of full queues or hardware failure, as described above.

                     <u>crd_next</u>    Point  to  the next descriptor.  Linked operations are useful in protocols such
                                 as <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4), where multiple cryptographic transforms may be applied on the same
                                 block of data.

       <b>crypto_getreq</b>() allocates a <u>cryptop</u> structure with a linked list of <u>num</u> <u>cryptodesc</u> structures.

       <b>crypto_freereq</b>() deallocates a structure <u>cryptop</u> and any <u>cryptodesc</u> structures linked to it.   Note  that
       it  is the responsibility of the callback routine to do the necessary cleanups associated with the opaque
       field in the <u>cryptop</u> structure.

       <b>crypto_kdispatch</b>() is called to perform a keying operation.  The various fields in the <u>cryptkop</u> structure
       are:

       <u>krp_op</u>        Operation code, such as CRK_MOD_EXP.

       <u>krp_status</u>    Return code.  This <u>errno</u>-style variable indicates whether lower level reasons for operation
                     failure.

       <u>krp_iparams</u>   Number of input parameters to the specified operation.  Note  that  each  operation  has  a
                     (typically hardwired) number of such parameters.

       <u>krp_oparams</u>   Number  of  output parameters from the specified operation.  Note that each operation has a
                     (typically hardwired) number of such parameters.

       <u>krp_kvp</u>       An array of kernel memory blocks containing the parameters.

       <u>krp_hid</u>       Identifier specifying which low-level driver is being used.

       <u>krp_callback</u>  Callback called on completion of a keying operation.

</pre><h4><b>DRIVER-SIDE</b> <b>API</b></h4><pre>
       The   <b>crypto_get_driverid</b>(),    <b>crypto_get_driver_session</b>(),    <b>crypto_register</b>(),    <b>crypto_kregister</b>(),
       <b>crypto_unregister</b>(),  <b>crypto_unblock</b>(),  and  <b>crypto_done</b>()  routines  are  used  by drivers that provide
       support for cryptographic  primitives  to  register  and  unregister  with  the  kernel  crypto  services
       framework.

       Drivers  must first use the <b>crypto_get_driverid</b>() function to acquire a driver identifier, specifying the
       <u>flags</u> as an argument.  One of  CRYPTOCAP_F_SOFTWARE  or  CRYPTOCAP_F_HARDWARE  must  be  specified.   The
       CRYPTOCAP_F_SYNC may also be specified, and should be specified if the driver does all of it's operations
       synchronously.   Drivers  must  pass  the  size  of  their  session structure as the second argument.  An
       appropriately sized memory will be allocated by  the  framework,  zeroed,  and  passed  to  the  driver's
       <b>newsession</b>() method.

       For each algorithm the driver supports, it must then call <b>crypto_register</b>().  The first two arguments are
       the  driver  and  algorithm  identifiers.   The  next two arguments specify the largest possible operator
       length (in bits, important for public key operations) and flags for this algorithm.

       <b>crypto_unregister</b>() is called by drivers that wish  to  withdraw  support  for  an  algorithm.   The  two
       arguments  are  the driver and algorithm identifiers, respectively.  Typically, drivers for PCMCIA crypto
       cards that are being ejected will  invoke  this  routine  for  all  algorithms  supported  by  the  card.
       <b>crypto_unregister_all</b>()  will  unregister  all  algorithms  registered by a driver and the driver will be
       disabled (no new sessions will be allocated on that driver, and any existing sessions will be migrated to
       other drivers).  The same will be done if all algorithms associated with a driver are unregistered one by
       one.  After a call to <b>crypto_unregister_all</b>() there will be  no  threads  in  either  the  newsession  or
       freesession function of the driver.

       The calling convention for the driver-supplied routines are:

       <u>int</u> (<b>*newsession</b>)(<u>device_t</u>, <u>crypto_session_t</u>, <u>struct</u> <u>cryptoini</u> <u>*</u>);
       <u>void</u> (<b>*freesession</b>)(<u>device_t</u>, <u>crypto_session_t</u>);
       <u>int</u> (<b>*process</b>)(<u>device_t</u>, <u>struct</u> <u>cryptop</u> <u>*</u>, <u>int</u>);
       <u>int</u> (<b>*kprocess</b>)(<u>device_t</u>, <u>struct</u> <u>cryptkop</u> <u>*</u>, <u>int</u>);

       On   invocation,   the   first   argument   to  all  routines  is  the  <u>device_t</u>  that  was  provided  to
       <b>crypto_get_driverid</b>().  The second argument to <b>newsession</b>() is the opaque  session  handle  for  the  new
       session.  The third argument is identical to that of <b>crypto_newsession</b>().

       Drivers  obtain  a  pointer to their session memory by invoking <b>crypto_get_driver_session</b>() on the opaque
       <u>crypto_session_t</u> handle.

       The <b>freesession</b>() routine takes as arguments the opaque data value and the  session  handle.   It  should
       clear  any context associated with the session (clear hardware registers, memory, etc.).  If no resources
       need to be released other than the contents of session  memory,  the  method  is  optional.   The  <b>crypto</b>
       framework  will zero and release the allocated session memory (after running the <b>freesession</b>() method, if
       one exists).

       The <b>process</b>() routine is invoked with a request to perform crypto  processing.   This  routine  must  not
       block or sleep, but should queue the request and return immediately or process the request to completion.
       In  case  of  an  unrecoverable  error, the error indication must be placed in the <u>crp_etype</u> field of the
       <u>cryptop</u> structure.  When the request is completed, or an error is detected, the  <b>process</b>()  routine  must
       invoke <b>crypto_done</b>().  Session migration may be performed, as mentioned previously.

       In  case  of a temporary resource exhaustion, the <b>process</b>() routine may return ERESTART in which case the
       crypto services will requeue the request, mark the driver as “blocked”, and stop submitting requests  for
       processing.   The  driver  is then responsible for notifying the crypto services when it is again able to
       process requests through the <b>crypto_unblock</b>() routine.  This simple flow control mechanism should only be
       used for short-lived resource exhaustion as it causes operations to be queued in the crypto layer.  Doing
       so is preferable to returning an error in such cases  as  it  can  cause  network  protocols  to  degrade
       performance by treating the failure much like a lost packet.

       The <b>kprocess</b>() routine is invoked with a request to perform crypto key processing.  This routine must not
       block,  but  should  queue the request and return immediately.  Upon processing the request, the callback
       routine should be invoked.  In case of an unrecoverable error, the error indication must be placed in the
       <u>krp_status</u> field of the <u>cryptkop</u> structure.  When the request is completed, or an error is detected,  the
       <b>kprocess</b>() routine should invoked <b>crypto_kdone</b>().

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>crypto_register</b>(),  <b>crypto_kregister</b>(),  <b>crypto_unregister</b>(),  <b>crypto_newsession</b>(), <b>crypto_freesession</b>(),
       and <b>crypto_unblock</b>() return 0 on success, or an error code on failure.  <b>crypto_get_driverid</b>()  returns  a
       non-negative value on error, and -1 on failure.  <b>crypto_getreq</b>() returns a pointer to a <u>cryptop</u> structure
       and NULL on failure.  <b>crypto_dispatch</b>() returns EINVAL if its argument or the callback function was NULL,
       and 0 otherwise.  The callback is provided with an error code in case of failure, in the <u>crp_etype</u> field.

</pre><h4><b>FILES</b></h4><pre>
       <u>sys/opencrypto/crypto.c</u>  most of the framework code

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/crypto.4.html">crypto</a></u>(4), <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4), <u><a href="../man7/crypto.7.html">crypto</a></u>(7), <u><a href="../man9/malloc.9.html">malloc</a></u>(9), <u><a href="../man9/sleep.9.html">sleep</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The  cryptographic  framework  first  appeared  in  OpenBSD  2.7  and was written by Angelos D. Keromytis
       &lt;<u><a href="mailto:angelos@openbsd.org">angelos@openbsd.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The framework currently assumes that all the  algorithms  in  a  <b>crypto_newsession</b>()  operation  must  be
       available by the same driver.  If that is not the case, session initialization will fail.

       The  framework  also  needs  a  mechanism  for  determining  which  driver  is best for a specific set of
       algorithms associated with a session.  Some type of benchmarking is in order here.

       Multiple instances of the same algorithm in the same session are not supported.

Debian                                          December 17, 2019                                      <u><a href="../man9/CRYPTO.9.html">CRYPTO</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>