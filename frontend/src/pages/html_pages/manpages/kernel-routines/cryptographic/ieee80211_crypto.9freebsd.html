<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ieee80211_crypto — 802.11 cryptographic support</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ieee80211_crypto — 802.11 cryptographic support

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;net80211/ieee80211_var.h&gt;</b>

       <u>void</u>
       <b>ieee80211_crypto_register</b>(<u>const</u> <u>struct</u> <u>ieee80211_cipher</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_crypto_unregister</b>(<u>const</u> <u>struct</u> <u>ieee80211_cipher</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_crypto_available</b>(<u>int</u> <u>cipher</u>);

       <u>void</u>
       <b>ieee80211_notify_replay_failure</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>,                    <u>const</u> <u>struct</u> <u>ieee80211_frame</u> <u>*</u>,
           <u>const</u> <u>struct</u> <u>ieee80211_key</u> <u>*</u>, <u>uint64_t</u> <u>rsc</u>, <u>int</u> <u>tid</u>);

       <u>void</u>
       <b>ieee80211_notify_michael_failure</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>const</u> <u>struct</u> <u>ieee80211_frame</u> <u>*</u>, <u>u_int</u> <u>keyix</u>);

       <u>int</u>
       <b>ieee80211_crypto_newkey</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>int</u> <u>cipher</u>, <u>int</u> <u>flags</u>, <u>struct</u> <u>ieee80211_key</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_crypto_setkey</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>struct</u> <u>ieee80211_key</u> <u>*</u>);

       <u>int</u>
       <b>ieee80211_crypto_delkey</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>struct</u> <u>ieee80211_key</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_key_update_begin</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_key_update_end</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_crypto_delglobalkeys</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>);

       <u>void</u>
       <b>ieee80211_crypto_reload_keys</b>(<u>struct</u> <u>ieee80211com</u> <u>*</u>);

       <u>struct</u> <u>ieee80211_key</u> <u>*</u>
       <b>ieee80211_crypto_encap</b>(<u>struct</u> <u>ieee80211_node</u> <u>*</u>, <u>struct</u> <u>mbuf</u> <u>*</u>);

       <u>struct</u> <u>ieee80211_key</u> <u>*</u>
       <b>ieee80211_crypto_decap</b>(<u>struct</u> <u>ieee80211_node</u> <u>*</u>, <u>struct</u> <u>mbuf</u> <u>*</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>ieee80211_crypto_demic</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>struct</u> <u>ieee80211_key</u> <u>*</u>, <u>struct</u> <u>mbuf</u> <u>*</u>, <u>int</u> <u>force</u>);

       <u>int</u>
       <b>ieee80211_crypto_enmic</b>(<u>struct</u> <u>ieee80211vap</u> <u>*</u>, <u>struct</u> <u>ieee80211_key</u> <u>*</u>, <u>struct</u> <u>mbuf</u> <u>*</u>, <u>int</u> <u>force</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>net80211</b>  layer  includes  comprehensive  cryptographic  support  for  802.11  protocols.   Software
       implementations  of ciphers required by WPA and 802.11i are provided as well as encap/decap processing of
       802.11 frames.  Software ciphers are written as kernel modules and register with the core crypto support.
       The cryptographic framework supports hardware acceleration of ciphers by drivers with automatic fall-back
       to software implementations when a driver is unable to provide necessary hardware services.

</pre><h4><b>CRYPTO</b> <b>CIPHER</b> <b>MODULES</b></h4><pre>
       <b>net80211</b> cipher modules register their services using <b>ieee80211_crypto_register</b>() and supply  a  template
       that  describes  their operation.  This <u>ieee80211_cipher</u> structure defines protocol-related state such as
       the number of bytes of space in the 802.11 header to reserve/remove during encap/decap and  entry  points
       for setting up keys and doing cryptographic operations.

       Cipher modules can associate private state to each key through the <u>wk_private</u> structure member.  If state
       is setup by the module it will be called before a key is destroyed so it can reclaim resources.

       Crypto  modules  can  notify  the  system  of  two  events.   When  a  packet  replay event is recognized
       <b>ieee80211_notify_replay_failure</b>() can be used to signal the  event.   When  a  TKIP  Michael  failure  is
       detected  <b>ieee80211_notify_michael_failure</b>()  can  be  invoked.   Drivers  may also use these routines to
       signal events detected by the hardware.

</pre><h4><b>CRYPTO</b> <b>KEY</b> <b>MANAGEMENT</b></h4><pre>
       The <b>net80211</b> layer implements a per-vap 4-element “global key table” and a per-station “unicast key”  for
       protocols  such  as  WPA,  802.1x,  and  802.11i.  The global key table is designed to support legacy WEP
       operation and Multicast/Group keys, though some applications also use it  to  implement  WPA  in  station
       mode.   Keys  in  the  global table are identified by a key index in the range 0-3.  Per-station keys are
       identified by the MAC address of the station and are typically used for unicast PTK bindings.

       <b>net80211</b> provides <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) operations for managing both global and per-station keys.   Drivers  typically
       do  not  participate  in  software  key  management;  they  are  involved  only  when  providing hardware
       acceleration of cryptographic operations.

       <b>ieee80211_crypto_newkey</b>() is used to allocate a new <b>net80211</b> key or reconfigure  an  existing  key.   The
       cipher  must  be  specified  along  with  any fixed key index.  The <b>net80211</b> layer will handle allocating
       cipher and driver resources to support the key.

       Once a key is allocated it's contents  can  be  set  using  <b>ieee80211_crypto_setkey</b>()  and  deleted  with
       <b>ieee80211_crypto_delkey</b>() (with any cipher and driver resources reclaimed).

       <b>ieee80211_crypto_delglobalkeys</b>()  is  used  to  reclaim  all  keys  in the global key table for a vap; it
       typically is used only within the <b>net80211</b> layer.

       <b>ieee80211_crypto_reload_keys</b>() handles hardware key state reloading from  software  key  state,  such  as
       required after a suspend/resume cycle.

</pre><h4><b>DRIVER</b> <b>CRYPTO</b> <b>SUPPORT</b></h4><pre>
       Drivers  identify  ciphers  they  have  hardware  support  for  through  the  <u>ic_cryptocaps</u>  field of the
       <u>ieee80211com</u> structure.  If hardware support  is  available  then  a  driver  should  also  fill  in  the
       iv_key_alloc, iv_key_set, and iv_key_delete methods of each <u>ieee80211vap</u> created for use with the device.
       In  addition the methods iv_key_update_begin and iv_key_update_end can be setup to handle synchronization
       requirements for updating hardware key state.

       When <b>net80211</b> allocates a  software  key  and  the  driver  can  accelerate  the  cipher  operations  the
       iv_key_alloc method will be invoked.  Drivers may return a token that is associated with outbound traffic
       (for use in encrypting frames).  Otherwise, e.g. if hardware resources are not available, the driver will
       not  return  a  token  and <b>net80211</b> will arrange to do the work in software and pass frames to the driver
       that are already prepared for transmission.

       For receive, drivers mark frames with the M_WEP mbuf flag to indicate  the  hardware  has  decrypted  the
       payload.  If frames have the IEEE80211_FC1_PROTECTED bit marked in their 802.11 header and are not tagged
       with M_WEP then decryption is done in software.  For more complicated scenarios the software key state is
       consulted;  e.g.   to  decide if Michael verification needs to be done in software after the hardware has
       handled TKIP decryption.

       Drivers that manage complicated key data structures, e.g. faulting software  keys  into  a  hardware  key
       cache,   can   safely   manipulate   software   key   state  by  bracketing  their  work  with  calls  to
       <b>ieee80211_key_update_begin</b>() and <b>ieee80211_key_update_end</b>().  These calls also synchronize  hardware  key
       state update when receive traffic is active.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man4/wlan_ccmp.4.html">wlan_ccmp</a></u>(4), <u><a href="../man4/wlan_tkip.4.html">wlan_tkip</a></u>(4), <u><a href="../man4/wlan_wep.4.html">wlan_wep</a></u>(4), <u><a href="../man9/ieee80211.9.html">ieee80211</a></u>(9)

Debian                                           March 29, 2010                              <u><a href="../man9/IEEE80211_CRYPTO.9.html">IEEE80211_CRYPTO</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>