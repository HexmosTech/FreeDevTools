<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sglist,   sglist_alloc,   sglist_append,   sglist_append_bio,   sglist_append_mbuf,   sglist_append_phys,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sglist,   sglist_alloc,   sglist_append,   sglist_append_bio,   sglist_append_mbuf,   sglist_append_phys,
       sglist_append_sglist,   sglist_append_uio,   sglist_append_user,   sglist_append_vmpages,   sglist_build,
       sglist_clone,   sglist_consume_uio,   sglist_count,   sglist_count_vmpages,   sglist_free,   sglist_hold,
       sglist_init,  sglist_join,  sglist_length,  sglist_reset,   sglist_slice,   sglist_split   â€”   manage   a
       scatter/gather list of physical memory addresses

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sglist.h&gt;</b>

       <u>struct</u> <u>sglist</u> <u>*</u>
       <b>sglist_alloc</b>(<u>int</u> <u>nsegs</u>, <u>int</u> <u>mflags</u>);

       <u>int</u>
       <b>sglist_append</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sglist_append_bio</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>struct</u> <u>bio</u> <u>*bp</u>);

       <u>int</u>
       <b>sglist_append_mbuf</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>struct</u> <u>mbuf</u> <u>*m</u>);

       <u>int</u>
       <b>sglist_append_phys</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>vm_paddr_t</u> <u>paddr</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sglist_append_sglist</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>struct</u> <u>sglist</u> <u>*source</u>, <u>size_t</u> <u>offset</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sglist_append_uio</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>struct</u> <u>uio</u> <u>*uio</u>);

       <u>int</u>
       <b>sglist_append_user</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>, <u>struct</u> <u>thread</u> <u>*td</u>);

       <u>int</u>
       <b>sglist_append_vmpages</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>vm_page_t</u> <u>*m</u>, <u>size_t</u> <u>pgoff</u>, <u>size_t</u> <u>len</u>);

       <u>struct</u> <u>sglist</u> <u>*</u>
       <b>sglist_build</b>(<u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>, <u>int</u> <u>mflags</u>);

       <u>struct</u> <u>sglist</u> <u>*</u>
       <b>sglist_clone</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>int</u> <u>mflags</u>);

       <u>int</u>
       <b>sglist_consume_uio</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>struct</u> <u>uio</u> <u>*uio</u>, <u>size_t</u> <u>resid</u>);

       <u>int</u>
       <b>sglist_count</b>(<u>void</u> <u>*buf</u>, <u>size_t</u> <u>len</u>);

       <u>int</u>
       <b>sglist_count_vmpages</b>(<u>vm_page_t</u> <u>*m</u>, <u>size_t</u> <u>pgoff</u>, <u>size_t</u> <u>len</u>);

       <u>void</u>
       <b>sglist_free</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>);

       <u>struct</u> <u>sglist</u> <u>*</u>
       <b>sglist_hold</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>);

       <u>void</u>
       <b>sglist_init</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>, <u>int</u> <u>maxsegs</u>, <u>struct</u> <u>sglist_seg</u> <u>*segs</u>);

       <u>int</u>
       <b>sglist_join</b>(<u>struct</u> <u>sglist</u> <u>*first</u>, <u>struct</u> <u>sglist</u> <u>*second</u>);

       <u>size_t</u>
       <b>sglist_length</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>);

       <u>void</u>
       <b>sglist_reset</b>(<u>struct</u> <u>sglist</u> <u>*sg</u>);

       <u>int</u>
       <b>sglist_slice</b>(<u>struct</u> <u>sglist</u> <u>*original</u>, <u>struct</u> <u>sglist</u> <u>**slice</u>, <u>size_t</u> <u>offset</u>, <u>size_t</u> <u>length</u>, <u>int</u> <u>mflags</u>);

       <u>int</u>
       <b>sglist_split</b>(<u>struct</u> <u>sglist</u> <u>*original</u>, <u>struct</u> <u>sglist</u> <u>**head</u>, <u>size_t</u> <u>length</u>, <u>int</u> <u>mflags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sglist</b>  API manages physical address ranges.  Each list contains one or more elements.  Each element
       contains a starting physical address and a length.  Scatter/gather lists are  read-only  while  they  are
       shared.   If  one wishes to alter an existing scatter/gather list and does not hold the sole reference to
       the list, then one should create a new list instead of modifying the existing list.

       Each scatter/gather list object contains a  reference  count.   New  lists  are  created  with  a  single
       reference.  New references are obtained by calling <b>sglist_hold</b> and are released by calling <b>sglist_free</b>.

   <b>Allocating</b> <b>and</b> <b>Initializing</b> <b>Lists</b>
       Each  <b>sglist</b>  object  consists  of  a header structure and a variable-length array of scatter/gather list
       elements.  The <b>sglist_alloc</b> function allocates a new list that contains a header and <u>nsegs</u> scatter/gather
       list elements.  The <u>mflags</u> argument can be set to either M_NOWAIT or M_WAITOK.

       The <b>sglist_count</b> function returns the number of scatter/gather  list  elements  needed  to  describe  the
       physical  address  ranges  mapped  by  a single kernel virtual address range.  The kernel virtual address
       range starts at <u>buf</u> and is <u>len</u> bytes long.

       The <b>sglist_count_vmpages</b> function returns the number of scatter/gather list elements needed  to  describe
       the  physical address ranges of a buffer backed by an array of virtual memory pages <u>m</u>.  The buffer starts
       at an offset of <u>pgoff</u> bytes relative to the first page and is <u>len</u> bytes long.

       The <b>sglist_build</b> function allocates a new scatter/gather list object that describes the physical  address
       ranges  mapped  by a single kernel virtual address range.  The kernel virtual address range starts at <u>buf</u>
       and is <u>len</u> bytes long.  The <u>mflags</u> argument can be set to either M_NOWAIT or M_WAITOK.

       The <b>sglist_clone</b> function returns a copy of an  existing  scatter/gather  list  object  <u>sg</u>.   The  <u>mflags</u>
       argument  can  be  set  to  either  M_NOWAIT or M_WAITOK.  This can be used to obtain a private copy of a
       scatter/gather list before modifying it.

       The <b>sglist_init</b> function initializes a scatter/gather list header.  The header is pointed to by <u>sg</u> and is
       initialized to manage an array of <u>maxsegs</u> scatter/gather list elements pointed to by <u>segs</u>.  This  can  be
       used  to  initialize a scatter/gather list header whose storage is not provided by <b>sglist_alloc</b>.  In that
       case, the caller should not call <b>sglist_free</b> to release its own reference and is responsible for ensuring
       all other references to the list are dropped before it releases the storage for <u>sg</u> and <u>segs</u>.

   <b>Constructing</b> <b>Scatter/Gather</b> <b>Lists</b>
       The <b>sglist</b> API provides several routines for building a scatter/gather  list  to  describe  one  or  more
       objects.   Specifically,  the <b>sglist_append</b> family of routines can be used to append the physical address
       ranges described by an object to the end of a scatter/gather list.  All of these  routines  return  0  on
       success  or an error on failure.  If a request to append an address range to a scatter/gather list fails,
       the scatter/gather list will remain unchanged.

       The <b>sglist_append</b> function appends the physical address ranges  described  by  a  single  kernel  virtual
       address  range  to the scatter/gather list <u>sg</u>.  The kernel virtual address range starts at <u>buf</u> and is <u>len</u>
       bytes long.

       The <b>sglist_append_bio</b> function appends the physical address ranges described by a single bio  <u>bp</u>  to  the
       scatter/gather list <u>sg</u>.

       The  <b>sglist_append_mbuf</b>  function appends the physical address ranges described by an entire mbuf chain <u>m</u>
       to the scatter/gather list <u>sg</u>.

       The <b>sglist_append_phys</b> function appends a single physical address range to the  scatter/gather  list  <u>sg</u>.
       The physical address range starts at <u>paddr</u> and is <u>len</u> bytes long.

       The  <b>sglist_append_sglist</b>  function  appends physical address ranges described by the scatter/gather list
       <u>source</u> to the scatter/gather list <u>sg</u>.  The physical address ranges start at offset <u>offset</u>  within  <u>source</u>
       and continue for <u>len</u> bytes.

       The  <b>sglist_append_uio</b>  function  appends the physical address ranges described by a <u><a href="../man9/uio.9.html">uio</a></u>(9) object to the
       scatter/gather list <u>sg</u>.  Note that it is the caller's responsibility to ensure that the pages backing the
       I/O request are wired for the lifetime of <u>sg</u>.  Note also that this routine does not modify <u>uio</u>.

       The <b>sglist_append_user</b> function appends the physical address ranges described by a  single  user  virtual
       address  range  to the scatter/gather list <u>sg</u>.  The user virtual address range is relative to the address
       space of the thread <u>td</u>.  It starts at <u>buf</u>  and  is  <u>len</u>  bytes  long.   Note  that  it  is  the  caller's
       responsibility to ensure that the pages backing the user buffer are wired for the lifetime of <u>sg</u>.

       The  <b>sglist_append_vmpages</b> function appends the physical address ranges of a buffer backed by an array of
       virtual memory pages <u>m</u>.  The buffer starts at an offset of <u>pgoff</u> bytes relative to the first page and  is
       <u>len</u> bytes long.

       The  <b>sglist_consume_uio</b>  function  is  a  variation  of <b>sglist_append_uio</b>.  As with <b>sglist_append_uio</b>, it
       appends  the  physical  address  ranges  described  by  <u>uio</u>  to  the  scatter/gather  list  <u>sg</u>.    Unlike
       <b>sglist_append_uio</b>,  however,  <b>sglist_consume_uio</b>  modifies  the I/O request to indicate that the appended
       address ranges have been processed similar to calling <u><a href="../man9/uiomove.9.html">uiomove</a></u>(9).  This routine will only  append  ranges
       that  describe  up  to <u>resid</u> total bytes in length.  If the available segments in the scatter/gather list
       are exhausted before <u>resid</u> bytes are processed, then the <u>uio</u> structure will be  updated  to  reflect  the
       actual number of bytes processed, and <b>sglist_consume_io</b> will return zero to indicate success.  In effect,
       this  function  will perform partial reads or writes.  The caller can compare the <u>uio_resid</u> member of <u>uio</u>
       before and after calling <b>sglist_consume_uio</b> to determine the actual number of bytes processed.

   <b>Manipulating</b> <b>Scatter/Gather</b> <b>Lists</b>
       The <b>sglist_join</b> function appends physical address ranges from the scatter/gather list <u>second</u>  onto  <u>first</u>
       and then resets <u>second</u> to an empty list.  It returns zero on success or an error on failure.

       The  <b>sglist_split</b> function splits an existing scatter/gather list into two lists.  The first <u>length</u> bytes
       described by the list <u>original</u> are moved to a new list <u>*head</u>.  If  <u>original</u>  describes  a  total  address
       range  that is smaller than <u>length</u> bytes, then all of the address ranges will be moved to the new list at
       <u>*head</u> and <u>original</u> will be an empty list.  The caller may  supply  an  existing  scatter/gather  list  in
       <u>*head</u>.   If  so, the list must be empty.  Otherwise, the caller may set <u>*head</u> to NULL in which case a new
       scatter/gather list will be allocated.  In that case, <u>mflags</u> may be set to either M_NOWAIT  or  M_WAITOK.
       Note  that  since  the  <u>original</u>  list  is modified by this call, it must be a private list with no other
       references.  The <b>sglist_split</b> function returns zero on success or an error on failure.

       The <b>sglist_slice</b>  function  generates  a  new  scatter/gather  list  from  a  sub-range  of  an  existing
       scatter/gather list <u>original</u>.  The sub-range to extract is specified by the <u>offset</u> and <u>length</u> parameters.
       The  new  scatter/gather  list  is stored in <u>*slice</u>.  As with <u>head</u> for <b>sglist_join</b>, the caller may either
       provide an empty scatter/gather list, or it may set <u>*slice</u>  to  NULL  in  which  case  <b>sglist_slice</b>  will
       allocate  a  new  list subject to <u>mflags</u>.  Unlike <b>sglist_split</b>, <b>sglist_slice</b> does not modify <u>original</u> and
       does not require it to be a private list.  The <b>sglist_split</b> function returns zero on success or an  error
       on failure.

   <b>Miscellaneous</b> <b>Routines</b>
       The <b>sglist_reset</b> function clears the scatter/gather list <u>sg</u> so that it no longer maps any address ranges.
       This can allow reuse of a single scatter/gather list object for multiple requests.

       The  <b>sglist_length</b>  function  returns  the  total  length of the physical address ranges described by the
       scatter/gather list <u>sg</u>.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>sglist_alloc</b>, <b>sglist_build</b>, and <b>sglist_clone</b> functions return a new scatter/gather list on success or
       NULL on failure.

       The <b>sglist_append</b>  family  of  functions  and  the  <b>sglist_consume_uio</b>,  <b>sglist_join</b>,  <b>sglist_slice</b>,  and
       <b>sglist_split</b> functions return zero on success or an error on failure.

       The <b>sglist_count</b> and <b>sglist_count_vmpages</b> functions return a count of scatter/gather list elements.

       The <b>sglist_length</b> function returns a count of address space described by a scatter/gather list in bytes.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>sglist_append</b> functions return the following errors on failure:

       [EINVAL]           The scatter/gather list has zero segments.

       [EFBIG]            There  are  not  enough  available  segments  in the scatter/gather list to append the
                          specified physical address ranges.

       The <b>sglist_consume_uio</b> function returns the following error on failure:

       [EINVAL]           The scatter/gather list has zero segments.

       The <b>sglist_join</b> function returns the following error on failure:

       [EFBIG]            There are not enough available segments in the scatter/gather list <u>first</u> to append the
                          physical address ranges from <u>second</u>.

       The <b>sglist_slice</b> function returns the following errors on failure:

       [EINVAL]           The <u>original</u> scatter/gather list does not describe enough address space to  cover  the
                          requested sub-range.

       [EINVAL]           The caller-supplied scatter/gather list in <u>*slice</u> is not empty.

       [ENOMEM]           An attempt to allocate a new scatter/gather list with M_NOWAIT set in <u>mflags</u> failed.

       [EFBIG]            There  are not enough available segments in the caller-supplied scatter/gather list in
                          <u>*slice</u> to describe the requested physical address ranges.

       The <b>sglist_split</b> function returns the following errors on failure:

       [EDOOFUS]          The <u>original</u> scatter/gather list has more than one reference.

       [EINVAL]           The caller-supplied scatter/gather list in <u>*head</u> is not empty.

       [ENOMEM]           An attempt to allocate a new scatter/gather list with M_NOWAIT set in <u>mflags</u> failed.

       [EFBIG]            There are not enough available segments in the caller-supplied scatter/gather list  in
                          <u>*head</u> to describe the requested physical address ranges.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/g_bio.9.html">g_bio</a></u>(9), <u><a href="../man9/malloc.9.html">malloc</a></u>(9), <u><a href="../man9/mbuf.9.html">mbuf</a></u>(9), <u><a href="../man9/uio.9.html">uio</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       This API was first introduced in FreeBSD 8.0.

Debian                                            May 16, 2017                                         <u><a href="../man9/SGLIST.9.html">SGLIST</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>