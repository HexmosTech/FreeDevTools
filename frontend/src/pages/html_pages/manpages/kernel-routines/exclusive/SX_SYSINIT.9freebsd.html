<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sx,  sx_init,  sx_init_flags,  sx_destroy,  sx_slock, sx_xlock, sx_slock_sig, sx_xlock_sig, sx_try_slock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sx,  sx_init,  sx_init_flags,  sx_destroy,  sx_slock, sx_xlock, sx_slock_sig, sx_xlock_sig, sx_try_slock,
       sx_try_xlock, sx_sunlock, sx_xunlock,  sx_unlock,  sx_try_upgrade,  sx_downgrade,  sx_sleep,  sx_xholder,
       sx_xlocked, sx_assert, SX_SYSINIT, SX_SYSINIT_FLAGS â€” kernel shared/exclusive lock

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/lock.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sx.h&gt;</b>

       <u>void</u>
       <b>sx_init</b>(<u>struct</u> <u>sx</u> <u>*sx</u>, <u>const</u> <u>char</u> <u>*description</u>);

       <u>void</u>
       <b>sx_init_flags</b>(<u>struct</u> <u>sx</u> <u>*sx</u>, <u>const</u> <u>char</u> <u>*description</u>, <u>int</u> <u>opts</u>);

       <u>void</u>
       <b>sx_destroy</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>void</u>
       <b>sx_slock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>void</u>
       <b>sx_xlock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_slock_sig</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_xlock_sig</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_try_slock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_try_xlock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>void</u>
       <b>sx_sunlock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>void</u>
       <b>sx_xunlock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>void</u>
       <b>sx_unlock</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_try_upgrade</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>void</u>
       <b>sx_downgrade</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_sleep</b>(<u>void</u> <u>*chan</u>, <u>struct</u> <u>sx</u> <u>*sx</u>, <u>int</u> <u>priority</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>timo</u>);

       <u>struct</u> <u>thread</u> <u>*</u>
       <b>sx_xholder</b>(<u>struct</u> <u>sx</u> <u>*sx</u>);

       <u>int</u>
       <b>sx_xlocked</b>(<u>const</u> <u>struct</u> <u>sx</u> <u>*sx</u>);

       <b>options</b> <b>INVARIANTS</b>
       <b>options</b> <b>INVARIANT_SUPPORT</b>

       <u>void</u>
       <b>sx_assert</b>(<u>const</u> <u>struct</u> <u>sx</u> <u>*sx</u>, <u>int</u> <u>what</u>);

       <b>#include</b> <b>&lt;sys/kernel.h&gt;</b>

       <b>SX_SYSINIT</b>(<u>name</u>, <u>struct</u> <u>sx</u> <u>*sx</u>, <u>const</u> <u>char</u> <u>*desc</u>);

       <b>SX_SYSINIT_FLAGS</b>(<u>name</u>, <u>struct</u> <u>sx</u> <u>*sx</u>, <u>const</u> <u>char</u> <u>*desc</u>, <u>int</u> <u>flags</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Shared/exclusive  locks  are  used  to  protect  data that are read far more often than they are written.
       Shared/exclusive locks do not implement priority propagation like  mutexes  and  reader/writer  locks  to
       prevent priority inversions, so shared/exclusive locks should be used prudently.

       Shared/exclusive  locks  are  created  with  either <b>sx_init</b>() or <b>sx_init_flags</b>() where <u>sx</u> is a pointer to
       space for a <u>struct</u> <u>sx</u>, and <u>description</u> is a pointer to a null-terminated character string that  describes
       the  shared/exclusive  lock.   The  <u>opts</u> argument to <b>sx_init_flags</b>() specifies a set of optional flags to
       alter the behavior of <u>sx</u>.  It contains one or more of the following flags:

       SX_NOADAPTIVE  Disable adaptive spinning, rather than sleeping, for lock operations  while  an  exclusive
                      lock  holder  is  executing  on  another CPU.  Adaptive spinning is the default unless the
                      kernel is compiled with <b>options</b> <b>NO_ADAPTIVE_SX</b>.

       SX_DUPOK       Witness should not log messages about duplicate locks being acquired.

       SX_NOWITNESS   Instruct <u><a href="../man4/witness.4.html">witness</a></u>(4) to ignore this lock.

       SX_NOPROFILE   Do not profile this lock.

       SX_RECURSE     Allow threads to recursively acquire exclusive locks for <u>sx</u>.

       SX_QUIET       Do not log any operations for this lock via <u><a href="../man4/ktr.4.html">ktr</a></u>(4).

       SX_NEW         If the kernel has been compiled with <b>options</b> <b>INVARIANTS</b>, <b>sx_init</b>() will assert that the <u>sx</u>
                      has not been initialized multiple times without intervening calls to  <b>sx_destroy</b>()  unless
                      this option is specified.

       Shared/exclusive  locks  are  destroyed  with <b>sx_destroy</b>().  The lock <u>sx</u> must not be locked by any thread
       when it is destroyed.

       Threads acquire and release a shared lock by calling <b>sx_slock</b>(),  <b>sx_slock_sig</b>()  or  <b>sx_try_slock</b>()  and
       <b>sx_sunlock</b>()  or  <b>sx_unlock</b>().   Threads  acquire  and  release  an exclusive lock by calling <b>sx_xlock</b>(),
       <b>sx_xlock_sig</b>() or <b>sx_try_xlock</b>() and <b>sx_xunlock</b>() or <b>sx_unlock</b>().  A thread  can  attempt  to  upgrade  a
       currently  held  shared  lock  to  an  exclusive  lock by calling <b>sx_try_upgrade</b>().  A thread that has an
       exclusive lock can downgrade it to a shared lock by calling <b>sx_downgrade</b>().

       <b>sx_try_slock</b>() and <b>sx_try_xlock</b>()  will  return  0  if  the  shared/exclusive  lock  cannot  be  acquired
       immediately; otherwise the shared/exclusive lock will be acquired and a non-zero value will be returned.

       <b>sx_try_upgrade</b>()  will  return  0 if the shared lock cannot be upgraded to an exclusive lock immediately;
       otherwise the exclusive lock will be acquired and a non-zero value will be returned.

       <b>sx_slock_sig</b>() and <b>sx_xlock_sig</b>() do the same as their normal versions but  performing  an  interruptible
       sleep.   They  return  a  non-zero  value  if the sleep has been interrupted by a signal or an interrupt,
       otherwise 0.

       A thread can atomically release a shared/exclusive lock while waiting for an event by calling <b>sx_sleep</b>().
       For more details on the parameters to this function, see <u><a href="../man9/sleep.9.html">sleep</a></u>(9).

       When compiled with <b>options</b> <b>INVARIANTS</b> and <b>options</b> <b>INVARIANT_SUPPORT</b>, the <b>sx_assert</b>()  function  tests  <u>sx</u>
       for  the  assertions  specified in <u>what</u>, and panics if they are not met.  One of the following assertions
       must be specified:

       SA_LOCKED    Assert that the current thread has either a shared or an  exclusive  lock  on  the  <u>sx</u>  lock
                    pointed to by the first argument.

       SA_SLOCKED   Assert  that  the  current  thread  has a shared lock on the <u>sx</u> lock pointed to by the first
                    argument.

       SA_XLOCKED   Assert that the current thread has an exclusive lock on the <u>sx</u> lock pointed to by the  first
                    argument.

       SA_UNLOCKED  Assert that the current thread has no lock on the <u>sx</u> lock pointed to by the first argument.

       In  addition,  one  of  the  following  optional  assertions  may  be  included with either an SA_LOCKED,
       SA_SLOCKED, or SA_XLOCKED assertion:

       SA_RECURSED     Assert that the current thread has a recursed lock on <u>sx</u>.

       SA_NOTRECURSED  Assert that the current thread does not have a recursed lock on <u>sx</u>.

       <b>sx_xholder</b>() will return a pointer to the thread which currently holds an exclusive lock on  <u>sx</u>.   If  no
       thread holds an exclusive lock on <u>sx</u>, then NULL is returned instead.

       <b>sx_xlocked</b>()  will  return  non-zero  if  the current thread holds the exclusive lock; otherwise, it will
       return zero.

       For ease of programming, <b>sx_unlock</b>() is provided  as  a  macro  frontend  to  the  respective  functions,
       <b>sx_sunlock</b>()  and <b>sx_xunlock</b>().  Algorithms that are aware of what state the lock is in should use either
       of the two specific functions for a minor performance benefit.

       The <b>SX_SYSINIT</b>() macro is used to generate a call to the <b>sx_sysinit</b>() routine at system startup in  order
       to initialize a given <u>sx</u> lock.  The parameters are the same as <b>sx_init</b>() but with an additional argument,
       <u>name</u>,  that  is  used  in generating unique variable names for the related structures associated with the
       lock and the sysinit routine.  The <b>SX_SYSINIT_FLAGS</b>() macro can similarly be used to initialize  a  given
       <u>sx</u> lock using <b>sx_init_flags</b>().

       A  thread  may  not  hold  both  a  shared  lock  and  an exclusive lock on the same lock simultaneously;
       attempting to do so will result in deadlock.

</pre><h4><b>CONTEXT</b></h4><pre>
       A thread may hold a shared or exclusive lock on an <b>sx</b> lock while sleeping.  As a result, an <b>sx</b>  lock  may
       not  be  acquired  while  holding a mutex.  Otherwise, if one thread slept while holding an <b>sx</b> lock while
       another thread blocked on the same <b>sx</b> lock  after  acquiring  a  mutex,  then  the  second  thread  would
       effectively end up sleeping while holding a mutex, which is not allowed.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/lock.9.html">lock</a></u>(9), <u><a href="../man9/locking.9.html">locking</a></u>(9), <u><a href="../man9/mutex.9.html">mutex</a></u>(9), <u><a href="../man9/panic.9.html">panic</a></u>(9), <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9), <u><a href="../man9/sema.9.html">sema</a></u>(9)

</pre><h4><b>BUGS</b></h4><pre>
       A  kernel  without  WITNESS cannot assert whether the current thread does or does not hold a shared lock.
       SA_LOCKED and SA_SLOCKED can only assert that <u>any</u> thread holds a shared lock.  They  cannot  ensure  that
       the  current  thread  holds  a shared lock.  Further, SA_UNLOCKED can only assert that the current thread
       does not hold an exclusive lock.

Debian                                          November 11, 2017                                          <u><a href="../man9/SX.9.html">SX</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>