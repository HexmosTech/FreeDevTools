<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>style — kernel source file style guide</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       style — kernel source file style guide

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This file specifies the preferred style for kernel source files in the FreeBSD source tree.  It is also a
       guide  for  the preferred userland code style.  Many of the style rules are implicit in the examples.  Be
       careful to check the examples before assuming that <b>style</b> is silent on an issue.

       /*
        * Style guide for FreeBSD.  Based on the CSRG's KNF (Kernel Normal Form).
        *
        *      @(#)style       1.14 (Berkeley) 4/28/95
        * $FreeBSD: releng/12.2/share/man/man9/style.9 359375 2020-03-27 19:08:10Z emaste $
        */

       /*
        * VERY important single-line comments look like this.
        */

       /* Most single-line comments look like this. */

       /*
        * Multi-line comments look like this.  Make them real sentences.  Fill
        * them so they look like real paragraphs.
        */

       The copyright header should be a multi-line comment, with the first line of the  comment  having  a  dash
       after the star like so:

       /*-
        * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
        *
        * Copyright (c) 1984-2025 John Q. Public
        * All rights reserved.
        *
        * Long, boring license goes here, but trimmed for brevity
        */

       An  automatic  script collects license information from the tree for all comments that start in the first
       column with “<b>/*-</b>”.  If you desire to flag <u><a href="../man1/indent.1.html">indent</a></u>(1) to not reformat a comment that starts  in  the  first
       column  which  is  not  a  license  or  copyright  notice,  change the dash to a star for those comments.
       Comments starting in columns other than the first are  never  considered  license  statements.   Use  the
       appropriate SPDX-License-Identifier line before the copyright.

       After any copyright header, there is a blank line, and the <b>$FreeBSD$</b> for non C/C++ language source files.
       Version  control  system ID tags should only exist once in a file (unlike in this one).  Non-C/C++ source
       files follow the example above, while C/C++ source files follow the one below.  All VCS (version  control
       system)  revision  identification in files obtained from elsewhere should be maintained, including, where
       applicable, multiple IDs showing a file's history.   In  general,  do  not  edit  foreign  IDs  or  their
       infrastructure.   Unless otherwise wrapped (such as “<b>#if</b> <b>defined(LIBC_SCCS)</b>”), enclose both in “<b>#if</b> <b>0</b> <b>...</b>
       <b>#endif</b>” to hide any uncompilable bits and to keep the IDs out of object files.   Only  add  “<b>From:</b>  ”  in
       front of foreign VCS IDs if the file is renamed.

       /* From: @(#)style      1.14 (Berkeley) 4/28/95 */

       #include &lt;sys/cdefs.h&gt;
       __FBSDID("$FreeBSD: releng/12.2/share/man/man9/style.9 359375 2020-03-27 19:08:10Z emaste $");

       Leave one blank line before the header files.

       Kernel  include files (<u>sys/*.h</u>) come first.  If &lt;<u>sys/cdefs.h</u>&gt; is needed for <b>__FBSDID</b>(), include it first.
       If  either  &lt;<u>sys/types.h</u>&gt;  or  &lt;<u>sys/param.h</u>&gt;  is  needed,  include  it  before   other   include   files.
       (&lt;<u>sys/param.h</u>&gt;  includes  &lt;<u>sys/types.h</u>&gt;;  do  not  include both.)  The remaining kernel headers should be
       sorted alphabetically.

       #include &lt;sys/types.h&gt;  /* Non-local includes in angle brackets. */
       #include &lt;sys/endian.h&gt;
       #include &lt;sys/lock.h&gt;
       #include &lt;sys/queue.h&gt;

       For a network program, put the network include files next.

       #include &lt;<a href="file:/usr/include/net/if.h">net/if.h</a>&gt;
       #include &lt;net/if_dl.h&gt;
       #include &lt;<a href="file:/usr/include/net/route.h">net/route.h</a>&gt;
       #include &lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;
       #include &lt;<a href="file:/usr/include/protocols/rwhod.h">protocols/rwhod.h</a>&gt;

       Do not include files from <u><a href="file:/usr/include">/usr/include</a></u> in the kernel.

       Leave a blank line before the next group, the <u><a href="file:/usr/include">/usr/include</a></u> files, which should be  sorted  alphabetically
       by name.

       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       Global  pathnames  are  defined  in &lt;<u>paths.h</u>&gt;.  Pathnames local to the program go in "<u>pathnames.h</u>" in the
       local directory.

       #include &lt;<a href="file:/usr/include/paths.h">paths.h</a>&gt;

       Leave another blank line before the local include files.

       #include "pathnames.h"          /* Local includes in double quotes. */

       Do not <b>#define</b> or declare names in the  implementation  namespace  except  for  implementing  application
       interfaces.

       The  names  of  “unsafe”  macros  (ones  that  have  side  effects), and the names of macros for manifest
       constants, are all in uppercase.  The expansions of expression-like macros are either a single  token  or
       have  outer  parentheses.  Put a single tab character between the <b>#define</b> and the macro name.  If a macro
       is an inline expansion of a function, the function name is all in lowercase and the macro  has  the  same
       name  all  in  uppercase.   Right-justify  the  backslashes;  it  makes  it easier to read.  If the macro
       encapsulates a compound statement, enclose it in a <b>do</b>  loop,  so  that  it  can  safely  be  used  in  <b>if</b>
       statements.   Any final statement-terminating semicolon should be supplied by the macro invocation rather
       than the macro, to make parsing easier for pretty-printers and editors.

       #define MACRO(x, y) do {                                                \
               variable = (x) + (y);                                           \
               (y) += 2;                                                       \
       } while (0)

       When code is conditionally compiled using <b>#ifdef</b> or <b>#if</b>, a comment may be added  following  the  matching
       <b>#endif</b>  or  <b>#else</b>  to  permit the reader to easily discern where conditionally compiled code regions end.
       This comment should be used only for (subjectively) long regions, regions greater than 20 lines, or where
       a series of nested <b>#ifdef</b> <b>'s</b> may be confusing to the reader.  The comment should be  separated  from  the
       <b>#endif</b>  or  <b>#else</b>  by a single space.  For short conditionally compiled regions, a closing comment should
       not be used.

       The comment for <b>#endif</b> should match the expression used in the corresponding <b>#if</b> or <b>#ifdef</b>.  The  comment
       for  <b>#else</b> and <b>#elif</b> should match the inverse of the expression(s) used in the preceding <b>#if</b> and/or <b>#elif</b>
       statements.  In the comments, the subexpression “<b>defined(FOO)</b>” is abbreviated as “<b>FOO</b>”.  For the purposes
       of comments, “<b>#ifndef</b> <b>FOO</b>” is treated as “<b>#if</b> <b>!defined(FOO)</b>”.

       #ifdef KTRACE
       #include &lt;sys/ktrace.h&gt;
       #endif

       #ifdef COMPAT_43
       /* A large region here, or other conditional code. */
       #else /* !COMPAT_43 */
       /* Or here. */
       #endif /* COMPAT_43 */

       #ifndef COMPAT_43
       /* Yet another large region here, or other conditional code. */
       #else /* COMPAT_43 */
       /* Or here. */
       #endif /* !COMPAT_43 */

       The project prefers the use of ISO/IEC 9899:1999 (“ISO C99”) unsigned integer  identifiers  of  the  form
       <u>uintXX_t</u>  rather than the older BSD-style integer identifiers of the form <u>u_intXX_t</u>.  New code should use
       the former, and old code should be converted to the new form if other major work is being  done  in  that
       area  and  there  is  no overriding reason to prefer the older BSD-style.  Like white-space commits, care
       should be taken in making <u>uintXX_t</u> only commits.

       Similarly, the project prefers the use of ISO C99 <u>bool</u> rather than the older <u>int</u> or <u>boolean_t</u>.  New  code
       should  use  <u>bool</u>,  and old code may be converted if it is reasonable to do so.  Literal values are named
       true and false.  These are preferred to the old spellings TRUE and FALSE.  Userspace code should  include
       &lt;<u>stdbool.h</u>&gt;, while kernel code should include &lt;<u>sys/types.h</u>&gt;.

       Likewise, the project prefers ISO C99 designated initializers when it makes sense to do so.

       Enumeration values are all uppercase.

       enum enumtype { ONE, TWO } et;

       The use of internal_underscores in identifiers is preferred over camelCase or TitleCase.

       In  declarations, do not put any whitespace between asterisks and adjacent tokens, except for tokens that
       are identifiers related to types.  (These identifiers are the names of basic types, type qualifiers,  and
       <b>typedef</b>-names  other  than  the  one  being declared.)  Separate these identifiers from asterisks using a
       single space.

       When declaring variables in structures, declare them sorted by use, then by size (largest  to  smallest),
       and  then  in  alphabetical order.  The first category normally does not apply, but there are exceptions.
       Each one gets its own line.  Try to make the structure readable by aligning the member names using either
       one or two tabs depending upon your judgment.  You should use one tab only if it  suffices  to  align  at
       least  90%  of  the  member  names.  Names following extremely long types should be separated by a single
       space.

       Major structures should be declared at the top of the file in which they are used, or in separate  header
       files  if  they  are  used  in  multiple  source  files.   Use  of  the  structures should be by separate
       declarations and should be <b>extern</b> if they are declared in a header file.

       struct foo {
               struct foo      *next;          /* List of active foo. */
               struct mumble   amumble;        /* Comment for mumble. */
               int             bar;            /* Try to align the comments. */
               struct verylongtypename *baz;   /* Does not fit in 2 tabs. */
       };
       struct foo *foohead;                    /* Head of global foo list. */

       Use <u><a href="../man3/queue.3.html">queue</a></u>(3) macros rather than rolling your own lists, whenever possible.  Thus,  the  previous  example
       would be better written:

       #include &lt;sys/queue.h&gt;

       struct foo {
               LIST_ENTRY(foo) link;           /* Use queue macros for foo lists. */
               struct mumble   amumble;        /* Comment for mumble. */
               int             bar;            /* Try to align the comments. */
               struct verylongtypename *baz;   /* Does not fit in 2 tabs. */
       };
       LIST_HEAD(, foo) foohead;               /* Head of global foo list. */

       Avoid  using  typedefs  for  structure types.  Typedefs are problematic because they do not properly hide
       their underlying type; for example you need to know if the typedef is the structure itself or  a  pointer
       to  the  structure.  In addition they must be declared exactly once, whereas an incomplete structure type
       can be mentioned as many times as necessary.  Typedefs are difficult to use in stand-alone header  files:
       the  header  that  defines  the typedef must be included before the header that uses it, or by the header
       that uses it (which causes namespace pollution), or there must be a back-door mechanism for obtaining the
       typedef.

       When convention requires a <b>typedef</b>, make its name match the struct tag.  Avoid typedefs ending  in  “<b>_t</b>”,
       except as specified in Standard C or by POSIX.

       /* Make the structure name match the typedef. */
       typedef struct bar {
               int     level;
       } BAR;
       typedef int             foo;            /* This is foo. */
       typedef const long      baz;            /* This is baz. */

       All functions are prototyped somewhere.

       Function prototypes for private functions (i.e., functions not used elsewhere) go at the top of the first
       source module.  Functions local to one source module should be declared <b>static</b>.

       Functions  used  from  other  parts  of the kernel are prototyped in the relevant include file.  Function
       prototypes should be listed in a logical order, preferably alphabetical  unless  there  is  a  compelling
       reason to use a different ordering.

       Functions that are used locally in more than one module go into a separate header file, e.g., "<u>extern.h</u>".

       Do not use the __P macro.

       In  general code can be considered “new code” when it makes up about 50% or more of the file(s) involved.
       This is enough to break precedents in the existing code and use the current <b>style</b> guidelines.

       The kernel has a name associated with parameter types, e.g., in the kernel use:

       void    function(int fd);

       In header files visible to userland applications, prototypes that are visible must use either “protected”
       names (ones beginning with an underscore) or no names with the types.  It is preferable to use  protected
       names.  E.g., use:

       void    function(int);

       or:

       void    function(int _fd);

       Prototypes may have an extra space after a tab to enable function names to line up:

       static char     *function(int _arg, const char *_arg2, struct foo *_arg3,
                           struct bar *_arg4);
       static void      usage(void);

       /*
        * All major routines should have a comment briefly describing what
        * they do.  The comment before the "main" routine should describe
        * what the program does.
        */
       int
       main(int argc, char *argv[])
       {
               char *ep;
               long num;
               int ch;

       For  consistency,  <u><a href="../man3/getopt.3.html">getopt</a></u>(3)  should be used to parse options.  Options should be sorted in the <u><a href="../man3/getopt.3.html">getopt</a></u>(3)
       call and the <b>switch</b> statement, unless parts of the <b>switch</b> cascade.  Elements in a <b>switch</b>  statement  that
       cascade  should  have  a  <b>FALLTHROUGH</b> comment.  Numerical arguments should be checked for accuracy.  Code
       which is unreachable for non-obvious reasons may be marked /* <b>NOTREACHED</b> *<a href="file:/.">/.</a>

               while ((ch = getopt(argc, argv, "abNn:")) != -1)
                       switch (ch) {           /* Indent the switch. */
                       case 'a':               /* Do not indent the case. */
                               aflag = 1;      /* Indent case body one tab. */
                               /* FALLTHROUGH */
                       case 'b':
                               bflag = 1;
                               break;
                       case 'N':
                               Nflag = 1;
                               break;
                       case 'n':
                               num = strtol(optarg, &amp;ep, 10);
                               if (num &lt;= 0 || *ep != '\0') {
                                       warnx("illegal number, -n argument -- %s",
                                           optarg);
                                       usage();
                               }
                               break;
                       case '?':
                       default:
                               usage();
                       }
               argc -= optind;
               argv += optind;

       Space after keywords (<b>if</b>, <b>while</b>, <b>for</b>, <b>return</b>, <b>switch</b>).  Two styles of braces (‘{’ and  ‘}’)  are  allowed
       for  single line statements.  Either they are used for all single statements, or they are used only where
       needed for clarity.  Usage within a function should be consistent.  Forever loops are  done  with  <b>for</b>'s,
       not <b>while</b>'s.

               for (p = buf; *p != '\0'; ++p)
                       ;       /* nothing */
               for (;;)
                       stmt;
               for (;;) {
                       z = a + really + long + statement + that + needs +
                           two + lines + gets + indented + four + spaces +
                           on + the + second + and + subsequent + lines;
               }
               for (;;) {
                       if (cond)
                               stmt;
               }
               if (val != NULL)
                       val = realloc(val, newsize);

       Parts  of  a  <b>for</b>  loop  may  be left empty.  Do not put declarations inside blocks unless the routine is
       unusually complicated.

               for (; cnt &lt; 15; cnt++) {
                       stmt1;
                       stmt2;
               }

       Indentation is an 8 character tab.  Second level indents are four spaces.  If you have  to  wrap  a  long
       statement, put the operator at the end of the line.

               while (cnt &lt; 20 &amp;&amp; this_variable_name_is_too_long &amp;&amp;
                   ep != NULL)
                       z = a + really + long + statement + that + needs +
                           two + lines + gets + indented + four + spaces +
                           on + the + second + and + subsequent + lines;

       Do not add whitespace at the end of a line, and only use tabs followed by spaces to form the indentation.
       Do not use more spaces than a tab will produce and do not use spaces in front of tabs.

       Closing  and  opening  braces go on the same line as the <b>else</b>.  Braces that are not necessary may be left
       out.

               if (test)
                       stmt;
               else if (bar) {
                       stmt;
                       stmt;
               } else
                       stmt;

       No spaces after function names.  Commas have a space after them.  No spaces after ‘(’ or ‘[’ or preceding
       ‘]’ or ‘)’ characters.

               error = function(a1, a2);
               if (error != 0)
                       exit(error);

       Unary operators do not require spaces, binary operators do.  Do  not  use  parentheses  unless  they  are
       required  for  precedence  or unless the statement is confusing without them.  Remember that other people
       may confuse easier than you.  Do YOU understand the following?

               a = b-&gt;c[0] + ~d == (e || f) || g &amp;&amp; h ? i : j &gt;&gt; 1;
               k = !(l &amp; FLAGS);

       Exits should be 0 on success, or 1 on failure.

               <a href="../man0/exit.0.html">exit</a>(0);        /*
                                * Avoid obvious comments such as
                                * "Exit 0 on success."
                                */
       }

       The function type should be on a line by itself  preceding  the  function.   The  opening  brace  of  the
       function body should be on a line by itself.

       static char *
       function(int a1, int a2, float fl, int a4)
       {

       When  declaring  variables in functions declare them sorted by size, then in alphabetical order; multiple
       ones per line are okay.  If a line overflows reuse the type keyword.

       Be careful to not obfuscate the code by initializing variables in the  declarations.   Use  this  feature
       only thoughtfully.  DO NOT use function calls in initializers.

               struct foo one, *two;
               double three;
               int *four, five;
               char *six, seven, eight, nine, ten, eleven, twelve;

               four = myfunction();

       Do  not  declare  functions  inside  other  functions; ANSI C says that such declarations have file scope
       regardless of the nesting of the declaration.  Hiding file declarations in what appears  to  be  a  local
       scope is undesirable and will elicit complaints from a good compiler.

       Casts  and  <b>sizeof</b>'s  are  not  followed  by a space.  Note that <u><a href="../man1/indent.1.html">indent</a></u>(1) does not understand this rule.
       <b>sizeof</b>'s are written  with  parenthesis  always.   The  redundant  parenthesis  rules  do  not  apply  to
       <b>sizeof</b>(<u>var</u>) instances.

       NULL  is  the preferred null pointer constant.  Use NULL instead of (<u>type</u> <u>*</u>)0 or (<u>type</u> <u>*</u>)NULL in contexts
       where the compiler knows the type, e.g.,  in  assignments.   Use  (<u>type</u>  <u>*</u>)NULL  in  other  contexts,  in
       particular  for  all  function  args.  (Casting is essential for variadic args and is necessary for other
       args if the function prototype might not be in scope.)  Test pointers against NULL, e.g., use:

       (p = f()) == NULL

       not:

       !(p = f())

       Do not use <b>!</b> for tests unless it is a boolean, e.g., use:

       if (*p == '\0')

       not:

       if (!*p)

       Routines returning <u>void</u> <u>*</u> should not have their return values cast to any pointer type.

       Values in <b>return</b> statements should be enclosed in parentheses.

       Use <u><a href="../man3/err.3.html">err</a></u>(3) or <u><a href="../man3/warn.3.html">warn</a></u>(3), do not roll your own.

               if ((four = malloc(sizeof(struct foo))) == NULL)
                       err(1, (char *)NULL);
               if ((six = (int *)overflow()) == NULL)
                       errx(1, "number overflowed");
               return (eight);
       }

       When converting K&amp;R style declarations to ANSI style, preserve any comments about parameters.

       Long parameter lists are wrapped with a normal four space indent.

       Variable numbers of arguments should look like this:

       #include &lt;stdarg.h&gt;

       void
       vaf(const char *fmt, ...)
       {
               va_list ap;

               va_start(ap, fmt);
               STUFF;
               va_end(ap);
               /* No return needed for void functions. */
       }

       static void
       usage()
       {
               /* Insert an empty line if the function has no local variables. */

       Use <u><a href="../man3/printf.3.html">printf</a></u>(3), not <u><a href="../man3/fputs.3.html">fputs</a></u>(3), <u><a href="../man3/puts.3.html">puts</a></u>(3), <u><a href="../man3/putchar.3.html">putchar</a></u>(3), whatever; it is faster  and  usually  cleaner,  not  to
       mention avoiding stupid bugs.

       Usage  statements should look like the manual pages “SYNOPSIS”.  The usage statement should be structured
       in the following order:

       1.   Options without operands come first, in alphabetical order, inside a single set of brackets (‘[’ and
            ‘]’).

       2.   Options with operands come next, also in alphabetical order,  with  each  option  and  its  argument
            inside its own pair of brackets.

       3.   Required  arguments  (if  any) are next, listed in the order they should be specified on the command
            line.

       4.   Finally, any optional arguments should be listed, listed in the order they should be specified,  and
            all inside brackets.

       A  bar  (‘|’) separates “either-or” options/arguments, and multiple options/arguments which are specified
       together are placed in a single set of brackets.

           "usage: f [-aDde] [-b b_arg] [-m m_arg] req1 req2 [opt1 [opt2]]\n"
           "usage: f [-a | -b] [-c [-dEe] [-n number]]\n"

               (void)fprintf(stderr, "usage: f [-ab]\n");
               <a href="../man1/exit.1.html">exit</a>(1);
       }

       Note that the manual page options description should list the options in pure alphabetical  order.   That
       is,  without  regard  to whether an option takes arguments or not.  The alphabetical ordering should take
       into account the case ordering shown above.

       New core kernel code should be reasonably compliant with the <b>style</b> guides.   The  guidelines  for  third-
       party  maintained  modules  and  device  drivers  are  more relaxed but at a minimum should be internally
       consistent with their style.

       Stylistic changes (including whitespace changes) are hard on the source repository and are to be  avoided
       without  good  reason.  Code that is approximately FreeBSD KNF <b>style</b> compliant in the repository must not
       diverge from compliance.

       Whenever possible, code should be run through a code checker (e.g., various static analyzers or <b>cc</b> <b>-Wall</b>)
       and produce minimal warnings.

</pre><h4><b>FILES</b></h4><pre>
       <u>/usr/src/tools/tools/editing/freebsd.el</u>
               An Emacs plugin to follow the FreeBSD <b>style</b> indentation rules.

       <u>/usr/src/tools/tools/editing/freebsd.vim</u>
               A Vim plugin to follow the FreeBSD <b>style</b> indentation rules.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/indent.1.html">indent</a></u>(1), <u><a href="../man3/err.3.html">err</a></u>(3), <u><a href="../man3/warn.3.html">warn</a></u>(3), <u><a href="../man5/style.Makefile.5.html">style.Makefile</a></u>(5), <u><a href="../man9/style.lua.9.html">style.lua</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       This manual page is largely based on the <u>src/admin/style/style</u> file from the 4.4BSD-Lite2  release,  with
       occasional   updates   to   reflect   the   current   practice   and   desire  of  the  FreeBSD  project.
       <u>src/admin/style/style</u> is a codification by the CSRG of the programming style of Ken Thompson  and  Dennis
       Ritchie in Version 6 AT&amp;T UNIX.

Debian                                          January 25, 2018                                        <u><a href="../man9/STYLE.9.html">STYLE</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>