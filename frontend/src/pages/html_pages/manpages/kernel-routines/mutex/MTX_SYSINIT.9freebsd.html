<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mutex,  mtx_init, mtx_destroy, mtx_lock, mtx_lock_spin, mtx_lock_flags, mtx_lock_spin_flags, mtx_trylock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mutex,  mtx_init, mtx_destroy, mtx_lock, mtx_lock_spin, mtx_lock_flags, mtx_lock_spin_flags, mtx_trylock,
       mtx_trylock_flags,     mtx_trylock_spin,     mtx_trylock_spin_flags,     mtx_unlock,     mtx_unlock_spin,
       mtx_unlock_flags, mtx_unlock_spin_flags, mtx_sleep, mtx_initialized, mtx_owned, mtx_recursed, mtx_assert,
       MTX_SYSINIT â€” kernel synchronization primitives

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/lock.h&gt;</b>
       <b>#include</b> <b>&lt;sys/mutex.h&gt;</b>

       <u>void</u>
       <b>mtx_init</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>const</u> <u>char</u> <u>*type</u>, <u>int</u> <u>opts</u>);

       <u>void</u>
       <b>mtx_destroy</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>void</u>
       <b>mtx_lock</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>void</u>
       <b>mtx_lock_spin</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>void</u>
       <b>mtx_lock_flags</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>mtx_lock_spin_flags</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>mtx_trylock</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>int</u>
       <b>mtx_trylock_flags</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>mtx_trylock_spin</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>int</u>
       <b>mtx_trylock_spin_flags</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>mtx_unlock</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>void</u>
       <b>mtx_unlock_spin</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>void</u>
       <b>mtx_unlock_flags</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>flags</u>);

       <u>void</u>
       <b>mtx_unlock_spin_flags</b>(<u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>mtx_sleep</b>(<u>void</u> <u>*chan</u>, <u>struct</u> <u>mtx</u> <u>*mtx</u>, <u>int</u> <u>priority</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>timo</u>);

       <u>int</u>
       <b>mtx_initialized</b>(<u>const</u> <u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>int</u>
       <b>mtx_owned</b>(<u>const</u> <u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <u>int</u>
       <b>mtx_recursed</b>(<u>const</u> <u>struct</u> <u>mtx</u> <u>*mutex</u>);

       <b>options</b> <b>INVARIANTS</b>
       <b>options</b> <b>INVARIANT_SUPPORT</b>

       <u>void</u>
       <b>mtx_assert</b>(<u>const</u> <u>struct</u> <u>mtx</u> <u>*mutex</u>, <u>int</u> <u>what</u>);

       <b>#include</b> <b>&lt;sys/kernel.h&gt;</b>

       <b>MTX_SYSINIT</b>(<u>name</u>, <u>struct</u> <u>mtx</u> <u>*mtx</u>, <u>const</u> <u>char</u> <u>*description</u>, <u>int</u> <u>opts</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mutexes are the most basic and primary method of thread synchronization.  The major design considerations
       for mutexes are:

       1.   Acquiring and releasing uncontested mutexes should be as cheap as possible.

       2.   They must have the information and storage space to support priority propagation.

       3.   A  thread  must  be  able  to recursively acquire a mutex, provided that the mutex is initialized to
            support recursion.

       There are currently two flavors of mutexes, those that context switch when they block and those  that  do
       not.

       By default, MTX_DEF mutexes will context switch when they are already held.  As an optimization, they may
       spin  for  some amount of time before context switching.  It is important to remember that since a thread
       may be preempted at any time, the possible context switch introduced by acquiring a mutex  is  guaranteed
       to not break anything that is not already broken.

       Mutexes  which  do  not  context  switch are MTX_SPIN mutexes.  These should only be used to protect data
       shared with primary interrupt code.  This includes interrupt filters and low level scheduling  code.   In
       all  architectures  both  acquiring  and releasing of a uncontested spin mutex is more expensive than the
       same operation on a non-spin mutex.  In order to protect  an  interrupt  service  routine  from  blocking
       against  itself  all  interrupts are either blocked or deferred on a processor while holding a spin lock.
       It is permissible to hold multiple spin mutexes.

       Once a spin mutex has been acquired it is not permissible to acquire a blocking mutex.

       The storage needed to implement a mutex is provided by a <u>struct</u> <u>mtx</u>.  In general this should  be  treated
       as an opaque object and referenced only with the mutex primitives.

       The  <b>mtx_init</b>()  function  must be used to initialize a mutex before it can be passed to any of the other
       mutex functions.  The <u>name</u> option is used to identify the lock in debugging output etc.  The <u>type</u>  option
       is  used  by  the  witness code to classify a mutex when doing checks of lock ordering.  If <u>type</u> is NULL,
       <u>name</u> is used in its place.  The pointer passed in as <u>name</u> and <u>type</u> is  saved  rather  than  the  data  it
       points  to.   The  data pointed to must remain stable until the mutex is destroyed.  The <u>opts</u> argument is
       used to set the type of mutex.  It may contain either MTX_DEF or MTX_SPIN but not both.   If  the  kernel
       has  been compiled with <b>option</b> <b>INVARIANTS</b>, <b>mtx_init</b>() will assert that the <u>mutex</u> has not been initialized
       multiple times without intervening calls to <b>mtx_destroy</b>() unless the MTX_NEW option  is  specified.   See
       below for additional initialization options.

       The  <b>mtx_lock</b>()  function  acquires  a  MTX_DEF  mutual exclusion lock on behalf of the currently running
       kernel thread.  If another kernel thread is holding the mutex, the caller will be disconnected  from  the
       CPU until the mutex is available (i.e., it will block).

       The <b>mtx_lock_spin</b>() function acquires a MTX_SPIN mutual exclusion lock on behalf of the currently running
       kernel  thread.   If  another  kernel  thread  is holding the mutex, the caller will spin until the mutex
       becomes available.  Interrupts are disabled during the spin and remain disabled following  the  acquiring
       of the lock.

       It  is possible for the same thread to recursively acquire a mutex with no ill effects, provided that the
       MTX_RECURSE bit was passed to <b>mtx_init</b>() during the initialization of the mutex.

       The  <b>mtx_lock_flags</b>()  and  <b>mtx_lock_spin_flags</b>()  functions  acquire  a  MTX_DEF   or   MTX_SPIN   lock,
       respectively,  and  also  accept a <u>flags</u> argument.  In both cases, the only flags presently available for
       lock acquires are MTX_QUIET and MTX_RECURSE.  If the MTX_QUIET bit is turned on in  the  <u>flags</u>  argument,
       then  if KTR_LOCK tracing is being done, it will be silenced during the lock acquire.  If the MTX_RECURSE
       bit is turned on in the <u>flags</u> argument, then the mutex can be acquired recursively.

       The <b>mtx_trylock</b>() and <b>mtx_trylock_spin</b>() functions attempt  to  acquire  a  MTX_DEF  or  MTX_SPIN  mutex,
       respectively,  pointed  to  by  <u>mutex</u>.   If  the mutex cannot be immediately acquired, the functions will
       return 0, otherwise the mutex will be acquired and a non-zero value will be returned.

       The <b>mtx_trylock_flags</b>() and <b>mtx_trylock_spin_flags</b>() functions have the same  behavior  as  <b>mtx_trylock</b>()
       and <b>mtx_trylock_spin</b>() respectively, but should be used when the caller desires to pass in a <u>flags</u> value.
       Presently,  the  only valid value in the <b>mtx_trylock</b>() and <b>mtx_trylock_spin</b>() cases is MTX_QUIET, and its
       effects are identical to those described for <b>mtx_lock</b>() above.

       The <b>mtx_unlock</b>() function releases a MTX_DEF mutual exclusion lock.  The current thread may be  preempted
       if a higher priority thread is waiting for the mutex.

       The <b>mtx_unlock_spin</b>() function releases a MTX_SPIN mutual exclusion lock.

       The  <b>mtx_unlock_flags</b>()  and  <b>mtx_unlock_spin_flags</b>()  functions behave in exactly the same way as do the
       standard mutex unlock routines above, while also allowing a <u>flags</u> argument which may  specify  MTX_QUIET.
       The behavior of MTX_QUIET is identical to its behavior in the mutex lock routines.

       The  <b>mtx_destroy</b>()  function  is  used  to  destroy  <u>mutex</u> so the data associated with it may be freed or
       otherwise overwritten.  Any  mutex  which  is  destroyed  must  previously  have  been  initialized  with
       <b>mtx_init</b>().   It  is  permissible to have a single hold count on a mutex when it is destroyed.  It is not
       permissible to hold the mutex recursively, or have another  thread  blocked  on  the  mutex  when  it  is
       destroyed.

       The  <b>mtx_sleep</b>() function is used to atomically release <u>mtx</u> while waiting for an event.  For more details
       on the parameters to this function, see <u><a href="../man9/sleep.9.html">sleep</a></u>(9).

       The <b>mtx_initialized</b>() function returns non-zero if <u>mutex</u> has been initialized and zero otherwise.

       The <b>mtx_owned</b>() function returns non-zero if the current thread holds <u>mutex</u>.  If the current thread  does
       not hold <u>mutex</u> zero is returned.

       The <b>mtx_recursed</b>() function returns non-zero if the <u>mutex</u> is recursed.  This check should only be made if
       the running thread already owns <u>mutex</u>.

       The  <b>mtx_assert</b>() function allows assertions specified in <u>what</u> to be made about <u>mutex</u>.  If the assertions
       are not true and the kernel is compiled with <b>options</b> <b>INVARIANTS</b> and <b>options</b> <b>INVARIANT_SUPPORT</b>, the kernel
       will panic.  Currently the following assertions are supported:

       MA_OWNED        Assert that the current thread holds the mutex pointed to by the first argument.

       MA_NOTOWNED     Assert that the current thread does not hold the mutex pointed to by the first argument.

       MA_RECURSED     Assert that the current thread has  recursed  on  the  mutex  pointed  to  by  the  first
                       argument.  This assertion is only valid in conjunction with MA_OWNED.

       MA_NOTRECURSED  Assert  that  the  current  thread  has not recursed on the mutex pointed to by the first
                       argument.  This assertion is only valid in conjunction with MA_OWNED.

       The <b>MTX_SYSINIT</b>() macro is used to generate a call to the <b>mtx_sysinit</b>()  routine  at  system  startup  in
       order to initialize a given mutex lock.  The parameters are the same as <b>mtx_init</b>() but with an additional
       argument,  <u>name</u>,  that  is used in generating unique variable names for the related structures associated
       with the lock and the sysinit routine.

   <b>The</b> <b>Default</b> <b>Mutex</b> <b>Type</b>
       Most kernel code should use the default lock type, MTX_DEF.  The default lock type will allow the  thread
       to  be  disconnected  from the CPU if the lock is already held by another thread.  The implementation may
       treat the lock as a short term spin lock under some circumstances.  However, it is  always  safe  to  use
       these forms of locks in an interrupt thread without fear of deadlock against an interrupted thread on the
       same CPU.

   <b>The</b> <b>Spin</b> <b>Mutex</b> <b>Type</b>
       A  MTX_SPIN mutex will not relinquish the CPU when it cannot immediately get the requested lock, but will
       loop, waiting for the mutex to be released by another CPU.  This could  result  in  deadlock  if  another
       thread  interrupted  the  thread which held a mutex and then tried to acquire the mutex.  For this reason
       spin locks disable all interrupts on the local CPU.

       Spin locks are fairly specialized locks that are intended to be held for  very  short  periods  of  time.
       Their  primary purpose is to protect portions of the code that implement other synchronization primitives
       such as default mutexes, thread scheduling, and interrupt threads.

   <b>Initialization</b> <b>Options</b>
       The options passed in the <u>opts</u> argument of <b>mtx_init</b>() specify the mutex type.   One  of  the  MTX_DEF  or
       MTX_SPIN options is required and only one of those two options may be specified.  The possibilities are:

       MTX_DEF        Default  mutexes  will  always  allow the current thread to be suspended to avoid deadlock
                      conditions against interrupt threads.  The implementation of this lock type may spin for a
                      while before suspending the current thread.

       MTX_SPIN       Spin mutexes will never relinquish the CPU.  All interrupts are disabled on the local  CPU
                      while any spin lock is held.

       MTX_RECURSE    Specifies  that  the initialized mutex is allowed to recurse.  This bit must be present if
                      the mutex is permitted to recurse.

                      Note that  neither  <b>mtx_trylock</b>()  nor  <b>mtx_trylock_spin</b>()  support  recursion;  that  is,
                      attempting to acquire an already-owned mutex fails.

       MTX_QUIET      Do not log any mutex operations for this lock.

       MTX_NOWITNESS  Instruct <u><a href="../man4/witness.4.html">witness</a></u>(4) to ignore this lock.

       MTX_DUPOK      Witness should not log messages about duplicate locks being acquired.

       MTX_NOPROFILE  Do not profile this lock.

       MTX_NEW        Do not check for double-init.

   <b>Lock</b> <b>and</b> <b>Unlock</b> <b>Flags</b>
       The    flags   passed   to   the   <b>mtx_lock_flags</b>(),   <b>mtx_lock_spin_flags</b>(),   <b>mtx_unlock_flags</b>(),   and
       <b>mtx_unlock_spin_flags</b>() functions provide some basic options to the caller, and are often used only under
       special circumstances to modify lock or unlock  behavior.   Standard  locking  and  unlocking  should  be
       performed with the <b>mtx_lock</b>(), <b>mtx_lock_spin</b>(), <b>mtx_unlock</b>(), and <b>mtx_unlock_spin</b>() functions.  Only if a
       flag is required should the corresponding flags-accepting routines be used.

       Options that modify mutex behavior:

       MTX_QUIET  This option is used to quiet logging messages during individual mutex operations.  This can be
                  used to trim superfluous logging messages for debugging purposes.

   <b>Giant</b>
       If  <u>Giant</u> must be acquired, it must be acquired prior to acquiring other mutexes.  Put another way: it is
       impossible to acquire <u>Giant</u> non-recursively while holding another mutex.  It is possible to acquire other
       mutexes while holding <u>Giant</u>, and it is possible to acquire <u>Giant</u> recursively while holding other mutexes.

   <b>Sleeping</b>
       Sleeping while holding a mutex (except for <u>Giant</u>) is  never  safe  and  should  be  avoided.   There  are
       numerous assertions which will fail if this is attempted.

   <b>Functions</b> <b>Which</b> <b>Access</b> <b>Memory</b> <b>in</b> <b>Userspace</b>
       No  mutexes  should be held (except for <u>Giant</u>) across functions which access memory in userspace, such as
       <u><a href="../man9/copyin.9.html">copyin</a></u>(9), <u><a href="../man9/copyout.9.html">copyout</a></u>(9), <u><a href="../man9/uiomove.9.html">uiomove</a></u>(9), <u><a href="../man9/fuword.9.html">fuword</a></u>(9), etc.  No locks are needed when calling these functions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/condvar.9.html">condvar</a></u>(9), <u><a href="../man9/LOCK_PROFILING.9.html">LOCK_PROFILING</a></u>(9), <u><a href="../man9/locking.9.html">locking</a></u>(9), <u><a href="../man9/mtx_pool.9.html">mtx_pool</a></u>(9), <u><a href="../man9/panic.9.html">panic</a></u>(9), <u><a href="../man9/rwlock.9.html">rwlock</a></u>(9), <u><a href="../man9/sema.9.html">sema</a></u>(9), <u><a href="../man9/sleep.9.html">sleep</a></u>(9), <u><a href="../man9/sx.9.html">sx</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       These functions appeared in BSD/OS 4.1 and FreeBSD 5.0.  The <b>mtx_trylock_spin</b>()  function  was  added  in
       FreeBSD 11.1.

Debian                                            May 24, 2017                                          <u><a href="../man9/MUTEX.9.html">MUTEX</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>