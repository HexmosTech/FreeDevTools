<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>atomic_add,     atomic_clear,     atomic_cmpset,     atomic_fcmpset,     atomic_fetchadd,    atomic_load,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       atomic_add,     atomic_clear,     atomic_cmpset,     atomic_fcmpset,     atomic_fetchadd,    atomic_load,
       atomic_readandclear, atomic_set, atomic_subtract, atomic_store, atomic_thread_fence — atomic operations

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;machine/atomic.h&gt;</b>

       <u>void</u>
       <b>atomic_add_[acq_|rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>void</u>
       <b>atomic_clear_[acq_|rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>int</u>
       <b>atomic_cmpset_[acq_|rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*dst</u>, <u>&lt;type&gt;</u> <u>old</u>, <u>&lt;type&gt;</u> <u>new</u>);

       <u>int</u>
       <b>atomic_fcmpset_[acq_|rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*dst</u>, <u>&lt;type&gt;</u> <u>*old</u>, <u>&lt;type&gt;</u> <u>new</u>);

       <u>&lt;type&gt;</u>
       <b>atomic_fetchadd_&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>&lt;type&gt;</u>
       <b>atomic_load_[acq_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>);

       <u>&lt;type&gt;</u>
       <b>atomic_readandclear_&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>);

       <u>void</u>
       <b>atomic_set_[acq_|rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>void</u>
       <b>atomic_subtract_[acq_|rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>void</u>
       <b>atomic_store_[rel_]&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>&lt;type&gt;</u>
       <b>atomic_swap_&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>&lt;type&gt;</u> <u>v</u>);

       <u>int</u>
       <b>atomic_testandclear_&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>u_int</u> <u>v</u>);

       <u>int</u>
       <b>atomic_testandset_&lt;type&gt;</b>(<u>volatile</u> <u>&lt;type&gt;</u> <u>*p</u>, <u>u_int</u> <u>v</u>);

       <u>void</u>
       <b>atomic_thread_fence_[acq|acq_rel|rel|seq_cst]</b>(<u>void</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Atomic  operations  are  commonly  used  to  implement  reference  counts  and  as  building  blocks  for
       synchronization primitives, such as mutexes.

       All  of  these  operations  are  performed  <u>atomically</u>  across  multiple  threads  and in the presence of
       interrupts, meaning that they are performed in an indivisible manner from the perspective of concurrently
       running threads and interrupt handlers.

       On all architectures supported by FreeBSD, ordinary loads and stores of integers in cache-coherent memory
       are inherently atomic if the integer is naturally aligned and its size does not  exceed  the  processor's
       word size.  However, such loads and stores may be elided from the program by the compiler, whereas atomic
       operations are always performed.

       When  atomic  operations  are performed on cache-coherent memory, all operations on the same location are
       totally ordered.

       When an atomic load is performed on a location in cache-coherent memory, it reads the entire  value  that
       was  defined  by  the last atomic store to each byte of the location.  An atomic load will never return a
       value out of thin air.  When an atomic store is performed on a location, no  other  thread  or  interrupt
       handler will observe a <u>torn</u> <u>write</u>, or partial modification of the location.

       Except  as  noted  below,  the  semantics  of  these  operations are almost identical to the semantics of
       similarly named C11 atomic operations.

   <b>Types</b>
       Most atomic operations act upon a specific <u>type</u>.  That type  is  indicated  in  the  function  name.   In
       contrast  to  C11 atomic operations, FreeBSD's atomic operations are performed on ordinary integer types.
       The available types are:

             <b>int</b>    unsigned integer
             <b>long</b>   unsigned long integer
             <b>ptr</b>    unsigned integer the size of a pointer
             <b>32</b>     unsigned 32-bit integer
             <b>64</b>     unsigned 64-bit integer

       For example, the function to atomically add two integers is called <b>atomic_add_int</b>().

       Certain architectures also provide operations for types smaller than “<b>int</b>”.

             <b>char</b>   unsigned character
             <b>short</b>  unsigned short integer
             <b>8</b>      unsigned 8-bit integer
             <b>16</b>     unsigned 16-bit integer

       These types must not be used in machine-independent code.

   <b>Acquire</b> <b>and</b> <b>Release</b> <b>Operations</b>
       By default, a thread's accesses to different memory locations might not be performed  in  <u>program</u>  <u>order</u>,
       that is, the order in which the accesses appear in the source code.  To optimize the program's execution,
       both  the  compiler  and  processor might reorder the thread's accesses.  However, both ensure that their
       reordering of the accesses is not visible to the thread.  Otherwise, the traditional memory model that is
       expected by single-threaded programs would be violated.  Nonetheless, other threads  in  a  multithreaded
       program,  such as the FreeBSD kernel, might observe the reordering.  Moreover, in some cases, such as the
       implementation of synchronization between threads, arbitrary reordering might  result  in  the  incorrect
       execution of the program.  To constrain the reordering that both the compiler and processor might perform
       on a thread's accesses, a programmer can use atomic operations with <u>acquire</u> and <u>release</u> semantics.

       Atomic  operations  on  memory  have  up  to three variants.  The first, or <u>relaxed</u> variant, performs the
       operation without imposing any ordering constraints on accesses to other memory locations.  This  variant
       is the default.  The second variant has acquire semantics, and the third variant has release semantics.

       When  an  atomic operation has acquire semantics, the operation must have completed before any subsequent
       load or store (by program order) is performed.  Conversely, acquire semantics do not require  that  prior
       loads  or  stores  have completed before the atomic operation is performed.  An atomic operation can only
       have acquire semantics if it performs a load from memory.  To denote acquire semantics, the suffix “<b>_acq</b>”
       is inserted into the function name immediately prior to the “<b>_</b>⟨<u>type</u>⟩” suffix.  For example,  to  subtract
       two  integers  ensuring  that  the  subtraction  is  completed before any subsequent loads and stores are
       performed, use <b>atomic_subtract_acq_int</b>().

       When an atomic operation has release semantics, all prior loads or stores (by program  order)  must  have
       completed  before  the  operation  is  performed.   Conversely, release semantics do not require that the
       atomic operation must have completed before any  subsequent  load  or  store  is  performed.   An  atomic
       operation can only have release semantics if it performs a store to memory.  To denote release semantics,
       the  suffix  “<b>_rel</b>”  is  inserted  into the function name immediately prior to the “<b>_</b>⟨<u>type</u>⟩” suffix.  For
       example, to add two long integers ensuring that all prior loads  and  stores  are  completed  before  the
       addition is performed, use <b>atomic_add_rel_long</b>().

       When  a release operation by one thread <u>synchronizes</u> <u>with</u> an acquire operation by another thread, usually
       meaning that the acquire operation reads the value written by the release operation, then the effects  of
       all prior stores by the releasing thread must become visible to subsequent loads by the acquiring thread.
       Moreover,  the  effects  of  all stores (by other threads) that were visible to the releasing thread must
       also become visible to the acquiring thread.  These rules only apply to the synchronizing threads.  Other
       threads might observe these stores in a different order.

       In effect, atomic operations with acquire and release semantics establish one-way barriers to  reordering
       that  enable  the  implementations  of  synchronization primitives to express their ordering requirements
       without also imposing unnecessary ordering.  For example, for a critical section guarded by a  mutex,  an
       acquire  operation  when  the  mutex  is  locked  and a release operation when the mutex is unlocked will
       prevent any loads or stores from moving outside of the critical section.  However, they will not  prevent
       the  compiler  or processor from moving loads or stores into the critical section, which does not violate
       the semantics of a mutex.

   <b>Thread</b> <b>Fence</b> <b>Operations</b>
       Alternatively, a programmer can use atomic  thread  fence  operations  to  constrain  the  reordering  of
       accesses.  In contrast to other atomic operations, fences do not, themselves, access memory.

       When  a  fence  has  acquire semantics, all prior loads (by program order) must have completed before any
       subsequent load or store is performed.  Thus, an acquire fence is a two-way barrier for load  operations.
       To  denote  acquire  semantics,  the  suffix  “<b>_acq</b>”  is  appended  to  the  function  name, for example,
       <b>atomic_thread_fence_acq</b>().

       When a fence has release semantics, all prior loads or stores (by  program  order)  must  have  completed
       before any subsequent store operation is performed.  Thus, a release fence is a two-way barrier for store
       operations.   To  denote  release  semantics,  the  suffix  “<b>_rel</b>”  is appended to the function name, for
       example, <b>atomic_thread_fence_rel</b>().

       Although <b>atomic_thread_fence_acq_rel</b>() implements both acquire and release semantics, it is  not  a  full
       barrier.   For  example,  a  store  prior  to  the fence (in program order) may be completed after a load
       subsequent to the fence.  In contrast, <b>atomic_thread_fence_seq_cst</b>() implements a full barrier.   Neither
       loads nor stores may cross this barrier in either direction.

       In C11, a release fence by one thread synchronizes with an acquire fence by another thread when an atomic
       load  that  is  prior  to the acquire fence (by program order) reads the value written by an atomic store
       that is subsequent to the release fence.  In constrast, in FreeBSD, because of the atomicity of ordinary,
       naturally aligned loads and stores, fences can also be synchronized by ordinary loads and  stores.   This
       simplifies the implementation and use of some synchronization primitives in FreeBSD.

       Since  neither  a compiler nor a processor can foresee which (atomic) load will read the value written by
       an (atomic) store, the ordering constraints imposed by fences must be more restrictive than acquire loads
       and release stores.  Essentially, this is why fences are two-way barriers.

       Although fences impose more restrictive ordering than acquire loads and  release  stores,  by  separating
       access  from  ordering,  they  can sometimes facilitate more efficient implementations of synchronization
       primitives.  For example, they can be used to avoid executing a memory  barrier  until  a  memory  access
       shows that some condition is satisfied.

   <b>Multiple</b> <b>Processors</b>
       In  multiprocessor systems, the atomicity of the atomic operations on memory depends on support for cache
       coherence in the underlying architecture.  In general,  cache  coherence  on  the  default  memory  type,
       VM_MEMATTR_DEFAULT, is guaranteed by all architectures that are supported by FreeBSD.  For example, cache
       coherence  is  guaranteed  on  write-back  memory  by the amd64 and i386 architectures.  However, on some
       architectures, cache coherence might not be enabled on all memory types.  To determine if cache coherence
       is enabled for a non-default memory type, consult the architecture's documentation.

   <b>Semantics</b>
       This section describes the semantics of each operation using a C like notation.

       <b>atomic_add</b>(<u>p</u>, <u>v</u>)
               *p += v;

       <b>atomic_clear</b>(<u>p</u>, <u>v</u>)
               *p &amp;= ~v;

       <b>atomic_cmpset</b>(<u>dst</u>, <u>old</u>, <u>new</u>)
               if (*dst == old) {
                       *dst = new;
                       return (1);
               } else
                       return (0);

       Some architectures do not implement the <b>atomic_cmpset</b>() functions for the types “<b>char</b>”, “<b>short</b>”, “<b>8</b>”, and
       “<b>16</b>”.

       <b>atomic_fcmpset</b>(<u>dst</u>, <u>*old</u>, <u>new</u>)

       On architectures implementing <u>Compare</u> <u>And</u> <u>Swap</u> operation in hardware, the functionality can be  described
       as
             if (*dst == *old) {
                     *dst = new;
                     return (1);
             } else {
                     *old = *dst;
                     return (0);
             }
       On architectures which provide <u>Load</u> <u>Linked/Store</u> <u>Conditional</u> primitive, the write to *dst might also fail
       for  several  reasons,  most  important of which is a parallel write to *dst cache line by other CPU.  In
       this case <b>atomic_fcmpset</b>() function also returns false, despite
             <b>*old</b> <b>==</b> <b>*dst</b>.

       Some architectures do not implement the <b>atomic_fcmpset</b>() functions for the types  “<b>char</b>”,  “<b>short</b>”,  “<b>8</b>”,
       and “<b>16</b>”.

       <b>atomic_fetchadd</b>(<u>p</u>, <u>v</u>)
               tmp = *p;
               *p += v;
               return (tmp);

       The <b>atomic_fetchadd</b>() functions are only implemented for the types “<b>int</b>”, “<b>long</b>” and “<b>32</b>” and do not have
       any variants with memory barriers at this time.

       <b>atomic_load</b>(<u>p</u>)
               return (*p);

       <b>atomic_readandclear</b>(<u>p</u>)
               tmp = *p;
               *p = 0;
               return (tmp);

       The  <b>atomic_readandclear</b>()  functions  are not implemented for the types “<b>char</b>”, “<b>short</b>”, “<b>ptr</b>”, “<b>8</b>”, and
       “<b>16</b>” and do not have any variants with memory barriers at this time.

       <b>atomic_set</b>(<u>p</u>, <u>v</u>)
               *p |= v;

       <b>atomic_subtract</b>(<u>p</u>, <u>v</u>)
               *p -= v;

       <b>atomic_store</b>(<u>p</u>, <u>v</u>)
               *p = v;

       <b>atomic_swap</b>(<u>p</u>, <u>v</u>)
               tmp = *p;
               *p = v;
               return (tmp);

       The <b>atomic_swap</b>() functions are not implemented for the types “<b>char</b>”, “<b>short</b>”, “<b>ptr</b>”, “<b>8</b>”, and  “<b>16</b>”  and
       do not have any variants with memory barriers at this time.

       <b>atomic_testandclear</b>(<u>p</u>, <u>v</u>)
               bit = 1 &lt;&lt; (v % (sizeof(*p) * NBBY));
               tmp = (*p &amp; bit) != 0;
               *p &amp;= ~bit;
               return (tmp);

       <b>atomic_testandset</b>(<u>p</u>, <u>v</u>)
               bit = 1 &lt;&lt; (v % (sizeof(*p) * NBBY));
               tmp = (*p &amp; bit) != 0;
               *p |= bit;
               return (tmp);

       The  <b>atomic_testandset</b>()  and  <b>atomic_testandclear</b>()  functions are only implemented for the types “<b>int</b>”,
       “<b>long</b>” and “<b>32</b>” and do not have any variants with memory barriers at this time.

       The type “<b>64</b>” is currently not implemented for some of the  atomic  operations  on  the  arm,  i386,  and
       powerpc architectures.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The  <b>atomic_cmpset</b>() function returns the result of the compare operation.  The <b>atomic_fcmpset</b>() function
       returns true if the operation succeeded.  Otherwise it returns false and sets <u>*old</u> to  the  found  value.
       The <b>atomic_fetchadd</b>(), <b>atomic_load</b>(), <b>atomic_readandclear</b>(), and <b>atomic_swap</b>() functions return the value
       at  the specified address.  The <b>atomic_testandset</b>() and <b>atomic_testandclear</b>() function returns the result
       of the test operation.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This example uses the <b>atomic_cmpset_acq_ptr</b>() and <b>atomic_set_ptr</b>() functions to obtain a sleep mutex  and
       handle recursion.  Since the <u>mtx_lock</u> member of a <u>struct</u> <u>mtx</u> is a pointer, the “<b>ptr</b>” type is used.

       /* Try to obtain mtx_lock once. */
       #define _obtain_lock(mp, tid)                                           \
               atomic_cmpset_acq_ptr(&amp;(mp)-&gt;mtx_lock, MTX_UNOWNED, (tid))

       /* Get a sleep lock, deal with recursion inline. */
       #define _get_sleep_lock(mp, tid, opts, file, line) do {                 \
               uintptr_t _tid = (uintptr_t)(tid);                              \
                                                                               \
               if (!_obtain_lock(mp, tid)) {                                   \
                       if (((mp)-&gt;mtx_lock &amp; MTX_FLAGMASK) != _tid)            \
                               _mtx_lock_sleep((mp), _tid, (opts), (file), (line));\
                       else {                                                  \
                               atomic_set_ptr(&amp;(mp)-&gt;mtx_lock, MTX_RECURSE);   \
                               (mp)-&gt;mtx_recurse++;                            \
                       }                                                       \
               }                                                               \
       } while (0)

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b>atomic_add</b>(),  <b>atomic_clear</b>(),  <b>atomic_set</b>(),  and  <b>atomic_subtract</b>()  operations were introduced in
       FreeBSD 3.0.  Initially, these operations were defined on the types “<b>char</b>”, “<b>short</b>”, “<b>int</b>”, and “<b>long</b>”.

       The <b>atomic_cmpset</b>(), <b>atomic_load_acq</b>(), <b>atomic_readandclear</b>(),  and  <b>atomic_store_rel</b>()  operations  were
       added  in FreeBSD 5.0.  Simultaneously, the acquire and release variants were introduced, and support was
       added for operation on the types “<b>8</b>”, “<b>16</b>”, “<b>32</b>”, “<b>64</b>”, and “<b>ptr</b>”.

       The <b>atomic_fetchadd</b>() operation was added in FreeBSD 6.0.

       The <b>atomic_swap</b>() and <b>atomic_testandset</b>() operations were added in FreeBSD 10.0.

       The <b>atomic_testandclear</b>() and <b>atomic_thread_fence</b>() operations were added in FreeBSD 11.0.

       The relaxed variants of <b>atomic_load</b>() and <b>atomic_store</b>() were added in FreeBSD 12.0.

Debian                                           August 18, 2019                                       <u><a href="../man9/ATOMIC.9.html">ATOMIC</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>