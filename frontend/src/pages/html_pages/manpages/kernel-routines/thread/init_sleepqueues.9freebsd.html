<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>init_sleepqueues,  sleepq_abort,  sleepq_add,  sleepq_alloc,  sleepq_broadcast, sleepq_free, sleepq_lock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       init_sleepqueues,  sleepq_abort,  sleepq_add,  sleepq_alloc,  sleepq_broadcast, sleepq_free, sleepq_lock,
       sleepq_lookup, sleepq_release, sleepq_remove, sleepq_signal, sleepq_set_timeout,  sleepq_set_timeout_sbt,
       sleepq_sleepcnt,  sleepq_timedwait,  sleepq_timedwait_sig,  sleepq_type,  sleepq_wait,  sleepq_wait_sig â€”
       manage the queues of sleeping threads

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sleepqueue.h&gt;</b>

       <u>void</u>
       <b>init_sleepqueues</b>(<u>void</u>);

       <u>int</u>
       <b>sleepq_abort</b>(<u>struct</u> <u>thread</u> <u>*td</u>);

       <u>void</u>
       <b>sleepq_add</b>(<u>void</u> <u>*wchan</u>, <u>struct</u> <u>lock_object</u> <u>*lock</u>, <u>const</u> <u>char</u> <u>*wmesg</u>, <u>int</u> <u>flags</u>, <u>int</u> <u>queue</u>);

       <u>struct</u> <u>sleepqueue</u> <u>*</u>
       <b>sleepq_alloc</b>(<u>void</u>);

       <u>int</u>
       <b>sleepq_broadcast</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>flags</u>, <u>int</u> <u>pri</u>, <u>int</u> <u>queue</u>);

       <u>void</u>
       <b>sleepq_free</b>(<u>struct</u> <u>sleepqueue</u> <u>*sq</u>);

       <u>struct</u> <u>sleepqueue</u> <u>*</u>
       <b>sleepq_lookup</b>(<u>void</u> <u>*wchan</u>);

       <u>void</u>
       <b>sleepq_lock</b>(<u>void</u> <u>*wchan</u>);

       <u>void</u>
       <b>sleepq_release</b>(<u>void</u> <u>*wchan</u>);

       <u>void</u>
       <b>sleepq_remove</b>(<u>struct</u> <u>thread</u> <u>*td</u>, <u>void</u> <u>*wchan</u>);

       <u>int</u>
       <b>sleepq_signal</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>flags</u>, <u>int</u> <u>pri</u>, <u>int</u> <u>queue</u>);

       <u>void</u>
       <b>sleepq_set_timeout</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>timo</u>);

       <u>void</u>
       <b>sleepq_set_timeout_sbt</b>(<u>void</u> <u>*wchan</u>, <u>sbintime_t</u> <u>sbt</u>, <u>sbintime_t</u> <u>pr</u>, <u>int</u> <u>flags</u>);

       <u>u_int</u>
       <b>sleepq_sleepcnt</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>queue</u>);

       <u>int</u>
       <b>sleepq_timedwait</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>pri</u>);

       <u>int</u>
       <b>sleepq_timedwait_sig</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>pri</u>);

       <u>int</u>
       <b>sleepq_type</b>(<u>void</u> <u>*wchan</u>);

       <u>void</u>
       <b>sleepq_wait</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>pri</u>);

       <u>int</u>
       <b>sleepq_wait_sig</b>(<u>void</u> <u>*wchan</u>, <u>int</u> <u>pri</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sleep queues provide a mechanism for suspending execution of a thread until some condition is met.   Each
       queue  is associated with a specific wait channel when it is active, and only one queue may be associated
       with a wait channel at any given point in time.  The implementation  of  each  wait  channel  splits  its
       sleepqueue  into 2 sub-queues in order to enable some optimizations on threads' wakeups.  An active queue
       holds a list of threads that are blocked on the associated wait channel.  Threads that are not blocked on
       a wait channel have an associated inactive sleep queue.  When a  thread  blocks  on  a  wait  channel  it
       donates its inactive sleep queue to the wait channel.  When a thread is resumed, the wait channel that it
       was blocked on gives it an inactive sleep queue for later use.

       The  <b>sleepq_alloc</b>()  function  allocates an inactive sleep queue and is used to assign a sleep queue to a
       thread during thread creation.  The  <b>sleepq_free</b>()  function  frees  the  resources  associated  with  an
       inactive sleep queue and is used to free a queue during thread destruction.

       Active sleep queues are stored in a hash table hashed on the addresses pointed to by wait channels.  Each
       bucket  in  the hash table contains a sleep queue chain.  A sleep queue chain contains a spin mutex and a
       list of sleep queues that hash to that specific chain.   Active  sleep  queues  are  protected  by  their
       chain's spin mutex.  The <b>init_sleepqueues</b>() function initializes the hash table of sleep queue chains.

       The <b>sleepq_lock</b>() function locks the sleep queue chain associated with wait channel <u>wchan</u>.

       The  <b>sleepq_lookup</b>()  returns  a  pointer  to  the  currently  active  sleep  queue for that wait channel
       associated with <u>wchan</u> or NULL if there is no active sleep  queue  associated  with  argument  <u>wchan</u>.   It
       requires  the  sleep  queue  chain  associated  with  <u>wchan</u>  to  have  been  locked  by  a  prior call to
       <b>sleepq_lock</b>().

       The <b>sleepq_release</b>() function unlocks the sleep queue chain associated  with  <b>wchan</b>()  and  is  primarily
       useful when aborting a pending sleep request before one of the wait functions is called.

       The  <b>sleepq_add</b>()  function places the current thread on the sleep queue associated with the wait channel
       <u>wchan</u>.  The sleep queue chain associated  with  argument  <u>wchan</u>  must  be  locked  by  a  prior  call  to
       <b>sleepq_lock</b>()  when  this  function  is called.  If a lock is specified via the <u>lock</u> argument, and if the
       kernel was compiled with <b>options</b> <b>INVARIANTS</b>, then the sleep queue  code  will  perform  extra  checks  to
       ensure  that  the  lock  is used by all threads sleeping on <u>wchan</u>.  The <u>wmesg</u> parameter should be a short
       description of <u>wchan</u>.  The <u>flags</u> parameter is a bitmask consisting of the type of sleep queue being slept
       on and zero or more optional flags.  The <u>queue</u> parameter specifies the sub-queue, in which the contending
       thread will be inserted.

       There are currently three types of sleep queues:

       SLEEPQ_CONDVAR  A sleep queue used to implement condition variables.
       SLEEPQ_SLEEP    A sleep queue used to implement <u><a href="../man9/sleep.9.html">sleep</a></u>(9), <u><a href="../man9/wakeup.9.html">wakeup</a></u>(9) and <u><a href="../man9/wakeup_one.9.html">wakeup_one</a></u>(9).
       SLEEPQ_PAUSE    A sleep queue used to implement <u><a href="../man9/pause.9.html">pause</a></u>(9).

       There are currently two optional flag:

       SLEEPQ_INTERRUPTIBLE  The current thread is entering an interruptible sleep.
       SLEEPQ_STOP_ON_BDRY  When thread is entering an interruptible sleep, do not stop it upon arrival of  stop
                            action, like SIGSTOP.  Wake it up instead.

       A  timeout  on  the sleep may be specified by calling <b>sleepq_set_timeout</b>() after <b>sleepq_add</b>().  The <u>wchan</u>
       parameter should be the same value from the preceding call to <b>sleepq_add</b>(), and  the  sleep  queue  chain
       associated  with <u>wchan</u> must have been locked by a prior call to <b>sleepq_lock</b>().  The <u>timo</u> parameter should
       specify the timeout value in ticks.

       <b>sleepq_set_timeout_sbt</b>() function takes <u>sbt</u> argument instead of <u>timo</u>.  It allows to specify  relative  or
       absolute  wakeup  time  with higher resolution in form of <u>sbintime_t</u>.  The parameter <u>pr</u> allows to specify
       wanted absolute event precision.  The parameter  <u>flags</u>  allows  to  pass  additional  <b>callout_reset_sbt</b>()
       flags.

       Once  the  thread  is  ready to suspend, one of the wait functions is called to put the current thread to
       sleep until it is awakened and to context switch to another thread.  The <b>sleepq_wait</b>() function  is  used
       for  non-interruptible  sleeps  that  do not have a timeout.  The <b>sleepq_timedwait</b>() function is used for
       non-interruptible sleeps that have had a timeout set  via  <b>sleepq_set_timeout</b>().   The  <b>sleepq_wait_sig</b>()
       function  is  used  for  interruptible  sleeps  that  do  not have a timeout.  The <b>sleepq_timedwait_sig</b>()
       function is used for interruptible sleeps that do have a timeout set.  The <u>wchan</u> argument to all  of  the
       wait  functions is the wait channel being slept on.  The sleep queue chain associated with argument <u>wchan</u>
       needs to have been locked with a prior call to <b>sleepq_lock</b>().  The  <u>pri</u>  argument  is  used  to  set  the
       priority of the thread when it is awakened.  If it is set to zero, the thread's priority is left alone.

       When  the thread is resumed, the wait functions return a non-zero value if the thread was awakened due to
       an interrupt other than a signal or a timeout.  If the sleep timed out, then EWOULDBLOCK is returned.  If
       the sleep was interrupted by something other than  a  signal,  then  some  other  return  value  will  be
       returned.

       A  sleeping  thread  is  normally  resumed  by the <b>sleepq_broadcast</b>() and <b>sleepq_signal</b>() functions.  The
       <b>sleepq_signal</b>() function awakens the highest priority thread sleeping on a wait channel (if SLEEPQ_UNFAIR
       flag is set, thread that went to sleep recently) while <b>sleepq_broadcast</b>()  awakens  all  of  the  threads
       sleeping  on  a  wait  channel.   The  <u>wchan</u>  argument specifics which wait channel to awaken.  The <u>flags</u>
       argument must match the sleep queue type contained in the <u>flags</u> argument passed to  <b>sleepq_add</b>()  by  the
       threads  sleeping  on  the wait channel.  If the <u>pri</u> argument does not equal -1, then each thread that is
       awakened will have its priority raised to <u>pri</u> if  it  has  a  lower  priority.   The  sleep  queue  chain
       associated  with  argument  <u>wchan</u>  must  be locked by a prior call to <b>sleepq_lock</b>() before calling any of
       these functions.  The <u>queue</u> argument specifies the sub-queue, from which threads need to be woken up.

       A thread in an interruptible sleep can be interrupted by another thread via the <b>sleepq_abort</b>()  function.
       The  <u>td</u>  argument  specifies  the  thread  to  interrupt.  An individual thread can also be awakened from
       sleeping on a specific wait channel via the <b>sleepq_remove</b>() function.   The  <u>td</u>  argument  specifies  the
       thread  to  awaken and the <u>wchan</u> argument specifies the wait channel to awaken it from.  If the thread <u>td</u>
       is not blocked on the wait channel <u>wchan</u> then this function will not do anything, even if the  thread  is
       asleep  on  a  different  wait  channel.  This function should only be used if one of the other functions
       above is not sufficient.  One possible use is waking up a specific thread  from  a  widely  shared  sleep
       channel.

       The  <b>sleepq_sleepcnt</b>()  function  offer  a  simple way to retrieve the number of threads sleeping for the
       specified <u>queue</u>, given a <u>wchan</u>.

       The <b>sleepq_type</b>() function returns the type of <u>wchan</u> associated to a sleepqueue.

       The <b>sleepq_abort</b>(), <b>sleepq_broadcast</b>(), and <b>sleepq_signal</b>() functions all return a boolean value.  If the
       return value is true, then at least one thread was resumed that is currently swapped out.  The caller  is
       responsible for awakening the scheduler process so that the resumed thread will be swapped back in.  This
       is  done  by  calling  the <b>kick_proc0</b>() function after releasing the sleep queue chain lock via a call to
       <b>sleepq_release</b>().

       The sleep queue interface is currently used to implement the <u><a href="../man9/sleep.9.html">sleep</a></u>(9) and <u><a href="../man9/condvar.9.html">condvar</a></u>(9) interfaces.   Almost
       all  other  code  in  the kernel should use one of those interfaces rather than manipulating sleep queues
       directly.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/condvar.9.html">condvar</a></u>(9), <u><a href="../man9/runqueue.9.html">runqueue</a></u>(9), <u><a href="../man9/scheduler.9.html">scheduler</a></u>(9), <u><a href="../man9/sleep.9.html">sleep</a></u>(9), <u><a href="../man9/timeout.9.html">timeout</a></u>(9)

Debian                                            June 19, 2019                                    <u><a href="../man9/SLEEPQUEUE.9.html">SLEEPQUEUE</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>