<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSCTL_DECL,     SYSCTL_ADD_INT,     SYSCTL_ADD_LONG,     SYSCTL_ADD_NODE,    SYSCTL_ADD_NODE_WITH_LABEL,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SYSCTL_DECL,     SYSCTL_ADD_INT,     SYSCTL_ADD_LONG,     SYSCTL_ADD_NODE,    SYSCTL_ADD_NODE_WITH_LABEL,
       SYSCTL_ADD_OPAQUE, SYSCTL_ADD_PROC, SYSCTL_ADD_QUAD, SYSCTL_ADD_ROOT_NODE, SYSCTL_ADD_S8, SYSCTL_ADD_S16,
       SYSCTL_ADD_S32,   SYSCTL_ADD_S64,    SYSCTL_ADD_STRING,    SYSCTL_ADD_CONST_STRING,    SYSCTL_ADD_STRUCT,
       SYSCTL_ADD_TIMEVAL_SEC,  SYSCTL_ADD_U8, SYSCTL_ADD_U16, SYSCTL_ADD_U32, SYSCTL_ADD_U64, SYSCTL_ADD_UAUTO,
       SYSCTL_ADD_UINT,    SYSCTL_ADD_ULONG,    SYSCTL_ADD_UQUAD,    SYSCTL_CHILDREN,    SYSCTL_STATIC_CHILDREN,
       SYSCTL_NODE_CHILDREN,       SYSCTL_PARENT,      SYSCTL_INT,      SYSCTL_INT_WITH_LABEL,      SYSCTL_LONG,
       sysctl_msec_to_ticks,  SYSCTL_NODE,  SYSCTL_NODE_WITH_LABEL,  SYSCTL_OPAQUE,  SYSCTL_PROC,   SYSCTL_QUAD,
       SYSCTL_ROOT_NODE,  SYSCTL_S8,  SYSCTL_S16,  SYSCTL_S32,  SYSCTL_S64,  SYSCTL_STRING, SYSCTL_CONST_STRING,
       SYSCTL_STRUCT,  SYSCTL_TIMEVAL_SEC,   SYSCTL_U8,   SYSCTL_U16,   SYSCTL_U32,   SYSCTL_U64,   SYSCTL_UINT,
       SYSCTL_ULONG, SYSCTL_UQUAD â€” Dynamic and static sysctl MIB creation functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sysctl.h&gt;</b>

       <b>SYSCTL_DECL</b>(<u>name</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_INT</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>int</u> <u>*ptr</u>, <u>int</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_LONG</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,          <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,         <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>long</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_NODE</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,          <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>int</u> <u>(*handler)(SYSCTL_HANDLER_ARGS)</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_NODE_WITH_LABEL</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,    <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,    <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>,     <u>int</u> <u>ctlflags</u>,      <u>int</u> <u>(*handler)(SYSCTL_HANDLER_ARGS)</u>,      <u>const</u> <u>char</u> <u>*descr</u>,
           <u>const</u> <u>char</u> <u>*label</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_OPAQUE</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,        <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>void</u> <u>*ptr</u>, <u>intptr_t</u> <u>len</u>, <u>const</u> <u>char</u> <u>*format</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_PROC</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,          <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>,   <u>int</u> <u>ctlflags</u>,  <u>void</u> <u>*arg1</u>,  <u>intptr_t</u> <u>arg2</u>,  <u>int</u> <u>(*handler)</u> <u>(SYSCTL_HANDLER_ARGS)</u>,
           <u>const</u> <u>char</u> <u>*format</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_QUAD</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,          <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>int64_t</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_ROOT_NODE</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,     <u>int</u> <u>number</u>,     <u>const</u> <u>char</u> <u>*name</u>,     <u>int</u> <u>ctlflags</u>,
           <u>int</u> <u>(*handler)(SYSCTL_HANDLER_ARGS)</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_S8</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>,  <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>int8_t</u> <u>*ptr</u>, <u>int8_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_S16</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>int16_t</u> <u>*ptr</u>, <u>int16_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_S32</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>int32_t</u> <u>*ptr</u>, <u>int32_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_S64</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>int64_t</u> <u>*ptr</u>, <u>int64_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_STRING</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,        <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>char</u> <u>*ptr</u>, <u>intptr_t</u> <u>len</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_CONST_STRING</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,     <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,      <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>const</u> <u>char</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_STRUCT</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,        <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>void</u> <u>*ptr</u>, <u>struct_type</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_TIMEVAL_SEC</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,      <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,      <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>struct</u> <u>timeval</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_U8</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,  <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>uint8_t</u> <u>*ptr</u>, <u>uint8_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_U16</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>uint16_t</u> <u>*ptr</u>, <u>uint16_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_U32</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>uint32_t</u> <u>*ptr</u>, <u>uint32_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_U64</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>, <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>, <u>int</u> <u>number</u>, <u>const</u> <u>char</u> <u>*name</u>,
           <u>int</u> <u>ctlflags</u>, <u>uint64_t</u> <u>*ptr</u>, <u>uint64_t</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_UINT</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,          <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>unsigned</u> <u>int</u> <u>*ptr</u>, <u>unsigned</u> <u>int</u> <u>val</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_ULONG</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,         <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>unsigned</u> <u>long</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_UQUAD</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,         <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>uint64_t</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_ADD_UAUTO</b>(<u>struct</u> <u>sysctl_ctx_list</u> <u>*ctx</u>,         <u>struct</u> <u>sysctl_oid_list</u> <u>*parent</u>,         <u>int</u> <u>number</u>,
           <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>ctlflags</u>, <u>void</u> <u>*ptr</u>, <u>const</u> <u>char</u> <u>*descr</u>);

       <u>struct</u> <u>sysctl_oid_list</u> <u>*</u>
       <b>SYSCTL_CHILDREN</b>(<u>struct</u> <u>sysctl_oid</u> <u>*oidp</u>);

       <u>struct</u> <u>sysctl_oid_list</u> <u>*</u>
       <b>SYSCTL_STATIC_CHILDREN</b>(<u>struct</u> <u>sysctl_oid_list</u> <u>OID_NAME</u>);

       <u>struct</u> <u>sysctl_oid_list</u> <u>*</u>
       <b>SYSCTL_NODE_CHILDREN</b>(<u>parent</u>, <u>name</u>);

       <u>struct</u> <u>sysctl_oid</u> <u>*</u>
       <b>SYSCTL_PARENT</b>(<u>struct</u> <u>sysctl_oid</u> <u>*oid</u>);

       <b>SYSCTL_INT</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_INT_WITH_LABEL</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>, <u>label</u>);

       <b>SYSCTL_LONG</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <u>int</u>
       <b>sysctl_msec_to_ticks</b>(<u>SYSCTL_HANDLER_ARGS</u>);

       <b>SYSCTL_NODE</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>handler</u>, <u>descr</u>);

       <b>SYSCTL_NODE_WITH_LABEL</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>handler</u>, <u>descr</u>, <u>label</u>);

       <b>SYSCTL_OPAQUE</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>len</u>, <u>format</u>, <u>descr</u>);

       <b>SYSCTL_PROC</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>arg1</u>, <u>arg2</u>, <u>handler</u>, <u>format</u>, <u>descr</u>);

       <b>SYSCTL_QUAD</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_ROOT_NODE</b>(<u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>handler</u>, <u>descr</u>);

       <b>SYSCTL_S8</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_S16</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_S32</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_S64</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_STRING</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>arg</u>, <u>len</u>, <u>descr</u>);

       <b>SYSCTL_CONST_STRING</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>arg</u>, <u>descr</u>);

       <b>SYSCTL_STRUCT</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>struct_type</u>, <u>descr</u>);

       <b>SYSCTL_TIMEVAL_SEC</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>descr</u>);

       <b>SYSCTL_U8</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_U16</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_U32</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_U64</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_UINT</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_ULONG</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

       <b>SYSCTL_UQUAD</b>(<u>parent</u>, <u>number</u>, <u>name</u>, <u>ctlflags</u>, <u>ptr</u>, <u>val</u>, <u>descr</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>SYSCTL</b> kernel interface allows dynamic or static creation  of  <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)  MIB  entries.   All  static
       sysctls  are  automatically destroyed when the module which they are part of is unloaded.  Most top level
       categories are created statically and are available to all kernel code and its modules.

</pre><h4><b>DESCRIPTION</b> <b>OF</b> <b>ARGUMENTS</b></h4><pre>
       <u>ctx</u>       Pointer to sysctl context or NULL, if no context.  See <u><a href="../man9/sysctl_ctx_init.9.html">sysctl_ctx_init</a></u>(9) for how to  create  a
                 new  sysctl  context.  Programmers are strongly advised to use contexts to organize the dynamic
                 OIDs which they create because when a context is destroyed all belonging sysctls are  destroyed
                 as  well.   This makes the sysctl cleanup code much simpler.  Else deletion of all created OIDs
                 is required at module unload.

       <u>parent</u>    A pointer to a <b>struct</b> <b>sysctl_oid_list</b>, which is the head of  the  parent's  list  of  children.
                 This  pointer  is retrieved using the <b>SYSCTL_STATIC_CHILDREN</b>() macro for static sysctls and the
                 <b>SYSCTL_CHILDREN</b>() macro for dynamic sysctls.  The <b>SYSCTL_PARENT</b>() macro can be used to get  the
                 parent of an OID.  The macro returns NULL if there is no parent.

       <u>number</u>    The  OID  number  that will be assigned to this OID.  In almost all cases this should be set to
                 OID_AUTO, which will result in the assignment of the next available OID number.

       <u>name</u>      The name of the OID.  The newly created OID will contain a copy of the name.

       <u>ctlflags</u>  A bit mask of sysctl control flags.  See the section below describing all the control flags.

       <u>arg1</u>      First callback argument for procedure sysctls.

       <u>arg2</u>      Second callback argument for procedure sysctls.

       <u>len</u>       The length of the data pointed to by the <u>ptr</u> argument.  For string type OIDs a length  of  zero
                 means that <u><a href="../man3/strlen.3.html">strlen</a></u>(3) will be used to get the length of the string at each access to the OID.

       <u>ptr</u>       Pointer   to   sysctl  variable  or  string  data.   For  sysctl  values  the  pointer  can  be
                 SYSCTL_NULL_XXX_PTR which means the OID is read-only and the returned  value  should  be  taken
                 from the <u>val</u> argument.

       <u>val</u>       If  the  <u>ptr</u>  argument  is  SYSCTL_NULL_XXX_PTR, gives the constant value returned by this OID.
                 Else this argument is not used.

       <u>struct_type</u>
                 Name of structure type.

       <u>handler</u>   A pointer to the function that is responsible for handling read and write requests to this OID.
                 There are several standard handlers that support operations on  nodes,  integers,  strings  and
                 opaque  objects.  It is possible to define custom handlers using the <b>SYSCTL_PROC</b>() macro or the
                 <b>SYSCTL_ADD_PROC</b>() function.

       <u>format</u>    A pointer to a string which specifies the format of the OID in a symbolic way.  This format  is
                 used as a hint by <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) to apply proper data formatting for display purposes.

                 Current formats:
                       <b>N</b>       node
                       <b>A</b>       <b>char</b> <b>*</b>
                       <b>I</b>       <b>int</b>
                       <b>IK</b>[<u>n</u>]   temperature  in  Kelvin,  multiplied  by  an  optional  single digit power of ten
                               scaling factor: 1 (default) gives deciKelvin, 0 gives Kelvin, 3 gives milliKelvin
                       <b>IU</b>      <b>unsigned</b> <b>int</b>
                       <b>L</b>       <b>long</b>
                       <b>LU</b>      <b>unsigned</b> <b>long</b>
                       <b>Q</b>       <b>quad_t</b>
                       <b>QU</b>      <b>u_quad_t</b>
                       <b>S,TYPE</b>  <b>struct</b> <b>TYPE</b> structures

       <u>descr</u>     A pointer to a textual description of the OID.

       <u>label</u>     A pointer to an aggregation label for this component of the OID.  To make it easier  to  export
                 sysctl  data to monitoring systems that support aggregations through labels (e.g., Prometheus),
                 this argument can be used to attach a label name to an OID.  The label acts as a hint that this
                 component's name should not be part of the metric's name, but attached to the metric as a label
                 instead.

                 Labels should only be applied to siblings that are structurally similar  and  encode  the  same
                 type of value, as aggregation is of no use otherwise.

</pre><h4><b>NODE</b> <b>VALUE</b> <b>TYPES</b></h4><pre>
       Most  of  the  macros  and functions used to create sysctl nodes export a read-only constant or in-kernel
       variable whose type matches the type of the node's value.  For  example,  <b>SYSCTL_INT</b>()  reports  the  raw
       value  of  an  associated  variable  of  type  <u>int</u>.   However,  nodes  may  also export a value that is a
       translatation of an internal representation.

       The <b>sysctl_msec_to_ticks</b>() handler can be used  with  <b>SYSCTL_PROC</b>()  or  <b>SYSCTL_ADD_PROC</b>()  to  export  a
       millisecond  time  interval.  When using this handler, the <u>arg2</u> parameter points to an in-kernel variable
       of  type  <u>int</u>  which  stores  a  tick  count  suitable  for  use  with  functions  like  <u><a href="../man9/tsleep.9.html">tsleep</a></u>(9).   The
       <b>sysctl_msec_to_ticks</b>()  function  converts  this  value  to milliseconds when reporting the node's value.
       Similarly, <b>sysctl_msec_to_ticks</b>() accepts new values in milliseconds and stores an  equivalent  value  in
       ticks to <u>*arg2</u>.

       The  <b>SYSCTL_ADD_TIMEVAL_SEC</b>()  function  and  <b>SYSCTL_TIMEVAL_SEC</b>() macro create nodes which export an in-
       kernel variable of type <u>struct</u> <u>timeval</u>.   These  nodes  do  not  export  full  value  of  the  associated
       structure.   Instead,  they  export  a count in seconds as a simple integer which is stored in the <u>tv_sec</u>
       field of the associated variable.  This function and macro are intended to be used with  variables  which
       store  a  non-negative interval rather than an absolute time.  As a result, they reject attempts to store
       negative values.

</pre><h4><b>CREATING</b> <b>ROOT</b> <b>NODES</b></h4><pre>
       Sysctl MIBs or OIDs are created in a hierarchical tree.  The nodes at the bottom of the tree  are  called
       root  nodes,  and  have  no  parent OID.  To create bottom tree nodes the <b>SYSCTL_ROOT_NODE</b>() macro or the
       <b>SYSCTL_ADD_ROOT_NODE</b>() function needs to be used.  By default all static sysctl node OIDs are global  and
       need  a  <b>SYSCTL_DECL</b>()  statement  prior  to their <b>SYSCTL_NODE</b>() definition statement, typically in a so-
       called header file.

</pre><h4><b>CREATING</b> <b>SYSCTL</b> <b>STRINGS</b></h4><pre>
       Zero terminated character strings sysctls are created either  using  the  <b>SYSCTL_STRING</b>()  macro  or  the
       <b>SYSCTL_ADD_STRING</b>() function.  If the <u>len</u> argument in zero, the string length is computed at every access
       to  the  OID  using  <u><a href="../man3/strlen.3.html">strlen</a></u>(3).   Use  the  <b>SYSCTL_CONST_STRING</b>()  macro or the <b>SYSCTL_ADD_CONST_STRING</b>()
       function to add a sysctl for a constant string.

</pre><h4><b>CREATING</b> <b>OPAQUE</b> <b>SYSCTLS</b></h4><pre>
       The <b>SYSCTL_OPAQUE</b>() or <b>SYSCTL_STRUCT</b>() macros or the <b>SYSCTL_ADD_OPAQUE</b>() or <b>SYSCTL_ADD_STRUCT</b>() functions
       create an OID that handle any chunk of data of the size specified by the <u>len</u> argument and data pointed to
       by the <u>ptr</u> argument.  When using the structure version the type is encoded as part of the created sysctl.

</pre><h4><b>CREATING</b> <b>CUSTOM</b> <b>SYSCTLS</b></h4><pre>
       The <b>SYSCTL_PROC</b>() macro and the  <b>SYSCTL_ADD_PROC</b>()  function  create  OIDs  with  the  specified  <u>handler</u>
       function.  The handler is responsible for handling all read and write requests to the OID.  This OID type
       is  especially  useful  if  the  kernel  data  is  not easily accessible, or needs to be processed before
       exporting.

</pre><h4><b>CREATING</b> <b>A</b> <b>STATIC</b> <b>SYSCTL</b></h4><pre>
       Static sysctls are declared  using  one  of  the  <b>SYSCTL_INT</b>(),  <b>SYSCTL_INT_WITH_LABEL</b>(),  <b>SYSCTL_LONG</b>(),
       <b>SYSCTL_NODE</b>(),      <b>SYSCTL_NODE_WITH_LABEL</b>(),      <b>SYSCTL_OPAQUE</b>(),     <b>SYSCTL_PROC</b>(),     <b>SYSCTL_QUAD</b>(),
       <b>SYSCTL_ROOT_NODE</b>(),   <b>SYSCTL_S8</b>(),    <b>SYSCTL_S16</b>(),    <b>SYSCTL_S32</b>(),    <b>SYSCTL_S64</b>(),    <b>SYSCTL_STRING</b>(),
       <b>SYSCTL_CONST_STRING</b>(),  <b>SYSCTL_STRUCT</b>(),  <b>SYSCTL_TIMEVAL_SEC</b>(),  <b>SYSCTL_U8</b>(), <b>SYSCTL_U16</b>(), <b>SYSCTL_U32</b>(),
       <b>SYSCTL_U64</b>(), <b>SYSCTL_UINT</b>(), <b>SYSCTL_ULONG</b>() or <b>SYSCTL_UQUAD</b>() macros.

</pre><h4><b>CREATING</b> <b>A</b> <b>DYNAMIC</b> <b>SYSCTL</b></h4><pre>
       Dynamic nodes are created  using  one  of  the  <b>SYSCTL_ADD_INT</b>(),  <b>SYSCTL_ADD_LONG</b>(),  <b>SYSCTL_ADD_NODE</b>(),
       <b>SYSCTL_ADD_NODE_WITH_LABEL</b>(),       <b>SYSCTL_ADD_OPAQUE</b>(),       <b>SYSCTL_ADD_PROC</b>(),      <b>SYSCTL_ADD_QUAD</b>(),
       <b>SYSCTL_ADD_ROOT_NODE</b>(),   <b>SYSCTL_ADD_S8</b>(),    <b>SYSCTL_ADD_S16</b>(),    <b>SYSCTL_ADD_S32</b>(),    <b>SYSCTL_ADD_S64</b>(),
       <b>SYSCTL_ADD_STRING</b>(),     <b>SYSCTL_ADD_CONST_STRING</b>(),     <b>SYSCTL_ADD_STRUCT</b>(),    <b>SYSCTL_ADD_TIMEVAL_SEC</b>(),
       <b>SYSCTL_ADD_U8</b>(),    <b>SYSCTL_ADD_U16</b>(),     <b>SYSCTL_ADD_U32</b>(),     <b>SYSCTL_ADD_U64</b>(),     <b>SYSCTL_ADD_UAUTO</b>(),
       <b>SYSCTL_ADD_UINT</b>(),   <b>SYSCTL_ADD_ULONG</b>(),   or  <b>SYSCTL_UQUAD</b>()  functions.   See  <u><a href="../man9/sysctl_remove_oid.9.html">sysctl_remove_oid</a></u>(9)  or
       <u><a href="../man9/sysctl_ctx_free.9.html">sysctl_ctx_free</a></u>(9) for more information on how to destroy a dynamically created OID.

</pre><h4><b>CONTROL</b> <b>FLAGS</b></h4><pre>
       For most of the above functions and macros, declaring a type as part of the access flags is not necessary
       â€” however, when declaring a sysctl implemented by a function, including a type  in  the  access  mask  is
       required:

       CTLTYPE_NODE     This is a node intended to be a parent for other nodes.

       CTLTYPE_INT      This is a signed integer.

       CTLTYPE_STRING   This is a nul-terminated string stored in a character array.

       CTLTYPE_S8       This is an 8-bit signed integer.

       CTLTYPE_S16      This is a 16-bit signed integer.

       CTLTYPE_S32      This is a 32-bit signed integer.

       CTLTYPE_S64      This is a 64-bit signed integer.

       CTLTYPE_OPAQUE   This is an opaque data structure.

       CTLTYPE_STRUCT   Alias for CTLTYPE_OPAQUE.

       CTLTYPE_U8       This is an 8-bit unsigned integer.

       CTLTYPE_U16      This is a 16-bit unsigned integer.

       CTLTYPE_U32      This is a 32-bit unsigned integer.

       CTLTYPE_U64      This is a 64-bit unsigned integer.

       CTLTYPE_UINT     This is an unsigned integer.

       CTLTYPE_LONG     This is a signed long.

       CTLTYPE_ULONG    This is an unsigned long.

       All sysctl types except for new node declarations require one of the following flags to be set indicating
       the read and write disposition of the sysctl:

       CTLFLAG_RD       This is a read-only sysctl.

       CTLFLAG_RDTUN    This  is  a  read-only  sysctl  and  tunable which is tried fetched once from the system
                        environment early during module load or system boot.

       CTLFLAG_WR       This is a writable sysctl.

       CTLFLAG_RW       This sysctl is readable and writable.

       CTLFLAG_RWTUN    This is a readable and writeable sysctl and tunable which is tried fetched once from the
                        system environment early during module load or system boot.

       CTLFLAG_NOFETCH  In case the node is marked as a  tunable  using  the  CTLFLAG_[XX]TUN,  this  flag  will
                        prevent  fetching  the  initial  value from the system environment.  Typically this flag
                        should only be used for very early low level  system  setup  code,  and  not  by  common
                        drivers and modules.

       CTLFLAG_MPSAFE   This  <u><a href="../man9/sysctl.9.html">sysctl</a></u>(9)  handler  is  MP  safe.  Do not grab Giant around calls to this handler.
                        This should only be used for <b>SYSCTL_PROC</b>() entries.

       Additionally, any of the following optional flags may also be specified:

       CTLFLAG_ANYBODY  Any user or process can write to this sysctl.

       CTLFLAG_CAPRD    A process in capability mode can read from this sysctl.

       CTLFLAG_CAPWR    A process in capability mode can write to this sysctl.

       CTLFLAG_SECURE   This sysctl can be written to only if the effective securelevel of the process is â‰¤ 0.

       CTLFLAG_PRISON   This sysctl can be written to by processes in <u><a href="../man2/jail.2.html">jail</a></u>(2).

       CTLFLAG_SKIP     When iterating the sysctl name space, do not list this sysctl.

       CTLFLAG_TUN      Advisory flag that a system tunable also exists for this variable.  The  initial  sysctl
                        value  is  tried  fetched  once  from the system environment early during module load or
                        system boot.

       CTLFLAG_DYN      Dynamically created OIDs automatically get this flag set.

       CTLFLAG_VNET     OID references a VIMAGE-enabled variable.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Sample use of <b>SYSCTL_DECL</b>() to declare the <u>security</u> sysctl tree for use by new nodes:

             SYSCTL_DECL(_security);

       Examples of integer, opaque, string, and procedure sysctls follow:

             /*
              * Example of a constant integer value.  Notice that the control
              * flags are CTLFLAG_RD, the variable pointer is SYSCTL_NULL_INT_PTR,
              * and the value is declared.
              */
             SYSCTL_INT(_debug_sizeof, OID_AUTO, bio, CTLFLAG_RD, SYSCTL_NULL_INT_PTR,
                 sizeof(struct bio), "sizeof(struct bio)");

             /*
              * Example of a variable integer value.  Notice that the control
              * flags are CTLFLAG_RW, the variable pointer is set, and the
              * value is 0.
              */
             static int      doingcache = 1;         /* 1 =&gt; enable the cache */
             SYSCTL_INT(_debug, OID_AUTO, vfscache, CTLFLAG_RW, &amp;doingcache, 0,
                 "Enable name cache");

             /*
              * Example of a variable string value.  Notice that the control
              * flags are CTLFLAG_RW, that the variable pointer and string
              * size are set.  Unlike newer sysctls, this older sysctl uses a
              * static oid number.
              */
             char kernelname[MAXPATHLEN] = "/kernel";        /* XXX bloat */
             SYSCTL_STRING(_kern, KERN_BOOTFILE, bootfile, CTLFLAG_RW,
                 kernelname, sizeof(kernelname), "Name of kernel file booted");

             /*
              * Example of an opaque data type exported by sysctl.  Notice that
              * the variable pointer and size are provided, as well as a format
              * string for <a href="../man8/sysctl.8.html">sysctl</a>(8).
              */
             static l_fp pps_freq;   /* scaled frequency offset (ns/s) */
             SYSCTL_OPAQUE(_kern_ntp_pll, OID_AUTO, pps_freq, CTLFLAG_RD,
                 &amp;pps_freq, sizeof(pps_freq), "I", "");

             /*
              * Example of a procedure based sysctl exporting string
              * information.  Notice that the data type is declared, the NULL
              * variable pointer and 0 size, the function pointer, and the
              * format string for <a href="../man8/sysctl.8.html">sysctl</a>(8).
              */
             SYSCTL_PROC(_kern_timecounter, OID_AUTO, hardware, CTLTYPE_STRING |
                 CTLFLAG_RW, NULL, 0, sysctl_kern_timecounter_hardware, "A",
                 "");

       The following is an example of how to create a new top-level category and how to hook up another  subtree
       to  an  existing static node.  This example does not use contexts, which results in tedious management of
       all intermediate oids, as they need to be freed later on:

             #include &lt;sys/sysctl.h&gt;
              ...
             /*
              * Need to preserve pointers to newly created subtrees,
              * to be able to free them later:
              */
             static struct sysctl_oid *root1;
             static struct sysctl_oid *root2;
             static struct sysctl_oid *oidp;
             static int a_int;
             static char *string = "dynamic sysctl";
              ...

             root1 = SYSCTL_ADD_ROOT_NODE(NULL,
                     OID_AUTO, "newtree", CTLFLAG_RW, 0, "new top level tree");
             oidp = SYSCTL_ADD_INT(NULL, SYSCTL_CHILDREN(root1),
                     OID_AUTO, "newint", CTLFLAG_RW, &amp;a_int, 0, "new int leaf");
              ...
             root2 = SYSCTL_ADD_NODE(NULL, SYSCTL_STATIC_CHILDREN(_debug),
                     OID_AUTO, "newtree", CTLFLAG_RW, 0, "new tree under debug");
             oidp = SYSCTL_ADD_STRING(NULL, SYSCTL_CHILDREN(root2),
                     OID_AUTO, "newstring", CTLFLAG_RD, string, 0, "new string leaf");

       This example creates the following subtrees:

             debug.newtree.newstring
             newtree.newint

       <u>Care</u> <u>should</u> <u>be</u> <u>taken</u> <u>to</u> <u>free</u> <u>all</u> <u>OIDs</u> <u>once</u> <u>they</u> <u>are</u> <u>no</u> <u>longer</u> <u>needed!</u>

</pre><h4><b>SYSCTL</b> <b>NAMING</b></h4><pre>
       When adding, modifying, or removing sysctl names, it is important to be aware that these  interfaces  may
       be used by users, libraries, applications, or documentation (such as published books), and are implicitly
       published  application  interfaces.   As  with other application interfaces, caution must be taken not to
       break existing applications, and to think about future use of new name spaces so as to avoid the need  to
       rename or remove interfaces that might be depended on in the future.

       The  semantics  chosen  for  a new sysctl should be as clear as possible, and the name of the sysctl must
       closely reflect its semantics.  Therefore the sysctl name deserves a fair amount  of  consideration.   It
       should  be  short  but  yet representative of the sysctl meaning.  If the name consists of several words,
       they should be separated by underscore characters, as in <u>compute_summary_at_mount</u>.  Underscore characters
       may be omitted only if the name consists of not more than two words, each  being  not  longer  than  four
       characters,  as in <u>bootfile</u>.  For boolean sysctls, negative logic should be totally avoided.  That is, do
       not use names like <u>no_foobar</u> or <u>foobar_disable</u>.  They are confusing and  lead  to  configuration  errors.
       Use positive logic instead: <u>foobar</u>, <u>foobar_enable</u>.

       A  temporary  sysctl  node  OID  that  should  not be relied upon must be designated as such by a leading
       underscore character in its name.  For example: <b>_</b><u>dirty_hack</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/sysctl.3.html">sysctl</a></u>(3), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8), <u><a href="../man9/sysctl_add_oid.9.html">sysctl_add_oid</a></u>(9), <u><a href="../man9/sysctl_ctx_free.9.html">sysctl_ctx_free</a></u>(9), <u><a href="../man9/sysctl_ctx_init.9.html">sysctl_ctx_init</a></u>(9), <u><a href="../man9/sysctl_remove_oid.9.html">sysctl_remove_oid</a></u>(9)

</pre><h4><b>HISTORY</b></h4><pre>
       The <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) utility first appeared in 4.4BSD.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>sysctl</b> implementation originally found in BSD has been extensively rewritten by Poul-Henning Kamp  in
       order to add support for name lookups, name space iteration, and dynamic addition of MIB nodes.

       This man page was written by Robert N. M. Watson.

</pre><h4><b>SECURITY</b> <b>CONSIDERATIONS</b></h4><pre>
       When  creating  new  sysctls,  careful  attention  should  be  paid  to  the security implications of the
       monitoring or management interface being created.  Most sysctls present in the kernel  are  read-only  or
       writable  only  by  the superuser.  Sysctls exporting extensive information on system data structures and
       operation, especially those implemented using procedures, will wish to implement access control to  limit
       the undesired exposure of information about other processes, network connections, etc.

       The following top level sysctl name spaces are commonly used:

       <u>compat</u>      Compatibility layer information.

       <u>debug</u>       Debugging information.  Various name spaces exist under <u>debug</u>.

       <u>hw</u>          Hardware and device driver information.

       <u>kern</u>        Kernel behavior tuning; generally deprecated in favor of more specific name spaces.

       <u>machdep</u>     Machine-dependent configuration parameters.

       <u>net</u>         Network subsystem.  Various protocols have name spaces under <u>net</u>.

       <u>regression</u>  Regression test configuration and information.

       <u>security</u>    Security and security-policy configuration and information.

       <u>sysctl</u>      Reserved name space for the implementation of sysctl.

       <u>user</u>        Configuration  settings  relating  to  user  application  behavior.   Generally,  configuring
                   applications using kernel sysctls is discouraged.

       <u>vfs</u>         Virtual file system configuration and information.

       <u>vm</u>          Virtual memory subsystem configuration and information.

Debian                                            June 11, 2019                                        <u><a href="../man9/SYSCTL.9.html">SYSCTL</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>