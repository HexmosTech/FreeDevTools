<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmap_quick_enter_page, pmap_quick_remove_page — manage fast, single-page kernel address space mappings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pmap_quick_enter_page, pmap_quick_remove_page — manage fast, single-page kernel address space mappings

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/param.h&gt;</b>
       <b>#include</b> <b>&lt;vm/vm.h&gt;</b>
       <b>#include</b> <b>&lt;vm/pmap.h&gt;</b>

       <u>vm_offset_t</u>
       <b>pmap_quick_enter_page</b>(<u>vm_page_t</u> <u>m</u>);

       <u>void</u>
       <b>pmap_quick_remove_page</b>(<u>vm_offset_t</u> <u>kva</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>pmap_quick_enter_page</b>()  function  accepts a single page <u>m</u>, and enters this page into a preallocated
       address in kernel virtual address (KVA) space.  This function is intended  for  temporary  mappings  that
       will only be used for a very short period, for example a copy operation on the page contents.

       The  <b>pmap_quick_remove_page</b>() function removes a mapping previously created by <b>pmap_quick_enter_page</b>() at
       <u>kva</u>, making the KVA frame used by <b>pmap_quick_enter_page</b>() available for reuse.

       On many architectures, <b>pmap_quick_enter_page</b>() uses a per-CPU pageframe.  In those cases, it must disable
       preemption on the  local  CPU.   The  corresponding  call  to  <b>pmap_quick_remove_page</b>()  then  re-enables
       preemption.  It is therefore not safe for machine-independent code to sleep or perform locking operations
       while  holding  these mappings.  Current implementations only guarantee the availability of a single page
       for the calling thread, so calls to <b>pmap_quick_enter_page</b>() must not be nested.

       <b>pmap_quick_enter_page</b>() and <b>pmap_quick_remove_page</b>() do not  sleep,  and  <b>pmap_quick_enter_page</b>()  always
       returns a valid address.  It is safe to use these functions under all types of locks except spin mutexes.
       It is also safe to use them in all thread contexts except primary interrupt context.

       The page <u>must</u> not be swapped or otherwise reused while the mapping is active.  It must be either wired or
       held, or it must belong to an unmanaged region such as I/O device memory.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>pmap_quick_enter_page</b>() function returns the kernel virtual address that is mapped to the page <u>m</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man9/pmap.9.html">pmap</a></u>(9)

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Jason A Harmening &lt;<u><a href="mailto:jah@FreeBSD.org">jah@FreeBSD.org</a></u>&gt;.

Debian                                           August 6, 2015                         <u><a href="../man9/PMAP_QUICK_ENTER_PAGE.9.html">PMAP_QUICK_ENTER_PAGE</a></u>(9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>