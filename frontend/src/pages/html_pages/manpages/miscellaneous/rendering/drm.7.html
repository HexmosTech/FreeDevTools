<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>drm - Direct Rendering Manager</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdrm-dev">libdrm-dev_2.4.125-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       drm - Direct Rendering Manager

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;xf86drm.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>Direct</u>  <u>Rendering</u>  <u>Manager</u>  (DRM)  is  a framework to manage <u>Graphics</u> <u>Processing</u> <u>Units</u> (GPUs). It is
       designed to support the needs of complex graphics devices, usually containing programmable pipelines well
       suited to 3D graphics acceleration. Furthermore, it  is  responsible  for  memory  management,  interrupt
       handling and DMA to provide a uniform interface to applications.

       In  earlier  days,  the  kernel  framework  was  solely used to provide raw hardware access to privileged
       user-space processes which implement all the hardware abstraction layers. But more and  more  tasks  were
       moved  into  the kernel. All these interfaces are based on <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) commands on the DRM character device.
       The <u>libdrm</u> library provides wrappers for these system-calls and many helpers to simplify the API.

       When a GPU is detected, the DRM system loads a driver for the detected hardware type. Each connected  GPU
       is  then  presented  to user-space via a character-device that is usually available as <b>/dev/dri/card0</b> and
       can be accessed with <b><a href="../man2/open.2.html">open</a></b>(2) and <b><a href="../man2/close.2.html">close</a></b>(2). However,  it  still  depends  on  the  graphics  driver  which
       interfaces  are available on these devices. If an interface is not available, the syscalls will fail with
       <b>EINVAL</b>.

   <b>Authentication</b>
       All DRM devices provide authentication mechanisms. Only a DRM master is allowed to  perform  mode-setting
       or  modify  core state and only one user can be DRM master at a time. See <b><a href="../man3/drmSetMaster.3.html">drmSetMaster</a></b>(3) for information
       on how to become DRM master and what the limitations are. Other DRM users can  be  authenticated  to  the
       DRM-Master via <b><a href="../man3/drmAuthMagic.3.html">drmAuthMagic</a></b>(3) so they can perform buffer allocations and rendering.

   <b>Mode-Setting</b>
       Managing  connected  monitors and displays and changing the current modes is called <u>Mode-Setting</u>. This is
       restricted to the current DRM master.  Historically, this was implemented  in  user-space,  but  new  DRM
       drivers  implement  a  kernel interface to perform mode-setting called <u>Kernel</u> <u>Mode</u> <u>Setting</u> (KMS). If your
       hardware-driver supports it, you  can  use  the  KMS  API  provided  by  DRM.  This  includes  allocating
       framebuffers, selecting modes and managing CRTCs and encoders. See <b><a href="../man7/drm-kms.7.html">drm-kms</a></b>(7) for more.

   <b>Memory</b> <b>Management</b>
       The  most  sophisticated  tasks  for  GPUs  today  is  managing  memory objects.  Textures, framebuffers,
       command-buffers and all other kinds of commands for the GPU have to be stored in memory. The  DRM  driver
       takes care of managing all memory objects, flushing caches, synchronizing access and providing CPU access
       to  GPU  memory.  All memory management is hardware driver dependent. However, two generic frameworks are
       available that are used by most DRM drivers. These are  the  <u>Translation</u>  <u>Table</u>  <u>Manager</u>  (TTM)  and  the
       <u>Graphics</u>  <u>Execution</u>  <u>Manager</u>  (GEM). They provide generic APIs to create, destroy and access buffers from
       user-space. However, there are still many differences between the drivers  so  driver-dependent  code  is
       still  needed.  Many  helpers are provided in <u>libgbm</u> (Graphics Buffer Manager) from the <u>Mesa</u> project. For
       more information on DRM memory management, see <b><a href="../man7/drm-memory.7.html">drm-memory</a></b>(7).

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Bugs in this manual should be reported to
        &lt;https://gitlab.freedesktop.org/mesa/libdrm/-/issues&gt; .

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/drm-kms.7.html">drm-kms</a></b>(7), <b><a href="../man7/drm-memory.7.html">drm-memory</a></b>(7), <b><a href="../man3/drmSetMaster.3.html">drmSetMaster</a></b>(3), <b><a href="../man3/drmAuthMagic.3.html">drmAuthMagic</a></b>(3), <b><a href="../man3/drmAvailable.3.html">drmAvailable</a></b>(3), <b><a href="../man3/drmOpen.3.html">drmOpen</a></b>(3)

                                                 September 2012                                           <u><a href="../man7/DRM.7.html">DRM</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>