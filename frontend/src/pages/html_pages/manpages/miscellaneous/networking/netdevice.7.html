<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>netdevice - low-level access to Linux network devices</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       netdevice - low-level access to Linux network devices

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/ioctl.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/net/if.h">net/if.h</a>&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This man page describes the sockets interface which is used to configure network devices.

       Linux  supports some standard ioctls to configure network devices.  They can be used on any socket's file
       descriptor regardless of the family or type.  Most of them pass an <u>ifreq</u> structure:

           struct ifreq {
               char ifr_name[IFNAMSIZ]; /* Interface name */
               union {
                   struct sockaddr ifr_addr;
                   struct sockaddr ifr_dstaddr;
                   struct sockaddr ifr_broadaddr;
                   struct sockaddr ifr_netmask;
                   struct sockaddr ifr_hwaddr;
                   short           ifr_flags;
                   int             ifr_ifindex;
                   int             ifr_metric;
                   int             ifr_mtu;
                   struct ifmap    ifr_map;
                   char            ifr_slave[IFNAMSIZ];
                   char            ifr_newname[IFNAMSIZ];
                   char           *ifr_data;
               };
           };

       <b>AF_INET6</b> is an exception.  It passes an <u>in6_ifreq</u> structure:

           struct in6_ifreq {
               struct in6_addr     ifr6_addr;
               u32                 ifr6_prefixlen;
               int                 ifr6_ifindex; /* Interface index */
           };

       Normally, the user specifies which device to affect by setting <u>ifr_name</u> to the name of the  interface  or
       <u>ifr6_ifindex</u> to the index of the interface.  All other members of the structure may share memory.

   <b>Ioctls</b>
       If  an  ioctl  is  marked  as  privileged,  then  using  it  requires  an  effective  user ID of 0 or the
       <b>CAP_NET_ADMIN</b> capability.  If this is not the case, <b>EPERM</b> will be returned.

       <b>SIOCGIFNAME</b>
              Given the <u>ifr_ifindex</u>, return the name of the interface in <u>ifr_name</u>.  This is the only ioctl which
              returns its result in <u>ifr_name</u>.

       <b>SIOCGIFINDEX</b>
              Retrieve the interface index of the interface into <u>ifr_ifindex</u>.

       <b>SIOCGIFFLAGS</b>
       <b>SIOCSIFFLAGS</b>
              Get or set the active flag word of the device.  <u>ifr_flags</u> contains a bit  mask  of  the  following
              values:
                                      Device flags
              IFF_UP            Interface is running.
              IFF_BROADCAST     Valid broadcast address set.
              IFF_DEBUG         Internal debugging flag.
              IFF_LOOPBACK      Interface is a loopback interface.
              IFF_POINTOPOINT   Interface is a point-to-point link.
              IFF_RUNNING       Resources allocated.
              IFF_NOARP         No arp protocol, L2 destination address not
                                set.
              IFF_PROMISC       Interface is in promiscuous mode.
              IFF_NOTRAILERS    Avoid use of trailers.
              IFF_ALLMULTI      Receive all multicast packets.
              IFF_MASTER        Master of a load balancing bundle.
              IFF_SLAVE         Slave of a load balancing bundle.
              IFF_MULTICAST     Supports multicast
              IFF_PORTSEL       Is able to select media type via ifmap.
              IFF_AUTOMEDIA     Auto media selection active.
              IFF_DYNAMIC       The addresses are lost when the interface
                                goes down.
              IFF_LOWER_UP      Driver signals L1 up (since Linux 2.6.17)
              IFF_DORMANT       Driver signals dormant (since Linux 2.6.17)
              IFF_ECHO          Echo sent packets (since Linux 2.6.25)

       Setting the active flag word is a privileged operation, but any process may read it.

       <b>SIOCGIFPFLAGS</b>
       <b>SIOCSIFPFLAGS</b>
              Get  or  set  extended  (private)  flags  for  the  device.   <u>ifr_flags</u> contains a bit mask of the
              following values:
                                      Private flags
              IFF_802_1Q_VLAN      Interface is 802.1Q VLAN device.
              IFF_EBRIDGE          Interface is Ethernet bridging device.
              IFF_SLAVE_INACTIVE   Interface is inactive bonding slave.
              IFF_MASTER_8023AD    Interface is 802.3ad bonding master.
              IFF_MASTER_ALB       Interface is balanced-alb bonding master.
              IFF_BONDING          Interface is a bonding master or slave.
              IFF_SLAVE_NEEDARP    Interface needs ARPs for validation.
              IFF_ISATAP           Interface is RFC4214 ISATAP interface.

       Setting the extended (private) interface flags is a privileged operation.

       <b>SIOCGIFADDR</b>
       <b>SIOCSIFADDR</b>
       <b>SIOCDIFADDR</b>
              Get, set, or delete the address of the device using <u>ifr_addr</u>, or  <u>ifr6_addr</u>  with  <u>ifr6_prefixlen</u>.
              Setting  or  deleting  the  interface  address  is  a  privileged  operation.   For compatibility,
              <b>SIOCGIFADDR</b> returns only <b>AF_INET</b> addresses, <b>SIOCSIFADDR</b> accepts <b>AF_INET</b>  and  <b>AF_INET6</b>  addresses,
              and  <b>SIOCDIFADDR</b>  deletes only <b>AF_INET6</b> addresses.  A <b>AF_INET</b> address can be deleted by setting it
              to zero via <b>SIOCSIFADDR</b>.

       <b>SIOCGIFDSTADDR</b>
       <b>SIOCSIFDSTADDR</b>
              Get  or  set  the  destination  address  of  a  point-to-point  device  using  <u>ifr_dstaddr</u>.    For
              compatibility,  only  <b>AF_INET</b> addresses are accepted or returned.  Setting the destination address
              is a privileged operation.

       <b>SIOCGIFBRDADDR</b>
       <b>SIOCSIFBRDADDR</b>
              Get or set the broadcast address for a device using <u>ifr_brdaddr</u>.  For compatibility, only  <b>AF_INET</b>
              addresses are accepted or returned.  Setting the broadcast address is a privileged operation.

       <b>SIOCGIFNETMASK</b>
       <b>SIOCSIFNETMASK</b>
              Get  or  set  the  network  mask  for a device using <u>ifr_netmask</u>.  For compatibility, only <b>AF_INET</b>
              addresses are accepted or returned.  Setting the network mask is a privileged operation.

       <b>SIOCGIFMETRIC</b>
       <b>SIOCSIFMETRIC</b>
              Get or set the metric of the device using <u>ifr_metric</u>.  This is currently not implemented; it  sets
              <u>ifr_metric</u> to 0 if you attempt to read it and returns <b>EOPNOTSUPP</b> if you attempt to set it.

       <b>SIOCGIFMTU</b>
       <b>SIOCSIFMTU</b>
              Get  or  set  the  MTU  (Maximum  Transfer  Unit) of a device using <u>ifr_mtu</u>.  Setting the MTU is a
              privileged operation.  Setting the MTU to too small values may cause kernel crashes.

       <b>SIOCGIFHWADDR</b>
       <b>SIOCSIFHWADDR</b>
              Get or set the hardware address of a device using <u>ifr_hwaddr</u>.  The hardware address  is  specified
              in  a  struct  <u>sockaddr</u>.   <u>sa_family</u>  contains  the  ARPHRD_* device type, <u>sa_data</u> the L2 hardware
              address starting from byte 0.  Setting the hardware address is a privileged operation.

       <b>SIOCSIFHWBROADCAST</b>
              Set the hardware broadcast address of a device from <u>ifr_hwaddr</u>.  This is a privileged operation.

       <b>SIOCGIFMAP</b>
       <b>SIOCSIFMAP</b>
              Get or set the interface's hardware  parameters  using  <u>ifr_map</u>.   Setting  the  parameters  is  a
              privileged operation.

                  struct ifmap {
                      unsigned long   mem_start;
                      unsigned long   mem_end;
                      unsigned short  base_addr;
                      unsigned char   irq;
                      unsigned char   dma;
                      unsigned char   port;
                  };

              The interpretation of the ifmap structure depends on the device driver and the architecture.

       <b>SIOCADDMULTI</b>
       <b>SIOCDELMULTI</b>
              Add  an  address  to  or  delete  an  address from the device's link layer multicast filters using
              <u>ifr_hwaddr</u>.  These are privileged operations.  See also <b><a href="../man7/packet.7.html">packet</a></b>(7) for an alternative.

       <b>SIOCGIFTXQLEN</b>
       <b>SIOCSIFTXQLEN</b>
              Get or set the transmit queue length of a device  using  <u>ifr_qlen</u>.   Setting  the  transmit  queue
              length is a privileged operation.

       <b>SIOCSIFNAME</b>
              Changes  the  name  of  the  interface specified in <u>ifr_name</u> to <u>ifr_newname</u>.  This is a privileged
              operation.  It is allowed only when the interface is not up.

       <b>SIOCGIFCONF</b>
              Return a list of interface (network layer) addresses.  This currently means only addresses of  the
              <b>AF_INET</b>  (IPv4)  family  for  compatibility.   Unlike  the  others,  this  ioctl  passes an <u>ifconf</u>
              structure:

                  struct ifconf {
                      int               ifc_len; /* size of buffer */
                      union {
                          char         *ifc_buf; /* buffer address */
                          struct ifreq *ifc_req; /* array of structures */
                      };
                  };

              If <u>ifc_req</u> is NULL, <b>SIOCGIFCONF</b> returns the necessary buffer  size  in  bytes  for  receiving  all
              available  addresses  in  <u>ifc_len</u>.   Otherwise,  <u>ifc_req</u>  contains  a pointer to an array of <u>ifreq</u>
              structures to be filled with all currently active L3 interface addresses.   <u>ifc_len</u>  contains  the
              size  of  the  array  in  bytes.  Within each <u>ifreq</u> structure, <u>ifr_name</u> will receive the interface
              name, and <u>ifr_addr</u> the address.  The actual number of bytes transferred is returned in <u>ifc_len</u>.

              If the size specified by <u>ifc_len</u> is insufficient to store all the addresses, the kernel will  skip
              the  exceeding ones and return success.  There is no reliable way of detecting this condition once
              it has occurred.  It is therefore recommended  to  either  determine  the  necessary  buffer  size
              beforehand  by  calling  <b>SIOCGIFCONF</b>  with <u>ifc_req</u> set to NULL, or to retry the call with a bigger
              buffer whenever <u>ifc_len</u> upon return differs by less than <u>sizeof(struct</u> <u>ifreq)</u>  from  its  original
              value.

              If an error occurs accessing the <u>ifconf</u> or <u>ifreq</u> structures, <b>EFAULT</b> will be returned.

       Most  protocols  support  their  own  ioctls  to  configure protocol-specific interface options.  See the
       protocol man pages for a description.  For configuring IP addresses, see <b><a href="../man7/ip.7.html">ip</a></b>(7).

       In addition, some devices support private ioctls.  These are not described here.

</pre><h4><b>NOTES</b></h4><pre>
       <b>SIOCGIFCONF</b> and the other ioctls that accept or return only <b>AF_INET</b> socket addresses are IP-specific  and
       perhaps should rather be documented in <b><a href="../man7/ip.7.html">ip</a></b>(7).

       The  names  of  interfaces with no addresses or that don't have the <b>IFF_RUNNING</b> flag set can be found via
       <u><a href="file:/proc/net/dev">/proc/net/dev</a></u>.

       <b>AF_INET6</b> IPv6 addresses can be read from <u><a href="file:/proc/net/if_inet6">/proc/net/if_inet6</a></u> or  via  <b><a href="../man7/rtnetlink.7.html">rtnetlink</a></b>(7).   Adding  a  new  IPv6
       address  and  deleting  an  existing  IPv6  address  can  be  done via <b>SIOCSIFADDR</b> and <b>SIOCDIFADDR</b> or via
       <b><a href="../man7/rtnetlink.7.html">rtnetlink</a></b>(7).  Retrieving or changing  destination  IPv6  addresses  of  a  point-to-point  interface  is
       possible only via <b><a href="../man7/rtnetlink.7.html">rtnetlink</a></b>(7).

</pre><h4><b>BUGS</b></h4><pre>
       glibc  2.1  is  missing  the  <u>ifr_newname</u>  macro  in  <u>&lt;net/if.h&gt;</u>.  Add the following to your program as a
       workaround:

           #ifndef ifr_newname
           #define ifr_newname     ifr_ifru.ifru_slave
           #endif

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/proc.5.html">proc</a></b>(5), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/ip.7.html">ip</a></b>(7), <b><a href="../man7/rtnetlink.7.html">rtnetlink</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                       <u><a href="../man7/netdevice.7.html">netdevice</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>