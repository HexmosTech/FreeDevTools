<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pkeys - overview of Memory Protection Keys</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pkeys - overview of Memory Protection Keys

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Memory  Protection  Keys (pkeys) are an extension to existing page-based memory permissions.  Normal page
       permissions using page tables  require  expensive  system  calls  and  TLB  invalidations  when  changing
       permissions.   Memory  Protection  Keys  provide  a  mechanism for changing protections without requiring
       modification of the page tables on every permission change.

       To use pkeys, software must first "tag" a page in the page tables with a pkey.   After  this  tag  is  in
       place,  an  application only has to change the contents of a register in order to remove write access, or
       all access to a tagged page.

       Protection keys work in conjunction with the existing <b>PROT_READ</b>, <b>PROT_WRITE</b>,  and  <b>PROT_EXEC</b>  permissions
       passed  to  system  calls  such  as  <b><a href="../man2/mprotect.2.html">mprotect</a></b>(2)  and  <b><a href="../man2/mmap.2.html">mmap</a></b>(2),  but always act to further restrict these
       traditional permission mechanisms.

       If a process performs an access that violates pkey restrictions,  it  receives  a  <b>SIGSEGV</b>  signal.   See
       <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) for details of the information available with that signal.

       To  use  the  pkeys  feature,  the processor must support it, and the kernel must contain support for the
       feature on a given processor.  As of early 2016 only future Intel x86 processors are supported, and  this
       hardware  supports  16 protection keys in each process.  However, pkey 0 is used as the default key, so a
       maximum of 15 are available for actual application use.  The default key is assigned to any memory region
       for which a pkey has not been explicitly assigned via <b><a href="../man2/pkey_mprotect.2.html">pkey_mprotect</a></b>(2).

       Protection keys have the potential to add a layer of security and reliability to applications.  But  they
       have  not  been  primarily  designed  as  a  security  feature.   For  instance,  WRPKRU  is a completely
       unprivileged instruction, so pkeys are useless in any case that an attacker controls the PKRU register or
       can execute arbitrary instructions.

       Applications should be very careful to ensure that they do not "leak"  protection  keys.   For  instance,
       before  calling  <b><a href="../man2/pkey_free.2.html">pkey_free</a></b>(2),  the application should be sure that no memory has that pkey assigned.  If
       the application left the freed pkey assigned, a future user of that pkey might inadvertently  change  the
       permissions  of  an  unrelated  data  structure,  which  could  impact security or stability.  The kernel
       currently allows in-use pkeys to have <b><a href="../man2/pkey_free.2.html">pkey_free</a></b>(2) called on them because  it  would  have  processor  or
       memory  performance  implications to perform the additional checks needed to disallow it.  Implementation
       of the necessary checks is left up to applications.  Applications may implement these checks by searching
       the <u><a href="file:/proc/">/proc/</a></u>pid<u>/smaps</u> file for memory regions with the pkey assigned.  Further  details  can  be  found  in
       <b><a href="../man5/proc.5.html">proc</a></b>(5).

       Any  application wanting to use protection keys needs to be able to function without them.  They might be
       unavailable because the hardware that the application runs on does not support them, the kernel code does
       not contain support, the kernel support has been disabled, or because the keys have all  been  allocated,
       perhaps  by  a  library  the  application  is  using.  It is recommended that applications wanting to use
       protection keys should simply  call  <b><a href="../man2/pkey_alloc.2.html">pkey_alloc</a></b>(2)  and  test  whether  the  call  succeeds,  instead  of
       attempting to detect support for the feature in any other way.

       Although  unnecessary, hardware support for protection keys may be enumerated with the <u>cpuid</u> instruction.
       Details of how to do this can be found in the Intel Software Developers Manual.  The kernel performs this
       enumeration and exposes the information in <u><a href="file:/proc/cpuinfo">/proc/cpuinfo</a></u> under the "flags" field.  The  string  "pku"  in
       this  field  indicates  hardware  support  for  protection keys and the string "ospke" indicates that the
       kernel contains and has enabled protection keys support.

       Applications using threads and protection  keys  should  be  especially  careful.   Threads  inherit  the
       protection key rights of the parent at the time of the <b><a href="../man2/clone.2.html">clone</a></b>(2), system call.  Applications should either
       ensure  that their own permissions are appropriate for child threads at the time when <b><a href="../man2/clone.2.html">clone</a></b>(2) is called,
       or ensure that each child thread can perform its own initialization of protection key rights.

   <b>Signal</b> <b>Handler</b> <b>Behavior</b>
       Each time a signal handler is invoked (including nested signals), the thread is temporarily given a  new,
       default  set  of protection key rights that override the rights from the interrupted context.  This means
       that applications must re-establish their desired protection key rights upon entering a signal handler if
       the desired rights differ from the defaults.  The rights of any interrupted context are restored when the
       signal handler returns.

       This signal behavior is unusual and is due  to  the  fact  that  the  x86  PKRU  register  (which  stores
       protection  key access rights) is managed with the same hardware mechanism (XSAVE) that manages floating-
       point registers.  The signal behavior is the same as that of floating-point registers.

   <b>Protection</b> <b>Keys</b> <b>system</b> <b>calls</b>
       The Linux kernel implements the following pkey-related system calls: <b><a href="../man2/pkey_mprotect.2.html">pkey_mprotect</a></b>(2), <b><a href="../man2/pkey_alloc.2.html">pkey_alloc</a></b>(2), and
       <b><a href="../man2/pkey_free.2.html">pkey_free</a></b>(2).

       The Linux pkey system calls are  available  only  if  the  kernel  was  configured  and  built  with  the
       <b>CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS</b> option.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below allocates a page of memory with read and write permissions.  It then writes some data
       to the memory and successfully reads it back.  After that, it attempts to allocate a protection  key  and
       disallows access to the page by using the WRPKRU instruction.  It then tries to access the page, which we
       now expect to cause a fatal signal to the application.

           $ <b>./a.out</b>
           buffer contains: 73
           about to read buffer again...
           Segmentation fault (core dumped)

   <b>Program</b> <b>source</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/mman.h&gt;

       int
       main(void)
       {
           int status;
           int pkey;
           int *buffer;

           /*
            * Allocate one page of memory.
            */
           buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,
                         MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
           if (buffer == MAP_FAILED)
               err(EXIT_FAILURE, "mmap");

           /*
            * Put some random data into the page (still OK to touch).
            */
           *buffer = __LINE__;
           printf("buffer contains: %d\n", *buffer);

           /*
            * Allocate a protection key:
            */
           pkey = pkey_alloc(0, 0);
           if (pkey == -1)
               err(EXIT_FAILURE, "pkey_alloc");

           /*
            * Disable access to any memory with "pkey" set,
            * even though there is none right now.
            */
           status = pkey_set(pkey, PKEY_DISABLE_ACCESS);
           if (status)
               err(EXIT_FAILURE, "pkey_set");

           /*
            * Set the protection key on "buffer".
            * Note that it is still read/write as far as mprotect() is
            * concerned and the previous pkey_set() overrides it.
            */
           status = pkey_mprotect(buffer, getpagesize(),
                                  PROT_READ | PROT_WRITE, pkey);
           if (status == -1)
               err(EXIT_FAILURE, "pkey_mprotect");

           printf("about to read buffer again...\n");

           /*
            * This will crash, because we have disallowed access.
            */
           printf("buffer contains: %d\n", *buffer);

           status = pkey_free(pkey);
           if (status == -1)
               err(EXIT_FAILURE, "pkey_free");

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/pkey_alloc.2.html">pkey_alloc</a></b>(2), <b><a href="../man2/pkey_free.2.html">pkey_free</a></b>(2), <b><a href="../man2/pkey_mprotect.2.html">pkey_mprotect</a></b>(2), <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)

Linux man-pages 6.9.1                              2024-06-15                                           <u><a href="../man7/pkeys.7.html">pkeys</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>