<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BindRules - ShapeTools version bind rules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libatfs1t64">libatfs1t64_1.4pl6-16.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BindRules - ShapeTools version bind rules

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  ShapeTools  version  binding  subsystem  (see  <a href="../man1/vbind.1.html">vbind</a>(1)) provides a mechanism for expressing <u>general</u>
       <u>version</u> <u>bind</u> <u>rules</u>. These rules describe on an abstract level version properties, which will  be  matched
       against  the properties of concrete versions during the version bind procedure. The goal is to select one
       or more versions from a named history in order to provides access to these version(s).   A  version  bind
       operation  is  always  performed  for exactly one history at a time. Version bind rules express something
       like

            <u>Select</u> <u>the</u> <u>most</u> <u>recent</u> <u>saved</u> <u>version.</u>
            <u>If</u> <u>there</u> <u>is</u> <u>no</u> <u>saved</u> <u>version,</u> <u>select</u> <u>the</u> <u>busy</u> <u>version.</u>

       ShapeTools however needs rules in a more formal notation to be able to interpret them. Let's see, how the
       rule above is translated into the formal notation.

       Version bind rules consist of a list of attribute expressions evaluated one after another  until  one  of
       the  expressions  leads  to a unique version identification. The expressions are separated by semicolons,
       the last expression ends with a period. The rule from above will now read:

            <u>Select</u> <u>the</u> <u>most</u> <u>recent</u> <u>saved</u> <u>version</u> <b>;</b>
            <u>Select</u> <u>the</u> <u>busy</u> <u>version</u> <b>.</b>

       Each attribute expression consist of a list of  predicates,  separated  by  commas.  The  predicates  are
       evaluated  from  left  to  right  resulting  in  a  <u>hit</u>  <u>set</u>, a set of versions fulfilling all predicates
       evaluated so far. The initial hit set for an attribute expression contains all versions of the name to be
       bound. Each predicate potentially narrows the hit set. The predicates in our rule are:

            <u>all</u> <u>saved</u> <u>versions</u> <b>,</b> <u>most</u> <u>recent</u> <u>version</u> <b>;</b>
            <u>busy</u> <u>version</u> <b>.</b>

       Remember, that each predicate bases it's selection on the hit set left by  the  predicate  before.  Hence
       exchanging  the  two  predicates in the first attribute expression may lead to different results. We will
       give more information on this topic in the section about the evaluation algorithm below. We now reach the
       final form of ShapeTools version bind rules. The predicates must be taken from a list of predefined names
       and be equipped with arguments:

            ge (status, saved) <b>,</b> max (stime) <b>;</b>
            <b>eq</b> <b>(status,</b> <b>busy)</b> <b>.</b>

       That's it so far. This is a rule how ShapeTools understands it.  It does however illustrate just a  small
       piece  of  the world of version bind rules. We will go on in this manual page with a detailed description
       of version bind rules divides into the sections

       RULE HEAD           Description of the structure of rule heads.

       EVALUATION ALGORITHM
                           The Algorithm how version bind rules are evaluated.

       NAME PATTERNS       Name patterns as first predicate in attribute expressions.

       PREDICATES          List of valid predicates.

       ATTRIBUTES          A List of predefined attribute names and some word about  the  ordering  relationship
                           between attribute values.

       EXPANSION           Description  of  the  various  types  of  expansion  such  as parameter substitution,
                           attribute and macro expansion, and command substitution.

       LEXICAL STRUCTURE   Lexical constraints for names and strings in version bind rules.

       TIPS, TRICKS, AND TRAPS
                           Some common problems.

       GRAMMAR             A complete grammar for version bind rules.

</pre><h4><b>RULE</b> <b>HEAD</b></h4><pre>
       A version bind rule consists of a rule head and a rule body. The example above shows only the rule  body.
       The  rule  head  defines  a  name  for  the  rule  and  optionally a parameter list. The name is a string
       consisting of any printable non-whitespace character except colon and parentheses. It is followed  by  an
       optional  parameter list in parentheses and a colon, delimiting the rule head. Multiple parameters in the
       list are separated by comma. Examples are

            most_recently_released:

            from_release (release_name):

            last_released (library_path, include_path):

</pre><h4><b>EVALUATION</b> <b>ALGORITHM</b></h4><pre>
       The basic idea of the rule evaluation algorithm is, that in every state of processing a <u>hit</u> <u>set</u> exists, a
       set of versions reflecting the current rule evaluation result.  The  hit  set  is  initialized  with  all
       versions  of  the  given  name  at  the beginning of each attribute expression. The attribute expressions
       predicates are processed from left to right in the order they occur. Each predicate imposes  requirements
       to  the  versions  in the hit set and eliminates all versions not fulfilling these requirements.  So, the
       hit set becomes smaller  and  smaller  during  attribute  expression  evaluation.  The  following  figure
       illustrates  this  process  together  with the rule most_recently_released defined above and the file foo
       existing as busy version and as versions 1.0 through 1.2.

           Initial hit set:    ( foo[busy], foo[1.0], foo[1.1], foo[1.2] )

           Evaluate Predicate: ge (status, saved),

           New hit set:        ( foo[1.0], foo[1.1], foo[1.2] )

           Evaluate Predicate: max (stime);

           Final hit set:      ( foo[1.2] )

       When the hit set becomes empty, that is when no version meets all the predicates evaluated  so  far,  the
       attribute  expression  <u>fails</u> and processing is finished immediately. All remaining predicates will not be
       evaluated. Even remaining predicates without influence on the hit set (for  example  message  predicates)
       will  not  be  processed.  Processing  continues  with  the  next  attribute expression. If all attribute
       expressions finish prematurely, the whole version binding fails. In  the  following  example,  the  first
       attribute expression fails and the second alternative leads to success.

           Initial hit set:    ( bar[busy] )

           Evaluate Predicate: ge (status, saved),

           New hit set (empty):( )

           Evaluate next attribute expression
           starting with initial hit set again:( bar[busy] )

           Evaluate Predicate: eq (status, busy);

           Final hit set:      ( bar[busy] )

       When evaluation reaches the end of an attribute expression without the hit set being empty, two cases are
       possible.  First,  the  hit  set contains exactly one version and everything is fine. This is usually the
       desired state and rule evaluation returns the remaining version as bind result. Second, the hit  set  may
       contain  more  than  one  version. In this case, the evaluation algorithm depends on the expected result.
       When a unique version binding is expected, this is treated as failure and evaluation  goes  on  with  the
       next  attribute  expression. Non-unique version binding regards this as success and returns the whole hit
       set.

       Extending the hit set during evaluation of an attribute expression is not possible. This would be against
       the nature of the version bind rules and would make them much more  difficult  to  understand.   Hit  set
       extension  may  only happen by letting the current attribute expression fail and begin with a new one and
       the maximum hit set.

       Failure of an attribute expression must not necessarily be caused by an empty hit set.  It  may  also  be
       caused by user interaction or by external constraints. The following rules exemplify user interaction:

           eq (state, busy), confirm (select busy version ?, y);
           ge (state, busy), max (version).

       where the user will be asked for confirmation to select the busy version, and external constraints:

           exists (otto, 1.0), eq (state, busy);
           ge (state, busy), max (version).

       where  selection  of  the  busy  version  happens  only, when version 1.0 of otto exists (this example is
       somewhat silly).  Predicates like confirm and exists don't care about  the  hit  set.  They  provide  the
       possibility  to  impose external control on the evaluation of version bind rules. An attribute expression
       may be finished prematurely and control switches to the next one.

       There is another operator, the cut operator, that forces the whole bind operation to finish  (and  fail).
       Typically  the  cut  operator stands at the end of an attribute expression that should never succeed. The
       following is a typical example for use of this. Version binding fails, if there is an update lock set  on
       the most recent version.

           max (version), hasattr (locker), cut (history is locked !);
           max (version).

       The cut operator accepts a string argument that will be written to the standard output.

</pre><h4><b>NAME</b> <b>PATTERNS</b></h4><pre>
       Each  attribute  expression may start with a pattern, against which the name to be bound is matched. Only
       when the name matches the pattern, the corresponding attribute expression will be evaluated. If not,  the
       attribute expression will be skipped.  When the pattern is omitted in the attribute expression (as in our
       example above), the expression is evaluated for each name.

       The patterns are the same as those recognized by <a href="../man1/sh.1.html">sh</a>(1) for filename generation on the command line. Magic
       cookies are:

       <b>*</b>       matching any string, including the empty string,

       <b>?</b>       matching any single character,

       <b>[c...]</b>  matching any one of the characters enclosed in the square brackets,

       <b>[l-r]</b>   matching any character lexically between the left (<b>l</b>) and the right (<b>r</b>) character, inclusive, and

       <b>[!c...]</b>

       <b>[!l-r]</b>  matching any character not recognized by their counterparts above.

       A rule with name patterns for example looks like:

           xyyz.h, eq (version, 1.3);
           *.c,    eq (generation, 2), max (revision);
           *.h,    eq (generation, 3), max (revision).

       In  this example, version binding for C source files (most recent version from generation 2) is different
       from version binding for header files (most recent version from generation  3).  Additionally,  the  name
       xyyz.h will always be bound to version 1.3.

       If  the  name  to be bound is given together with a (absolute or relative) pathname, this will <u>not</u> be cut
       off. The match is always performed lexically for the whole name given. Hence, the name pattern  may  also
       contain path names, like

           variant1/*, eq (alias, var1-1.4);
           variant2/*, eq (alias, var2-1.2);
           /usr/sample/include/*.h,max (revision).

       Usually,  the  version  bind subsystem does not check, if different path prefixes in the name pattern and
       the given name to be bound lead to the same location. The match is done lexically and must  fit  exactly.
       An  exception  is,  when  the  name  pattern  is given as network path name as in <a href="../man3/atnetwork.3.html">atnetwork</a>(3). A network
       pathname consists of the name of the host,  controlling  the  device  where  a  version  is  stored,  the
       canonical  pathname  to  the  version and a version binding (e.g. version number, version alias, or date)
       either in brackets or separated from the name by an at (@) sign. Examples are

           desaster:/usr/sample/project/foo.c[1.0];
           desaster:/usr/sample/project/variant1/bar.c[var1-1.4];
           desaster:/usr/sample/project/<a href="mailto:xyyz.h@1.3">xyyz.h@1.3</a>;
           desaster:/usr/sample/project/bar.c@Fri Jun 18 13:40:58 MET DST 1993.

       Network pathnames are mapped to canonical local pathnames before being processes and in  this  case,  the
       given name to be bound will also be mapped to a canonical local pathname.

       The  technique  using  network  pathnames  is  especially  useful when storing the result of a successful
       version selection persistently.  This makes the version selection easily reproducible  from  anywhere  in
       the local areas network. <a href="../man1/shape.1.html">shape</a>(1) uses this mechanism when generating its <u>bound</u> <u>configuration</u> <u>threads</u>.

</pre><h4><b>PREDICATES</b></h4><pre>
       This is the complete list of valid predicate names and a synopsis of their arguments. The list is divided
       into several parts, each describing a certain class of predicates.

       The  first class are predicates working independently on each element of the current hit set. They impose
       certain requirements to  the  attributes  of  each  version  and  eliminate  those,  not  fulfilling  the
       requirements.

       eq (<u>attrName</u>,<u>attrValue</u>)
              The  named  attribute must exist in the versions attribute list and it must have exactly the given
              value. When the corresponding version attribute has multiple values, at least one  of  the  values
              must match exactly.

       hasattr (<u>attrName</u>)
              The  named  attribute  must  exist  in  the  versions  attribute list.  When applied to a standard
              attribute, hasattr requires a value to be associated with the standard attribute. In case of  user
              defined attributes, the attribute value is not regarded.

       ne (<u>attrName</u>,<u>attrValue</u>)
              The  named  attribute,  when  existing  in  the versions attribute buffer, must not have the given
              attribute value. When the attribute does not exist, everything  is  fine.  If  the  attribute  has
              multiple values, it is required, that none of the values matches the given <u>attrValue</u>.

       {ge,gt,le,lt} (<u>attrName</u>,<u>attrValue</u>)
              The  named  version attribute must have a value, that is greater or equal / greater than / less or
              equal / less than the given attribute value. The  named  attribute  must  exist  in  the  versions
              attribute  buffer,  otherwise  the  version  is  eliminated  from the hit set. For attributes with
              multiple values, only one of the values must meet the required property.

       The second class are predicates that do not operate on single version but rather on the complete hit set.
       They express relations between different versions in the hit set and base their selection  on  comparison
       of  different  versions.  Usually, they are used to get a unique version binding, by ordering the hit set
       and selecting one of the extremes.

       min (<u>attrName</u>)
              Retain the version(s) with the lowest value for the named attribute in the hit set. String  values
              are  compared  literally,  others  "naturally"  (see  the  list  of  known attributes below for an
              explanation of that).  Versions not carrying the named attribute or  having  no  value  associated
              with the attribute name are eliminated from the hit set.

       max (<u>attrName</u>)
              Retain the version(s) with the highest value for the named attribute in the hit set. String values
              are  compared  literally,  others  "naturally"  (see  the  list  of  known attributes below for an
              explanation of that).  Versions not carrying the named attribute or  having  no  value  associated
              with the attribute name are eliminated from the hit set.

       The  next  two predicate groups have no direct influence on the hit set.  They can invalidate the hit set
       and cause the rule evaluation to go on with the next attribute expression, but they do never  modify  the
       hit  set.  These  predicates are activated, when the evaluation of the attribute expression reaches them,
       i.e. when the hit set is not empty.

       msg (<u>msgString</u>)
              Print the given message to standard output and retain the current hit set.

       cut (<u>msgString</u>)
              Force the current rule binding to fail and print the given message to standard output. Printing is
              omitted, when the message string is empty. Rule processing is stopped immediately and the returned
              hit set is empty.

       confirm (<u>msgString</u>,<u>expectedAnswer</u>)
              Ask the user for confirmation to go on with the evaluation of the  current  attribute  expression.
              The given message string is printed to standard output with the expected answer appended in square
              brackets.   After  that,  user  input  is  read. When the user confirms the expected answer (empty
              input) or his/her  input  matches  the  expected  answer,  evaluation  of  the  current  attribute
              expression  continues.  Otherwise,  the current hit set is invalidated and processing goes on with
              the next attribute expression.

       bindrule (<u>ruleName</u>)
              Abort evaluation of current attribute expression and switch to another  version  bind  rule.  This
              predicate  makes  only sense as last predicate in an attribute expression, as following predicates
              will never be evaluated. Evaluation of the target rule (<u>ruleName</u>) happens as if the rule has  been
              invoked  directly,  no  influence on the initial hit set is taken. When the target rule fails, the
              evaluation algorithm switches back to the  source  rule  and  goes  on  with  the  next  attribute
              expression.

       The  last  predicate group are external constraints. Their task is to influence the evaluation process by
       examining conditions outside the handled version history. Each of the following predicates has  either  a
       positive or a negative result. Positive results have no effect on the hit set and the evaluation process,
       while  negative  results  invalidate  the  hit  set and cause evaluation to go on with the next attribute
       expression.

       exists (<u>name[binding]</u>)
              Version binding with the given name (usually another one than the current  target  name)  and  the
              given version binding must lead to at least one version. The result is not required to be unique.

       existsnot (<u>name[binding]</u>)
              Version binding with the given name and rule must fail.

       existsuniq (<u>name[binding]</u>)
              Version binding with the given name and rule must lead to a unique selection.

       condexpr (<u>program</u>,<u>expression</u>)
              An external program, named in the program argument, is activated to evaluate the given expression.
              The expression string is written to the standard input of the external program. A zero result code
              is considered to be positive, all others negative.

</pre><h4><b>OBSOLETE</b> <b>PREDICATE</b> <b>NAMES</b></h4><pre>
       There  are  a  number of known predicate names from former versions of the bind rules machinery. They are
       internally mapped to the new predicate names. These names are obsolete and should not be used any longer.

       <u>Obsolete</u>  <u>name</u>   <u>mapped</u>  <u>to</u>   -   cut   attr            eq   attrex          hasattr   attrge          ge
       attrgt          gt    attrle          le   attrlt          lt   attrmax         max   attrmin         min
       attrnot         ne condex          exists condnot         existsnot conduniq        existsuniq

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       All predicates with effect on the contents of the hit set work on version  attributes.  These  attributes
       are  either  standard  attributes  with a defined meaning or user defined attributes.  The following is a
       list of attribute names recognized as standard attributes. All other names  are  considered  to  be  user
       defined attributes.

       alias      Version alias name (symbolic version identification name).

       atime      The date of last access (read or write) to the versions contents.

       author     The version author in the form <u>username@domain.</u>

       cachekey   A  unique key for cached versions built from the creation date, the id of the creating process
                  and a serial number (e.g.  <u>740148430.18469.6</u>).

       ctime      The date of the last status change. This date is  updated,  when  an  attribute  is  added  or
                  deleted, or an attribute value is changed.

       generation
                  The generation number. The value for this attribute is plain numeric.

       host       The  name  of  the host from where the version was accessed. This attribute may have different
                  values at one time, when the version is accessed from different hosts.

       locker     The user who has set a lock on the concerned version. This attribute has an empty value,  when
                  no lock is active. The attribute value is given in the form <u>username@domain.</u>

       ltime      The  date  of last lock change (set or give up update lock). This has an empty value is empty,
                  when there was never a lock set on the version.

       mtime      The date of the last modification of the versions contents.

       name       The name (without suffix) of the version. For example <u>foo</u> for <u>foo.c</u>.

       owner      The version owner in the form <u>username@domain.</u>

       revision   The revision number. As for generation, only numeric values are accepted.

       size       The size of the versions contents in bytes.

       status     The version status. This is one of busy, saved, proposed, published, accessed, or frozen.

       stime      The save date. This attribute has an empty value for busy versions.

       syspath    The absolute pathname through  which  the  version  was  accessed.  This  attribute  may  have
                  different  values  at  one  time,  when  the  version is accessed by different pathnames (e.g.
                  symbolic links).

       type       The suffix part of the versions name. For example <u>fc</u> for <u>foo.c</u>.

       version    The version number in the form <u>generation.revision</u>. A special value is the string busy instead
                  of a version number. As busy  versions  have  no  version  number,  this  value  is  used  for
                  identifying the busy version of a history.

       Some  predicates  (like  <u>ge</u>  or  <u>max</u>) require an ordering relationship between attribute values. For user
       defined attributes, ordering bases on  alphabetical  (ASCII)  comparison  of  the  values.  User  defined
       attributes  with  multiple  values  are  compared  by their first values, if these are identical by their
       second values and so on. No value is considered smaller than any other value. For example

               attr1 = anton                  attr2 = berta
                       berta   is smaller than        anton
                       karl

       but
               attr1 = anton                  attr2 = anton
                       berta   is bigger than         berta
                       karl

       For some of the standard attributes listed above, we need special
       regulations.

       Version numbers (<u>generation.revision</u>)
                  are ordered by generation number first and revision number secondary
                  (e.g. 1.2 is smaller than 2.1). Busy is smaller than
                  any version number.

       Alias Names
                  are ordered by the version numbers (see above) of the identified
                  versions.

       Cache keys are ordered by simple text comparison. This has the effect that the
                  youngest cache key is considered the biggest.

       Version states
                  are ordered in the sequence as listed above. Busy is the lowest
                  and frozen the highest state.

       User attributes
                  The order of user attributes bases on alphabetical comparison of the
                  string <u>username@domain</u>.

       Time attributes
                  Time comparison assumes older dates to be smaller than newer ones.

</pre><h4><b>EXPANSION</b></h4><pre>
       During evaluation of version bind rules, four different  kinds  of  expansion  are  possible.  These  are
       <u>parameter</u> <u>substitution</u>, <u>attribute</u> <u>expansion</u>, <u>external</u> <u>macro</u> <u>expansion</u> and <u>command</u> <u>substitution</u>. Expansion
       happens,  when  a  magic pattern is found in the rule text, starting with either a dollar sign ($) or, in
       case of command substitution, with a backward quote character (`).

       Generally, expansion in version bind rules happens only within patterns and within  predicate  arguments.
       Bind  rule  syntax  or  predicate  names cannot be introduced by substituted strings.  Expansions outside
       patterns and predicate arguments are ignored and usually lead to an error message.

   <b>Parameter</b> <b>Substitution</b>
       A parameter substitution string is usually introduced by the pattern $_ followed by  the  parameter  name
       (an exception is $+ as shown below). The parameter name is optionally delimited by a dollar sign. This is
       necessary,  when  there  is no whitespace character following. The parameter name may be any of the names
       specified in the rule head or one of the following predefined names.

       $_rule$       The current rule name.

       $_target$ or $+
                     The current target file name to be bound.

       $_<u>parameter$</u>  Any other parameter.

       A parameter may have the same name as a citeable attribute (see  below).  In  this  case,  the  parameter
       citation hides the attribute citation. There is no way to cite the value of an attribute when there is an
       equally  named  rule  parameter.  The  reserved names rule, target, and hits are not allowed as parameter
       names.

   <b>Attribute</b> <b>Expansion</b>
       An attribute expansion string looks exactly like a parameter substitution string. It is introduced by the
       pattern $_ followed by the attribute name which is optionally delimited by a dollar  sign,  when  a  non-
       whitespace character follows immediately. Attribute names may be built of any printable characters except
       '#'.   Besides,  it  makes no sense to cite attributes with an equal sign ('=') in the attribute name, as
       the Attributed Filesystem (AtFS) doesn't allow this.

       The value by which the attribute expansion string will be  replaced  depends  on  the  current  state  of
       processing.  This may cause different values to be inserted for the same citation in different processing
       states. Attribute expansion happens as late as possible, it is done right before the  evaluation  of  the
       concerned  pattern  or  predicate.   With  one  exception,  $_hits$,  attribute  expansions  will only be
       substituted, if the current hit set cardinality is 1.

       $_hits$ or $=
                     The number of versions satisfying the binding conditions expressed so far (the  cardinality
                     of the hit set). This value continuously changes during rule evaluation.

       $_<u>attribute$</u>  The value of any attribute of a uniquely selected version.

       Attribute citations may be overloaded by parameter citations (see above).

   <b>External</b> <b>Macro</b> <b>Expansion</b>
       External  macros  are  evaluated by an external macro processor. If no such macro processor is available,
       external macros remain unchanged.  They have the form:

       $C     where C is any printable non-whitespace character except '+', '=', '_', ':', or '#'

       $(<u>macroName</u>) or ${<u>macroName</u>}
              Macro names may not contain '#' characters. Other limitations may be imposed by the external macro
              definition and processing facility.

   <b>Command</b> <b>Substitution</b>
       A command enclosed in back quotes occuring in a bind rule quotes will  be  replaced  by  its  output.  No
       modifications are done to the command output, hence it may contain newline characters.

</pre><h4><b>LEXICAL</b> <b>STRUCTURE</b></h4><pre>
       There  are  some  characters  with  special  meaning  when occurring in version bind rules. These are the
       syntactical characters colon (:), comma, (,), semicolon (;), period (.), and parentheses (( and  )),  the
       comment  symbol  (#), the dollar sign ($) or the back quote (`) introducing expansion strings ($), quotes
       (" and '), and the escape symbol (\).

       Comments are handled somewhat rigorously. A comment symbol (#) occurring anywhere in  the  rule  name  or
       rule  body  has effect as long as it is not escaped by a backslash (\) character. Comments range from the
       comment symbol (inclusive) to the end of the line. Newline characters within comments may also be escaped
       by a backslash character, continuing the comment on the next line.

       Nesting of parentheses and quotes is not supported.

       The following is a list of lexical constraints for each part of a version bind rule.

       Rule names and rule parameters
               Rule names may consist of any printable non-whitespace character except  colon  and  parentheses.
               The leftmost colon or opening parentheses delimits the rule name.
               Rule  parameter  names  follow  the  same  lexical  rule, but additionally must not contain comma
               characters, as this in the delimiter between parameters.

       Patterns
               In principle, name patterns  may  consist  of  any  printable  character.   Comma  and  semicolon
               characters  occurring  in  a  name  pattern  must  be  escaped by a backslash character. A period
               occurring in a name pattern needs <u>not</u> to be escaped as long as  it  is  not  the  last  character
               (ignoring trailing whitespace) in the rule body. Period as last character is <u>always</u> considered to
               be  end  of  rule  sign.   Name  patterns  may  contain  macro or parameter citations and command
               substitutions.

       Predicates
               Each predicate name must be one of the reserved names listed previously in this paper.  Predicate
               arguments  consist of any printable character including whitespace. Comma, parenthesis or quoting
               characters must be escaped. Any argument may be  quoted  by  single  or  double  quotes.  Quoting
               exceeds line limits.
               Predicate  arguments may contain macro, attribute or parameter citations leaded by a dollar sign,
               or command substitutions enclosed in back quotes. When quoted in single quotes, dollar signs  and
               back  quotes  occurring  in  a  predicate  argument are not taken by their special meaning and no
               citations happen. Double quotes do <u>not</u> hide citations.

</pre><h4><b>TIPS,</b> <b>TRICKS,</b> <b>AND</b> <b>TRAPS</b></h4><pre>
       <u>Why</u> <u>doesn't</u> <u>the</u> <u>bind</u> <u>rule</u> <u>select</u> <u>version</u> <u>xyz</u> <u>although</u> <u>I</u> <u>think</u> <u>it</u> <u>should</u> <u>?</u>. An important facility to  find
       an  answer  to this question is the <u>trace</u> <u>option</u> provided by the <a href="../man1/vbind.1.html">vbind</a>(1) command. It shows the evolution
       of the hit set during rule evaluation.

       Typing errors in standard attribute names may lead to confusing situations. They cannot be recognized  by
       the evaluation machinery, as any unknown attribute name is considered to be an user defined attribute.

       A  minus  sign  (-)  as first character in an alternative is considered as part of the pattern and not as
       (old style) cut operator.  Hence
               -; (- as pattern)
       and
               ,-; (default pattern followed by cut)
       make a big difference. We recommend the use of cut() in any case. The short form (-)  is  supported  only
       for compatibility with older versions.

</pre><h4><b>GRAMMAR</b></h4><pre>
       <u>bind_rule</u> ::= <u>bind_rule_head</u> <b>:</b>[<b>-</b>] <u>bind_rule_body</u> .

       <u>bind_rule_head</u> ::= <u>rule_name</u> | <u>rule_name</u> <b>(</b> <u>rule_arg_list</u> <b>)</b> .

       <u>rule_arg_list</u>: <u>rule_name</u> { <b>,</b> <u>arg_name</u> }* .

       <u>bind_rule_body</u> ::= <u>attr_expression</u> { <b>;</b> <u>attr_expression</u>}* <b>.</b> .

       <u>attr_expression</u> ::=<u>name_pattern</u> { <b>,</b> <u>predicate</u> }* |
                        <u>predicate</u> { <b>,</b> <u>predicate</u> }* | .

       <u>name_pattern</u> ::= { <u>&lt;any</u> <u>printable</u> <u>character</u> <u>or</u> <u>whitespace&gt;</u> }+

       <u>predicate</u> ::=   <u>attr_value_predicate</u> <b>(</b> <u>attr_name</u> <b>,</b> <u>string</u> <b>)</b> |
                <u>attr_name_predicate</u> <b>(</b> <u>attr_name</u> <b>)</b> |
                <u>bind_rule_predicate</u> <b>(</b> <u>rule_name</u> <b>)</b> |
                <u>msg_predicate</u> <b>(</b> <u>string</u> <b>)</b> |
                <u>msg_answer_predicate</u> <b>(</b> <u>string</u> <b>,</b> <u>string</u> <b>)</b> |
                <u>cond_rule_predicate</u> <b>(</b> <u>string</u> <b>,</b> <u>bind_rule_head</u> <b>)</b> |
                <u>cond_expr_predicate</u> <b>(</b> <u>string</u> <b>,</b> <u>string</u> <b>)</b> |
                <u>cut_predicate</u>.

       <u>attr_value_predicate</u> ::= eq | ge | gt | le | lt | ne .

       <u>attr_name_predicate</u> ::= hasattr | max | min .

       <u>bind_rule_predicate</u> ::= bindrule .

       <u>msg_predicate</u> ::= cut | msg .

       <u>msg_answer_predicate</u> ::= confirm .

       <u>cond_rule_predicate</u> ::= exists | existsnot | existsuniq .

       <u>cond_expr_predicate</u> ::= condexpr .

       <u>cut_predicate</u> ::= <b>-</b> .

       <u>attr_name</u> ::=   arg_name | author | atime | ctime | generation |
                       locker | ltime | mtime | owner |
                       revision | size | state | stime | version .

       <u>rule_name</u> ::= { <u>&lt;any</u> <u>printable</u> <u>character</u> <u>except</u> <u>colon</u> <u>and</u> <u>parentheses</u> }+ .

       <u>arg_name</u> ::= { <u>&lt;any</u> <u>printable</u> <u>character</u> <u>except</u> <u>comma,</u> <u>colon</u> <u>and</u> <u>parentheses</u> }+ .

       <u>string</u> ::= { <u>&lt;any</u> <u>printable</u> <u>character</u> <u>or</u> <u>whitespace&gt;</u> } .

</pre><h4><b>FILES</b></h4><pre>
       $SHAPETOOLS/BindRules

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/vbind.1.html">vbind</a>(1), <a href="../man1/vadm.1.html">vadm</a>(1), <a href="../man3/atnetwork.3.html">atnetwork</a>(3), <a href="../man1/shape.1.html">shape</a>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       <a href="mailto:Andreas.Lampen@cs.tu-berlin.de">Andreas.Lampen@cs.tu-berlin.de</a>

AtFStk-1.12                                 Tue Jun 29 16:16:30 1993                                <u><a href="../man7/BindRules.7.html">BindRules</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>