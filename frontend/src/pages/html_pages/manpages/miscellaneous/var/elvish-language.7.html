<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  document describes the Elvish programming language.  It is both a specification and an advanced tu‐</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/elvish">elvish_0.17.0-1ubuntu0.1_amd64</a> <br><br><pre>
</pre><h4><b>Introduction</b></h4><pre>
       This  document describes the Elvish programming language.  It is both a specification and an advanced tu‐
       torial.  The parts of this document marked with either <b>notes</b> or called out as <b>examples</b> are non-normative,
       and only serve to help you understand the more formal descriptions.

       Examples in this document might use constructs that have not yet been  introduced,  so  some  familiarity
       with the language is assumed.  If you are new to Elvish, start with the learning materials.

</pre><h4><b>Source</b> <b>code</b> <b>encoding</b></h4><pre>
       Elvish source code must be Unicode text encoded in UTF-8.

       In  this document, <b>character</b> is a synonym of Unicode codepoint (https://en.wikipedia.org/wiki/Code_point)
       or its UTF-8 encoding.

</pre><h4><b>Lexical</b> <b>elements</b></h4><pre>
   <b>Whitespace</b>
       In this document, an <b>inline</b> <b>whitespace</b> is any of the following:

       • A space (U+0020);

       • A tab (U+0009);

       • A comment: starting with # and ending before (but not including) the next carriage return,  newline  or
         end of file;

       • A line continuation: a ^ followed by a newline ("\n"), or a carriage return and newline ("\r\n").

       A <b>whitespace</b> is any of the following:

       • An inline whitespace;

       • A carriage return (U+000D);

       • A newline (U+000A).

   <b>Metacharacters</b>
       The following <b>metacharacters</b> serve to introduce or delimit syntax constructs:

       Metacharacter   Use
       ──────────────────────────────────────────────────────
       $               Referencing variables
       * and ?         Forming wildcard
       |               Separating forms in a pipeline
       &amp;               Marking  background pipelines; intro‐
                       ducing key-value pairs
       ;               Separating pipelines
       &lt; and &gt;         Introducing IO redirections
       ( and )         Enclosing output captures
       [ and ]         Enclosing list literals, map literals
                       or function signature
       { and }         Enclosing lambda  literals  or  brace
                       expressions

       The following characters are parsed as metacharacters under certain conditions:

       • ~  is a metacharacter if it appears at the beginning of a compound expression, in which case it is sub‐
         ject to tilde expansion;

       • = is a metacharacter when used for terminating map keys or option keys, or denoting  legacy  assignment
         form or temporary assignments.

   <b>Single-quoted</b> <b>string</b>
       A  single-quoted  string consists of zero or more characters enclosed in single quotes (').  All enclosed
       characters represent themselves, except the single quote.

       Two consecutive single quotes are handled as a special case: they represent one single quote, instead  of
       terminating a single-quoted string and starting another.

       <b>Examples</b>: '*\' evaluates to *\, and 'it''s' evaluates to it's.

   <b>Double-quoted</b> <b>string</b>
       A  double-quoted  string consists of zero or more characters enclosed in double quotes (").  All enclosed
       characters represent themselves, except backslashes  (\),  which  introduces  <b>escape</b>  <b>sequences</b>.   Double
       quotes are not allowed inside double-quoted strings, except after backslashes.

       The following escape sequences are supported:

       • \cX, where <u>X</u> is a character with codepoint between 0x40 and 0x5F, represents the codepoint that is 0x40
         lower  than <u>X</u>.  For example, \cI is the tab character: 0x49 (I) - 0x40 = 0x09 (tab).  There is one spe‐
         cial case: A question-mark is converted to del; i.e., \c? or \^? is equivalent to \x7F.

       • \^X is the same as \cX.

       • \[0..7][0..7][0..7] is a byte written as an octal value.  There must be three  octal  digits  following
         the backslash.  For example, \000 is the nul character, and \101 is the same as A, but \0 is an invalid
         escape sequence (too few digits).

       • \x.. is a Unicode code point represented by two hexadecimal digits.

       • \u.... is a Unicode code point represented by four hexadecimal digits.

       • \U...... is a Unicode code point represented by eight hexadecimal digits.

       • The following single character escape sequences:

         • \a is the “bell” character, equivalent to \007 or \x07.

         • \b is the “backspace” character, equivalent to \010 or \x08.

         • \f is the “form feed” character, equivalent to \014 or \x0c.

         • \n is the “new line” character, equivalent to \012 or \x0a.

         • \r is the “carriage return” character, equivalent to \015 or \x0d.

         • \t is the “tab” character, equivalent to \011 or \x09.

         • \v is the “vertical tab” character, equivalent to \013 or \x0b.

         • \\ is the “backslash” character, equivalent to \134 or \x5c.

         • \" is the “double-quote” character, equivalent to \042 or \x22.

       An unsupported escape sequence results in a parse error.

       <b>Note</b>:  Unlike  most  other shells, double-quoted strings in Elvish do not support interpolation.  For in‐
       stance, "$name" simply evaluates to a string containing $name.  To get a similar effect, simply  concate‐
       nate  strings:  instead  of  "my name is $name", write "my name is "$name.  Under the hood this is a com‐
       pounding operation.

   <b>Bareword</b>
       A string can be written without quoting – a <b>bareword</b>, if it only includes the characters from the follow‐
       ing set:

       • ASCII letters (a-z and A-Z) and numbers (0-9);

       • The symbols !%+,-./:@\_;

       • Non-ASCII codepoints that are printable, as defined by  unicode.IsPrint  (https://godoc.org/unicode#Is‐
         Print) in Go’s standard library.

       <b>Examples</b>: a.txt, long-bareword, <a href="mailto:elf@elv.sh">elf@elv.sh</a>, <a href="file:/usr/local/bin">/usr/local/bin</a>, 你好世界.

       Moreover, ~ and = are allowed to appear without quoting when they are not parsed as metacharacters.

       <b>Note</b>:  since  the  backslash  (\)  is  a  valid bareword character in Elvish, it cannot be used to escape
       metacharacter.  Use quotes instead: for example, to echo a star, write echo "*" or echo '*', not echo \*.
       The last command just writes out \*.

</pre><h4><b>Value</b> <b>types</b></h4><pre>
   <b>String</b>
       A string is a (possibly empty) sequence of bytes.

       Single-quoted string literals, double-quoted string literals and barewords all evaluate to string values.
       Unless otherwise noted, different syntaxes of string literals are equivalent in the code.  For  instance,
       xyz, 'xyz' and "xyz" are different syntaxes for the same string with content xyz.

       Strings  that contain UTF-8 encoded text can be indexed with a <b>byte</b> <b>index</b> where a codepoint starts, which
       results in the codepoint that starts there.  The index can be given as either a typed number, or a string
       that parses to a number.  Examples:

       • In the string elv, every codepoint is encoded with only one byte, so 0, 1, 2 are all valid indices:

                ~&gt; put elv[0]
                ▶ e
                ~&gt; put elv[1]
                ▶ l
                ~&gt; put elv[2]
                ▶ v

       • In the string 世界, each codepoint is encoded with three bytes.  The first codepoint  occupies  byte  0
         through 2, and the second occupies byte 3 through 5.  Hence valid indices are 0 and 3:

                ~&gt; put 世界[0]
                ▶ 世
                ~&gt; put 世界[3]
                ▶ 界

       Such  strings  may  also be indexed with a slice (see documentation of list for slice syntax).  The range
       determined by the slice is also interpreted as byte indices, and the range must begin and  end  at  code‐
       point boundaries.

       The behavior of indexing a string that does not contain valid UTF-8-encoded Unicode text is unspecified.

       <b>Note</b>: String indexing will likely change.

   <b>Number</b>
       Elvish  supports  several  types  of numbers.  There is no literal syntax, but they can be constructed by
       passing their <b>string</b> <b>representation</b> to the num builtin command:

       • <b>Integers</b> are written in decimal (e.g.  10), hexadecimal (e.g.  0xA), octal (e.g.  0o12) or binary (e.g.
         0b1010).

         <b>NOTE</b>: Integers with leading zeros are now parsed as octal (e.g.  010 is the same as 0o10,  or  8),  but
         this is subject to change (#1372 (https://b.elv.sh/1371)).

       • <b>Rationals</b> are written as two exact integers joined by /, e.g.  1/2 or 0x10/100 (16/100).

       • <b>Floating-point</b> <b>numbers</b> are written with a decimal point (e.g.  10.0) or using scientific notation (e.g.
         1e1 or 1.0e1).  There are also three additional special floating-point values: +Inf, -Inf and NaN.

       Digits may be separated by underscores, which are ignored; this permits separating the digits into groups
       to  improve  readability.   For  example,  1000000  and  1_000_000  are equivalent, so are 1.234_56e3 and
       1.23456e3, or 1_2_3 and 123.

       The string representation is case-insensitive.

   <b>Strings</b> <b>and</b> <b>numbers</b>
       Strings and numbers are distinct types; for example, 2 and (num 2) are distinct values.

       However, by convention, all language constructs that expect numbers  (e.g.   list  indices)  also  accept
       strings  that can be converted to numbers.  This means that most of the time, you can just use the string
       representation of numbers, instead of explicitly constructing number values.   Builtin  numeric  commands
       follow the same convention.

       When the word <b>number</b> appears unqualified in other sections of this document, it means either an explicit‐
       ly number-typed value (<b>typed</b> <b>number</b>), or its string representation.

       When  a typed number is converted to a string (e.g.  with to-string), the result is guaranteed to convert
       back to the original number.  In other words, eq $x (num (to-string $x)) always outputs $true if $x is  a
       typed number.

   <b>Exactness</b>
       Integers  and  rationals  are <b>exact</b> numbers; their precision is only limited by the available memory, and
       many (but not all) operations on them are guaranteed to produce mathematically correct results.

       Floating-point numbers are IEEE 754 (https://en.wikipedia.org/wiki/IEEE_754) double-precision.  Since op‐
       erations on floating-point numbers in general are not guaranteed to be precise, they are  always  consid‐
       ered <b>inexact</b>.

       This distinction is important for some builtin commands; see exactness-preserving commands.

   <b>List</b>
       A  list is a value containing a sequence of values.  Values in a list are called its <b>elements</b>.  Each ele‐
       ment has an index, starting from zero.

       List literals are surrounded by square brackets [ ], with elements separated by whitespace.  Examples:

              ~&gt; put [lorem ipsum]
              ▶ [lorem ipsum]
              ~&gt; put [lorem
                      ipsum
                      foo
                      bar]
              ▶ [lorem ipsum foo bar]

       <b>Note</b>: In Elvish, commas have no special meanings and are valid bareword characters, so don’t use them  to
       separate elements:

              ~&gt; li = [a, b]
              ~&gt; put $li
              ▶ [a, b]
              ~&gt; put $li[0]
              ▶ a,

       A  list  can  be  indexed  with  the index of an element to obtain the element, which can take one of two
       forms:

       • A non-negative integer, an offset counting from the beginning of the list.  For example, $li[0] is  the
         first element of $li.

       • A  negative  integer,  an offset counting from the back of the list.  For instance, $li[-1] is the last
         element $li.

       In both cases, the index can be given either as a typed number or a number-like string.

       A list can also be indexed with a <b>slice</b> to obtain a sublist, which can take one of two forms:

       • A slice $a..$b, where both $a and $b are integers.  The result is sublist of $li[$a] up to, but not in‐
         cluding, $li[$b].  For instance, $li[4..7] equals [$li[4] $li[5] $li[6]], while $li[1..-1] contains all
         elements from $li except the first and last one.

         Both integers may be omitted; $a defaults to 0 while $b defaults to the length of the  list.   For  in‐
         stance, $li[..2] is equivalent to $li[0..2], $li[2..] is equivalent to $li[2..(count $li)], and $li[..]
         makes a copy of $li.  The last form is rarely useful, as lists are immutable.

         Note  that  the slice needs to be a <b>single</b> string, so there cannot be any spaces within the slice.  For
         instance, $li[2..10] cannot be written as $li[2.. 10]; the latter contains two indices and  is  equiva‐
         lent to $li[2..] $li[10] (see Indexing).

       • A slice $a..=$b, which is similar to $a..$b, but includes $li[$b].

       Examples:

              ~&gt; li = [lorem ipsum foo bar]
              ~&gt; put $li[0]
              ▶ lorem
              ~&gt; put $li[-1]
              ▶ bar
              ~&gt; put $li[0..2]
              ▶ [lorem ipsum]

   <b>Map</b>
       A map is a value containing unordered key-value pairs.

       Map  literals  are  surrounded by square brackets; a key/value pair is written &amp;key=value (reminiscent to
       HTTP query parameters), and pairs are separated by whitespaces.  Whitespaces are allowed after =, but not
       before =.  Examples:

              ~&gt; put [&amp;foo=bar &amp;lorem=ipsum]
              ▶ [&amp;foo=bar &amp;lorem=ipsum]
              ~&gt; put [&amp;a=   10
                      &amp;b=   23
                      &amp;sum= (+ 10 23)]
              ▶ [&amp;a=10 &amp;b=23 &amp;sum=33]

       The literal of an empty map is [&amp;].

       Specifying a key without = or a value following it is equivalent to specifying $true as the value.  Spec‐
       ifying a key with = but no value following it is equivalent to specifying the empty string as the  value.
       Example:

              ~&gt; echo [&amp;a &amp;b=]
              [&amp;a=$true &amp;b='']

       A  map  can be indexed by any of its keys.  Unlike strings and lists, there is no support for slices, and
       .. and ..= have no special meanings.  Examples:

              ~&gt; map = [&amp;a=lorem &amp;b=ipsum &amp;a..b=haha]
              ~&gt; echo $map[a]
              lorem
              ~&gt; echo $map[a..b]
              haha

       You can test if a key is present using has-key and enumerate the keys using the keys builtins.

       <b>Note</b>: Since &amp; is a metacharacter, key-value pairs do not have to follow  whitespaces;  [&amp;a=lorem&amp;b=ipsum]
       is equivalent to [&amp;a=lorem &amp;b=ipsum], just less readable.  This might change in future.

   <b>Pseudo-map</b>
       A  pseudo-map is not a single concrete data type.  It refers to concrete types that behave like maps with
       some restrictions.

       A pseudo-map has a fixed set of keys whose values can be accessed by indexing like you would for a  regu‐
       lar map.  Similarly, you can use commands like keys and has-key on such objects.

       Unlike a normal map, it is currently not possible to create a modified version of an existing pseudo-map:
       it is not possible to create a pseudo-map with new keys, without existing keys, or with a different value
       for a given key.

       The  pseudo-map  mechanism  is often used for introspection.  For example, exceptions, user-defined func‐
       tions, and $buildinfo are pseudo-maps.

   <b>Nil</b>
       The value $nil serves as the initial value of variables that are declared but not assigned.

   <b>Boolean</b>
       There are two boolean values, $true and $false.

       When converting non-boolean values to the boolean type, $nil and exceptions convert to $false; such  val‐
       ues  and $false itself are <b>booleanly</b> <b>false</b>.  All the other non-boolean values convert to $true; such val‐
       ues and $true itself are <b>booleanly</b> <b>true</b>.

   <b>Exception</b>
       An exception carries information about errors during the execution of code.

       There is no literal syntax for exceptions.  See the discussion of exception and flow  commands  for  more
       information about this data type.

       An  exception  is a pseudo-map with a reason field, which is in turn a pseudo-map.  The reason pseudo-map
       has has a type field identifying how the exception was raised, and further fields depending on the type:

       • If the type field is fail, the exception was raised by the fail command.

         In this case, the content field contains the argument to fail.

       • If the type field is flow, the exception was raised by one of the flow commands.

         In this case, the name field contains the name of the flow command.

       • If the type field is pipeline, the exception was a result of multiple commands  in  the  same  pipeline
         raising exceptions.

         In this case, the exceptions field contains the exceptions from the individual commands.

       • If  the  type field starts with external-cmd/, the exception was caused by one of several conditions of
         an external command.  In this case, the following fields are available:

         • The cmd-name field contains the name of the command.

         • The pid field contains the PID of the command.

       • If the type field is external-cmd/exited, the external command exited with a non-zero status code.   In
         this case, the exit-status field contains the exit status.

       • If the type field is external-cmd/signaled, the external command was killed by a signal.  In this case,
         the following extra fields are available:

         • The signal-name field contains the name of the signal.

         • The signal-number field contains the numerical value of the signal, as a string.

         • The core-dumped field is a boolean reflecting whether a core dump was generated.

       • If the type field is external-cmd/stopped, the external command was stopped.  In this case, the follow‐
         ing extra fields are available:

         • The signal-name field contains the name of the signal.

         • The signal-number field contains the numerical value of the signal, as a string.

         • The trap-cause field contains the number indicating the trap cause.

       Examples:

              ~&gt; put ?(fail foo)[reason]
              ▶ [&amp;content=foo &amp;type=fail]
              ~&gt; put ?(return)[reason]
              ▶ [&amp;name=return &amp;type=flow]
              ~&gt; put ?(false)[reason]
              ▶ [&amp;cmd-name=false &amp;exit-status=1 &amp;pid=953421 &amp;type=external-cmd/exited]

   <b>File</b>
       There  is  no  literal syntax for the file type.  This type is returned by commands such as file:open and
       path:temp-file.  It can be used as the target of a redirection rather than a filename.

       A file object is a pseudo-map with fields fd (an int) and name (a string).  If the file is closed the  fd
       will be -1.

   <b>Function</b>
       A  function encapsulates a piece of code that can be executed in an ordinary command, and takes its argu‐
       ments and options.  Functions are first-class values; they can be kept in variables, used  as  arguments,
       output  on  the  value channel and embedded in other data structures.  Elvish comes with a set of <b>builtin</b>
       <b>functions</b>, and Elvish code can also create <b>user-defined</b> <b>functions</b>.

       <b>Note</b>: Unlike most programming languages, functions in Elvish do not have return  values.   Instead,  they
       can output values, which can be captured later.

       A  <b>function</b> <b>literal</b>, or alternatively a <b>lambda</b>, evaluates to a user-defined function.  The literal syntax
       consists of an optional <b>signature</b> <b>list</b>, followed by a code chunk that defines the body of the function.

       Here is an example without a signature:

              ~&gt; f = { echo "Inside a lambda" }
              ~&gt; put $f
              ▶ &lt;closure 0x18a1a340&gt;

       One or more whitespace characters after { is required: Elvish relies on the  presence  of  whitespace  to
       disambiguate function literals and braced lists.

       <b>Note</b>: It is good style to put some whitespace before the closing } for symmetry, but this is not required
       by the syntax.

       Functions  defined  without  a  signature list do not accept any arguments or options.  To do so, write a
       signature list.  Here is an example:

              ~&gt; f = [a b]{ put $b $a }
              ~&gt; $f lorem ipsum
              ▶ ipsum
              ▶ lorem

       There must be no space between ] and {; otherwise Elvish will parse the signature as a list, followed  by
       a lambda without signature:

              ~&gt; put [a]{ nop }
              ▶ &lt;closure 0xc420153d80&gt;
              ~&gt; put [a] { nop }
              ▶ [a]
              ▶ &lt;closure 0xc42004a480&gt;

       Like  in the left hand of assignments, if you prefix one of the arguments with @, it becomes a <b>rest</b> <b>argu‐</b>
       <b>ment</b>, and its value is a list containing all the remaining arguments:

              ~&gt; f = [a @rest]{ put $a $rest }
              ~&gt; $f lorem
              ▶ lorem
              ▶ []
              ~&gt; $f lorem ipsum dolar sit
              ▶ lorem
              ▶ [ipsum dolar sit]
              ~&gt; f = [a @rest b]{ put $a $rest $b }
              ~&gt; $f lorem ipsum dolar sit
              ▶ lorem
              ▶ [ipsum dolar]
              ▶ sit

       You can also declare options in the signature.  The syntax is &amp;name=default (like a map pair), where  de‐
       fault  is  the  default  value  for the option; the value of the option will be kept in a variable called
       name:

              ~&gt; f = [&amp;opt=default]{ echo "Value of $opt is "$opt }
              ~&gt; $f
              Value of $opt is default
              ~&gt; $f &amp;opt=foobar
              Value of $opt is foobar

       Options must have default values: Options should be <b>option</b>al.

       If you call a function with too few arguments, too many arguments or unknown  options,  an  exception  is
       thrown:

              ~&gt; [a]{ echo $a } foo bar
              Exception: need 1 arguments, got 2
              [tty], line 1: [a]{ echo $a } foo bar
              ~&gt; [a b]{ echo $a $b } foo
              Exception: need 2 arguments, got 1
              [tty], line 1: [a b]{ echo $a $b } foo
              ~&gt; [a b @rest]{ echo $a $b $rest } foo
              Exception: need 2 or more arguments, got 1
              [tty], line 1: [a b @rest]{ echo $a $b $rest } foo
              ~&gt; [&amp;k=v]{ echo $k } &amp;k2=v2
              Exception: unknown option k2
              [tty], line 1: [&amp;k=v]{ echo $k } &amp;k2=v2

       A user-defined function is a pseudo-map.  If $f is a user-defined function, it has the following fields:

       • $f[arg-names] is a list containing the names of the arguments.

       • $f[rest-arg] is the index of the rest argument.  If there is no rest argument, it is -1.

       • $f[opt-names] is a list containing the names of the options.

       • $f[opt-defaults]  is  a list containing the default values of the options, in the same order as $f[opt-
         names].

       • $f[def] is a string containing the definition of the function, including the signature and the body.

       • $f[body] is a string containing the body of the function, without the enclosing brackets.

       • $f[src] is a map-like data structure containing information about the source code that the function  is
         defined in.  It contains the same value that the src function would output if called from the function.

</pre><h4><b>Variable</b></h4><pre>
       A  variable  is  a  named  storage location for holding a value.  The following characters can be used in
       variable names (a subset of bareword characters) without quoting:

       A variable exist after it is declared (either explicitly using var or implicitly using the legacy assign‐
       ment form), and its value may be mutated by further assignments.  It can be used as an expression or part
       of an expression.

       <b>Note</b>: In most other shells, variables can map directly to environmental variables: $PATH is the  same  as
       the  PATH  environment variable.  This is not the case in Elvish.  Instead, environment variables are put
       in a dedicated E: namespace; the environment variable PATH is known as $E:PATH.  The $PATH  variable,  on
       the  other  hand,  does  not exist initially, and if you have defined it, only lives in a certain lexical
       scope within the Elvish interpreter.

       You will notice that variables sometimes have a leading dollar $, and sometimes not.   The  tradition  is
       that  they  do  when they are used for their values, and do not otherwise (e.g.  in assignment).  This is
       consistent with most other shells.

   <b>Variable</b> <b>suffix</b>
       There are two characters that have special meanings and extra type constraints when used as the suffix of
       a variable name:

       • If a variable name ends with ~, it can only take callable values, which are functions and external com‐
         mands.  Such variables are consulted when resolving  ordinary  commands.   The  default  value  is  the
         builtin nop command.

       • If  a  variable  name  ends with :, it can only take namespaces as values.  They are used for accessing
         namespaced variables.

   <b>Scoping</b> <b>rule</b>
       Elvish has lexical scoping.  A file or an interactive prompt starts with a top-level scope, and  a  func‐
       tion literal introduce new lexical scopes.

       When  you use a variable, Elvish looks for it in the current lexical scope, then its parent lexical scope
       and so forth, until the outermost scope:

              ~&gt; x = 12
              ~&gt; { echo $x } # $x is in the global scope
              12
              ~&gt; { y = bar; { echo $y } } # $y is in the outer scope
              bar

       If a variable is not in any of the lexical scopes, Elvish tries to resolve it in the builtin:  namespace,
       and if that also fails, fails with an error:

              ~&gt; echo $pid # builtin
              36613
              ~&gt; echo $nonexistent
              Compilation error: variable $nonexistent not found
                [interactive], line 1:
                  echo $nonexistent

       Note that Elvish resolves all variables in a code chunk before starting to execute any of it; that is why
       the error message above says <u>compilation</u> <u>error</u>.  This can be more clearly observed in the following exam‐
       ple:

              ~&gt; echo pre-error; echo $nonexistent
              Compilation error: variable $nonexistent not found
              [tty], line 1: echo pre-error; echo $nonexistent

       When you assign a variable, Elvish does a similar searching.  If the variable cannot be found, instead of
       causing an error, it will be created in the current scope:

              ~&gt; x = 12
              ~&gt; { x = 13 } # assigns to x in the global scope
              ~&gt; echo $x
              13
              ~&gt; { z = foo } # creates z in the inner scope
              ~&gt; echo $z
              Compilation error: variable $z not found
              [tty], line 1: echo $z

       One implication of this behavior is that Elvish will not shadow your variable in outer scopes.

       There  is  a  local: namespace that always refers to the current scope, and by using it it is possible to
       force Elvish to shadow variables:

              ~&gt; x = 12
              ~&gt; { local:x = 13; echo $x } # force shadowing
              13
              ~&gt; echo $x
              12

       After force shadowing, you can still access the variable in the outer  scope  using  the  up:  namespace,
       which always <b>skips</b> the innermost scope:

              ~&gt; x = 12
              ~&gt; { local:x = 14; echo $x $up:x }
              14 12

       The  local:  and up: namespaces can also be used on unshadowed variables, although they are not useful in
       those cases:

              ~&gt; foo = a
              ~&gt; { echo $up:foo } # $up:foo is the same as $foo
              a
              ~&gt; { bar = b; echo $local:bar } # $local:bar is the same as $bar
              b

       It is not possible to refer to a specific outer scope.

       You cannot create new variables in the builtin: namespace, although existing variables in it can  be  as‐
       signed new values.

   <b>Closure</b> <b>semantics</b>
       When  a  function  literal  refers  to a variable in an outer scope, the function will keep that variable
       alive, even if that variable is the local variable of an outer function that that function has  returned.
       This  is called closure semantics (https://en.wikipedia.org/wiki/Closure_(computer_programming)), because
       the function literal “closes” over the environment it is defined in.

       In the following example, the make-adder function outputs two functions, both referring to a local  vari‐
       able $n.  Closure semantics means that:

       1. Both functions can continue to refer to the $n variable after make-adder has returned.

       2. Multiple calls to the make-adder function generates distinct instances of the $n variables.

          ~&gt; fn make-adder {
               n = 0
               put { put $n } { n = (+ $n 1) }
             }
          ~&gt; getter adder = (make-adder)
          ~&gt; $getter # $getter outputs $n
          ▶ 0
          ~&gt; $adder # $adder increments $n
          ~&gt; $getter # $getter and $setter refer to the same $n
          ▶ 1
          ~&gt; getter2 adder2 = (make-adder)
          ~&gt; $getter2 # $getter2 and $getter refer to different $n
          ▶ 0
          ~&gt; $getter
          ▶ 1

       Variables that get “captured” in closures are called <b>upvalues</b>; this is why the pseudo-namespace for vari‐
       ables  in  outer  scopes is called up:.  When capturing upvalues, Elvish only captures the variables that
       are used.  In the following example, $m is not an upvalue of $g because it is not used:

              ~&gt; fn f { m = 2; n = 3; put { put $n } }
              ~&gt; g = (f)

       This effect is not currently observable,  but  will  become  so  when  namespaces  become  introspectable
       (https://github.com/elves/elvish/issues/492).

</pre><h4><b>Expressions</b></h4><pre>
       Elvish  has a few types of expressions.  Some of those are new compared to most other languages, but some
       are very similar.

       Unlike most other languages, expressions in Elvish may evaluate to any number of values.  The concept  of
       multiple values is distinct from a list of multiple elements.

   <b>Literal</b>
       Literals  of  strings,  lists, maps and functions all evaluate to one value of their corresponding types.
       They are described in their respective sections.

   <b>Variable</b> <b>use</b>
       A <b>variable</b> <b>use</b> expression is formed by a $ followed by the name of the variable.  Examples:

              ~&gt; foo = bar
              ~&gt; x y = 3 4
              ~&gt; put $foo
              ▶ bar
              ~&gt; put $x
              ▶ 3

       If the variable name only contains the following characters (a subset of bareword characters),  the  name
       can appear unquoted after $ and the variable use expression extends to the longest sequence of such char‐
       acters:

       • ASCII letters (a-z and A-Z) and numbers (0-9);

       • The  symbols  -_:~.   The colon : is special; it is normally used for separating namespaces or denoting
         namespace variables;

       • Non-ASCII codepoints that are printable, as defined by  unicode.IsPrint  (https://godoc.org/unicode#Is‐
         Print) in Go’s standard library.

       Alternatively,  $  may  be  followed  immediately  by  a  single-quoted  string  (https://elv.sh/ref/lan‐
       guage.html#single-quoted-string) or a double-quoted string (https://elv.sh/ref/language.html#double-quot‐
       ed-string), in which cases the value of the string specifies the name of the variable.  Examples:

              ~&gt; "\n" = foo
              ~&gt; put $"\n"
              ▶ foo
              ~&gt; '!!!' = bar
              ~&gt; put $'!!!'
              ▶ bar

       Unlike other shells and other dynamic languages, local namespaces in Elvish are statically checked.  This
       means that referencing a nonexistent variable results in a compilation error, which is  triggered  before
       any code is actually evaluated:

              ~&gt; echo $x
              Compilation error: variable $x not found
              [tty], line 1: echo $x
              ~&gt; f = { echo $x }
              compilation error: variable $x not found
              [tty 1], line 1: f = { echo $x }

       If  a  variable  contains a list value, you can add @ before the variable name; this evaluates to all the
       elements within the list.  This is called <b>exploding</b> the variable:

              ~&gt; li = [lorem ipsum foo bar]
              ~&gt; put $li
              ▶ [lorem ipsum foo bar]
              ~&gt; put $@li
              ▶ lorem
              ▶ ipsum
              ▶ foo
              ▶ bar

       <b>Note</b>: Since variable uses have higher precedence than indexing, this does not work for exploding  a  list
       that  is an element of another list.  For doing that, and exploding the result of other expressions (such
       as an output capture), use the builtin all command.)

   <b>Output</b> <b>capture</b>
       An <b>output</b> <b>capture</b> expression is formed by putting parentheses () around a code chunk.  It  redirects  the
       output of the chunk into an internal pipe, and evaluates to all the values that have been output.

              ~&gt; + 1 10 100
              ▶ 111
              ~&gt; x = (+ 1 10 100)
              ~&gt; put $x
              ▶ 111
              ~&gt; put lorem ipsum
              ▶ lorem
              ▶ ipsum
              ~&gt; x y = (put lorem ipsum)
              ~&gt; put $x
              ▶ lorem
              ~&gt; put $y
              ▶ ipsum

       If the chunk outputs bytes, Elvish strips the last newline (if any), and split them by newlines, and con‐
       sider each line to be one string value:

              ~&gt; put (echo "a\nb")
              ▶ a
              ▶ b

       Trailing  carriage returns are also stripped from each line, which effectively makes \r\n also valid line
       separators:

              ~&gt; put (echo "a\r\nb")
              ▶ a
              ▶ b

       <b>Note</b> <b>1</b>.  Only the last newline is ever removed, so empty lines are preserved; (echo "a\n")  evaluates  to
       two values, "a" and "".

       <b>Note</b>  <b>2</b>.   One consequence of this mechanism is that you can not distinguish outputs that lack a trailing
       newline from outputs that have one; (echo what) evaluates to the same value as (print what).  If  such  a
       distinction is needed, use slurp to preserve the original bytes output.

       If  the chunk outputs both values and bytes, the values of output capture will contain both value outputs
       and lines.  However, the ordering between value output and byte output might not agree with the order  in
       which they happened:

              ~&gt; put (put a; echo b) # value order need not be the same as output order
              ▶ b
              ▶ a

       <b>Note</b>:  If you want to capture the stdout and stderr byte streams independent of each other, see the exam‐
       ple in the run-parallel documentation.

   <b>Exception</b> <b>capture</b>
       An <b>exception</b> <b>capture</b> expression is formed by putting ?() around a code chunk.   It  runs  the  chunk  and
       evaluates to the exception it throws.

              ~&gt; fail bad
              Exception: bad
              Traceback:
                [interactive], line 1:
                  fail bad
              ~&gt; put ?(fail bad)
              ▶ ?(fail bad)

       If there was no error, it evaluates to the special value $ok:

              ~&gt; nop
              ~&gt; put ?(nop)
              ▶ $ok

       Exceptions are booleanly false and $ok is booleanly true.  This is useful in if (introduced later):

              if ?(test -d ./a) {
                # ./a is a directory
              }

       <b>Note</b>:  Exception captures do not affect the output of the code chunk.  You can combine output capture and
       exception capture:

              output = (error = ?(commands-that-may-fail))

   <b>Braced</b> <b>list</b>
       A <b>braced</b> <b>list</b> consists of multiple expressions separated by whitespaces and surrounded  by  braces  ({}).
       There  must be no space after the opening brace.  A braced list evaluates to whatever the expressions in‐
       side it evaluate to.  Its most typical use is grouping multiple values in a compound  expression.   Exam‐
       ple:

              ~&gt; put {a b}-{1 2}
              ▶ a-1
              ▶ a-2
              ▶ b-1
              ▶ b-2

       It can also be used to affect the order of evaluation.  Examples:

              ~&gt; put *
              ▶ foo
              ▶ bar
              ~&gt; put *o
              ▶ foo
              ~&gt; put {*}o
              ▶ fooo
              ▶ baro

       <b>Note</b>: When used to affect the order of evaluation, braced lists are very similar to parentheses in C-like
       languages.

       <b>Note</b>: A braced list is an expression.  It is a syntactical construct and not a separate data structure.

       Elvish  currently also supports using commas to separate items in a braced list.  This will likely be re‐
       moved in future, but it also means that literal commas must be quoted right now.

   <b>Indexing</b>
       An <b>indexing</b> <b>expression</b> is formed by appending one or more indices inside a pair of  brackets  ([])  after
       another expression (the indexee).  Examples:

              ~&gt; li = [foo bar]
              ~&gt; put $li[0]
              ▶ foo
              ~&gt; li = [[foo bar] quux]
              ~&gt; put $li[0][0]
              ▶ foo
              ~&gt; put [[foo bar]][0][0]
              ▶ foo

       If  the  expression being indexed evaluates to multiple values, the indexing operation is applied on each
       value.  Example:

              ~&gt; put (put [foo bar] [lorem ipsum])[0]
              ▶ foo
              ▶ lorem
              ~&gt; put {[foo bar] [lorem ipsum]}[0]
              ▶ foo
              ▶ lorem

       If there are multiple index expressions, or the index expression evaluates to multiple values, the index‐
       ee is indexed once for each of the index value.  Examples:

              ~&gt; put elv[0 2 0..2]
              ▶ e
              ▶ v
              ▶ el
              ~&gt; put [lorem ipsum foo bar][0 2 0..2]
              ▶ lorem
              ▶ foo
              ▶ [lorem ipsum]
              ~&gt; put [&amp;a=lorem &amp;b=ipsum &amp;a..b=haha][a a..b]
              ▶ lorem
              ▶ haha

       If both the indexee and index evaluate to multiple values, the results generated from the  first  indexee
       appear first.  Example:

              ~&gt; put {[foo bar] [lorem ipsum]}[0 1]
              ▶ foo
              ▶ bar
              ▶ lorem
              ▶ ipsum

   <b>Compounding</b>
       A <b>compound</b> <b>expression</b> is formed by writing several expressions together with no space in between.  A com‐
       pound expression evaluates to a string concatenation of all the constituent expressions.  Examples:

              ~&gt; put 'a'b"c" # compounding three string literals
              ▶ abc
              ~&gt; v = value
              ~&gt; put '$v is '$v # compounding one string literal with one string variable
              ▶ '$v is value'

       When  one  or more of the constituent expressions evaluate to multiple values, the result is all possible
       combinations:

              ~&gt; li = [foo bar]
              ~&gt; put {a b}-$li[0 1]
              ▶ a-foo
              ▶ a-bar
              ▶ b-foo
              ▶ b-bar

       The order of the combinations is determined by first taking the first value in  the  leftmost  expression
       that generates multiple values, and then taking the second value, and so on.

   <b>Tilde</b> <b>expansion</b>
       An  unquoted  tilde at the beginning of a compound expression triggers <b>tilde</b> <b>expansion</b>.  The remainder of
       this expression must be a string.  The part from the beginning of the string up to the first  /  (or  the
       end of the word if the string does not contain /), is taken as a user name; and they together evaluate to
       the home directory of that user.  If the user name is empty, the current user is assumed.

       In  the  following  example, the home directory of the current user is /home/xiaq, while that of the root
       user is <a href="file:/root">/root</a>:

              ~&gt; put ~
              ▶ /home/xiaq
              ~&gt; put ~root
              ▶ <a href="file:/root">/root</a>
              ~&gt; put <a href="file:~/xxx">~/xxx</a>
              ▶ /home/xiaq/xxx
              ~&gt; put ~root/xxx
              ▶ /root/xxx

       Note that tildes are not special when they appear elsewhere in a word:

              ~&gt; put a~root
              ▶ a~root

       If you need them to be, use a braced list:

              ~&gt; put a{~root}
              ▶ a/root

   <b>Wildcard</b> <b>expansion</b>
       <b>Wildcard</b> <b>patterns</b> are expressions that contain <b>wildcards</b>.  Wildcard patterns evaluate  to  all  filenames
       they match.

       In examples in this section, we will assume that the current directory has the following structure:

              .x.conf
              a.cc
              ax.conf
              foo.cc
              d/
              |__ .x.conf
              |__ ax.conf
              |__ y.cc
              .d2/
              |__ .x.conf
              |__ ax.conf

       Elvish supports the following wildcards:

       • ? matches one arbitrary character except <a href="file:/.">/.</a>  For example, ?.cc matches a.cc;

       • * matches any number of arbitrary characters except <a href="file:/.">/.</a>  For example, *.cc matches a.cc and foo.cc;

       • ** matches any number of arbitrary characters including <a href="file:/.">/.</a>  For example, **.cc matches a.cc, foo.cc and
         b/y.cc.

       The following behaviors are default, although they can be altered by modifiers:

       • When the entire wildcard pattern has no match, an error is thrown.

       • None of the wildcards matches . at the beginning of filenames.  For example:

         • ?x.conf does not match .x.conf;

         • d/*.conf does not match d/.x.conf;

         • **.conf does not match d/.x.conf.

       Wildcards  can  be  <b>modified</b>  using  the same syntax as indexing.  For instance, in *[match-hidden] the *
       wildcard  is  modified  with  the  match-hidden  modifier.   Multiple  matchers  can  be   chained   like
       *[set:abc][range:0-9].  In which case they are OR’ed together.

       There are two kinds of modifiers:

       <b>Global</b> <b>modifiers</b> apply to the whole pattern and can be placed after any wildcard:

       • nomatch-ok tells Elvish not to throw an error when there is no match for the pattern.  For instance, in
         the example directory put bad* will be an error, but put bad*[nomatch-ok] does exactly nothing.

       • but:xxx (where xxx is any filename) excludes the filename from the final result.

       • type:xxx (where xxx is a recognized file type from the list below).  Only one type modifier is allowed.
         For example, to find the directories at any level below the current working directory: **[type:dir].

         • dir will match if the path is a directory.

         • regular will match if the path is a regular file.

       Although  global modifiers affect the entire wildcard pattern, you can add it after any wildcard, and the
       effect is the same.  For example, put */*[nomatch-ok].cpp and put *[nomatch-ok]/*.cpp do the same  thing.
       On the other hand, you must add it after a wildcard, instead of after the entire pattern: put */*.cpp[no‐
       match-ok] unfortunately does not do the correct thing.  (This will probably be fixed.)

       <b>Local</b> <b>modifiers</b> only apply to the wildcard it immediately follows:

       • match-hidden  tells  the  wildcard to match . at the beginning of filenames, e.g.  *[match-hidden].conf
         matches .x.conf and ax.conf.

         Being a local modifier, it only applies to the wildcard it immediately follows.  For instance, *[match-
         hidden]/*.conf matches d/ax.conf and .d2/ax.conf, but not d/.x.conf or .d2/.x.conf.

       • Character matchers restrict the characters to match:

         • Character sets, like set:aeoiu;

         • Character ranges like range:a-z (including z) or range:a~z (excluding z);

         • Character classes: control, digit, graphic, letter, lower, mark, number, print, punct, space, symbol,
           title, and upper.  See the Is* functions here (https://godoc.org/unicode) for their definitions.

       Note the following caveats:

       • Local matchers chained together in separate modifiers are  OR’ed.   For  instance,  ?[set:aeoiu][digit]
         matches all files with the chars aeoiu or containing a digit.

       • Local  matchers  combined in the same modifier, such as ?[set:aeoiu digit], behave in a hard to explain
         manner.  Do not use this form as <b>the</b> <b>behavior</b> <b>is</b> <b>likely</b> <b>to</b> <b>change</b> <b>in</b> <b>the</b> <b>future.</b>

       • Dots at the beginning of filenames always require an explicit match-hidden, even  if  the  matcher  in‐
         cludes  ..   For  example,  ?[set:.a]x.conf  does  <b>not</b>  match  .x.conf; you have to ?[set:.a match-hid‐
         den]x.conf.

       • Likewise, you always need to use ** to match slashes, even if the  matcher  includes  <a href="file:/.">/.</a>   For  example
         *[set:abc/] is the same as *[set:abc].

   <b>Order</b> <b>of</b> <b>evaluation</b>
       An expression can use a combination of indexing, tilde expansion, wildcard and compounding.  The order of
       evaluation is as follows:

       1. Literals,  variable  uses,  output  captures  and exception captures and braced lists have the highest
          precedence and are evaluated first.

       2. Indexing has the next highest precedence and is then evaluated first.

       3. Expression compounding then happens.  Tildes and wildcards are kept unevaluated.

       4. If the expression starts with a tilde, tilde expansion happens.  If the tilde is followed by  a  wild‐
          card, an exception is raised.

       5. If the expression contains any wildcard, wildcard expansion happens.

       Here an example: in ~/$li[0 1]/* (where $li is a list [foo bar]), the expression is evaluated as follows:

       1. The variable use $li evaluates to the list [foo bar].

       2. The indexing expression $li[0] evaluates to two strings foo and bar.

       3. Compounding the expression, the result is <a href="file:~/foo/">~/foo/</a>* and <a href="file:~/bar/">~/bar/</a>*.

       4. Tilde  expansion  happens;  assuming  that  the user’s home directory is /home/elf, the values are now
          /home/elf/foo/* and /home/elf/bar/*.

       5. Wildcard expansion happens, evaluating the expression to all the filenames  within  /home/elf/foo  and
          /home/elf/bar.  If any directory is empty or nonexistent, an exception is thrown.

       To force a particular order of evaluation, group expressions using a braced list.

</pre><h4><b>Command</b> <b>forms</b></h4><pre>
       A  <b>command</b>  <b>form</b>  is  either an ordinary command, a special command or an legacy assignment form.  All of
       three different types have access to IO ports, which can be modified via redirections.

       When Elvish parses a command form, it applies the following process to decide its type:

       • If the command form contains an unquoted equal sign surrounded by inline whitespaces, it is an ordinary
         assignment.

       • If the first expression in the command form contains a single string  literal,  and  the  string  value
         matches one of the special commands, it is a special command.

       • Otherwise, it is an ordinary command.

   <b>Ordinary</b> <b>command</b>
       An <b>ordinary</b> <b>command</b> form consists of a command head, and any number of arguments and options.

       The first expression in an ordinary command is the command <b>head</b>.  If the head is a single string literal,
       it is subject to <b>static</b> <b>resolution</b>:

       • If  a  variable with name head~ (where head is the value of the head) exists, the head will evaluate as
         if it is $head~; i.e., a function invocation.

       • If the head contains at least one slash, it is treated as an external command with  the  value  as  its
         path relative to the current directory.

       • Otherwise,  the  head  is  considered  “unknown”, and the behavior is controlled by the unknown-command
         pragma:

         • If the unknown-command pragma is set to external (the default), the head is treated as the name of an
           external command, to be searched in the $E:PATH during runtime.

         • If the unknown-command pragma is set to disallow, such command heads trigger a compilation error.

       If the head is not a single string literal, it is evaluated as a normal expression.  The expression  must
       evaluate to one value, and the value must be one of the following:

       • A callable value: a function or external command.

       • A  string  containing at least one slash, in which case it is treated like an external command with the
         string value as its path.

       Examples of commands using static resolution:

              ~&gt; put x # resolves to builtin function $put~
              ▶ x
              ~&gt; f~ = { put 'this is f' }
              ~&gt; f # resolves to user-defined function $f~
              ▶ 'this is f'
              ~&gt; whoami # resolves to external command whoami
              elf

       Examples of commands using a dynamic callable head:

              ~&gt; $put~ x
              ▶ x
              ~&gt; (external whoami)
              elf
              ~&gt; { put 'this is a lambda' }
              ▶ 'this is a lambda'

       <b>Note</b>: The last command resembles a code block in C-like languages in syntax, but is quite different under
       the hood: it works by defining a function on the fly and calling it immediately.

       Examples of commands using a dynamic string head:

              ~&gt; x = <a href="file:/bin/whoami">/bin/whoami</a>
              ~&gt; $x
              elf
              ~&gt; x = whoami
              ~&gt; $x # dynamic strings can only used when containing slash
              Exception: bad value: command must be callable or string containing slash, but is string
              [tty 10], line 1: $x

       The definition of barewords is relaxed when parsing the head, and includes &lt;, &gt;, and *.   These  are  all
       names of numeric builtins:

              ~&gt; &lt; 3 5 # less-than
              ▶ $true
              ~&gt; &gt; 3 5 # greater-than
              ▶ $false
              ~&gt; * 3 5 # multiplication
              ▶ 15

       <b>Arguments</b> and <b>options</b> can be supplied to commands.  Arguments are arbitrary words, while options have ex‐
       actly  the  same syntax as key-value pairs in map literals.  They are separated by inline whitespaces and
       may be intermixed:

              ~&gt; echo &amp;sep=, a b c # &amp;seq=, is an option; a b c are arguments
              a,b,c
              ~&gt; echo a b &amp;sep=, c # same, with the option mixed within arguments
              a,b,c

       <b>Note</b>: Since options have the same syntax as key-value pairs in maps, &amp;key is equivalent to &amp;key=$true:

              ~&gt; fn f [&amp;opt=$false]{ put $opt }
              ~&gt; f &amp;opt
              ▶ $true

       <b>Note</b>: Since &amp; is a metacharacter, it can be used to start an option immediately after the  command  name;
       echo&amp;sep=, a b is equivalent to echo &amp;sep=, a b, just less readable.  This might change in future.

   <b>Special</b> <b>command</b>
       A  <b>special</b>  <b>command</b>  form has the same syntax with an ordinary command, but how it is executed depends on
       the command head.  See special commands.

   <b>Legacy</b> <b>assignment</b> <b>form</b>
       If any argument in a command form is an unquoted equal sign (=), the command form is treated  as  an  as‐
       signment  form: the arguments to the left of =, including the head, are treated as lvalues, and the argu‐
       ments to the right of = are treated as values to assign to those lvalues.

       If any lvalue refers to a variable that doesn’t yet exist, it is created first.

       This is a legacy syntax that will be deprecated in future.  Use the var special command to declare  vari‐
       ables, and the set special command set the values of variables.

   <b>Temporary</b> <b>assignment</b>
       You  can  prepend  any  command form with <b>temporary</b> <b>assignments</b>, which gives variables temporarily values
       during the execution of that command.

       In the following example, $x and $y are temporarily assigned 100 and 200:

              ~&gt; x y = 1 2
              ~&gt; x=100 y=200 + $x $y
              ▶ 300
              ~&gt; echo $x $y
              1 2

       In contrary to normal assignments, there should be no whitespaces around the equal sign =.  To have  mul‐
       tiple variables in the left-hand side, use braces:

              ~&gt; x y = 1 2
              ~&gt; fn f { put 100 200 }
              ~&gt; {x,y}=(f) + $x $y
              ▶ 300

       If  you  use  a  previously undefined variable in a temporary assignment, its value will become the empty
       string after the command finishes.  This behavior will likely change; don’t rely on it.

       Since ordinary assignments are also command forms, they can also be prepended with temporary assignments:

              ~&gt; x=1
              ~&gt; x=100 y = (+ 133 $x)
              ~&gt; put $x $y
              ▶ 1
              ▶ 233

       Temporary assignments must all appear at the beginning of the command form.  As soon as something that is
       not a temporary assignments is parsed, Elvish no longer parses temporary assignments.  For  instance,  in
       x=1 echo x=1, the second x=1 is not a temporary assignment, but a bareword.

       <b>Note</b>:  Elvish’s  behavior  differs from bash (or zsh) in one important place.  In bash, temporary assign‐
       ments to variables do not affect their direct appearance in the command:

              bash-4.4$ x=1
              bash-4.4$ x=100 echo $x
              1

       <b>Note</b>: Elvish currently supports using the syntax of temporary assignments for ordinary assignments,  when
       they  are  not  followed  by  a command form; for example, a=x behaves like an ordinary assignment a = x.
       This will likely go away; don’t rely on it.

   <b>IO</b> <b>ports</b>
       A command have access to a number of <b>IO</b> <b>ports</b>.  Each IO port is identified by a number starting  from  0,
       and combines a traditional file object, which conveys bytes, and a <b>value</b> <b>channel</b>, which conveys values.

       Elvish starts with 3 IO ports at the top level with special significance for commands:

       • Port 0, known as standard input or stdin, and is used as the default input port by builtin commands.

       • Port 1, known as standard output or stdout, and is used as the default output port by builtin commands.

       • Port  2,  known as standard error or stderr, is currently not special for builtin commands, but usually
         has special significance for external commands.

       Value channels are typically created by a pipeline, and used to pass values between commands in the  same
       pipeline.  At the top level, they are initialized with special values:

       • The value channel for port 0 never produces any values when read.

       • The  value  channels  for  port 1 and 2 are special channels that forward the values written to them to
         their file counterparts.  Each value is put on a separate line, with a prefix controlled by $value-out-
         indicator.  The default prefix is ▶ followed by a space.

       When running an external command, the file object from each port is used to create  its  file  descriptor
       table.  Value channels only work inside the Elvish process, and are not accessible to external commands.

       IO ports can be modified with redirections or by pipelines.

   <b>Redirection</b>
       A <b>redirection</b> modifies the IO ports a command operate with.  There are several variants.

       A  <b>file</b>  <b>redirection</b>  opens a file and associates it with an IO port.  The syntax consists of an optional
       destination IO port (like 2), a redirection operator (like &gt;) and a filename (like error.log):

       • The <b>destination</b> <b>IO</b> <b>port</b> determines which IO port to modify.  It can be given either as  the  number  of
         the IO port, or one of stdin, stdout and stderr, which are equivalent to 0, 1 and 2 respectively.

         The destination IO port can be omitted, in which case it is inferred from the redirection operator.

         When  the  destination  IO  port  is  given, it must precede the redirection operator directly, without
         whitespaces in between; if there are whitespaces, otherwise Elvish will parse it  as  an  argument  in‐
         stead.

       • The <b>redirection</b> <b>operator</b> determines the mode to open the file, and the destination IO port if it is not
         explicitly specified.

       • The <b>filename</b> names the file to open.

       Possible redirection operators and their default FDs are:

       • &lt; for reading.  The default IO port is 0 (stdin).

       • &gt; for writing.  The default IO port is 1 (stdout).

       • &gt;&gt; for appending.  The default IO port is 1 (stdout).

       • &lt;&gt; for reading and writing.  The default IO port is 1 (stdout).

       Examples:

              ~&gt; echo haha &gt; log
              ~&gt; cat log
              haha
              ~&gt; cat &lt; log
              haha
              ~&gt; ls --bad-arg 2&gt; error
              Exception: ls exited with 2
              Traceback:
                [interactive], line 1:
                  ls --bad-arg 2&gt; error
              ~&gt; cat error
              <a href="file:/bin/ls">/bin/ls</a>: unrecognized option '--bad-arg'
              Try '<a href="file:/bin/ls">/bin/ls</a> --help' for more information.

       IO ports modified by file redirections do not support value channels.  To be more exact:

       • A file redirection using &lt; sets the value channel to one that never produces any values.

       • A  file redirection using &gt;, &gt;&gt; or &lt;&gt; sets the value channel to one that throws an exception when writ‐
         ten to.

       Examples:

              ~&gt; put foo &gt; file # will truncate file if it exists
              Exception: port has no value output
              [tty 2], line 1: put foo &gt; file
              ~&gt; echo content &gt; file
              ~&gt; only-values &lt; file
              ~&gt; # previous command produced nothing

       Redirections can also be used for closing or duplicating IO ports.  Instead of writing  a  filename,  use
       &amp;fd  (where  fd  is a number, or any of stdin, stdout and stderr) for duplicating, or &amp;- for closing.  In
       this case, the redirection operator only determines the default destination FD (and is totally irrevelant
       if a destination IO port is specified).  Examples:

              ~&gt; date &gt;&amp;-
              date: stdout: Bad file descriptor
              Exception: date exited with 1
              [tty 3], line 1: date &gt;&amp;-
              ~&gt; put foo &gt;&amp;-
              Exception: port has no value output
              [tty 37], line 1: put foo &gt;&amp;-

       If you have multiple related redirections, they are applied in the order they appear.  For instance:

              ~&gt; fn f { echo out; echo err &gt;&amp;2 } # echoes "out" on stdout, "err" on stderr
              ~&gt; f &gt;log 2&gt;&amp;1 # use file "log" for stdout, then use (changed) stdout for stderr
              ~&gt; cat log
              out
              err

       Redirections may appear anywhere in the command, except at the beginning, (this may be restricted in  fu‐
       ture).  It’s usually good style to write redirections at the end of command forms.

</pre><h4><b>Special</b> <b>commands</b></h4><pre>
       <b>Special</b> <b>commands</b> obey the same syntax rules as normal commands, but have evaluation rules that are custom
       to each command.  Consider the following example:

              ~&gt; or ?(echo x) ?(echo y) ?(echo z)
              x
              ▶ $ok

       In the example, the or command first evaluates its first argument, which has the value $ok (a truish val‐
       ue)  and the side effect of outputting x.  Due to the custom evaluation rule of or, the rest of the argu‐
       ments are not evaluated.

       If or were a normal command, the code above is still syntactically correct.  However, Elvish  would  then
       evaluate all its arguments, with the side effect of outputting x, y and z, before calling or.

   <b>Declaring</b> <b>variables:</b> <b>var</b> {#var}
       The  var  special  command  declares  local variables.  It takes any number of unqualified variable names
       (without the leading $).  The variables will start out having value $nil.  Examples:

              ~&gt; var a
              ~&gt; put $a
              ▶ $nil
              ~&gt; var foo bar
              ~&gt; put $foo $bar
              ▶ $nil
              ▶ $nil

       To set alternative initial values, add an unquoted = and the initial values.  Examples:

              ~&gt; var a b = foo bar
              ~&gt; put $a $b
              ▶ foo
              ▶ bar

       Similar to set, at most one of variables may be prefixed with @ to function as a rest variable.

       When declaring a variable that already exists, the existing variable is shadowed.  The shadowed  variable
       may still be accessed indirectly if it is referenced by a function.  Example:

              ~&gt; var x = old
              ~&gt; fn f { put $x }
              ~&gt; var x = new
              ~&gt; put $x
              ▶ new
              ~&gt; f
              ▶ old

   <b>Setting</b> <b>the</b> <b>value</b> <b>of</b> <b>variables</b> <b>or</b> <b>elements:</b> <b>set</b> {#set}
       The set special command sets the value of variables or elements.

       It  takes  any number of <b>lvalues</b> (which refer to either variables or elements), followed by an equal sign
       (=) and any number of expressions.  The equal sign must appear unquoted, as a single argument.

       An <b>lvalue</b> is one of the following:

       • A variable name (without $).

       • A variable name prefixed with @, for packing a variable number of values into a list and  assigning  to
         the variable.

         This variant is called a <b>rest</b> <b>variable</b>.  There could be at most one rest variable.

         <b>Note</b>:  Schematically  this is the reverse operation of exploding a variable when using it, which is why
         they share the @ sign.

       • A variable name followed by one or more indices in brackets ([]), for assigning to an element.

       The number of values the expressions evaluate to and lvalues must be compatible.  To be more exact:

       • If there is no rest variable, the number of values and lvalues must match exactly.

       • If there is a rest variable, the number of values should be at least the number of lvalues minus one.

       All the variables to set must already exist; use the var special command to declare new variables.

       Examples:

              ~&gt; var x y z
              ~&gt; set x = foo
              ~&gt; put $x
              ▶ foo
              ~&gt; x y = lorem ipsum
              ~&gt; put $x $y
              ▶ lorem
              ▶ ipsum
              ~&gt; set x @y z = a b
              ~&gt; put $x $y $z
              ▶ a
              ▶ []
              ▶ b
              ~&gt; set x @y z = a b c d
              ~&gt; put $x $y $z
              ▶ a
              ▶ [b c]
              ▶ d
              ~&gt; set y[0] = foo
              ~&gt; put $y
              ▶ [foo c]

       If the variable name contains any character that may not appear unquoted in variable use expressions,  it
       must be quoted even if it is otherwise a valid bareword:

              ~&gt; var 'a/b'
              ~&gt; set a/b = foo
              compilation error: lvalue must be valid literal variable names
              [tty 23], line 1: a/b = foo
              ~&gt; set 'a/b' = foo
              ~&gt; put $'a/b'
              ▶ foo

       Lists  and  maps  in Elvish are immutable.  As a result, when assigning to the element of a variable that
       contains a list or map, Elvish does not mutate the underlying list or map.  Instead, Elvish creates a new
       list or map with the mutation applied, and assigns it to the variable.  Example:

              ~&gt; var li = [foo bar]
              ~&gt; var li2 = $li
              ~&gt; set li[0] = lorem
              ~&gt; put $li $li2
              ▶ [lorem bar]
              ▶ [foo bar]

   <b>Deleting</b> <b>variables</b> <b>or</b> <b>elements:</b> <b>del</b> {#del}
       The del special command can be used to delete variables or map elements.  Operands  should  be  specified
       without a leading dollar sign, like the left-hand side of assignments.

       Example of deleting variable:

              ~&gt; x = 2
              ~&gt; echo $x
              2
              ~&gt; del x
              ~&gt; echo $x
              Compilation error: variable $x not found
              [tty], line 1: echo $x

       If  the variable name contains any character that cannot appear unquoted after $, it must be quoted, even
       if it is otherwise a valid bareword:

              ~&gt; 'a/b' = foo
              ~&gt; del 'a/b'

       Deleting a variable does not affect closures that have already captured it; it  only  removes  the  name.
       Example:

              ~&gt; x = value
              ~&gt; fn f { put $x }
              ~&gt; del x
              ~&gt; f
              ▶ value

       Example of deleting map element:

              ~&gt; m = [&amp;k=v &amp;k2=v2]
              ~&gt; del m[k2]
              ~&gt; put $m
              ▶ [&amp;k=v]
              ~&gt; l = [[&amp;k=v &amp;k2=v2]]
              ~&gt; del l[0][k2]
              ~&gt; put $l
              ▶ [[&amp;k=v]]

   <b>Logics:</b> <b>and</b>, or, coalesce {#and-or-coalesce}
       The  and special command outputs the first booleanly false value the arguments evaluate to, or $true when
       given no value.  Examples:

              ~&gt; and $true $false
              ▶ $false
              ~&gt; and a b c
              ▶ c
              ~&gt; and a $false
              ▶ $false

       The or special command outputs the first booleanly true value the arguments evaluate to, or  $false  when
       given no value.  Examples:

              ~&gt; or $true $false
              ▶ $true
              ~&gt; or a b c
              ▶ a
              ~&gt; or $false a b
              ▶ a

       The coalesce special command outputs the first non-nil value the arguments evaluate to, or $nil when giv‐
       en no value.  Examples:

              ~&gt; coalesce $nil a b
              ▶ a
              ~&gt; coalesce $nil $nil
              ▶ $nil
              ~&gt; coalesce $nil $nil a
              ▶ a
              ~&gt; coalesce a b
              ▶ a

       All three commands use short-circuit evaluation, and stop evaluating arguments as soon as it sees a value
       satisfying the termination condition.  For example, none of the following throws an exception:

              ~&gt; and $false (fail foo)
              ▶ $false
              ~&gt; or $true (fail foo)
              ▶ $true
              ~&gt; coalesce a (fail foo)
              ▶ a

   <b>Condition:</b> <b>if</b> {#if}
       <b>TODO</b>: Document the syntax notation, and add more examples.

       Syntax:

              if &lt;condition&gt; {
                  &lt;body&gt;
              } elif &lt;condition&gt; {
                  &lt;body&gt;
              } else {
                  &lt;else-body&gt;
              }

       The  if  special  command goes through the conditions one by one: as soon as one evaluates to a booleanly
       true value, its corresponding body is executed.  If none of conditions are booleanly  true  and  an  else
       body is supplied, it is executed.

       The condition part is an expression, not a command like in other shells.  Example:

              fn tell-language [fname]{
                  if (has-suffix $fname .go) {
                      echo $fname" is a Go file!"
                  } elif (has-suffix $fname .c) {
                      echo $fname" is a C file!"
                  } else {
                      echo $fname" is a mysterious file!"
                  }
              }

       The  condition part must be syntactically a single expression, but it can evaluate to multiple values, in
       which case they are and’ed:

              if (put $true $false) {
                  echo "will not be executed"
              }

       If the expression evaluates to 0 values, it is considered true, consistent with how and works.

       Tip: a combination of if and ?() gives you a semantics close to other shells:

              if ?(test -d .git) {
                  # do something
              }

       However, for Elvish’s builtin predicates that output values instead of throw exceptions, the output  cap‐
       ture construct () should be used.

   <b>Conditional</b> <b>loop:</b> <b>while</b> {#while}
       Syntax:

              while &lt;condition&gt; {
                  &lt;body&gt;
              } else {
                  &lt;else-body&gt;
              }

       Execute the body as long as the condition evaluates to a booleanly true value.

       The else body, if present, is executed if the body has never been executed (i.e.  the condition evaluates
       to a booleanly false value in the very beginning).

   <b>Iterative</b> <b>loop:</b> <b>for</b> {#for}
       Syntax:

              for &lt;var&gt; &lt;container&gt; {
                  &lt;body&gt;
              } else {
                  &lt;body&gt;
              }

       Iterate  the  container (e.g.  a list).  In each iteration, assign the variable to an element of the con‐
       tainer and execute the body.

       The else body, if present, is executed if the body has never been executed (i.e.  the iteration value has
       no elements).

   <b>Exception</b> <b>control:</b> <b>try</b> {#try}
       (If you just want to capture the exception, you can use the more concise exception capture construct  ?()
       instead.)

       Syntax:

              try {
                  &lt;try-block&gt;
              } except except-varname {
                  &lt;except-block&gt;
              } else {
                  &lt;else-block&gt;
              } finally {
                  &lt;finally-block&gt;
              }

       Only try and try-block are required.  This control structure behaves as follows:

       1. The try-block is always executed first.

       2. If  except is present and an exception occurs in try-block, it is caught and stored in except-varname,
          and except-block is then executed.  Example:

                  ~&gt; try { fail bad } except e { put $e }
                  ▶ ?(fail bad)

           Note that if except is not present, exceptions thrown from try are not caught: for  instance,  try  {
           fail bad } throws bad; it is equivalent to a plain fail bad.

           Note  that  the  word after except names a variable, not a matching condition.  Exception matching is
           not supported yet.  For instance, you may want to only match exceptions that were created  with  fail
           bad  with  except  bad, but in fact this creates a variable $bad that contains whatever exception was
           thrown.

       3. If no exception occurs and else is present, else-block is executed.  Example:

                  ~&gt; try { nop } else { echo well }
                  well

       4. If finally-block is present, it is executed.  Examples:

                  ~&gt; try { fail bad } finally { echo final }
                  final
                  Exception: bad
                  Traceback:
                    [tty], line 1:
                      try { fail bad } finally { echo final }
                  ~&gt; try { echo good } finally { echo final }
                  good
                  final

       5. If the exception was not caught (i.e.  except is not present), it is rethrown.

       Exceptions thrown in blocks other than try-block are not caught.  If an exception was thrown  and  either
       except-block or finally-block throws another exception, the original exception is lost.  Examples:

              ~&gt; try { fail bad } except e { fail worse }
              Exception: worse
              Traceback:
                [tty], line 1:
                  try { fail bad } except e { fail worse }
              ~&gt; try { fail bad } except e { fail worse } finally { fail worst }
              Exception: worst
              Traceback:
                [tty], line 1:
                  try { fail bad } except e { fail worse } finally { fail worst }

   <b>Function</b> <b>definition:</b> <b>fn</b> {#fn}
       Syntax:

              fn &lt;name&gt; &lt;lambda&gt;

       Define  a  function with a given name.  The function behaves in the same way to the lambda used to define
       it, except that it “captures” return.  In other words, return will fall through lambdas not defined  with
       fn, and continues until it exits a function defined with fn:

              ~&gt; fn f {
                   { echo a; return }
                   echo b # will not execute
                 }
              ~&gt; f
              a
              ~&gt; {
                   f
                   echo c # executed, because f "captures" the return
                 }
              a
              c

       <b>TODO</b>: Find a better way to describe this.  Hopefully the example is illustrative enough, though.

       The lambda may refer to the function being defined.  This makes it easy to define recursive functions:

              ~&gt; fn f [n]{ if (== $n 0) { put 1 } else { * $n (f (- $n 1)) } }
              ~&gt; f 3
              ▶ (float64 6)

       Under the hood, fn defines a variable with the given name plus ~ (see variable suffix).  Example:

              ~&gt; fn f { echo hello from f }
              ~&gt; var v = $f~
              ~&gt; $v
              hello from f

   <b>Language</b> <b>pragmas:</b> <b>pragma</b> {#pragma}
       The  pragma  special  command can be used to set <b>pragmas</b> that affect the behavior of the Elvish language.
       The syntax looks like:

              pragma &lt;name&gt; = &lt;value&gt;

       The name must appear literally.  The value must also appear literally, unless otherwise specified.

       Pragmas apply from the point it appears, to the end of the lexical scope it appears  in,  including  sub‐
       scopes.

       The following pragmas are available:

       • The unknown-command pragma affects the resolution of command heads, and can take one of two values, ex‐
         ternal (the default) and disallow.  See ordinary command for details.

         <b>Note</b>: pragma unknown-command = disallow enables a style where uses of external commands must be explic‐
         itly via the e: namespace.  You can also explicitly declare a set of external commands to use directly,
         like the following:

                pragma unknown-command = disallow
                var ls = $e:ls~
                var cat = $e:cat~
                # ls and cat can be used directly;
                # other external commands must be prefixed with e:

</pre><h4><b>Pipeline</b></h4><pre>
       A <b>pipeline</b> is formed by joining one or more commands together with the pipe sign (|).

       For  each  pair of adjacent commands a | b, the standard output of the left-hand command a (IO port 1) is
       connected to the standard input (IO port 0) of the right-hand command b.  Both the  file  and  the  value
       channel are connected, even if one of them is not used.

       Elvish  may  have  internal  buffering for both the file and the value channel, so a may be able to write
       bytes or values even if b is not reading them.  The exact buffer size is not specified.

       Command redirections are applied before the connection happens.  For instance, the following  writes  foo
       to a.txt instead of the output:

              ~&gt; echo foo &gt; a.txt | cat
              ~&gt; cat a.txt
              foo

       A pipeline runs all of its command in parallel, and terminates when all of the commands have terminated.

   <b>Pipeline</b> <b>exception</b>
       If  one or more command in a pipeline throws an exception, the other commands will continue to execute as
       normal.  After all commands finish execution, an exception is thrown, the value of which depends  on  the
       number of commands that have thrown an exception:

       • If only one command has thrown an exception, that exception is rethrown.

       • If  more  than one commands have thrown exceptions, a “composite exception”, containing information all
         exceptions involved, is thrown.

       If a command threw an exception because it tried to write output when the next  command  has  terminated,
       that exception is suppressed when it is propagated to the pipeline.

       For  example, the put command throws an exception when trying to write to a closed pipe, so the following
       loop will terminate with an exception:

              ~&gt; while $true { put foo } &gt; &amp;-
              Exception: port has no value output
              [tty 9], line 1: while $true { put foo } &gt; &amp;-

       However, if it appears in a pipeline before nop, the entire pipeline will not throw an exception:

              ~&gt; while $true { put foo } | nop
              ~&gt; # no exception thrown from previous line

       Internally, the put foo command still threw an exception, but since that exception was trying to write to
       output when nop already terminated, that exception was suppressed by the pipeline.

       This can be more clearly observed with the following code:

              ~&gt; var r = $false
              ~&gt; { while $true { put foo }; set r = $true } | nop
              ~&gt; put $r
              ▶ $false

       The same mechanism works for builtin commands that write to the byte output:

              ~&gt; var r = $false
              ~&gt; { while $true { echo foo }; set r = $true } | nop
              ~&gt; put $r
              ▶ $false

       On UNIX, if an external command was terminated by SIGPIPE, and Elvish detected that it  terminated  after
       the  next command in the pipeline, such exceptions will also be suppressed by the pipeline.  For example,
       the following pipeline does not throw an exception, despite the yes command being killed by SIGPIPE:

              ~&gt; yes | head -n1
              y

   <b>Background</b> <b>pipeline</b>
       Adding an ampersand &amp; to the end of a pipeline will cause it to be executed in the background.   In  this
       case,  the  rest  of  the code chunk will continue to execute without waiting for the pipeline to finish.
       Exceptions thrown from the background pipeline do not affect the code chunk that contains it.

       When a background pipeline finishes, a message is printed to the terminal if the shell is interactive.

</pre><h4><b>Code</b> <b>Chunk</b></h4><pre>
       A <b>code</b> <b>chunk</b> is formed by joining zero or more pipelines together, separating them with  either  newlines
       or semicolons.

       Pipelines  in  a code chunk are executed in sequence.  If any pipeline throws an exception, the execution
       of the whole code chunk stops, propagating that exception.

</pre><h4><b>Exception</b> <b>and</b> <b>Flow</b> <b>Commands</b></h4><pre>
       Exceptions have similar semantics to those in Python or Java.  They can be thrown with the  fail  command
       and caught with either exception capture ?() or the try special command.

       If an external command exits with a non-zero status, Elvish treats that as an exception.

       Flow  commands – break, continue and return – are ordinary builtin commands that raise special “flow con‐
       trol” exceptions.  The for, while, and peach commands capture break and continue, while fn  modifies  its
       closure to capture return.

       One  interesting  implication  is that since flow commands are just ordinary commands you can build func‐
       tions on top of them.  For instance, this function breaks randomly:

              fn random-break {
                if eq (randint 2) 0 {
                  break
                }
              }

       The function random-break can then be used in for-loops and while-loops.

       Note that the return flow control exception is only captured by functions  defined  with  fn.   It  falls
       through ordinary lambdas:

              fn f {
                {
                  # returns f, falling through the innermost lambda
                  return
                }
              }

</pre><h4><b>Namespaces</b> <b>and</b> <b>Modules</b></h4><pre>
       Like  other modern programming languages, but unlike traditional shells, Elvish has a <b>namespace</b> mechanism
       for preventing name collisions.

   <b>Syntax</b>
       Prepend namespace: to command names and variable names to specify the namespace.  The following code

              e:echo $E:PATH

       uses the echo command from the e: namespace and the PATH variable from the E: namespace.   The  colon  is
       considered part of the namespace name.

       Namespaces  may  be nested; for example, calling edit:location:start first finds the edit: namespace, and
       then the location: namespace inside it, and then call the start function within the nested namespace.

   <b>Special</b> <b>namespaces</b>
       The following namespaces have special meanings to the language:

       • local: and up: refer to lexical scopes, and have been documented above.

       • e: refers to externals.  For instance, e:ls refers to the external command ls.

         Most of the time you can rely on static resolution rules of ordinary commands and do not  need  to  use
         this explicitly, unless a function defined by you (or an Elvish builtin) shadows an external command.

       • E: refers to environment variables.  For instance, $E:USER is the environment variable USER.

         This  <b>is</b>  always needed, because unlike command resolution, variable resolution does not fall back onto
         environment variables.

       • builtin: refers to builtin functions and variables.

         You don’t need to use this explicitly unless you have defined names that shadows builtin counterparts.

   <b>Modules</b>
       Apart from the special namespaces, the most common usage of namespaces is to reference modules,  reusable
       pieces of code that are either shipped with Elvish itself or defined by the user.

   <b>Importing</b> <b>modules</b> <b>with</b> <b>use</b>
       Modules  are  imported  using  the use special command.  It requires a <b>module</b> <b>spec</b> and allows a namespace
       alias:

              use $spec $alias?

       The module spec and the alias must both be a simple string literal.  Compound strings such as  'a'/b  are
       not allowed.

       The module spec specifies which module to import.  The alias, if given, specifies the namespace to import
       the module under.  By default, the namespace is derived from the module spec by taking the part after the
       last slash.

       Module specs fall into three categories that are resolved in the following order:

       1. <b>Relative</b>: These are relative to the file containing the use command.

       2. <b>User</b> <b>defined</b>: These match a user defined module in a module search directory.

       3. <b>Pre-defined</b>: These match the name of a pre-defined module, such as math or str.

       If a module spec doesn’t match any of the above a “no such module” exception is raised.

       Examples:

              use str # imports the "str" module as "str:"
              use a/b/c # imports the "a/b/c" module as "c:"
              use a/b/c foo # imports the "a/b/c" module as "foo:"

   <b>Pre-defined</b> <b>modules</b>
       Elvish’s standard library provides the following pre-defined modules that can be imported by the use com‐
       mand:

       • edit  is only available in interactive mode.  As a special case it does not need importing via use, but
         this may change in the future.

       • epm

       • math

       • path

       • platform

       • re

       • readline-binding

       • store

       • str

       • unix is only available on UNIX-like platforms (see $platform:is-unix)

   <b>User-defined</b> <b>modules</b>
       You can define your own modules in Elvish by putting them under one of the module search directories  and
       giving  them  a  .elv extension (but see relative imports for an alternative).  For instance, to define a
       module named a, you can put the following in <a href="file:~/.config/elvish/lib/a.elv">~/.config/elvish/lib/a.elv</a> (on  Windows,  replace  <a href="file:~/.config">~/.config</a>
       with ~\AppData\Roaming):

              ~&gt; cat <a href="file:~/.config/elvish/lib/a.elv">~/.config/elvish/lib/a.elv</a>
              echo "mod a loading"
              fn f {
                echo "f from mod a"
              }

       This module can now be imported by use a:

              ~&gt; use a
              mod a loading
              ~&gt; a:f
              f from mod a

       Similarly, a module defined in <a href="file:~/.config/elvish/lib/x/y/z.elv">~/.config/elvish/lib/x/y/z.elv</a> can be imported by use x/y/z:

              ~&gt; cat .config/elvish/lib/x/y/z.elv
              fn f {
                echo "f from x/y/z"
              }
              ~&gt; use x/y/z
              ~&gt; z:f
              f from x/y/z

       In general, a module defined in namespace will be the same as the file name (without the .elv extension).

       There  is  experimental  support  for  importing  modules  written  in  Go.   See  the project repository
       (https://github.com/elves/elvish) for details.

   <b>Circular</b> <b>dependencies</b>
       Circular dependencies are allowed but has an important restriction.  If a module a  contains  use  b  and
       module  b contains use a, the top-level statements in module b will only be able to access variables that
       are defined before the use b in module a; other variables will be $nil.

       On the other hand, functions in module b will have access to bindings in module a after it is fully eval‐
       uated.

       Examples:

              ~&gt; cat a.elv
              var before = before
              use ./b
              var after = after
              ~&gt; cat b.elv
              use ./a
              put $a:before $a:after
              fn f { put $a:before $a:after }
              ~&gt; use ./a
              ▶ before
              ▶ $nil
              ~&gt; use ./b
              ~&gt; b:f
              ▶ before
              ▶ after

       Note that this behavior can be different depending on whether the REPL imports a or b first.  In the pre‐
       vious example, if the REPL imports b first, it will have access to all the variables in a:

              ~&gt; use ./b
              ▶ before
              ▶ after

       <b>Note</b>: Elvish caches imported modules.  If you are trying this locally, run a fresh Elvish  instance  with
       exec first.

       When  you  do need to have circular dependencies, it is best to avoid using variables from the modules in
       top-level statements, and only use them in functions.

   <b>Relative</b> <b>imports</b>
       The module spec may begin with ./ or ../ to introduce a <b>relative</b> <b>import</b>.  When use is invoked from a file
       this will import the file relative to the location of the file.  When use is invoked from an  interactive
       prompt, this will import the file relative to the current working directory.

   <b>Scoping</b> <b>of</b> <b>imports</b>
       Namespace  imports  are lexically scoped.  For instance, if you use a module within an inner scope, it is
       not available outside that scope:

              {
                  use some-mod
                  some-mod:some-func
              }
              some-mod:some-func # not valid

       The imported modules themselves are also evaluated in a separate scope.  That means  that  functions  and
       variables defined in the module does not pollute the default namespace, and vice versa.  For instance, if
       you define ls as a wrapper function in rc.elv:

              fn ls [@a]{
                  e:ls --color=auto $@a
              }

       That  definition  is  not visible in module files: ls will still refer to the external command ls, unless
       you shadow it in the very same module.

   <b>Re-importing</b>
       Modules are cached after one import.  Subsequent imports do not re-execute the module;  they  only  serve
       the  bring  it  into  the current scope.  Moreover, the cache is keyed by the path of the module, not the
       name  under  which  it  is  imported.   For  instance,   if   you   have   the   following   in   <a href="file:~/.con">~/.con</a>‐
       fig/elvish/lib/a/b.elv:

              echo importing

       The following code only prints one importing:

              { use a/b }
              use a/b # only brings mod into the lexical scope

       As does the following:

              use a/b
              use a/b alias

Elvish 0.17.0                                     Nov 18, 2024                                <u><a href="../man7/elvish-language.7.html">elvish-language</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>