<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tcp - TCP protocol</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tcp - TCP protocol

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/netinet/tcp.h">netinet/tcp.h</a>&gt;</b>

       <u>tcp_socket</u> <b>=</b> <b>socket(AF_INET,</b> <b>SOCK_STREAM,</b> <b>0);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  is an implementation of the TCP protocol defined in RFC 793, RFC 1122 and RFC 2001 with the NewReno
       and SACK extensions.  It provides a reliable, stream-oriented, full-duplex connection between two sockets
       on top of <b><a href="../man7/ip.7.html">ip</a></b>(7), for both v4 and v6 versions.   TCP  guarantees  that  the  data  arrives  in  order  and
       retransmits  lost  packets.   It generates and checks a per-packet checksum to catch transmission errors.
       TCP does not preserve record boundaries.

       A newly created TCP socket has no remote or local address and is  not  fully  specified.   To  create  an
       outgoing  TCP  connection use <b><a href="../man2/connect.2.html">connect</a></b>(2) to establish a connection to another TCP socket.  To receive new
       incoming connections, first <b><a href="../man2/bind.2.html">bind</a></b>(2) the socket to a local address and port and then call <b><a href="../man2/listen.2.html">listen</a></b>(2) to put
       the socket into the listening state.  After that a  new  socket  for  each  incoming  connection  can  be
       accepted  using  <b><a href="../man2/accept.2.html">accept</a></b>(2).   A socket which has had <b><a href="../man2/accept.2.html">accept</a></b>(2) or <b><a href="../man2/connect.2.html">connect</a></b>(2) successfully called on it is
       fully specified and may transmit data.  Data cannot be transmitted on  listening  or  not  yet  connected
       sockets.

       Linux  supports  RFC 1323  TCP  high  performance  extensions.   These include Protection Against Wrapped
       Sequence Numbers (PAWS), Window Scaling and Timestamps.  Window scaling allows the use of large (&gt; 64 kB)
       TCP windows in order to support links with high latency or bandwidth.  To make use of them, the send  and
       receive  buffer  sizes  must be increased.  They can be set globally with the <u><a href="file:/proc/sys/net/ipv4/tcp_wmem">/proc/sys/net/ipv4/tcp_wmem</a></u>
       and <u><a href="file:/proc/sys/net/ipv4/tcp_rmem">/proc/sys/net/ipv4/tcp_rmem</a></u> files, or on individual sockets by  using  the  <b>SO_SNDBUF</b>  and  <b>SO_RCVBUF</b>
       socket options with the <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2) call.

       The  maximum  sizes for socket buffers declared via the <b>SO_SNDBUF</b> and <b>SO_RCVBUF</b> mechanisms are limited by
       the values in the <u><a href="file:/proc/sys/net/core/rmem_max">/proc/sys/net/core/rmem_max</a></u>  and  <u><a href="file:/proc/sys/net/core/wmem_max">/proc/sys/net/core/wmem_max</a></u>  files.   Note  that  TCP
       actually  allocates twice the size of the buffer requested in the <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2) call, and so a succeeding
       <b><a href="../man2/getsockopt.2.html">getsockopt</a></b>(2) call will not return the same size of buffer as requested in the <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2)  call.   TCP
       uses  the  extra  space  for  administrative  purposes and internal kernel structures, and the <u><a href="file:/proc">/proc</a></u> file
       values reflect the larger sizes compared to the actual  TCP  windows.   On  individual  connections,  the
       socket  buffer  size  must  be  set  prior  to the <b><a href="../man2/listen.2.html">listen</a></b>(2) or <b><a href="../man2/connect.2.html">connect</a></b>(2) calls in order to have it take
       effect.  See <b><a href="../man7/socket.7.html">socket</a></b>(7) for more information.

       TCP supports urgent data.  Urgent data is used to signal the receiver that some important message is part
       of the data stream and that it should be processed as soon as possible.  To send urgent data specify  the
       <b>MSG_OOB</b> option to <b><a href="../man2/send.2.html">send</a></b>(2).  When urgent data is received, the kernel sends a <b>SIGURG</b> signal to the process
       or  process group that has been set as the socket "owner" using the <b>SIOCSPGRP</b> or <b>FIOSETOWN</b> ioctls (or the
       POSIX.1-specified <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_SETOWN</b> operation).  When the <b>SO_OOBINLINE</b> socket option is  enabled,  urgent
       data  is  put into the normal data stream (a program can test for its location using the <b>SIOCATMARK</b> ioctl
       described below), otherwise it can be received  only  when  the  <b>MSG_OOB</b>  flag  is  set  for  <b><a href="../man2/recv.2.html">recv</a></b>(2)  or
       <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2).

       When  out-of-band  data  is  present,  <b><a href="../man2/select.2.html">select</a></b>(2)  indicates  the file descriptor as having an exceptional
       condition and <u>poll</u> <u>(2)</u> indicates a <b>POLLPRI</b> event.

       Linux 2.4 introduced a number of changes for  improved  throughput  and  scaling,  as  well  as  enhanced
       functionality.   Some  of  these  features include support for zero-copy <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), Explicit Congestion
       Notification, new management of TIME_WAIT sockets, keep-alive socket options and  support  for  Duplicate
       SACK extensions.

   <b>Address</b> <b>formats</b>
       TCP  is built on top of IP (see <b><a href="../man7/ip.7.html">ip</a></b>(7)).  The address formats defined by <b><a href="../man7/ip.7.html">ip</a></b>(7) apply to TCP.  TCP supports
       point-to-point communication only; broadcasting and multicasting are not supported.

   <b><a href="file:/proc">/proc</a></b> <b>interfaces</b>
       System-wide TCP parameter settings can be accessed by files in  the  directory  <u><a href="file:/proc/sys/net/ipv4/">/proc/sys/net/ipv4/</a></u>.   In
       addition,  most IP <u><a href="file:/proc">/proc</a></u> interfaces also apply to TCP; see <b><a href="../man7/ip.7.html">ip</a></b>(7).  Variables described as <u>Boolean</u> take an
       integer value, with a nonzero value ("true") meaning that the corresponding option is enabled, and a zero
       value ("false") meaning that the option is disabled.

       <u>tcp_abc</u> (Integer; default: 0; Linux 2.6.15 to Linux 3.8)
              Control the Appropriate Byte Count (ABC), defined in RFC 3465.  ABC is a  way  of  increasing  the
              congestion  window  (<u>cwnd</u>)  more  slowly in response to partial acknowledgements.  Possible values
              are:

              <b>0</b>      increase <u>cwnd</u> once per acknowledgement (no ABC)

              <b>1</b>      increase <u>cwnd</u> once per acknowledgement of full sized segment

              <b>2</b>      allow increase <u>cwnd</u> by two if acknowledgement is of two segments to compensate for  delayed
                     acknowledgements.

       <u>tcp_abort_on_overflow</u> (Boolean; default: disabled; since Linux 2.4)
              Enable resetting connections if the listening service is too slow and unable to keep up and accept
              them.   It  means  that  if overflow occurred due to a burst, the connection will recover.  Enable
              this option <u>only</u> if you are really sure that the  listening  daemon  cannot  be  tuned  to  accept
              connections faster.  Enabling this option can harm the clients of your server.

       <u>tcp_adv_win_scale</u> (integer; default: 2; since Linux 2.4)
              Count  buffering overhead as <u>bytes/2^tcp_adv_win_scale</u>, if <u>tcp_adv_win_scale</u> is greater than 0; or
              <u>bytes-bytes/2^(-tcp_adv_win_scale)</u>, if <u>tcp_adv_win_scale</u> is less than or equal to zero.

              The socket receive buffer space is shared between the application and kernel.  TCP maintains  part
              of  the  buffer  as the TCP window, this is the size of the receive window advertised to the other
              end.  The rest of the space is used as the "application" buffer, used to isolate the network  from
              scheduling  and  application latencies.  The <u>tcp_adv_win_scale</u> default value of 2 implies that the
              space used for the application buffer is one fourth that of the total.

       <u>tcp_allowed_congestion_control</u> (String; default: see text; since Linux 2.4.20)
              Show/set the congestion control algorithm choices available to  unprivileged  processes  (see  the
              description  of  the  <b>TCP_CONGESTION</b> socket option).  The items in the list are separated by white
              space and terminated  by  a  newline  character.   The  list  is  a  subset  of  those  listed  in
              <u>tcp_available_congestion_control</u>.   The  default  value  for  this list is "reno" plus the default
              setting of <u>tcp_congestion_control</u>.

       <u>tcp_autocorking</u> (Boolean; default: enabled; since Linux 3.14)
              If this option is enabled, the kernel tries to coalesce small writes  (from  consecutive  <b><a href="../man2/write.2.html">write</a></b>(2)
              and  <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2) calls) as much as possible, in order to decrease the total number of sent packets.
              Coalescing is done if at least one prior packet for the flow is waiting in Qdisc queues or  device
              transmit  queue.  Applications can still use the <b>TCP_CORK</b> socket option to obtain optimal behavior
              when they know how/when to uncork their sockets.

       <u>tcp_available_congestion_control</u> (String; read-only; since Linux 2.4.20)
              Show a list of the congestion-control algorithms that are registered.  The items in the  list  are
              separated  by  white space and terminated by a newline character.  This list is a limiting set for
              the list in <u>tcp_allowed_congestion_control</u>.  More congestion-control algorithms may  be  available
              as modules, but not loaded.

       <u>tcp_app_win</u> (integer; default: 31; since Linux 2.4)
              This variable defines how many bytes of the TCP window are reserved for buffering overhead.

              A  maximum  of  (<u>window/2^tcp_app_win</u>,  mss)  bytes in the window are reserved for the application
              buffer.  A value of 0 implies that no amount is reserved.

       <u>tcp_base_mss</u> (Integer; default: 512; since Linux 2.6.17)
              The initial value of <u>search_low</u> to be used by the packetization  layer  Path  MTU  discovery  (MTU
              probing).  If MTU probing is enabled, this is the initial MSS used by the connection.

       <u>tcp_bic</u> (Boolean; default: disabled; Linux 2.4.27/2.6.6 to Linux 2.6.13)
              Enable  BIC TCP congestion control algorithm.  BIC-TCP is a sender-side-only change that ensures a
              linear RTT fairness  under  large  windows  while  offering  both  scalability  and  bounded  TCP-
              friendliness.   The  protocol  combines  two  schemes  called  additive increase and binary search
              increase.  When the congestion window is large, additive increase with a large  increment  ensures
              linear  RTT  fairness  as well as good scalability.  Under small congestion windows, binary search
              increase provides TCP friendliness.

       <u>tcp_bic_low_window</u> (integer; default: 14; Linux 2.4.27/2.6.6 to Linux 2.6.13)
              Set the threshold window (in packets) where BIC TCP starts to adjust the congestion window.  Below
              this threshold BIC TCP behaves the same as the default TCP Reno.

       <u>tcp_bic_fast_convergence</u> (Boolean; default: enabled; Linux 2.4.27/2.6.6 to Linux 2.6.13)
              Force BIC TCP to more quickly respond to changes in congestion window.  Allows two  flows  sharing
              the same connection to converge more rapidly.

       <u>tcp_congestion_control</u> (String; default: see text; since Linux 2.4.13)
              Set the default congestion-control algorithm to be used for new connections.  The algorithm "reno"
              is  always  available,  but additional choices may be available depending on kernel configuration.
              The default value for this file is set as part of kernel configuration.

       <u>tcp_dma_copybreak</u> (integer; default: 4096; since Linux 2.6.24)
              Lower limit, in bytes, of the size of socket reads that will be offloaded to a DMA copy engine, if
              one is present in the system and the kernel was configured with the <b>CONFIG_NET_DMA</b> option.

       <u>tcp_dsack</u> (Boolean; default: enabled; since Linux 2.4)
              Enable RFC 2883 TCP Duplicate SACK support.

       <u>tcp_fastopen</u> (Bitmask; default: 0x1; since Linux 3.7)
              Enables RFC 7413 Fast Open support.  The flag is used as a bitmap with the following values:

              <b>0x1</b>    Enables client side Fast Open support

              <b>0x2</b>    Enables server side Fast Open support

              <b>0x4</b>    Allows client side to transmit data in SYN without Fast Open option

              <b>0x200</b>  Allows server side to accept SYN data without Fast Open option

              <b>0x400</b>  Enables Fast Open on all listeners without <b>TCP_FASTOPEN</b> socket option

       <u>tcp_fastopen_key</u> (since Linux 3.7)
              Set server side RFC 7413 Fast Open key to generate Fast Open cookie when  server  side  Fast  Open
              support is enabled.

       <u>tcp_ecn</u> (Integer; default: see below; since Linux 2.4)
              Enable RFC 3168 Explicit Congestion Notification.

              This file can have one of the following values:

              <b>0</b>      Disable  ECN.   Neither  initiate nor accept ECN.  This was the default up to and including
                     Linux 2.6.30.

              <b>1</b>      Enable ECN when requested  by  incoming  connections  and  also  request  ECN  on  outgoing
                     connection attempts.

              <b>2</b>      Enable  ECN  when  requested  by  incoming  connections, but do not request ECN on outgoing
                     connections.  This value is supported, and is the default, since Linux 2.6.31.

              When enabled, connectivity to some destinations could be affected due to older, misbehaving middle
              boxes along the path, causing connections to be dropped.  However,  to  facilitate  and  encourage
              deployment with option 1, and to work around such buggy equipment, the <b>tcp_ecn_fallback</b> option has
              been introduced.

       <u>tcp_ecn_fallback</u> (Boolean; default: enabled; since Linux 4.1)
              Enable  RFC 3168,  Section 6.1.1.1. fallback.  When enabled, outgoing ECN-setup SYNs that time out
              within the normal SYN retransmission timeout will be resent with CWR and ECE cleared.

       <u>tcp_fack</u> (Boolean; default: enabled; since Linux 2.2)
              Enable TCP Forward Acknowledgement support.

       <u>tcp_fin_timeout</u> (integer; default: 60; since Linux 2.2)
              This specifies how many seconds to wait for a final FIN  packet  before  the  socket  is  forcibly
              closed.  This is strictly a violation of the TCP specification, but required to prevent denial-of-
              service attacks.  In Linux 2.2, the default value was 180.

       <u>tcp_frto</u> (integer; default: see below; since Linux 2.4.21/2.6)
              Enable  F-RTO,  an  enhanced  recovery  algorithm  for  TCP retransmission timeouts (RTOs).  It is
              particularly beneficial in wireless environments where packet loss  is  typically  due  to  random
              radio interference rather than intermediate router congestion.  See RFC 4138 for more details.

              This file can have one of the following values:

              <b>0</b>      Disabled.  This was the default up to and including Linux 2.6.23.

              <b>1</b>      The basic version F-RTO algorithm is enabled.

              <b>2</b>      Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be used also when SACK
                     is  in  use  though  in  that  case scenario(s) exists where F-RTO interacts badly with the
                     packet counting of the SACK-enabled TCP flow.   This  value  is  the  default  since  Linux
                     2.6.24.

              Before Linux 2.6.22, this parameter was a Boolean value, supporting just values 0 and 1 above.

       <u>tcp_frto_response</u> (integer; default: 0; since Linux 2.6.22)
              When  F-RTO  has  detected that a TCP retransmission timeout was spurious (i.e., the timeout would
              have been avoided had TCP set a longer retransmission timeout), TCP has several options concerning
              what to do next.  Possible values are:

              <b>0</b>      Rate halving based; a smooth and conservative response, results in halved congestion window
                     (<u>cwnd</u>) and slow-start threshold (<u>ssthresh</u>) after one RTT.

              <b>1</b>      Very conservative response; not recommended because even though being valid,  it  interacts
                     poorly with the rest of Linux TCP; halves <u>cwnd</u> and <u>ssthresh</u> immediately.

              <b>2</b>      Aggressive   response;  undoes  congestion-control  measures  that  are  now  known  to  be
                     unnecessary (ignoring the possibility of a lost retransmission that would require TCP to be
                     more cautious); <u>cwnd</u> and <u>ssthresh</u> are restored to the values prior to timeout.

       <u>tcp_keepalive_intvl</u> (integer; default: 75; since Linux 2.4)
              The number of seconds between TCP keep-alive probes.

       <u>tcp_keepalive_probes</u> (integer; default: 9; since Linux 2.2)
              The maximum number of TCP keep-alive probes to send before giving up and killing the connection if
              no response is obtained from the other end.

       <u>tcp_keepalive_time</u> (integer; default: 7200; since Linux 2.2)
              The number of seconds a connection needs to be idle  before  TCP  begins  sending  out  keep-alive
              probes.   Keep-alives  are  sent only when the <b>SO_KEEPALIVE</b> socket option is enabled.  The default
              value is 7200 seconds (2  hours).   An  idle  connection  is  terminated  after  approximately  an
              additional 11 minutes (9 probes an interval of 75 seconds apart) when keep-alive is enabled.

              Note that underlying connection tracking mechanisms and application timeouts may be much shorter.

       <u>tcp_low_latency</u> (Boolean; default: disabled; since Linux 2.4.21/2.6; obsolete since Linux 4.14)
              If  enabled,  the  TCP  stack  makes  decisions  that  prefer  lower  latency as opposed to higher
              throughput.  It this option is disabled, then higher throughput is preferred.  An  example  of  an
              application  where this default should be changed would be a Beowulf compute cluster.  Since Linux
              4.14, this file still exists, but its value is ignored.

       <u>tcp_max_orphans</u> (integer; default: see below; since Linux 2.4)
              The maximum number of orphaned (not attached to any user file handle) TCP sockets allowed  in  the
              system.   When this number is exceeded, the orphaned connection is reset and a warning is printed.
              This limit exists only to prevent simple denial-of-service attacks.  Lowering this  limit  is  not
              recommended.   Network conditions might require you to increase the number of orphans allowed, but
              note that each orphan can eat up to ~64 kB of unswappable memory.  The default  initial  value  is
              set  equal  to  the  kernel  parameter NR_FILE.  This initial default is adjusted depending on the
              memory in the system.

       <u>tcp_max_syn_backlog</u> (integer; default: see below; since Linux 2.2)
              The maximum number of queued connection requests which have still not received an  acknowledgement
              from  the connecting client.  If this number is exceeded, the kernel will begin dropping requests.
              The default value of 256 is increased to 1024 when the memory present in the system is adequate or
              greater (&gt;= 128 MB), and reduced to 128 for those systems with very low memory (&lt;= 32 MB).

              Before Linux 2.6.20, it was recommended that if this needed to be increased above 1024,  the  size
              of the SYNACK hash table (<b>TCP_SYNQ_HSIZE</b>) in <u>include/net/tcp.h</u> should be modified to keep

                  TCP_SYNQ_HSIZE * 16 &lt;= tcp_max_syn_backlog

              and  the kernel should be recompiled.  In Linux 2.6.20, the fixed sized <b>TCP_SYNQ_HSIZE</b> was removed
              in favor of dynamic sizing.

       <u>tcp_max_tw_buckets</u> (integer; default: see below; since Linux 2.4)
              The maximum number of sockets in TIME_WAIT state allowed in the system.  This limit exists only to
              prevent simple denial-of-service attacks.  The default value of NR_FILE*2 is adjusted depending on
              the memory in the system.  If this number is exceeded, the socket  is  closed  and  a  warning  is
              printed.

       <u>tcp_moderate_rcvbuf</u> (Boolean; default: enabled; since Linux 2.4.17/2.6.7)
              If  enabled,  TCP performs receive buffer auto-tuning, attempting to automatically size the buffer
              (no greater than <u>tcp_rmem[2]</u>) to match the size required by the path for full throughput.

       <u>tcp_mem</u> (since Linux 2.4)
              This is a vector of 3 integers: [low, pressure, high].  These bounds, measured  in  units  of  the
              system  page size, are used by TCP to track its memory usage.  The defaults are calculated at boot
              time from the amount of available memory.  (TCP can only use <u>low</u> <u>memory</u> for this, which is limited
              to around 900 megabytes on 32-bit systems.  64-bit systems do not suffer this limitation.)

              <u>low</u>    TCP doesn't regulate its memory allocation when  the  number  of  pages  it  has  allocated
                     globally is below this number.

              <u>pressure</u>
                     When  the amount of memory allocated by TCP exceeds this number of pages, TCP moderates its
                     memory consumption.  This memory  pressure  state  is  exited  once  the  number  of  pages
                     allocated falls below the <u>low</u> mark.

              <u>high</u>   The  maximum  number  of pages, globally, that TCP will allocate.  This value overrides any
                     other limits imposed by the kernel.

       <u>tcp_mtu_probing</u> (integer; default: 0; since Linux 2.6.17)
              This parameter controls TCP Packetization-Layer Path MTU Discovery.  The following values  may  be
              assigned to the file:

              <b>0</b>      Disabled

              <b>1</b>      Disabled by default, enabled when an ICMP black hole detected

              <b>2</b>      Always enabled, use initial MSS of <u>tcp_base_mss</u>.

       <u>tcp_no_metrics_save</u> (Boolean; default: disabled; since Linux 2.6.6)
              By default, TCP saves various connection metrics in the route cache when the connection closes, so
              that connections established in the near future can use these to set initial conditions.  Usually,
              this  increases  overall  performance,  but  it  may  sometimes cause performance degradation.  If
              <u>tcp_no_metrics_save</u> is enabled, TCP will not cache metrics on closing connections.

       <u>tcp_orphan_retries</u> (integer; default: 8; since Linux 2.4)
              The maximum number of attempts made to probe the other end of a connection which has  been  closed
              by our end.

       <u>tcp_reordering</u> (integer; default: 3; since Linux 2.4)
              The  maximum a packet can be reordered in a TCP packet stream without TCP assuming packet loss and
              going into slow start.  It is not advisable to change this number.  This is  a  packet  reordering
              detection  metric designed to minimize unnecessary back off and retransmits provoked by reordering
              of packets on a connection.

       <u>tcp_retrans_collapse</u> (Boolean; default: enabled; since Linux 2.2)
              Try to send full-sized packets during retransmit.

       <u>tcp_retries1</u> (integer; default: 3; since Linux 2.2)
              The number of times TCP will attempt to retransmit a packet on an established connection normally,
              without the extra effort of getting the network layers involved.  Once we exceed  this  number  of
              retransmits,  we  first  have  the  network  layer  update  the  route if possible before each new
              retransmit.  The default is the RFC specified minimum of 3.

       <u>tcp_retries2</u> (integer; default: 15; since Linux 2.2)
              The maximum number of times a TCP packet is retransmitted in established state before  giving  up.
              The  default  value  is  15,  which  corresponds  to  a duration of approximately between 13 to 30
              minutes, depending on the retransmission timeout.  The RFC 1122 specified  minimum  limit  of  100
              seconds is typically deemed too short.

       <u>tcp_rfc1337</u> (Boolean; default: disabled; since Linux 2.2)
              Enable  TCP  behavior  conformant with RFC 1337.  When disabled, if a RST is received in TIME_WAIT
              state, we close the socket immediately without waiting for the end of the TIME_WAIT period.

       <u>tcp_rmem</u> (since Linux 2.4)
              This is a vector of 3 integers: [min, default, max].  These parameters are used by TCP to regulate
              receive buffer sizes.  TCP dynamically adjusts the size of the receive buffer  from  the  defaults
              listed below, in the range of these values, depending on memory available in the system.

              <u>min</u>    minimum  size  of  the  receive  buffer  used by each TCP socket.  The default value is the
                     system page size.  (On Linux 2.4, the default value is 4 kB, lowered to <b>PAGE_SIZE</b> bytes  in
                     low-memory  systems.)   This  value  is  used  to  ensure  that  in  memory  pressure mode,
                     allocations below this size will still succeed.  This is not used to bound the size of  the
                     receive buffer declared using <b>SO_RCVBUF</b> on a socket.

              <u>default</u>
                     the default size of the receive buffer for a TCP socket.  This value overwrites the initial
                     default  buffer  size  from  the  generic  global  <u>net.core.rmem_default</u>  defined  for  all
                     protocols.  The default value is 87380 bytes.  (On Linux 2.4, this will be lowered to 43689
                     in low-memory systems.)  If larger receive buffer sizes are desired, this value  should  be
                     increased    (to    affect    all   sockets).    To   employ   large   TCP   windows,   the
                     <u>net.ipv4.tcp_window_scaling</u> must be enabled (default).

              <u>max</u>    the maximum size of the receive buffer used by  each  TCP  socket.   This  value  does  not
                     override  the  global <u>net.core.rmem_max</u>.  This is not used to limit the size of the receive
                     buffer declared using <b>SO_RCVBUF</b> on a socket.  The default value  is  calculated  using  the
                     formula

                         max(87380, min(4 MB, <u>tcp_mem</u>[1]*PAGE_SIZE/128))

                     (On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in low-memory systems).

       <u>tcp_sack</u> (Boolean; default: enabled; since Linux 2.2)
              Enable RFC 2018 TCP Selective Acknowledgements.

       <u>tcp_slow_start_after_idle</u> (Boolean; default: enabled; since Linux 2.6.18)
              If enabled, provide RFC 2861 behavior and time out the congestion window after an idle period.  An
              idle  period  is defined as the current RTO (retransmission timeout).  If disabled, the congestion
              window will not be timed out after an idle period.

       <u>tcp_stdurg</u> (Boolean; default: disabled; since Linux 2.2)
              If this option is enabled, then use the RFC 1122 interpretation of the TCP  urgent-pointer  field.
              According  to  this interpretation, the urgent pointer points to the last byte of urgent data.  If
              this option is disabled, then use the BSD-compatible interpretation of  the  urgent  pointer:  the
              urgent  pointer  points to the first byte after the urgent data.  Enabling this option may lead to
              interoperability problems.

       <u>tcp_syn_retries</u> (integer; default: 6; since Linux 2.2)
              The maximum  number  of  times  initial  SYNs  for  an  active  TCP  connection  attempt  will  be
              retransmitted.   This  value  should  not  be  higher  than  255.   The  default value is 6, which
              corresponds to retrying for up to approximately 127 seconds.  Before Linux 3.7, the default  value
              was  5,  which  (in conjunction with calculation based on other kernel parameters) corresponded to
              approximately 180 seconds.

       <u>tcp_synack_retries</u> (integer; default: 5; since Linux 2.2)
              The maximum number of times a SYN/ACK segment for a passive TCP connection will be  retransmitted.
              This number should not be higher than 255.

       <u>tcp_syncookies</u> (integer; default: 1; since Linux 2.2)
              Enable  TCP  syncookies.   The  kernel  must  be compiled with <b>CONFIG_SYN_COOKIES</b>.  The syncookies
              feature attempts to protect a socket from a SYN flood attack.  This  should  be  used  as  a  last
              resort, if at all.  This is a violation of the TCP protocol, and conflicts with other areas of TCP
              such as TCP extensions.  It can cause problems for clients and relays.  It is not recommended as a
              tuning  mechanism  for heavily loaded servers to help with overloaded or misconfigured conditions.
              For    recommended    alternatives    see     <u>tcp_max_syn_backlog</u>,     <u>tcp_synack_retries</u>,     and
              <u>tcp_abort_on_overflow</u>.  Set to one of the following values:

              <b>0</b>      Disable TCP syncookies.

              <b>1</b>      Send out syncookies when the syn backlog queue of a socket overflows.

              <b>2</b>      (since  Linux  3.12)  Send  out syncookies unconditionally.  This can be useful for network
                     testing.

       <u>tcp_timestamps</u> (integer; default: 1; since Linux 2.2)
              Set to one of the following values to enable or disable RFC 1323 TCP timestamps:

              <b>0</b>      Disable timestamps.

              <b>1</b>      Enable timestamps as defined in RFC1323 and use random offset for  each  connection  rather
                     than only using the current time.

              <b>2</b>      As  for  the  value 1, but without random offsets.  Setting <u>tcp_timestamps</u> to this value is
                     meaningful since Linux 4.10.

       <u>tcp_tso_win_divisor</u> (integer; default: 3; since Linux 2.6.9)
              This parameter controls what percentage of the congestion window can be consumed by a  single  TCP
              Segmentation  Offload (TSO) frame.  The setting of this parameter is a tradeoff between burstiness
              and building larger TSO frames.

       <u>tcp_tw_recycle</u> (Boolean; default: disabled; Linux 2.4 to Linux 4.11)
              Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not recommended as the remote
              IP may not use  monotonically  increasing  timestamps  (devices  behind  NAT,  devices  with  per-
              connection timestamp offsets).  See RFC 1323 (PAWS) and RFC 6191.

       <u>tcp_tw_reuse</u> (Boolean; default: disabled; since Linux 2.4.19/2.6)
              Allow  to reuse TIME_WAIT sockets for new connections when it is safe from protocol viewpoint.  It
              should not be changed without advice/request of technical experts.

       <u>tcp_vegas_cong_avoid</u> (Boolean; default: disabled; Linux 2.2 to Linux 2.6.13)
              Enable TCP Vegas congestion avoidance algorithm.  TCP Vegas is a sender-side-only  change  to  TCP
              that  anticipates  the  onset  of  congestion  by estimating the bandwidth.  TCP Vegas adjusts the
              sending rate by modifying the congestion window.  TCP Vegas should provide less packet  loss,  but
              it is not as aggressive as TCP Reno.

       <u>tcp_westwood</u> (Boolean; default: disabled; Linux 2.4.26/2.6.3 to Linux 2.6.13)
              Enable   TCP  Westwood+  congestion  control  algorithm.   TCP  Westwood+  is  a  sender-side-only
              modification of the TCP Reno protocol stack that  optimizes  the  performance  of  TCP  congestion
              control.   It  is based on end-to-end bandwidth estimation to set congestion window and slow start
              threshold after a congestion episode.  Using this estimation, TCP Westwood+ adaptively sets a slow
              start threshold and a congestion window which takes into account the bandwidth used  at  the  time
              congestion  is  experienced.   TCP  Westwood+ significantly increases fairness with respect to TCP
              Reno in wired networks and throughput over wireless links.

       <u>tcp_window_scaling</u> (Boolean; default: enabled; since Linux 2.2)
              Enable RFC 1323 TCP window scaling.  This feature allows the use of a large window (&gt; 64 kB) on  a
              TCP  connection, should the other end support it.  Normally, the 16 bit window length field in the
              TCP header limits the window size to less than 64 kB.  If larger windows are desired, applications
              can increase the size of their socket buffers and the window scaling option will be employed.   If
              <u>tcp_window_scaling</u>  is  disabled,  TCP will not negotiate the use of window scaling with the other
              end during connection setup.

       <u>tcp_wmem</u> (since Linux 2.4)
              This is a vector of 3 integers: [min, default, max].  These parameters are used by TCP to regulate
              send buffer sizes.  TCP dynamically adjusts the size of the send buffer from  the  default  values
              listed below, in the range of these values, depending on memory available.

              <u>min</u>    Minimum  size  of the send buffer used by each TCP socket.  The default value is the system
                     page size.  (On Linux 2.4, the default value is 4 kB.)  This value is used to  ensure  that
                     in  memory pressure mode, allocations below this size will still succeed.  This is not used
                     to bound the size of the send buffer declared using <b>SO_SNDBUF</b> on a socket.

              <u>default</u>
                     The default size of the send buffer for a TCP socket.  This value  overwrites  the  initial
                     default buffer size from the generic global <u><a href="file:/proc/sys/net/core/wmem_default">/proc/sys/net/core/wmem_default</a></u> defined for all
                     protocols.   The  default  value  is  16 kB.  If larger send buffer sizes are desired, this
                     value should be increased (to affect all  sockets).   To  employ  large  TCP  windows,  the
                     <u><a href="file:/proc/sys/net/ipv4/tcp_window_scaling">/proc/sys/net/ipv4/tcp_window_scaling</a></u> must be set to a nonzero value (default).

              <u>max</u>    The  maximum size of the send buffer used by each TCP socket.  This value does not override
                     the value in <u><a href="file:/proc/sys/net/core/wmem_max">/proc/sys/net/core/wmem_max</a></u>.  This is not used to limit the size of  the  send
                     buffer  declared  using  <b>SO_SNDBUF</b>  on a socket.  The default value is calculated using the
                     formula

                         max(65536, min(4 MB, <u>tcp_mem</u>[1]*PAGE_SIZE/128))

                     (On Linux 2.4, the default value is 128 kB, lowered 64 kB depending on low-memory systems.)

       <u>tcp_workaround_signed_windows</u> (Boolean; default: disabled; since Linux 2.6.26)
              If enabled, assume that no receipt of a window-scaling option means that the remote TCP is  broken
              and treats the window as a signed quantity.  If disabled, assume that the remote TCP is not broken
              even if we do not receive a window scaling option from it.

   <b>Socket</b> <b>options</b>
       To  set  or get a TCP socket option, call <b><a href="../man2/getsockopt.2.html">getsockopt</a></b>(2) to read or <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2) to write the option with
       the option level argument set to <b>IPPROTO_TCP</b>.  Unless otherwise noted, <u>optval</u> is a pointer to an <u>int</u>.  In
       addition, most <b>IPPROTO_IP</b> socket options are valid on TCP sockets.  For more information see <b><a href="../man7/ip.7.html">ip</a></b>(7).

       Following is a list of TCP-specific socket options.  For details of some other socket  options  that  are
       also applicable for TCP sockets, see <b><a href="../man7/socket.7.html">socket</a></b>(7).

       <b>TCP_CONGESTION</b> (since Linux 2.6.13)
              The argument for this option is a string.  This option allows the caller to set the TCP congestion
              control  algorithm  to  be  used, on a per-socket basis.  Unprivileged processes are restricted to
              choosing one of the algorithms in <u>tcp_allowed_congestion_control</u>  (described  above).   Privileged
              processes  (<b>CAP_NET_ADMIN</b>) can choose from any of the available congestion-control algorithms (see
              the description of <u>tcp_available_congestion_control</u> above).

       <b>TCP_CORK</b> (since Linux 2.2)
              If set, don't send out partial frames.  All queued partial frames are  sent  when  the  option  is
              cleared  again.   This  is  useful  for  prepending  headers  before  calling  <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), or for
              throughput optimization.  As currently implemented, there is a 200 millisecond ceiling on the time
              for which output is corked by  <b>TCP_CORK</b>.   If  this  ceiling  is  reached,  then  queued  data  is
              automatically  transmitted.  This option can be combined with <b>TCP_NODELAY</b> only since Linux 2.5.71.
              This option should not be used in code intended to be portable.

       <b>TCP_DEFER_ACCEPT</b> (since Linux 2.4)
              Allow a listener to be awakened only when data arrives on the  socket.   Takes  an  integer  value
              (seconds), this can bound the maximum number of attempts TCP will make to complete the connection.
              This option should not be used in code intended to be portable.

       <b>TCP_INFO</b> (since Linux 2.4)
              Used to collect information about this socket.  The kernel returns a <u>struct</u> <u>tcp_info</u> as defined in
              the  file  <u><a href="file:/usr/include/linux/tcp.h">/usr/include/linux/tcp.h</a></u>.   This  option  should  not  be  used  in code intended to be
              portable.

       <b>TCP_KEEPCNT</b> (since Linux 2.4)
              The maximum number of keepalive probes TCP should  send  before  dropping  the  connection.   This
              option should not be used in code intended to be portable.

       <b>TCP_KEEPIDLE</b> (since Linux 2.4)
              The  time  (in  seconds)  the  connection needs to remain idle before TCP starts sending keepalive
              probes, if the socket option <b>SO_KEEPALIVE</b> has been set on this socket.  This option should not  be
              used in code intended to be portable.

       <b>TCP_KEEPINTVL</b> (since Linux 2.4)
              The time (in seconds) between individual keepalive probes.  This option should not be used in code
              intended to be portable.

       <b>TCP_LINGER2</b> (since Linux 2.4)
              The lifetime of orphaned FIN_WAIT2 state sockets.  This option can be used to override the system-
              wide  setting  in  the file <u><a href="file:/proc/sys/net/ipv4/tcp_fin_timeout">/proc/sys/net/ipv4/tcp_fin_timeout</a></u> for this socket.  This is not to be
              confused with the <b><a href="../man7/socket.7.html">socket</a></b>(7) level option <b>SO_LINGER</b>.  This  option  should  not  be  used  in  code
              intended to be portable.

       <b>TCP_MAXSEG</b>
              The  maximum segment size for outgoing TCP packets.  In Linux 2.2 and earlier, and in Linux 2.6.28
              and later, if this option is set before connection establishment, it also changes  the  MSS  value
              announced  to  the  other end in the initial packet.  Values greater than the (eventual) interface
              MTU have no effect.  TCP will also impose its minimum and maximum bounds over the value provided.

       <b>TCP_NODELAY</b>
              If set, disable the Nagle algorithm.  This  means  that  segments  are  always  sent  as  soon  as
              possible,  even  if  there  is  only a small amount of data.  When not set, data is buffered until
              there is a sufficient amount to send out, thereby avoiding the frequent sending of small  packets,
              which results in poor utilization of the network.  This option is overridden by <b>TCP_CORK</b>; however,
              setting this option forces an explicit flush of pending output, even if <b>TCP_CORK</b> is currently set.

       <b>TCP_QUICKACK</b> (since Linux 2.4.4)
              Enable  quickack mode if set or disable quickack mode if cleared.  In quickack mode, acks are sent
              immediately, rather than delayed if needed in accordance to normal TCP operation.   This  flag  is
              not permanent, it only enables a switch to or from quickack mode.  Subsequent operation of the TCP
              protocol  will  once again enter/leave quickack mode depending on internal protocol processing and
              factors such as delayed ack timeouts occurring and data transfer.  This option should not be  used
              in code intended to be portable.

       <b>TCP_SYNCNT</b> (since Linux 2.4)
              Set the number of SYN retransmits that TCP should send before aborting the attempt to connect.  It
              cannot exceed 255.  This option should not be used in code intended to be portable.

       <b>TCP_USER_TIMEOUT</b> (since Linux 2.6.37)
              This  option takes an <u>unsigned</u> <u>int</u> as an argument.  When the value is greater than 0, it specifies
              the maximum amount of time in milliseconds that transmitted data  may  remain  unacknowledged,  or
              buffered  data  may  remain untransmitted (due to zero window size) before TCP will forcibly close
              the corresponding connection and return <b>ETIMEDOUT</b> to the application.   If  the  option  value  is
              specified as 0, TCP will use the system default.

              Increasing  user  timeouts  allows a TCP connection to survive extended periods without end-to-end
              connectivity.  Decreasing user timeouts  allows  applications  to  "fail  fast",  if  so  desired.
              Otherwise,  failure  may  take  up  to 20 minutes with the current system defaults in a normal WAN
              environment.

              This option can be set during any state of a TCP connection, but  is  effective  only  during  the
              synchronized states of a connection (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, and
              LAST-ACK).   Moreover,  when  used  with the TCP keepalive (<b>SO_KEEPALIVE</b>) option, <b>TCP_USER_TIMEOUT</b>
              will override keepalive to determine when to close a connection due to keepalive failure.

              The option has no effect on when TCP retransmits a packet, nor when a keepalive probe is sent.

              This option, like many others, will be inherited by the socket returned by <b><a href="../man2/accept.2.html">accept</a></b>(2),  if  it  was
              set on the listening socket.

              Further  details  on  the  user  timeout  feature  can be found in RFC 793 and RFC 5482 ("TCP User
              Timeout Option").

       <b>TCP_WINDOW_CLAMP</b> (since Linux 2.4)
              Bound the size of the advertised window to this value.  The  kernel  imposes  a  minimum  size  of
              SOCK_MIN_RCVBUF/2.  This option should not be used in code intended to be portable.

       <b>TCP_FASTOPEN</b> (since Linux 3.6)
              This  option enables Fast Open (RFC 7413) on the listener socket.  The value specifies the maximum
              length of pending SYNs (similar to the backlog argument in <b><a href="../man2/listen.2.html">listen</a></b>(2)).  Once enabled, the listener
              socket grants the TCP Fast Open cookie on incoming SYN with TCP Fast Open option.

              More importantly it accepts the data in SYN with a valid Fast Open  cookie  and  responds  SYN-ACK
              acknowledging  both  the  data and the SYN sequence.  <b><a href="../man2/accept.2.html">accept</a></b>(2) returns a socket that is available
              for read and write when the handshake has not completed yet.  Thus the data exchange can  commence
              before  the  handshake completes.  This option requires enabling the server-side support on sysctl
              <u>net.ipv4.tcp_fastopen</u>  (see  above).   For  TCP  Fast  Open  client-side  support,   see   <b><a href="../man2/send.2.html">send</a></b>(2)
              <b>MSG_FASTOPEN</b> or <b>TCP_FASTOPEN_CONNECT</b> below.

       <b>TCP_FASTOPEN_CONNECT</b> (since Linux 4.11)
              This  option  enables  an  alternative way to perform Fast Open on the active side (client).  When
              this option is enabled, <b><a href="../man2/connect.2.html">connect</a></b>(2) would behave differently depending on if a Fast Open cookie  is
              available for the destination.

              If  a cookie is not available (i.e. first contact to the destination), <b><a href="../man2/connect.2.html">connect</a></b>(2) behaves as usual
              by sending a SYN immediately, except the SYN would include an empty Fast  Open  cookie  option  to
              solicit a cookie.

              If  a  cookie  is  available,  <b><a href="../man2/connect.2.html">connect</a></b>(2)  would  return 0 immediately but the SYN transmission is
              deferred.  A subsequent <b><a href="../man2/write.2.html">write</a></b>(2) or <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2) would trigger a SYN with data plus  cookie  in  the
              Fast  Open  option.   In  other  words,  the  actual  connect  operation is deferred until data is
              supplied.

              <b>Note:</b> While this option is designed for convenience, enabling it does  change  the  behaviors  and
              certain  system  calls  might  set  different  <u>errno</u>  values.   With  cookie  present, <b><a href="../man2/write.2.html">write</a></b>(2) or
              <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2) must be called right after <b><a href="../man2/connect.2.html">connect</a></b>(2) in order to send out SYN+data  to  complete  3WHS
              and  establish connection.  Calling <b><a href="../man2/read.2.html">read</a></b>(2) right after <b><a href="../man2/connect.2.html">connect</a></b>(2) without <b><a href="../man2/write.2.html">write</a></b>(2) will cause the
              blocking socket to be blocked forever.

              The  application  should  either  set  <b>TCP_FASTOPEN_CONNECT</b>  socket  option  before  <b><a href="../man2/write.2.html">write</a></b>(2)   or
              <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), or call <b><a href="../man2/write.2.html">write</a></b>(2) or <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2) with <b>MSG_FASTOPEN</b> flag directly, instead of both on the
              same connection.

              Here is the typical call flow with this new option:

                  s = socket();
                  setsockopt(s, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, 1, ...);
                  connect(s);
                  write(s); /* write() should always follow connect()
                             * in order to trigger SYN to go out. */
                  read(s)/write(s);
                  /* ... */
                  close(s);

   <b>Sockets</b> <b>API</b>
       TCP  provides  limited  support  for out-of-band data, in the form of (a single byte of) urgent data.  In
       Linux this means if the other end sends newer out-of-band data the  older  urgent  data  is  inserted  as
       normal data into the stream (even when <b>SO_OOBINLINE</b> is not set).  This differs from BSD-based stacks.

       Linux  uses  the  BSD  compatible  interpretation  of the urgent pointer field by default.  This violates
       RFC 1122,  but  is  required  for  interoperability  with  other  stacks.   It   can   be   changed   via
       <u><a href="file:/proc/sys/net/ipv4/tcp_stdurg">/proc/sys/net/ipv4/tcp_stdurg</a></u>.

       It is possible to peek at out-of-band data using the <b><a href="../man2/recv.2.html">recv</a></b>(2) <b>MSG_PEEK</b> flag.

       Since  Linux  2.4, Linux supports the use of <b>MSG_TRUNC</b> in the <u>flags</u> argument of <b><a href="../man2/recv.2.html">recv</a></b>(2) (and <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2)).
       This flag causes the received bytes of data to be discarded, rather than passed back in a caller-supplied
       buffer.  Since Linux 2.4.4, <b>MSG_TRUNC</b> also has this effect when  used  in  conjunction  with  <b>MSG_OOB</b>  to
       receive out-of-band data.

   <b>Ioctls</b>
       The following <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) calls return information in <u>value</u>.  The correct syntax is:

              <b>int</b> <u>value</u><b>;</b>
              <u>error</u> <b>=</b> <b>ioctl(</b><u>tcp_socket</u><b>,</b> <u>ioctl_type</u><b>,</b> <b>&amp;</b><u>value</u><b>);</b>

       <u>ioctl_type</u> is one of the following:

       <b>SIOCINQ</b>
              Returns  the amount of queued unread data in the receive buffer.  The socket must not be in LISTEN
              state, otherwise an  error  (<b>EINVAL</b>)  is  returned.   <b>SIOCINQ</b>  is  defined  in  <u>&lt;linux/sockios.h&gt;</u>.
              Alternatively, you can use the synonymous <b>FIONREAD</b>, defined in <u>&lt;sys/ioctl.h&gt;</u>.

       <b>SIOCATMARK</b>
              Returns true (i.e., <u>value</u> is nonzero) if the inbound data stream is at the urgent mark.

              If the <b>SO_OOBINLINE</b> socket option is set, and <b>SIOCATMARK</b> returns true, then the next read from the
              socket  will return the urgent data.  If the <b>SO_OOBINLINE</b> socket option is not set, and <b>SIOCATMARK</b>
              returns true, then the next read from the socket will return the bytes following the  urgent  data
              (to actually read the urgent data requires the <b>recv(MSG_OOB)</b> flag).

              Note  that  a  read  never  reads  across  the  urgent mark.  If an application is informed of the
              presence of urgent data via <b><a href="../man2/select.2.html">select</a></b>(2) (using the <u>exceptfds</u> argument)  or  through  delivery  of  a
              <b>SIGURG</b>  signal,  then it can advance up to the mark using a loop which repeatedly tests <b>SIOCATMARK</b>
              and performs a read (requesting any number of bytes) as long as <b>SIOCATMARK</b> returns false.

       <b>SIOCOUTQ</b>
              Returns the amount of unsent data in the socket send queue.  The socket  must  not  be  in  LISTEN
              state,  otherwise  an  error  (<b>EINVAL</b>)  is  returned.   <b>SIOCOUTQ</b>  is defined in <u>&lt;linux/sockios.h&gt;</u>.
              Alternatively, you can use the synonymous <b>TIOCOUTQ</b>, defined in <u>&lt;sys/ioctl.h&gt;</u>.

   <b>Error</b> <b>handling</b>
       When a network error occurs, TCP tries to resend the packet.  If it  doesn't  succeed  after  some  time,
       either <b>ETIMEDOUT</b> or the last received error on this connection is reported.

       Some  applications  require  a quicker error notification.  This can be enabled with the <b>IPPROTO_IP</b> level
       <b>IP_RECVERR</b> socket option.  When this option is enabled, all incoming errors are immediately passed to the
       user program.  Use this option with care  it makes TCP less tolerant to routing changes and other normal
       network conditions.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAFNOTSUPPORT</b>
              Passed socket address type in <u>sin_family</u> was not <b>AF_INET</b>.

       <b>EPIPE</b>  The other end closed the socket unexpectedly or a read is executed on a shut down socket.

       <b>ETIMEDOUT</b>
              The other end didn't acknowledge retransmitted data after some time.

       Any errors defined for <b><a href="../man7/ip.7.html">ip</a></b>(7) or the generic socket layer may also be returned for TCP.

</pre><h4><b>VERSIONS</b></h4><pre>
       Support for Explicit Congestion Notification, zero-copy <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), reordering  support  and  some  SACK
       extensions  (DSACK)  were introduced in Linux 2.4.  Support for forward acknowledgement (FACK), TIME_WAIT
       recycling, and per-connection keepalive socket options were introduced in Linux 2.3.

</pre><h4><b>BUGS</b></h4><pre>
       Not all errors are documented.

       IPv6 is not described.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/accept.2.html">accept</a></b>(2), <b><a href="../man2/bind.2.html">bind</a></b>(2), <b><a href="../man2/connect.2.html">connect</a></b>(2), <b><a href="../man2/getsockopt.2.html">getsockopt</a></b>(2), <b><a href="../man2/listen.2.html">listen</a></b>(2), <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2), <b><a href="../man2/sendfile.2.html">sendfile</a></b>(2), <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), <b><a href="../man2/socket.2.html">socket</a></b>(2),
       <b><a href="../man7/ip.7.html">ip</a></b>(7), <b><a href="../man7/socket.7.html">socket</a></b>(7)

       The kernel source file <u>Documentation/networking/ip-sysctl.txt</u>.

       RFC 793 for the TCP specification.
       RFC 1122 for the TCP requirements and a description of the Nagle algorithm.
       RFC 1323 for TCP timestamp and window scaling options.
       RFC 1337 for a description of TIME_WAIT assassination hazards.
       RFC 3168 for a description of Explicit Congestion Notification.
       RFC 2581 for TCP congestion control algorithms.
       RFC 2018 and RFC 2883 for SACK and extensions to SACK.

Linux man-pages 6.9.1                              2024-05-02                                             <u><a href="../man7/tcp.7.html">tcp</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>