<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CREATE_SEQUENCE - define a new sequence generator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/postgresql-client-17">postgresql-client-17_17.5-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CREATE_SEQUENCE - define a new sequence generator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       CREATE [ { TEMPORARY | TEMP } | UNLOGGED ] SEQUENCE [ IF NOT EXISTS ] <u>name</u>
           [ AS <u>data_type</u> ]
           [ INCREMENT [ BY ] <u>increment</u> ]
           [ MINVALUE <u>minvalue</u> | NO MINVALUE ] [ MAXVALUE <u>maxvalue</u> | NO MAXVALUE ]
           [ START [ WITH ] <u>start</u> ] [ CACHE <u>cache</u> ] [ [ NO ] CYCLE ]
           [ OWNED BY { <u>table_name</u>.<u>column_name</u> | NONE } ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>CREATE</b> <b>SEQUENCE</b> creates a new sequence number generator. This involves creating and initializing a new
       special single-row table with the name <u>name</u>. The generator will be owned by the user issuing the command.

       If a schema name is given then the sequence is created in the specified schema. Otherwise it is created
       in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given
       when creating a temporary sequence. The sequence name must be distinct from the name of any other
       relation (table, sequence, index, view, materialized view, or foreign table) in the same schema.

       After a sequence is created, you use the functions <b>nextval</b>, <b>currval</b>, and <b>setval</b> to operate on the
       sequence. These functions are documented in Section 9.17.

       Although you cannot update a sequence directly, you can use a query like:

           SELECT * FROM <u>name</u>;

       to examine the parameters and current state of a sequence. In particular, the last_value field of the
       sequence shows the last value allocated by any session. (Of course, this value might be obsolete by the
       time it's printed, if other sessions are actively doing <b>nextval</b> calls.)

</pre><h4><b>PARAMETERS</b></h4><pre>
       TEMPORARY or TEMP
           If specified, the sequence object is created only for this session, and is automatically dropped on
           session exit. Existing permanent sequences with the same name are not visible (in this session) while
           the temporary sequence exists, unless they are referenced with schema-qualified names.

       UNLOGGED
           If specified, the sequence is created as an unlogged sequence. Changes to unlogged sequences are not
           written to the write-ahead log. They are not crash-safe: an unlogged sequence is automatically reset
           to its initial state after a crash or unclean shutdown. Unlogged sequences are also not replicated to
           standby servers.

           Unlike unlogged tables, unlogged sequences do not offer a significant performance advantage. This
           option is mainly intended for sequences associated with unlogged tables via identity columns or
           serial columns. In those cases, it usually wouldn't make sense to have the sequence WAL-logged and
           replicated but not its associated table.

       IF NOT EXISTS
           Do not throw an error if a relation with the same name already exists. A notice is issued in this
           case. Note that there is no guarantee that the existing relation is anything like the sequence that
           would have been created — it might not even be a sequence.

       <u>name</u>
           The name (optionally schema-qualified) of the sequence to be created.

       <u>data_type</u>
           The optional clause AS <u>data_type</u> specifies the data type of the sequence. Valid types are smallint,
           integer, and bigint.  bigint is the default. The data type determines the default minimum and maximum
           values of the sequence.

       <u>increment</u>
           The optional clause INCREMENT BY <u>increment</u> specifies which value is added to the current sequence
           value to create a new value. A positive value will make an ascending sequence, a negative one a
           descending sequence. The default value is 1.

       <u>minvalue</u>
       NO MINVALUE
           The optional clause MINVALUE <u>minvalue</u> determines the minimum value a sequence can generate. If this
           clause is not supplied or <b>NO</b> <b>MINVALUE</b> is specified, then defaults will be used. The default for an
           ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.

       <u>maxvalue</u>
       NO MAXVALUE
           The optional clause MAXVALUE <u>maxvalue</u> determines the maximum value for the sequence. If this clause
           is not supplied or <b>NO</b> <b>MAXVALUE</b> is specified, then default values will be used. The default for an
           ascending sequence is the maximum value of the data type. The default for a descending sequence is
           -1.

       <u>start</u>
           The optional clause START WITH <u>start</u> allows the sequence to begin anywhere. The default starting
           value is <u>minvalue</u> for ascending sequences and <u>maxvalue</u> for descending ones.

       <u>cache</u>
           The optional clause CACHE <u>cache</u> specifies how many sequence numbers are to be preallocated and stored
           in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e.,
           no cache), and this is also the default.

       CYCLE
       NO CYCLE
           The CYCLE option allows the sequence to wrap around when the <u>maxvalue</u> or <u>minvalue</u> has been reached by
           an ascending or descending sequence respectively. If the limit is reached, the next number generated
           will be the <u>minvalue</u> or <u>maxvalue</u>, respectively.

           If NO CYCLE is specified, any calls to <b>nextval</b> after the sequence has reached its maximum value will
           return an error. If neither CYCLE or NO CYCLE are specified, NO CYCLE is the default.

       OWNED BY <u>table_name</u>.<u>column_name</u>
       OWNED BY NONE
           The OWNED BY option causes the sequence to be associated with a specific table column, such that if
           that column (or its whole table) is dropped, the sequence will be automatically dropped as well. The
           specified table must have the same owner and be in the same schema as the sequence.  OWNED BY NONE,
           the default, specifies that there is no such association.

</pre><h4><b>NOTES</b></h4><pre>
       Use <b>DROP</b> <b>SEQUENCE</b> to remove a sequence.

       Sequences are based on bigint arithmetic, so the range cannot exceed the range of an eight-byte integer
       (-9223372036854775808 to 9223372036854775807).

       Because <b>nextval</b> and <b>setval</b> calls are never rolled back, sequence objects cannot be used if “gapless”
       assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive
       locking of a table containing a counter; but this solution is much more expensive than sequence objects,
       especially if many transactions need sequence numbers concurrently.

       Unexpected results might be obtained if a <u>cache</u> setting greater than one is used for a sequence object
       that will be used concurrently by multiple sessions. Each session will allocate and cache successive
       sequence values during one access to the sequence object and increase the sequence object's last_value
       accordingly. Then, the next <u>cache</u>-1 uses of <b>nextval</b> within that session simply return the preallocated
       values without touching the sequence object. So, any numbers allocated but not used within a session will
       be lost when that session ends, resulting in “holes” in the sequence.

       Furthermore, although multiple sessions are guaranteed to allocate distinct sequence values, the values
       might be generated out of sequence when all the sessions are considered. For example, with a <u>cache</u>
       setting of 10, session A might reserve values 1..10 and return <b>nextval</b>=1, then session B might reserve
       values 11..20 and return <b>nextval</b>=11 before session A has generated <b>nextval</b>=2. Thus, with a <u>cache</u> setting
       of one it is safe to assume that <b>nextval</b> values are generated sequentially; with a <u>cache</u> setting greater
       than one you should only assume that the <b>nextval</b> values are all distinct, not that they are generated
       purely sequentially. Also, last_value will reflect the latest value reserved by any session, whether or
       not it has yet been returned by <b>nextval</b>.

       Another consideration is that a <b>setval</b> executed on such a sequence will not be noticed by other sessions
       until they have used up any preallocated values they have cached.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create an ascending sequence called serial, starting at 101:

           CREATE SEQUENCE serial START 101;

       Select the next number from this sequence:

           SELECT nextval('serial');

            nextval
           ---------
                101

       Select the next number from this sequence:

           SELECT nextval('serial');

            nextval
           ---------
                102

       Use this sequence in an <b>INSERT</b> command:

           INSERT INTO distributors VALUES (nextval('serial'), 'nothing');

       Update the sequence value after a <b>COPY</b> <b>FROM</b>:

           BEGIN;
           COPY distributors FROM 'input_file';
           SELECT setval('serial', max(id)) FROM distributors;
           END;

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       <b>CREATE</b> <b>SEQUENCE</b> conforms to the SQL standard, with the following exceptions:

       •   Obtaining the next value is done using the <b>nextval()</b> function instead of the standard's <b>NEXT</b> <b>VALUE</b>
           <b>FOR</b> expression.

       •   The OWNED BY clause is a PostgreSQL extension.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       ALTER SEQUENCE (<b><a href="../man7/ALTER_SEQUENCE.7.html">ALTER_SEQUENCE</a></b>(7)), DROP SEQUENCE (<b><a href="../man7/DROP_SEQUENCE.7.html">DROP_SEQUENCE</a></b>(7))

PostgreSQL 17.5                                       2025                                    <u>CREATE</u> <u><a href="../man7/SEQUENCE.7.html">SEQUENCE</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>