<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>regex - POSIX.2 regular expressions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       regex - POSIX.2 regular expressions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Regular  expressions  ("RE"s),  as  defined  in  POSIX.2, come in two forms: modern REs (roughly those of
       <b><a href="../man1/egrep.1.html">egrep</a></b>(1); POSIX.2 calls these "extended" REs) and obsolete REs (roughly those of <b><a href="../man1/ed.1.html">ed</a></b>(1);  POSIX.2  "basic"
       REs).   Obsolete REs mostly exist for backward compatibility in some old programs; they will be discussed
       at the end.  POSIX.2 leaves some aspects of RE syntax and semantics open; "(!)" marks decisions on  these
       aspects that may not be fully portable to other POSIX.2 implementations.

       A (modern) RE is one(!) or more nonempty(!) <u>branches</u>, separated by '|'.  It matches anything that matches
       one of the branches.

       A  branch  is one(!) or more <u>pieces</u>, concatenated.  It matches a match for the first, followed by a match
       for the second, and so on.

       A piece is an <u>atom</u> possibly followed by a single(!) '*', '+', '?', or <u>bound</u>.  An  atom  followed  by  '*'
       matches  a sequence of 0 or more matches of the atom.  An atom followed by '+' matches a sequence of 1 or
       more matches of the atom.  An atom followed by '?' matches a sequence of 0 or 1 matches of the atom.

       A <u>bound</u> is '{' followed by an unsigned decimal integer, possibly followed by  ','  possibly  followed  by
       another unsigned decimal integer, always followed by '}'.  The integers must lie between 0 and <b>RE_DUP_MAX</b>
       (255(!))  inclusive, and if there are two of them, the first may not exceed the second.  An atom followed
       by a bound containing one integer <u>i</u> and no comma matches a sequence of exactly <u>i</u> matches of the atom.  An
       atom followed by a bound containing one integer <u>i</u> and a comma matches a sequence of <u>i</u> or more matches  of
       the  atom.  An atom followed by a bound containing two integers <u>i</u> and <u>j</u> matches a sequence of <u>i</u> through <u>j</u>
       (inclusive) matches of the atom.

       An atom is a regular expression enclosed in "<u>()</u>" (matching a match for the regular expression), an  empty
       set  of  "<u>()</u>"  (matching  the null string)(!), a <u>bracket</u> <u>expression</u> (see below), '.' (matching any single
       character), '^' (matching the null string at the beginning of a line), '$' (matching the null  string  at
       the end of a line), a '\' followed by one of the characters "<u>^.[$()|*+?{\</u>" (matching that character taken
       as an ordinary character), a '\' followed by any other character(!)  (matching that character taken as an
       ordinary  character,  as  if  the  '\'  had  not  been  present(!)),  or a single character with no other
       significance (matching that character).  A '{' followed by a character other than a digit is an  ordinary
       character, not the beginning of a bound(!).  It is illegal to end an RE with '\'.

       A  <u>bracket</u> <u>expression</u> is a list of characters enclosed in "<u>[]</u>".  It normally matches any single character
       from the list (but see below).  If the list begins with '^', it matches any  single  character  (but  see
       below)  <u>not</u>  from  the  rest  of  the  list.  If two characters in the list are separated by '-', this is
       shorthand for the full <u>range</u> of characters between those two (inclusive) in the collating  sequence,  for
       example,  "<u>[0-9]</u>"  in  ASCII  matches  any  decimal  digit.   It is illegal(!) for two ranges to share an
       endpoint, for example, "<u>a-c-e</u>".  Ranges are  very  collating-sequence-dependent,  and  portable  programs
       should avoid relying on them.

       To include a literal ']' in the list, make it the first character (following a possible '^').  To include
       a  literal '-', make it the first or last character, or the second endpoint of a range.  To use a literal
       '-' as the first endpoint of a range, enclose it in "<u>[.</u>" and "<u>.]</u>"  to make it a  collating  element  (see
       below).   With  the  exception  of these and some combinations using '[' (see next paragraphs), all other
       special characters, including '\', lose their special significance within a bracket expression.

       Within a bracket expression, a collating element (a character, a multicharacter sequence that collates as
       if it were a single character, or a collating-sequence name for either) enclosed in "<u>[.</u>" and "<u>.]</u>"  stands
       for  the  sequence  of  characters  of  that  collating element.  The sequence is a single element of the
       bracket expression's list.  A bracket expression containing a multicharacter collating element  can  thus
       match  more than one character, for example, if the collating sequence includes a "ch" collating element,
       then the RE "<u>[[.ch.]]*c</u>" matches the first five characters of "chchcc".

       Within a bracket expression, a collating element enclosed in "<u>[=</u>"  and  "<u>=]</u>"  is  an  equivalence  class,
       standing  for  the  sequences  of  characters of all collating elements equivalent to that one, including
       itself.  (If there are no other equivalent collating elements, the  treatment  is  as  if  the  enclosing
       delimiters  were  "<u>[.</u>"  and "<u>.]</u>".)  For example, if o and ô are the members of an equivalence class, then
       "<u>[[=o=]]</u>", "<u>[[=ô=]]</u>", and "<u>[oô]</u>" are all synonymous.  An equivalence class may not(!) be an endpoint of a
       range.

       Within a bracket expression, the name of a <u>character</u> <u>class</u> enclosed in "<u>[:</u>" and "<u>:]</u>" stands for the  list
       of all characters belonging to that class.  Standard character class names are:

              alnum   digit   punct
              alpha   graph   space
              blank   lower   upper
              cntrl   print   xdigit

       These  stand  for  the character classes defined in <b><a href="../man3/wctype.3.html">wctype</a></b>(3).  A locale may provide others.  A character
       class may not be used as an endpoint of a range.

       In the event that an RE could match more than one substring of a given string, the  RE  matches  the  one
       starting  earliest  in the string.  If the RE could match more than one substring starting at that point,
       it matches the longest.  Subexpressions also match  the  longest  possible  substrings,  subject  to  the
       constraint  that  the  whole match be as long as possible, with subexpressions starting earlier in the RE
       taking priority over ones starting later.  Note that higher-level subexpressions thus take priority  over
       their lower-level component subexpressions.

       Match  lengths  are  measured  in characters, not collating elements.  A null string is considered longer
       than  no  match  at  all.   For  example,  "<u>bb*</u>"  matches  the  three  middle  characters   of   "abbbc",
       "<u>(wee|week)(knights|nights)</u>" matches all ten characters of "weeknights", when "<u>(.*).*</u>" is matched against
       "abc"  the  parenthesized subexpression matches all three characters, and when "<u>(a*)*</u>" is matched against
       "bc" both the whole RE and the parenthesized subexpression match the null string.

       If case-independent matching is specified, the effect is much as if all case  distinctions  had  vanished
       from  the  alphabet.   When  an alphabetic that exists in multiple cases appears as an ordinary character
       outside a bracket expression, it is effectively transformed into a  bracket  expression  containing  both
       cases,  for  example,  'x'  becomes  "<u>[xX]</u>".   When  it  appears  inside  a  bracket expression, all case
       counterparts of it are added to the bracket expression, so that, for example, "<u>[x]</u>"  becomes  "<u>[xX]</u>"  and
       "<u>[^x]</u>" becomes "<u>[^xX]</u>".

       No  particular  limit  is  imposed  on the length of REs(!).  Programs intended to be portable should not
       employ REs longer than 256 bytes, as an implementation can refuse to accept such REs  and  remain  POSIX-
       compliant.

       Obsolete  ("basic")  regular  expressions  differ  in  several  respects.  '|', '+', and '?' are ordinary
       characters and there is no equivalent for their functionality.  The delimiters for bounds  are  "<u>\{</u>"  and
       "<u>\}</u>",  with '{' and '}' by themselves ordinary characters.  The parentheses for nested subexpressions are
       "<u>\(</u>" and "<u>\)</u>", with '(' and ')' by themselves ordinary characters.  '^' is an ordinary  character  except
       at  the  beginning  of  the  RE  or(!) the beginning of a parenthesized subexpression, '$' is an ordinary
       character except at the end of the RE or(!) the end of a  parenthesized  subexpression,  and  '*'  is  an
       ordinary  character  if  it  appears  at  the  beginning  of  the  RE or the beginning of a parenthesized
       subexpression (after a possible leading '^').

       Finally, there is one new type of atom, a <u>back</u> <u>reference</u>: '\' followed  by  a  nonzero  decimal  digit  <u>d</u>
       matches  the  same  sequence  of  characters  matched  by  the <u>d</u>th parenthesized subexpression (numbering
       subexpressions by the positions of their opening parentheses, left  to  right),  so  that,  for  example,
       <u>"\([bc]\)\1"</u> matches <u>"bb"</u> or <u>"cc"</u> but not <u>"bc"</u>.

</pre><h4><b>BUGS</b></h4><pre>
       Having two kinds of REs is a botch.

       The  current POSIX.2 spec says that ')' is an ordinary character in the absence of an unmatched '('; this
       was an unintentional result of a wording error, and change is likely.  Avoid relying on it.

       Back references are a dreadful botch, posing major problems for efficient implementations.  They are also
       somewhat vaguely defined (does "<u>a\(\(b\)*\2\)*d</u>" match "abbbd"?).  Avoid using them.

       POSIX.2's specification of case-independent  matching  is  vague.   The  "one  case  implies  all  cases"
       definition given above is current consensus among implementors as to the right interpretation.

</pre><h4><b>AUTHOR</b></h4><pre>
       This page was taken from Henry Spencer's regex package.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/grep.1.html">grep</a></b>(1), <b><a href="../man3/regex.3.html">regex</a></b>(3)

       POSIX.2, section 2.8 (Regular Expression Notation).

Linux man-pages 6.9.1                              2024-06-15                                           <u><a href="../man7/regex.7.html">regex</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>