<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mount_namespaces - overview of Linux mount namespaces</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mount_namespaces - overview of Linux mount namespaces

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For an overview of namespaces, see <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7).

       Mount  namespaces  provide  isolation  of  the  list  of  mounts  seen by the processes in each namespace
       instance.  Thus, the processes in each of  the  mount  namespace  instances  will  see  distinct  single-
       directory hierarchies.

       The  views  provided  by  the  <u><a href="file:/proc/">/proc/</a></u>pid<u>/mounts</u>, <u><a href="file:/proc/">/proc/</a></u>pid<u>/mountinfo</u>, and <u><a href="file:/proc/">/proc/</a></u>pid<u>/mountstats</u> files (all
       described in <b><a href="../man5/proc.5.html">proc</a></b>(5)) correspond to the mount namespace in which the process with the  PID  <u>pid</u>  resides.
       (All of the processes that reside in the same mount namespace will see the same view in these files.)

       A  new  mount namespace is created using either <b><a href="../man2/clone.2.html">clone</a></b>(2) or <b><a href="../man2/unshare.2.html">unshare</a></b>(2) with the <b>CLONE_NEWNS</b> flag.  When a
       new mount namespace is created, its mount list is initialized as follows:

       •  If the namespace is created using <b><a href="../man2/clone.2.html">clone</a></b>(2), the mount list of the child's namespace is a copy  of  the
          mount list in the parent process's mount namespace.

       •  If  the  namespace  is  created using <b><a href="../man2/unshare.2.html">unshare</a></b>(2), the mount list of the new namespace is a copy of the
          mount list in the caller's previous mount namespace.

       Subsequent modifications to the mount list (<b><a href="../man2/mount.2.html">mount</a></b>(2) and <b><a href="../man2/umount.2.html">umount</a></b>(2)) in either mount  namespace  will  not
       (by  default)  affect  the  mount  list  seen in the other namespace (but see the following discussion of
       shared subtrees).

</pre><h4><b>SHARED</b> <b>SUBTREES</b></h4><pre>
       After the implementation of mount namespaces was completed, experience showed  that  the  isolation  that
       they  provided  was, in some cases, too great.  For example, in order to make a newly loaded optical disk
       available in all mount namespaces, a mount operation was required in each namespace.  For this use  case,
       and  others,  the  shared  subtree  feature  was  introduced  in  Linux  2.6.15.  This feature allows for
       automatic, controlled  propagation  of  <b><a href="../man2/mount.2.html">mount</a></b>(2)  and  <b><a href="../man2/umount.2.html">umount</a></b>(2)  <u>events</u>  between  namespaces  (or,  more
       precisely,  between  the  mounts  that  are  members  of  a <u>peer</u> <u>group</u> that are propagating events to one
       another).

       Each mount is marked (via <b><a href="../man2/mount.2.html">mount</a></b>(2)) as having one of the following <u>propagation</u> <u>types</u>:

       <b>MS_SHARED</b>
              This mount shares events with members of a peer group.  <b><a href="../man2/mount.2.html">mount</a></b>(2) and <b><a href="../man2/umount.2.html">umount</a></b>(2) events  immediately
              under  this  mount  will  propagate  to  the  other  mounts  that  are  members of the peer group.
              <u>Propagation</u> here means that the same <b><a href="../man2/mount.2.html">mount</a></b>(2) or <b><a href="../man2/umount.2.html">umount</a></b>(2) will automatically occur under  all  of
              the  other  mounts  in  the peer group.  Conversely, <b><a href="../man2/mount.2.html">mount</a></b>(2) and <b><a href="../man2/umount.2.html">umount</a></b>(2) events that take place
              under peer mounts will propagate to this mount.

       <b>MS_PRIVATE</b>
              This mount is private; it does not have a peer  group.   <b><a href="../man2/mount.2.html">mount</a></b>(2)  and  <b><a href="../man2/umount.2.html">umount</a></b>(2)  events  do  not
              propagate into or out of this mount.

       <b>MS_SLAVE</b>
              <b><a href="../man2/mount.2.html">mount</a></b>(2)  and  <b><a href="../man2/umount.2.html">umount</a></b>(2)  events  propagate  into  this  mount  from a (master) shared peer group.
              <b><a href="../man2/mount.2.html">mount</a></b>(2) and <b><a href="../man2/umount.2.html">umount</a></b>(2) events under this mount do not propagate to any peer.

              Note that a mount can be the slave of another peer group while at the same time  sharing  <b><a href="../man2/mount.2.html">mount</a></b>(2)
              and  <b><a href="../man2/umount.2.html">umount</a></b>(2)  events with a peer group of which it is a member.  (More precisely, one peer group
              can be the slave of another peer group.)

       <b>MS_UNBINDABLE</b>
              This is like a private mount, and in addition this mount can't be bind mounted.  Attempts to  bind
              mount this mount (<b><a href="../man2/mount.2.html">mount</a></b>(2) with the <b>MS_BIND</b> flag) will fail.

              When  a  recursive  bind  mount  (<b><a href="../man2/mount.2.html">mount</a></b>(2)  with  the  <b>MS_BIND</b> and <b>MS_REC</b> flags) is performed on a
              directory subtree, any bind  mounts  within  the  subtree  are  automatically  pruned  (i.e.,  not
              replicated) when replicating that subtree to produce the target subtree.

       For a discussion of the propagation type assigned to a new mount, see NOTES.

       The  propagation type is a per-mount-point setting; some mounts may be marked as shared (with each shared
       mount being a member of a distinct peer group), while others are private (or slaved or unbindable).

       Note that a mount's propagation type determines whether <b><a href="../man2/mount.2.html">mount</a></b>(2)  and  <b><a href="../man2/umount.2.html">umount</a></b>(2)  of  mounts  <u>immediately</u>
       <u>under</u>  the  mount  are  propagated.  Thus, the propagation type does not affect propagation of events for
       grandchildren and further removed descendant mounts.  What happens if the mount itself  is  unmounted  is
       determined by the propagation type that is in effect for the <u>parent</u> of the mount.

       Members are added to a <u>peer</u> <u>group</u> when a mount is marked as shared and either:

       (a)  the mount is replicated during the creation of a new mount namespace; or

       (b)  a new bind mount is created from the mount.

       In both of these cases, the new mount joins the peer group of which the existing mount is a member.

       A  new peer group is also created when a child mount is created under an existing mount that is marked as
       shared.  In this case, the new child mount is also marked as shared and the resulting peer group consists
       of all the mounts that are replicated under the peers of parent mounts.

       A mount ceases to be a member of a peer group when either the mount is explicitly unmounted, or when  the
       mount  is  implicitly  unmounted  because  a  mount  namespace  is removed (because it has no more member
       processes).

       The propagation type of the mounts in a mount namespace can  be  discovered  via  the  "optional  fields"
       exposed  in  <u><a href="file:/proc/">/proc/</a></u>pid<u>/mountinfo</u>.  (See <b><a href="../man5/proc.5.html">proc</a></b>(5) for details of this file.)  The following tags can appear
       in the optional fields for a record in that file:

       <u>shared:X</u>
              This mount is shared in peer group <u>X</u>.  Each peer group has  a  unique  ID  that  is  automatically
              generated  by the kernel, and all mounts in the same peer group will show the same ID.  (These IDs
              are assigned starting from the value 1, and may be recycled when a peer group ceases to  have  any
              members.)

       <u>master:X</u>
              This mount is a slave to shared peer group <u>X</u>.

       <u>propagate_from:X</u> (since Linux 2.6.26)
              This  mount  is  a  slave and receives propagation from shared peer group <u>X</u>.  This tag will always
              appear in conjunction with a <u>master:X</u> tag.  Here, <u>X</u> is the closest dominant peer group  under  the
              process's  root  directory.  If <u>X</u> is the immediate master of the mount, or if there is no dominant
              peer  group  under  the  same  root,  then  only  the  <u>master:X</u>  field  is  present  and  not  the
              <u>propagate_from:X</u> field.  For further details, see below.

       <u>unbindable</u>
              This is an unbindable mount.

       If none of the above tags is present, then this is a private mount.

   <b>MS_SHARED</b> <b>and</b> <b>MS_PRIVATE</b> <b>example</b>
       Suppose  that  on  a  terminal in the initial mount namespace, we mark one mount as shared and another as
       private, and then view the mounts in <u><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></u>:

           sh1# <b>mount</b> <b>--make-shared</b> <b>/mntS</b>
           sh1# <b>mount</b> <b>--make-private</b> <b>/mntP</b>
           sh1# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           77 61 8:17 / /mntS rw,relatime shared:1
           83 61 8:15 / /mntP rw,relatime

       From the <u><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></u> output, we see that <u>/mntS</u> is a shared mount in peer group 1, and that <u>/mntP</u>
       has no optional tags, indicating that it is a private mount.  The first two fields in each record in this
       file are the unique ID for this mount, and the mount ID of the parent mount.  We can further inspect this
       file to see that the parent mount of <u>/mntS</u> and <u>/mntP</u> is the  root  directory,  <u>/</u>,  which  is  mounted  as
       private:

           sh1# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>awk</b> <b>'$1</b> <b>==</b> <b>61'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           61 0 8:2 / / rw,relatime

       On a second terminal, we create a new mount namespace where we run a second shell and inspect the mounts:

           $ <b>PS1='sh2#</b> <b>'</b> <b>sudo</b> <b>unshare</b> <b>-m</b> <b>--propagation</b> <b>unchanged</b> <b>sh</b>
           sh2# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           222 145 8:17 / /mntS rw,relatime shared:1
           225 145 8:15 / /mntP rw,relatime

       The  new  mount  namespace  received  a  copy  of the initial mount namespace's mounts.  These new mounts
       maintain the same propagation types, but have unique mount  IDs.   (The  <u>--propagation</u>  <u>unchanged</u>  option
       prevents <b><a href="../man1/unshare.1.html">unshare</a></b>(1) from marking all mounts as private when creating a new mount namespace, which it does
       by default.)

       In the second terminal, we then create submounts under each of <u>/mntS</u> and <u>/mntP</u> and inspect the set-up:

           sh2# <b>mkdir</b> <b>/mntS/a</b>
           sh2# <b>mount</b> <b>/dev/sdb6</b> <b>/mntS/a</b>
           sh2# <b>mkdir</b> <b>/mntP/b</b>
           sh2# <b>mount</b> <b>/dev/sdb7</b> <b>/mntP/b</b>
           sh2# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           222 145 8:17 / /mntS rw,relatime shared:1
           225 145 8:15 / /mntP rw,relatime
           178 222 8:22 / /mntS/a rw,relatime shared:2
           230 225 8:23 / /mntP/b rw,relatime

       From  the  above,  it  can  be  seen that <u>/mntS/a</u> was created as shared (inheriting this setting from its
       parent mount) and <u>/mntP/b</u> was created as a private mount.

       Returning to the first terminal and inspecting the set-up, we see that the new mount  created  under  the
       shared  mount  <u>/mntS</u>  propagated  to  its  peer mount (in the initial mount namespace), but the new mount
       created under the private mount <u>/mntP</u> did not propagate:

           sh1# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           77 61 8:17 / /mntS rw,relatime shared:1
           83 61 8:15 / /mntP rw,relatime
           179 77 8:22 / /mntS/a rw,relatime shared:2

   <b>MS_SLAVE</b> <b>example</b>
       Making a mount a slave allows it to receive propagated <b><a href="../man2/mount.2.html">mount</a></b>(2) and <b><a href="../man2/umount.2.html">umount</a></b>(2) events from a master shared
       peer group, while preventing it from propagating events to that master.  This is useful  if  we  want  to
       (say)  receive  a mount event when an optical disk is mounted in the master shared peer group (in another
       mount namespace), but want to prevent <b><a href="../man2/mount.2.html">mount</a></b>(2) and <b><a href="../man2/umount.2.html">umount</a></b>(2) events under the  slave  mount  from  having
       side effects in other namespaces.

       We  can  demonstrate  the  effect  of  slaving by first marking two mounts as shared in the initial mount
       namespace:

           sh1# <b>mount</b> <b>--make-shared</b> <b>/mntX</b>
           sh1# <b>mount</b> <b>--make-shared</b> <b>/mntY</b>
           sh1# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2

       On a second terminal, we create a new mount namespace and inspect the mounts:

           sh2# <b>unshare</b> <b>-m</b> <b>--propagation</b> <b>unchanged</b> <b>sh</b>
           sh2# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime shared:2

       In the new mount namespace, we then mark one of the mounts as a slave:

           sh2# <b>mount</b> <b>--make-slave</b> <b>/mntY</b>
           sh2# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2

       From the above output, we see that <u>/mntY</u> is now a slave mount that is receiving propagation  events  from
       the shared peer group with the ID 2.

       Continuing in the new namespace, we create submounts under each of <u>/mntX</u> and <u>/mntY</u>:

           sh2# <b>mkdir</b> <b>/mntX/a</b>
           sh2# <b>mount</b> <b>/dev/sda3</b> <b>/mntX/a</b>
           sh2# <b>mkdir</b> <b>/mntY/b</b>
           sh2# <b>mount</b> <b>/dev/sda5</b> <b>/mntY/b</b>

       When  we inspect the state of the mounts in the new mount namespace, we see that <u>/mntX/a</u> was created as a
       new shared mount (inheriting the "shared" setting from its parent mount) and <u>/mntY/b</u>  was  created  as  a
       private mount:

           sh2# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2
           173 168 8:3 / /mntX/a rw,relatime shared:3
           175 169 8:5 / /mntY/b rw,relatime

       Returning  to  the  first  terminal  (in  the  initial  mount  namespace),  we see that the mount <u>/mntX/a</u>
       propagated to the peer (the shared <u>/mntX</u>), but the mount <u>/mntY/b</u> was not propagated:

           sh1# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2
           174 132 8:3 / /mntX/a rw,relatime shared:3

       Now we create a new mount under <u>/mntY</u> in the first shell:

           sh1# <b>mkdir</b> <b>/mntY/c</b>
           sh1# <b>mount</b> <b>/dev/sda1</b> <b>/mntY/c</b>
           sh1# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2
           174 132 8:3 / /mntX/a rw,relatime shared:3
           178 133 8:1 / /mntY/c rw,relatime shared:4

       When we examine the mounts in the second mount namespace, we see that in this case the new mount has been
       propagated to the slave mount, and that the new mount is itself a slave mount (to peer group 4):

           sh2# <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2
           173 168 8:3 / /mntX/a rw,relatime shared:3
           175 169 8:5 / /mntY/b rw,relatime
           179 169 8:1 / /mntY/c rw,relatime master:4

   <b>MS_UNBINDABLE</b> <b>example</b>
       One of the primary purposes of  unbindable  mounts  is  to  avoid  the  "mount  explosion"  problem  when
       repeatedly  performing  bind  mounts  of  a  higher-level subtree at a lower-level mount.  The problem is
       illustrated by the following shell session.

       Suppose we have a system with the following mounts:

           # <b>mount</b> <b>|</b> <b>awk</b> <b>'{print</b> <b>$1,</b> <b>$2,</b> <b>$3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY

       Suppose furthermore that we wish to recursively bind mount the root directory under several  users'  home
       directories.  We do this for the first user, and inspect the mounts:

           # <b>mount</b> <b>--rbind</b> <b>/</b> <b>/home/cecilia/</b>
           # <b>mount</b> <b>|</b> <b>awk</b> <b>'{print</b> <b>$1,</b> <b>$2,</b> <b>$3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY

       When we repeat this operation for the second user, we start to see the explosion problem:

           # <b>mount</b> <b>--rbind</b> <b>/</b> <b>/home/henry</b>
           # <b>mount</b> <b>|</b> <b>awk</b> <b>'{print</b> <b>$1,</b> <b>$2,</b> <b>$3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/henry/home/cecilia
           /dev/sdb6 on /home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/henry/home/cecilia/mntY

       Under  <u>/home/henry</u>, we have not only recursively added the <u>/mntX</u> and <u>/mntY</u> mounts, but also the recursive
       mounts of those directories under <u>/home/cecilia</u> that were created in the previous step.   Upon  repeating
       the step for a third user, it becomes obvious that the explosion is exponential in nature:

           # <b>mount</b> <b>--rbind</b> <b>/</b> <b>/home/otto</b>
           # <b>mount</b> <b>|</b> <b>awk</b> <b>'{print</b> <b>$1,</b> <b>$2,</b> <b>$3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/henry/home/cecilia
           /dev/sdb6 on /home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/henry/home/cecilia/mntY
           /dev/sda1 on /home/otto
           /dev/sdb6 on /home/otto/mntX
           /dev/sdb7 on /home/otto/mntY
           /dev/sda1 on /home/otto/home/cecilia
           /dev/sdb6 on /home/otto/home/cecilia/mntX
           /dev/sdb7 on /home/otto/home/cecilia/mntY
           /dev/sda1 on /home/otto/home/henry
           /dev/sdb6 on /home/otto/home/henry/mntX
           /dev/sdb7 on /home/otto/home/henry/mntY
           /dev/sda1 on /home/otto/home/henry/home/cecilia
           /dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY

       The  mount  explosion  problem  in  the  above  scenario  can be avoided by making each of the new mounts
       unbindable.  The effect of doing this is that recursive mounts of the root directory will  not  replicate
       the unbindable mounts.  We make such a mount for the first user:

           # <b>mount</b> <b>--rbind</b> <b>--make-unbindable</b> <b>/</b> <b>/home/cecilia</b>

       Before going further, we show that unbindable mounts are indeed unbindable:

           # <b>mkdir</b> <b>/mntZ</b>
           # <b>mount</b> <b>--bind</b> <b>/home/cecilia</b> <b>/mntZ</b>
           mount: wrong fs type, bad option, bad superblock on /home/cecilia,
                  missing codepage or helper program, or other error

                  In some cases useful info is found in syslog - try
                  dmesg | tail or so.

       Now we create unbindable recursive bind mounts for the other two users:

           # <b>mount</b> <b>--rbind</b> <b>--make-unbindable</b> <b>/</b> <b>/home/henry</b>
           # <b>mount</b> <b>--rbind</b> <b>--make-unbindable</b> <b>/</b> <b>/home/otto</b>

       Upon  examining  the list of mounts, we see there has been no explosion of mounts, because the unbindable
       mounts were not replicated under each user's directory:

           # <b>mount</b> <b>|</b> <b>awk</b> <b>'{print</b> <b>$1,</b> <b>$2,</b> <b>$3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/otto
           /dev/sdb6 on /home/otto/mntX
           /dev/sdb7 on /home/otto/mntY

   <b>Propagation</b> <b>type</b> <b>transitions</b>
       The following table shows the effect that applying a new propagation type (i.e., <u>mount</u>  <u>--make-xxxx</u>)  has
       on  the existing propagation type of a mount.  The rows correspond to existing propagation types, and the
       columns are the new propagation settings.  For reasons of space, "private" is abbreviated as  "priv"  and
       "unbindable" as "unbind".
                     <b>make-shared</b>   <b>make-slave</b>      <b>make-priv</b>  <b>make-unbind</b>
       ─────────────┬───────────────────────────────────────────────────────
       <b>shared</b>       │shared        slave/priv [1]  priv       unbind
       <b>slave</b>        │slave+shared  slave [2]       priv       unbind
       <b>slave+shared</b> │slave+shared  slave           priv       unbind
       <b>private</b>      │shared        priv [2]        priv       unbind
       <b>unbindable</b>   │shared        unbind [2]      priv       unbind

       Note the following details to the table:

       [1]  If  a  shared  mount  is  the only mount in its peer group, making it a slave automatically makes it
            private.

       [2]  Slaving a nonshared mount has no effect on the mount.

   <b>Bind</b> <b>(MS_BIND)</b> <b>semantics</b>
       Suppose that the following command is performed:

           mount --bind A/a B/b

       Here, <u>A</u> is the source mount, <u>B</u> is the destination mount, <u>a</u> is a subdirectory path under the  mount  point
       <u>A</u>,  and  <u>b</u>  is a subdirectory path under the mount point <u>B</u>.  The propagation type of the resulting mount,
       <u>B/b</u>, depends on the propagation types of the mounts <u>A</u> and <u>B</u>, and is summarized in the following table.

                                  <b>source(A)</b>
                          <b>shared</b>  <b>private</b>    <b>slave</b>         <b>unbind</b>
       ──────────────────┬──────────────────────────────────────────
       <b>dest(B)</b>  <b>shared</b>   │shared  shared     slave+shared  invalid
                <b>nonshared</b>│shared  private    slave         invalid

       Note that a recursive bind of a subtree follows the same semantics as for a bind operation on each  mount
       in the subtree.  (Unbindable mounts are automatically pruned at the target mount point.)

       For further details, see <u>Documentation/filesystems/sharedsubtree.rst</u> in the kernel source tree.

   <b>Move</b> <b>(MS_MOVE)</b> <b>semantics</b>
       Suppose that the following command is performed:

           mount --move A B/b

       Here,  <u>A</u>  is  the  source mount, <u>B</u> is the destination mount, and <u>b</u> is a subdirectory path under the mount
       point <u>B</u>.  The propagation type of the resulting mount, <u>B/b</u>, depends  on  the  propagation  types  of  the
       mounts <u>A</u> and <u>B</u>, and is summarized in the following table.

                                  <b>source(A)</b>
                          <b>shared</b>  <b>private</b>    <b>slave</b>         <b>unbind</b>
       ──────────────────┬─────────────────────────────────────────────
       <b>dest(B)</b>  <b>shared</b>   │shared  shared     slave+shared  invalid
                <b>nonshared</b>│shared  private    slave         unbindable

       Note: moving a mount that resides under a shared mount is invalid.

       For further details, see <u>Documentation/filesystems/sharedsubtree.rst</u> in the kernel source tree.

   <b>Mount</b> <b>semantics</b>
       Suppose that we use the following command to create a mount:

           mount device B/b

       Here,  <u>B</u> is the destination mount, and <u>b</u> is a subdirectory path under the mount point <u>B</u>.  The propagation
       type of the resulting mount, <u>B/b</u>, follows the same rules as for a bind mount, where the propagation  type
       of the source mount is considered always to be private.

   <b>Unmount</b> <b>semantics</b>
       Suppose that we use the following command to tear down a mount:

           umount A

       Here, <u>A</u> is a mount on <u>B/b</u>, where <u>B</u> is the parent mount and <u>b</u> is a subdirectory path under the mount point
       <u>B</u>.   If  <b>B</b>  is shared, then all most-recently-mounted mounts at <u>b</u> on mounts that receive propagation from
       mount <u>B</u> and do not have submounts under them are unmounted.

   <b>The</b> <b><a href="file:/proc/">/proc/</a></b> <b>pid</b> <b>/mountinfo</b> <b>propagate_from</b> <b>tag</b>
       The <u>propagate_from:X</u> tag is shown in the optional fields of a <u><a href="file:/proc/">/proc/</a></u>pid<u>/mountinfo</u> record in cases where a
       process can't see a slave's immediate master (i.e., the pathname of the master is not reachable from  the
       filesystem  root  directory)  and  so cannot determine the chain of propagation between the mounts it can
       see.

       In the following example, we first  create  a  two-link  master-slave  chain  between  the  mounts  <u><a href="file:/mnt">/mnt</a></u>,
       <u>/tmp/etc</u>,  and  <u>/mnt/tmp/etc</u>.   Then  the  <b><a href="../man1/chroot.1.html">chroot</a></b>(1)  command  is  used  to make the <u>/tmp/etc</u> mount point
       unreachable from the root directory, creating a  situation  where  the  master  of  <u>/mnt/tmp/etc</u>  is  not
       reachable from the (new) root directory of the process.

       First,  we  bind  mount the root directory onto <u><a href="file:/mnt">/mnt</a></u> and then bind mount <u><a href="file:/proc">/proc</a></u> at <u>/mnt/proc</u> so that after
       the later <b><a href="../man1/chroot.1.html">chroot</a></b>(1) the <b><a href="../man5/proc.5.html">proc</a></b>(5) filesystem remains visible at  the  correct  location  in  the  chroot-ed
       environment.

           # <b>mkdir</b> <b>-p</b> <b>/mnt/proc</b>
           # <b>mount</b> <b>--bind</b> <b>/</b> <b><a href="file:/mnt">/mnt</a></b>
           # <b>mount</b> <b>--bind</b> <b><a href="file:/proc">/proc</a></b> <b>/mnt/proc</b>

       Next, we ensure that the <u><a href="file:/mnt">/mnt</a></u> mount is a shared mount in a new peer group (with no peers):

           # <b>mount</b> <b>--make-private</b> <b><a href="file:/mnt">/mnt</a></b>  # Isolate from any previous peer group
           # <b>mount</b> <b>--make-shared</b> <b><a href="file:/mnt">/mnt</a></b>
           # <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>grep</b> <b>'<a href="file:/mnt">/mnt</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           239 61 8:2 / <a href="file:/mnt">/mnt</a> ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5

       Next, we bind mount <u>/mnt/etc</u> onto <u>/tmp/etc</u>:

           # <b>mkdir</b> <b>-p</b> <b>/tmp/etc</b>
           # <b>mount</b> <b>--bind</b> <b>/mnt/etc</b> <b>/tmp/etc</b>
           # <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>egrep</b> <b>'<a href="file:/mnt">/mnt</a>|<a href="file:/tmp/">/tmp/</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           239 61 8:2 / <a href="file:/mnt">/mnt</a> ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 <a href="file:/etc">/etc</a> /tmp/etc ... shared:102

       Initially,  these  two  mounts  are  in  the  same  peer  group, but we then make the <u>/tmp/etc</u> a slave of
       <u>/mnt/etc</u>, and then make <u>/tmp/etc</u> shared as well, so that it can propagate events to the next slave in the
       chain:

           # <b>mount</b> <b>--make-slave</b> <b>/tmp/etc</b>
           # <b>mount</b> <b>--make-shared</b> <b>/tmp/etc</b>
           # <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>egrep</b> <b>'<a href="file:/mnt">/mnt</a>|<a href="file:/tmp/">/tmp/</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           239 61 8:2 / <a href="file:/mnt">/mnt</a> ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 <a href="file:/etc">/etc</a> /tmp/etc ... shared:105 master:102

       Then we bind mount <u>/tmp/etc</u> onto <u>/mnt/tmp/etc</u>.  Again, the two mounts are  initially  in  the  same  peer
       group, but we then make <u>/mnt/tmp/etc</u> a slave of <u>/tmp/etc</u>:

           # <b>mkdir</b> <b>-p</b> <b>/mnt/tmp/etc</b>
           # <b>mount</b> <b>--bind</b> <b>/tmp/etc</b> <b>/mnt/tmp/etc</b>
           # <b>mount</b> <b>--make-slave</b> <b>/mnt/tmp/etc</b>
           # <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>egrep</b> <b>'<a href="file:/mnt">/mnt</a>|<a href="file:/tmp/">/tmp/</a>'</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           239 61 8:2 / <a href="file:/mnt">/mnt</a> ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 <a href="file:/etc">/etc</a> /tmp/etc ... shared:105 master:102
           273 239 8:2 <a href="file:/etc">/etc</a> /mnt/tmp/etc ... master:105

       From  the above, we see that <u><a href="file:/mnt">/mnt</a></u> is the master of the slave <u>/tmp/etc</u>, which in turn is the master of the
       slave <u>/mnt/tmp/etc</u>.

       We then <b><a href="../man1/chroot.1.html">chroot</a></b>(1) to the <u><a href="file:/mnt">/mnt</a></u> directory, which renders the mount with ID 267 unreachable from  the  (new)
       root directory:

           # <b>chroot</b> <b><a href="file:/mnt">/mnt</a></b>

       When we examine the state of the mounts inside the chroot-ed environment, we see the following:

           # <b>cat</b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
           239 61 8:2 / / ... shared:102
           248 239 0:4 / <a href="file:/proc">/proc</a> ... shared:5
           273 239 8:2 <a href="file:/etc">/etc</a> /tmp/etc ... master:105 propagate_from:102

       Above,  we see that the mount with ID 273 is a slave whose master is the peer group 105.  The mount point
       for that master is unreachable, and so a <u>propagate_from</u> tag is displayed,  indicating  that  the  closest
       dominant  peer group (i.e., the nearest reachable mount in the slave chain) is the peer group with the ID
       102 (corresponding to the <u><a href="file:/mnt">/mnt</a></u> mount point before the <b><a href="../man1/chroot.1.html">chroot</a></b>(1) was performed).

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       Linux 2.4.19.

</pre><h4><b>NOTES</b></h4><pre>
       The propagation type assigned to a new mount depends on the propagation type of the parent mount.  If the
       mount has a parent (i.e., it is a non-root mount point)  and  the  propagation  type  of  the  parent  is
       <b>MS_SHARED</b>, then the propagation type of the new mount is also <b>MS_SHARED</b>.  Otherwise, the propagation type
       of the new mount is <b>MS_PRIVATE</b>.

       Notwithstanding  the  fact  that  the default propagation type for new mount is in many cases <b>MS_PRIVATE</b>,
       <b>MS_SHARED</b> is typically more useful.  For this reason, <b><a href="../man1/systemd.1.html">systemd</a></b>(1) automatically  remounts  all  mounts  as
       <b>MS_SHARED</b>  on  system startup.  Thus, on most modern systems, the default propagation type is in practice
       <b>MS_SHARED</b>.

       Since, when one uses <b><a href="../man1/unshare.1.html">unshare</a></b>(1) to create a mount  namespace,  the  goal  is  commonly  to  provide  full
       isolation  of  the  mounts  in the new namespace, <b><a href="../man1/unshare.1.html">unshare</a></b>(1) (since <u>util-linux</u> 2.27) in turn reverses the
       step performed by <b><a href="../man1/systemd.1.html">systemd</a></b>(1), by making all mounts private in the new  namespace.   That  is,  <b><a href="../man1/unshare.1.html">unshare</a></b>(1)
       performs the equivalent of the following in the new mount namespace:

           mount --make-rprivate /

       To prevent this, one can use the <u>--propagation</u> <u>unchanged</u> option to <b><a href="../man1/unshare.1.html">unshare</a></b>(1).

       An  application  that  creates  a new mount namespace directly using <b><a href="../man2/clone.2.html">clone</a></b>(2) or <b><a href="../man2/unshare.2.html">unshare</a></b>(2) may desire to
       prevent propagation of mount events to other mount namespaces (as is done by <b><a href="../man1/unshare.1.html">unshare</a></b>(1)).   This  can  be
       done  by  changing  the propagation type of mounts in the new namespace to either <b>MS_SLAVE</b> or <b>MS_PRIVATE</b>,
       using a call such as the following:

           mount(NULL, "/", MS_SLAVE | MS_REC, NULL);

       For a discussion of propagation types when moving mounts (<b>MS_MOVE</b>) and creating  bind  mounts  (<b>MS_BIND</b>),
       see <u>Documentation/filesystems/sharedsubtree.rst</u>.

   <b>Restrictions</b> <b>on</b> <b>mount</b> <b>namespaces</b>
       Note the following points with respect to mount namespaces:

       [1]  Each mount namespace has an owner user namespace.  As explained above, when a new mount namespace is
            created,  its  mount list is initialized as a copy of the mount list of another mount namespace.  If
            the new namespace and the namespace from which the mount list was copied are owned by different user
            namespaces, then the new mount namespace is considered <u>less</u> <u>privileged</u>.

       [2]  When creating a less privileged mount namespace, shared mounts are reduced to  slave  mounts.   This
            ensures  that  mappings  performed  in  less  privileged mount namespaces will not propagate to more
            privileged mount namespaces.

       [3]  Mounts that come as a single unit from a more privileged mount namespace are locked together and may
            not be separated in a less privileged mount namespace.  (The <b><a href="../man2/unshare.2.html">unshare</a></b>(2) <b>CLONE_NEWNS</b> operation brings
            across all of the mounts from the original mount namespace as a single unit,  and  recursive  mounts
            that propagate between mount namespaces propagate as a single unit.)

            In  this  context,  "may  not be separated" means that the mounts are locked so that they may not be
            individually unmounted.  Consider the following example:

                $ <b>sudo</b> <b>sh</b>
                # <b>mount</b> <b>--bind</b> <b>/dev/null</b> <b><a href="file:/etc/shadow">/etc/shadow</a></b>
                # <b>cat</b> <b><a href="file:/etc/shadow">/etc/shadow</a></b>       # Produces no output

            The above steps, performed in a more privileged mount namespace, have  created  a  bind  mount  that
            obscures the contents of the shadow password file, <u><a href="file:/etc/shadow">/etc/shadow</a></u>.  For security reasons, it should not
            be  possible  to  <b><a href="../man2/umount.2.html">umount</a></b>(2) that mount in a less privileged mount namespace, since that would reveal
            the contents of <u><a href="file:/etc/shadow">/etc/shadow</a></u>.

            Suppose we now create a new mount namespace owned by a new user namespace.  The new mount  namespace
            will  inherit  copies of all of the mounts from the previous mount namespace.  However, those mounts
            will be locked because the new mount namespace is less  privileged.   Consequently,  an  attempt  to
            <b><a href="../man2/umount.2.html">umount</a></b>(2) the mount fails as show in the following step:

                # <b>unshare</b> <b>--user</b> <b>--map-root-user</b> <b>--mount</b> <b>\</b>
                               <b>strace</b> <b>-o</b> <b>/tmp/log</b> <b>\</b>
                               <b>umount</b> <b>/mnt/dir</b>
                umount: <a href="file:/etc/shadow">/etc/shadow</a>: not mounted.
                # <b>grep</b> <b>'^umount'</b> <b>/tmp/log</b>
                umount2("<a href="file:/etc/shadow">/etc/shadow</a>", 0)     = -1 EINVAL (Invalid argument)

            The  error  message  from  <b><a href="../man8/mount.8.html">mount</a></b>(8) is a little confusing, but the <b><a href="../man1/strace.1.html">strace</a></b>(1) output reveals that the
            underlying <b><a href="../man2/umount2.2.html">umount2</a></b>(2) system call failed with the error <b>EINVAL</b>, which is the error that  the  kernel
            returns to indicate that the mount is locked.

            Note,  however,  that  it  is possible to stack (and unstack) a mount on top of one of the inherited
            locked mounts in a less privileged mount namespace:

                # <b>echo</b> <b>'aaaaa'</b> <b>&gt;</b> <b>/tmp/a</b>    # File to mount onto <a href="file:/etc/shadow">/etc/shadow</a>
                # <b>unshare</b> <b>--user</b> <b>--map-root-user</b> <b>--mount</b> <b>\</b>
                    <b>sh</b> <b>-c</b> <b>'mount</b> <b>--bind</b> <b>/tmp/a</b> <b><a href="file:/etc/shadow">/etc/shadow</a>;</b> <b>cat</b> <b><a href="file:/etc/shadow">/etc/shadow</a>'</b>
                aaaaa
                # <b>umount</b> <b><a href="file:/etc/shadow">/etc/shadow</a></b>

            The final <b><a href="../man8/umount.8.html">umount</a></b>(8) command above, which is performed in the  initial  mount  namespace,  makes  the
            original <u><a href="file:/etc/shadow">/etc/shadow</a></u> file once more visible in that namespace.

       [4]  Following  on from point [3], note that it is possible to <b><a href="../man2/umount.2.html">umount</a></b>(2) an entire subtree of mounts that
            propagated as a unit into a less  privileged  mount  namespace,  as  illustrated  in  the  following
            example.

            First,  we  create  new user and mount namespaces using <b><a href="../man1/unshare.1.html">unshare</a></b>(1).  In the new mount namespace, the
            propagation type of all mounts is set to private.  We then create a shared bind mount at <u><a href="file:/mnt">/mnt</a></u>, and a
            small hierarchy of mounts underneath that mount.

                $ <b>PS1='ns1#</b> <b>'</b> <b>sudo</b> <b>unshare</b> <b>--user</b> <b>--map-root-user</b> <b>\</b>
                                       <b>--mount</b> <b>--propagation</b> <b>private</b> <b>bash</b>
                ns1# <b>echo</b> <b>$$</b>        # We need the PID of this shell later
                778501
                ns1# <b>mount</b> <b>--make-shared</b> <b>--bind</b> <b><a href="file:/mnt">/mnt</a></b> <b><a href="file:/mnt">/mnt</a></b>
                ns1# <b>mkdir</b> <b>/mnt/x</b>
                ns1# <b>mount</b> <b>--make-private</b> <b>-t</b> <b>tmpfs</b> <b>none</b> <b>/mnt/x</b>
                ns1# <b>mkdir</b> <b>/mnt/x/y</b>
                ns1# <b>mount</b> <b>--make-private</b> <b>-t</b> <b>tmpfs</b> <b>none</b> <b>/mnt/x/y</b>
                ns1# <b>grep</b> <b><a href="file:/mnt">/mnt</a></b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
                986 83 8:5 <a href="file:/mnt">/mnt</a> <a href="file:/mnt">/mnt</a> rw,relatime shared:344
                989 986 0:56 / /mnt/x rw,relatime
                990 989 0:57 / /mnt/x/y rw,relatime

            Continuing in the same shell session, we then create a second shell in a new user  namespace  and  a
            new (less privileged) mount namespace and check the state of the propagated mounts rooted at <u><a href="file:/mnt">/mnt</a></u>.

                ns1# <b>PS1='ns2#</b> <b>'</b> <b>unshare</b> <b>--user</b> <b>--map-root-user</b> <b>\</b>
                                       <b>--mount</b> <b>--propagation</b> <b>unchanged</b> <b>bash</b>
                ns2# <b>grep</b> <b><a href="file:/mnt">/mnt</a></b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
                1239 1204 8:5 <a href="file:/mnt">/mnt</a> <a href="file:/mnt">/mnt</a> rw,relatime master:344
                1240 1239 0:56 / /mnt/x rw,relatime
                1241 1240 0:57 / /mnt/x/y rw,relatime

            Of  note  in  the  above  output  is that the propagation type of the mount <u><a href="file:/mnt">/mnt</a></u> has been reduced to
            slave, as explained in point [2].  This means that submount events will propagate  from  the  master
            <u><a href="file:/mnt">/mnt</a></u> in "ns1", but propagation will not occur in the opposite direction.

            From  a  separate  terminal  window,  we  then use <b><a href="../man1/nsenter.1.html">nsenter</a></b>(1) to enter the mount and user namespaces
            corresponding to "ns1".  In that terminal window, we then  recursively  bind  mount  <u>/mnt/x</u>  at  the
            location <u>/mnt/ppp</u>.

                $ <b>PS1='ns3#</b> <b>'</b> <b>sudo</b> <b>nsenter</b> <b>-t</b> <b>778501</b> <b>--user</b> <b>--mount</b>
                ns3# <b>mount</b> <b>--rbind</b> <b>--make-private</b> <b>/mnt/x</b> <b>/mnt/ppp</b>
                ns3# <b>grep</b> <b><a href="file:/mnt">/mnt</a></b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
                986 83 8:5 <a href="file:/mnt">/mnt</a> <a href="file:/mnt">/mnt</a> rw,relatime shared:344
                989 986 0:56 / /mnt/x rw,relatime
                990 989 0:57 / /mnt/x/y rw,relatime
                1242 986 0:56 / /mnt/ppp rw,relatime
                1243 1242 0:57 / /mnt/ppp/y rw,relatime shared:518

            Because  the  propagation  type  of  the  parent  mount,  <u><a href="file:/mnt">/mnt</a></u>, was shared, the recursive bind mount
            propagated a small subtree of mounts under the slave mount <u><a href="file:/mnt">/mnt</a></u> into "ns2", as can  be  verified  by
            executing the following command in that shell session:

                ns2# <b>grep</b> <b><a href="file:/mnt">/mnt</a></b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>
                1239 1204 8:5 <a href="file:/mnt">/mnt</a> <a href="file:/mnt">/mnt</a> rw,relatime master:344
                1240 1239 0:56 / /mnt/x rw,relatime
                1241 1240 0:57 / /mnt/x/y rw,relatime
                1244 1239 0:56 / /mnt/ppp rw,relatime
                1245 1244 0:57 / /mnt/ppp/y rw,relatime master:518

            While  it is not possible to <b><a href="../man2/umount.2.html">umount</a></b>(2) a part of the propagated subtree (<u>/mnt/ppp/y</u>) in "ns2", it is
            possible to <b><a href="../man2/umount.2.html">umount</a></b>(2) the entire subtree, as shown by the following commands:

                ns2# <b>umount</b> <b>/mnt/ppp/y</b>
                umount: /mnt/ppp/y: not mounted.
                ns2# <b>umount</b> <b>-l</b> <b>/mnt/ppp</b> <b>|</b> <b>sed</b> <b>'s/</b> <b>-</b> <b>.*//'</b>      # Succeeds...
                ns2# <b>grep</b> <b><a href="file:/mnt">/mnt</a></b> <b><a href="file:/proc/self/mountinfo">/proc/self/mountinfo</a></b>
                1239 1204 8:5 <a href="file:/mnt">/mnt</a> <a href="file:/mnt">/mnt</a> rw,relatime master:344
                1240 1239 0:56 / /mnt/x rw,relatime
                1241 1240 0:57 / /mnt/x/y rw,relatime

       [5]  The  <b><a href="../man2/mount.2.html">mount</a></b>(2)  flags  <b>MS_RDONLY</b>,  <b>MS_NOSUID</b>,  <b>MS_NOEXEC</b>,  and   the   "atime"   flags   (<b>MS_NOATIME</b>,
            <b>MS_NODIRATIME</b>,  <b>MS_RELATIME</b>) settings become locked when propagated from a more privileged to a less
            privileged mount namespace, and may not be changed in the less privileged mount namespace.

            This point is illustrated in the following example where, in a more privileged mount  namespace,  we
            create a bind mount that is marked as read-only.  For security reasons, it should not be possible to
            make the mount writable in a less privileged mount namespace, and indeed the kernel prevents this:

                $ <b>sudo</b> <b>mkdir</b> <b>/mnt/dir</b>
                $ <b>sudo</b> <b>mount</b> <b>--bind</b> <b>-o</b> <b>ro</b> <b>/some/path</b> <b>/mnt/dir</b>
                $ <b>sudo</b> <b>unshare</b> <b>--user</b> <b>--map-root-user</b> <b>--mount</b> <b>\</b>
                               <b>mount</b> <b>-o</b> <b>remount,rw</b> <b>/mnt/dir</b>
                mount: /mnt/dir: permission denied.

       [6]  A  file  or  directory  that  is a mount point in one namespace that is not a mount point in another
            namespace, may be renamed, unlinked, or removed (<b><a href="../man2/rmdir.2.html">rmdir</a></b>(2)) in the mount namespace in which it is not
            a mount point (subject to the usual permission checks).  Consequently, the mount point is removed in
            the mount namespace where it was a mount point.

            Previously (before Linux 3.18), attempting to unlink, rename, or remove a file or directory that was
            a mount point in another mount namespace would  result  in  the  error  <b>EBUSY</b>.   That  behavior  had
            technical  problems  of  enforcement (e.g., for NFS) and permitted denial-of-service attacks against
            more privileged users (i.e., preventing individual files from being updated by bind mounting on  top
            of them).

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <b><a href="../man2/pivot_root.2.html">pivot_root</a></b>(2).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/unshare.1.html">unshare</a></b>(1),   <b><a href="../man2/clone.2.html">clone</a></b>(2),  <b><a href="../man2/mount.2.html">mount</a></b>(2),  <b><a href="../man2/mount_setattr.2.html">mount_setattr</a></b>(2),  <b><a href="../man2/pivot_root.2.html">pivot_root</a></b>(2),  <b><a href="../man2/setns.2.html">setns</a></b>(2),  <b><a href="../man2/umount.2.html">umount</a></b>(2),  <b><a href="../man2/unshare.2.html">unshare</a></b>(2),
       <b><a href="../man5/proc.5.html">proc</a></b>(5),  <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7),  <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7),  <b><a href="../man8/findmnt.8.html">findmnt</a></b>(8),  <b><a href="../man8/mount.8.html">mount</a></b>(8),  <b><a href="../man8/pam_namespace.8.html">pam_namespace</a></b>(8),   <b><a href="../man8/pivot_root.8.html">pivot_root</a></b>(8),
       <b><a href="../man8/umount.8.html">umount</a></b>(8)

       <u>Documentation/filesystems/sharedsubtree.rst</u> in the kernel source tree.

Linux man-pages 6.9.1                              2024-06-15                                <u><a href="../man7/mount_namespaces.7.html">mount_namespaces</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>