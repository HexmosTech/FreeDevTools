<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>stpcpy,  strcpy,  strcat, stpecpy, strtcpy, strlcpy, strlcat, stpncpy, strncpy, strncat - copying strings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       stpcpy,  strcpy,  strcat, stpecpy, strtcpy, strlcpy, strlcat, stpncpy, strncpy, strncat - copying strings
       and character sequences

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Strings</b>
       // Chain-copy a string.
       <b>char</b> <b>*stpcpy(char</b> <b>*restrict</b> <u>dst</u><b>,</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>);</b>

       // Copy/catenate a string.
       <b>char</b> <b>*strcpy(char</b> <b>*restrict</b> <u>dst</u><b>,</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>);</b>
       <b>char</b> <b>*strcat(char</b> <b>*restrict</b> <u>dst</u><b>,</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>);</b>

       // Chain-copy a string with truncation.
       <b>char</b> <b>*stpecpy(char</b> <b>*</b><u>dst</u><b>,</b> <b>char</b> <u>end</u><b>[0],</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>);</b>

       // Copy/catenate a string with truncation.
       <b>ssize_t</b> <b>strtcpy(char</b> <u>dst</u><b>[restrict</b> <b>.</b><u>dsize</u><b>],</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>,</b>
                      <b>size_t</b> <u>dsize</u><b>);</b>
       <b>size_t</b> <b>strlcpy(char</b> <u>dst</u><b>[restrict</b> <b>.</b><u>dsize</u><b>],</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>,</b>
                      <b>size_t</b> <u>dsize</u><b>);</b>
       <b>size_t</b> <b>strlcat(char</b> <u>dst</u><b>[restrict</b> <b>.</b><u>dsize</u><b>],</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>,</b>
                      <b>size_t</b> <u>dsize</u><b>);</b>

   <b>Null-padded</b> <b>character</b> <b>sequences</b>
       // Fill a fixed-size buffer with characters from a string
       // and pad with null bytes.
       <b>char</b> <b>*strncpy(char</b> <u>dst</u><b>[restrict</b> <b>.</b><u>dsize</u><b>],</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>,</b>
                      <b>size_t</b> <u>dsize</u><b>);</b>
       <b>char</b> <b>*stpncpy(char</b> <u>dst</u><b>[restrict</b> <b>.</b><u>dsize</u><b>],</b> <b>const</b> <b>char</b> <b>*restrict</b> <u>src</u><b>,</b>
                      <b>size_t</b> <u>dsize</u><b>);</b>

       // Chain-copy a null-padded character sequence into a character sequence.
       <u>mempcpy(dst,</u> <u>src,</u> <u>strnlen(src,</u> <u>NITEMS(src)));</u>

       // Chain-copy a null-padded character sequence into a string.
       <u>stpcpy(mempcpy(dst,</u> <u>src,</u> <u>strnlen(src,</u> <u>NITEMS(src))),</u> <u>"");</u>

       // Catenate a null-padded character sequence into a string.
       <b>char</b> <b>*strncat(char</b> <b>*restrict</b> <u>dst</u><b>,</b> <b>const</b> <b>char</b> <u>src</u><b>[restrict</b> <b>.</b><u>ssize</u><b>],</b>
                      <b>size_t</b> <u>ssize</u><b>);</b>

       // Duplicate a null-padded character sequence into a string.
       <b>char</b> <b>*strndup(const</b> <b>char</b> <u>src</u><b>[.</b><u>ssize</u><b>],</b> <b>size_t</b> <u>ssize</u><b>);</b>

   <b>Known-length</b> <b>character</b> <b>sequences</b>
       // Chain-copy a known-length character sequence.
       <b>void</b> <b>*mempcpy(void</b> <u>dst</u><b>[restrict</b> <b>.</b><u>len</u><b>],</b> <b>const</b> <b>void</b> <u>src</u><b>[restrict</b> <b>.</b><u>len</u><b>],</b>
                      <b>size_t</b> <u>len</u><b>);</b>

       // Chain-copy a known-length character sequence into a string.
       <u>stpcpy(mempcpy(dst,</u> <u>src,</u> <u>len),</u> <u>"");</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Terms</b> <b>(and</b> <b>abbreviations)</b>
       <u>string</u> (<u>str</u>)
              is a sequence of zero or more non-null characters followed by a null character.

       <u>character</u> <u>sequence</u>
              is a sequence of zero or more non-null  characters.   A  program  should  never  use  a  character
              sequence  where a string is required.  However, with appropriate care, a string can be used in the
              place of a character sequence.

              <u>null-padded</u> <u>character</u> <u>sequence</u>
                     Character sequences can be contained in fixed-size  buffers,  which  contain  padding  null
                     bytes  after  the  character sequence, to fill the rest of the buffer without affecting the
                     character sequence; however, those padding  null  bytes  are  not  part  of  the  character
                     sequence.   Don't  confuse  null-padded  with  null-terminated: null-padded means 0 or more
                     padding null bytes, while null-terminated means exactly 1 terminating null character.

              <u>known-length</u> <u>character</u> <u>sequence</u>
                     Character sequence delimited by its length.  It may  be  a  slice  of  a  larger  character
                     sequence, or even of a string.

       <u>length</u> (<u>len</u>)
              is the number of non-null characters in a string or character sequence.  It is the return value of
              <u>strlen(str)</u> and of <u>strnlen(buf,</u> <u>size)</u>.

       <u>size</u>   refers to the entire buffer where the string or character sequence is contained.

       <u>end</u>    is  the  name  of  a  pointer  to  one  past  the  last  element of a buffer.  It is equivalent to
              <u>&amp;str[size]</u>.  It is used as a sentinel value, to be able to truncate strings or character sequences
              instead of overrunning the containing buffer.

       <u>copy</u>   This term is used when the writing starts at the first element pointed to by <u>dst</u>.

       <u>catenate</u>
              This term is used when a function first finds the terminating null  character  in  <u>dst</u>,  and  then
              starts writing at that position.

       <u>chain</u>  This  term  is  used  when  it's  the  programmer  who  provides a pointer to the terminating null
              character in the string <u>dst</u> (or one after the last character in a  character  sequence),  and  the
              function  starts  writing at that location.  The function returns a pointer to the new location of
              the terminating null character (or one after the last character in a character sequence) after the
              call, so that the programmer can use it to chain such calls.

       <u>duplicate</u>
              Allocate a new buffer where a copy is placed.

   <b>Copy,</b> <b>catenate,</b> <b>and</b> <b>chain-copy</b>
       Originally, there was a distinction between functions that copy and those that catenate.  However,  newer
       functions  that  copy  while  allowing  chaining  cover  both use cases with a single API.  They are also
       algorithmically faster, since they don't need to  search  for  the  terminating  null  character  of  the
       existing  string.   However,  functions  that  catenate have a much simpler use, so if performance is not
       important, it can make sense to use them for improving readability.

       The pointer returned by functions that allow chaining is a byproduct of the copy operation, so it has  no
       performance costs.  Functions that return such a pointer, and thus can be chained, have names of the form
       *<b>stp</b>*(), since it's common to name the pointer just <u>p</u>.

       Chain-copying  functions  that truncate should accept a pointer to the end of the destination buffer, and
       have names of the form *<b>stpe</b>*().  This allows not having to recalculate the  remaining  size  after  each
       call.

   <b>Truncate</b> <b>or</b> <b>not?</b>
       The  first  thing  to  note  is  that programmers should be careful with buffers, so they always have the
       correct size, and truncation is not necessary.

       In most cases, truncation is not desired, and it is simpler to just do the copy.  Simpler code  is  safer
       code.   Programming against programming mistakes by adding more code just adds more points where mistakes
       can be made.

       Nowadays, compilers can detect most programmer  errors  with  features  like  compiler  warnings,  static
       analyzers,  and  <b>_FORTIFY_SOURCE</b>  (see  <b><a href="../man7/ftm.7.html">ftm</a></b>(7)).   Keeping the code simple helps these overflow-detection
       features be more precise.

       When validating user input, code should normally not truncate, but instead fail and prevent the  copy  at
       all.

       In some cases, however, it makes sense to truncate.

       Functions that truncate:

       •  <b>stpecpy</b>()

       •  <b>strtcpy</b>()

       •  <b><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></b>(3bsd) and <b><a href="../man3bsd/strlcat.3bsd.html">strlcat</a></b>(3bsd) are similar, but have important performance problems; see BUGS.

       •  <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3)  and  <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3)  also  truncate,  but  they  don't  write  strings, but rather null-padded
          character sequences.

   <b>Null-padded</b> <b>character</b> <b>sequences</b>
       For historic reasons, some standard APIs and file formats, such as <b><a href="../man5/utmpx.5.html">utmpx</a></b>(5) and <b><a href="../man1/tar.1.html">tar</a></b>(1),  use  null-padded
       character  sequences  in  fixed-size  buffers.   To interface with them, specialized functions need to be
       used.

       To copy bytes from strings into these buffers, use <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3) or <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3).

       To read a null-padded character sequence, use <u>strnlen(src,</u> <u>NITEMS(src))</u>, and then you can treat it  as  a
       known-length character sequence; or use <b><a href="../man3/strncat.3.html">strncat</a></b>(3) or <b><a href="../man3/strndup.3.html">strndup</a></b>(3) directly.

   <b>Known-length</b> <b>character</b> <b>sequences</b>
       The simplest character sequence copying function is <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3).  It requires always knowing the length of
       your  character  sequences,  for  which structures can be used.  It makes the code much faster, since you
       always know the  length  of  your  character  sequences,  and  can  do  the  minimal  copies  and  length
       measurements.   <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3) copies character sequences, so you need to explicitly set the terminating null
       character if you need a string.

       In programs that make considerable use of strings or character sequences, and need the best  performance,
       using  overlapping  character  sequences  can make a big difference.  It allows holding subsequences of a
       larger character sequence, while not duplicating memory nor using time to do a copy.

       However, this is delicate, since it requires using character sequences.  C library APIs use  strings,  so
       programs  that  use  character sequences will have to take care of differentiating strings from character
       sequences.

       To copy a known-length character sequence, use <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3).

       To copy a known-length character sequence into a string, use <u>stpcpy(mempcpy(dst,</u> <u>src,</u> <u>len),</u> <u>"")</u>.

       A string is also accepted as input, because <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3) asks for the length, and a string is composed of a
       character sequence of the same length plus a terminating null character.

   <b>String</b> <b>vs</b> <b>character</b> <b>sequence</b>
       Some functions only operate on strings.  Those require that the input <u>src</u> is a string, and  guarantee  an
       output  string  (even  when  truncation  occurs).   Functions that catenate also require that <u>dst</u> holds a
       string before the call.  List of functions:

       •  <b><a href="../man3/stpcpy.3.html">stpcpy</a></b>(3)
       •  <b><a href="../man3/strcpy.3.html">strcpy</a></b>(3), <b><a href="../man3/strcat.3.html">strcat</a></b>(3)
       •  <b>stpecpy</b>()
       •  <b>strtcpy</b>()
       •  <b><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></b>(3bsd), <b><a href="../man3bsd/strlcat.3bsd.html">strlcat</a></b>(3bsd)

       Other functions require an input string, but create a character sequence as output.  These functions have
       confusing names, and have a long history of misuse.  List of functions:

       •  <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3)
       •  <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3)

       Other functions operate on an input character sequence, and create  an  output  string.   Functions  that
       catenate  also  require  that <u>dst</u> holds a string before the call.  <b><a href="../man3/strncat.3.html">strncat</a></b>(3) has an even more misleading
       name than the functions above.  List of functions:

       •  <b><a href="../man3/strncat.3.html">strncat</a></b>(3)
       •  <b><a href="../man3/strndup.3.html">strndup</a></b>(3)

       Other functions operate on an input character sequence to create an output character sequence.   List  of
       functions:

       •  <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3)

   <b>Functions</b>
       <b><a href="../man3/stpcpy.3.html">stpcpy</a></b>(3)
              Copy  the  input string into a destination string.  The programmer is responsible for allocating a
              buffer large enough.  It returns a pointer suitable for chaining.

       <b><a href="../man3/strcpy.3.html">strcpy</a></b>(3)
       <b><a href="../man3/strcat.3.html">strcat</a></b>(3)
              Copy and catenate the input string into a destination string.  The programmer is  responsible  for
              allocating a buffer large enough.  The return value is useless.

              <b><a href="../man3/stpcpy.3.html">stpcpy</a></b>(3) is a faster alternative to these functions.

       <b>stpecpy</b>()
              Chain-copy  the  input  string into a destination string.  If the destination buffer, limited by a
              pointer to its end, isn't large enough to hold the copy, the resulting string is truncated (but it
              is guaranteed to be null-terminated).  It returns a pointer  suitable  for  chaining.   Truncation
              needs to be detected only once after the last chained call.

              This function is not provided by any library; see EXAMPLES for a reference implementation.

       <b>strtcpy</b>()
              Copy  the input string into a destination string.  If the destination buffer isn't large enough to
              hold the copy, the resulting string is truncated (but it is guaranteed to be null-terminated).  It
              returns the length of the string, or -1 if it truncated.

              This function is not provided by any library; see EXAMPLES for a reference implementation.

       <b><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></b>(3bsd)
       <b><a href="../man3bsd/strlcat.3bsd.html">strlcat</a></b>(3bsd)
              Copy and catenate the input string into a destination string.  If the destination buffer,  limited
              by  its  size,  isn't  large enough to hold the copy, the resulting string is truncated (but it is
              guaranteed to be null-terminated).  They return the length of  the  total  string  they  tried  to
              create.

              Check BUGS before using these functions.

              <b>strtcpy</b>() and <b>stpecpy</b>() are better alternatives to these functions.

       <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3)
              Copy  the  input  string into a destination null-padded character sequence in a fixed-size buffer.
              If the destination buffer, limited by its size, isn't large enough to hold the copy, the resulting
              character sequence is truncated.  Since it creates a character sequence, it doesn't need to  write
              a  terminating  null  character.   It's  impossible to distinguish truncation by the result of the
              call, from a character sequence that just  fits  the  destination  buffer;  truncation  should  be
              detected by comparing the length of the input string with the size of the destination buffer.

       <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3)
              This function is identical to <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3) except for the useless return value.

              <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3) is a more useful alternative to this function.

       <b><a href="../man3/strncat.3.html">strncat</a></b>(3)
              Catenate  the  input  character  sequence,  contained  in  a null-padded fixed-size buffer, into a
              destination string.  The programmer is responsible for allocating  a  buffer  large  enough.   The
              return value is useless.

              Do not confuse this function with <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3); they are not related at all.

              <u>stpcpy(mempcpy(dst,</u> <u>src,</u> <u>strnlen(src,</u> <u>NITEMS(src))),</u> <u>"")</u> is a faster alternative to this function.

       <b><a href="../man3/strndup.3.html">strndup</a></b>(3)
              Duplicate the input character sequence, contained in a null-padded fixed-size buffer, into a newly
              allocated destination string.

              The string must be freed with <b><a href="../man3/free.3.html">free</a></b>(3).

       <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3)
              Copy  the  input character sequence, limited by its length, into a destination character sequence.
              The programmer is responsible for allocating a buffer large enough.  It returns a pointer suitable
              for chaining.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b><a href="../man3/stpcpy.3.html">stpcpy</a></b>(3)
              A pointer to the terminating null character in the destination string.

       <b>stpecpy</b>()
              A pointer to the terminating null character in the destination string, on success.  On error, NULL
              is returned, and <u>errno</u> is set to indicate the error.

       <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3)
       <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3)
              A pointer to one after the last character in the destination character sequence.

       <b>strtcpy</b>()
              The length of the string, on success.  On error, -1 is returned, and <u>errno</u> is set to indicate  the
              error.

       <b><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></b>(3bsd)
       <b><a href="../man3bsd/strlcat.3bsd.html">strlcat</a></b>(3bsd)
              The length of the total string that they tried to create (as if truncation didn't occur).

       <b><a href="../man3/strcpy.3.html">strcpy</a></b>(3)
       <b><a href="../man3/strcat.3.html">strcat</a></b>(3)
       <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3)
       <b><a href="../man3/strncat.3.html">strncat</a></b>(3)
              The <u>dst</u> pointer, which is useless.

       <b><a href="../man3/strndup.3.html">strndup</a></b>(3)
              The newly allocated string.

</pre><h4><b>ERRORS</b></h4><pre>
       Most of these functions don't set <u>errno</u>.

       <b>stpecpy</b>()
       <b>strtcpy</b>()

              <b>ENOBUFS</b>
                     <u>dsize</u> was <b>0</b>.

              <b>E2BIG</b>  The string has been truncated.

       <b><a href="../man3/strndup.3.html">strndup</a></b>(3)

              <b>ENOMEM</b> Insufficient memory available to allocate duplicate string.

</pre><h4><b>NOTES</b></h4><pre>
       The  Linux  kernel  has  an  internal  function  for  copying  strings, <b><a href="../man9/strscpy.9.html">strscpy</a></b>(9), which is identical to
       <b>strtcpy</b>(), except that it returns <b>-E2BIG</b> instead of -1 and it doesn't set <u>errno</u>.

</pre><h4><b>CAVEATS</b></h4><pre>
       Don't mix chain calls to truncating and non-truncating functions.  It is conceptually  wrong  unless  you
       know  that the first part of a copy will always fit.  Anyway, the performance difference will probably be
       negligible, so it will probably be more clear if you use consistent semantics: either truncating or  non-
       truncating.  Calling a non-truncating function after a truncating one is necessarily wrong.

</pre><h4><b>BUGS</b></h4><pre>
       All  catenation  functions  share  the  same performance problem: Shlemiel the painter.  As a mitigation,
       compilers are able to transform some calls to catenation functions  into  normal  copy  functions,  since
       <u>strlen(dst)</u> is usually a byproduct of the previous copy.

       <b><a href="../man3/strlcpy.3.html">strlcpy</a></b>(3)  and  <b><a href="../man3/strlcat.3.html">strlcat</a></b>(3)  need to read the entire <u>src</u> string, even if the destination buffer is small.
       This makes them vulnerable to Denial of Service (DoS) attacks if an attacker can control  the  length  of
       the <u>src</u> string.  And if not, they're still unnecessarily slow.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following are examples of correct use of each of these functions.

       <b><a href="../man3/stpcpy.3.html">stpcpy</a></b>(3)
              p = buf;
              p = stpcpy(p, "Hello ");
              p = stpcpy(p, "world");
              p = stpcpy(p, "!");
              len = p - buf;
              puts(buf);

       <b><a href="../man3/strcpy.3.html">strcpy</a></b>(3)
       <b><a href="../man3/strcat.3.html">strcat</a></b>(3)
              strcpy(buf, "Hello ");
              strcat(buf, "world");
              strcat(buf, "!");
              len = strlen(buf);
              puts(buf);

       <b>stpecpy</b>()
              end = buf + NITEMS(buf);
              p = buf;
              p = stpecpy(p, end, "Hello ");
              p = stpecpy(p, end, "world");
              p = stpecpy(p, end, "!");
              if (p == NULL) {
                  len = NITEMS(buf) - 1;
                  goto toolong;
              }
              len = p - buf;
              puts(buf);

       <b>strtcpy</b>()
              len = strtcpy(buf, "Hello world!", NITEMS(buf));
              if (len == -1)
                  goto toolong;
              puts(buf);

       <b><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></b>(3bsd)
       <b><a href="../man3bsd/strlcat.3bsd.html">strlcat</a></b>(3bsd)
              if (strlcpy(buf, "Hello ", NITEMS(buf)) &gt;= NITEMS(buf))
                  goto toolong;
              if (strlcat(buf, "world", NITEMS(buf)) &gt;= NITEMS(buf))
                  goto toolong;
              len = strlcat(buf, "!", NITEMS(buf));
              if (len &gt;= NITEMS(buf))
                  goto toolong;
              puts(buf);

       <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3)
              p = stpncpy(u-&gt;ut_user, "alx", NITEMS(u-&gt;ut_user));
              if (NITEMS(u-&gt;ut_user) &lt; strlen("alx"))
                  goto toolong;
              len = p - u-&gt;ut_user;
              fwrite(u-&gt;ut_user, 1, len, stdout);

       <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3)
              strncpy(u-&gt;ut_user, "alx", NITEMS(u-&gt;ut_user));
              if (NITEMS(u-&gt;ut_user) &lt; strlen("alx"))
                  goto toolong;
              len = strnlen(u-&gt;ut_user, NITEMS(u-&gt;ut_user));
              fwrite(u-&gt;ut_user, 1, len, stdout);

       <u>mempcpy(dst,</u> <u>src,</u> <u>strnlen(src,</u> <u>NITEMS(src)))</u>
              char  buf[NITEMS(u-&gt;ut_user)];
              p = buf;
              p = mempcpy(p, u-&gt;ut_user, strnlen(u-&gt;ut_user, NITEMS(u-&gt;ut_user)));
              len = p - buf;
              fwrite(buf, 1, len, stdout);

       <u>stpcpy(mempcpy(dst,</u> <u>src,</u> <u>strnlen(src,</u> <u>NITEMS(src))),</u> <u>"")</u>
              char  buf[NITEMS(u-&gt;ut_user) + 1];
              p = buf;
              p = mempcpy(p, u-&gt;ut_user, strnlen(u-&gt;ut_user, NITEMS(u-&gt;ut_user)));
              p = stpcpy(p, "");
              len = p - buf;
              puts(buf);

       <b><a href="../man3/strncat.3.html">strncat</a></b>(3)
              char  buf[NITEMS(u-&gt;ut_user) + 1];
              strcpy(buf, "");
              strncat(buf, u-&gt;ut_user, NITEMS(u-&gt;ut_user));
              len = strlen(buf);
              puts(buf);

       <b><a href="../man3/strndup.3.html">strndup</a></b>(3)
              buf = strndup(u-&gt;ut_user, NITEMS(u-&gt;ut_user));
              len = strlen(buf);
              puts(buf);
              free(buf);

       <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3)
              p = buf;
              p = mempcpy(p, "Hello ", 6);
              p = mempcpy(p, "world", 5);
              p = mempcpy(p, "!", 1);
              len = p - buf;
              fwrite(buf, 1, len, stdout);

       <u>stpcpy(mempcpy(dst,</u> <u>src,</u> <u>len),</u> <u>"")</u>
              p = buf;
              p = mempcpy(p, "Hello ", 6);
              p = mempcpy(p, "world", 5);
              p = mempcpy(p, "!", 1);
              p = stpcpy(p, "");
              len = p - buf;
              puts(buf);

   <b>Implementations</b>
       Here are reference implementations for functions not provided by libc.

           /* This code is in the public domain. */

           char *
           <u>stpecpy</u>(char *dst, char end[0], const char *restrict src)
           {
               size_t  dlen;

               if (dst == NULL)
                   return NULL;

               dlen = strtcpy(dst, src, end - dst);
               return (dlen == -1) ? NULL : dst + dlen;
           }

           ssize_t
           <u>strtcpy</u>(char *restrict dst, const char *restrict src, size_t dsize)
           {
               bool    trunc;
               size_t  dlen, slen;

               if (dsize == 0) {
                   errno = ENOBUFS;
                   return -1;
               }

               slen = strnlen(src, dsize);
               trunc = (slen == dsize);
               dlen = slen - trunc;

               stpcpy(mempcpy(dst, src, dlen), "");
               if (trunc)
                   errno = E2BIG;
               return trunc ? -1 : slen;
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/bzero.3.html">bzero</a></b>(3), <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3), <b><a href="../man3/memccpy.3.html">memccpy</a></b>(3), <b><a href="../man3/mempcpy.3.html">mempcpy</a></b>(3), <b><a href="../man3/stpcpy.3.html">stpcpy</a></b>(3), <b><a href="../man3bsd/strlcpy.3bsd.html">strlcpy</a></b>(3bsd), <b><a href="../man3/strncat.3.html">strncat</a></b>(3), <b><a href="../man3/stpncpy.3.html">stpncpy</a></b>(3), <b><a href="../man3/string.3.html">string</a></b>(3)

Linux man-pages 6.9.1                              2024-05-14                                  <u><a href="../man7/string_copying.7.html">string_copying</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>