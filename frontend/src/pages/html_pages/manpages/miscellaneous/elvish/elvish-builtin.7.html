<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The builtin module contains facilities that are potentially useful to all users.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/elvish">elvish_0.17.0-1ubuntu0.1_amd64</a> <br><br><pre>
</pre><h4><b>Introduction</b></h4><pre>
       The builtin module contains facilities that are potentially useful to all users.

   <b>Using</b> <b>builtin:</b> <b>explicitly</b>
       The builtin module is consulted implicitly when resolving unqualified names, so you usually don’t need to
       specify builtin: explicitly.  However, there are some cases where it is useful to do that:

       • When  a  builtin  function  is  shadowed by a local function, you can still use the builtin function by
         specifying builtin:.  This is especially useful when wrapping a builtin function:

                use builtin
                fn cd [@args]{
                    echo running my cd function
                    builtin:cd $@args
                }

       • Introspecting the builtin module, for example keys $builtin:.

   <b>Usage</b> <b>Notation</b>
       The usage of a builtin command is described by giving an example usage,  using  variables  as  arguments.
       For instance, The repeat command takes two arguments and are described as:

              repeat $n $v

       Optional  arguments are represented with a trailing ?, while variadic arguments with a trailing ....  For
       instance, the count command takes an optional list:

              count $input-list?

       While the put command takes an arbitrary number of arguments:

              put $values...

       Options are given along with their default values.  For instance, the echo command takes  an  sep  option
       and arbitrary arguments:

              echo &amp;sep=' ' $value...

       (When you calling functions, options are always optional.)

   <b>Supplying</b> <b>Input</b>
       Some builtin functions, e.g.  count and each, can take their input in one of two ways:

       1. From pipe:

                  ~&gt; put lorem ipsum | count # count number of inputs
                  2
                  ~&gt; put 10 100 | each [x]{ + 1 $x } # apply function to each input
                  ▶ 11
                  ▶ 101

           Byte pipes are also possible; one line becomes one input:

                  ~&gt; echo "a\nb\nc" | count # count number of lines
                  ▶ 3

       2. From an argument – an iterable value:

                  ~&gt; count [lorem ipsum] # count number of elements in argument
                  2
                  ~&gt; each [x]{ + 1 $x } [10 100] # apply to each element in argument
                  ▶ 11
                  ▶ 101

           Strings, and in future, other sequence types are also possible:

                  ~&gt; count lorem
                  ▶ 5

       When  documenting  such  commands, the optional argument is always written as $input-list?.  On the other
       hand, a trailing $input-list? always indicates that a command can take its  input  in  one  of  two  ways
       above: this fact is not repeated below.

       <b>Note</b>:  You  should  prefer  the  first form, unless using it requires explicit put commands.  Avoid count
       [(some-command)] or each $some-func [(some-command)]; they are, most of the time, equivalent to some-com‐
       mand | count or some-command | each $some-func.

       <b>Rationale</b>: An alternative way to design this is to make (say) count take an  arbitrary  number  of  argu‐
       ments,  and count its arguments; when there is 0 argument, count inputs.  However, this leads to problems
       in code like count *; the intention is clearly to count the number of files in the current directory, but
       when the current directory is empty, count will wait for inputs.  Hence it is required to put  the  input
       in a list: count [*] unambiguously supplies input in the argument, even if there is no file.

   <b>Numeric</b> <b>commands</b>
       Anywhere a command expects a number argument, that argument can be supplied either with a typed number or
       a string that can be converted to a number.  This includes numeric comparison commands like ==.

       When a command outputs numbers, it always outputs a typed number.

       Examples:

              ~&gt; + 2 10
              ▶ (num 12)
              ~&gt; == 2 (num 2)
              ▶ $true

   <b>Exactness-preserving</b> <b>commands</b> <b>{#exactness-preserving}</b>
       Some numeric commands are designated <b>exactness-preserving</b>.  When such commands are called with only exact
       numbers (i.e.  integers or rationals), they will always output an exact number.  Examples:

              ~&gt; + 10 1/10
              ▶ (num 101/10)
              ~&gt; * 12 5/17
              ▶ (num 60/17)

       If  the  condition above is not satisfied - i.e.  when a numeric command is not designated exactness-pre‐
       serving, or when at least one of the arguments is inexact (i.e.  a floating-point number), the result  is
       an inexact number, unless otherwise documented.  Examples:

              ~&gt; + 10 0.1
              ▶ (num 10.1)
              ~&gt; + 10 1e1
              ▶ (num 20.0)
              ~&gt; use math
              ~&gt; math:sin 1
              ▶ (num 0.8414709848078965)

       There are some cases where the result is exact despite the use of inexact arguments or non-exactness-pre‐
       serving commands.  Such cases are always documented in their respective commands.

   <b>Predicates</b>
       Predicates  are  functions  that  write  exactly one output that is either $true or $false.  They are de‐
       scribed like “Determine ...” or “Test ...”.  See is for one example.

   <b>“Do</b> <b>Not</b> <b>Use”</b> <b>Functions</b> <b>and</b> <b>Variables</b>
       The name of some variables and functions have a leading -.  This is a convention to say that it  is  sub‐
       ject  to change and should not be depended upon.  They are either only useful for debug purposes, or have
       known issues in the interface or implementation, and in the worst case will make Elvish  crash.   (Before
       1.0, all features are subject to change, but those ones are sure to be changed.)

       Those  functions and variables are documented near the end of the respective sections.  Their known prob‐
       lem is also discussed.

</pre><h4><b>Variables</b></h4><pre>
   <b>$_</b> <b>{#_}</b>
       A blackhole variable.

       Values assigned to it will be discarded.  Referencing it always results in $nil.

   <b>$after-chdir</b> <b>{#after-chdir}</b>
       A list of functions to run after changing directory.  These functions are always called with directory to
       change it, which might be a relative path.  The following example also shows $before-chdir:

              ~&gt; before-chdir = [{|dir| echo "Going to change to "$dir", pwd is "$pwd }]
              ~&gt; after-chdir = [{|dir| echo "Changed to "$dir", pwd is "$pwd }]
              ~&gt; cd <a href="file:/usr">/usr</a>
              Going to change to <a href="file:/usr">/usr</a>, pwd is /Users/xiaq
              Changed to <a href="file:/usr">/usr</a>, pwd is <a href="file:/usr">/usr</a>
              <a href="file:/usr">/usr</a>&gt; cd local
              Going to change to local, pwd is <a href="file:/usr">/usr</a>
              Changed to local, pwd is <a href="file:/usr/local">/usr/local</a>
              <a href="file:/usr/local">/usr/local</a>&gt;

       See also before-chdir.

   <b>$args</b> <b>{#args}</b>
       A list containing command-line arguments.  Analogous to argv in some other languages.  Examples:

              ~&gt; echo 'put $args' &gt; args.elv
              ~&gt; elvish args.elv foo -bar
              ▶ [foo -bar]
              ~&gt; elvish -c 'put $args' foo -bar
              ▶ [foo -bar]

       As demonstrated above, this variable does not contain the name of the script used to invoke it.  For that
       information, use the src command.

       See also src.

   <b>$before-chdir</b> <b>{#before-chdir}</b>
       A list of functions to run before changing directory.  These functions are always  called  with  the  new
       working directory.

       See also after-chdir.

   <b>$buildinfo</b> <b>{#buildinfo}</b>
       A  psuedo-map  that  exposes  information about the Elvish binary.  Running put $buildinfo | to-json will
       produce the same output as elvish -buildinfo -json.

       See also version.

   <b>$false</b> <b>{#false}</b>
       The boolean false value.

   <b>$nil</b> <b>{#nil}</b>
       A special value useful for representing the lack of values.

   <b>$notify-bg-job-success</b> <b>{#notify-bg-job-success}</b>
       Whether to notify success of background jobs, defaulting to $true.

       Failures of background jobs are always notified.

   <b>$num-bg-jobs</b> <b>{#num-bg-jobs}</b>
       Number of background jobs.

   <b>$ok</b> <b>{#ok}</b>
       The special value used by ?() to signal absence of exceptions.

   <b>$paths</b> <b>{#paths}</b>
       A list of search paths, kept in sync with $E:PATH.  It is easier to use than $E:PATH.

   <b>$pid</b> <b>{#pid}</b>
       The process ID of the current Elvish process.

   <b>$pwd</b> <b>{#pwd}</b>
       The present working directory.  Setting this variable has the same effect as cd.  This variable  is  most
       useful in a temporary assignment.

       Example:

              ## Updates all git repositories
              for x [*/] {
                pwd=$x {
                  if ?(test -d .git) {
                    git pull
                  }
                }
              }

       Etymology: the pwd command.

       See also cd.

   <b>$true</b> <b>{#true}</b>
       The boolean true value.

   <b>$value-out-indicator</b> <b>{#value-out-indicator}</b>
       A string put before value outputs (such as those of of put).  Defaults to '▶ '.  Example:

              ~&gt; put lorem ipsum
              ▶ lorem
              ▶ ipsum
              ~&gt; value-out-indicator = 'val&gt; '
              ~&gt; put lorem ipsum
              val&gt; lorem
              val&gt; ipsum

       Note that you almost always want some trailing whitespace for readability.

   <b>$version</b> <b>{#version}</b>
       The full version of the Elvish binary as a string.  This is the same information reported by elvish -ver‐
       sion and the value of $buildinfo[version].

       <b>Note:</b>  In general it is better to perform functionality tests rather than testing $version.  For example,
       do something like

              has-key $builtin: new-var

       to test if variable new-var is available rather than comparing against $version to see if the elvish ver‐
       sion is equal to or newer than the version that introduced new-var.

       See also buildinfo.

</pre><h4><b>Functions</b></h4><pre>
   <b>+</b> <b>{#add}</b>
              + $num...

       Outputs the sum of all arguments, or 0 when there are no arguments.

       This command is exactness-preserving.

       Examples:

              ~&gt; + 5 2 7
              ▶ (num 14)
              ~&gt; + 1/2 1/3 1/4
              ▶ (num 13/12)
              ~&gt; + 1/2 0.5
              ▶ (num 1.0)

   <b>-</b> <b>{#sub}</b>
              - $x-num $y-num...

       Outputs the result of subtracting from $x-num all the $y-nums, working from left to right.  When  no  $y-
       num  is  given, outputs the negation of $x-num instead (in other words, - $x-num is equivalent to - 0 $x-
       num).

       This command is exactness-preserving.

       Examples:

              ~&gt; - 5
              ▶ (num -5)
              ~&gt; - 5 2
              ▶ (num 3)
              ~&gt; - 5 2 7
              ▶ (num -4)
              ~&gt; - 1/2 1/3
              ▶ (num 1/6)
              ~&gt; - 1/2 0.3
              ▶ (num 0.2)
              ~&gt; - 10
              ▶ (num -10)

   <b>*</b> <b>{#mul}</b>
              * $num...

       Outputs the product of all arguments, or 1 when there are no arguments.

       This command is exactness-preserving.  Additionally, when any argument is exact 0 and no  other  argument
       is a floating-point infinity, the result is exact 0.

       Examples:

              ~&gt; * 2 5 7
              ▶ (num 70)
              ~&gt; * 1/2 0.5
              ▶ (num 0.25)
              ~&gt; * 0 0.5
              ▶ (num 0)

   <b>/</b> <b>{#div}</b>
              / $x-num $y-num...

       Outputs  the  result of dividing $x-num with all the $y-nums, working from left to right.  When no $y-num
       is given, outputs the reciprocal of $x-num instead (in other words, / $y-num is equivalent  to  /  1  $y-
       num).

       Dividing  by  exact 0 raises an exception.  Dividing by inexact 0 results with either infinity or NaN ac‐
       cording to floating-point semantics.

       This command is exactness-preserving.  Additionally, when $x-num is exact 0 and no $y-num is exact 0, the
       result is exact 0.

       Examples:

              ~&gt; / 2
              ▶ (num 1/2)
              ~&gt; / 2.0
              ▶ (num 0.5)
              ~&gt; / 10 5
              ▶ (num 2)
              ~&gt; / 2 5
              ▶ (num 2/5)
              ~&gt; / 2 5 7
              ▶ (num 2/35)
              ~&gt; / 0 1.0
              ▶ (num 0)
              ~&gt; / 2 0
              Exception: bad value: divisor must be number other than exact 0, but is exact 0
              [tty 6], line 1: / 2 0
              ~&gt; / 2 0.0
              ▶ (num +Inf)

       When given no argument, this command is equivalent to cd /, due to the implicit cd feature.  (The implic‐
       it cd feature will probably change to avoid this oddity).

   <b>%</b> <b>{#rem}</b>
              % $x $y

       Output the remainder after dividing $x by $y.  The result has the same sign as $x.  Both must be integers
       that can represented in a machine word (this limit may be lifted in future).

       Examples:

              ~&gt; % 10 3
              ▶ 1
              ~&gt; % -10 3
              ▶ -1
              ~&gt; % 10 -3
              ▶ 1

   <b>&lt;</b> <b>&lt;=</b> <b>==</b> <b>!=</b> <b>&gt;</b> <b>&gt;=</b> <b>{#num-cmp}</b>
              &lt;  $number... # less
              &lt;= $number... # less or equal
              == $number... # equal
              != $number... # not equal
              &gt;  $number... # greater
              &gt;= $number... # greater or equal

       Number comparisons.  All of them accept an arbitrary number of arguments:

       1. When given fewer than two arguments, all output $true.

       2. When given two arguments, output whether the two arguments satisfy the named relationship.

       3. When given more than two arguments, output whether every adjacent pair of numbers  satisfy  the  named
          relationship.

       Examples:

              ~&gt; == 3 3.0
              ▶ $true
              ~&gt; &lt; 3 4
              ▶ $true
              ~&gt; &lt; 3 4 10
              ▶ $true
              ~&gt; &lt; 6 9 1
              ▶ $false

       As  a consequence of rule 3, the != command outputs $true as long as any <u>adjacent</u> pair of numbers are not
       equal, even if some numbers that are not adjacent are equal:

              ~&gt; != 5 5 4
              ▶ $false
              ~&gt; != 5 6 5
              ▶ $true

   <b>&lt;s</b> <b>&lt;=s</b> <b>==s</b> <b>!=s</b> <b>&gt;s</b> <b>&gt;=s</b> <b>{#str-cmp}</b>
              &lt;s  $string... # less
              &lt;=s $string... # less or equal
              ==s $string... # equal
              !=s $string... # not equal
              &gt;s  $string... # greater
              &gt;=s $string... # greater or equal

       String comparisons.  They behave similarly to their number counterparts when  given  multiple  arguments.
       Examples:

              ~&gt; &gt;s lorem ipsum
              ▶ $true
              ~&gt; ==s 1 1.0
              ▶ $false
              ~&gt; &gt;s 8 12
              ▶ $true

   <b>all</b> <b>{#all}</b>
              all $input-list?

       Passes inputs to the output as is.  Byte inputs into values, one per line.

       This  is an identity function for commands with value outputs: a | all is equivalent to a if it only out‐
       puts values.

       This function is useful for turning inputs into arguments, like:

              ~&gt; use str
              ~&gt; put 'lorem,ipsum' | str:split , (all)
              ▶ lorem
              ▶ ipsum

       Or capturing all inputs in a variable:

              ~&gt; x = [(all)]
              foo
              bar
              (Press ^D)
              ~&gt; put $x
              ▶ [foo bar]

       When given a list, it outputs all elements of the list:

              ~&gt; all [foo bar]
              ▶ foo
              ▶ bar

       See also one.

   <b>assoc</b> <b>{#assoc}</b>
              assoc $container $k $v

       Output a slightly modified version of $container, such that its value at $k is $v.  Applies to both lists
       and to maps.

       When $container is a list, $k may be a negative index.  However, slice is not yet supported.

              ~&gt; assoc [foo bar quux] 0 lorem
              ▶ [lorem bar quux]
              ~&gt; assoc [foo bar quux] -1 ipsum
              ▶ [foo bar ipsum]
              ~&gt; assoc [&amp;k=v] k v2
              ▶ [&amp;k=v2]
              ~&gt; assoc [&amp;k=v] k2 v2
              ▶ [&amp;k2=v2 &amp;k=v]

       Etymology: Clojure (https://clojuredocs.org/clojure.core/assoc).

       See also dissoc.

   <b>base</b> <b>{#base}</b>
              base $base $number...

       Outputs a string for each $number written in $base.  The $base must be between 2 and 36, inclusive.   Ex‐
       amples:

              ~&gt; base 2 1 3 4 16 255
              ▶ 1
              ▶ 11
              ▶ 100
              ▶ 10000
              ▶ 11111111
              ~&gt; base 16 1 3 4 16 255
              ▶ 1
              ▶ 3
              ▶ 4
              ▶ 10
              ▶ ff

   <b>bool</b> <b>{#bool}</b>
              bool $value

       Convert a value to boolean.  In Elvish, only $false and errors are booleanly false.  Everything else, in‐
       cluding 0, empty strings and empty lists, is booleanly true:

              ~&gt; bool $true
              ▶ $true
              ~&gt; bool $false
              ▶ $false
              ~&gt; bool $ok
              ▶ $true
              ~&gt; bool ?(fail haha)
              ▶ $false
              ~&gt; bool ''
              ▶ $true
              ~&gt; bool []
              ▶ $true
              ~&gt; bool abc
              ▶ $true

       See also not.

   <b>break</b> <b>{#break}</b>
       Raises  the  special  “break” exception.  When raised inside a loop it is captured and causes the loop to
       terminate.

       Because break raises an exception it can be caught by a try block.  If not caught, either implicitly by a
       loop or explicitly, it causes a failure like any other uncaught exception.

       See the discussion about flow commands and exceptions

       <b>Note</b>: You can create a break function and it will shadow the builtin command.  If you do  so  you  should
       explicitly invoke the builtin.  For example:

              ~&gt; use builtin
              ~&gt; fn break { put 'break'; builtin:break; put 'should not appear' }
              ~&gt; for x [a b c] { put $x; break; put 'unexpected' }
              ▶ a
              ▶ break

   <b>cd</b> <b>{#cd}</b>
              cd $dirname

       Change  directory.   This affects the entire process; i.e., all threads whether running indirectly (e.g.,
       prompt functions) or started explicitly by commands such as peach.

       Note that Elvish’s cd does not support cd -.

       See also pwd.

   <b>compare</b> <b>{#compare}</b>
              compare $a $b

       Outputs -1 if $a &lt; $b, 0 if $a = $b, and 1 if $a &gt; $b.

       The following comparison algorithm is used:

       • Typed numbers are compared numerically.  The comparison is consistent with the number  comparison  com‐
         mands, except that NaN values are considered equal to each other and smaller than all other numbers.

       • Strings  are  compared lexicographically by bytes, consistent with the string comparison commands.  For
         UTF-8 encoded strings, this is equivalent to comparing by codepoints.

       • Lists are compared lexicographically by elements, if the elements at the same positions are comparable.

       If the ordering between two elements is not defined by the conditions above, i.e.  if the value of $a  or
       $b is not covered by any of the cases above or if they belong to different cases, a “bad value” exception
       is thrown.

       Examples:

              ~&gt; compare a b
              ▶ (num 1)
              ~&gt; compare b a
              ▶ (num -1)
              ~&gt; compare x x
              ▶ (num 0)
              ~&gt; compare (float64 10) (float64 1)
              ▶ (num 1)

       Beware that strings that look like numbers are treated as strings, not numbers.

       See also order.

   <b>constantly</b> <b>{#constantly}</b>
              constantly $value...

       Output a function that takes no arguments and outputs $values when called.  Examples:

              ~&gt; f=(constantly lorem ipsum)
              ~&gt; $f
              ▶ lorem
              ▶ ipsum

       The  above  example  is actually equivalent to simply f = { put lorem ipsum }; it is most useful when the
       argument is <b>not</b> a literal value, e.g.

              ~&gt; f = (constantly (uname))
              ~&gt; $f
              ▶ Darwin
              ~&gt; $f
              ▶ Darwin

       The above code only calls uname once, while if you do f = { put (uname) }, every time you invoke $f,  un‐
       ame will be called.

       Etymology: Clojure (https://clojuredocs.org/clojure.core/constantly).

   <b>continue</b> <b>{#continue}</b>
       Raises the special “continue” exception.  When raised inside a loop it is captured and causes the loop to
       begin its next iteration.

       Because  continue  raises an exception it can be caught by a try block.  If not caught, either implicitly
       by a loop or explicitly, it causes a failure like any other uncaught exception.

       See the discussion about flow commands and exceptions

       <b>Note</b>: You can create a continue function and it will shadow the builtin command.  If you do so you should
       explicitly invoke the builtin.  For example:

              ~&gt; use builtin
              ~&gt; fn continue { put 'continue'; builtin:continue; put 'should not appear' }
              ~&gt; for x [a b c] { put $x; continue; put 'unexpected' }
              ▶ a
              ▶ continue
              ▶ b
              ▶ continue
              ▶ c
              ▶ continue

   <b>count</b> <b>{#count}</b>
              count $input-list?

       Count the number of inputs.

       Examples:

              ~&gt; count lorem # count bytes in a string
              ▶ 5
              ~&gt; count [lorem ipsum]
              ▶ 2
              ~&gt; range 100 | count
              ▶ 100
              ~&gt; seq 100 | count
              ▶ 100

   <b>deprecate</b> <b>{#deprecate}</b>
              deprecate $msg

       Shows the given deprecation message to stderr.  If called from a function or module, also shows the  call
       site  of the function or import site of the module.  Does nothing if the combination of the call site and
       the message has been shown before.

              ~&gt; deprecate msg
              deprecation: msg
              ~&gt; fn f { deprecate msg }
              ~&gt; f
              deprecation: msg
              [tty 19], line 1: f
              ~&gt; exec
              ~&gt; deprecate msg
              deprecation: msg
              ~&gt; fn f { deprecate msg }
              ~&gt; f
              deprecation: msg
              [tty 3], line 1: f
              ~&gt; f # a different call site; shows deprecate message
              deprecation: msg
              [tty 4], line 1: f
              ~&gt; fn g { f }
              ~&gt; g
              deprecation: msg
              [tty 5], line 1: fn g { f }
              ~&gt; g # same call site, no more deprecation message

   <b>dir-history</b> <b>{#dir-history}</b>
              dir-history

       Return a list containing the interactive directory history.  Each element is a map with  two  keys:  path
       and score.  The list is sorted by descending score.

       Example:

              ~&gt; dir-history | take 1
              ▶ [&amp;path=/Users/foo/.elvish &amp;score=96.79928]

       See also edit:command-history.

   <b>dissoc</b> <b>{#dissoc}</b>
              dissoc $map $k

       Output  a  slightly  modified version of $map, with the key $k removed.  If $map does not contain $k as a
       key, the same map is returned.

              ~&gt; dissoc [&amp;foo=bar &amp;lorem=ipsum] foo
              ▶ [&amp;lorem=ipsum]
              ~&gt; dissoc [&amp;foo=bar &amp;lorem=ipsum] k
              ▶ [&amp;lorem=ipsum &amp;foo=bar]

       See also assoc.

   <b>drop</b> <b>{#drop}</b>
              drop $n $input-list?

       Drop the first $n elements of the input.  If $n is larger than the number of input elements,  the  entire
       input is dropped.

       Example:

              ~&gt; drop 2 [a b c d e]
              ▶ c
              ▶ d
              ▶ e
              ~&gt; use str
              ~&gt; str:split ' ' 'how are you?' | drop 1
              ▶ are
              ▶ 'you?'
              ~&gt; range 2 | drop 10

       Etymology: Haskell.

       See also take.

   <b>each</b> <b>{#each}</b>
              each $f $input-list?

       Call $f on all inputs.

       An exception raised from break is caught by each, and will cause it to terminate early.

       An exception raised from continue is swallowed and can be used to terminate a single iteration early.

       Examples:

              ~&gt; range 5 8 | each {|x| * $x $x }
              ▶ 25
              ▶ 36
              ▶ 49
              ~&gt; each {|x| put $x[:3] } [lorem ipsum]
              ▶ lor
              ▶ ips

       See also peach.

       Etymology:  Various  languages, as for each.  Happens to have the same name as the iteration construct of
       Factor (<a href="http://docs.factorcode.org/content/word-each">http://docs.factorcode.org/content/word-each</a>,sequences.html).

   <b>eawk</b> <b>{#eawk}</b>
              eawk $f $input-list?

       For each input, call $f with the input followed by all its fields.  A break command will  cause  eawk  to
       stop processing inputs.  A continue command will exit $f, but is ignored by eawk.

       It should behave the same as the following functions:

              fn eawk {|f @rest|
                each {|line|
                  @fields = (re:split '[ \t]+'
                  (re:replace '^[ \t]+|[ \t]+$' '' $line))
                  $f $line $@fields
                } $@rest
              }

       This command allows you to write code very similar to awk scripts using anonymous functions.  Example:

              ~&gt; echo ' lorem ipsum
              1 2' | awk '{ print $1 }'
              lorem
              1
              ~&gt; echo ' lorem ipsum
              1 2' | eawk {|line a b| put $a }
              ▶ lorem
              ▶ 1

   <b>echo</b> <b>{#echo}</b>
              echo &amp;sep=' ' $value...

       Print all arguments, joined by the sep option, and followed by a newline.

       Examples:

              ~&gt; echo Hello   elvish
              Hello elvish
              ~&gt; echo "Hello   elvish"
              Hello   elvish
              ~&gt; echo &amp;sep=, lorem ipsum
              lorem,ipsum

       Notes:  The  echo  builtin does not treat -e or -n specially.  For instance, echo -n just prints -n.  Use
       double-quoted strings to print special characters, and print to suppress the trailing newline.

       See also print.

       Etymology: Bourne sh.

   <b>eq</b> <b>{#eq}</b>
              eq $values...

       Determines whether all $values are equal.  Writes $true when given no or one argument.

       Two values are equal when they have the same type and value.

       For complex data structures like lists and maps, comparison is done recursively.  A pseudo-map  is  equal
       to another pseudo-map with the same internal type (which is not exposed to Elvish code now) and value.

              ~&gt; eq a a
              ▶ $true
              ~&gt; eq [a] [a]
              ▶ $true
              ~&gt; eq [&amp;k=v] [&amp;k=v]
              ▶ $true
              ~&gt; eq a [b]
              ▶ $false

       See also is and not-eq.

       Etymology: Perl (https://perldoc.perl.org/perlop.html#Equality-Operators).

   <b>eval</b> <b>{#eval}</b>
              eval $code &amp;ns=$nil &amp;on-end=$nil

       Evaluates  $code, which should be a string.  The evaluation happens in a new, restricted namespace, whose
       initial set of variables can be specified by the &amp;ns option.  After evaluation completes, the  new  name‐
       space is passed to the callback specified by &amp;on-end if it is not nil.

       The  namespace specified by &amp;ns is never modified; it will not be affected by the creation or deletion of
       variables by $code.  However, the values of the variables may be mutated by $code.

       If the &amp;ns option is $nil (the default), a temporary namespace built by amalgamating the local and upval‐
       ue scopes of the caller is used.

       If $code fails to parse or compile, the parse error or compilation error is raised as an exception.

       Basic examples that do not modify the namespace or any variable:

              ~&gt; eval 'put x'
              ▶ x
              ~&gt; x = foo
              ~&gt; eval 'put $x'
              ▶ foo
              ~&gt; ns = (ns [&amp;x=bar])
              ~&gt; eval &amp;ns=$ns 'put $x'
              ▶ bar

       Examples that modify existing variables:

              ~&gt; y = foo
              ~&gt; eval 'y = bar'
              ~&gt; put $y
              ▶ bar

       Examples that creates new variables and uses the callback to access it:

              ~&gt; eval 'z = lorem'
              ~&gt; put $z
              compilation error: variable $z not found
              [ttz 2], line 1: put $z
              ~&gt; saved-ns = $nil
              ~&gt; eval &amp;on-end={|ns| saved-ns = $ns } 'z = lorem'
              ~&gt; put $saved-ns[z]
              ▶ lorem

   <b>exact-num</b> <b>{#exact-num}</b>
              exact-num $string-or-number

       Coerces the argument to an exact number.  If the argument is infinity or NaN, an exception is thrown.

       If the argument is a string, it is converted to a typed number first.  If the argument is already an  ex‐
       act number, it is returned as is.

       Examples:

              ~&gt; exact-num (num 0.125)
              ▶ (num 1/8)
              ~&gt; exact-num 0.125
              ▶ (num 1/8)
              ~&gt; exact-num (num 1)
              ▶ (num 1)

       Beware  that  seemingly  simple fractions that can’t be represented precisely in binary can result in the
       denominator being a very large power of 2:

              ~&gt; exact-num 0.1
              ▶ (num 3602879701896397/36028797018963968)

   <b>exec</b> <b>{#exec}</b>
              exec $command? $args...

       Replace the Elvish process with an external $command, defaulting to elvish, passing the given  arguments.
       This decrements $E:SHLVL before starting the new process.

       This command always raises an exception on Windows with the message “not supported on Windows”.

   <b>exit</b> <b>{#exit}</b>
              exit $status?

       Exit the Elvish process with $status (defaulting to 0).

   <b>external</b> <b>{#external}</b>
              external $program

       Construct a callable value for the external program $program.  Example:

              ~&gt; x = (external man)
              ~&gt; $x ls # opens the manpage for ls

       See also has-external and search-external.

   <b>fail</b> <b>{#fail}</b>
              fail $v

       Throws an exception; $v may be any type.  If $v is already an exception, fail rethrows it.

              ~&gt; fail bad
              Exception: bad
              [tty 9], line 1: fail bad
              ~&gt; put ?(fail bad)
              ▶ ?(fail bad)
              ~&gt; fn f { fail bad }
              ~&gt; fail ?(f)
              Exception: bad
              Traceback:
                [tty 7], line 1:
                  fn f { fail bad }
                [tty 8], line 1:
                  fail ?(f)

   <b>float64</b> <b>{#float64}</b>
              float64 $string-or-number

       Constructs a floating-point number.

       This command is deprecated; use num instead.

   <b>from-json</b> <b>{#from-json}</b>
              from-json

       Takes  bytes  stdin,  parses  it as JSON and puts the result on structured stdout.  The input can contain
       multiple JSONs, and whitespace between them are ignored.

       Note that JSON’s only number type corresponds to Elvish’s floating-point number type, and is always  con‐
       sidered inexact.  It may be necessary to coerce JSON numbers to exact numbers using exact-num.

       Examples:

              ~&gt; echo '"a"' | from-json
              ▶ a
              ~&gt; echo '["lorem", "ipsum"]' | from-json
              ▶ [lorem ipsum]
              ~&gt; echo '{"lorem": "ipsum"}' | from-json
              ▶ [&amp;lorem=ipsum]
              ~&gt; # multiple JSONs running together
              echo '"a""b"["x"]' | from-json
              ▶ a
              ▶ b
              ▶ [x]
              ~&gt; # multiple JSONs separated by newlines
              echo '"a"
              {"k": "v"}' | from-json
              ▶ a
              ▶ [&amp;k=v]

       See also to-json.

   <b>from-lines</b> <b>{#from-lines}</b>
              from-lines

       Splits byte input into lines, and writes them to the value output.  Value input is ignored.

              ~&gt; { echo a; echo b } | from-lines
              ▶ a
              ▶ b
              ~&gt; { echo a; put b } | from-lines
              ▶ a

       See also from-terminated, read-upto and to-lines.

   <b>from-terminated</b> <b>{#from-terminated}</b>
              from-terminated $terminator

       Splits  byte input into lines at each $terminator character, and writes them to the value output.  If the
       byte input ends with $terminator, it is dropped.  Value input is ignored.

       The $terminator must be a single ASCII character such as "\x00" (NUL).

              ~&gt; { echo a; echo b } | from-terminated "\x00"
              ▶ "a\nb\n"
              ~&gt; print "a\x00b" | from-terminated "\x00"
              ▶ a
              ▶ b
              ~&gt; print "a\x00b\x00" | from-terminated "\x00"
              ▶ a
              ▶ b

       See also from-lines, read-upto and to-terminated.

   <b>-gc</b> <b>{#-gc}</b>
              -gc

       Force the Go garbage collector to run.

       This is only useful for debug purposes.

   <b>get-env</b> <b>{#get-env}</b>
              get-env $name

       Gets the value of an environment variable.  Throws an exception if the environment variable does not  ex‐
       ist.  Examples:

              ~&gt; get-env LANG
              ▶ zh_CN.UTF-8
              ~&gt; get-env NO_SUCH_ENV
              Exception: non-existent environment variable
              [tty], line 1: get-env NO_SUCH_ENV

       See also has-env, set-env and unset-env.

   <b>has-env</b> <b>{#has-env}</b>
              has-env $name

       Test whether an environment variable exists.  Examples:

              ~&gt; has-env PATH
              ▶ $true
              ~&gt; has-env NO_SUCH_ENV
              ▶ $false

       See also get-env, set-env and unset-env.

   <b>has-external</b> <b>{#has-external}</b>
              has-external $command

       Test whether $command names a valid external command.  Examples (your output might differ):

              ~&gt; has-external cat
              ▶ $true
              ~&gt; has-external lalala
              ▶ $false

       See also external and search-external.

   <b>has-key</b> <b>{#has-key}</b>
              has-key $container $key

       Determine whether $key is a key in $container.  A key could be a map key or an index on a list or string.
       This includes a range of indexes.

       Examples, maps:

              ~&gt; has-key [&amp;k1=v1 &amp;k2=v2] k1
              ▶ $true
              ~&gt; has-key [&amp;k1=v1 &amp;k2=v2] v1
              ▶ $false

       Examples, lists:

              ~&gt; has-key [v1 v2] 0
              ▶ $true
              ~&gt; has-key [v1 v2] 1
              ▶ $true
              ~&gt; has-key [v1 v2] 2
              ▶ $false
              ~&gt; has-key [v1 v2] 0:2
              ▶ $true
              ~&gt; has-key [v1 v2] 0:3
              ▶ $false

       Examples, strings:

              ~&gt; has-key ab 0
              ▶ $true
              ~&gt; has-key ab 1
              ▶ $true
              ~&gt; has-key ab 2
              ▶ $false
              ~&gt; has-key ab 0:2
              ▶ $true
              ~&gt; has-key ab 0:3
              ▶ $false

   <b>has-value</b> <b>{#has-value}</b>
              has-value $container $value

       Determine whether $value is a value in $container.

       Examples, maps:

              ~&gt; has-value [&amp;k1=v1 &amp;k2=v2] v1
              ▶ $true
              ~&gt; has-value [&amp;k1=v1 &amp;k2=v2] k1
              ▶ $false

       Examples, lists:

              ~&gt; has-value [v1 v2] v1
              ▶ $true
              ~&gt; has-value [v1 v2] k1
              ▶ $false

       Examples, strings:

              ~&gt; has-value ab b
              ▶ $true
              ~&gt; has-value ab c
              ▶ $false

   <b>-ifaddrs</b> <b>{#-ifaddrs}</b>
              -ifaddrs

       Output all IP addresses of the current host.

       This should be part of a networking module instead of the builtin module.

   <b>is</b> <b>{#is}</b>
              is $values...

       Determine whether all $values have the same identity.  Writes $true when given no or one argument.

       The definition of identity is subject to change.  Do not rely on its behavior.

              ~&gt; is a a
              ▶ $true
              ~&gt; is a b
              ▶ $false
              ~&gt; is [] []
              ▶ $true
              ~&gt; is [a] [a]
              ▶ $false

       See also eq.

       Etymology: Python (https://docs.python.org/3/reference/expressions.html#is).

   <b>keys</b> <b>{#keys}</b>
              keys $map

       Put all keys of $map on the structured stdout.

       Example:

              ~&gt; keys [&amp;a=foo &amp;b=bar &amp;c=baz]
              ▶ a
              ▶ c
              ▶ b

       Note that there is no guaranteed order for the keys of a map.

   <b>kind-of</b> <b>{#kind-of}</b>
              kind-of $value...

       Output the kinds of $values.  Example:

              ~&gt; kind-of lorem [] [&amp;]
              ▶ string
              ▶ list
              ▶ map

       The terminology and definition of “kind” is subject to change.

   <b>-log</b> <b>{#-log}</b>
              -log $filename

       Direct internal debug logs to the named file.

       This is only useful for debug purposes.

   <b>make-map</b> <b>{#make-map}</b>
              make-map $input?

       Outputs  a  map from an input consisting of containers with two elements.  The first element of each con‐
       tainer is used as the key, and the second element is used as the value.

       If the same key appears multiple times, the last value is used.

       Examples:

              ~&gt; make-map [[k v]]
              ▶ [&amp;k=v]
              ~&gt; make-map [[k v1] [k v2]]
              ▶ [&amp;k=v2]
              ~&gt; put [k1 v1] [k2 v2] | make-map
              ▶ [&amp;k1=v1 &amp;k2=v2]
              ~&gt; put aA bB | make-map
              ▶ [&amp;a=A &amp;b=B]

   <b>nop</b> <b>{#nop}</b>
              nop &amp;any-opt= $value...

       Accepts arbitrary arguments and options and does exactly nothing.

       Examples:

              ~&gt; nop
              ~&gt; nop a b c
              ~&gt; nop &amp;k=v

       Etymology: Various languages, in  particular  NOP  in  assembly  languages  (https://en.wikipedia.org/wi‐
       ki/NOP).

   <b>not</b> <b>{#not}</b>
              not $value

       Boolean negation.  Examples:

              ~&gt; not $true
              ▶ $false
              ~&gt; not $false
              ▶ $true
              ~&gt; not $ok
              ▶ $false
              ~&gt; not ?(fail error)
              ▶ $true

       <b>Note</b>:  The related logical commands and and or are implemented as special commands instead, since they do
       not always evaluate all their arguments.  The not command always evaluates its only argument, and is thus
       a normal command.

       See also bool.

   <b>not-eq</b> <b>{#not-eq}</b>
              not-eq $values...

       Determines whether every adjacent pair of $values are not equal.  Note that  this  does  not  imply  that
       $values are all distinct.  Examples:

              ~&gt; not-eq 1 2 3
              ▶ $true
              ~&gt; not-eq 1 2 1
              ▶ $true
              ~&gt; not-eq 1 1 2
              ▶ $false

       See also eq.

   <b>ns</b> <b>{#ns}</b>
              ns $map

       Constructs a namespace from $map, using the keys as variable names and the values as their values.  Exam‐
       ples:

              ~&gt; n = (ns [&amp;name=value])
              ~&gt; put $n[name]
              ▶ value
              ~&gt; n: = (ns [&amp;name=value])
              ~&gt; put $n:name
              ▶ value

   <b>num</b> <b>{#num}</b>
              num $string-or-number

       Constructs a typed number.

       If  the argument is a string, this command outputs the typed number the argument represents, or raises an
       exception if the argument is not a valid representation of a number.  If the argument is already a  typed
       number, this command outputs it as is.

       This command is usually not needed for working with numbers; see the discussion of numeric commands.

       Examples:

              ~&gt; num 10
              ▶ (num 10)
              ~&gt; num 0x10
              ▶ (num 16)
              ~&gt; num 1/12
              ▶ (num 1/12)
              ~&gt; num 3.14
              ▶ (num 3.14)
              ~&gt; num (num 10)
              ▶ (num 10)

   <b>one</b> <b>{#one}</b>
              one $input-list?

       Passes inputs to outputs, if there is only a single one.  Otherwise raises an exception.

       This  function  can be used in a similar way to all, but is a better choice when you expect that there is
       exactly one output:

       See also all.

   <b>only-bytes</b> <b>{#only-bytes}</b>
              only-bytes

       Passes byte input to output, and discards value inputs.

       Example:

              ~&gt; { put value; echo bytes } | only-bytes
              bytes

   <b>only-values</b> <b>{#only-values}</b>
              only-values

       Passes value input to output, and discards byte inputs.

       Example:

              ~&gt; { put value; echo bytes } | only-values
              ▶ value

   <b>order</b> <b>{#order}</b>
              order &amp;reverse=$false $less-than=$nil $inputs?

       Outputs  the  input  values  sorted  in  ascending  order.   The  sort  is  guaranteed   to   be   stable
       (https://en.wikipedia.org/wiki/Sorting_algorithm#Stability).

       The &amp;reverse option, if true, reverses the order of output.

       The  &amp;less-than  option, if given, establishes the ordering of the elements.  Its value should be a func‐
       tion that takes two arguments and outputs a single boolean indicating whether the first argument is  less
       than the second argument.  If the function throws an exception, order rethrows the exception without out‐
       putting any value.

       If  &amp;less-than  has value $nil (the default if not set), it is equivalent to {|a b| eq -1 (compare $a $b)
       }.

       Examples:

              ~&gt; put foo bar ipsum | order
              ▶ bar
              ▶ foo
              ▶ ipsum
              ~&gt; order [(float64 10) (float64 1) (float64 5)]
              ▶ (float64 1)
              ▶ (float64 5)
              ▶ (float64 10)
              ~&gt; order [[a b] [a] [b b] [a c]]
              ▶ [a]
              ▶ [a b]
              ▶ [a c]
              ▶ [b b]
              ~&gt; order &amp;reverse [a c b]
              ▶ c
              ▶ b
              ▶ a
              ~&gt; order &amp;less-than={|a b| eq $a x } [l x o r x e x m]
              ▶ x
              ▶ x
              ▶ x
              ▶ l
              ▶ o
              ▶ r
              ▶ e
              ▶ m

       Beware that strings that look like numbers are treated as strings, not numbers.  To sort strings as  num‐
       bers, use an explicit &amp;less-than option:

              ~&gt; order [5 1 10]
              ▶ 1
              ▶ 10
              ▶ 5
              ~&gt; order &amp;less-than={|a b| &lt; $a $b } [5 1 10]
              ▶ 1
              ▶ 5
              ▶ 10

       See also compare.

   <b>peach</b> <b>{#peach}</b>
              peach $f $input-list?

       Calls $f on all inputs, possibly in parallel.

       Like each, an exception raised from break will cause peach to terminate early.  However due to the paral‐
       lel nature of peach, the exact time of termination is non-deterministic and not even guaranteed.

       An exception raised from continue is swallowed and can be used to terminate a single iteration early.

       Example (your output will differ):

              ~&gt; range 1 10 | peach {|x| + $x 10 }
              ▶ (num 12)
              ▶ (num 13)
              ▶ (num 11)
              ▶ (num 16)
              ▶ (num 18)
              ▶ (num 14)
              ▶ (num 17)
              ▶ (num 15)
              ▶ (num 19)
              ~&gt; range 1 101 |
                 peach {|x| if (== 50 $x) { break } else { put $x } } |
                 + (all) # 1+...+49 = 1225; 1+...+100 = 5050
              ▶ (num 1328)

       This  command is intended for homogeneous processing of possibly unbound data.  If you need to do a fixed
       number of heterogeneous things in parallel, use run-parallel.

       See also each and run-parallel.

   <b>pprint</b> <b>{#pprint}</b>
              pprint $value...

       Pretty-print representations of Elvish values.  Examples:

              ~&gt; pprint [foo bar]
              [
              foo
              bar
              ]
              ~&gt; pprint [&amp;k1=v1 &amp;k2=v2]
              [
              &amp;k2=
              v2
              &amp;k1=
              v1
              ]

       The output format is subject to change.

       See also repr.

   <b>print</b> <b>{#print}</b>
              print &amp;sep=' ' $value...

       Like echo, just without the newline.

       See also echo.

       Etymology: Various languages, in particular Perl (https://perldoc.perl.org/functions/print.html) and  zsh
       (<a href="http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html">http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html</a>),  whose prints do not print a trail‐
       ing newline.

   <b>printf</b> <b>{#printf}</b>
              printf $template $value...

       Prints values to the byte stream according to a template.  If you need to inject the output into the val‐
       ue stream use this pattern: printf .... | slurp.  That ensures that any newlines in the output of  printf
       do  not cause its output to be broken into multiple values, thus eliminating the newlines, which will oc‐
       cur if you do put (printf ....).

       Like print, this command does not add an implicit newline; include an explicit  "\n"  in  the  formatting
       template instead.  For example, printf "%.1f\n" (/ 10.0 3).

       See  Go’s  fmt  (https://golang.org/pkg/fmt/#hdr-Printing) package for details about the formatting verbs
       and the various flags that modify the default behavior, such as padding and justification.

       Unlike Go, each formatting verb has a single associated internal type, and accepts any argument that  can
       reasonably be converted to that type:

       • The verbs %s, %q and %v convert the corresponding argument to a string in different ways:

         • %s uses to-string to convert a value to string.

         • %q uses repr to convert a value to string.

         • %v is equivalent to %s, and %#v is equivalent to %q.

       • The  verb  %t  first  convert  the corresponding argument to a boolean using bool, and then uses its Go
         counterpart to format the boolean.

       • The verbs %b, %c, %d, %o, %O, %x, %X and %U first convert the corresponding argument to an integer  us‐
         ing an internal algorithm, and use their Go counterparts to format the integer.

       • The verbs %e, %E, %f, %F, %g and %G first convert the corresponding argument to a floating-point number
         using float64, and then use their Go counterparts to format the number.

       The special verb %% prints a literal % and consumes no argument.

       Verbs not documented above are not supported.

       Examples:

              ~&gt; printf "%10s %.2f\n" Pi $math:pi
                      Pi 3.14
              ~&gt; printf "%-10s %.2f %s\n" Pi $math:pi $math:pi
              Pi         3.14 3.141592653589793
              ~&gt; printf "%d\n" 0b11100111
              231
              ~&gt; printf "%08b\n" 231
              11100111
              ~&gt; printf "list is: %q\n" [foo bar 'foo bar']
              list is: [foo bar 'foo bar']

       <b>Note</b>:      Compared      to      the     POSIX     printf     command     (https://pubs.opengroup.org/on‐
       linepubs/007908799/xcu/printf.html) found in other shells, there are 3 key differences:

       • The behavior of the formatting verbs are based on Go’s fmt  (https://golang.org/pkg/fmt/)  package  in‐
         stead of the POSIX specification.

       • The  number  of arguments after the formatting template must match the number of formatting verbs.  The
         POSIX command will repeat the template string to consume excess values; this command does not have that
         behavior.

       • This command does not interpret escape sequences such as \n; just use double-quoted strings.

       See also print, echo, pprint and repr.

   <b>put</b> <b>{#put}</b>
              put $value...

       Takes arbitrary arguments and write them to the structured stdout.

       Examples:

              ~&gt; put a
              ▶ a
              ~&gt; put lorem ipsum [a b] { ls }
              ▶ lorem
              ▶ ipsum
              ▶ [a b]
              ▶ &lt;closure 0xc4202607e0&gt;

       <b>Note</b>: It is almost never necessary to use put (...)  - just write the ... part.  For example, put  (eq  a
       b) is the equivalent to just eq a b.

       Etymology:    Various   languages,   in   particular   C   (https://manpages.debian.org/stretch/manpages-
       dev/puts.3.en.html) and Ruby (https://ruby-doc.org/core-2.2.2/IO.html#method-i-puts) as puts.

   <b>rand</b> <b>{#rand}</b>
              rand

       Output a pseudo-random number in the interval [0, 1).  Example:

              ~&gt; rand
              ▶ 0.17843564133528436

   <b>randint</b> <b>{#randint}</b>
              randint $low? $high

       Output a pseudo-random integer N such that $low &lt;= N &lt; $high.  If not given, $low defaults to  0.   Exam‐
       ples:

              ~&gt; # Emulate dice
              randint 1 7
              ▶ 6

   <b>range</b> <b>{#range}</b>
              range &amp;step $start=0 $end

       Outputs numbers, starting from $start and ending before $end, using &amp;step as the increment.

       • If $start &lt;= $end, &amp;step defaults to 1, and range outputs values as long as they are smaller than $end.
         An exception is thrown if &amp;step is given a negative value.

       • If $start &gt; $end, &amp;step defaults to -1, and range outputs values as long as they are greater than $end.
         An exception is thrown if &amp;step is given a positive value.

       As  a  special  case, if the outputs are floating point numbers, range also terminates if the values stop
       changing.

       This command is exactness-preserving.

       Examples:

              ~&gt; range 4
              ▶ (num 0)
              ▶ (num 1)
              ▶ (num 2)
              ▶ (num 3)
              ~&gt; range 4 0
              ▶ (num 4)
              ▶ (num 3)
              ▶ (num 2)
              ▶ (num 1)
              ~&gt; range -3 3 &amp;step=2
              ▶ (num -3)
              ▶ (num -1)
              ▶ (num 1)
              ~&gt; range 3 -3 &amp;step=-2
              ▶ (num 3)
              ▶ (num 1)
              ▶ (num -1)
              ~&gt; range (- (math:pow 2 53) 1) +inf
              ▶ (num 9007199254740991.0)
              ▶ (num 9007199254740992.0)

       When using floating-point numbers, beware that numerical errors can result in an incorrect number of out‐
       puts:

              ~&gt; range 0.9 &amp;step=0.3
              ▶ (num 0.0)
              ▶ (num 0.3)
              ▶ (num 0.6)
              ▶ (num 0.8999999999999999)

       Avoid this problem by using exact rationals:

              ~&gt; range 9/10 &amp;step=3/10
              ▶ (num 0)
              ▶ (num 3/10)
              ▶ (num 3/5)

       Etymology: Python (https://docs.python.org/3/library/functions.html#func-range).

   <b>read-line</b> <b>{#read-line}</b>
              read-line

       Reads a single line from byte input, and writes the line to the value output, stripping the line  ending.
       A line can end with "\r\n", "\n", or end of file.  Examples:

              ~&gt; print line | read-line
              ▶ line
              ~&gt; print "line\n" | read-line
              ▶ line
              ~&gt; print "line\r\n" | read-line
              ▶ line
              ~&gt; print "line-with-extra-cr\r\r\n" | read-line
              ▶ "line-with-extra-cr\r"

   <b>read-upto</b> <b>{#read-upto}</b>
              read-upto $terminator

       Reads  byte input until $terminator or end-of-file is encountered.  It outputs the part of the input read
       as a string value.  The output contains the trailing $terminator, unless read-upto terminated at  end-of-
       file.

       The $terminator must be a single ASCII character such as "\x00" (NUL).

       Examples:

              ~&gt; echo "a,b,c" | read-upto ","
              ▶ 'a,'
              ~&gt; echo "foo\nbar" | read-upto "\n"
              ▶ "foo\n"
              ~&gt; echo "a.elv\x00b.elv" | read-upto "\x00"
              ▶ "a.elv\x00"
              ~&gt; print "foobar" | read-upto "\n"
              ▶ foobar

   <b>repeat</b> <b>{#repeat}</b>
              repeat $n $value

       Output $value for $n times.  Example:

              ~&gt; repeat 0 lorem
              ~&gt; repeat 4 NAN
              ▶ NAN
              ▶ NAN
              ▶ NAN
              ▶ NAN

       Etymology: Clojure (https://clojuredocs.org/clojure.core/repeat).

   <b>repr</b> <b>{#repr}</b>
              repr $value...

       Writes representation of $values, separated by space and followed by a newline.  Example:

              ~&gt; repr [foo 'lorem ipsum'] "aha\n"
              [foo 'lorem ipsum'] "aha\n"

       See also pprint.

       Etymology: Python (https://docs.python.org/3/library/functions.html#repr).

   <b>resolve</b> <b>{#resolve}</b>
              resolve $command

       Output  what $command resolves to in symbolic form.  Command resolution is described in the language ref‐
       erence.

       Example:

              ~&gt; resolve echo
              ▶ &lt;builtin echo&gt;
              ~&gt; fn f { }
              ~&gt; resolve f
              ▶ &lt;closure 0xc4201c24d0&gt;
              ~&gt; resolve cat
              ▶ &lt;external cat&gt;

   <b>return</b> <b>{#return}</b>
       Raises the special “return” exception.  When raised inside a named function (defined by the  fn  keyword)
       it  is  captured by the function and causes the function to terminate.  It is not captured by an ordinary
       anonymous function.

       Because return raises an exception it can be caught by a try block.  If not caught, either implicitly  by
       a named function or explicitly, it causes a failure like any other uncaught exception.

       See the discussion about flow commands and exceptions

       <b>Note</b>: If you want to shadow the builtin return function with a local wrapper, do not define it with fn as
       fn swallows the special exception raised by return.  Consider this example:

              ~&gt; use builtin
              ~&gt; fn return { put return; builtin:return }
              ~&gt; fn test-return { put before; return; put after }
              ~&gt; test-return
              ▶ before
              ▶ return
              ▶ after

       Instead, shadow the function by directly assigning to return~:

              ~&gt; use builtin
              ~&gt; var return~ = { put return; builtin:return }
              ~&gt; fn test-return { put before; return; put after }
              ~&gt; test-return
              ▶ before
              ▶ return

   <b>run-parallel</b> <b>{#run-parallel}</b>
              run-parallel $callable ...

       Run several callables in parallel, and wait for all of them to finish.

       If  one  or more callables throw exceptions, the other callables continue running, and a composite excep‐
       tion is thrown when all callables finish execution.

       The behavior of run-parallel is consistent with the behavior of pipelines, except that it does  not  per‐
       form any redirections.

       Here is an example that lets you pipe the stdout and stderr of a command to two different commands in or‐
       der to independently capture the output of each byte stream:

              ~&gt; fn capture {|f|
                   var pout = (file:pipe)
                   var perr = (file:pipe)
                   var out err
                   run-parallel {
                     $f &gt; $pout[w] 2&gt; $perr[w]
                     file:close $pout[w]
                     file:close $perr[w]
                   } {
                     set out = (slurp &lt; $pout[r])
                     file:close $pout[r]
                   } {
                     set err = (slurp &lt; $perr[r])
                     file:close $perr[r]
                   }
                   put $out $err
                 }
              ~&gt; capture { echo stdout-test; echo stderr-test &gt;&amp;2 }
              ▶ "stdout-test\n"
              ▶ "stderr-test\n"

       This command is intended for doing a fixed number of heterogeneous things in parallel.  If you need homo‐
       geneous parallel processing of possibly unbound data, use peach instead.

       See also peach.

   <b>search-external</b> <b>{#search-external}</b>
              search-external $command

       Output the full path of the external $command.  Throws an exception when not found.  Example (your output
       might vary):

              ~&gt; search-external cat
              ▶ <a href="file:/bin/cat">/bin/cat</a>

       See also external and has-external.

   <b>set-env</b> <b>{#set-env}</b>
              set-env $name $value

       Sets an environment variable to the given value.  Example:

              ~&gt; set-env X foobar
              ~&gt; put $E:X
              ▶ foobar

       See also get-env, has-env and unset-env.

   <b>show</b> <b>{#show}</b>
              show $e

       Shows the value to the output, which is assumed to be a VT-100-compatible terminal.

       Currently,  the  only  type of value that can be showed is exceptions, but this will likely expand in fu‐
       ture.

       Example:

              ~&gt; e = ?(fail lorem-ipsum)
              ~&gt; show $e
              Exception: lorem-ipsum
              [tty 3], line 1: e = ?(fail lorem-ipsum)

   <b>sleep</b> <b>{#sleep}</b>
              sleep $duration

       Pauses for at least the specified duration.  The actual pause duration depends on the system.

       This only affects the current Elvish context.  It does not affect any other contexts that might  be  exe‐
       cuting in parallel as a consequence of a command such as peach.

       A  duration can be a simple number (with optional fractional value) without an explicit unit suffix, with
       an implicit unit of seconds.

       A duration can also be a string written as a sequence of decimal numbers, each  with  optional  fraction,
       plus  a  unit  suffix.   For  example, “300ms”, “1.5h” or “1h45m7s”.  Valid time units are “ns”, “us” (or
       “µs”), “ms”, “s”, “m”, “h”.

       Passing a negative duration causes an exception; this is different from the typical BSD or GNU sleep com‐
       mand that silently exits with a success status without pausing when given a negative duration.

       See the Go documentation (https://golang.org/pkg/time/#ParseDuration) for more information about how  du‐
       rations are parsed.

       Examples:

              ~&gt; sleep 0.1    # sleeps 0.1 seconds
              ~&gt; sleep 100ms  # sleeps 0.1 seconds
              ~&gt; sleep 1.5m   # sleeps 1.5 minutes
              ~&gt; sleep 1m30s  # sleeps 1.5 minutes
              ~&gt; sleep -1
              Exception: sleep duration must be &gt;= zero
              [tty 8], line 1: sleep -1

   <b>slurp</b> <b>{#slurp}</b>
              slurp

       Reads bytes input into a single string, and put this string on structured stdout.

       Example:

              ~&gt; echo "a\nb" | slurp
              ▶ "a\nb\n"

       Etymology: Perl, as File::Slurp (<a href="http://search.cpan.org/~uri/File-Slurp-9999.19/lib/File/Slurp.pm">http://search.cpan.org/~uri/File-Slurp-9999.19/lib/File/Slurp.pm</a>).

   <b>src</b> <b>{#src}</b>
              src

       Output  a map-like value describing the current source being evaluated.  The value contains the following
       fields:

       • name, a unique name of the current source.  If the source originates from a file, it is the  full  path
         of the file.

       • code, the full body of the current source.

       • is-file, whether the source originates from a file.

       Examples:

              ~&gt; put (src)[name code is-file]
              ▶ '[tty]'
              ▶ 'put (src)[name code is-file]'
              ▶ $false
              ~&gt; echo 'put (src)[name code is-file]' &gt; show-src.elv
              ~&gt; elvish show-src.elv
              ▶ /home/elf/show-src.elv
              ▶ "put (src)[name code is-file]\n"
              ▶ $true

       Note:  this  builtin  always returns information of the source of the function calling src.  Consider the
       following example:

              ~&gt; echo 'fn show { put (src)[name] }' &gt; <a href="file:~/.elvish/lib/src-fsutil.elv">~/.elvish/lib/src-fsutil.elv</a>
              ~&gt; use src-util
              ~&gt; src-util:show
              ▶ /home/elf/.elvish/lib/src-fsutil.elv

   <b>-stack</b> <b>{#-stack}</b>
              -stack

       Print a stack trace.

       This is only useful for debug purposes.

   <b>styled</b> <b>{#styled}</b>
              styled $object $style-transformer...

       Construct a styled text by applying the supplied transformers to the supplied object.  $object can be ei‐
       ther a string, a styled segment (see below), a styled text or an  arbitrary  concatenation  of  them.   A
       $style-transformer is either:

       • The name of a builtin style transformer, which may be one of the following:

         • One  of  the  attribute  names bold, dim, italic, underlined, blink or inverse for setting the corre‐
           sponding attribute.

         • An attribute name prefixed by no- for unsetting the attribute.

         • An attribute name prefixed by toggle- for toggling the attribute between set and unset.

       • A color name for setting the text color, which may be one of the following:

         • One of the 8 basic ANSI colors: black, red, green, yellow, blue, magenta, cyan and white.

         • The bright variant of the 8 basic ANSI colors, with a bright- prefix.

         • Any color from the xterm 256-color palette, as colorX (such as color12).

         • A 24-bit RGB color written as #RRGGBB such as '#778899'.

           <b>Note</b>: You need to quote such  values  since  an  unquoted  #  char  introduces  a  comment.   So  use
           'bg-#778899'  not bg-#778899.  If you omit the quotes the text after the # char is ignored which will
           result in an error or unexpected behavior.

       • A color name prefixed by bg- to set the background color.

       • A color name prefixed by fg- to set the foreground color.  This has the same effect as  specifying  the
         color name without the fg- prefix.

       • A lambda that receives a styled segment as the only argument and returns a single styled segment.

       • A function with the same properties as the lambda (provided via the $transformer~ syntax).

       When a styled text is converted to a string the corresponding ANSI SGR code (https://en.wikipedia.org/wi‐
       ki/ANSI_escape_code#SGR_.28Select_Graphic_Rendition.29_parameters) is built to render the style.

       A  styled  text is nothing more than a wrapper around a list of styled segments.  They can be accessed by
       indexing into it.

              s = (styled abc red)(styled def green)
              put $s[0] $s[1]

   <b>styled-segment</b> <b>{#styled-segment}</b>
              styled-segment $object &amp;fg-color=default &amp;bg-color=default &amp;bold=$false &amp;dim=$false &amp;italic=$false &amp;underlined=$false &amp;blink=$false &amp;inverse=$false

       Constructs a styled segment and is a helper function for styled transformers.  $object  can  be  a  plain
       string, a styled segment or a concatenation thereof.  Probably the only reason to use it is to build cus‐
       tom style transformers:

              fn my-awesome-style-transformer {|seg| styled-segment $seg &amp;bold=(not $seg[dim]) &amp;dim=(not $seg[italic]) &amp;italic=$seg[bold] }
              styled abc $my-awesome-style-transformer~

       As  just  seen the properties of styled segments can be inspected by indexing into it.  Valid indices are
       the same as the options to styled-segment plus text.

              s = (styled-segment abc &amp;bold)
              put $s[text]
              put $s[fg-color]
              put $s[bold]

   <b>take</b> <b>{#take}</b>
              take $n $input-list?

       Retain the first $n input elements.  If $n is larger than the number of input elements, the entire  input
       is retained.  Examples:

              ~&gt; take 3 [a b c d e]
              ▶ a
              ▶ b
              ▶ c
              ~&gt; use str
              ~&gt; str:split ' ' 'how are you?' | take 1
              ▶ how
              ~&gt; range 2 | take 10
              ▶ 0
              ▶ 1

       Etymology: Haskell.

   <b>tilde-abbr</b> <b>{#tilde-abbr}</b>
              tilde-abbr $path

       If $path represents a path under the home directory, replace the home directory with ~.  Examples:

              ~&gt; echo $E:HOME
              /Users/foo
              ~&gt; tilde-abbr /Users/foo
              ▶ '~'
              ~&gt; tilde-abbr /Users/foobar
              ▶ /Users/foobar
              ~&gt; tilde-abbr /Users/foo/a/b
              ▶ '<a href="file:~/a/b">~/a/b</a>'

   <b>time</b> <b>{#time}</b>
              time &amp;on-end=$nil $callable

       Runs  the  callable,  and  call $on-end with the duration it took, as a number in seconds.  If $on-end is
       $nil (the default), prints the duration in human-readable form.

       If $callable throws an exception, the exception is propagated after the on-end  or  default  printing  is
       done.

       If $on-end throws an exception, it is propagated, unless $callable has already thrown an exception.

       Example:

              ~&gt; time { sleep 1 }
              1.006060647s
              ~&gt; time { sleep 0.01 }
              1.288977ms
              ~&gt; t = ''
              ~&gt; time &amp;on-end={|x| t = $x } { sleep 1 }
              ~&gt; put $t
              ▶ (float64 1.000925004)
              ~&gt; time &amp;on-end={|x| t = $x } { sleep 0.01 }
              ~&gt; put $t
              ▶ (float64 0.011030208)

   <b>to-json</b> <b>{#to-json}</b>
              to-json

       Takes structured stdin, convert it to JSON and puts the result on bytes stdout.

              ~&gt; put a | to-json
              "a"
              ~&gt; put [lorem ipsum] | to-json
              ["lorem","ipsum"]
              ~&gt; put [&amp;lorem=ipsum] | to-json
              {"lorem":"ipsum"}

       See also from-json.

   <b>to-lines</b> <b>{#to-lines}</b>
              to-lines $input?

       Writes each value input to a separate line in the byte output.  Byte input is ignored.

              ~&gt; put a b | to-lines
              a
              b
              ~&gt; to-lines [a b]
              a
              b
              ~&gt; { put a; echo b } | to-lines
              b
              a

       See also from-lines and to-terminated.

   <b>to-string</b> <b>{#to-string}</b>
              to-string $value...

       Convert arguments to string values.

              ~&gt; to-string foo [a] [&amp;k=v]
              ▶ foo
              ▶ '[a]'
              ▶ '[&amp;k=v]'

   <b>to-terminated</b> <b>{#to-terminated}</b>
              to-terminated $terminator $input?

       Writes  each  value  input to the byte output with the specified terminator character.  Byte input is ig‐
       nored.  This behavior is useful, for example, when feeding output into a program that accepts NUL  termi‐
       nated lines to avoid ambiguities if the values contains newline characters.

       The $terminator must be a single ASCII character such as "\x00" (NUL).

              ~&gt; put a b | to-terminated "\x00" | slurp
              ▶ "a\x00b\x00"
              ~&gt; to-terminated "\x00" [a b] | slurp
              ▶ "a\x00b\x00"

       See also from-terminated and to-lines.

   <b>unset-env</b> <b>{#unset-env}</b>
              unset-env $name

       Unset an environment variable.  Example:

              ~&gt; E:X = foo
              ~&gt; unset-env X
              ~&gt; has-env X
              ▶ $false
              ~&gt; put $E:X
              ▶ ''

       See also has-env, get-env and set-env.

   <b>use-mod</b> <b>{#use-mod}</b>
              use-mod $use-spec

       Imports a module, and outputs the namespace for the module.

       Most code should use the use special command instead.

       Examples:

              ~&gt; echo 'x = value' &gt; a.elv
              ~&gt; put (use-mod ./a)[x]
              ▶ value

   <b>wcswidth</b> <b>{#wcswidth}</b>
              wcswidth $string

       Output the width of $string when displayed on the terminal.  Examples:

              ~&gt; wcswidth a
              ▶ 1
              ~&gt; wcswidth lorem
              ▶ 5
              ~&gt; wcswidth 你好，世界
              ▶ 10

Elvish 0.17.0                                     Nov 18, 2024                                 <u><a href="../man7/elvish-builtin.7.html">elvish-builtin</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>