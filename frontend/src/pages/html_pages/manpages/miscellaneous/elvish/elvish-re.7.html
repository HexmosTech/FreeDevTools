<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The  re:  module  wraps  Go’s  regexp  package.  See the Go’s doc for supported regular expression syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/elvish">elvish_0.17.0-1ubuntu0.1_amd64</a> <br><br><pre>
</pre><h4><b>Introduction</b></h4><pre>
       The  re:  module  wraps  Go’s  regexp  package.  See the Go’s doc for supported regular expression syntax
       (https://godoc.org/regexp/syntax).

       Function usages notations follow the same convention as the builtin module doc.

       The following options are supported by multiple functions in this module:

       • &amp;posix=$false: Use POSIX ERE syntax.  See also doc (<a href="http://godoc.org/regexp">http://godoc.org/regexp</a>#CompilePOSIX) in  Go  pack‐
         age.

       • &amp;longest=$false:  Prefer leftmost-longest match.  See also doc (<a href="http://godoc.org/regexp">http://godoc.org/regexp</a>#Regexp.Longest)
         in Go package.

       • &amp;max=-1: If non-negative, limits the maximum number of results.

</pre><h4><b>Functions</b></h4><pre>
   <b>re:find</b> <b>{#re:find}</b>
              re:find &amp;posix=$false &amp;longest=$false &amp;max=-1 $pattern $source

       Find all matches of $pattern in $source.

       Each match is represented by a map-like value $m; $m[text], $m[start] and $m[end] are the text, start and
       end positions (as byte indices into $source) of the match; $m[groups] is a list of submatches for capture
       groups in the pattern.  A submatch has a similar structure to a match, except that it  does  not  have  a
       group key.  The entire pattern is an implicit capture group, and it always appears first.

       Examples:

              ~&gt; re:find . ab
              ▶ [&amp;text=a &amp;start=0 &amp;end=1 &amp;groups=[[&amp;text=a &amp;start=0 &amp;end=1]]]
              ▶ [&amp;text=b &amp;start=1 &amp;end=2 &amp;groups=[[&amp;text=b &amp;start=1 &amp;end=2]]]
              ~&gt; re:find '[A-Z]([0-9])' 'A1 B2'
              ▶ [&amp;text=A1 &amp;start=0 &amp;end=2 &amp;groups=[[&amp;text=A1 &amp;start=0 &amp;end=2] [&amp;text=1 &amp;start=1 &amp;end=2]]]
              ▶ [&amp;text=B2 &amp;start=3 &amp;end=5 &amp;groups=[[&amp;text=B2 &amp;start=3 &amp;end=5] [&amp;text=2 &amp;start=4 &amp;end=5]]]

   <b>re:match</b> <b>{#re:match}</b>
              re:match &amp;posix=$false $pattern $source

       Determine whether $pattern matches $source.  The pattern is not anchored.  Examples:

              ~&gt; re:match . xyz
              ▶ $true
              ~&gt; re:match . ''
              ▶ $false
              ~&gt; re:match '[a-z]' A
              ▶ $false

   <b>re:quote</b> <b>{#re:quote}</b>
              re:quote $string

       Quote $string for use in a pattern.  Examples:

              ~&gt; re:quote a.txt
              ▶ a\.txt
              ~&gt; re:quote '(*)'
              ▶ '\(\*\)'

   <b>re:replace</b> <b>{#re:replace}</b>
              re:replace &amp;posix=$false &amp;longest=$false &amp;literal=$false $pattern $repl $source

       Replace all occurrences of $pattern in $source with $repl.

       The replacement $repl can be any of the following:

       • A  string-typed  replacement template.  The template can use $name or ${name} patterns to refer to cap‐
         ture groups, where name consists of letters, digits and underscores.  A purely numeric patterns like $1
         refers to the capture group with the corresponding index; other names refer  to  capture  groups  named
         with the (?P&lt;name&gt;...)) syntax.

         In  the  $name form, the name is taken to be as long as possible; $1 is equivalent to ${1x}, not ${1}x;
         $10 is equivalent to ${10}, not ${1}0.

         To insert a literal $, use $$.

       • A function that takes a string argument and outputs a string.  For each match, the function  is  called
         with the content of the match, and its output is used as the replacement.

       If $literal is true, $repl must be a string and is treated literally instead of as a pattern.

       Example:

              ~&gt; re:replace '(ba|z)sh' '${1}SH' 'bash and zsh'
              ▶ 'baSH and zSH'
              ~&gt; re:replace '(ba|z)sh' elvish 'bash and zsh rock'
              ▶ 'elvish and elvish rock'
              ~&gt; re:replace '(ba|z)sh' {|x| put [&amp;bash=BaSh &amp;zsh=ZsH][$x] } 'bash and zsh'
              ▶ 'BaSh and ZsH'

   <b>re:split</b> <b>{#re:split}</b>
              re:split &amp;posix=$false &amp;longest=$false &amp;max=-1 $pattern $source

       Split $source, using $pattern as separators.  Examples:

              ~&gt; re:split : <a href="file:/usr/sbin">/usr/sbin</a>:<a href="file:/usr/bin">/usr/bin</a>:<a href="file:/bin">/bin</a>
              ▶ <a href="file:/usr/sbin">/usr/sbin</a>
              ▶ <a href="file:/usr/bin">/usr/bin</a>
              ▶ <a href="file:/bin">/bin</a>
              ~&gt; re:split &amp;max=2 : <a href="file:/usr/sbin">/usr/sbin</a>:<a href="file:/usr/bin">/usr/bin</a>:<a href="file:/bin">/bin</a>
              ▶ <a href="file:/usr/sbin">/usr/sbin</a>
              ▶ <a href="file:/usr/bin">/usr/bin</a>:<a href="file:/bin">/bin</a>

Elvish 0.17.0                                     Nov 18, 2024                                      <u><a href="../man7/elvish-re.7.html">elvish-re</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>