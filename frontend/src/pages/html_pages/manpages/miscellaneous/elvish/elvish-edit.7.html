<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modes and Submodules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/elvish">elvish_0.17.0-1ubuntu0.1_amd64</a> <br><br><pre>
</pre><h4><b>Overview</b></h4><pre>
   <b>Modes</b> <b>and</b> <b>Submodules</b>
       The  Elvish  editor  has different <b>modes</b>, and exactly one mode is active at the same time.  Each mode has
       its own UI and keybindings.  For instance, the default <b>insert</b> <b>mode</b> lets you modify the  current  command.
       The  <b>completion</b>  <b>mode</b>  (triggered by Tab by default) shows you all candidates for completion, and you can
       use arrow keys to navigate those candidates.

       Each mode has its own submodule under edit:.  For instance, builtin functions and configuration variables
       for the completion mode can be found in the edit:completion: module.

       The primary modes supported now are insert, command, completion, navigation, history, histlist, location,
       and lastcmd.  The last 4 are “listing modes”, and their particularity is documented below.

   <b>Prompts</b>
       Elvish has two prompts: the (normal) left-hand prompt and the right-side prompt (rprompt).  Most of  this
       section  only  documents  the  left-hand  prompt, but API for rprompt is the same other than the variable
       name: just replace prompt with rprompt.

       To customize the prompt, assign a function to edit:prompt.  The function may write value outputs or  byte
       outputs:

       • Value outputs may be either strings or styled values; they are joiend with no spaces in between.

       • Byte    outputs   are   output   as-is,   including   any   newlines.    Any   SGR   escape   sequences
         (https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters) included in the byte  outputs  will  be
         parsed, but any other escape sequences or control character will be removed.

       If you mix value and byte outputs, the order in which they appear is non-deterministic.

       Prefer using styled to output styled text; the support for SGR escape sequences is mostly for compatibil‐
       ity with external cross-shell prompts.

       The default prompt and rprompt are equivalent to:

              edit:prompt = { tilde-abbr $pwd; put '&gt; ' }
              edit:rprompt = (constantly (styled (whoami)@(hostname) inverse))

       More prompt functions:

              ~&gt; edit:prompt = { tilde-abbr $pwd; styled '&gt; ' green }
              ~&gt; # "&gt;" is now green
              ~&gt; edit:prompt = { echo '$' }
              $
              # Cursor will be on the next line as `echo` outputs a trailing newline

   <b>Stale</b> <b>Prompt</b>
       Elvish never waits for the prompt function to finish.  Instead, the prompt function is always executed on
       a separate thread, and Elvish updates the screen when the function finishes.

       However,  this  can be misleading when the function is slow: this means that the prompt on the screen may
       not contain the latest information.  To deal with this, if the prompt function does not finish  within  a
       certain  threshold  -  by  default  0.2 seconds, Elvish marks the prompt as <b>stale</b>: it still shows the old
       stale prompt content, but transforms it using a <b>stale</b> <b>transformer</b>.  The default stale transformer applies
       reverse-video to the whole prompt.

       The threshold is customizable with $edit:prompt-stale-threshold; it specifies the threshold in seconds.

       The transformer is customizable with $edit:prompt-stale-transform.  It is a  function;  the  function  is
       called  with  one  argument, a styled text, and the output is interpreted in the same way as prompt func‐
       tions.  Some examples are:

              # The following effectively disables marking of stale prompt.
              edit:prompt-stale-transform = [x]{ put $x }
              # Show stale prompts in inverse; equivalent to the default.
              edit:prompt-stale-transform = [x]{ styled $x inverse }
              # Gray out stale prompts.
              edit:prompt-stale-transform = [x]{ styled $x bright-black }

       To see the transformer in action, try the following example (assuming  default  $edit:prompt-stale-trans‐
       form):

              n = 0
              edit:prompt = { sleep 2; put $n; n = (+ $n 1); put ': ' }
              edit:-prompt-eagerness = 10 # update prompt on each keystroke
              edit:prompt-stale-threshold = 0.5

       And  then  start  typing.   Type one character; the prompt becomes inverse after 0.5 second: this is when
       Elvish starts to consider the prompt as stale.  The prompt will return normal after 2  seconds,  and  the
       counter in the prompt is updated: this is when the prompt function finishes.

       Another  thing  you will notice is that, if you type a few characters quickly (in less than 2 seconds, to
       be precise), the prompt is only updated twice.  This is because Elvish never does two prompt  updates  in
       parallel:  prompt  updates  are  serialized.   If a prompt update is required when the prompt function is
       still running, Elvish simply queues another update.  If an update is  already  queued,  Elvish  does  not
       queue another update.  The reason why exactly two updates happen in this case, and how this algorithm en‐
       sures freshness of the prompt is left as an exercise to the reader.

   <b>Prompt</b> <b>Eagerness</b>
       The occasions when the prompt should get updated can be controlled with $edit:-prompt-eagerness:

       • The prompt is always updated when the editor becomes active – when Elvish starts, or a command finishes
         execution, or when the user presses Enter.

       • If $edit:-prompt-eagerness &gt;= 5, it is updated when the working directory changes.

       • If $edit:-prompt-eagerness &gt;= 10, it is updated on each keystroke.

       The default value is 5.

   <b>RPrompt</b> <b>Persistency</b>
       By  default,  the  rprompt  is  only  shown while the editor is active: as soon as you press Enter, it is
       erased.  If you want to keep it, simply set $edit:rprompt-persistent to $true:

              edit:rprompt-persistent = $true

   <b>Keybindings</b>
       Each mode has its own keybinding, accessible as the binding variable in its module.   For  instance,  the
       binding table for insert mode is $edit:insert:binding.  To see current bindings, simply print the binding
       table: pprint $edit:insert:binding (replace insert with any other mode).

       The  global  key binding table, $edit:global-binding is consulted when a key is not handled by the active
       mode.

       A binding tables is simply a map that maps keys to functions.  For instance, to bind Alt-x in insert mode
       to exit Elvish, simply do:

              edit:insert:binding[Alt-x] = { exit }

       Outputs from a bound function always appear above the Elvish prompt.  You can see this by doing the  fol‐
       lowing:

              edit:insert:binding[Alt-x] = { echo 'output from a bound function!' }

       and  press Alt-x in insert mode.  It allows you to put debugging outputs in bound functions without mess‐
       ing up the terminal.

       Internally, this is implemented by connecting their output to a pipe.  This does  the  correct  thing  in
       most  cases,  but  if  you  are  sure  you  want  to do something to the terminal, redirect the output to
       /dev/tty.  Since this will break Elvish’s internal tracking of the terminal state, you should also  do  a
       full  redraw with edit:redraw &amp;full=$true.  For instance, the following binds Ctrl-L to clearing the ter‐
       minal:

              edit:insert:binding[Ctrl-L] = { clear &gt; /dev/tty; edit:redraw &amp;full=$true }

       (The same functionality is already available as a builtin, edit:clear.)

       Bound functions have their inputs redirected to /dev/null.

   <b>Format</b> <b>of</b> <b>Keys</b>
       Key modifiers and names are case sensitive.  This includes single character key names such as x and Y  as
       well as function key names such as Enter.

       Key names have zero or more modifiers from the following symbols:

                  A  Alt
                  C  Ctrl
                  M  Meta
                  S  Shift

       Modifiers,  if  present,  end with either a - or +; e.g., S-F1, Ctrl-X or Alt+Enter.  You can stack modi‐
       fiers; e.g., C+A-X.

       The key name may be a simple character such as x or a function key from these symbols:

                  F1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11  F12
                  Up  Down  Right  Left
                  Home  Insert  Delete  End  PageUp  PageDown
                  Tab  Enter  Backspace

       <b>Note:</b> Tab is an alias for "\t" (aka Ctrl-I), Enter for "\n" (aka Ctrl-J), and Backspace for  "\x7F"  (aka
       Ctrl-?).

       <b>Note:</b>  The  Shift modifier is only applicable to function keys such as F1.  You cannot write Shift-m as a
       synonym for M.

       <b>TODO:</b> Document the behavior of the Shift modifier.

   <b>Listing</b> <b>Modes</b>
       The modes histlist, loc and lastcmd are all <b>listing</b> <b>modes</b>: They all show a list, and you can filter items
       and accept items.

       Because they are very similar, you may want to change their bindings at the same time.  This is made pos‐
       sible by the $edit:listing:binding binding table (listing is not a “real” mode but an  “abstract”  mode).
       These  modes  still  have  their  own binding tables like $edit:histlist:binding, and bindings there have
       higher precedence over those in the shared $edit:listing:binding table.

       Moreover, there are a lot of builtin functions in the edit:listing  module  like  edit:listing:down  (for
       moving down selection).  They always apply to whichever listing mode is active.

   <b>Caveat:</b> <b>Bindings</b> <b>to</b> <b>Start</b> <b>Modes</b>
       Note  that  keybindings to <b>start</b> modes live in the binding table of the insert mode, not the target mode.
       For instance, if you want to be able to use Alt-l to start location mode,  you  should  modify  $edit:in‐
       sert:binding[Alt-l]:

              edit:insert:binding[Alt-l] = { edit:location:start }

       One  tricky  case  is  the  history  mode.  You can press ▲︎ to start searching for history, and continue
       pressing it to search further.  However, when the first press happens, the  editor  is  in  insert  mode,
       while  with subsequent presses, the editor is in history mode.  Hence this binding actually relies on two
       entries, $edit:insert:binding[Up] and $edit:history:binding[Up].

       So for instance if you want to be able to use Ctrl-P for this, you need to modify both bindings:

              edit:insert:binding[Ctrl-P] =  { edit:history:start }
              edit:history:binding[Ctrl-P] = { edit:history:up }

   <b>Filter</b> <b>DSL</b>
       The completion, history listing, location and navigation modes all support filtering the  items  to  show
       using  a filter DSL.  It uses a small subset of Elvish’s expression syntax, and can be any of the follow‐
       ing:

       • A literal string (barewords and single-quoted or double-quoted strings all work) matches items contain‐
         ing the string.  If the string is all lower case, the match is done case-insensitively;  otherwise  the
         match is case-sensitive.

       • A  list [re $string] matches items matching the regular expression $string.  The $string must be a lit‐
         eral string.

       • A list [and $expr...] matches items matching all of the $exprs.

       • A list [or $expr...] matches items matching any of the $exprs.

       If the filter contains multiple expressions, they are ANDed, as if surrounded by an implicit [and ...].

   <b>Completion</b> <b>API</b>
   <b>Argument</b> <b>Completer</b>
       There are two types of completions in Elvish: completion for internal data and completion for command ar‐
       guments.  The former includes completion for variable names (e.g.  echo $Tab)  and  indices  (e.g.   echo
       $edit:insert:binding[Tab).   These  are  the completions that Elvish can provide itself because they only
       depend on the internal state of Elvish.

       The latter, in turn, is what happens when you type e.g.  catTab.  Elvish cannot provide  completions  for
       them without full knowledge of the command.

       Command  argument  completions  are  programmable  via the $edit:completion:arg-completer variable.  When
       Elvish is completing an argument of command $x, it will call the value  stored  in  $edit:completion:arg-
       completer[$x], with all the existing arguments, plus the command name in the front.

       For example, if the user types man 1Tab, Elvish will call:

              $edit:completion:arg-completer[man] man 1

       If  the  user is starting a new argument when hitting Tab, Elvish will call the completer with a trailing
       empty string.  For instance, if you do man 1SpaceTab, Elvish will call:

              $edit:completion:arg-completer[man] man 1 ""

       The output of this call becomes candidates.  There are several ways of outputting candidates:

       • Writing byte output, e.g.  “echo cand1; echo cand2”.  Each line becomes  a  candidate.   This  has  the
         drawback that you cannot put newlines in candidates.  Only use this if you are sure that you candidates
         will not contain newlines – e.g.  package names, usernames, but <b>not</b> file names, etc..

       • Write strings to value output, e.g.  “put cand1 cand2”.  Each string output becomes a candidate.

       • Use the edit:complex-candidate command, e.g.:

                edit:complex-candidate &amp;code-suffix='' &amp;display=$stem' ('$description')'  $stem

         See edit:complex-candidate for the full description of the arguments is accepts.

       After  receiving  your  candidates,  Elvish  will  match your candidates against what the user has typed.
       Hence, normally you don’t need to (and shouldn’t) do any matching yourself.

       That means that in many cases you can (and should) simply ignore the last  argument  to  your  completer.
       However,  they  can  be useful for deciding what <b>kind</b> of things to complete.  For instance, if you are to
       write a completer for ls, you want to see whether the last argument starts with - or  not:  if  it  does,
       complete an option; and if not, complete a filename.

       Here is a very basic example of configuring a completer for the apt command.  It only supports completing
       the install and remove command and package names after that:

              all-packages = [(apt-cache search '' | eawk [0 1 @rest]{ put $1 })]

              edit:completion:arg-completer[apt] = [@args]{
                  n = (count $args)
                  if (== $n 2) {
                      # apt x&lt;Tab&gt; -- complete a subcommand name
                      put install uninstall
                  } elif (== $n 3) {
                      put $@all-packages
                  }
              }

       Here  is  another  slightly more complex example for the git command.  It supports completing some common
       subcommands and then branch names after that:

              fn all-git-branches {
                  # Note: this assumes a recent version of git that supports the format
                  # string used.
                  git branch -a --format="%(refname:strip=2)" | eawk [0 1 @rest]{ put $1 }
              }

              common-git-commands = [
                add branch checkout clone commit diff init log merge
                pull push rebase reset revert show stash status
              ]

              edit:arg-completer[git] = [@args]{
                  n = (count $args)
                  if (== $n 2) {
                      put $@common-git-commands
                  } elif (&gt;= $n 3) {
                      all-git-branches
                  }
              }

   <b>Matcher</b>
       As stated above, after the completer outputs candidates, Elvish matches them with them with what the user
       has typed.  For clarity, the part of the user input that is relevant to tab completion is called for  the
       <b>seed</b> of the completion.  For instance, in echo xTab, the seed is x.

       Elvish  first  indexes  the matcher table – $edit:completion:matcher – with the completion type to find a
       <b>matcher</b>.  The <b>completion</b> <b>type</b> is currently one of variable, index, command, redir or  argument.   If  the
       $edit:completion:matcher lacks the suitable key, $edit:completion:matcher[''] is used.

       Elvish  then  calls the matcher with one argument – the seed, and feeds the <u>text</u> of all candidates to the
       input.  The mather must output an identical number of booleans, indicating whether the  candidate  should
       be kept.

       As an example, the following code configures a prefix matcher for all completion types:

              edit:completion:matcher[''] = [seed]{ each [cand]{ has-prefix $cand $seed } }

       Elvish  provides  three builtin matchers, edit:match-prefix, edit:match-substr and edit:match-subseq.  In
       addition to conforming to the matcher protocol, they accept two  options  &amp;ignore-case  and  &amp;smart-case.
       For example, if you want completion of arguments to use prefix matching and ignore case, use:

              edit:completion:matcher[argument] = [seed]{ edit:match-prefix $seed &amp;ignore-case=$true }

       The default value of $edit:completion:matcher is [&amp;''=$edit:match-prefix~], hence that candidates for all
       completion types are matched by prefix.

   <b>Hooks</b>
       Hooks are functions that are executed at certain points in time.  In Elvish this functionality is provid‐
       ed by variables that are a list of functions.

       <b>NOTE</b>:  Hook  variables  may be initialized with a non-empty list, and you may have modules that add their
       own hooks.  In general you should append to a hook variable rather than assign a list of functions to it.
       That is, rather than doing set edit:some-hook = [ []{ put 'I ran' } ] you should do set edit:some-hook  =
       [ $@hook-var []{ put 'I ran' } ].

       These are the editor/REPL hooks:

       • $edit:before-readline  (https://elv.sh/ref/edit.html#editbefore-readline): The functions are called be‐
         fore the editor runs.  Each function is called with no arguments.

       • $edit:after-readline (https://elv.sh/ref/edit.html#editafter-readline): The functions are called  after
         the  editor  accepts  a  command for execution.  Each function is called with a sole argument: the line
         just read.

       • $edit:after-command (https://elv.sh/ref/edit.html#editafter-command): The functions  are  called  after
         the  shell  executes  the  command you entered (typically by pressing the Enter key).  Each function is
         called with a sole argument: a map that provides information about the executed command.  This hook  is
         also called after your interactive RC file is executed and before the first prompt is output.

       Example usage:

              edit:before-readline = [{ echo 'going to read' }]
              edit:after-readline = [[line]{ echo 'just read '$line }]
              edit:after-command = [[m]{ echo 'command took '$m[duration]' seconds' }]

       Given the above hooks...

       1. Every time you accept a chunk of code (normally by pressing Enter) just read is printed.

       2. At  the  very  beginning  of  an Elvish session, or after a chunk of code is handled, going to read is
          printed.

       3. After each non empty chunk of code is accepted and executed the string “command took ...  seconds`  is
          output.

   <b>Word</b> <b>types</b>
       The  editor supports operating on entire “words”.  As intuitive as the concept of “word” is, there is ac‐
       tually no single definition for the concept.  The editor supports  the  following  three  definitions  of
       words:

       • A <b>big</b> <b>word</b>, or simply <b>word</b>, is a sequence of non-whitespace characters.  This definition corresponds to
         the concept of “WORD” in vi.

       • A  <b>small</b> <b>word</b> is a sequence of alphanumerical characters (“alnum small word”), or a sequence of non-al‐
         phanumerical, non-whitespace characters (“punctuation small word”).  This definition corresponds to the
         concept of “word” in vi and zsh.

       • An <b>alphanumerical</b> <b>word</b> is a sequence of alphanumerical characters.  This definition corresponds to  the
         concept of “word” in bash.

       Whitespace  characters  are  those  with  the  Unicode  Whitespace  (https://en.wikipedia.org/wiki/White‐
       space_character#Unicode) property.  Alphanumerical characters are those in the Unicode Letter  or  Number
       category.

       A <b>word</b> <b>boundary</b> is an imaginary zero-length boundary around a word.

       To see the difference between these definitions, consider the following string: abc++ /* xyz:

       • It contains three (big) words: abc++, /* and xyz.

       • It  contains  four  small  words,  abc, ++, /* and xyz.  Among them, abc and xyz are alnum small words,
         while ++ and /* are punctuation small words.

       • It contains two alnum words, abc and xyz.

</pre><h4><b>Variables</b></h4><pre>
   <b>$edit:abbr</b> <b>{#edit:abbr}</b>
       A map from (simple) abbreviations to their expansions.

       An abbreviation is replaced by its expansion when it is typed in full and  consecutively,  without  being
       interrupted by the use of other editing functionalities, such as cursor movements.

       If more than one abbreviations would match, the longest one is used.

       Examples:

              edit:abbr['||'] = '| less'
              edit:abbr['&gt;dn'] = '2&gt;/dev/null'

       With  the  definitions  above,  typing  || anywhere expands to | less, and typing &gt;dn anywhere expands to
       2&gt;/dev/null.  However, typing a |, moving the cursor left, and typing another |  does  <b>not</b>  expand  to  |
       less, since the abbreviation || was not typed consecutively.

       See also edit:small-word-abbr.

   <b>$edit:add-cmd-filters</b> <b>{#edit:add-cmd-filters}</b>
       List of filters to run before adding a command to history.

       A  filter is a function that takes a command as argument and outputs a boolean value.  If any of the fil‐
       ters outputs $false, the command is not saved to history, and the rest of the filters are not  run.   The
       default value of this list contains a filter which ignores command starts with space.

   <b>$edit:after-command</b> <b>{#edit:after-command}</b>
       A  list of functions to call after each interactive command completes.  There is one pre-defined function
       used to populate the $edit:command-duration  variable.   Each  function  is  called  with  a  single  map
       (https://elv.sh/ref/language.html#map) argument containing the following keys:

       • src: Information about the source that was executed, same as what src would output inside the code.

       • duration:  A  floating-point  number (https://elv.sh/ref/language.html#number) representing the command
         execution duration in seconds.

       • error: An exception object if the command terminated with an exception, else $nil.

       See also edit:command-duration.

   <b>$edit:after-readline</b> <b>{#edit:after-readline}</b>
       A list of functions to call after each readline cycle.  Each function is called with a single string  ar‐
       gument containing the code that has been read.

   <b>$edit:before-readline</b> <b>{#edit:before-readline}</b>
       A list of functions to call before each readline cycle.  Each function is called without any arguments.

   <b>$edit:command-duration</b> <b>{#edit:command-duration}</b>
       Duration,  in seconds, of the most recent interactive command.  This can be useful in your prompt to pro‐
       vide feedback on how long a command took to run.  The initial value of this variable is the time to eval‐
       uate your <a href="file:~/.elvish/rc.elv">~/.elvish/rc.elv</a> script before printing the first prompt.

       See also edit:after-command.

   <b>$edit:command:binding</b> <b>{#edit:command:binding}</b>
       Key bindings for command mode.  This is currently a very small subset of Vi command mode bindings.

       See also edit:command:start.

   <b>$edit:completion:arg-completer</b> <b>{#edit:completion:arg-completer}</b>
       A map containing argument completers.

   <b>$edit:completion:binding</b> <b>{#edit:completion:binding}</b>
       Keybinding for the completion mode.

   <b>$edit:completion:matcher</b> <b>{#edit:completion:matcher}</b>
       A map mapping from context names to matcher functions.  See the Matcher section.

   <b>$edit:current-command</b> <b>{#edit:current-command}</b>
       Contains the content of the current input.  Setting the variable will cause the cursor  to  move  to  the
       very end, as if edit-dot = (count $edit:current-command) has been invoked.

       This API is subject to change.

   <b>$edit:-dot</b> <b>{#edit:-dot}</b>
       Contains the current position of the cursor, as a byte position within $edit:current-command.

   <b>$edit:exceptions</b> <b>{#edit:exceptions}</b>
       A  list  of  exceptions thrown from callbacks such as prompts.  Useful for examining tracebacks and other
       metadata.

   <b>$edit:global-binding</b> <b>{#edit:global-binding}</b>
       Global keybindings, consulted for keys not handled by mode-specific bindings.

       See Keybindings.

   <b>$edit:history:binding</b> <b>{#edit:history:binding}</b>
       Binding table for the history mode.

   <b>$edit:-instant:binding</b> <b>{#edit:-instant:binding}</b>
       Binding for the instant mode.

   <b>$edit:location:hidden</b> <b>{#edit:location:hidden}</b>
       A list of directories to hide in the location addon.

   <b>$edit:location:pinned</b> <b>{#edit:location:pinned}</b>
       A list of directories to always show at the top of the list of the location addon.

   <b>$edit:location:workspaces</b> <b>{#edit:location:workspaces}</b>
       A map mapping types of workspaces to their patterns.

   <b>$edit:max-height</b> <b>{#edit:max-height}</b>
       Maximum height the editor is allowed to use, defaults to +Inf.

       By default, the height of the editor is only restricted by the terminal height.  Some modes like location
       mode can use a lot of lines; as a result, it can often occupy the  entire  terminal,  and  push  up  your
       scrollback buffer.  Change this variable to a finite number to restrict the height of the editor.

   <b>$edit:navigation:binding</b> <b>{#edit:navigation:binding}</b>
       Keybinding for the navigation mode.

   <b>$edit:navigation:width-ratio</b> <b>{#edit:navigation:width-ratio}</b>
       A list of 3 integers, used for specifying the width ratio of the 3 columns in navigation mode.

   <b>$edit:prompt</b> <b>{#edit:prompt}</b>
       See Prompts.

   <b>$edit:-prompt-eagerness</b> <b>{#edit:-prompt-eagerness}</b>
       See Prompt Eagerness.

   <b>$edit:prompt-stale-threshold</b> <b>{#edit:prompt-stale-threshold}</b>
       See Stale Prompt.

   <b>$edit:prompt-stale-transformer.</b> <b>{#edit:prompt-stale-transformer.}</b>
       See Stale Prompt.

   <b>$edit:rprompt</b> <b>{#edit:rprompt}</b>
       See Prompts.

   <b>$edit:-rprompt-eagerness</b> <b>{#edit:-rprompt-eagerness}</b>
       See Prompt Eagerness.

   <b>$edit:rprompt-persistent</b> <b>{#edit:rprompt-persistent}</b>
       See RPrompt Persistency.

   <b>$edit:rprompt-stale-threshold</b> <b>{#edit:rprompt-stale-threshold}</b>
       See Stale Prompt.

   <b>$edit:rprompt-stale-transformer.</b> <b>{#edit:rprompt-stale-transformer.}</b>
       See Stale Prompt.

   <b>$edit:selected-file</b> <b>{#edit:selected-file}</b>
       Name of the currently selected file in navigation mode.  $nil if not in navigation mode.

   <b>$edit:small-word-abbr</b> <b>{#edit:small-word-abbr}</b>
       A map from small-word abbreviations and their expansions.

       A  small-word  abbreviation is replaced by its expansion after it is typed in full and consecutively, and
       followed by another character (the <u>trigger</u> character).  Furthermore, the expansion requires the following
       conditions to be satisfied:

       • The end of the abbreviation must be adjacent to a small-word boundary, i.e.  the last character of  the
         abbreviation and the trigger character must be from two different small-word categories.

       • The  start of the abbreviation must also be adjacent to a small-word boundary, unless it appears at the
         beginning of the code buffer.

       • The cursor must be at the end of the buffer.

       If more than one abbreviations would match, the longest one is used.

       As an example, with the following configuration:

              edit:small-word-abbr['gcm'] = 'git checkout master'

       In the following scenarios, the gcm abbreviation is expanded:

       • With an empty buffer, typing gcm and a space or semicolon;

       • When the buffer ends with a space, typing gcm and a space or semicolon.

       The space or semicolon after gcm is preserved in both cases.

       In the following scenarios, the gcm abbreviation is <b>not</b> expanded:

       • With an empty buffer, typing Xgcm and a space or semicolon (start of abbreviation is not adjacent to  a
         small-word boundary);

       • When  the  buffer ends with X, typing gcm and a space or semicolon (end of abbreviation is not adjacent
         to a small-word boundary);

       • When the buffer is non-empty, move the cursor to the beginning, and typing gcm and a space (cursor  not
         at the end of the buffer).

       This  example  shows  the  case  where the abbreviation consists of a single small word of alphanumerical
       characters, but that doesn’t have to be the case.  For example, with the following configuration:

              edit:small-word-abbr['&gt;dn'] = ' 2&gt;/dev/null'

       The abbreviation &gt;dn starts with a punctuation character, and  ends  with  an  alphanumerical  character.
       This  means that it is expanded when it borders a whitespace or alphanumerical character to the left, and
       a whitespace or punctuation to the right; for example, typing ls&gt;dn; will expand it.

       Some extra examples of small-word abbreviations:

              edit:small-word-abbr['gcp'] = 'git cherry-pick -x'
              edit:small-word-abbr['ll'] = 'ls -ltr'

       If both a simple abbreviation and a small-word abbreviation can be expanded, the simple abbreviation  has
       priority.

       See also edit:abbr.

</pre><h4><b>Functions</b></h4><pre>
   <b>edit:add-var</b> <b>{#edit:add-var}</b>
              edit:add-var $name $value

       Declares a new variable in the REPL.  The new variable becomes available during the next REPL cycle.

       Equivalent to running var $name = $value at the REPL, but $name can be dynamic.

       Example:

              ~&gt; edit:add-var foo bar
              ~&gt; put $foo
              ▶ bar

   <b>edit:add-vars</b> <b>{#edit:add-vars}</b>
              edit:add-vars $map

       Takes a map from strings to arbitrary values.  Equivalent to calling edit:add-var for each key-value pair
       in the map.

   <b>edit:binding-table</b> <b>{#edit:binding-table}</b>
       Converts a normal map into a binding map.

   <b>edit:clear</b> <b>{#edit:clear}</b>
              edit:clear

       Clears the screen.

       This command should be used in place of the external clear command to clear the screen.

   <b>edit:close-mode</b> <b>{#edit:close-mode}</b>
       Closes the current active mode.

   <b>edit:command-history</b> <b>{#edit:command-history}</b>
              edit:command-history &amp;cmd-only=$false &amp;dedup=$false &amp;newest-first

       Outputs the command history.

       By  default,  each  entry is represented as a map, with an id key key for the sequence number of the com‐
       mand, and a cmd key for the text of the command.  If &amp;cmd-only is $true, only the text of each command is
       output.

       All entries are output by default.  If &amp;dedup is $true, only the most recent  instance  of  each  command
       (when comparing just the cmd key) is output.

       Commands are are output in oldest to newest order by default.  If &amp;newest-first is $true the output is in
       newest to oldest order instead.

       As an example, either of the following extracts the text of the most recent command:

              edit:command-history | put [(all)][-1][cmd]
              edit:command-history &amp;cmd-only &amp;newest-first | take 1

       See also builtin:dir-history.

   <b>edit:command:start</b> <b>{#edit:command:start}</b>
       Enter  command mode.  This mode is intended to emulate Vi’s command mode, but it is very incomplete right
       now.

       See also edit:command:binding.

   <b>edit:complete-filename</b> <b>{#edit:complete-filename}</b>
              edit:complete-filename $args...

       Produces a list of filenames found in the directory of the last argument.  All other  arguments  are  ig‐
       nored.  If the last argument does not contain a path (either absolute or relative to the current directo‐
       ry), then the current directory is used.  Relevant files are output as edit:complex-candidate objects.

       This  function is the default handler for any commands without explicit handlers in $edit:completion:arg-
       completer.  See Argument Completer.

       Example:

              ~&gt; edit:complete-filename ''
              ▶ (edit:complex-candidate Applications &amp;code-suffix=/ &amp;style='01;34')
              ▶ (edit:complex-candidate Books &amp;code-suffix=/ &amp;style='01;34')
              ▶ (edit:complex-candidate Desktop &amp;code-suffix=/ &amp;style='01;34')
              ▶ (edit:complex-candidate Docsafe &amp;code-suffix=/ &amp;style='01;34')
              ▶ (edit:complex-candidate Documents &amp;code-suffix=/ &amp;style='01;34')
              ...
              ~&gt; edit:complete-filename .elvish/
              ▶ (edit:complex-candidate .elvish/aliases &amp;code-suffix=/ &amp;style='01;34')
              ▶ (edit:complex-candidate .elvish/db &amp;code-suffix=' ' &amp;style='')
              ▶ (edit:complex-candidate .elvish/epm-installed &amp;code-suffix=' ' &amp;style='')
              ▶ (edit:complex-candidate .elvish/lib &amp;code-suffix=/ &amp;style='01;34')
              ▶ (edit:complex-candidate .elvish/rc.elv &amp;code-suffix=' ' &amp;style='')

   <b>edit:complete-getopt</b> <b>{#edit:complete-getopt}</b>
              edit:complete-getopt $args $opt-specs $arg-handlers

       Produces completions according to a specification of accepted command-line options (both short  and  long
       options  are  handled), positional handler functions for each command position, and the current arguments
       in the command line.  The arguments are as follows:

       • $args is an array containing the current arguments in the command line (without  the  command  itself).
         These are the arguments as passed to the Argument Completer function.

       • $opt-specs is an array of maps, each one containing the definition of one possible command-line option.
         Matching options will be provided as completions when the last element of $args starts with a dash, but
         not  otherwise.   Each  map  can  contain the following keys (at least one of short or long needs to be
         specified):

         • short contains the one-letter short option, if any, without the dash.

         • long contains the long option name, if any, without the initial two dashes.

         • arg-optional, if set to $true, specifies that the option receives an optional argument.

         • arg-required, if set to $true, specifies that the option receives a mandatory argument.  Only one  of
           arg-optional or arg-required can be set to $true.

         • desc  can be set to a human-readable description of the option which will be displayed in the comple‐
           tion menu.

         • completer can be set to a function to generate possible completions for  the  option  argument.   The
           function receives as argument the element at that position and return zero or more candidates.

       • $arg-handlers  is  an array of functions, each one returning the possible completions for that position
         in the arguments.  Each function receives as argument the last element of $args, and should return zero
         or more possible values for the completions at that point.  The returned values can be plain strings or
         the output of edit:complex-candidate.  If the last element of the list is the string ..., then the last
         handler is reused for all following arguments.

       Example:

              ~&gt; fn complete {|@args|
                   opt-specs = [ [&amp;short=a &amp;long=all &amp;desc="Show all"]
                                 [&amp;short=n &amp;desc="Set name" &amp;arg-required=$true
                                  &amp;completer= {|_| put name1 name2 }] ]
                   arg-handlers = [ {|_| put first1 first2 }
                                    {|_| put second1 second2 } ... ]
                   edit:complete-getopt $args $opt-specs $arg-handlers
                 }
              ~&gt; complete ''
              ▶ first1
              ▶ first2
              ~&gt; complete '-'
              ▶ (edit:complex-candidate -a &amp;display='-a (Show all)')
              ▶ (edit:complex-candidate --all &amp;display='--all (Show all)')
              ▶ (edit:complex-candidate -n &amp;display='-n (Set name)')
              ~&gt; complete -n ''
              ▶ name1
              ▶ name2
              ~&gt; complete -a ''
              ▶ first1
              ▶ first2
              ~&gt; complete arg1 ''
              ▶ second1
              ▶ second2
              ~&gt; complete arg1 arg2 ''
              ▶ second1
              ▶ second2

   <b>edit:completion:close</b> <b>{#edit:completion:close}</b>
       Closes the completion mode UI.

   <b>edit:completion:smart-start</b> <b>{#edit:completion:smart-start}</b>
       Starts the completion mode.  However, if all the candidates share a  non-empty  prefix  and  that  prefix
       starts with the seed, inserts the prefix instead.

   <b>edit:completion:start</b> <b>{#edit:completion:start}</b>
       Start the completion mode.

   <b>edit:complex-candidate</b> <b>{#edit:complex-candidate}</b>
              edit:complex-candidate $stem &amp;display='' &amp;code-suffix=''

       Builds a complex candidate.  This is mainly useful in argument completers.

       The  &amp;display option controls how the candidate is shown in the UI.  It can be a string or a styled text.
       If it is empty, $stem is used.

       The &amp;code-suffix option affects how the candidate is inserted into the code when it is accepted.  By  de‐
       fault,  a  quoted  version of $stem is inserted.  If $code-suffix is non-empty, it is added to that text,
       and the suffix is not quoted.

   <b>edit:-dump-buf</b> <b>{#edit:-dump-buf}</b>
       Dumps the current UI buffer as HTML.  This  command  is  used  to  generate  “ttyshots”  on  the  website
       (https://elv.sh).

       Example:

              ttyshot = <a href="file:~/a.html">~/a.html</a>
              edit:insert:binding[Ctrl-X] = { edit:-dump-buf &gt; $tty }

   <b>edit:end-of-history</b> <b>{#edit:end-of-history}</b>
       Adds a notification saying “End of history”.

   <b>edit:history:down</b> <b>{#edit:history:down}</b>
       Walks to the next entry in history mode.

   <b>edit:history:down-or-quit</b> <b>{#edit:history:down-or-quit}</b>
       Walks to the next entry in history mode, or quit the history mode if already at the newest entry.

   <b>edit:history:fast-forward</b> <b>{#edit:history:fast-forward}</b>
       Import command history entries that happened after the current session started.

   <b>edit:history:start</b> <b>{#edit:history:start}</b>
       Starts the history mode.

   <b>edit:history:up</b> <b>{#edit:history:up}</b>
       Walks to the previous entry in history mode.

   <b>edit:insert-at-dot</b> <b>{#edit:insert-at-dot}</b>
              edit:insert-at-dot $text

       Inserts the given text at the dot, moving the dot after the newly inserted text.

   <b>edit:insert-last-word</b> <b>{#edit:insert-last-word}</b>
       Inserts the last word of the last command.

   <b>edit:insert-raw</b> <b>{#edit:insert-raw}</b>
       Requests the next terminal input to be inserted uninterpreted.

   <b>edit:-instant:start</b> <b>{#edit:-instant:start}</b>
       Starts the instant mode.  In instant mode, any text entered at the command line is evaluated immediately,
       with the output displayed.

       <b>WARNING</b>: Beware of unintended consequences when using destructive commands.  For example, if you type su‐
       do  rm  -rf <a href="file:/tmp/">/tmp/</a>* in the instant mode, Elvish will attempt to evaluate sudo rm -rf / when you typed that
       far.

   <b>edit:key</b> <b>{#edit:key}</b>
              edit:key $string

       Parses a string into a key.

   <b>edit:kill-alnum-word-left</b> <b>{#edit:kill-alnum-word-left}</b>
       Deletes the the last alnum word to the left of the dot.

   <b>edit:kill-alnum-word-right</b> <b>{#edit:kill-alnum-word-right}</b>
       Deletes the the first alnum word to the right of the dot.

   <b>edit:kill-line-left</b> <b>{#edit:kill-line-left}</b>
       Deletes the text between the dot and the start of the current line.

   <b>edit:kill-line-right</b> <b>{#edit:kill-line-right}</b>
       Deletes the text between the dot and the end of the current line.

   <b>edit:kill-rune-left</b> <b>{#edit:kill-rune-left}</b>
       Kills one rune right of the dot.  Does nothing if the dot is at the end of the buffer.

   <b>edit:kill-small-word-left</b> <b>{#edit:kill-small-word-left}</b>
       Deletes the the last small word to the left of the dot.

   <b>edit:kill-small-word-right</b> <b>{#edit:kill-small-word-right}</b>
       Deletes the the first small word to the right of the dot.

   <b>edit:kill-word-left</b> <b>{#edit:kill-word-left}</b>
       Deletes the the last word to the left of the dot.

   <b>edit:kill-word-right</b> <b>{#edit:kill-word-right}</b>
       Deletes the the first word to the right of the dot.

   <b>edit:listing:accept</b> <b>{#edit:listing:accept}</b>
       Accepts the current selected listing item.

   <b>edit:listing:down</b> <b>{#edit:listing:down}</b>
       Moves the cursor down in listing mode.

   <b>edit:listing:down-cycle</b> <b>{#edit:listing:down-cycle}</b>
       Moves the cursor down in listing mode, or to the first item if the last item is currently selected.

   <b>edit:listing:left</b> <b>{#edit:listing:left}</b>
       Moves the cursor left in listing mode.

   <b>edit:listing:page-down</b> <b>{#edit:listing:page-down}</b>
       Moves the cursor down one page.

   <b>edit:listing:page-up</b> <b>{#edit:listing:page-up}</b>
       Moves the cursor up one page.

   <b>edit:listing:right</b> <b>{#edit:listing:right}</b>
       Moves the cursor right in listing mode.

   <b>edit:listing:start-custom</b> <b>{#edit:listing:start-custom}</b>
       Starts a custom listing addon.

   <b>edit:listing:up</b> <b>{#edit:listing:up}</b>
       Moves the cursor up in listing mode.

   <b>edit:listing:up-cycle</b> <b>{#edit:listing:up-cycle}</b>
       Moves the cursor up in listing mode, or to the last item if the first item is currently selected.

   <b>edit:match-prefix</b> <b>{#edit:match-prefix}</b>
              edit:match-prefix $seed $inputs?

       For each input, outputs whether the input has $seed as a prefix.  Uses the result of to-string  for  non-
       string inputs.

       Roughly equivalent to the following Elvish function, but more efficient:

              use str
              fn match-prefix {|seed @input|
                each {|x| str:has-prefix (to-string $x) $seed } $@input
              }

   <b>edit:match-subseq</b> <b>{#edit:match-subseq}</b>
              edit:match-subseq $seed $inputs?

       For  each input, outputs whether the input has $seed as a subsequence (https://en.wikipedia.org/wiki/Sub‐
       sequence).  Uses the result of to-string for non-string inputs.

   <b>edit:match-substr</b> <b>{#edit:match-substr}</b>
              edit:match-substr $seed $inputs?

       For each input, outputs whether the input has $seed as a substring.  Uses the  result  of  to-string  for
       non-string inputs.

       Roughly equivalent to the following Elvish function, but more efficient:

              use str
              fn match-substr {|seed @input|
                each {|x| str:has-contains (to-string $x) $seed } $@input
              }

   <b>edit:move-dot-down</b> <b>{#edit:move-dot-down}</b>
       Moves  the  dot down one line, trying to preserve the visual horizontal position.  Does nothing if dot is
       already on the last line of the buffer.

   <b>edit:move-dot-eol</b> <b>{#edit:move-dot-eol}</b>
       Moves the dot to the end of the current line.

   <b>edit:move-dot-left</b> <b>{#edit:move-dot-left}</b>
       Moves the dot left one rune.  Does nothing if the dot is at the beginning of the buffer.

   <b>edit:move-dot-left-alnum-word</b> <b>{#edit:move-dot-left-alnum-word}</b>
       Moves the dot to the beginning of the last alnum word to the left of the dot.

   <b>edit:move-dot-left-small-word</b> <b>{#edit:move-dot-left-small-word}</b>
       Moves the dot to the beginning of the last small word to the left of the dot.

   <b>edit:move-dot-left-word</b> <b>{#edit:move-dot-left-word}</b>
       Moves the dot to the beginning of the last word to the left of the dot.

   <b>edit:move-dot-right</b> <b>{#edit:move-dot-right}</b>
       Moves the dot right one rune.  Does nothing if the dot is at the end of the buffer.

   <b>edit:move-dot-right-alnum-word</b> <b>{#edit:move-dot-right-alnum-word}</b>
       Moves the dot to the beginning of the first alnum word to the right of the dot.

   <b>edit:move-dot-right-small-word</b> <b>{#edit:move-dot-right-small-word}</b>
       Moves the dot to the beginning of the first small word to the right of the dot.

   <b>edit:move-dot-right-word</b> <b>{#edit:move-dot-right-word}</b>
       Moves the dot to the beginning of the first word to the right of the dot.

   <b>edit:move-dot-sol</b> <b>{#edit:move-dot-sol}</b>
       Moves the dot to the start of the current line.

   <b>edit:move-dot-up</b> <b>{#edit:move-dot-up}</b>
       Moves the dot up one line, trying to preserve the visual horizontal position.  Does nothing if dot is al‐
       ready on the first line of the buffer.

   <b>edit:navigation:insert-selected</b> <b>{#edit:navigation:insert-selected}</b>
       Inserts the selected filename.

   <b>edit:navigation:insert-selected-and-quit</b> <b>{#edit:navigation:insert-selected-and-quit}</b>
       Inserts the selected filename and closes the navigation addon.

   <b>edit:navigation:start</b> <b>{#edit:navigation:start}</b>
       Start the navigation mode.

   <b>edit:navigation:trigger-filter</b> <b>{#edit:navigation:trigger-filter}</b>
       Toggles the filtering status of the navigation addon.

   <b>edit:navigation:trigger-shown-hidden</b> <b>{#edit:navigation:trigger-shown-hidden}</b>
       Toggles whether the navigation addon should be showing hidden files.

   <b>edit:notify</b> <b>{#edit:notify}</b>
              edit:notify $message

       Prints a notification message.

       If called while the editor is active, this will print the message above the editor, and redraw  the  edi‐
       tor.

       If called while the editor is inactive, the message will be queued, and shown once the editor becomes ac‐
       tive.

   <b>edit:redraw</b> <b>{#edit:redraw}</b>
              edit:redraw &amp;full=$false

       Triggers a redraw.

       The &amp;full option controls whether to do a full redraw.  By default, all redraws performed by the line ed‐
       itor are incremental redraws, updating only the part of the screen that has changed from the last redraw.
       A full redraw updates the entire command line.

   <b>edit:replace-input</b> <b>{#edit:replace-input}</b>
              edit:replace-input $text

       Equivalent to assigning $text to $edit:current-command.

   <b>edit:return-eof</b> <b>{#edit:return-eof}</b>
       Causes  the  Elvish  REPL to terminate.  If called from a key binding, takes effect after the key binding
       returns.

   <b>edit:return-line</b> <b>{#edit:return-line}</b>
       Causes the Elvish REPL to end the current read iteration and evaluate the code it just read.   If  called
       from a key binding, takes effect after the key binding returns.

   <b>edit:smart-enter</b> <b>{#edit:smart-enter}</b>
       Inserts  a  literal  newline  if the current code is not syntactically complete Elvish code.  Accepts the
       current line otherwise.

   <b>edit:transpose-alnum-word</b> <b>{#edit:transpose-alnum-word}</b>
       Swaps the alnum words to the left and right of the dot.  If the dot is at the beginning of the buffer, it
       swaps the first two alnum words, and if the dot is at the end, it swaps the last two.

   <b>edit:transpose-rune</b> <b>{#edit:transpose-rune}</b>
       Swaps the runes to the left and right of the dot.  If the dot is at the beginning of  the  buffer,  swaps
       the first two runes, and if the dot is at the end, it swaps the last two.

   <b>edit:transpose-small-word</b> <b>{#edit:transpose-small-word}</b>
       Swaps the small words to the left and right of the dot.  If the dot is at the beginning of the buffer, it
       swaps the first two small words, and if the dot is at the end, it swaps the last two.

   <b>edit:transpose-word</b> <b>{#edit:transpose-word}</b>
       Swaps  the  words  to the left and right of the dot.  If the dot is at the beginning of the buffer, swaps
       the first two words, and the dot is at the end, it swaps the last two.

   <b>edit:wordify</b> <b>{#edit:wordify}</b>
              edit:wordify $code

       Breaks Elvish code into words.

Elvish 0.17.0                                     Nov 18, 2024                                    <u><a href="../man7/elvish-edit.7.html">elvish-edit</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>