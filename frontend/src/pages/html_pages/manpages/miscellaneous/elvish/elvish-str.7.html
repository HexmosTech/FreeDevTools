<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The str: module provides string manipulation functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/elvish">elvish_0.17.0-1ubuntu0.1_amd64</a> <br><br><pre>
</pre><h4><b>Introduction</b></h4><pre>
       The str: module provides string manipulation functions.

       Function usages are given in the same format as in the reference doc for the builtin module.

</pre><h4><b>Functions</b></h4><pre>
   <b>str:compare</b> <b>{#str:compare}</b>
              str:compare $a $b

       Compares two strings and output an integer that will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b.

              ~&gt; str:compare a a
              ▶ 0
              ~&gt; str:compare a b
              ▶ -1
              ~&gt; str:compare b a
              ▶ 1

   <b>str:contains</b> <b>{#str:contains}</b>
              str:contains $str $substr

       Outputs whether $str contains $substr as a substring.

              ~&gt; str:contains abcd x
              ▶ $false
              ~&gt; str:contains abcd bc
              ▶ $true

   <b>str:contains-any</b> <b>{#str:contains-any}</b>
              str:contains-any $str $chars

       Outputs whether $str contains any Unicode code points in $chars.

              ~&gt; str:contains-any abcd x
              ▶ $false
              ~&gt; str:contains-any abcd xby
              ▶ $true

   <b>str:count</b> <b>{#str:count}</b>
              str:count $str $substr

       Outputs  the number of non-overlapping instances of $substr in $s.  If $substr is an empty string, output
       1 + the number of Unicode code points in $s.

              ~&gt; str:count abcdefabcdef bc
              ▶ 2
              ~&gt; str:count abcdef ''
              ▶ 7

   <b>str:equal-fold</b> <b>{#str:equal-fold}</b>
              str:equal-fold $str1 $str2

       Outputs if $str1 and $str2, interpreted as UTF-8 strings, are equal under Unicode case-folding.

              ~&gt; str:equal-fold ABC abc
              ▶ $true
              ~&gt; str:equal-fold abc ab
              ▶ $false

   <b>str:from-codepoints</b> <b>{#str:from-codepoints}</b>
              str:from-codepoints $number...

       Outputs a string consisting of the given Unicode codepoints.  Example:

              ~&gt; str:from-codepoints 0x61
              ▶ a
              ~&gt; str:from-codepoints 0x4f60 0x597d
              ▶ 你好

       See also str:to-codepoints.

   <b>str:from-utf8-bytes</b> <b>{#str:from-utf8-bytes}</b>
              str:from-utf8-bytes $number...

       Outputs a string consisting of the given Unicode bytes.  Example:

              ~&gt; str:from-utf8-bytes 0x61
              ▶ a
              ~&gt; str:from-utf8-bytes 0xe4 0xbd 0xa0 0xe5 0xa5 0xbd
              ▶ 你好

       See also str:to-utf8-bytes.

   <b>str:has-prefix</b> <b>{#str:has-prefix}</b>
              str:has-prefix $str $prefix

       Outputs if $str begins with $prefix.

              ~&gt; str:has-prefix abc ab
              ▶ $true
              ~&gt; str:has-prefix abc bc
              ▶ $false

   <b>str:has-suffix</b> <b>{#str:has-suffix}</b>
              str:has-suffix $str $suffix

       Outputs if $str ends with $suffix.

              ~&gt; str:has-suffix abc ab
              ▶ $false
              ~&gt; str:has-suffix abc bc
              ▶ $true

   <b>str:index</b> <b>{#str:index}</b>
              str:index $str $substr

       Outputs the index of the first instance of $substr in $str, or -1 if $substr is not present in $str.

              ~&gt; str:index abcd cd
              ▶ 2
              ~&gt; str:index abcd xyz
              ▶ -1

   <b>str:index-any</b> <b>{#str:index-any}</b>
              str:index-any $str $chars

       Outputs the index of the first instance of any Unicode code point from $chars in $str, or -1 if  no  Uni‐
       code code point from $chars is present in $str.

              ~&gt; str:index-any "chicken" "aeiouy"
              ▶ 2
              ~&gt; str:index-any l33t aeiouy
              ▶ -1

   <b>str:join</b> <b>{#str:join}</b>
              str:join $sep $input-list?

       Joins inputs with $sep.  Examples:

              ~&gt; put lorem ipsum | str:join ,
              ▶ lorem,ipsum
              ~&gt; str:join , [lorem ipsum]
              ▶ lorem,ipsum
              ~&gt; str:join '' [lorem ipsum]
              ▶ loremipsum
              ~&gt; str:join '...' [lorem ipsum]
              ▶ lorem...ipsum

       Etymology: Various languages, Python (https://docs.python.org/3.6/library/stdtypes.html#str.join).

       See also str:split.

   <b>str:last-index</b> <b>{#str:last-index}</b>
              str:last-index $str $substr

       Outputs the index of the last instance of $substr in $str, or -1 if $substr is not present in $str.

              ~&gt; str:last-index "elven speak elvish" elv
              ▶ 12
              ~&gt; str:last-index "elven speak elvish" romulan
              ▶ -1

   <b>str:replace</b> <b>{#str:replace}</b>
              str:replace &amp;max=-1 $old $repl $source

       Replaces  all  occurrences of $old with $repl in $source.  If $max is non-negative, it determines the max
       number of substitutions.

       <b>Note</b>: This command does not support searching by regular expressions, $old is  always  interpreted  as  a
       plain string.  Use re:replace if you need to search by regex.

   <b>str:split</b> <b>{#str:split}</b>
              str:split &amp;max=-1 $sep $string

       Splits $string by $sep.  If $sep is an empty string, split it into codepoints.

       If the &amp;max option is non-negative, stops after producing the maximum number of results.

              ~&gt; str:split , lorem,ipsum
              ▶ lorem
              ▶ ipsum
              ~&gt; str:split '' 你好
              ▶ 你
              ▶ 好
              ~&gt; str:split &amp;max=2 ' ' 'a b c d'
              ▶ a
              ▶ 'b c d'

       <b>Note</b>:  This  command  does  not support splitting by regular expressions, $sep is always interpreted as a
       plain string.  Use re:split if you need to split by regex.

       Etymology:   Various   languages,   in   particular   Python    (https://docs.python.org/3.6/library/std‐
       types.html#str.split).

       See also str:join.

   <b>str:title</b> <b>{#str:title}</b>
              str:title $str

       Outputs $str with all Unicode letters that begin words mapped to their Unicode title case.

              ~&gt; str:title "her royal highness"
              ▶ Her Royal Highness

   <b>str:to-codepoints</b> <b>{#str:to-codepoints}</b>
              str:to-codepoints $string

       Outputs value of each codepoint in $string, in hexadecimal.  Examples:

              ~&gt; str:to-codepoints a
              ▶ 0x61
              ~&gt; str:to-codepoints 你好
              ▶ 0x4f60
              ▶ 0x597d

       The output format is subject to change.

       See also str:from-codepoints.

   <b>str:to-lower</b> <b>{#str:to-lower}</b>
              str:to-lower $str

       Outputs $str with all Unicode letters mapped to their lower-case equivalent.

              ~&gt; str:to-lower 'ABC!123'
              ▶ abc!123

   <b>str:to-title</b> <b>{#str:to-title}</b>
              str:to-title $str

       Outputs $str with all Unicode letters mapped to their Unicode title case.

              ~&gt; str:to-title "her royal highness"
              ▶ HER ROYAL HIGHNESS
              ~&gt; str:to-title "хлеб"
              ▶ ХЛЕБ

   <b>str:to-upper</b> <b>{#str:to-upper}</b>
              str:to-upper

       Outputs $str with all Unicode letters mapped to their upper-case equivalent.

              ~&gt; str:to-upper 'abc!123'
              ▶ ABC!123

   <b>str:to-utf8-bytes</b> <b>{#str:to-utf8-bytes}</b>
              str:to-utf8-bytes $string

       Outputs value of each byte in $string, in hexadecimal.  Examples:

              ~&gt; str:to-utf8-bytes a
              ▶ 0x61
              ~&gt; str:to-utf8-bytes 你好
              ▶ 0xe4
              ▶ 0xbd
              ▶ 0xa0
              ▶ 0xe5
              ▶ 0xa5
              ▶ 0xbd

       The output format is subject to change.

       See also str:from-utf8-bytes.

   <b>str:trim</b> <b>{#str:trim}</b>
              str:trim $str $cutset

       Outputs $str with all leading and trailing Unicode code points contained in $cutset removed.

              ~&gt; str:trim "¡¡¡Hello, Elven!!!" "!¡"
              ▶ 'Hello, Elven'

   <b>str:trim-left</b> <b>{#str:trim-left}</b>
              str:trim-left $str $cutset

       Outputs  $str  with  all  leading  Unicode  code points contained in $cutset removed.  To remove a prefix
       string use str:trim-prefix.

              ~&gt; str:trim-left "¡¡¡Hello, Elven!!!" "!¡"
              ▶ 'Hello, Elven!!!'

   <b>str:trim-prefix</b> <b>{#str:trim-prefix}</b>
              str:trim-prefix $str $prefix

       Outputs $str minus the leading $prefix string.  If $str doesn’t begin with $prefix, $str  is  output  un‐
       changed.

              ~&gt; str:trim-prefix "¡¡¡Hello, Elven!!!" "¡¡¡Hello, "
              ▶ Elven!!!
              ~&gt; str:trim-prefix "¡¡¡Hello, Elven!!!" "¡¡¡Hola, "
              ▶ '¡¡¡Hello, Elven!!!'

   <b>str:trim-right</b> <b>{#str:trim-right}</b>
              str:trim-right $str $cutset

       Outputs  $str  with  all  leading  Unicode  code points contained in $cutset removed.  To remove a suffix
       string use str:trim-suffix.

              ~&gt; str:trim-right "¡¡¡Hello, Elven!!!" "!¡"
              ▶ '¡¡¡Hello, Elven'

   <b>str:trim-space</b> <b>{#str:trim-space}</b>
              str:trim-space $str

       Outputs $str with all leading and trailing white space removed as defined by Unicode.

              ~&gt; str:trim-space " \t\n Hello, Elven \n\t\r\n"
              ▶ 'Hello, Elven'

   <b>str:trim-suffix</b> <b>{#str:trim-suffix}</b>
              str:trim-suffix $str $suffix

       Outputs $str minus the trailing $suffix string.  If $str doesn’t end with $suffix,  $str  is  output  un‐
       changed.

              ~&gt; str:trim-suffix "¡¡¡Hello, Elven!!!" ", Elven!!!"
              ▶ ¡¡¡Hello
              ~&gt; str:trim-suffix "¡¡¡Hello, Elven!!!" ", Klingons!!!"
              ▶ '¡¡¡Hello, Elven!!!'

Elvish 0.17.0                                     Nov 18, 2024                                     <u><a href="../man7/elvish-str.7.html">elvish-str</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>