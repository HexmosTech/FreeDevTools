<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cmake-compile-features - CMake Compile Features Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cmake-data">cmake-data_3.31.6-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cmake-compile-features - CMake Compile Features Reference

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Project  source  code  may  depend  on, or be conditional on, the availability of certain features of the
       compiler.  There are three use-cases which arise: <u>Compile</u> <u>Feature</u> <u>Requirements</u>, <u>Optional</u> <u>Compile</u> <u>Features</u>
       and <u>Conditional</u> <u>Compilation</u> <u>Options</u>.

       While features are typically specified in programming language standards, CMake provides a  primary  user
       interface  based  on  granular  handling  of  the features, not the language standard that introduced the
       feature.

       The <u>CMAKE_C_KNOWN_FEATURES</u>, <u>CMAKE_CUDA_KNOWN_FEATURES</u>,  and  <u>CMAKE_CXX_KNOWN_FEATURES</u>  global  properties
       contain  all  the  features  known  to  CMake,  regardless  of  compiler  support  for  the feature.  The
       <u>CMAKE_C_COMPILE_FEATURES</u>, <u>CMAKE_CUDA_COMPILE_FEATURES</u> , and <u>CMAKE_CXX_COMPILE_FEATURES</u> variables  contain
       all  features  CMake  knows  are  known to the compiler, regardless of language standard or compile flags
       needed to use them.

       Features known to CMake are named mostly following the same convention as the Clang feature test  macros.
       There  are  some  exceptions,  such  as  CMake  using  <b>cxx_final</b>  and  <b>cxx_override</b> instead of the single
       <b>cxx_override_control</b> used by Clang.

       Note that there are no separate  compile  features  properties  or  variables  for  the  <b>OBJC</b>  or  <b>OBJCXX</b>
       languages.   These  are  based  off  <b>C</b>  or  <b>C++</b>  respectively,  so the properties and variables for their
       corresponding base language should be used instead.

</pre><h4><b>COMPILE</b> <b>FEATURE</b> <b>REQUIREMENTS</b></h4><pre>
       Compile feature requirements may be specified with the <u>target_compile_features()</u> command.   For  example,
       if a target must be compiled with compiler support for the <u>cxx_constexpr</u> feature:

          add_library(mylib requires_constexpr.cpp)
          target_compile_features(mylib PRIVATE cxx_constexpr)

       In  processing  the  requirement  for the <b>cxx_constexpr</b> feature, <u><a href="../man1/cmake.1.html">cmake</a>(1)</u> will ensure that the in-use C++
       compiler is capable of the feature, and will add any necessary flags such as <b>-std=gnu++11</b> to the  compile
       lines  of  C++  files in the <b>mylib</b> target.  A <b>FATAL_ERROR</b> is issued if the compiler is not capable of the
       feature.

       The exact compile flags and language standard are deliberately not part of the user  interface  for  this
       use-case.   CMake will compute the appropriate compile flags to use by considering the features specified
       for each target.

       Such compile flags are added even if the compiler supports the particular feature without the  flag.  For
       example,  the  GNU  compiler  supports  variadic templates (with a warning) even if <b>-std=gnu++98</b> is used.
       CMake adds the <b>-std=gnu++11</b> flag if <b>cxx_variadic_templates</b> is specified as a requirement.

       In the above example, <b>mylib</b> requires <b>cxx_constexpr</b> when it is built itself, but consumers  of  <b>mylib</b>  are
       not  required to use a compiler which supports <b>cxx_constexpr</b>.  If the interface of <b>mylib</b> does require the
       <b>cxx_constexpr</b> feature (or any other known feature), that may be specified with the  <b>PUBLIC</b>  or  <b>INTERFACE</b>
       signatures of <u>target_compile_features()</u>:

          add_library(mylib requires_constexpr.cpp)
          # cxx_constexpr is a usage-requirement
          target_compile_features(mylib PUBLIC cxx_constexpr)

          # main.cpp will be compiled with -std=gnu++11 on GNU for cxx_constexpr.
          add_executable(myexe main.cpp)
          target_link_libraries(myexe mylib)

       Feature   requirements   are   evaluated   transitively   by  consuming  the  link  implementation.   See
       <u><a href="../man7/cmake-buildsystem.7.html">cmake-buildsystem</a>(7)</u> for more on transitive behavior of build properties and usage requirements.

   <b>Requiring</b> <b>Language</b> <b>Standards</b>
       In projects that use a large number of commonly available features from a  particular  language  standard
       (e.g.  C++ 11) one may specify a meta-feature (e.g. <b>cxx_std_11</b>) that requires use of a compiler mode that
       is at minimum aware of that standard, but could be greater.  This is  simpler  than  specifying  all  the
       features  individually, but does not guarantee the existence of any particular feature.  Diagnosis of use
       of unsupported features will be delayed until compile time.

       For example, if C++ 11 features are used extensively in a project's header files, then clients must use a
       compiler mode that is no less than C++ 11.  This can be requested with the code:

          target_compile_features(mylib PUBLIC cxx_std_11)

       In this example, CMake will ensure the compiler is invoked in a mode of at-least C++ 11 (or C++  14,  C++
       17,  ...),  adding flags such as <b>-std=gnu++11</b> if necessary.  This applies to sources within <b>mylib</b> as well
       as any dependents (that may include headers from <b>mylib</b>).

       <b>NOTE:</b>
          If the compiler's default standard level is at least that of the requested feature, CMake may omit the
          <b>-std=</b> flag.  The flag may still be added if the compiler's default extensions mode does not match  the
          <u>&lt;LANG&gt;_EXTENSIONS</u> target property, or if the <u>&lt;LANG&gt;_STANDARD</u> target property is set.

   <b>Availability</b> <b>of</b> <b>Compiler</b> <b>Extensions</b>
       The     <u>&lt;LANG&gt;_EXTENSIONS</u>    target    property    defaults    to    the    compiler's    default    (see
       <u>CMAKE_&lt;LANG&gt;_EXTENSIONS_DEFAULT</u>). Note that because most compilers enable extensions by default, this may
       expose portability bugs in user code or in the headers of third-party dependencies.

       <u>&lt;LANG&gt;_EXTENSIONS</u> used to default to <b>ON</b>. See <u>CMP0128</u>.

</pre><h4><b>OPTIONAL</b> <b>COMPILE</b> <b>FEATURES</b></h4><pre>
       Compile features may be preferred if available, without  creating  a  hard  requirement.    This  can  be
       achieved  by  <u>not</u>  specifying  features  with <u>target_compile_features()</u> and instead checking the compiler
       capabilities with preprocessor conditions in project code.

       In this use-case, the project may wish to establish a particular language standard if available from  the
       compiler, and use preprocessor conditions to detect the features actually available.  A language standard
       may  be  established  by  <u>Requiring</u> <u>Language</u> <u>Standards</u> using <u>target_compile_features()</u> with meta-features
       like <b>cxx_std_11</b>, or by setting the <u>CXX_STANDARD</u> target property or <u>CMAKE_CXX_STANDARD</u> variable.

       See  also  policy   <u>CMP0120</u>   and   legacy   documentation   on   <u>Example</u>   <u>Usage</u>   of   the   deprecated
       <u>WriteCompilerDetectionHeader</u> module.

</pre><h4><b>CONDITIONAL</b> <b>COMPILATION</b> <b>OPTIONS</b></h4><pre>
       Libraries may provide entirely different header files depending on requested compiler features.

       For example, a header at <b>with_variadics/interface.h</b> may contain:

          template&lt;int I, int... Is&gt;
          struct Interface;

          template&lt;int I&gt;
          struct Interface&lt;I&gt;
          {
            static int accumulate()
            {
              return I;
            }
          };

          template&lt;int I, int... Is&gt;
          struct Interface
          {
            static int accumulate()
            {
              return I + Interface&lt;Is...&gt;::accumulate();
            }
          };

       while a header at <b>no_variadics/interface.h</b> may contain:

          template&lt;int I1, int I2 = 0, int I3 = 0, int I4 = 0&gt;
          struct Interface
          {
            static int accumulate() { return I1 + I2 + I3 + I4; }
          };

       It may be possible to write an abstraction <b>interface.h</b> header containing something like:

          #ifdef HAVE_CXX_VARIADIC_TEMPLATES
          #include "with_variadics/interface.h"
          #else
          #include "no_variadics/interface.h"
          #endif

       However  this  could  be  unmaintainable  if  there  are many files to abstract. What is needed is to use
       alternative include directories depending on the compiler capabilities.

       CMake provides a <b>COMPILE_FEATURES</b> <u>generator</u> <u>expression</u> to implement such conditions.  This  may  be  used
       with  the build-property commands such as <u>target_include_directories()</u> and <u>target_link_libraries()</u> to set
       the appropriate <u>buildsystem</u> properties:

          add_library(foo INTERFACE)
          set(with_variadics ${CMAKE_CURRENT_SOURCE_DIR}/with_variadics)
          set(no_variadics ${CMAKE_CURRENT_SOURCE_DIR}/no_variadics)
          target_include_directories(foo
            INTERFACE
              "$&lt;$&lt;COMPILE_FEATURES:cxx_variadic_templates&gt;:${with_variadics}&gt;"
              "$&lt;$&lt;NOT:$&lt;COMPILE_FEATURES:cxx_variadic_templates&gt;&gt;:${no_variadics}&gt;"
            )

       Consuming code then simply links to the <b>foo</b> target as usual  and  uses  the  feature-appropriate  include
       directory

          add_executable(consumer_with consumer_with.cpp)
          target_link_libraries(consumer_with foo)
          set_property(TARGET consumer_with CXX_STANDARD 11)

          add_executable(consumer_no consumer_no.cpp)
          target_link_libraries(consumer_no foo)

</pre><h4><b>SUPPORTED</b> <b>COMPILERS</b></h4><pre>
       CMake  is currently aware of the <u>C++</u> <u>standards</u> and <u>compile</u> <u>features</u> available from the following <u>compiler</u>
       <u>ids</u> as of the versions specified for each:

       • <b>AppleClang</b>: Apple Clang for Xcode versions 4.4+.

       • <b>Clang</b>: Clang compiler versions 2.9+.

       • <b>GNU</b>: GNU compiler versions 4.4+.

       • <b>MSVC</b>: Microsoft Visual Studio versions 2010+.

       • <b>SunPro</b>: Oracle SolarisStudio versions 12.4+.

       • <b>Intel</b>: Intel compiler versions 12.1+.

       CMake is currently aware of the <u>C</u> <u>standards</u> and <u>compile</u> <u>features</u> available from  the  following  <u>compiler</u>
       <u>ids</u> as of the versions specified for each:

       • all compilers and versions listed above for C++.

       • <b>GNU</b>: GNU compiler versions 3.4+

       CMake  is  currently  aware  of  the  <u>C++</u>  <u>standards</u> and their associated meta-features (e.g. <b>cxx_std_11</b>)
       available from the following <u>compiler</u> <u>ids</u> as of the versions specified for each:

       • <b>Cray</b>: Cray Compiler Environment version 8.1+.

       • <b>Fujitsu</b>: Fujitsu HPC compiler 4.0+.

       • <b>PGI</b>: PGI version 12.10+.

       • <b>NVHPC</b>: NVIDIA HPC compilers version 11.0+.

       • <b>TI</b>: Texas Instruments compiler.

       • <b>TIClang</b>: Texas Instruments Clang-based compilers.

       • <b>XL</b>: IBM XL version 10.1+.

       CMake is currently aware of the <u>C</u> <u>standards</u> and their associated meta-features (e.g. <b>c_std_99</b>)  available
       from the following <u>compiler</u> <u>ids</u> as of the versions specified for each:

       • all compilers and versions listed above with only meta-features for C++.

       CMake  is  currently  aware  of  the <u>CUDA</u> <u>standards</u> and their associated meta-features (e.g. <b>cuda_std_11</b>)
       available from the following <u>compiler</u> <u>ids</u> as of the versions specified for each:

       • <b>Clang</b>: Clang compiler 5.0+.

       • <b>NVIDIA</b>: NVIDIA nvcc compiler 7.5+.

</pre><h4><b>LANGUAGE</b> <b>STANDARD</b> <b>FLAGS</b></h4><pre>
       In  order  to  satisfy  requirements  specified  by  the   <u>target_compile_features()</u>   command   or   the
       <u>CMAKE_&lt;LANG&gt;_STANDARD</u>  variable,  CMake  may  pass  a  language  standard  flag  to the compiler, such as
       <b>-std=c++11</b>.

       For <u>Visual</u> <u>Studio</u> <u>Generators</u>, CMake cannot precisely control the placement of the language standard  flag
       on  the  compiler  command  line.  For <u>Ninja</u> <u>Generators</u>, <u>Makefile</u> <u>Generators</u>, and <u>Xcode</u>, CMake places the
       language   standard   flag   just   after   the   language-wide   flags   from   <u>CMAKE_&lt;LANG&gt;_FLAGS</u>   and
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>.

       Changed  in  version  3.26:  The  language  standard  flag  is  placed  before  flags  specified by other
       abstractions such as the <u>target_compile_options()</u> command.  Prior to CMake 3.26,  the  language  standard
       flag was placed after them.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2000-2024 Kitware, Inc. and Contributors

3.31.6                                            May 23, 2025                         <u><a href="../man7/CMAKE-COMPILE-FEATURES.7.html">CMAKE-COMPILE-FEATURES</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>