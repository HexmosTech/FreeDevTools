<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ossl-guide-libcrypto-introduction, crypto - OpenSSL Guide: An introduction to libcrypto</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openssl">openssl_3.5.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ossl-guide-libcrypto-introduction, crypto - OpenSSL Guide: An introduction to libcrypto

</pre><h4><b>INTRODUCTION</b></h4><pre>
       The OpenSSL cryptography library ("libcrypto") enables access to a wide range of cryptographic algorithms
       used in various Internet standards. The services provided by this library are used by the OpenSSL
       implementations of TLS and CMS, and they have also been used to implement many other third party products
       and protocols.

       The functionality includes symmetric encryption, public key cryptography, key agreement, certificate
       handling, cryptographic hash functions, cryptographic pseudo-random number generators, message
       authentication codes (MACs), key derivation functions (KDFs), and various utilities.

   <b>Algorithms</b>
       Cryptographic primitives such as the SHA256 digest, or AES encryption are referred to in OpenSSL as
       "algorithms". Each algorithm may have multiple implementations available for use. For example the RSA
       algorithm is available as a "default" implementation suitable for general use, and a "fips"
       implementation which has been validated to FIPS 140 standards for situations where that is important. It
       is also possible that a third party could add additional implementations such as in a hardware security
       module (HSM).

       Algorithms are implemented in providers. See <b><a href="../man7/ossl-guide-libraries-introduction.7.html">ossl-guide-libraries-introduction</a></b>(7) for information about
       providers.

   <b>Operations</b>
       Different algorithms can be grouped together by their purpose. For example there are algorithms for
       encryption, and different algorithms for digesting data.  These different groups are known as
       "operations" in OpenSSL. Each operation has a different set of functions associated with it. For example
       to perform an encryption operation using AES (or any other encryption algorithm) you would use the
       encryption functions detailed on the <b><a href="../man3/EVP_EncryptInit.3.html">EVP_EncryptInit</a></b>(3) page. Or to perform a digest operation using
       SHA256 then you would use the digesting functions on the <b><a href="../man3/EVP_DigestInit.3.html">EVP_DigestInit</a></b>(3) page.

</pre><h4><b>ALGORITHM</b> <b>FETCHING</b></h4><pre>
       In order to use an algorithm an implementation for it must first be "fetched".  Fetching is the process
       of looking through the available implementations, applying selection criteria (via a property query
       string), and finally choosing the implementation that will be used.

       Two types of fetching are supported by OpenSSL - "Explicit fetching" and "Implicit fetching".

   <b>Explicit</b> <b>fetching</b>
       Explicit fetching involves directly calling a specific API to fetch an algorithm implementation from a
       provider. This fetched object can then be passed to other APIs. These explicit fetching functions usually
       have the name "APINAME_fetch", where "APINAME" is the name of the operation. For example <b><a href="../man3/EVP_MD_fetch.3.html">EVP_MD_fetch</a></b>(3)
       can be used to explicitly fetch a digest algorithm implementation. The user is responsible for freeing
       the object returned from the "APINAME_fetch" function using "APINAME_free" when it is no longer needed.

       These fetching functions follow a fairly common pattern, where three arguments are passed:

       The library context
           See  <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3)  for  a  more  detailed  description.   This  may be NULL to signify the default
           (global) library context, or a context created by the user. Only providers  loaded  in  this  library
           context  (see <b><a href="../man3/OSSL_PROVIDER_load.3.html">OSSL_PROVIDER_load</a></b>(3)) will be considered by the fetching function. In case no provider
           has been loaded in this library context then the default provider will be loaded as a  fallback  (see
           <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7)).

       An identifier
           For  all currently implemented fetching functions this is the algorithm name.  Each provider supports
           a list of algorithm implementations. See the provider specific documentation for information  on  the
           algorithm   implementations   available   in   each   provider:   "OPERATIONS   AND   ALGORITHMS"  in
           <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7), "OPERATIONS  AND  ALGORITHMS"  in  <b><a href="../man7/OSSL_PROVIDER-FIPS.7.html">OSSL_PROVIDER-FIPS</a></b>(7),  "OPERATIONS  AND
           ALGORITHMS" in <b><a href="../man7/OSSL_PROVIDER-legacy.7.html">OSSL_PROVIDER-legacy</a></b>(7) and "OPERATIONS AND ALGORITHMS" in <b><a href="../man7/OSSL_PROVIDER-base.7.html">OSSL_PROVIDER-base</a></b>(7).

           Note,  while  providers  may  register algorithms against a list of names using a string with a colon
           separated list of names, fetching algorithms using that format is currently unsupported.

       A property query string
           The property query string used to guide selection of  the  algorithm  implementation.  See  "PROPERTY
           QUERY STRINGS" in <b><a href="../man7/ossl-guide-libraries-introduction.7.html">ossl-guide-libraries-introduction</a></b>(7).

       The algorithm implementation that is fetched can then be used with other diverse functions that use them.
       For  example  the <b><a href="../man3/EVP_DigestInit_ex.3.html">EVP_DigestInit_ex</a></b>(3) function takes as a parameter an <b>EVP_MD</b> object which may have been
       returned from an earlier call to <b><a href="../man3/EVP_MD_fetch.3.html">EVP_MD_fetch</a></b>(3).

   <b>Implicit</b> <b>fetching</b>
       OpenSSL has a number of functions that return an algorithm object with no associated implementation, such
       as <b><a href="../man3/EVP_sha256.3.html">EVP_sha256</a></b>(3),  <b><a href="../man3/EVP_aes_128_cbc.3.html">EVP_aes_128_cbc</a></b>(3),  <b><a href="../man3/EVP_get_cipherbyname.3.html">EVP_get_cipherbyname</a></b>(3)  or  <b><a href="../man3/EVP_get_digestbyname.3.html">EVP_get_digestbyname</a></b>(3).  These  are
       present for compatibility with OpenSSL before version 3.0 where explicit fetching was not available.

       When  they  are  used  with  functions  like  <b><a href="../man3/EVP_DigestInit_ex.3.html">EVP_DigestInit_ex</a></b>(3)  or  <b><a href="../man3/EVP_CipherInit_ex.3.html">EVP_CipherInit_ex</a></b>(3),  the actual
       implementation to be used is fetched implicitly using default search criteria (which uses  NULL  for  the
       library context and property query string).

       In  some cases implicit fetching can also occur when a NULL algorithm parameter is supplied. In this case
       an algorithm implementation is implicitly fetched using default search criteria  and  an  algorithm  name
       that is consistent with the context in which it is being used.

       Functions  that  use  an  <b>EVP_PKEY_CTX</b>  or  an  <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3), such as <b><a href="../man3/EVP_DigestSignInit.3.html">EVP_DigestSignInit</a></b>(3), all fetch the
       implementations implicitly. Usually the algorithm to fetch is determined based on the type of key that is
       being used and the function that has been called.

   <b>Performance</b>
       If you perform the same operation many times with the same algorithm then it  is  recommended  to  use  a
       single  explicit  fetch  of the algorithm and then reuse the explicitly fetched algorithm each subsequent
       time. This will typically be faster than implicitly fetching the algorithm every time you use it. See  an
       example of Explicit fetching in "USING ALGORITHMS IN APPLICATIONS".

       Prior  to OpenSSL 3.0, functions such as <b>EVP_sha256()</b> which return a "const" object were used directly to
       indicate the algorithm to use in various function calls. If you pass the return value  of  one  of  these
       convenience  functions  to  an  operation  then you are using implicit fetching. If you are converting an
       application that worked with an OpenSSL version prior to OpenSSL 3.0 then consider changing instances  of
       implicit fetching to explicit fetching instead.

       If  an  explicitly  fetched  object  is  not  passed to an operation, then any implicit fetch will use an
       internally cached prefetched object, but it will still be slower  than  passing  the  explicitly  fetched
       object directly.

       The following functions can be used for explicit fetching:

       <b><a href="../man3/EVP_MD_fetch.3.html">EVP_MD_fetch</a></b>(3)
           Fetch a message digest/hashing algorithm implementation.

       <b><a href="../man3/EVP_CIPHER_fetch.3.html">EVP_CIPHER_fetch</a></b>(3)
           Fetch a symmetric cipher algorithm implementation.

       <b><a href="../man3/EVP_KDF_fetch.3.html">EVP_KDF_fetch</a></b>(3)
           Fetch a Key Derivation Function (KDF) algorithm implementation.

       <b><a href="../man3/EVP_MAC_fetch.3.html">EVP_MAC_fetch</a></b>(3)
           Fetch a Message Authentication Code (MAC) algorithm implementation.

       <b><a href="../man3/EVP_KEM_fetch.3.html">EVP_KEM_fetch</a></b>(3)
           Fetch a Key Encapsulation Mechanism (KEM) algorithm implementation

       <b><a href="../man3/OSSL_ENCODER_fetch.3.html">OSSL_ENCODER_fetch</a></b>(3)
           Fetch an encoder algorithm implementation (e.g. to encode keys to a specified format).

       <b><a href="../man3/OSSL_DECODER_fetch.3.html">OSSL_DECODER_fetch</a></b>(3)
           Fetch a decoder algorithm implementation (e.g. to decode keys from a specified format).

       <b><a href="../man3/EVP_RAND_fetch.3.html">EVP_RAND_fetch</a></b>(3)
           Fetch a Pseudo Random Number Generator (PRNG) algorithm implementation.

       See   "OPERATIONS   AND   ALGORITHMS"   in   <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7),  "OPERATIONS  AND  ALGORITHMS"  in
       <b><a href="../man7/OSSL_PROVIDER-FIPS.7.html">OSSL_PROVIDER-FIPS</a></b>(7),  "OPERATIONS  AND  ALGORITHMS"  in  <b><a href="../man7/OSSL_PROVIDER-legacy.7.html">OSSL_PROVIDER-legacy</a></b>(7)  and  "OPERATIONS  AND
       ALGORITHMS" in <b><a href="../man7/OSSL_PROVIDER-base.7.html">OSSL_PROVIDER-base</a></b>(7) for a list of algorithm names that can be fetched.

</pre><h4><b>FETCHING</b> <b>EXAMPLES</b></h4><pre>
       The following section provides a series of examples of fetching algorithm implementations.

       Fetch  any  available  implementation  of SHA2-256 in the default context. Note that some algorithms have
       aliases. So "SHA256" and "SHA2-256" are synonymous:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", NULL);
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch any available implementation of AES-128-CBC in the default context:

        EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, "AES-128-CBC", NULL);
        ...
        EVP_CIPHER_free(cipher);

       Fetch an implementation of SHA2-256 from the default provider in the default context:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider=default");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch an implementation of SHA2-256 that is not from the default provider in the default context:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider!=default");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch an implementation of SHA2-256 that is preferably from the FIPS provider in the default context:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider=?fips");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch an implementation of SHA2-256 from the default provider in the specified library context:

        EVP_MD *md = EVP_MD_fetch(libctx, "SHA2-256", "provider=default");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Load the legacy provider into the default context and then fetch an implementation of WHIRLPOOL from it:

        /* This only needs to be done once - usually at application start up */
        OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, "legacy");

        EVP_MD *md = EVP_MD_fetch(NULL, "WHIRLPOOL", "provider=legacy");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Note that in the above example the property string "provider=legacy" is optional since, assuming no other
       providers have been loaded, the only implementation of the  "whirlpool"  algorithm  is  in  the  "legacy"
       provider.  Also  note that the default provider should be explicitly loaded if it is required in addition
       to other providers:

        /* This only needs to be done once - usually at application start up */
        OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, "legacy");
        OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, "default");

        EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, "whirlpool", NULL);
        EVP_MD *md_sha256 = EVP_MD_fetch(NULL, "SHA2-256", NULL);
        ...
        <a href="../manmd_whirlpool/EVP_MD_free.md_whirlpool.html">EVP_MD_free</a>(md_whirlpool);
        <a href="../manmd_sha256/EVP_MD_free.md_sha256.html">EVP_MD_free</a>(md_sha256);

</pre><h4><b>USING</b> <b>ALGORITHMS</b> <b>IN</b> <b>APPLICATIONS</b></h4><pre>
       Cryptographic algorithms are made available to applications through use of the "EVP" APIs.  Each  of  the
       various  operations  such as encryption, digesting, message authentication codes, etc., have a set of EVP
       function calls that can be invoked to use them. See the <b><a href="../man7/evp.7.html">evp</a></b>(7) page for further details.

       Most of these follow a common pattern. A "context" object is first created.  For  example  for  a  digest
       operation  you  would  use  an  <b>EVP_MD_CTX</b>,  and  for an encryption/decryption operation you would use an
       <b>EVP_CIPHER_CTX</b>. The operation is then initialised ready for use  via  an  "init"  function  -  optionally
       passing  in  a  set  of  parameters  (using the <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) type) to configure how the operation should
       behave. Next data is fed into the operation in a series of "update" calls.  The  operation  is  finalised
       using  a "final" call which will typically provide some kind of output. Finally the context is cleaned up
       and freed.

       The following shows a complete example for doing this  process  for  digesting  data  using  SHA256.  The
       process is similar for other operations such as encryption/decryption, signatures, message authentication
       codes,  etc.  Additional  examples  can  be  found  in  the  OpenSSL  demos  (see  "DEMO APPLICATIONS" in
       <b><a href="../man7/ossl-guide-libraries-introduction.7.html">ossl-guide-libraries-introduction</a></b>(7)).

        #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/bio.h&gt;
        #include &lt;openssl/err.h&gt;

        int main(void)
        {
            EVP_MD_CTX *ctx = NULL;
            EVP_MD *sha256 = NULL;
            const unsigned char msg[] = {
                0x00, 0x01, 0x02, 0x03
            };
            unsigned int len = 0;
            unsigned char *outdigest = NULL;
            int ret = 1;

            /* Create a context for the digest operation */
            ctx = EVP_MD_CTX_new();
            if (ctx == NULL)
                goto err;

            /*
             * Fetch the SHA256 algorithm implementation for doing the digest. We're
             * using the "default" library context here (first NULL parameter), and
             * we're not supplying any particular search criteria for our SHA256
             * implementation (second NULL parameter). Any SHA256 implementation will
             * do.
             * In a larger application this fetch would just be done once, and could
             * be used for multiple calls to other operations such as EVP_DigestInit_ex().
             */
            sha256 = EVP_MD_fetch(NULL, "SHA256", NULL);
            if (sha256 == NULL)
                goto err;

           /* Initialise the digest operation */
           if (!EVP_DigestInit_ex(ctx, sha256, NULL))
               goto err;

            /*
             * Pass the message to be digested. This can be passed in over multiple
             * EVP_DigestUpdate calls if necessary
             */
            if (!EVP_DigestUpdate(ctx, msg, <a href="../manmsg/sizeof.msg.html">sizeof</a>(msg)))
                goto err;

            /* Allocate the output buffer */
            outdigest = OPENSSL_malloc(EVP_MD_get_size(sha256));
            if (outdigest == NULL)
                goto err;

            /* Now calculate the digest itself */
            if (!EVP_DigestFinal_ex(ctx, outdigest, &amp;len))
                goto err;

            /* Print out the digest result */
            BIO_dump_fp(stdout, outdigest, len);

            ret = 0;

         err:
            /* Clean up all the resources we allocated */
            OPENSSL_free(outdigest);
            EVP_MD_free(sha256);
            EVP_MD_CTX_free(ctx);
            if (ret != 0)
               ERR_print_errors_fp(stderr);
            return ret;
        }

</pre><h4><b>ENCODING</b> <b>AND</b> <b>DECODING</b> <b>KEYS</b></h4><pre>
       Many algorithms require the use of a key. Keys can be generated  dynamically  using  the  EVP  APIs  (for
       example  see  <b><a href="../man3/EVP_PKEY_Q_keygen.3.html">EVP_PKEY_Q_keygen</a></b>(3)).  However  it  is  often  necessary  to  save  or load keys (or their
       associated parameters) to or from some external format such as  PEM  or  DER  (see  <b><a href="../man7/openssl-glossary.7.html">openssl-glossary</a></b>(7)).
       OpenSSL uses encoders and decoders to perform this task.

       Encoders  and  decoders  are  just  algorithm  implementations  in  the  same  way as any other algorithm
       implementation in OpenSSL. They are implemented by providers.  The  OpenSSL  encoders  and  decoders  are
       available in the default provider. They are also duplicated in the base provider.

       For  information  about encoders see <b><a href="../man3/OSSL_ENCODER_CTX_new_for_pkey.3.html">OSSL_ENCODER_CTX_new_for_pkey</a></b>(3). For information about decoders see
       <b><a href="../man3/OSSL_DECODER_CTX_new_for_pkey.3.html">OSSL_DECODER_CTX_new_for_pkey</a></b>(3).

       As well as using encoders/decoders directly there are also some helper functions that  can  be  used  for
       certain   well   known   and   commonly   used   formats.  For  example  see  <b><a href="../man3/PEM_read_PrivateKey.3.html">PEM_read_PrivateKey</a></b>(3)  and
       <b><a href="../man3/PEM_write_PrivateKey.3.html">PEM_write_PrivateKey</a></b>(3) for information about reading and writing key data from PEM encoded files.

</pre><h4><b>FURTHER</b> <b>READING</b></h4><pre>
       See <b><a href="../man7/ossl-guide-libssl-introduction.7.html">ossl-guide-libssl-introduction</a></b>(7) for an introduction to using "libssl".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/openssl.1.html">openssl</a></b>(1), <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man7/evp.7.html">evp</a></b>(7), <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3), <b><a href="../man7/openssl-threads.7.html">openssl-threads</a></b>(7),  <b><a href="../man7/property.7.html">property</a></b>(7),  <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7),
       <b><a href="../man7/OSSL_PROVIDER-base.7.html">OSSL_PROVIDER-base</a></b>(7),     <b><a href="../man7/OSSL_PROVIDER-FIPS.7.html">OSSL_PROVIDER-FIPS</a></b>(7),     <b><a href="../man7/OSSL_PROVIDER-legacy.7.html">OSSL_PROVIDER-legacy</a></b>(7),     <b><a href="../man7/OSSL_PROVIDER-null.7.html">OSSL_PROVIDER-null</a></b>(7),
       <b><a href="../man7/openssl-glossary.7.html">openssl-glossary</a></b>(7), <b><a href="../man7/provider.7.html">provider</a></b>(7)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04            <u><a href="../man7SSL/OSSL-GUIDE-LIBCRYPTO-INTRODUCTION.7SSL.html">OSSL-GUIDE-LIBCRYPTO-INTRODUCTION</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>