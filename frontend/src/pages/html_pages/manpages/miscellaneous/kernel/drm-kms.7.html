<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>drm-kms - Kernel Mode-Setting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdrm-dev">libdrm-dev_2.4.125-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       drm-kms - Kernel Mode-Setting

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;xf86drm.h&gt;</b>

       <b>#include</b> <b>&lt;xf86drmMode.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Each  DRM device provides access to manage which monitors and displays are currently used and what frames
       to be displayed. This task is called <u>Kernel</u> <u>Mode-Setting</u> (KMS). Historically, this was done in user-space
       and called <u>User-space</u> <u>Mode-Setting</u> (UMS). Almost all open-source drivers now provide the KMS  kernel  API
       to  do  this  in the kernel, however, many non-open-source binary drivers from different vendors still do
       not support this. You can use <b><a href="../man3/drmModeSettingSupported.3.html">drmModeSettingSupported</a></b>(3) to check whether your driver supports  this.  To
       understand  how  KMS  works,  we  need  to  introduce  5 objects: <u>CRTCs</u>, <u>Planes</u>, <u>Encoders</u>, <u>Connectors</u> and
       <u>Framebuffers</u>.

       <b>CRTCs</b>  A <u>CRTC</u> short for <u>CRT</u> <u>Controller</u> is an abstraction representing a part of the chip that contains  a
              pointer  to  a  scanout  buffer.   Therefore,  the  number  of CRTCs available determines how many
              independent scanout buffers can be active at any given time. The CRTC structure  contains  several
              fields  to  support  this: a pointer to some video memory (abstracted as a frame-buffer object), a
              list of driven connectors, a display mode and an (x, y) offset into the video  memory  to  support
              panning  or  configurations  where  one  piece of video memory spans multiple CRTCs. A CRTC is the
              central point where configuration of displays happens. You select  which  objects  to  use,  which
              modes and which parameters and then configure each CRTC via <b><a href="../man3/drmModeCrtcSet.3.html">drmModeCrtcSet</a></b>(3) to drive the display
              devices.

       <b>Planes</b> A  <u>plane</u> respresents an image source that can be blended with or overlayed on top of a CRTC during
              the scanout process. Planes are associated with a frame-buffer to crop  a  portion  of  the  image
              memory  (source) and optionally scale it to a destination size. The result is then blended with or
              overlayed on top of a CRTC. Planes are not provided by all hardware and the  number  of  available
              planes  is  limited.  If  planes are not available or if not enough planes are available, the user
              should fall back to normal software blending (via GPU or CPU).

       <b>Encoders</b>
              An <u>encoder</u> takes pixel data from a CRTC and converts it to a  format  suitable  for  any  attached
              connectors. On some devices, it may be possible to have a CRTC send data to more than one encoder.
              In that case, both encoders would receive data from the same scanout buffer, resulting in a <u>cloned</u>
              display configuration across the connectors attached to each encoder.

       <b>Connectors</b>
              A  <u>connector</u>  is the final destination of pixel-data on a device, and usually connects directly to
              an external display device like a monitor or laptop panel. A connector can only be attached to one
              encoder at a time. The connector is also  the  structure  where  information  about  the  attached
              display  is  kept,  so it contains fields for display data, <u>EDID</u> data, <u>DPMS</u> and <u>connection</u> <u>status</u>,
              and information about modes supported on the attached displays.

       <b>Framebuffers</b>
              <u>Framebuffers</u> are abstract memory objects that provide a source of pixel data to scanout to a CRTC.
              Applications explicitly request the creation of  framebuffers  and  can  control  their  behavior.
              Framebuffers  rely on the underneath memory manager for low-level memory operations. When creating
              a framebuffer, applications pass a memory handle through the API which is used as backing storage.
              The framebuffer itself is only an abstract object with no data. It just refers to  memory  buffers
              that must be created with the <b><a href="../man7/drm-memory.7.html">drm-memory</a></b>(7) API.

   <b>Mode-Setting</b>
       Before  mode-setting can be performed, an application needs to call <b><a href="../man3/drmSetMaster.3.html">drmSetMaster</a></b>(3) to become <u>DRM-Master</u>.
       It then has exclusive access to the KMS API. A call to <b><a href="../man3/drmModeGetResources.3.html">drmModeGetResources</a></b>(3) returns a  list  of  <u>CRTCs</u>,
       <u>Connectors</u>, <u>Encoders</u> and <u>Planes</u>.

       Normal  procedure  now  includes:  First,  you  select which connectors you want to use. Users are mostly
       interested in which monitor or display-panel is active so you need to make sure to arrange  them  in  the
       correct  logical order and select the correct ones to use. For each connector, you need to find a CRTC to
       drive this connector. If you want to clone output to two or more connectors, you may use  a  single  CRTC
       for  all  cloned connectors (if the hardware supports this). To find a suitable CRTC, you need to iterate
       over the list of encoders that are available for each connector. Each encoder contains a  list  of  CRTCs
       that  it can work with and you simply select one of these CRTCs. If you later program the CRTC to control
       a connector, it automatically selects the best encoder.  However, this procedure is needed so  your  CRTC
       has  at  least  one  working  encoder for the selected connector. See the <u>Examples</u> section below for more
       information.

       All valid modes for a connector can be retrieved with a call to <b><a href="../man3/drmModeGetConnector.3.html">drmModeGetConnector</a></b>(3) You need to select
       the mode you want to use and save it.  The first mode in the list is the default mode  with  the  highest
       resolution possible and often a suitable choice.

       After  you  have a working connector+CRTC+mode combination, you need to create a framebuffer that is used
       for scanout. Memory buffer allocation is driver-dependent and described in  <b><a href="../man7/drm-memory.7.html">drm-memory</a></b>(7).  You  need  to
       create a buffer big enough for your selected mode. Now you can create a framebuffer object that uses your
       memory-buffer as scanout buffer. You can do this with <b><a href="../man3/drmModeAddFB.3.html">drmModeAddFB</a></b>(3) and <b><a href="../man3/drmModeAddFB2.3.html">drmModeAddFB2</a></b>(3).

       As  a  last step, you want to program your CRTC to drive your selected connector.  You can do this with a
       call to <b><a href="../man3/drmModeSetCrtc.3.html">drmModeSetCrtc</a></b>(3).

   <b>Page-Flipping</b>
       A call to <b><a href="../man3/drmModeSetCrtc.3.html">drmModeSetCrtc</a></b>(3) is executed immediately and forces the CRTC to use the new scanout buffer. If
       you want smooth-transitions without tearing, you probably use double-buffering. You need  to  create  one
       framebuffer  object  for  each  buffer you use. You can then call <b><a href="../man3/drmModeSetCrtc.3.html">drmModeSetCrtc</a></b>(3) on the next buffer to
       flip. If you want to synchronize your flips with <u>vertical-blanks</u>, you can  use  <b><a href="../man3/drmModePageFlip.3.html">drmModePageFlip</a></b>(3)  which
       schedules your page-flip for the next <u>vblank</u>.

   <b>Planes</b>
       Planes  are  controlled  independently  from  CRTCs. That is, a call to <b><a href="../man3/drmModeSetCrtc.3.html">drmModeSetCrtc</a></b>(3) does not affect
       planes. Instead, you need to call <b><a href="../man3/drmModeSetPlane.3.html">drmModeSetPlane</a></b>(3) to configure a plane. This requires the plane ID,  a
       CRTC, a framebuffer and offsets into the plane-framebuffer and the CRTC-framebuffer. The CRTC then blends
       the  content from the plane over the CRTC framebuffer buffer during scanout. As this does not involve any
       software-blending, it is way faster than traditional blending. However, plane resources are limited.  See
       <b><a href="../man3/drmModeGetPlaneResources.3.html">drmModeGetPlaneResources</a></b>(3) for more information.

   <b>Cursors</b>
       Similar  to  planes,  many  hardware also supports cursors. A cursor is a very small buffer with an image
       that is blended over  the  CRTC  framebuffer.  You  can  set  a  different  cursor  for  each  CRTC  with
       <b><a href="../man3/drmModeSetCursor.3.html">drmModeSetCursor</a></b>(3)  and move it on the screen with <b><a href="../man3/drmModeMoveCursor.3.html">drmModeMoveCursor</a></b>(3).  This allows to move the cursor
       on the screen without rerendering. If no hardware cursors are supported, you need to  rerender  for  each
       frame the cursor is moved.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Some  examples  of  how  basic  mode-setting  can be done. See the man-page of each DRM function for more
       information.

   <b>CRTC/Encoder</b> <b>Selection</b>
       If you retrieved all display configuration information via  <b><a href="../man3/drmModeGetResources.3.html">drmModeGetResources</a></b>(3)  as  <b>drmModeRes</b>  <b>*res</b>,
       selected  a  connector  from  the  list  in  <b>res-&gt;connectors</b>  and  retrieved the connector-information as
       <b>drmModeConnector</b> <b>*conn</b> via <b><a href="../man3/drmModeGetConnector.3.html">drmModeGetConnector</a></b>(3) then this example shows, how you can  find  a  suitable
       CRTC id to drive this connector. This function takes a file-descriptor to the DRM device (see <b><a href="../man3/drmOpen.3.html">drmOpen</a></b>(3))
       as  <b>fd</b>,  a  pointer to the retrieved resources as <b>res</b> and a pointer to the selected connector as <b>conn</b>. It
       returns an integer smaller than 0 on failure, otherwise, a valid CRTC id is returned.

          static int modeset_find_crtc(int fd, drmModeRes *res, drmModeConnector *conn)
          {
              drmModeEncoder *enc;
              unsigned int i, j;

              /* iterate all encoders of this connector */
              for (i = 0; i &lt; conn-&gt;count_encoders; ++i) {
                  enc = drmModeGetEncoder(fd, conn-&gt;encoders[i]);
                  if (!enc) {
                      /* cannot retrieve encoder, ignoring... */
                      continue;
                  }

                  /* iterate all global CRTCs */
                  for (j = 0; j &lt; res-&gt;count_crtcs; ++j) {
                      /* check whether this CRTC works with the encoder */
                      if (!(enc-&gt;possible_crtcs &amp; (1 &lt;&lt; j)))
                          continue;

                      /* Here you need to check that no other connector
                       * currently uses the CRTC with id "crtc". If you intend
                       * to drive one connector only, then you can skip this
                       * step. Otherwise, simply scan your list of configured
                       * connectors and CRTCs whether this CRTC is already
                       * used. If it is, then simply continue the search here. */
                      if (res-&gt;crtcs[j] "is unused") {
                          drmModeFreeEncoder(enc);
                          return res-&gt;crtcs[j];
                      }
                  }

                  drmModeFreeEncoder(enc);
              }

              /* cannot find a suitable CRTC */
              return -ENOENT;
          }

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Bugs in this manual should be reported to
        &lt;https://gitlab.freedesktop.org/mesa/libdrm/-/issues&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/drm.7.html">drm</a></b>(7),    <b><a href="../man7/drm-memory.7.html">drm-memory</a></b>(7),    <b><a href="../man3/drmModeGetResources.3.html">drmModeGetResources</a></b>(3),    <b><a href="../man3/drmModeGetConnector.3.html">drmModeGetConnector</a></b>(3),     <b><a href="../man3/drmModeGetEncoder.3.html">drmModeGetEncoder</a></b>(3),
       <b><a href="../man3/drmModeGetCrtc.3.html">drmModeGetCrtc</a></b>(3), <b><a href="../man3/drmModeSetCrtc.3.html">drmModeSetCrtc</a></b>(3), <b><a href="../man3/drmModeGetFB.3.html">drmModeGetFB</a></b>(3), <b><a href="../man3/drmModeAddFB.3.html">drmModeAddFB</a></b>(3), <b><a href="../man3/drmModeAddFB2.3.html">drmModeAddFB2</a></b>(3), <b><a href="../man3/drmModeRmFB.3.html">drmModeRmFB</a></b>(3),
       <b><a href="../man3/drmModePageFlip.3.html">drmModePageFlip</a></b>(3),       <b><a href="../man3/drmModeGetPlaneResources.3.html">drmModeGetPlaneResources</a></b>(3),       <b><a href="../man3/drmModeGetPlane.3.html">drmModeGetPlane</a></b>(3),      <b><a href="../man3/drmModeSetPlane.3.html">drmModeSetPlane</a></b>(3),
       <b><a href="../man3/drmModeSetCursor.3.html">drmModeSetCursor</a></b>(3),          <b><a href="../man3/drmModeMoveCursor.3.html">drmModeMoveCursor</a></b>(3),           <b><a href="../man3/drmSetMaster.3.html">drmSetMaster</a></b>(3),           <b><a href="../man3/drmAvailable.3.html">drmAvailable</a></b>(3),
       <b><a href="../man3/drmCheckModesettingSupported.3.html">drmCheckModesettingSupported</a></b>(3), <b><a href="../man3/drmOpen.3.html">drmOpen</a></b>(3)

                                                 September 2012                                       <u><a href="../man7/DRM-KMS.7.html">DRM-KMS</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>