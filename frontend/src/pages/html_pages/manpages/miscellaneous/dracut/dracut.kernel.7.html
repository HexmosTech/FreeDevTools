<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dracut.cmdline - dracut kernel command line options</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dracut-core">dracut-core_107-1ubuntu5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dracut.cmdline - dracut kernel command line options

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The root device used by the kernel is specified in the boot configuration file on the kernel command
       line, as always.

       The traditional <u>root=/dev/sda1</u> style device specification is allowed, but not encouraged. The root device
       should better be identified by LABEL or UUID. If a label is used, as in <u>root=LABEL=&lt;label_of_root&gt;</u> the
       initramfs will search all available devices for a filesystem with the appropriate label, and mount that
       device as the root filesystem. <u>root=UUID=&lt;uuidnumber&gt;</u> will mount the partition with that UUID as the root
       filesystem.

       In the following all kernel command line parameters, which are processed by dracut, are described.

       "rd.*" parameters mentioned without "=" are boolean parameters. They can be turned on/off by setting them
       to {0|1}. If the assignment with "=" is missing "=1" is implied. For example <u>rd.info</u> can be turned off
       with <u>rd.info=0</u> or turned on with <u>rd.info=1</u> or <u>rd.info</u>. The last value in the kernel command line is the
       value, which is honored.

   <b>Standard</b>
       <b>init=</b><u>&lt;path</u> <u>to</u> <u>real</u> <u>init&gt;</u>
           specify the path to the init program to be started after the initramfs has finished

       <b>root=</b><u>&lt;path</u> <u>to</u> <u>blockdevice&gt;</u>
           specify the block device to use as the root filesystem.

           <b>Example</b> <b>1.</b> <b>Example</b>

               root=/dev/sda1
               root=/dev/disk/by-path/pci-0000:00:1f.1-scsi-0:0:1:0-part1
               root=/dev/disk/by-label/Root
               root=LABEL=Root
               root=/dev/disk/by-uuid/3f5ad593-4546-4a94-a374-bcfb68aa11f7
               root=UUID=3f5ad593-4546-4a94-a374-bcfb68aa11f7
               root=PARTUUID=3f5ad593-4546-4a94-a374-bcfb68aa11f7

       <b>rootfstype=</b><u>&lt;filesystem</u> <u>type&gt;</u>
           "auto" if not specified.

           <b>Example</b> <b>2.</b> <b>Example</b>

               rootfstype=ext4

       <b>rootflags=</b><u>&lt;mount</u> <u>options&gt;</u>
           specify additional mount options for the root filesystem. If not set, <u><a href="file:/etc/fstab">/etc/fstab</a></u> of the real root
           will be parsed for special mount options and mounted accordingly.

       <b>ro</b>
           force mounting <u>/</u> and <u><a href="file:/usr">/usr</a></u> (if it is a separate device) read-only. If none of ro and rw is present,
           both are mounted according to <u><a href="file:/etc/fstab">/etc/fstab</a></u>.

       <b>rw</b>
           force mounting <u>/</u> and <u><a href="file:/usr">/usr</a></u> (if it is a separate device) read-write. See also ro option.

       <b>rootfallback=</b><u>&lt;path</u> <u>to</u> <u>blockdevice&gt;</u>
           specify the block device to use as the root filesystem, if the normal root cannot be found. This can
           only be a simple block device with a simple file system, for which the filesystem driver is either
           compiled in, or added manually to the initramfs. This parameter can be specified multiple times.

       <b>rd.auto</b> <b>rd.auto=1</b>
           enable autoassembly of special devices like cryptoLUKS, dmraid, mdraid or lvm. Default is off as of
           dracut version &gt;= 024.

       <b>rd.hostonly=0</b>
           removes all compiled in configuration of the host system the initramfs image was built on. This helps
           booting, if any disk layout changed, especially in combination with rd.auto or other parameters
           specifying the layout.

       <b>rd.cmdline=ask</b>
           prompts the user for additional kernel command line parameters

       <b>rd.fstab=0</b>
           do not honor special mount options for the root filesystem found in <u><a href="file:/etc/fstab">/etc/fstab</a></u> of the real root.

       <b>resume=</b><u>&lt;path</u> <u>to</u> <u>resume</u> <u>partition&gt;</u>
           resume from a swap partition

           <b>Example</b> <b>3.</b> <b>Example</b>

               resume=/dev/disk/by-path/pci-0000:00:1f.1-scsi-0:0:1:0-part1
               resume=/dev/disk/by-uuid/3f5ad593-4546-4a94-a374-bcfb68aa11f7
               resume=UUID=3f5ad593-4546-4a94-a374-bcfb68aa11f7

       <b>rd.skipfsck</b>
           skip fsck for rootfs and <u><a href="file:/usr">/usr</a></u>. If you’re mounting <u><a href="file:/usr">/usr</a></u> read-only and the init system performs fsck
           before remount, you might want to use this option to avoid duplication.

   <b>iso-scan/filename</b>
       Mount all mountable devices and search for ISO pointed by the argument. When the ISO is found set it up
       as a loop device. Device containing this ISO image will stay mounted at /run/initramfs/isoscandev. Using
       iso-scan/filename with a Fedora/Red Hat/CentOS Live iso should just work by copying the original kernel
       cmdline parameters.

       <b>Example</b> <b>4.</b> <b>Example</b>

           menuentry 'Live Fedora 20' --class fedora --class gnu-linux --class gnu --class os {
               set isolabel=Fedora-Live-LXDE-x86_64-20-1
               set isofile="/boot/iso/Fedora-Live-LXDE-x86_64-20-1.iso"
               loopback loop $isofile
               linux (loop)/isolinux/vmlinuz0 boot=isolinux iso-scan/filename=$isofile root=live:LABEL=$isolabel ro rd.live.image quiet rhgb
               initrd (loop)/isolinux/initrd0.img
           }

   <b>Misc</b>
       <b>rd.emergency=</b><u>[reboot|poweroff|halt]</u>
           specify, what action to execute in case of a critical failure. rd.shell=0 must also be specified.

       <b>rd.driver.blacklist=</b><u>&lt;drivername&gt;</u>[,<u>&lt;drivername&gt;</u>,...]
           do not load kernel module &lt;drivername&gt;. This parameter can be specified multiple times.

       <b>rd.driver.pre=</b><u>&lt;drivername&gt;</u>[,<u>&lt;drivername&gt;</u>,...]
           force loading kernel module &lt;drivername&gt;. This parameter can be specified multiple times.

       <b>rd.driver.post=</b><u>&lt;drivername&gt;</u>[,<u>&lt;drivername&gt;</u>,...]
           force loading kernel module &lt;drivername&gt; after all automatic loading modules have been loaded. This
           parameter can be specified multiple times.

       <b>rd.retry=</b><u>&lt;seconds&gt;</u>
           specify how long dracut should retry the initqueue to configure devices. The default is 180 seconds.
           After 2/3 of the time, degraded raids are force started. If you have hardware, which takes a very
           long time to announce its drives, you might want to extend this value.

       <b>rd.timeout=</b><u>&lt;seconds&gt;</u>
           specify how long dracut should wait for devices to appear. The default is <u>0</u>, which means <u>forever</u>.
           Note that this timeout should be longer than rd.retry to allow for proper configuration.

       <b>rd.noverifyssl</b>
           accept self-signed certificates for ssl downloads.

       <b>rd.ctty=</b><u>&lt;terminal</u> <u>device&gt;</u>
           specify the controlling terminal for the console. This is useful, if you have multiple "console="
           arguments.

       <b>rd.shutdown.timeout.umount=</b><u>&lt;seconds&gt;</u>
           specify how long dracut should wait for an individual umount to finish during shutdown. This avoids
           the system from blocking when unmounting a file system cannot complete and waits indefinitely. Value
           <u>0</u> means to wait <u>forever</u>. The default is 90 seconds.

   <b>Debug</b>
       If you are dropped to an emergency shell, the file <u>/run/initramfs/rdsosreport.txt</u> is created, which can
       be saved to a (to be mounted by hand) partition (usually <a href="file:/boot">/boot</a>) or a USB stick. Additional debugging info
       can be produced by adding <b>rd.debug</b> to the kernel command line. <u>/run/initramfs/rdsosreport.txt</u> contains
       all logs and the output of some tools. It should be attached to any report about dracut problems.

       <b>rd.info</b>
           print informational output though "quiet" is set

       <b>rd.shell</b>
           allow dropping to a shell, if root mounting fails

       <b>rd.debug</b>
           set -x for the dracut shell. If systemd is active in the initramfs, all output is logged to the
           systemd journal, which you can inspect with "journalctl -ab". If systemd is not active, the logs are
           written to dmesg and <u>/run/initramfs/init.log</u>. If "quiet" is set, it also logs to the console.

       <b>rd.memdebug=[0-5]</b>
           Print memory usage info at various points, set the verbose level from 0 to 5.

               Higher level means more debugging output:

                   0 - no output
                   1 - partial <a href="file:/proc/meminfo">/proc/meminfo</a>
                   2 - <a href="file:/proc/meminfo">/proc/meminfo</a>
                   3 - <a href="file:/proc/meminfo">/proc/meminfo</a> + <a href="file:/proc/slabinfo">/proc/slabinfo</a>
                   4 - <a href="file:/proc/meminfo">/proc/meminfo</a> + <a href="file:/proc/slabinfo">/proc/slabinfo</a> + memstrack summary
                       NOTE: memstrack is a memory tracing tool that tracks the total memory
                             consumption, and peak memory consumption of each kernel modules
                             and userspace progress during the whole initramfs runtime, report
                             is generated and the end of initramfs run.
                   5 - <a href="file:/proc/meminfo">/proc/meminfo</a> + <a href="file:/proc/slabinfo">/proc/slabinfo</a> + memstrack (with top memory stacktrace)
                       NOTE: memstrack (with top memory stacktrace) will print top memory
                             allocation stack traces during the whole initramfs runtime.

       <b>rd.break</b>
           drop to a shell at the end

       <b>rd.break=</b><u>{cmdline|pre-udev|pre-trigger|initqueue|pre-mount|mount|pre-pivot|cleanup}</u>
           drop to a shell before the defined breakpoint starts. This parameter can be specified multiple times.

       <b>rd.udev.log_level=</b><u>{err|info|debug}</u>
           set udev log level. The default is <u>err</u>.

   <b>I18N</b>
       <b>rd.vconsole.keymap=</b><u>&lt;keymap</u> <u>base</u> <u>file</u> <u>name&gt;</u>
           keyboard translation table loaded by loadkeys; taken from keymaps directory; will be written as
           KEYMAP to <u><a href="file:/etc/vconsole.conf">/etc/vconsole.conf</a></u> in the initramfs.

           <b>Example</b> <b>5.</b> <b>Example</b>

               rd.vconsole.keymap=de-latin1-nodeadkeys

       <b>rd.vconsole.keymap.ext=</b><u>&lt;list</u> <u>of</u> <u>keymap</u> <u>base</u> <u>file</u> <u>names&gt;</u>
           list of extra keymaps to bo loaded (sep. by space); will be written as EXT_KEYMAP to
           <u><a href="file:/etc/vconsole.conf">/etc/vconsole.conf</a></u> in the initramfs

       <b>rd.vconsole.unicode</b>
           boolean, indicating UTF-8 mode; will be written as UNICODE to <u><a href="file:/etc/vconsole.conf">/etc/vconsole.conf</a></u> in the initramfs

       <b>rd.vconsole.font=</b><u>&lt;font</u> <u>base</u> <u>file</u> <u>name&gt;</u>
           console font; taken from consolefonts directory; will be written as FONT to <u><a href="file:/etc/vconsole.conf">/etc/vconsole.conf</a></u> in the
           initramfs.

           <b>Example</b> <b>6.</b> <b>Example</b>

               rd.vconsole.font=eurlatgr

       <b>rd.vconsole.font.map=</b><u>&lt;console</u> <u>map</u> <u>base</u> <u>file</u> <u>name&gt;</u>
           see description of <u>-m</u> parameter in setfont manual; taken from consoletrans directory; will be written
           as FONT_MAP to <u><a href="file:/etc/vconsole.conf">/etc/vconsole.conf</a></u> in the initramfs

       <b>rd.vconsole.font.unimap=</b><u>&lt;unicode</u> <u>table</u> <u>base</u> <u>file</u> <u>name&gt;</u>
           see description of <u>-u</u> parameter in setfont manual; taken from unimaps directory; will be written as
           FONT_UNIMAP to <u><a href="file:/etc/vconsole.conf">/etc/vconsole.conf</a></u> in the initramfs

       <b>rd.locale.LANG=</b><u>&lt;locale&gt;</u>
           taken from the environment; if no UNICODE is defined we set its value in basis of LANG value (whether
           it ends with ".utf8" (or similar) or not); will be written as LANG to <u><a href="file:/etc/locale.conf">/etc/locale.conf</a></u> in the
           initramfs.

           <b>Example</b> <b>7.</b> <b>Example</b>

               rd.locale.LANG=pl_PL.utf8

       <b>rd.locale.LC_ALL=</b><u>&lt;locale&gt;</u>
           taken from the environment; will be written as LC_ALL to <u><a href="file:/etc/locale.conf">/etc/locale.conf</a></u> in the initramfs

   <b>LVM</b>
       <b>rd.lvm=0</b>
           disable LVM detection

       <b>rd.lvm.vg=</b><u>&lt;volume</u> <u>group</u> <u>name&gt;</u>
           only activate all logical volumes in the the volume groups with the given name. rd.lvm.vg can be
           specified multiple times on the kernel command line.

       <b>rd.lvm.lv=</b><u>&lt;volume</u> <u>group</u> <u>name&gt;/&lt;logical</u> <u>volume</u> <u>name&gt;</u>
           only activate the logical volumes with the given name. rd.lvm.lv can be specified multiple times on
           the kernel command line.

       <b>rd.lvm.conf=0</b>
           remove any <u><a href="file:/etc/lvm/lvm.conf">/etc/lvm/lvm.conf</a></u>, which may exist in the initramfs

   <b>crypto</b> <b>LUKS</b>
       <b>rd.luks=0</b>
           disable crypto LUKS detection

       <b>rd.luks.uuid=</b><u>&lt;luks</u> <u>uuid&gt;</u>
           only activate the LUKS partitions with the given UUID. Any "luks-" of the LUKS UUID is removed before
           comparing to <u>&lt;luks</u> <u>uuid&gt;</u>. The comparisons also matches, if <u>&lt;luks</u> <u>uuid&gt;</u> is only the beginning of the
           LUKS UUID, so you don’t have to specify the full UUID. This parameter can be specified multiple
           times.  <u>&lt;luks</u> <u>uuid&gt;</u> may be prefixed by the keyword keysource:, see <u>rd.luks.key</u> below.

       <b>rd.luks.allow-discards=</b><u>&lt;luks</u> <u>uuid&gt;</u>
           Allow using of discards (TRIM) requests for LUKS partitions with the given UUID. Any "luks-" of the
           LUKS UUID is removed before comparing to <u>&lt;luks</u> <u>uuid&gt;</u>. The comparisons also matches, if <u>&lt;luks</u> <u>uuid&gt;</u> is
           only the beginning of the LUKS UUID, so you don’t have to specify the full UUID. This parameter can
           be specified multiple times.

       <b>rd.luks.allow-discards</b>
           Allow using of discards (TRIM) requests on all LUKS partitions.

       <b>rd.luks.crypttab=0</b>
           do not check, if LUKS partition is in <u><a href="file:/etc/crypttab">/etc/crypttab</a></u>

       <b>rd.luks.timeout=</b><u>&lt;seconds&gt;</u>
           specify how long dracut should wait when waiting for the user to enter the password. This avoid
           blocking the boot if no password is entered. It does not apply to luks key. The default is <u>0</u>, which
           means <u>forever</u>.

   <b>crypto</b> <b>LUKS</b> <b>-</b> <b>key</b> <b>on</b> <b>removable</b> <b>device</b> <b>support</b>
       NB: If systemd is included in the dracut initrd, dracut’s built in removable device keying support won’t
       work. systemd will prompt for a password from the console even if you’ve supplied <b>rd.luks.key</b>. You may be
       able to use standard systemd <b><a href="../man5/fstab.5.html">fstab</a></b>(5) syntax to get the same effect. If you do need <b>rd.luks.key</b> to work,
       you will have to exclude the "systemd" dracut module and any modules that depend on it. See
       <b><a href="../man5/dracut.conf.5.html">dracut.conf</a></b>(5) and <b>https://bugzilla.redhat.com/show_bug.cgi?id=905683</b> for more information.

       <b>rd.luks.key=</b><u>&lt;keypath&gt;[:&lt;keydev&gt;[:&lt;luksdev&gt;]]</u>
           <u>&lt;keypath&gt;</u> is the pathname of a key file, relative to the root of the filesystem on some device. It’s
           REQUIRED. When <u>&lt;keypath&gt;</u> ends with <u>.gpg</u> it’s considered to be key encrypted symmetrically with GPG.
           You will be prompted for the GPG password on boot. GPG support comes with the <u>crypt-gpg</u> module, which
           needs to be added explicitly.

           <u>&lt;keydev&gt;</u> identifies the device on which the key file resides. It may be the kernel name of the device
           (should start with "<a href="file:/dev/">/dev/</a>"), a UUID (prefixed with "UUID=") or a label (prefix with "LABEL="). You
           don’t have to specify a full UUID. Just its beginning will suffice, even if its ambiguous. All
           matching devices will be probed. This parameter is recommended, but not required. If it’s not
           present, all block devices will be probed, which may significantly increase boot time.

           If <u>&lt;luksdev&gt;</u> is given, the specified key will only be used for the specified LUKS device. Possible
           values are the same as for <u>&lt;keydev&gt;</u>. Unless you have several LUKS devices, you don’t have to specify
           this parameter. The simplest usage is:

           <b>Example</b> <b>8.</b> <b>Example</b>

               rd.luks.key=/foo/bar.key

           As you see, you can skip colons in such a case.

           <b>Note</b>

           Your LUKS partition must match your key file.

           dracut provides keys to cryptsetup with <u>-d</u> (an older alias for <u>--key-file</u>). This uses the entire
           binary content of the key file as part of the secret. If you pipe a password into cryptsetup <b>without</b>
           <u>-d</u> or <u>--key-file</u>, it will be treated as text user input, and only characters before the first newline
           will be used. Therefore, when you’re creating an encrypted partition for dracut to mount, and you
           pipe a key into <u>cryptsetup</u> <u>luksFormat</u>,you must use <u>-d</u> <u>-</u>.

           Here is an example for a key encrypted with GPG (warning: <u>--batch-mode</u> will overwrite the device
           without asking for confirmation):

               gpg --quiet --decrypt rootkey.gpg | \
               cryptsetup --batch-mode --key-file - \
                          luksFormat /dev/sda47

           If you use unencrypted key files, just use the key file pathname instead of the standard input. For a
           random key with 256 bits of entropy, you might use:

               head -32c /dev/urandom &gt; rootkey.key
               cryptsetup --batch-mode --key-file rootkey.key \
                          luksFormat /dev/sda47

           You can also use regular key files on an encrypted <u>keydev</u>.

           Compared to using GPG encrypted keyfiles on an unencrypted device this provides the following
           advantages:

           •   you can unlock your disk(s) using multiple passphrases

           •   better security by not losing the key stretching mechanism

           To use an encrypted <u>keydev</u> you <b>must</b> ensure that it becomes available by using the keyword keysource,
           e.g. rd.luks.uuid=keysource:aaaa <u>aaaa</u> being the uuid of the encrypted <u>keydev</u>.

           Example:

           Lets assume you have three disks <u>A</u>, <u>B</u> and <u>C</u> with the uuids <u>aaaa</u>, <u>bbbb</u> and <u>cccc</u>. You want to unlock <u>A</u>
           and <u>B</u> using keyfile <u>keyfile</u>. The unlocked volumes be <u>A'</u>, <u>B'</u> and <u>C'</u> with the uuids <u>AAAA</u>, <u>BBBB</u> and
           <u>CCCC</u>. <u>keyfile</u> is saved on <u>C'</u> as <u>/keyfile</u>.

           One luks keyslot of each <u>A</u>, <u>B</u> and <u>C</u> is setup with a passphrase. Another luks keyslot of each <u>A</u> and <u>B</u>
           is setup with <u>keyfile</u>.

           To boot this configuration you could use:

               rd.luks.uuid=aaaa
               rd.luks.uuid=bbbb
               rd.luks.uuid=keysource:cccc
               rd.luks.key=/keyfile:UUID=CCCC

           Dracut asks for the passphrase for <u>C</u> and uses the keyfile to unlock <u>A</u> and <u>B</u>. If getting the
           passphrase for <u>C</u> fails it falls back to asking for the passphrases for <u>A</u> and <u>B</u>.

           If you want <u>C'</u> to stay unlocked, specify a luks name for it, e.g. rd.luks.name=cccc=mykeys, otherwise
           it gets closed when not needed anymore.

       <b>rd.luks.key.tout=0</b>
           specify how many times dracut will try to read the keys specified in rd.luks.key. This gives a chance
           to the removable device containing the key to initialize.

   <b>MD</b> <b>RAID</b>
       <b>rd.md=0</b>
           disable MD RAID detection

       <b>rd.md.imsm=0</b>
           disable MD RAID for imsm/isw raids, use DM RAID instead

       <b>rd.md.ddf=0</b>
           disable MD RAID for SNIA ddf raids, use DM RAID instead

       <b>rd.md.conf=0</b>
           ignore mdadm.conf included in initramfs

       <b>rd.md.waitclean=1</b>
           wait for any resync, recovery, or reshape activity to finish before continuing

       <b>rd.md.uuid=</b><u>&lt;md</u> <u>raid</u> <u>uuid&gt;</u>
           only activate the raid sets with the given UUID. This parameter can be specified multiple times.

   <b>DM</b> <b>RAID</b>
       <b>rd.dm=0</b>
           disable DM RAID detection

       <b>rd.dm.uuid=</b><u>&lt;dm</u> <u>raid</u> <u>uuid&gt;</u>
           only activate the raid sets with the given UUID. This parameter can be specified multiple times.

   <b>MULTIPATH</b>
       <b>rd.multipath=0</b>
           disable multipath detection

       <b>rd.multipath=default</b>
           use default multipath settings

   <b>FIPS</b>
       <b>rd.fips</b>
           enable FIPS

       <b>boot=</b><u>&lt;boot</u> <u>device&gt;</u>
           specify the device, where <a href="file:/boot">/boot</a> is located.

           <b>Example</b> <b>9.</b> <b>Example</b>

               boot=/dev/sda1
               boot=/dev/disk/by-path/pci-0000:00:1f.1-scsi-0:0:1:0-part1
               boot=UUID=&lt;uuid&gt;
               boot=LABEL=&lt;label&gt;

       <b>rd.fips.skipkernel</b>
           skip checksum check of the kernel image. Useful, if the kernel image is not in a separate boot
           partition.

   <b>Network</b>
           <b>Important</b>

           It is recommended to either bind an interface to a MAC with the <b>ifname</b> argument, or to use the
           systemd-udevd predictable network interface names.

           Predictable network interface device names based on:

           •   firmware/bios-provided index numbers for on-board devices

           •   firmware-provided pci-express hotplug slot index number

           •   physical/geographical location of the hardware

           •   the interface’s MAC address

           See: <b><a href="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames">http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames</a></b>

           Two character prefixes based on the type of interface:

           en
               ethernet

           wl
               wlan

           ww
               wwan

           Type of names:

           o&lt;index&gt;
               on-board device index number

           s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_id&gt;]
               hotplug slot index number

           x&lt;MAC&gt;
               MAC address

           [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_id&gt;]
               PCI geographical location

           [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;]
               USB port number chain

           All multi-function PCI devices will carry the [f&lt;function&gt;] number in the device name, including the
           function 0 device.

           When using PCI geography, The PCI domain is only prepended when it is not 0.

           For USB devices the full chain of port numbers of hubs is composed. If the name gets longer than the
           maximum number of 15 characters, the name is not exported. The usual USB configuration == 1 and
           interface == 0 values are suppressed.

           PCI ethernet card with firmware index "1"

               •   eno1

           PCI ethernet card in hotplug slot with firmware index number

               •   ens1

           PCI ethernet multi-function card with 2 ports

               •   enp2s0f0

               •   enp2s0f1

           PCI wlan card

               •   wlp3s0

           USB built-in 3G modem

               •   wwp0s29u1u4i6

           USB Android phone

               •   enp0s29u1u2

       The following options are supported by the <u>network-legacy</u> dracut module. Other network modules might
       support a slightly different set of options; refer to the documentation of the specific network module in
       use. For NetworkManager, see <b><a href="../man8/nm-initrd-generator.8.html">nm-initrd-generator</a></b>(8).

       <b>ip=</b><u>{dhcp|on|any|dhcp6|auto6|either6|link6|single-dhcp}</u>

           dhcp|on|any
               get ip from dhcp server from all interfaces. If netroot=dhcp, loop sequentially through all
               interfaces (eth0, eth1, ...) and use the first with a valid DHCP root-path.

           single-dhcp
               Send DHCP on all available interfaces in parallel, as opposed to one after another. After the
               first DHCP response is received, stop DHCP on all other interfaces. This gives the fastest boot
               time by using the IP on interface for which DHCP succeeded first during early boot. Caveat: Does
               not apply to Network Manager.

           auto6
               IPv6 autoconfiguration

           dhcp6
               IPv6 DHCP

           either6
               if auto6 fails, then dhcp6

           link6
               bring up interface for IPv6 link-local addressing

       <b>ip=</b><u>&lt;interface&gt;</u>:<u>{dhcp|on|any|dhcp6|auto6|link6}</u>[:[<u>&lt;mtu&gt;</u>][:<u>&lt;macaddr&gt;</u>]]
           This parameter can be specified multiple times.

           dhcp|on|any|dhcp6
               get ip from dhcp server on a specific interface

           auto6
               do IPv6 autoconfiguration

           link6
               bring up interface for IPv6 link local address

           &lt;macaddr&gt;
               optionally <b>set</b> &lt;macaddr&gt; on the &lt;interface&gt;. This cannot be used in conjunction with the <b>ifname</b>
               argument for the same &lt;interface&gt;.

       <b>ip=</b><u>&lt;client-IP&gt;</u>:[<u>&lt;peer&gt;</u>]:<u>&lt;gateway-IP&gt;</u>:<u>&lt;netmask&gt;</u>:<u>&lt;client_hostname&gt;</u>:<u>&lt;interface&gt;</u>:<u>{none|off|dhcp|on|any|dhcp6|auto6|ibft}</u>[:[<u>&lt;mtu&gt;</u>][:<u>&lt;macaddr&gt;</u>]]
           explicit network configuration. If you want do define a IPv6 address, put it in brackets (e.g.
           [2001:DB8::1]). This parameter can be specified multiple times.  <u>&lt;peer&gt;</u> is optional and is the
           address of the remote endpoint for pointopoint interfaces and it may be followed by a slash and a
           decimal number, encoding the network prefix length.

           &lt;macaddr&gt;
               optionally <b>set</b> &lt;macaddr&gt; on the &lt;interface&gt;. This cannot be used in conjunction with the <b>ifname</b>
               argument for the same &lt;interface&gt;.

       <b>ip=</b><u>&lt;client-IP&gt;</u>:[<u>&lt;peer&gt;</u>]:<u>&lt;gateway-IP&gt;</u>:<u>&lt;netmask&gt;</u>:<u>&lt;client_hostname&gt;</u>:<u>&lt;interface&gt;</u>:<u>{none|off|dhcp|on|any|dhcp6|auto6|ibft}</u>[:[<u>&lt;dns1&gt;</u>][:<u>&lt;dns2&gt;</u>]]
           explicit network configuration. If you want do define a IPv6 address, put it in brackets (e.g.
           [2001:DB8::1]). This parameter can be specified multiple times.  <u>&lt;peer&gt;</u> is optional and is the
           address of the remote endpoint for pointopoint interfaces and it may be followed by a slash and a
           decimal number, encoding the network prefix length.

       <b>ifname=</b><u>&lt;interface&gt;</u>:<u>&lt;MAC&gt;</u>
           Assign network device name &lt;interface&gt; (i.e. "bootnet") to the NIC with MAC &lt;MAC&gt;.

               <b>Warning</b>
               Do <b>not</b> use the default kernel naming scheme for the interface name, as it can conflict with the
               kernel names. So, don’t use "eth[0-9]+" for the interface name. Better name it "bootnet" or
               "bluesocket".

       <b>rd.route=</b><u>&lt;net&gt;</u>/<u>&lt;netmask&gt;</u>:<u>&lt;gateway&gt;</u>[:<u>&lt;interface&gt;</u>]
           Add a static route with route options, which are separated by a colon. IPv6 addresses have to be put
           in brackets.

           <b>Example</b> <b>10.</b> <b>Example</b>

                   rd.route=192.168.200.0/24:192.168.100.222:ens10
                   rd.route=192.168.200.0/24:192.168.100.222
                   rd.route=192.168.200.0/24::ens10
                   rd.route=[2001:DB8:3::/8]:[2001:DB8:2::1]:ens10

       <b>bootdev=</b><u>&lt;interface&gt;</u>
           specify network interface to use routing and netroot information from. Required if multiple ip= lines
           are used.

       <b>BOOTIF=</b><u>&lt;MAC&gt;</u>
           specify network interface to use routing and netroot information from.

       <b>rd.bootif=0</b>
           Disable BOOTIF parsing, which is provided by PXE

       <b>nameserver=</b><u>&lt;IP&gt;</u> [<b>nameserver=</b><u>&lt;IP&gt;</u> ...]
           specify nameserver(s) to use

       <b>rd.peerdns=0</b>
           Disable DNS setting of DHCP parameters.

       <b>biosdevname=0</b>
           boolean, turn off biosdevname network interface renaming

       <b>rd.neednet=1</b>
           boolean, bring up network even without netroot set

       <b>vlan=</b><u>&lt;vlanname&gt;</u>:<u>&lt;phydevice&gt;</u>
           Setup vlan device named &lt;vlanname&gt; on &lt;phydevice&gt;. We support the four styles of vlan names:
           VLAN_PLUS_VID (vlan0005), VLAN_PLUS_VID_NO_PAD (vlan5), DEV_PLUS_VID (eth0.0005), DEV_PLUS_VID_NO_PAD
           (eth0.5)

       <b>bond=</b><u>&lt;bondname&gt;</u>[:<u>&lt;bondslaves&gt;</u>:[:<u>&lt;options&gt;</u>[:&lt;mtu&gt;]]]
           Setup bonding device &lt;bondname&gt; on top of &lt;bondslaves&gt;. &lt;bondslaves&gt; is a comma-separated list of
           physical (ethernet) interfaces. &lt;options&gt; is a comma-separated list on bonding options (modinfo
           bonding for details) in format compatible with initscripts. If &lt;options&gt; includes multi-valued
           arp_ip_target option, then its values should be separated by semicolon. if the mtu is specified, it
           will be set on the bond master. Bond without parameters assumes bond=bond0:eth0,eth1:mode=balance-rr

       <b>team=</b><u>&lt;teammaster&gt;</u>:<u>&lt;teamslaves&gt;</u>[:<u>&lt;teamrunner&gt;</u>]
           Setup team device &lt;teammaster&gt; on top of &lt;teamslaves&gt;. &lt;teamslaves&gt; is a comma-separated list of
           physical (ethernet) interfaces. &lt;teamrunner&gt; is the runner type to be used (see <b><a href="../man5/teamd.conf.5.html">teamd.conf</a></b>(5));
           defaults to activebackup. Team without parameters assumes team=team0:eth0,eth1:activebackup

       <b>bridge=</b><u>&lt;bridgename&gt;</u>:<u>&lt;ethnames&gt;</u>
           Setup bridge &lt;bridgename&gt; with &lt;ethnames&gt;. &lt;ethnames&gt; is a comma-separated list of physical
           (ethernet) interfaces. Bridge without parameters assumes bridge=br0:eth0

   <b>NFS</b>
       <b>root=</b>[<u>&lt;server-ip&gt;</u>:]<u>&lt;root-dir&gt;</u>[:<u>&lt;nfs-options&gt;</u>]
           mount nfs share from &lt;server-ip&gt;:/&lt;root-dir&gt;, if no server-ip is given, use dhcp next_server. If
           server-ip is an IPv6 address it has to be put in brackets, e.g. [2001:DB8::1]. NFS options can be
           appended with the prefix ":" or "," and are separated by ",".

       <b>root=</b>nfs:[<u>&lt;server-ip&gt;</u>:]<u>&lt;root-dir&gt;</u>[:<u>&lt;nfs-options&gt;</u>], <b>root=</b>nfs4:[<u>&lt;server-ip&gt;</u>:]<u>&lt;root-dir&gt;</u>[:<u>&lt;nfs-options&gt;</u>],
       <b>root=</b><u>{dhcp|dhcp6}</u>
           netroot=dhcp alone directs initrd to look at the DHCP root-path where NFS options can be specified.

           <b>Example</b> <b>11.</b> <b>Example</b>

                   root-path=&lt;server-ip&gt;:&lt;root-dir&gt;[,&lt;nfs-options&gt;]
                   root-path=nfs:&lt;server-ip&gt;:&lt;root-dir&gt;[,&lt;nfs-options&gt;]
                   root-path=nfs4:&lt;server-ip&gt;:&lt;root-dir&gt;[,&lt;nfs-options&gt;]

       <b>root=</b><u>/dev/nfs</u> nfsroot=[<u>&lt;server-ip&gt;</u>:]<u>&lt;root-dir&gt;</u>[:<u>&lt;nfs-options&gt;</u>]
           <u>Deprecated!</u>  kernel Documentation_/filesystems/nfsroot.txt_ defines this method. This is supported by
           dracut, but not recommended.

       <b>rd.nfs.domain=</b><u>&lt;NFSv4</u> <u>domain</u> <u>name&gt;</u>
           Set the NFSv4 domain name. Will override the settings in <u>/etc/idmap.conf</u>.

       <b>rd.net.dhcp.retry=</b><u>&lt;cnt&gt;</u>
           If this option is set, dracut will try to connect via dhcp &lt;cnt&gt; times before failing. Default is 1.

       <b>rd.net.timeout.dhcp=</b><u>&lt;arg&gt;</u>
           If this option is set, dhclient is called with "--timeout &lt;arg&gt;".

       <b>rd.net.timeout.iflink=</b><u>&lt;seconds&gt;</u>
           Wait &lt;seconds&gt; until link shows up. Default is 60 seconds.

       <b>rd.net.timeout.ifup=</b><u>&lt;seconds&gt;</u>
           Wait &lt;seconds&gt; until link has state "UP". Default is 20 seconds.

       <b>rd.net.timeout.route=</b><u>&lt;seconds&gt;</u>
           Wait &lt;seconds&gt; until route shows up. Default is 20 seconds.

       <b>rd.net.timeout.ipv6dad=</b><u>&lt;seconds&gt;</u>
           Wait &lt;seconds&gt; until IPv6 DAD is finished. Default is 50 seconds.

       <b>rd.net.timeout.ipv6auto=</b><u>&lt;seconds&gt;</u>
           Wait &lt;seconds&gt; until IPv6 automatic addresses are assigned. Default is 40 seconds.

       <b>rd.net.timeout.carrier=</b><u>&lt;seconds&gt;</u>
           Wait &lt;seconds&gt; until carrier is recognized. Default is 10 seconds.

   <b>CIFS</b>
       <b>root=</b>cifs://[<u>&lt;username&gt;</u>[:<u>&lt;password&gt;</u>]@]<u>&lt;server-ip&gt;</u>:<u>&lt;root-dir&gt;</u>
           mount cifs share from &lt;server-ip&gt;:/&lt;root-dir&gt;, if no server-ip is given, use dhcp next_server. if
           server-ip is an IPv6 address it has to be put in brackets, e.g. [2001:DB8::1]. If a username or
           password are not specified as part of the root, then they must be passed on the command line through
           cifsuser/cifspass.

               <b>Warning</b>
               Passwords specified on the kernel command line are visible for all users via the file
               <u><a href="file:/proc/cmdline">/proc/cmdline</a></u> and via dmesg or can be sniffed on the network, when using DHCP with DHCP
               root-path.

       <b>cifsuser</b>=<u>&lt;username&gt;</u>
           Set the cifs username, if not specified as part of the root.

       <b>cifspass</b>=<u>&lt;password&gt;</u>
           Set the cifs password, if not specified as part of the root.

               <b>Warning</b>
               Passwords specified on the kernel command line are visible for all users via the file
               <u><a href="file:/proc/cmdline">/proc/cmdline</a></u> and via dmesg or can be sniffed on the network, when using DHCP with DHCP
               root-path.

   <b>iSCSI</b>
       <b>root=</b>iscsi:[<u>&lt;username&gt;</u>:<u>&lt;password&gt;</u>[:<u>&lt;reverse&gt;</u>:<u>&lt;password&gt;</u>]@][<u>&lt;servername&gt;</u>]:[<u>&lt;protocol&gt;</u>]:[<u>&lt;port&gt;</u>][:[<u>&lt;iscsi_iface_name&gt;</u>]:[<u>&lt;netdev_name&gt;</u>]]:[<u>&lt;LUN&gt;</u>]:<u>&lt;targetname&gt;</u>
           protocol defaults to "6", LUN defaults to "0". If the "servername" field is provided by BOOTP or
           DHCP, then that field is used in conjunction with other associated fields to contact the boot server
           in the Boot stage. However, if the "servername" field is not provided, then the "targetname" field is
           then used in the Discovery Service stage in conjunction with other associated fields. See <b>rfc4173</b>[1].

               <b>Warning</b>
               Passwords specified on the kernel command line are visible for all users via the file
               <u><a href="file:/proc/cmdline">/proc/cmdline</a></u> and via dmesg or can be sniffed on the network, when using DHCP with DHCP
               root-path.

           <b>Example</b> <b>12.</b> <b>Example</b>

               root=iscsi:192.168.50.1::::iqn.2009-06.dracut:target0

           If servername is an IPv6 address, it has to be put in brackets:

           <b>Example</b> <b>13.</b> <b>Example</b>

               root=iscsi:[2001:DB8::1]::::iqn.2009-06.dracut:target0

       <b>root=</b><u>???</u>
       <b>netroot=</b>iscsi:[<u>&lt;username&gt;</u>:<u>&lt;password&gt;</u>[:<u>&lt;reverse&gt;</u>:<u>&lt;password&gt;</u>]@][<u>&lt;servername&gt;</u>]:[<u>&lt;protocol&gt;</u>]:[<u>&lt;port&gt;</u>][:[<u>&lt;iscsi_iface_name&gt;</u>]:[<u>&lt;netdev_name&gt;</u>]]:[<u>&lt;LUN&gt;</u>]:<u>&lt;targetname&gt;</u>
       ...
           multiple netroot options allow setting up multiple iscsi disks:

           <b>Example</b> <b>14.</b> <b>Example</b>

               root=UUID=12424547
               netroot=iscsi:192.168.50.1::::iqn.2009-06.dracut:target0
               netroot=iscsi:192.168.50.1::::iqn.2009-06.dracut:target1

           If servername is an IPv6 address, it has to be put in brackets:

           <b>Example</b> <b>15.</b> <b>Example</b>

               netroot=iscsi:[2001:DB8::1]::::iqn.2009-06.dracut:target0

               <b>Warning</b>
               Passwords specified on the kernel command line are visible for all users via the file
               <u><a href="file:/proc/cmdline">/proc/cmdline</a></u> and via dmesg or can be sniffed on the network, when using DHCP with DHCP
               root-path. You may want to use rd.iscsi.firmware.

       <b>root=</b><u>???</u> <b>rd.iscsi.initiator=</b><u>&lt;initiator&gt;</u> <b>rd.iscsi.target.name=</b><u>&lt;target</u> <u>name&gt;</u> <b>rd.iscsi.target.ip=</b><u>&lt;target</u> <u>ip&gt;</u>
       <b>rd.iscsi.target.port=</b><u>&lt;target</u> <u>port&gt;</u> <b>rd.iscsi.target.group=</b><u>&lt;target</u> <u>group&gt;</u> <b>rd.iscsi.username=</b><u>&lt;username&gt;</u>
       <b>rd.iscsi.password=</b><u>&lt;password&gt;</u> <b>rd.iscsi.in.username=</b><u>&lt;in</u> <u>username&gt;</u> <b>rd.iscsi.in.password=</b><u>&lt;in</u> <u>password&gt;</u>
           manually specify all iscsistart parameter (see <b>iscsistart</b> <b>--help</b>)

               <b>Warning</b>
               Passwords specified on the kernel command line are visible for all users via the file
               <u><a href="file:/proc/cmdline">/proc/cmdline</a></u> and via dmesg or can be sniffed on the network, when using DHCP with DHCP
               root-path. You may want to use rd.iscsi.firmware.

       <b>root=</b><u>???</u> <b>netroot=</b>iscsi <b>rd.iscsi.firmware=1</b>
           will read the iscsi parameter from the BIOS firmware

       <b>rd.iscsi.login_retry_max=</b><u>&lt;num&gt;</u>
           maximum number of login retries

       <b>rd.iscsi.param=</b><u>&lt;param&gt;</u>
           &lt;param&gt; will be passed as "--param &lt;param&gt;" to iscsistart. This parameter can be specified multiple
           times.

           <b>Example</b> <b>16.</b> <b>Example</b>

               "netroot=iscsi rd.iscsi.firmware=1 rd.iscsi.param=node.session.timeo.replacement_timeout=30"

           will result in

               iscsistart -b --param node.session.timeo.replacement_timeout=30

       <b>rd.iscsi.ibft</b> <b>rd.iscsi.ibft=1</b>: Turn on iBFT autoconfiguration for the interfaces

       <b>rd.iscsi.mp</b> <b>rd.iscsi.mp=1</b>: Configure all iBFT interfaces, not only used for booting (multipath)

       <b>rd.iscsi.waitnet=0</b>: Turn off waiting for all interfaces to be up before trying to login to the iSCSI
       targets.

       <b>rd.iscsi.testroute=0</b>: Turn off checking, if the route to the iSCSI target IP is possible before trying to
       login.

       <b>rd.iscsi.transport=</b><u>&lt;transport_name&gt;</u>
           Set the iSCSI transport name (see <b><a href="../man8/iscsiadm.8.html">iscsiadm</a></b>(8)). iSCSI offload transports like <b>bnx2i</b> don’t need the
           network to be up in order to bring up iSCSI connections. This parameter indicates that network setup
           can be skipped in the initramfs, which makes booting with iSCSI offload cards faster and more
           reliable. This parameter currently only has an effect for <u>&lt;transport_name&gt;=bnx2i</u> or
           <u>&lt;transport_name&gt;=qedi</u>.

   <b>FCoE</b>
       <b>rd.fcoe=0</b>
           disable FCoE and lldpad

       <b>fcoe=</b><u>&lt;edd|interface|MAC&gt;</u>:<u>{dcb|nodcb}</u>:<u>{fabric|vn2vn}</u>
           Try to connect to a FCoE SAN through the NIC specified by <u>&lt;interface&gt;</u> or <u>&lt;MAC&gt;</u> or EDD settings. The
           second argument specifies if DCB should be used. The optional third argument specifies whether fabric
           or VN2VN mode should be used. This parameter can be specified multiple times.

               <b>Note</b>
               letters in the MAC-address must be lowercase!

   <b>NVMf</b>
       <b>rd.nonvmf</b>
           Disable NVMf

       <b>rd.nvmf.nonbft</b>
           Disable connecting to targets from the NVMe Boot Firmware Table. Without this parameter, NBFT
           connections will take precedence over <u>rd.nvmf.discover</u>.

       <b>rd.nvmf.nostatic</b>
           Disable connecting to targets that have been statically configured when the initramfs was built.
           Targets specified with rd.nvmf.discover on the kernel command line will still be tried.

       <b>rd.nvmf.hostnqn=</b><u>&lt;hostNQN&gt;</u>
           NVMe host NQN to use

       <b>rd.nvmf.hostid=</b><u>&lt;hostID&gt;</u>
           NVMe host id to use

       <b>rd.nvmf.discover=</b><u>{rdma|fc|tcp}</u>,<u>&lt;traddr&gt;</u>,[<u>&lt;host_traddr&gt;</u>],[<u>&lt;trsvcid&gt;</u>]
           Discover and connect to a NVMe-over-Fabric controller specified by <u>&lt;traddr&gt;</u> and the optionally
           <u>&lt;host_traddr&gt;</u> or <u>&lt;trsvcid&gt;</u>. The first argument specifies the transport to use; currently only <u>rdma</u>,
           <u>fc</u>, or <u>tcp</u> are supported. This parameter can be specified multiple times.

           <b>Example</b> <b>17.</b> <b>Examples</b>

               rd.nvmf.discover=tcp,192.168.10.10,,4420
               rd.nvmf.discover=fc,nn-0x201700a05634f5bf:pn-0x201900a05634f5bf,nn-0x200000109b579ef3:pn-0x100000109b579ef3

       <b>rd.nvmf.discover=fc,auto</b>
           This special syntax determines that Fibre Channel autodiscovery is to be used rather than regular
           NVMe discovery. It takes precedence over all other <u>rd.nvmf.discover=</u> arguments.

   <b>NBD</b>
       <b>root=</b>??? <b>netroot=</b>nbd:<u>&lt;server&gt;</u>:<u>&lt;port/exportname&gt;</u>[:<u>&lt;fstype&gt;</u>[:<u>&lt;mountopts&gt;</u>[:<u>&lt;nbdopts&gt;</u>]]]
           mount nbd share from &lt;server&gt;.

           NOTE: If "exportname" instead of "port" is given the standard port is used. Newer versions of nbd are
           only supported with "exportname".

       <b>root=/dev/root</b> <b>netroot=dhcp</b> with <b>dhcp</b>
       <b>root-path=</b>nbd:<u>&lt;server&gt;</u>:<u>&lt;port/exportname&gt;</u>[:<u>&lt;fstype&gt;</u>[:<u>&lt;mountopts&gt;</u>[:<u>&lt;nbdopts&gt;</u>]]]
           netroot=dhcp alone directs initrd to look at the DHCP root-path where NBD options can be specified.
           This syntax is only usable in cases where you are directly mounting the volume as the rootfs.

           NOTE: If "exportname" instead of "port" is given the standard port is used. Newer versions of nbd are
           only supported with "exportname".

   <b>VIRTIOFS</b>
       <b>root=</b>virtiofs:<u>&lt;mount-tag&gt;</u>
           mount virtiofs share using the tag &lt;mount-tag&gt;. The tag name is arbitrary and must match the tag
           given in the qemu <u>-device</u> command.

       <b>rootfstype=</b>virtiofs <b>root=</b><u>&lt;mount-tag&gt;</u>
           mount virtiofs share using the tag &lt;mount-tag&gt;. The tag name is arbitrary and must match the tag
           given in the qemu <u>-device</u> command.

       Both formats are supported by the <u>virtiofs</u> dracut module. See <b>https://gitlab.com/virtio-fs/virtiofsd</b> for
       more information.

       <b>Example</b> <b>18.</b> <b>Example</b>

           root=virtiofs:host rw

   <b>DASD</b>
       <b>rd.dasd=</b>....
           same syntax as the kernel module parameter (s390 only). For more details on the syntax see the IBM
           book "Linux on IBM Z and IBM LinuxONE - Device Drivers, Features, and Commands"
           <b>https://www.ibm.com/docs/en/linux-on-systems?topic=overview-device-drivers-features-commands</b>. This
           parameter can be specified multiple times.

           NOTE: This parameter is no longer handled by dracut itself but with the exact same syntax by
           <b>https://github.com/ibm-s390-linux/s390-tools/tree/master/zdev/dracut/95zdev</b>.

   <b>ZFCP</b>
       <b>rd.zfcp=</b><u>&lt;zfcp</u> <u>adaptor</u> <u>device</u> <u>bus</u> <u>ID&gt;</u>,<u>&lt;WWPN&gt;</u>,<u>&lt;FCPLUN&gt;</u>
           rd.zfcp can be specified multiple times on the kernel command line.

           NOTE: This parameter is no longer handled by dracut itself but with the exact same syntax by
           <b>https://github.com/ibm-s390-linux/s390-tools/tree/master/zdev/dracut/95zdev</b>.

       <b>rd.zfcp=</b><u>&lt;zfcp</u> <u>adaptor</u> <u>device</u> <u>bus</u> <u>ID&gt;</u>
           If NPIV is enabled and the <u>allow_lun_scan</u> parameter to the zfcp module is set to <u>Y</u> then the zfcp
           driver will be initiating a scan internally and the &lt;WWPN&gt; and &lt;FCPLUN&gt; parameters can be omitted.

           NOTE: This parameter is no longer handled by dracut itself but with the exact same syntax by
           <b>https://github.com/ibm-s390-linux/s390-tools/tree/master/zdev/dracut/95zdev</b>.

           <b>Example</b> <b>19.</b> <b>Example</b>

               rd.zfcp=0.0.4000,0x5005076300C213e9,0x5022000000000000
               rd.zfcp=0.0.4000

       <b>rd.zfcp.conf=0</b>
           ignore zfcp.conf included in the initramfs

   <b>ZNET</b>
       <b>rd.znet=</b><u>&lt;nettype&gt;</u>,<u>&lt;subchannels&gt;</u>,<u>&lt;options&gt;</u>
           Activates a channel-attached network interface on s390 architecture. &lt;nettype&gt; is one of: qeth, lcs,
           ctc. &lt;subchannels&gt; is a comma-separated list of ccw device bus-IDs. The list consists of 3 entries
           with nettype qeth, and 2 for other nettype. &lt;options&gt; is a comma-separated list of &lt;name&gt;=&lt;value&gt;
           pairs, where &lt;name&gt; refers to a device sysfs attribute to which &lt;value&gt; gets written. rd.znet can be
           specified multiple times on the kernel command line.

       <b>rd.znet_ifname=</b><u>&lt;ifname&gt;</u>:<u>&lt;subchannels&gt;</u>
           Assign network device name &lt;interface&gt; (i.e. "bootnet") to the NIC corresponds to the subchannels.
           This is useful when dracut’s default "ifname=" doesn’t work due to device having a changing MAC
           address.

           <b>Example</b> <b>20.</b> <b>Example</b>

               rd.znet=qeth,0.0.0600,0.0.0601,0.0.0602,layer2=1,portname=foo
               rd.znet=ctc,0.0.0600,0.0.0601,protocol=bar

   <b>Booting</b> <b>live</b> <b>images</b>
       Dracut offers multiple options for live booted images:

       SquashFS (read-only) base filesystem image
           Note — There are 3 separate overlay types available:

           •   Device-mapper snapshots (the original offering),

           •   Device-mapper thin provisioning snapshots (see <u>rd.live.overlay.thin</u>, a later offering), and

           •   OverlayFS based overlay mounts (a more recent offering).

           Using one of these technologies, the system will provide a writable overlay for the base, read-only
           SquashFS root filesystem. These methods enable a relatively fast boot and lower RAM usage.

           With the original Device-mapper snapshot overlay, users <b>must</b> <b>be</b> <b>careful</b> to avoid writing too many
           blocks to the snapshot device. Once the blocks of the snapshot overlay are exhausted, the whole root
           filesystem becomes read-only leading to application failures. The snapshot overlay device is marked
           <u>Overflow</u>, and a difficult recovery is required to repair and enlarge the overlay offline.

           When <u>rd.live.overlay=</u> is not specified for persistent overlay storage, or the specified file is not
           found or writable, a Device-mapper snapshot based non-persistent or temporary overlay is
           automatically created as a sparse file in RAM of the initramfs. This file will only consume content
           space as required blocks are allocated. This snapshot based overlay defaults to an apparent size of
           32 GiB in RAM, and can be adjusted with the <u>rd.live.overlay.size=</u> kernel command line option. This
           file is hidden (and appears deleted) when the boot process switches out of the initramfs to the main
           root filesystem but its loop device remains connected to the Device-mapper snapshot.

           Even with large Device-mapper overlay files for write space, the available root filesystem capacity
           is limited by the total allocated size of the base root filesystem, which often provide only a small
           number of gigabytes of free space.

           This shortage could be remedied by building the root filesystem with more allocated free space, or
           the OverlayFS based overlay mount method can be used.

           When the <u>rd.live.overlay.overlayfs</u> option is specified or when <u>rd.live.overlay=</u> points to an
           appropriate directory with a sister at /../ovlwork, then an OverlayFS based overlay mount is
           employed. Such a persistent OverlayFS overlay can extend the available root filesystem storage up to
           the capacity of the LiveOS disk device.

           For non-persistent OverlayFS overlays, the /run/overlayfs directory in the <a href="file:/run">/run</a> tmpfs is used for
           temporary storage. This filesystem is typically sized to one half of the RAM total in the system.

           The command: mount -o remount,size=&lt;nbytes&gt; <a href="file:/run">/run</a> will resize this virtual filesystem after booting.

           The internal SquashFS structure is traditionally expected to be:

               squashfs.img          |  SquashFS from LiveCD .iso
                  !(mount)
                  /LiveOS
                      |- rootfs.img  |  Usually a ext4 filesystem image to mount read-only
                           !(mount)
                           <a href="file:/bin">/bin</a>      |  Base Live root filesystem
                           <a href="file:/boot">/boot</a>     |
                           <a href="file:/dev">/dev</a>      |
                           ...       |

           For OverlayFS mount overlays, the internal SquashFS structure may be a direct compression of the root
           filesystem:

               squashfs.img          |  SquashFS from LiveCD .iso
                  !(mount)
                  <a href="file:/bin">/bin</a>               |  Base Live root filesystem
                  <a href="file:/boot">/boot</a>              |
                  <a href="file:/dev">/dev</a>               |
                  ...                |

           Dracut uses one of the overlay methods of live booting by default. No additional command line options
           are required other than <b>root=</b>live:<u>&lt;path</u> <u>to</u> <u>blockdevice&gt;</u> or <b>root=</b>live:<u>&lt;URL&gt;</u> to specify the location of
           your squashed root filesystem.

           •   The compressed SquashFS image can be copied during boot to RAM at /run/initramfs/squashed.img by
               using the <b>rd.live.ram=1</b> option.

           •   A device with a persistent overlay can be booted read-only by using the <b>rd.live.overlay.readonly</b>
               option on the kernel command line. This will either cause a temporary, writable overlay to be
               stacked over a read-only snapshot of the root filesystem or the OverlayFS mount will use an
               additional lower layer with the root filesystem.

       Uncompressed live filesystem image
           When the live system was installed with the <u>--skipcompress</u> option of the <u>livecd-iso-to-disk</u>
           installation script for Live USB devices, the root filesystem image, <u>rootfs.img</u>, is expanded on
           installation and no SquashFS is involved during boot.

           •   If <b>rd.live.ram=1</b> is used in this situation, the full, uncompressed root filesystem is copied
               during boot to /run/initramfs/rootfs.img in the <a href="file:/run">/run</a> tmpfs.

           •   If <b>rd.live.overlay=none</b> is provided as a kernel command line option, a writable, linear
               Device-mapper target is created on boot with no overlay.

       Writable filesystem image
           The system will retrieve a compressed filesystem image, extract it to
           /run/initramfs/fsimg/rootfs.img, connect it to a loop device, create a writable, linear Device-mapper
           target at /dev/mapper/live-rw, and mount that as a writable volume at <a href="file:/.">/.</a> More RAM is required during
           boot but the live filesystem is easier to manage if it becomes full. Users can make a filesystem
           image of any size and that size will be maintained when the system boots. There is no persistence of
           root filesystem changes between boots with this option.

           The filesystem structure is expected to be:

               rootfs.tgz            |  Compressed tarball containing filesystem image
                  !(unpack)
                  /rootfs.img        |  Filesystem image at /run/initramfs/fsimg/
                     !(mount)
                     <a href="file:/bin">/bin</a>            |  Live filesystem
                     <a href="file:/boot">/boot</a>           |
                     <a href="file:/dev">/dev</a>            |
                     ...             |

           To use this boot option, ensure that <b>rd.writable.fsimg=1</b> is in your kernel command line and add the
           <b>root=live:&lt;URL&gt;</b> to specify the location of your compressed filesystem image tarball or SquashFS
           image.

       <b>rd.writable.fsimg=</b>1
           Enables writable filesystem support. The system will boot with a fully writable (but non-persistent)
           filesystem without snapshots <u>(see</u> <u>notes</u> <u>above</u> <u>about</u> <u>available</u> <u>live</u> <u>boot</u> <u>options)</u>. You can use the
           <b>rootflags</b> option to set mount options for the live filesystem as well <u>(see</u> <u>documentation</u> <u>about</u>
           <u>rootflags</u> <u>in</u> <u>the</u> <b>Standard</b> <u>section</u> <u>above)</u>. This implies that the whole image is copied to RAM before
           the boot continues.

               <b>Note</b>
               There must be enough free RAM available to hold the complete image.
           This method is very suitable for diskless boots.

       <b>rd.minmem=</b><u>&lt;megabyte&gt;</u>
           Specify minimum free RAM in MB after copying a live disk image into memory. The default is 1024.

           This parameter only applies together with the parameters rd.writable.fsimg or rd.live.ram.

       <b>root=</b>live:<u>&lt;url&gt;</u>
           Boots a live image retrieved from <u>&lt;url&gt;</u>. Requires the dracut <u>livenet</u> module. Valid handlers: <u>http,</u>
           <u>https,</u> <u>ftp,</u> <u>torrent,</u> <u>tftp</u>.

           <b>Example</b> <b>21.</b> <b>Examples</b>

               root=live:<a href="http://example.com/liveboot.img">http://example.com/liveboot.img</a>
               root=live:<a href="ftp://ftp.example.com/liveboot.img">ftp://ftp.example.com/liveboot.img</a>
               root=live:torrent://example.com/liveboot.img.torrent

       <b>rd.live.debug=</b>1
           Enables debug output from the live boot process.

       <b>rd.live.dir=</b><u>&lt;path&gt;</u>
           Specifies the directory within the boot device where the squashfs.img or rootfs.img can be found. By
           default, this is /LiveOS.

       <b>rd.live.squashimg=</b><u>&lt;filename</u> <u>of</u> <u>SquashFS</u> <u>image&gt;</u>
           Specifies the filename for a SquashFS image of the root filesystem. By default, this is <u>squashfs.img</u>.

       <b>rd.live.ram=</b>1
           Copy the complete image to RAM and use this for booting. This is useful when the image resides on,
           e.g., a DVD which needs to be ejected later on.

       <b>rd.live.overlay={</b><u>&lt;devspec&gt;</u>[:<u>{&lt;pathspec&gt;|auto}</u>]|<u>none</u>}
           Manage the usage of a persistent overlay.

           •   <u>&lt;devspec&gt;</u> specifies the path to a device with a mountable filesystem.

           •   <u>&lt;pathspec&gt;</u> is a path within the <u>&lt;devspec&gt;</u> filesystem to either

               •   a file (that is loop mounted for a Device-mapper overlay) or

               •   a directory (that is symbolically linked to /run/overlayfs for a OverlayFS mount overlay). (A
                   required sister directory /&lt;pathspec&gt;/../ovlwork is automatically made.)

           •   <u>none</u> (the word itself) specifies that no overlay will be used, such as when an uncompressed,
               writable live root filesystem is available.

           The above method shall be used to persist the changes made to the root filesystem specified within
           the

           <b>root=</b>live:<u>&lt;path</u> <u>to</u> <u>blockdevice&gt;</u> or <b>root=</b>live:<u>&lt;url&gt;</u> device.

           The default <u>pathspec</u>, when <b>:auto</b> or no <b>:</b><u>&lt;pathspec&gt;</u> is given, is
           /&lt;rd.live.dir&gt;/overlay-&lt;label&gt;-&lt;uuid&gt;, where <u>&lt;label&gt;</u> and <u>&lt;uuid&gt;</u> are the LABEL and UUID of the
           filesystem specified by the <b>root=</b>live:<u>&lt;path|url&gt;</u> device.

           If a persistent overlay <u>is</u> <u>detected</u> at the standard LiveOS path, and <u>rd.live.overlay.overlayfs</u> is not
           set to 1, the overlay type (either Device-mapper or OverlayFS) will be detected and it will be used.

           <b>Example</b> <b>22.</b> <b>Examples</b>

               rd.live.overlay=/dev/sdb1:/persistent-overlay.img
               rd.live.overlay=UUID=99440c1f-8daa-41bf-b965-b7240a8996f4

       <b>rd.live.overlay.cowfs=</b><u>[btrfs|ext4|xfs]</u>
           Specifies the filesystem to use when formatting the overlay partition. The default is ext4.

       <b>rd.live.overlay.size=</b><u>&lt;size_MiB&gt;</u>
           Specifies a non-persistent Device-mapper overlay size in MiB. The default is <u>32768</u>.

       <b>rd.live.overlay.readonly=</b>1
           This is used to boot in a read-only mode with a normally read-write persistent overlay. With this
           option,

           •   Device-mapper overlays will have an additional, non-persistent, writable snapshot overlay stacked
               over a read-only snapshot (/dev/mapper/live-ro) of the base root filesystem and the persistent
               overlay, or

           •   for writable rootfs.img images, the above over a read-only loop device, or

           •   an OverlayFS mount will link the persistent overlay directory at /run/overlayfs-r as an
               additional read-only lower layer stacked over the base root filesystem, and /run/overlayfs
               becomes the temporary, writable, upper directory overlay, to complete the bootable root
               filesystem.

       <b>rd.live.overlay.nouserconfirmprompt=</b>
           Suppresses the <u>Using</u> <u>temporary</u> <u>overlay</u> blocking prompt that asks for a user confirmation before
           proceeding to boot. This allows the boot process to continue to completion without user interation.

       <b>rd.live.overlay.reset=</b>1
           Specifies that a persistent overlay should be reset on boot. All previous root filesystem changes are
           vacated by this action.

       <b>rd.live.overlay.thin=</b>1
           Enables the usage of thin snapshots instead of classic dm snapshots. The advantage of thin snapshots
           is that they support discards, and will free blocks that are not claimed by the filesystem. In this
           use case, this means that memory is given back to the kernel when the filesystem does not claim it
           anymore.

       <b>rd.live.overlay.overlayfs=</b>1
           Enables the use of the <b>OverlayFS</b> kernel module, if available, to provide a copy-on-write union
           directory for the root filesystem. OverlayFS overlays are directories of the files that have changed
           on the read-only base (lower) filesystem. The root filesystem is provided through a special overlay
           type mount that merges at least two directories, designated the lower and the upper. If an OverlayFS
           upper directory is not present on the boot device, a tmpfs directory will be created at
           /run/overlayfs to provide temporary storage. Persistent storage can be provided on vfat or msdos
           formatted devices by supplying the OverlayFS upper directory within an embedded filesystem that
           supports the creation of trusted.* extended attributes and provides a valid d_type in readdir
           responses, such as with btrfs, ext4, f2fs, &amp; xfs. On non-vfat-formatted devices, a persistent
           OverlayFS overlay can extend the available root filesystem storage up to the capacity of the LiveOS
           disk device.

           The <b>rd.live.overlay.readonly</b> option, which allows a persistent overlayfs to be mounted read-only
           through a higher level transient overlay directory, has been implemented through the multiple lower
           layers feature of OverlayFS.

   <b>ZIPL</b>
       <b>rd.zipl=</b><u>&lt;path</u> <u>to</u> <u>blockdevice&gt;</u>
           Update the dracut commandline with the values found in the <u>dracut-cmdline.conf</u> file on the given
           device. The values are merged into the existing commandline values and the udev events are
           regenerated.

           <b>Example</b> <b>23.</b> <b>Example</b>

               rd.zipl=UUID=0fb28157-99e3-4395-adef-da3f7d44835a

   <b>CIO_IGNORE</b>
       <b>rd.cio_accept=</b><u>&lt;device-ids&gt;</u>
           Remove the devices listed in &lt;device-ids&gt; from the default cio_ignore kernel command-line settings.
           &lt;device-ids&gt; is a list of comma-separated CCW device ids. The default for this value is taken from
           the <u>/boot/zipl/active_devices.txt</u> file.

           <b>Example</b> <b>24.</b> <b>Example</b>

               rd.cio_accept=0.0.0180,0.0.0800,0.0.0801,0.0.0802

   <b>Plymouth</b> <b>Boot</b> <b>Splash</b>
       <b>plymouth.enable=0</b>
           disable the plymouth bootsplash completely.

       <b>rd.plymouth=0</b>
           disable the plymouth bootsplash only for the initramfs.

   <b>Kernel</b> <b>keys</b>
       <b>masterkey=</b><u>&lt;kernel</u> <u>master</u> <u>key</u> <u>path</u> <u>name&gt;</u>
           Set the path name of the kernel master key.

           <b>Example</b> <b>25.</b> <b>Example</b>

               masterkey=/etc/keys/kmk-trusted.blob

       <b>masterkeytype=</b><u>&lt;kernel</u> <u>master</u> <u>key</u> <u>type&gt;</u>
           Set the type of the kernel master key.

           <b>Example</b> <b>26.</b> <b>Example</b>

               masterkeytype=trusted

       <b>evmkey=</b><u>&lt;EVM</u> <u>HMAC</u> <u>key</u> <u>path</u> <u>name&gt;</u>
           Set the path name of the EVM HMAC key.

           <b>Example</b> <b>27.</b> <b>Example</b>

               evmkey=/etc/keys/evm-trusted.blob

       <b>evmx509=</b><u>&lt;EVM</u> <u>X.509</u> <u>cert</u> <u>path</u> <u>name&gt;</u>
           Set the path name of the EVM X.509 certificate.

           <b>Example</b> <b>28.</b> <b>Example</b>

               evmx509=/etc/keys/x509_evm.der

       <b>ecryptfskey=</b><u>&lt;eCryptfs</u> <u>key</u> <u>path</u> <u>name&gt;</u>
           Set the path name of the eCryptfs key.

           <b>Example</b> <b>29.</b> <b>Example</b>

               ecryptfskey=/etc/keys/ecryptfs-trusted.blob

   <b>Deprecated,</b> <b>renamed</b> <b>Options</b>
       Here is a list of options and their new replacement.

       rd_NO_DM
           rd.dm=0

       rd_NO_MDADMCONF
           rd.md.conf=0

       rd_NO_MDIMSM
           rd.md.imsm=0

       rd_NO_MD
           rd.md=0

       rd_MD_UUID
           rd.md.uuid

       iscsi_initiator
           rd.iscsi.initiator

       iscsi_target_name
           rd.iscsi.target.name

       iscsi_target_ip
           rd.iscsi.target.ip

       iscsi_target_port
           rd.iscsi.target.port

       iscsi_target_group
           rd.iscsi.target.group

       iscsi_username
           rd.iscsi.username

       iscsi_password
           rd.iscsi.password

       iscsi_in_username
           rd.iscsi.in.username

       iscsi_in_password
           rd.iscsi.in.password

       iscsi_firmware
           rd.iscsi.firmware=0

       rdudevdebug
           rd.udev.udev_log=debug

       rdudevinfo
           rd.udev.udev_log=info

       rd.udev.debug
           rd.udev.udev_log=debug

       rd.udev.info
           rd.udev.udev_log=info

       KEYMAP
           vconsole.keymap

       KEYTABLE
           vconsole.keymap

       SYSFONT
           vconsole.font

       CONTRANS
           vconsole.font.map

       UNIMAP
           vconsole.font.unimap

       UNICODE
           vconsole.unicode

       EXT_KEYMAP
           vconsole.keymap.ext

   <b>Configuration</b> <b>in</b> <b>the</b> <b>Initramfs</b>
       <u>/etc/conf.d/</u>
           Any files found in <u>/etc/conf.d/</u> will be sourced in the initramfs to set initial values. Command line
           options will override these values set in the configuration files.

       <u>/etc/cmdline</u>
           Can contain additional command line options. Deprecated, better use /etc/cmdline.d/*.conf.

       <u>/etc/cmdline.d/*.conf</u>
           Can contain additional command line options.

</pre><h4><b>AUTHOR</b></h4><pre>
       Harald Hoyer

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/dracut.8.html">dracut</a></b>(8) <b><a href="../man5/dracut.conf.5.html">dracut.conf</a></b>(5)

</pre><h4><b>NOTES</b></h4><pre>
        1. rfc4173
           <a href="http://tools.ietf.org/html/rfc4173">http://tools.ietf.org/html/rfc4173</a>#section-5

dracut 107-1ubuntu5                                07/08/2025                                  <u><a href="../man7/DRACUT.CMDLINE.7.html">DRACUT.CMDLINE</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>