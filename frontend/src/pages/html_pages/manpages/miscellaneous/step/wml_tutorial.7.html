<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WML Tutorial - Understanding WML step-by-step</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/wml">wml_2.32.0~ds1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       WML Tutorial - Understanding WML step-by-step

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This tutorial gives you a step-by-step introduction to the features of WML, separated into tiny lessons.
       Each lesson shows one particular aspect or feature of WML.  The order of lessons go from easy and trivial
       to hard and complex.

</pre><h4><b>IMPLICIT</b> <b>MARKUP</b> <b>PROCESSING</b></h4><pre>
   <b>LESSON:</b> <b>Plain</b> <b>Data</b> <b>Throughput</b>
       In this lesson we first learn that WML is 95% of the time transparent to its input, i.e. we can pass
       through any data without corruption.

       Input:

        1| foo
        2| &lt;bar&gt;
        3| quux

       Output:

        1| foo
        2| &lt;bar&gt;
        3| quux

       This is because per default there are neither definitions for symbols "foo" or "quux" nor a defined HTML
       tag named "&lt;bar&gt;". And because there are no unnecessary whitespaces in this example, the input cannot be
       stripped in any case.

   <b>LESSON:</b> <b>Protected</b> <b>Markup</b> <b>Code</b>
       Sometimes situations can occur where some of your markup code or page contents conflicts with WML due to
       overlapping tagnames, etc. Here WML interprets some stuff you actually don't want to be interpreted.

       Input:

        1| foo: foo.c
        2|    $(CC) -o foo foo.c

       Output:

        1| foo: foo.c
        2|     -o foo foo.c

       Here the `"$(CC)"' was expanded to an empty string because IPP uses the same syntax for variable
       interpolation like <u>make</u>. To avoid this just surround the critical part with the WML-internal "&lt;protect&gt;"
       container tag.

       Input:

        1| foo: foo.c
        2|    &lt;protect&gt;$(CC)&lt;/protect&gt; -o foo foo.c

       Output:

        1| foo: foo.c
        2|    $(CC) -o foo foo.c

   <b>LESSON:</b> <b>Stripped-Down</b> <b>Markup</b> <b>Code</b>
       Now let's try an example which has unnecessary whitespaces. Be careful, `unnecessary' here means they can
       be stripped as long as the resulting Webpage displays the same in a Webbrowser as the original.

       Input:

        1| &lt;body&gt;
        2|
        3| &lt;img src = "file.gif"    alt="  test  " &gt;
        4| &lt;pre&gt;
        5|
        6|     Preformatted          Text
        7| &lt;/pre&gt;
        8|     Not    Preformatted   Text
        9| &lt;/body&gt;

       Output:

        1| &lt;body&gt;
        2| &lt;img src="file.gif" alt=" test "&gt;
        4| &lt;pre&gt;
        5|
        6|     Preformatted          Text
        7| &lt;/pre&gt;
        8|     Not Preformatted Text
        9| &lt;/body&gt;

       Here we see that line 2 is completely removed because empty lines have no effect in HTML. The whitespaces
       between the attribute "src" and its value are removed, too. And all double whitespaces are replaced by a
       single whitespace character. But not inside preformatted areas.

   <b>LESSON:</b> <b>Fixed</b> <b>And</b> <b>Adjusted</b> <b>Markup</b> <b>Code</b>
       Now assume that we have an <u>image.gif</u> file containing a GIF image with a size of 500x400 pixels and the
       following input page:

        1| &lt;body&gt;
        2| &lt;center&gt;
        3| &lt;font color=336699&gt;Headline:&lt;/font&gt;&lt;br&gt;
        4| &lt;img src="image.gif"&gt;
        5| &lt;/center&gt;
        6| &lt;/body&gt;

       Although this is valid HTML code, WML can enhance it to make it more portable, speed up it rendering in
       the Webbrowser and make <u>Lynx</u> users more happy. So WML recognizes the "&lt;img&gt;" tag and automatically adds
       missing information and replaces obsolete tags with up-to-date variants:

        1| &lt;body&gt;
        2| &lt;div align=center&gt;
        3| &lt;font color="#336699"&gt;Headline:&lt;/font&gt;&lt;br&gt;
        4| &lt;img src="image.gif" alt="" width="500" height="400"&gt;
        5| &lt;/div&gt;
        6| &lt;/body&gt;

       As you can see, WML first replaced the proprietary "&lt;center&gt;" tag with the HTML 3.2 pedant "&lt;div
       align=center&gt;", second it fixed the "color" attribute of "&lt;font&gt;". And third it added missing "alt" and
       "width"/"height" attributes.

</pre><h4><b>STRUCTURING</b> <b>THE</b> <b>MARKUP</b> <b>CODE</b></h4><pre>
   <b>LESSON:</b> <b>Using</b> <b>Include</b> <b>Files</b>
       One of the most useful features of WML is the ability to move commonly used stuff into include files
       which can be selectively read in at later steps.

       Assume we have an include file <u>bar.wml</u>...

        1| bar
        2| The value of bar is: $(bar:-unknown)

       ...and the following input file:

        1| foo
        3| #include 'bar.wml' bar="FooBar"
        2| #include 'bar.wml'
        5| quux

       Then the output is:

        1| foo
        2| bar
        3| The value of bar is: Foobar
        4| bar
        5| The value of bar is: unknown
        6| quux

       As you can see, the "#include" directive is replaced by the contents of the corresponding file. And this
       included contents can contain variables which are interpolated when they are defined, inclusive default
       values.

       There is also a way to create simple constructs similar to an if-then-else just by using variable
       interpolation:

         1| The value of bar is $(bar:+set)$(bar:*unset).

       Here the `"$(bar:+set)$(bar:*unset)"' construct emulates the following semantics:

         if (isdefined(bar))
             expandto("set")
         if (not isdefined(bar))
             expandto("unset")

   <b>LESSON:</b> <b>Concatenating</b> <b>Lines</b>
       Although HTML usually does not care about whitespaces and newlines, sometimes it is very frustrating to
       create preformatted areas or write own tags (see later) without the ability to spread the code over more
       than one line while it should be actually one single line. For this a lot of languages use a line
       concatenation/continuation character `"\"', as does WML.

       Input:

        1| foo\
        2|    bar \
        3| quux

       Output:

        1| foobar quux

       The line concatenation strips whitespaces from the begin of concatenated lines but preserves whitespaces
       at the end of them, i.e. you can use leading whitespaces for structuring your input nicely but still use
       appended whitespaces for real ones.

   <b>LESSON:</b> <b>Diverting</b> <b>To</b> <b>Locations</b>
       One of the most powerful features of WML is the ability to <u>divert</u> data at any point to <u>locations</u> defined
       at any other point.

       Input:

        1| {#BAR#:this is:##}
        2| foo
        3| {#BAR#}
        4| quux
        5| {#BAR#: bar:##}
        6| foobar
        7| {#BAR#}

       Output:

        1| foo
        2| this is bar
        3| quux
        4| foobar
        5| this is bar

       Here in line 3 the location "BAR" is already dumped, but filled at lines 1 and 5.  And as you can see a
       location can be dumped at any point and even more than once. And you can accumulate the contents for a
       location by subsequent fills (line 1 and 5). This works because in WML first all locations are filled in
       a first pass and then dumped in a second pass.

       With the use of the high-level tags from <u>wml::std::tags</u> we also could write the example above in a little
       bit more human readable way:

        1| #use wml::std::tags
        2| &lt;divert BAR&gt;this is&lt;/divert&gt;
        3| foo
        4| &lt;dump BAR&gt;
        5| quux
        6| &lt;divert BAR&gt; bar&lt;/divert&gt;
        7| foobar
        8| &lt;dump BAR&gt;

   <b>LESSON:</b> <b>Defining</b> <b>Output</b> <b>Slices</b>
       Often one needs more than one output file. Usually although 90% of the contents is the same, one needs a
       way to select the remaining 10%. WML's approach here is to write these 10% directly in the input file but
       separate the variants by defining <u>slices</u> which later can be used to create the different output files.

        1| &lt;html&gt;
        2| &lt;head&gt;
        3| &lt;title&gt;[EN:Titleline:][DE:Titelzeile:]&lt;/title&gt;
        4| &lt;/head&gt;
        5| &lt;body&gt;
        6| &lt;h1&gt;[EN:Headerline:][DE:Ueberschrift:]&lt;/h1&gt;
        7| &lt;/body&gt;
        8| &lt;/html&gt;

       Now assume the above page is in file <u>index.wml</u>, then the command

        $ wml -o UNDEF+EN:index.html.en \
              -o UNDEF+DE:index.html.de index.wml

       generates the output file "index.html.en" containing the union of all undefined areas and the slices
       `"EN"'...

        1| &lt;html&gt;
        2| &lt;head&gt;
        3| &lt;title&gt;Titleline&lt;/title&gt;
        4| &lt;/head&gt;
        5| &lt;body&gt;
        6| &lt;h1&gt;Headerline&lt;/h1&gt;
        7| &lt;/body&gt;
        8| &lt;/html&gt;

       ...and the output file "index.html.de" containing the union of all undefined areas and the slices `"DE"':

        1| &lt;html&gt;
        2| &lt;head&gt;
        3| &lt;title&gt;Titelzeile&lt;/title&gt;
        4| &lt;/head&gt;
        5| &lt;body&gt;
        6| &lt;h1&gt;Ueberschrift&lt;/h1&gt;
        7| &lt;/body&gt;
        8| &lt;/html&gt;

</pre><h4><b>FORMATTING</b></h4><pre>
   <b>LESSON:</b> <b>Area</b> <b>Substitution</b>
       WML provides an area substitution feature which works by specifying the begin and end of the area and
       inserting some Perl substitution and translation commands.

       Input:

        1| foo
        2| {: [[s/foo/bar/g]] [[s/quux/foobar/g]] [[tr/[a-z]/[A-Z]/]]
        3| this is foo and quux.
        4| :}
        5| quux

       Output:

        1| foo
        2| THIS IS BAR AND FOOBAR.
        3| quux

       Because this seems useless, we go further and show an example of the "&lt;isolatin&gt;" and "&lt;url&gt;" container
       tags from <u>wml::fmt::isolatin</u> and <u>wml::fmt::url</u> which are programmed this way.

       Input:

        1| #use wml::fmt::isolatin
        2| #use wml::fmt::url
        3| &lt;isolatin&gt;&lt;url&gt;
        4| Some umlauts `XXXXXX' and
        5| a hyperlink <a href="http://foo.bar.com/">http://foo.bar.com/</a>
        6| &lt;/url&gt;&lt;/isolatin&gt;

       Output:

        1| Some umlauts `&amp;ouml;&amp;auml;&amp;uuml;&amp;Ouml;&amp;Auml;&amp;szlig;' and
        2| a hyperlink &lt;a href="<a href="http://foo.bar.com/">http://foo.bar.com/</a>"&gt;<a href="http://foo.bar.com/">http://foo.bar.com/</a>&lt;/a&gt;

   <b>LESSON:</b> <b>Text</b> <b>Formatting</b>
       HTML sucks when it comes to write more than one paragraph of text.  So WML provides nice ways to format
       an area of input via other (externally available) markup language processors. Here is an example which
       used two embedded areas, the first one is written in <u>Plain</u> <u>Old</u> <u>Document</u> (POD) format, second one is
       written in <u>Simple</u> <u>Document</u> <u>Format</u> (SDF).

       Input:

         1| #use wml::fmt::pod
         2| #use wml::fmt::sdf
         3| &lt;html&gt;
         4| &lt;pod notypo&gt;
         5| =head1 Headline1
         6|
         7| Foo
         8|
         9| =head2 Headline1.1
        10|
        11| Bar
        12| &lt;/pod&gt;
        13|
        14| &lt;sdf notypo&gt;
        15| H1: Headline1
        16|
        17| Foo
        18|
        19| H2: Headline 1.1
        20|
        21| Bar
        22|   * Baz
        23|     - Foobar
        24|     - Quux
        25|   * Foo
        26| &lt;/sdf&gt;
        27| &lt;/html&gt;

       Output:

         1| &lt;html&gt;
         2| &lt;P&gt;
         3| &lt;H1&gt;&lt;A NAME="Headline1"&gt;Headline1
         4| &lt;/A&gt;&lt;/H1&gt;
         5| Foo
         6| &lt;P&gt;
         7| &lt;H2&gt;&lt;A NAME="Headline1_1"&gt;Headline1.1
         8| &lt;/A&gt;&lt;/H2&gt;
         9| Bar
        10| &lt;P&gt;
        11| &lt;H1&gt;&lt;A NAME="Headline1"&gt;1. Headline1&lt;/A&gt;&lt;/H1&gt;
        12| &lt;P&gt;Foo&lt;/P&gt;
        13| &lt;H2&gt;&lt;A NAME="Headline 1.1"&gt;1.1. Headline 1.1&lt;/A&gt;&lt;/H2&gt;
        14| &lt;P&gt;Bar&lt;/P&gt;
        15| &lt;UL&gt;
        16| &lt;LI&gt;Baz&lt;UL&gt;
        17| &lt;LI&gt;Foobar
        18| &lt;LI&gt;Quux&lt;/UL&gt;
        19| &lt;LI&gt;Foo&lt;/UL&gt;
        20| &lt;/html&gt;

   <b>LESSON:</b> <b>Table</b> <b>Formatting</b>
       Another point where the HTML markup code is unproductive and ugly is when it comes to write some
       "&lt;table&gt;" structures. Here WML provides two new container tags which make your live easier:

       <b>&lt;grid&gt;</b>
           The goal of this container tag is to provide a way to specify tables the same way you have it in your
           mind,  i.e.  as a 2-dimensional grid. So, a grid is created by specifying a grid-layout and then fill
           its cells. Additionally the "&lt;grid&gt;" container tag provides a nice feature for  specifying  the  cell
           alignments.

           Input:

             1| #use wml::std::grid
             2| &lt;grid layout=2x3 align=lr valign=tbb border=1&gt;
             3|   &lt;cell&gt;Header 1&lt;/cell&gt; &lt;cell&gt;Header 2&lt;/cell&gt;
             4|   &lt;cell&gt;Cell-A&lt;/cell&gt;   &lt;cell&gt;Cell-B&lt;/cell&gt;
             5|   &lt;cell&gt;Cell-C&lt;/cell&gt;   &lt;cell&gt;Cell-D&lt;/cell&gt;
             6| &lt;/grid&gt;

           Output:

             1| &lt;table border="1" cellspacing="0" cellpadding="0"&gt;
             2|   &lt;tr&gt;
             3|     &lt;td align=left valign=top&gt;Header 1&lt;/td&gt;
             4|     &lt;td align=right valign=top&gt;Header 2&lt;/td&gt;
             5|   &lt;/tr&gt;
             6|   &lt;tr&gt;
             7|     &lt;td align=left valign=bottom&gt;Cell-A&lt;/td&gt;
             8|     &lt;td align=right valign=bottom&gt;Cell-B&lt;/td&gt;
             9|   &lt;/tr&gt;
            10|   &lt;tr&gt;
            11|     &lt;td align=left valign=bottom&gt;Cell-C&lt;/td&gt;
            12|     &lt;td align=right valign=bottom&gt;Cell-D&lt;/td&gt;
            13|   &lt;/tr&gt;
            14| &lt;/table&gt;

       <b>&lt;xtable&gt;</b>
           This  is  the  extended  "&lt;table&gt;"  container  tag which syntax is provided by the external <u>freetable</u>
           program. Its goal is to provide a compact syntax for specifying a table. Again the same example:

           Input:

             1| #use wml::fmt::xtable
             2| &lt;xtable border=1&gt;
             3|   (*, 1) align=left
             4|   (*, 2) align=right
             5|   (1, *) valign=top
             6|   (2|3, *) valign=bottom
             7|   (1,1)
             8|   Header 1
             9|   (1,2)
            10|   Header 2
            11|   (2,1)
            12|   Cell-A
            13|   (2,2)
            14|   Cell-B
            15|   (3,1)
            16|   Cell-C
            17|   (3,2)
            18|   Cell-D
            19| &lt;/xtable&gt;

           Output:

             1| &lt;table border="1"&gt;
             2|   &lt;tr valign=top&gt;
             3|     &lt;td align=left&gt;Header 1&lt;/td&gt;
             4|     &lt;td align=right&gt;Header 2&lt;/td&gt;
             5|   &lt;/tr&gt;
             6|   &lt;tr&gt;
             7|     &lt;td align=left valign=bottom&gt;Cell-A&lt;/td&gt;
             8|     &lt;td align=right valign=bottom&gt;Cell-B&lt;/td&gt;
             9|   &lt;/tr&gt;
            10|   &lt;tr&gt;
            11|     &lt;td align=left valign=bottom&gt;Cell-C&lt;/td&gt;
            12|     &lt;td align=right valign=bottom&gt;Cell-D&lt;/td&gt;
            13|   &lt;/tr&gt;
            14| &lt;/table&gt;

</pre><h4><b>DEFINITION</b> <b>OF</b> <b>OWN</b> <b>HTML</b> <b>TAGS</b></h4><pre>
   <b>LESSON:</b> <b>Simple</b> <b>Tags</b> <b>And</b> <b>Container</b> <b>Tags</b>
       Now it is time to enhance our markup language by defining new custom HTML tags.  There are two  types  of
       HTML tags:

       <b>Simple</b> <b>Tags</b>
           As an example let us define a "&lt;me&gt;" tag which expands to my name abbreviation.

           Input:

            1| &lt;define-tag me whitespace=delete&gt;
            2| <a href="mailto:rse@engelschall.com">rse@engelschall.com</a>
            3| &lt;/define-tag&gt;
            4|
            5| This is &lt;me&gt;.

           Output:

            1| This is <a href="mailto:rse@engelschall.com">rse@engelschall.com</a>.

       <b>Container</b> <b>Tags</b>
           As an example let us define a "&lt;red&gt;" tag which changes its body text color to red.

           Input:

             1| &lt;define-tag red endtag=required whitespace=delete&gt;
             2| &lt;font color="#cc3333"&gt;%body&lt;/font&gt;
             3| &lt;/define-tag&gt;
             4|
             5| This is &lt;red&gt;very important&lt;/red&gt;.

           Output:

             1| This is &lt;font color="#cc3333"&gt;very important&lt;/font&gt;.

   <b>LESSON:</b> <b>Tags</b> <b>With</b> <b>Attributes</b>
       Because  tags  without  attributes are not very flexible there is also a way to define tags which can use
       these.

       Input:

         1| &lt;define-tag me whitespace=delete&gt;
         2| &lt;if   "%0" ""            "<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>"&gt;
         3| &lt;ifeq "%0" "engelschall" "<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>"&gt;
         4| &lt;ifeq "%0" "netsw"       "<a href="mailto:rse@netsw.org">rse@netsw.org</a>"&gt;
         5| &lt;ifeq "%0" "apache"      "<a href="mailto:rse@apache.org">rse@apache.org</a>"&gt;
         6| &lt;ifeq "%0" "freebsd"     "<a href="mailto:rse@freebsd.org">rse@freebsd.org</a>"&gt;
         7| &lt;ifeq "%0" "sdm"         "<a href="mailto:rse@sdm.de">rse@sdm.de</a>"&gt;
         8| &lt;/define-tag&gt;
         9|
        10| This is &lt;me&gt; and &lt;me apache&gt;.

       Output:

          1| This is <a href="mailto:rse@engelschall.com">rse@engelschall.com</a> and <a href="mailto:rse@apache.org">rse@apache.org</a>.

       There is also a variant to use attributes of type "name=value":

       Input:

         2| &lt;define-tag me whitespace=delete&gt;
         3| &lt;preserve at&gt;
         4| &lt;set-var %attributes&gt;
         5| &lt;if   "&lt;get-var at&gt;" ""            "<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>"&gt;
         6| &lt;ifeq "&lt;get-var at&gt;" "engelschall" "<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>"&gt;
         7| &lt;ifeq "&lt;get-var at&gt;" "netsw"       "<a href="mailto:rse@netsw.org">rse@netsw.org</a>"&gt;
         8| &lt;ifeq "&lt;get-var at&gt;" "apache"      "<a href="mailto:rse@apache.org">rse@apache.org</a>"&gt;
         9| &lt;ifeq "&lt;get-var at&gt;" "freebsd"     "<a href="mailto:rse@freebsd.org">rse@freebsd.org</a>"&gt;
        10| &lt;ifeq "&lt;get-var at&gt;" "sdm"         "<a href="mailto:rse@sdm.de">rse@sdm.de</a>"&gt;
        11| &lt;restore at&gt;
        12| &lt;/define-tag&gt;
        13|
        14| This is &lt;me&gt; and &lt;me at=apache&gt;.

       Output:

          1| This is <a href="mailto:rse@engelschall.com">rse@engelschall.com</a> and <a href="mailto:rse@apache.org">rse@apache.org</a>.

   <b>LESSON:</b> <b>Overwriting</b> <b>Existing</b> <b>HTML</b> <b>Tags</b>
       WML also provides a way to overwrite existing HTML tags, i.e.  you can define a custom tag with the  same
       name as an already known HTML tag and use the original HTML tag inside it.

       Input:

          1| &lt;define-tag br whitespace=delete&gt;
          2| &lt;br*&gt;&lt;br*&gt;
          4| &lt;/define-tag&gt;
          5|
          6| Some Text&lt;br&gt;
          7| Some more Text

       Output:

          1| Some Text&lt;br&gt;&lt;br&gt;
          2| Some more Text

   <b>LESSON:</b> <b>Programming</b> <b>Tags</b> <b>In</b> <b>Perl</b>
       One  of  the  essential  features  in  WML is that you can embed Perl code at any point, just marked with
       `"&lt;:"' and `":&gt;"' delimiters.  This can be combined with the tag definitions by programming tags in Perl.

       Input:

         1| #use wml::std::tags
         2| &lt;define-tag me whitespace=delete&gt;
         3| &lt;preserve at&gt;
         4| &lt;set-var %attributes&gt;
         5| &lt;:{
         6|     my $at = qq/&lt;get-var at&gt;/;
         7|     my $addr;
         8|     $addr = "rse\@engelschall.com" if $at eq '';
         9|     $addr = "rse\@engelschall.com" if $at eq 'engelschall';
        10|     $addr = "rse\@netsw.org"       if $at eq 'netsw';
        11|     $addr = "rse\@apache.org"      if $at eq 'apache';
        12|     $addr = "rse\@freebsd.org"     if $at eq 'freebsd';
        13|     $addr = "rse\@sdm.de"          if $at eq 'sdm';
        14|     print $addr;
        15| }:&gt;
        16| &lt;restore at&gt;
        17| &lt;/define-tag&gt;
        18|
        19| This is &lt;me&gt; and &lt;me at=apache&gt;.

       Output:

         1| This is <a href="mailto:rse@engelschall.com">rse@engelschall.com</a> and <a href="mailto:rse@apache.org">rse@apache.org</a>.

</pre><h4><b>ADVANCED</b> <b>FEATURES</b></h4><pre>
   <b>LESSON:</b> <b>Using</b> <b>Templates</b>
       We've already seen how to divert data to a location.   Because  WML  automatically  closes  still  opened
       diversions  at  EndOfFile,  we  can  use  this feature to create templates.  Assume we have the following
       template defined in the file <u>template.wml</u>.

         1| #   the template itself
         2| &lt;html&gt;
         3| &lt;head&gt;
         4| &lt;title&gt;{#SUBJECT_LOC#}&lt;/title&gt;
         5| &lt;/head&gt;
         6| &lt;body&gt;
         7| &lt;h1&gt;{#SUBJECT_LOC#}&lt;/h1&gt;
         8| &lt;blockquote&gt;
         9| {#BODY#}
        10| &lt;/blockquote&gt;
        11| &lt;/body&gt;
        12| &lt;/html&gt;
        13|
        14| #   way to insert the subject
        15| &lt;define-tag subject&gt;
        16| {#SUBJECT_LOC#:%0:##}
        17| &lt;/define-tag&gt;
        18|
        19| #   per default we are in body
        20| {#BODY#:

       Input:

         1| #include 'template.wml'
         2|
         3| &lt;subject "Foo, Bar and Quux"&gt;
         4|
         5| This is about Foo, Bar and Quux...

       Output:

         1| &lt;html&gt;
         2| &lt;head&gt;
         3| &lt;title&gt;Foo, Bar and Quux&lt;/title&gt;
         4| &lt;/head&gt;
         5| &lt;body&gt;
         6| &lt;h1&gt;Foo, Bar and Quux&lt;/h1&gt;
         7| &lt;blockquote&gt;
         8| This is about Foo, Bar and Quux...
         9| &lt;/blockquote&gt;
        10| &lt;/body&gt;
        11| &lt;/html&gt;

       You can even nest more than one template because the diversion mechanism in WML  accepts  location  dumps
       and location fills at any point, even within other location fills.

   <b>LESSON:</b> <b>Creating</b> <b>Multi-Lingual</b> <b>Pages</b>
       The  core  languages of WML don't provide a dedicated facility to create multi-lingual pages, i.e. one or
       more output pages created out of a single input source, each one containing the same page information but
       in different human languages. But WML provides variants through ``slicing'' (Pass 9) and human  languages
       are  just a special case of general variants.  So wml::std::lang exists which provides specialized multi-
       lingual support tags which are mapped to slices which then can be  used  to  create  the  various  output
       files.

       Let take an example:

         1| #!wml -o (ALL-LANG_*)+LANG_EN:index.en.html \
         2|       -o (ALL-LANG_*)+LANG_DE:index.de.html
         3|
         4| #use wml::std::page
         5| #use wml::std::lang
         6|
         7| &lt;lang:new id=en short&gt;
         8| &lt;lang:new id=de short&gt;
         9|
        10| &lt;page&gt;
        11|
        12| &lt;h1&gt;&lt;en: Welcome&gt;&lt;de: Willkommen&gt;!&lt;/h1&gt;
        13|
        14| &lt;a href="&lt;lang:star: index2.*.html&gt;"&gt;Index 2&lt;/a&gt;
        15|
        16| &lt;lang:area&gt;
        17| (en)This is a test page
        18| (de)Dies ist eine Testseite
        19| &lt;/lang:area&gt;

       After processing passes 1 to 8 ("wml -p1-8") the following is internally generated by WML:

         1| &lt;html&gt;
         2| &lt;head&gt;
         3| &lt;/head&gt;
         4| &lt;body bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066"&gt;
         5| &lt;h1&gt;[LANG_EN:Welcome:][LANG_DE:Willkommen:]!&lt;/h1&gt;
         6| &lt;a href="[LANG_EN:index2.en.html:][LANG_DE:index2.de.html:]"&gt;Index 2&lt;/a&gt;
         7| [LANG_EN:This is a test page
         8| :][LANG_DE:Dies ist eine Testseite:]
         9| &lt;/body&gt;
        10| &lt;/html&gt;

       And then after processing pass 9 with the initial WML magic cookie line ("#!wml -o...") the following two
       files are generated:

       index.en.html:

         1| &lt;html&gt;
         2| &lt;head&gt;
         3| &lt;/head&gt;
         4| &lt;body bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066"&gt;
         5| &lt;h1&gt;Welcome!&lt;/h1&gt;
         6| &lt;a href="index2.en.html"&gt;Index 2&lt;/a&gt;
         7| This is a test page
         8|
         9| &lt;/body&gt;
        10| &lt;/html&gt;

       index.de.html:

         1| &lt;html&gt;
         2| &lt;head&gt;
         3| &lt;/head&gt;
         4| &lt;body bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066"&gt;
         5| &lt;h1&gt;Willkommen!&lt;/h1&gt;
         6| &lt;a href="index2.de.html"&gt;Index 2&lt;/a&gt;
         7| Dies ist eine Testseite
         8| &lt;/body&gt;
         9| &lt;/html&gt;

       And  these  two pages then can be served by a content negotiation feature of the webserver or by explicit
       references.

</pre><h4><b>MORE</b> <b>INFORMATION</b></h4><pre>
       Now you've seen the various core languages of WML in action. For the gory details of what  each  language
       provides  either  read  the  all-in-one  WML  Introduction in <b><a href="../man7/wml_intro.7.html">wml_intro</a></b>(7) or step through the particular
       manpages of the core languages.  Start here with the frontend <b><a href="../man1/wml.1.html">wml</a></b>(1).

       Additionally can can step through the set of available standard include files WML ships with. Start  with
       the top-level include file <b>wml::<a href="../man3/all.3.html">all</a></b>(3).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/wml_intro.7.html">wml_intro</a></b>(7)

       <b><a href="../man3/wml_p1_ipp.3.html">wml_p1_ipp</a></b>(3),   <b><a href="../man1/mp4h.1.html">mp4h</a></b>(1),   <b><a href="../man1/eperl.1.html">eperl</a></b>(1),   <b><a href="../man1/m4.1.html">m4</a></b>(1),   <b><a href="../man3/wml_p5_divert.3.html">wml_p5_divert</a></b>(3),  <b><a href="../man3/wml_p6_asubst.3.html">wml_p6_asubst</a></b>(3),  <b><a href="../man3/wml_p7_htmlfix.3.html">wml_p7_htmlfix</a></b>(3),
       <b><a href="../man3/wml_p8_htmlstrip.3.html">wml_p8_htmlstrip</a></b>(3), <b><a href="../man1/slice.1.html">slice</a></b>(1).

       <b>wml::<a href="../man3/all.3.html">all</a></b>(3)

EN Tools                                           2020-11-29                                    <u><a href="../man7/WML_TUTORIAL.7.html">WML_TUTORIAL</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>