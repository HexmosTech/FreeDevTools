<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_KDF-SS - The Single Step / One Step EVP_KDF implementation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openssl">openssl_3.5.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_KDF-SS - The Single Step / One Step EVP_KDF implementation

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The EVP_KDF-SS algorithm implements the Single Step key derivation function (SSKDF).  SSKDF derives a key
       using input such as a shared secret key (that was generated during the execution of a key establishment
       scheme) and fixedinfo.  SSKDF is also informally referred to as 'Concat KDF'.

       The output is considered to be keying material.

   <b>Auxiliary</b> <b>function</b>
       The implementation uses a selectable auxiliary function H, which can be one of:

       <b>H(x)</b> <b>=</b> <b>hash(x,</b> <b>digest=md)</b>
       <b>H(x)</b> <b>=</b> <b>HMAC_hash(x,</b> <b>key=salt,</b> <b>digest=md)</b>
       <b>H(x)</b> <b>=</b> <b>KMACxxx(x,</b> <b>key=salt,</b> <b>custom="KDF",</b> <b>outlen=mac_size)</b>

       Both  the  HMAC  and  KMAC  implementations  set  the key using the 'salt' value.  The hash and HMAC also
       require the digest to be set.

   <b>Identity</b>
       "SSKDF" is the name for this implementation; it can be used with the <b>EVP_KDF_fetch()</b> function.

   <b>Supported</b> <b>parameters</b>
       The supported parameters are:

       "properties" (<b>OSSL_KDF_PARAM_PROPERTIES</b>) &lt;UTF8 string&gt;
       "digest" (<b>OSSL_KDF_PARAM_DIGEST</b>) &lt;UTF8 string&gt;
           This parameter is ignored for KMAC.

       "mac" (<b>OSSL_KDF_PARAM_MAC</b>) &lt;UTF8 string&gt;
       "maclen" (<b>OSSL_KDF_PARAM_MAC_SIZE</b>) &lt;unsigned integer&gt;
       "salt" (<b>OSSL_KDF_PARAM_SALT</b>) &lt;octet string&gt;
           These parameters work as described in "PARAMETERS" in <b><a href="../man3/EVP_KDF.3.html">EVP_KDF</a></b>(3).

       "key" (<b>OSSL_KDF_PARAM_SECRET</b>) &lt;octet string&gt;
           This parameter set the shared secret that is used for key derivation.

       "info" (<b>OSSL_KDF_PARAM_INFO</b>) &lt;octet string&gt;
           This parameter sets an optional value for fixedinfo, also known as otherinfo.

       The OpenSSL FIPS provider also supports the following parameters:

       "fips-indicator" (<b>OSSL_KDF_PARAM_FIPS_APPROVED_INDICATOR</b>) &lt;integer&gt;
           A getter that returns 1 if the operation is FIPS approved, or 0 otherwise.  This may  be  used  after
           calling EVP_KDF_derive. It returns 0 if "key-check" is set to 0 and the check fails.

       "key-check" (<b>OSSL_KDF_PARAM_FIPS_KEY_CHECK</b>) &lt;integer&gt;
           The  default  value  of  1 causes an error during <b>EVP_KDF_CTX_set_params()</b> if the length of used key-
           derivation key (<b>OSSL_KDF_PARAM_KEY</b>) is shorter than 112 bits.  Setting this to zero will  ignore  the
           error  and  set  the approved "fips-indicator" to 0.  This option breaks FIPS compliance if it causes
           the approved "fips-indicator" to return 0.

</pre><h4><b>NOTES</b></h4><pre>
       A context for SSKDF can be obtained by calling:

        EVP_KDF *kdf = EVP_KDF_fetch(NULL, "SSKDF", NULL);
        EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);

       The output length of an SSKDF is specified via the <u>keylen</u> parameter to the <b><a href="../man3/EVP_KDF_derive.3.html">EVP_KDF_derive</a></b>(3) function.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This example derives 10 bytes using H(x) = SHA-256, with the secret  key  "secret"  and  fixedinfo  value
       "label":

        EVP_KDF *kdf;
        EVP_KDF_CTX *kctx;
        unsigned char out[10];
        OSSL_PARAM params[4], *p = params;

        kdf = EVP_KDF_fetch(NULL, "SSKDF", NULL);
        kctx = EVP_KDF_CTX_new(kdf);
        EVP_KDF_free(kdf);

        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
                                                SN_sha256, strlen(SN_sha256));
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
                                                 "secret", (size_t)6);
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
                                                 "label", (size_t)5);
        *p = OSSL_PARAM_construct_end();
        if (EVP_KDF_derive(kctx, out, sizeof(out), params) &lt;= 0) {
            error("EVP_KDF_derive");
        }

        EVP_KDF_CTX_free(kctx);

       This  example  derives 10 bytes using H(x) = HMAC(SHA-256), with the secret key "secret", fixedinfo value
       "label" and salt "salt":

        EVP_KDF *kdf;
        EVP_KDF_CTX *kctx;
        unsigned char out[10];
        OSSL_PARAM params[6], *p = params;

        kdf = EVP_KDF_fetch(NULL, "SSKDF", NULL);
        kctx = EVP_KDF_CTX_new(kdf);
        EVP_KDF_free(kdf);

        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC,
                                                SN_hmac, strlen(SN_hmac));
        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
                                                SN_sha256, strlen(SN_sha256));
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
                                                 "secret", (size_t)6);
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
                                                 "label", (size_t)5);
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
                                                 "salt", (size_t)4);
        *p = OSSL_PARAM_construct_end();
        if (EVP_KDF_derive(kctx, out, sizeof(out), params) &lt;= 0) {
            error("EVP_KDF_derive");
        }

        EVP_KDF_CTX_free(kctx);

       This example derives 10 bytes using H(x) = KMAC128(x,salt,outlen), with the secret key "secret" fixedinfo
       value "label", salt of "salt" and KMAC outlen of 20:

        EVP_KDF *kdf;
        EVP_KDF_CTX *kctx;
        unsigned char out[10];
        OSSL_PARAM params[6], *p = params;

        kdf = EVP_KDF_fetch(NULL, "SSKDF", NULL);
        kctx = EVP_KDF_CTX_new(kdf);
        EVP_KDF_free(kdf);

        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC,
                                                SN_kmac128, strlen(SN_kmac128));
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
                                                 "secret", (size_t)6);
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
                                                 "label", (size_t)5);
        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
                                                 "salt", (size_t)4);
        *p++ = OSSL_PARAM_construct_size_t(OSSL_KDF_PARAM_MAC_SIZE, (size_t)20);
        *p = OSSL_PARAM_construct_end();
        if (EVP_KDF_derive(kctx, out, sizeof(out), params) &lt;= 0) {
            error("EVP_KDF_derive");
        }

        EVP_KDF_CTX_free(kctx);

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       NIST SP800-56Cr1.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/EVP_KDF.3.html">EVP_KDF</a></b>(3),         <b><a href="../man3/EVP_KDF_CTX_new.3.html">EVP_KDF_CTX_new</a></b>(3),          <b><a href="../man3/EVP_KDF_CTX_free.3.html">EVP_KDF_CTX_free</a></b>(3),          <b><a href="../man3/EVP_KDF_CTX_set_params.3.html">EVP_KDF_CTX_set_params</a></b>(3),
       <b><a href="../man3/EVP_KDF_CTX_get_kdf_size.3.html">EVP_KDF_CTX_get_kdf_size</a></b>(3), <b><a href="../man3/EVP_KDF_derive.3.html">EVP_KDF_derive</a></b>(3), "PARAMETERS" in <b><a href="../man3/EVP_KDF.3.html">EVP_KDF</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       This functionality was added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  2019-2024 The OpenSSL Project Authors. All Rights Reserved.  Copyright (c) 2019, Oracle and/or
       its affiliates.  All rights reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                   <u><a href="../man7SSL/EVP_KDF-SS.7SSL.html">EVP_KDF-SS</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>