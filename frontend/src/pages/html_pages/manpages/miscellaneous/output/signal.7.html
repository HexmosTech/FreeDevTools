<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>signal - overview of signals</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       signal - overview of signals

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Linux supports both POSIX reliable signals (hereinafter "standard signals") and POSIX real-time signals.

   <b>Signal</b> <b>dispositions</b>
       Each  signal has a current <u>disposition</u>, which determines how the process behaves when it is delivered the
       signal.

       The entries in the "Action" column of the table below specify the default disposition for each signal, as
       follows:

       Term   Default action is to terminate the process.

       Ign    Default action is to ignore the signal.

       Core   Default action is to terminate the process and dump core (see <b><a href="../man5/core.5.html">core</a></b>(5)).

       Stop   Default action is to stop the process.

       Cont   Default action is to continue the process if it is currently stopped.

       A process can change the disposition of a signal using <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) or <b><a href="../man2/signal.2.html">signal</a></b>(2).  (The  latter  is  less
       portable  when  establishing  a  signal handler; see <b><a href="../man2/signal.2.html">signal</a></b>(2) for details.)  Using these system calls, a
       process can elect one of the following behaviors to occur on delivery of the signal: perform the  default
       action;  ignore the signal; or catch the signal with a <u>signal</u> <u>handler</u>, a programmer-defined function that
       is automatically invoked when the signal is delivered.

       By default, a signal handler is invoked on the normal process stack.  It is possible to arrange that  the
       signal handler uses an alternate stack; see <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2) for a discussion of how to do this and when it
       might be useful.

       The  signal  disposition is a per-process attribute: in a multithreaded application, the disposition of a
       particular signal is the same for all threads.

       A child created via <b><a href="../man2/fork.2.html">fork</a></b>(2) inherits a copy of its parent's signal dispositions.   During  an  <b><a href="../man2/execve.2.html">execve</a></b>(2),
       the  dispositions  of  handled  signals are reset to the default; the dispositions of ignored signals are
       left unchanged.

   <b>Sending</b> <b>a</b> <b>signal</b>
       The following system calls and library functions allow the caller to send a signal:

       <b><a href="../man3/raise.3.html">raise</a></b>(3)
              Sends a signal to the calling thread.

       <b><a href="../man2/kill.2.html">kill</a></b>(2)
              Sends a signal to a specified process, to all members of a specified  process  group,  or  to  all
              processes on the system.

       <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2)
              Sends a signal to a process identified by a PID file descriptor.

       <b><a href="../man3/killpg.3.html">killpg</a></b>(3)
              Sends a signal to all of the members of a specified process group.

       <b><a href="../man3/pthread_kill.3.html">pthread_kill</a></b>(3)
              Sends a signal to a specified POSIX thread in the same process as the caller.

       <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2)
              Sends  a signal to a specified thread within a specific process.  (This is the system call used to
              implement <b><a href="../man3/pthread_kill.3.html">pthread_kill</a></b>(3).)

       <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3)
              Sends a real-time signal with accompanying data to a specified process.

   <b>Waiting</b> <b>for</b> <b>a</b> <b>signal</b> <b>to</b> <b>be</b> <b>caught</b>
       The following system calls suspend execution of the calling thread  until  a  signal  is  caught  (or  an
       unhandled signal terminates the process):

       <b><a href="../man2/pause.2.html">pause</a></b>(2)
              Suspends execution until any signal is caught.

       <b><a href="../man2/sigsuspend.2.html">sigsuspend</a></b>(2)
              Temporarily  changes  the signal mask (see below) and suspends execution until one of the unmasked
              signals is caught.

   <b>Synchronously</b> <b>accepting</b> <b>a</b> <b>signal</b>
       Rather than asynchronously catching a signal via a signal handler, it is possible to synchronously accept
       the signal, that is, to block execution until the signal is delivered, at which point the kernel  returns
       information about the signal to the caller.  There are two general ways to do this:

       •  <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2),  <b><a href="../man2/sigtimedwait.2.html">sigtimedwait</a></b>(2),  and  <b><a href="../man3/sigwait.3.html">sigwait</a></b>(3)  suspend  execution  until  one of the signals in a
          specified set is delivered.  Each of these calls returns information about the delivered signal.

       •  <b><a href="../man2/signalfd.2.html">signalfd</a></b>(2) returns a file descriptor that can be used to read  information  about  signals  that  are
          delivered  to  the  caller.  Each <b><a href="../man2/read.2.html">read</a></b>(2) from this file descriptor blocks until one of the signals in
          the set specified in the <b><a href="../man2/signalfd.2.html">signalfd</a></b>(2) call is delivered to the caller.  The buffer returned by  <b><a href="../man2/read.2.html">read</a></b>(2)
          contains a structure describing the signal.

   <b>Signal</b> <b>mask</b> <b>and</b> <b>pending</b> <b>signals</b>
       A  signal may be <u>blocked</u>, which means that it will not be delivered until it is later unblocked.  Between
       the time when it is generated and when it is delivered a signal is said to be <u>pending</u>.

       Each thread in a process has an independent <u>signal</u> <u>mask</u>, which indicates the  set  of  signals  that  the
       thread  is  currently  blocking.  A thread can manipulate its signal mask using <b><a href="../man3/pthread_sigmask.3.html">pthread_sigmask</a></b>(3).  In a
       traditional single-threaded application, <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2) can be used to manipulate the signal mask.

       A child created via <b><a href="../man2/fork.2.html">fork</a></b>(2) inherits a copy of its parent's signal mask; the  signal  mask  is  preserved
       across <b><a href="../man2/execve.2.html">execve</a></b>(2).

       A  signal  may be process-directed or thread-directed.  A process-directed signal is one that is targeted
       at (and thus pending for) the process as a whole.  A  signal  may  be  process-directed  because  it  was
       generated by the kernel for reasons other than a hardware exception, or because it was sent using <b><a href="../man2/kill.2.html">kill</a></b>(2)
       or  <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3).  A thread-directed signal is one that is targeted at a specific thread.  A signal may be
       thread-directed because it was generated as  a  consequence  of  executing  a  specific  machine-language
       instruction  that  triggered  a hardware exception (e.g., <b>SIGSEGV</b> for an invalid memory access, or <b>SIGFPE</b>
       for a math error), or because it was targeted at a specific thread using interfaces such as <b><a href="../man2/tgkill.2.html">tgkill</a></b>(2)  or
       <b><a href="../man3/pthread_kill.3.html">pthread_kill</a></b>(3).

       A  process-directed  signal  may  be delivered to any one of the threads that does not currently have the
       signal blocked.  If more than one of the threads has the signal unblocked, then  the  kernel  chooses  an
       arbitrary thread to which to deliver the signal.

       A  thread can obtain the set of signals that it currently has pending using <b><a href="../man2/sigpending.2.html">sigpending</a></b>(2).  This set will
       consist of the union of the set of pending process-directed signals and the set of  signals  pending  for
       the calling thread.

       A  child  created  via  <b><a href="../man2/fork.2.html">fork</a></b>(2)  initially  has  an  empty  pending signal set; the pending signal set is
       preserved across an <b><a href="../man2/execve.2.html">execve</a></b>(2).

   <b>Execution</b> <b>of</b> <b>signal</b> <b>handlers</b>
       Whenever there is a transition from kernel-mode to user-mode execution (e.g., on  return  from  a  system
       call  or  scheduling  of  a  thread onto the CPU), the kernel checks whether there is a pending unblocked
       signal for which the process has established a signal handler.  If there is such a  pending  signal,  the
       following steps occur:

       (1)  The kernel performs the necessary preparatory steps for execution of the signal handler:

            (1.1)  The signal is removed from the set of pending signals.

            (1.2)  If  the  signal handler was installed by a call to <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) that specified the <b>SA_ONSTACK</b>
                   flag and the thread has defined an alternate signal stack (using <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2)),  then  that
                   stack is installed.

            (1.3)  Various  pieces  of  signal-related context are saved into a special frame that is created on
                   the stack.  The saved information includes:

                   •  the program counter register (i.e., the address  of  the  next  instruction  in  the  main
                      program that should be executed when the signal handler returns);

                   •  architecture-specific register state required for resuming the interrupted program;

                   •  the thread's current signal mask;

                   •  the thread's alternate signal stack settings.

                   If  the  signal  handler was installed using the <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) <b>SA_SIGINFO</b> flag, then the above
                   information is accessible via the <u>ucontext_t</u> object that is pointed to by the third  argument
                   of  the  signal  handler.   This  object reflects the state at which the signal is delivered,
                   rather than in the handler; for example, the mask of blocked signals stored  in  this  object
                   will not contain the mask of new signals blocked through <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2).

            (1.4)  Any  signals  specified  in  <u>act-&gt;sa_mask</u>  when registering the handler with <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) are
                   added to the thread's signal mask.  The signal being delivered is also added  to  the  signal
                   mask,  unless  <b>SA_NODEFER</b> was specified when registering the handler.  These signals are thus
                   blocked while the handler executes.

       (2)  The kernel constructs a frame for the signal handler on the stack.   The  kernel  sets  the  program
            counter  for  the  thread  to  point  to  the  first instruction of the signal handler function, and
            configures the return address for that function to point to a piece of user-space code known as  the
            signal trampoline (described in <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2)).

       (3)  The  kernel  passes control back to user-space, where execution commences at the start of the signal
            handler function.

       (4)  When the signal handler returns, control passes to the signal trampoline code.

       (5)  The signal trampoline calls <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2), a system call that uses the information in the stack frame
            created in step 1 to restore the thread to its state before the  signal  handler  was  called.   The
            thread's  signal  mask  and  alternate signal stack settings are restored as part of this procedure.
            Upon completion of the call to <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2), the kernel transfers control back to  user  space,  and
            the thread recommences execution at the point where it was interrupted by the signal handler.

       Note  that  if  the signal handler does not return (e.g., control is transferred out of the handler using
       <b><a href="../man3/siglongjmp.3.html">siglongjmp</a></b>(3), or the handler executes a new  program  with  <b><a href="../man2/execve.2.html">execve</a></b>(2)),  then  the  final  step  is  not
       performed.   In  particular, in such scenarios it is the programmer's responsibility to restore the state
       of the signal mask (using <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)), if it is desired to unblock the signals that were  blocked  on
       entry  to the signal handler.  (Note that <b><a href="../man3/siglongjmp.3.html">siglongjmp</a></b>(3) may or may not restore the signal mask, depending
       on the <u>savesigs</u> value that was specified in the corresponding call to <b><a href="../man3/sigsetjmp.3.html">sigsetjmp</a></b>(3).)

       From the kernel's point of view, execution of the  signal  handler  code  is  exactly  the  same  as  the
       execution  of  any  other  user-space code.  That is to say, the kernel does not record any special state
       information indicating that the thread is currently executing inside a  signal  handler.   All  necessary
       state  information  is  maintained  in user-space registers and the user-space stack.  The depth to which
       nested signal handlers may be invoked is thus limited only by the user-space stack (and sensible software
       design!).

   <b>Standard</b> <b>signals</b>
       Linux supports the standard signals listed below.   The  second  column  of  the  table  indicates  which
       standard  (if  any)  specified the signal: "P1990" indicates that the signal is described in the original
       POSIX.1-1990 standard; "P2001" indicates that the signal was added in SUSv2 and POSIX.1-2001.
       Signal      Standard   Action   Comment
       ────────────────────────────────────────────────────────────────────────
       <b>SIGABRT</b>      P1990      Core    Abort signal from <b><a href="../man3/abort.3.html">abort</a></b>(3)
       <b>SIGALRM</b>      P1990      Term    Timer signal from <b><a href="../man2/alarm.2.html">alarm</a></b>(2)
       <b>SIGBUS</b>       P2001      Core    Bus error (bad memory access)
       <b>SIGCHLD</b>      P1990      Ign     Child stopped or terminated
       <b>SIGCLD</b>         -        Ign     A synonym for <b>SIGCHLD</b>
       <b>SIGCONT</b>      P1990      Cont    Continue if stopped
       <b>SIGEMT</b>         -        Term    Emulator trap
       <b>SIGFPE</b>       P1990      Core    Floating-point exception
       <b>SIGHUP</b>       P1990      Term    Hangup detected on controlling terminal
                                       or death of controlling process
       <b>SIGILL</b>       P1990      Core    Illegal Instruction
       <b>SIGINFO</b>        -                A synonym for <b>SIGPWR</b>
       <b>SIGINT</b>       P1990      Term    Interrupt from keyboard
       <b>SIGIO</b>          -        Term    I/O now possible (4.2BSD)
       <b>SIGIOT</b>         -        Core    IOT trap. A synonym for <b>SIGABRT</b>
       <b>SIGKILL</b>      P1990      Term    Kill signal
       <b>SIGLOST</b>        -        Term    File lock lost (unused)
       <b>SIGPIPE</b>      P1990      Term    Broken pipe: write to pipe with no
                                       readers; see <b><a href="../man7/pipe.7.html">pipe</a></b>(7)
       <b>SIGPOLL</b>      P2001      Term    Pollable event (Sys V);
                                       synonym for <b>SIGIO</b>
       <b>SIGPROF</b>      P2001      Term    Profiling timer expired
       <b>SIGPWR</b>         -        Term    Power failure (System V)
       <b>SIGQUIT</b>      P1990      Core    Quit from keyboard
       <b>SIGSEGV</b>      P1990      Core    Invalid memory reference
       <b>SIGSTKFLT</b>      -        Term    Stack fault on coprocessor (unused)
       <b>SIGSTOP</b>      P1990      Stop    Stop process
       <b>SIGTSTP</b>      P1990      Stop    Stop typed at terminal
       <b>SIGSYS</b>       P2001      Core    Bad system call (SVr4);
                                       see also <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2)
       <b>SIGTERM</b>      P1990      Term    Termination signal
       <b>SIGTRAP</b>      P2001      Core    Trace/breakpoint trap
       <b>SIGTTIN</b>      P1990      Stop    Terminal input for background process
       <b>SIGTTOU</b>      P1990      Stop    Terminal output for background process
       <b>SIGUNUSED</b>      -        Core    Synonymous with <b>SIGSYS</b>
       <b>SIGURG</b>       P2001      Ign     Urgent condition on socket (4.2BSD)
       <b>SIGUSR1</b>      P1990      Term    User-defined signal 1
       <b>SIGUSR2</b>      P1990      Term    User-defined signal 2
       <b>SIGVTALRM</b>    P2001      Term    Virtual alarm clock (4.2BSD)
       <b>SIGXCPU</b>      P2001      Core    CPU time limit exceeded (4.2BSD);
                                       see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)
       <b>SIGXFSZ</b>      P2001      Core    File size limit exceeded (4.2BSD);
                                       see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)
       <b>SIGWINCH</b>       -        Ign     Window resize signal (4.3BSD, Sun)

       The signals <b>SIGKILL</b> and <b>SIGSTOP</b> cannot be caught, blocked, or ignored.

       Up to and including Linux 2.2, the default behavior for <b>SIGSYS</b>, <b>SIGXCPU</b>, <b>SIGXFSZ</b>, and  (on  architectures
       other  than  SPARC  and  MIPS) <b>SIGBUS</b> was to terminate the process (without a core dump).  (On some other
       UNIX systems the default action for <b>SIGXCPU</b> and <b>SIGXFSZ</b> is to terminate the process without a core dump.)
       Linux 2.4 conforms to the POSIX.1-2001 requirements for these signals, terminating  the  process  with  a
       core dump.

       <b>SIGEMT</b>  is  not specified in POSIX.1-2001, but nevertheless appears on most other UNIX systems, where its
       default action is typically to terminate the process with a core dump.

       <b>SIGPWR</b> (which is not specified in POSIX.1-2001) is typically ignored  by  default  on  those  other  UNIX
       systems where it appears.

       <b>SIGIO</b> (which is not specified in POSIX.1-2001) is ignored by default on several other UNIX systems.

   <b>Queueing</b> <b>and</b> <b>delivery</b> <b>semantics</b> <b>for</b> <b>standard</b> <b>signals</b>
       If  multiple  standard signals are pending for a process, the order in which the signals are delivered is
       unspecified.

       Standard signals do not queue.  If multiple instances of a  standard  signal  are  generated  while  that
       signal  is  blocked,  then  only  one instance of the signal is marked as pending (and the signal will be
       delivered just once when it is unblocked).  In the case where a standard signal is already  pending,  the
       <u>siginfo_t</u>  structure  (see  <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2))  associated  with  that signal is not overwritten on arrival of
       subsequent instances of the same signal.  Thus, the process will receive the information associated  with
       the first instance of the signal.

   <b>Signal</b> <b>numbering</b> <b>for</b> <b>standard</b> <b>signals</b>
       The  numeric value for each signal is given in the table below.  As shown in the table, many signals have
       different numeric values on different architectures.  The first numeric value in each table row shows the
       signal number on x86, ARM, and most other architectures; the second value is for  Alpha  and  SPARC;  the
       third  is  for  MIPS;  and  the  last  is  for PARISC.  A dash (-) denotes that a signal is absent on the
       corresponding architecture.
       Signal        x86/ARM     Alpha/   MIPS   PARISC   Notes
                   most others   SPARC
       ─────────────────────────────────────────────────────────────────
       <b>SIGHUP</b>           1           1       1       1
       <b>SIGINT</b>           2           2       2       2
       <b>SIGQUIT</b>          3           3       3       3
       <b>SIGILL</b>           4           4       4       4
       <b>SIGTRAP</b>          5           5       5       5
       <b>SIGABRT</b>          6           6       6       6
       <b>SIGIOT</b>           6           6       6       6
       <b>SIGBUS</b>           7          10      10      10
       <b>SIGEMT</b>           -           7       7      -
       <b>SIGFPE</b>           8           8       8       8
       <b>SIGKILL</b>          9           9       9       9
       <b>SIGUSR1</b>         10          30      16      16
       <b>SIGSEGV</b>         11          11      11      11
       <b>SIGUSR2</b>         12          31      17      17
       <b>SIGPIPE</b>         13          13      13      13
       <b>SIGALRM</b>         14          14      14      14
       <b>SIGTERM</b>         15          15      15      15
       <b>SIGSTKFLT</b>       16          -       -        7
       <b>SIGCHLD</b>         17          20      18      18
       <b>SIGCLD</b>           -          -       18      -
       <b>SIGCONT</b>         18          19      25      26
       <b>SIGSTOP</b>         19          17      23      24
       <b>SIGTSTP</b>         20          18      24      25
       <b>SIGTTIN</b>         21          21      26      27
       <b>SIGTTOU</b>         22          22      27      28
       <b>SIGURG</b>          23          16      21      29
       <b>SIGXCPU</b>         24          24      30      12
       <b>SIGXFSZ</b>         25          25      31      30
       <b>SIGVTALRM</b>       26          26      28      20
       <b>SIGPROF</b>         27          27      29      21
       <b>SIGWINCH</b>        28          28      20      23
       <b>SIGIO</b>           29          23      22      22
       <b>SIGPOLL</b>                                            Same as SIGIO
       <b>SIGPWR</b>          30         29/-     19      19
       <b>SIGINFO</b>          -         29/-     -       -
       <b>SIGLOST</b>          -         -/29     -       -
       <b>SIGSYS</b>          31          12      12      31
       <b>SIGUNUSED</b>       31          -       -       31

       Note the following:

       •  Where defined, <b>SIGUNUSED</b> is synonymous with <b>SIGSYS</b>.  Since glibc 2.26, <b>SIGUNUSED</b> is no longer  defined
          on any architecture.

       •  Signal 29 is <b>SIGINFO</b>/<b>SIGPWR</b> (synonyms for the same value) on Alpha but <b>SIGLOST</b> on SPARC.

   <b>Real-time</b> <b>signals</b>
       Starting with Linux 2.2, Linux supports real-time signals as originally defined in the POSIX.1b real-time
       extensions  (and  now  included in POSIX.1-2001).  The range of supported real-time signals is defined by
       the macros <b>SIGRTMIN</b> and  <b>SIGRTMAX</b>.   POSIX.1-2001  requires  that  an  implementation  support  at  least
       <b>_POSIX_RTSIG_MAX</b> (8) real-time signals.

       The  Linux  kernel  supports  a range of 33 different real-time signals, numbered 32 to 64.  However, the
       glibc POSIX threads implementation internally uses two (for NPTL) or three (for  LinuxThreads)  real-time
       signals  (see  <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7)), and adjusts the value of <b>SIGRTMIN</b> suitably (to 34 or 35).  Because the range
       of available real-time signals varies according to the glibc threading implementation (and this variation
       can occur at run time according to the available kernel and glibc), and indeed  the  range  of  real-time
       signals  varies  across  UNIX  systems, programs should <u>never</u> <u>refer</u> <u>to</u> <u>real-time</u> <u>signals</u> <u>using</u> <u>hard-coded</u>
       <u>numbers</u>, but instead should always refer to real-time signals using the notation <b>SIGRTMIN</b>+n, and  include
       suitable (run-time) checks that <b>SIGRTMIN</b>+n does not exceed <b>SIGRTMAX</b>.

       Unlike  standard  signals,  real-time  signals  have  no predefined meanings: the entire set of real-time
       signals can be used for application-defined purposes.

       The default action for an unhandled real-time signal is to terminate the receiving process.

       Real-time signals are distinguished by the following:

       •  Multiple instances of real-time signals can be queued.   By  contrast,  if  multiple  instances  of  a
          standard  signal  are  delivered  while  that  signal  is currently blocked, then only one instance is
          queued.

       •  If the signal is sent using <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3), an accompanying value (either an integer or a pointer) can be
          sent with the signal.  If the receiving process establishes  a  handler  for  this  signal  using  the
          <b>SA_SIGINFO</b>  flag to <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), then it can obtain this data via the <u>si_value</u> field of the <u>siginfo_t</u>
          structure passed as the second argument to the handler.  Furthermore, the <u>si_pid</u> and <u>si_uid</u> fields  of
          this structure can be used to obtain the PID and real user ID of the process sending the signal.

       •  Real-time  signals  are  delivered in a guaranteed order.  Multiple real-time signals of the same type
          are delivered in the order they were sent.  If different real-time signals are sent to a process, they
          are delivered starting with the lowest-numbered signal.   (I.e.,  low-numbered  signals  have  highest
          priority.)   By  contrast,  if multiple standard signals are pending for a process, the order in which
          they are delivered is unspecified.

       If both standard and real-time signals are pending for a process, POSIX leaves it  unspecified  which  is
       delivered  first.   Linux,  like  many  other implementations, gives priority to standard signals in this
       case.

       According to POSIX, an implementation should permit at least <b>_POSIX_SIGQUEUE_MAX</b> (32)  real-time  signals
       to  be  queued  to  a process.  However, Linux does things differently.  Up to and including Linux 2.6.7,
       Linux imposes a system-wide limit on the number of queued real-time  signals  for  all  processes.   This
       limit  can  be  viewed  and  (with privilege) changed via the <u>/proc/sys/kernel/rtsig-max</u> file.  A related
       file, <u>/proc/sys/kernel/rtsig-nr</u>, can be used to find out how many real-time signals are currently queued.
       In Linux 2.6.8, these <u><a href="file:/proc">/proc</a></u> interfaces were replaced  by  the  <b>RLIMIT_SIGPENDING</b>  resource  limit,  which
       specifies a per-user limit for queued signals; see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2) for further details.

       The addition of real-time signals required the widening of the signal set structure (<u>sigset_t</u>) from 32 to
       64  bits.   Consequently,  various  system  calls  were superseded by new system calls that supported the
       larger signal sets.  The old and new system calls are as follows:
       <b>Linux</b> <b>2.0</b> <b>and</b> <b>earlier</b>   <b>Linux</b> <b>2.2</b> <b>and</b> <b>later</b>
       <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)            <b><a href="../man2/rt_sigaction.2.html">rt_sigaction</a></b>(2)
       <b><a href="../man2/sigpending.2.html">sigpending</a></b>(2)           <b><a href="../man2/rt_sigpending.2.html">rt_sigpending</a></b>(2)
       <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2)          <b><a href="../man2/rt_sigprocmask.2.html">rt_sigprocmask</a></b>(2)
       <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2)            <b><a href="../man2/rt_sigreturn.2.html">rt_sigreturn</a></b>(2)
       <b><a href="../man2/sigsuspend.2.html">sigsuspend</a></b>(2)           <b><a href="../man2/rt_sigsuspend.2.html">rt_sigsuspend</a></b>(2)
       <b><a href="../man2/sigtimedwait.2.html">sigtimedwait</a></b>(2)         <b><a href="../man2/rt_sigtimedwait.2.html">rt_sigtimedwait</a></b>(2)

   <b>Interruption</b> <b>of</b> <b>system</b> <b>calls</b> <b>and</b> <b>library</b> <b>functions</b> <b>by</b> <b>signal</b> <b>handlers</b>
       If a signal handler is invoked while a system call or library function call is blocked, then either:

       •  the call is automatically restarted after the signal handler returns; or

       •  the call fails with the error <b>EINTR</b>.

       Which of these two behaviors occurs depends on the interface and whether or not the  signal  handler  was
       established  using  the <b>SA_RESTART</b> flag (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)).  The details vary across UNIX systems; below,
       the details for Linux.

       If a blocked call to one of the following interfaces is interrupted by a signal handler, then the call is
       automatically restarted after the signal handler returns if the <b>SA_RESTART</b> flag was used;  otherwise  the
       call fails with the error <b>EINTR</b>:

       •  <b><a href="../man2/read.2.html">read</a></b>(2),  <b><a href="../man2/readv.2.html">readv</a></b>(2), <b><a href="../man2/write.2.html">write</a></b>(2), <b><a href="../man2/writev.2.html">writev</a></b>(2), and <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) calls on "slow" devices.  A "slow" device is one
          where the I/O call may block for an indefinite time, for example, a terminal, pipe, or socket.  If  an
          I/O  call on a slow device has already transferred some data by the time it is interrupted by a signal
          handler, then the call will return a success status (normally, the number of bytes transferred).  Note
          that a (local) disk is not a slow device according to this definition; I/O operations on disk  devices
          are not interrupted by signals.

       •  <b><a href="../man2/open.2.html">open</a></b>(2), if it can block (e.g., when opening a FIFO; see <b><a href="../man7/fifo.7.html">fifo</a></b>(7)).

       •  <b><a href="../man2/wait.2.html">wait</a></b>(2), <b><a href="../man2/wait3.2.html">wait3</a></b>(2), <b><a href="../man2/wait4.2.html">wait4</a></b>(2), <b><a href="../man2/waitid.2.html">waitid</a></b>(2), and <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2).

       •  Socket  interfaces:  <b><a href="../man2/accept.2.html">accept</a></b>(2),  <b><a href="../man2/connect.2.html">connect</a></b>(2),  <b><a href="../man2/recv.2.html">recv</a></b>(2),  <b><a href="../man2/recvfrom.2.html">recvfrom</a></b>(2), <b><a href="../man2/recvmmsg.2.html">recvmmsg</a></b>(2), <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2), <b><a href="../man2/send.2.html">send</a></b>(2),
          <b><a href="../man2/sendto.2.html">sendto</a></b>(2), and <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), unless a timeout has been set on the socket (see below).

       •  File locking interfaces: <b><a href="../man2/flock.2.html">flock</a></b>(2) and the <b>F_SETLKW</b> and <b>F_OFD_SETLKW</b> operations of <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)

       •  POSIX message queue interfaces: <b><a href="../man3/mq_receive.3.html">mq_receive</a></b>(3), <b><a href="../man3/mq_timedreceive.3.html">mq_timedreceive</a></b>(3), <b><a href="../man3/mq_send.3.html">mq_send</a></b>(3), and <b><a href="../man3/mq_timedsend.3.html">mq_timedsend</a></b>(3).

       •  <b><a href="../man2/futex.2.html">futex</a></b>(2) <b>FUTEX_WAIT</b> (since Linux 2.6.22; beforehand, always failed with <b>EINTR</b>).

       •  <b><a href="../man2/getrandom.2.html">getrandom</a></b>(2).

       •  <b><a href="../man3/pthread_mutex_lock.3.html">pthread_mutex_lock</a></b>(3), <b><a href="../man3/pthread_cond_wait.3.html">pthread_cond_wait</a></b>(3), and related APIs.

       •  <b><a href="../man2/futex.2.html">futex</a></b>(2) <b>FUTEX_WAIT_BITSET</b>.

       •  POSIX semaphore interfaces: <b><a href="../man3/sem_wait.3.html">sem_wait</a></b>(3) and <b><a href="../man3/sem_timedwait.3.html">sem_timedwait</a></b>(3) (since Linux 2.6.22;  beforehand,  always
          failed with <b>EINTR</b>).

       •  <b><a href="../man2/read.2.html">read</a></b>(2) from an <b><a href="../man7/inotify.7.html">inotify</a></b>(7) file descriptor (since Linux 3.8; beforehand, always failed with <b>EINTR</b>).

       The  following  interfaces are never restarted after being interrupted by a signal handler, regardless of
       the use of <b>SA_RESTART</b>; they always fail with the error <b>EINTR</b> when interrupted by a signal handler:

       •  "Input"  socket  interfaces,  when  a  timeout  (<b>SO_RCVTIMEO</b>)  has  been  set  on  the  socket   using
          <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2):  <b><a href="../man2/accept.2.html">accept</a></b>(2),  <b><a href="../man2/recv.2.html">recv</a></b>(2), <b><a href="../man2/recvfrom.2.html">recvfrom</a></b>(2), <b><a href="../man2/recvmmsg.2.html">recvmmsg</a></b>(2) (also with a non-NULL <u>timeout</u> argument),
          and <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2).

       •  "Output"  socket  interfaces,  when  a  timeout  (<b>SO_RCVTIMEO</b>)  has  been  set  on  the  socket  using
          <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2): <b><a href="../man2/connect.2.html">connect</a></b>(2), <b><a href="../man2/send.2.html">send</a></b>(2), <b><a href="../man2/sendto.2.html">sendto</a></b>(2), and <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2).

       •  Interfaces used to wait for signals: <b><a href="../man2/pause.2.html">pause</a></b>(2), <b><a href="../man2/sigsuspend.2.html">sigsuspend</a></b>(2), <b><a href="../man2/sigtimedwait.2.html">sigtimedwait</a></b>(2), and <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2).

       •  File  descriptor multiplexing interfaces: <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2), <b><a href="../man2/epoll_pwait.2.html">epoll_pwait</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/ppoll.2.html">ppoll</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2),
          and <b><a href="../man2/pselect.2.html">pselect</a></b>(2).

       •  System V IPC interfaces: <b><a href="../man2/msgrcv.2.html">msgrcv</a></b>(2), <b><a href="../man2/msgsnd.2.html">msgsnd</a></b>(2), <b><a href="../man2/semop.2.html">semop</a></b>(2), and <b><a href="../man2/semtimedop.2.html">semtimedop</a></b>(2).

       •  Sleep interfaces: <b><a href="../man2/clock_nanosleep.2.html">clock_nanosleep</a></b>(2), <b><a href="../man2/nanosleep.2.html">nanosleep</a></b>(2), and <b><a href="../man3/usleep.3.html">usleep</a></b>(3).

       •  <b><a href="../man2/io_getevents.2.html">io_getevents</a></b>(2).

       The <b><a href="../man3/sleep.3.html">sleep</a></b>(3) function is also never restarted if interrupted by a handler, but gives  a  success  return:
       the number of seconds remaining to sleep.

       In certain circumstances, the <b><a href="../man2/seccomp.2.html">seccomp</a></b>(2) user-space notification feature can lead to restarting of system
       calls that would otherwise never be restarted by <b>SA_RESTART</b>; for details, see <b><a href="../man2/seccomp_unotify.2.html">seccomp_unotify</a></b>(2).

   <b>Interruption</b> <b>of</b> <b>system</b> <b>calls</b> <b>and</b> <b>library</b> <b>functions</b> <b>by</b> <b>stop</b> <b>signals</b>
       On  Linux,  even  in  the absence of signal handlers, certain blocking interfaces can fail with the error
       <b>EINTR</b> after the process is stopped by one of the  stop  signals  and  then  resumed  via  <b>SIGCONT</b>.   This
       behavior is not sanctioned by POSIX.1, and doesn't occur on other systems.

       The Linux interfaces that display this behavior are:

       •  "Input"   socket  interfaces,  when  a  timeout  (<b>SO_RCVTIMEO</b>)  has  been  set  on  the  socket  using
          <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2): <b><a href="../man2/accept.2.html">accept</a></b>(2), <b><a href="../man2/recv.2.html">recv</a></b>(2), <b><a href="../man2/recvfrom.2.html">recvfrom</a></b>(2), <b><a href="../man2/recvmmsg.2.html">recvmmsg</a></b>(2) (also with a non-NULL  <u>timeout</u>  argument),
          and <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2).

       •  "Output"  socket  interfaces,  when  a  timeout  (<b>SO_RCVTIMEO</b>)  has  been  set  on  the  socket  using
          <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2): <b><a href="../man2/connect.2.html">connect</a></b>(2), <b><a href="../man2/send.2.html">send</a></b>(2), <b><a href="../man2/sendto.2.html">sendto</a></b>(2), and <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), if a  send  timeout  (<b>SO_SNDTIMEO</b>)  has
          been set.

       •  <b><a href="../man2/epoll_wait.2.html">epoll_wait</a></b>(2), <b><a href="../man2/epoll_pwait.2.html">epoll_pwait</a></b>(2).

       •  <b><a href="../man2/semop.2.html">semop</a></b>(2), <b><a href="../man2/semtimedop.2.html">semtimedop</a></b>(2).

       •  <b><a href="../man2/sigtimedwait.2.html">sigtimedwait</a></b>(2), <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2).

       •  Linux 3.7 and earlier: <b><a href="../man2/read.2.html">read</a></b>(2) from an <b><a href="../man7/inotify.7.html">inotify</a></b>(7) file descriptor

       •  Linux 2.6.21 and earlier: <b><a href="../man2/futex.2.html">futex</a></b>(2) <b>FUTEX_WAIT</b>, <b><a href="../man3/sem_timedwait.3.html">sem_timedwait</a></b>(3), <b><a href="../man3/sem_wait.3.html">sem_wait</a></b>(3).

       •  Linux 2.6.8 and earlier: <b><a href="../man2/msgrcv.2.html">msgrcv</a></b>(2), <b><a href="../man2/msgsnd.2.html">msgsnd</a></b>(2).

       •  Linux 2.4 and earlier: <b><a href="../man2/nanosleep.2.html">nanosleep</a></b>(2).

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1, except as noted.

</pre><h4><b>NOTES</b></h4><pre>
       For a discussion of async-signal-safe functions, see <b><a href="../man7/signal-safety.7.html">signal-safety</a></b>(7).

       The  <u><a href="file:/proc/">/proc/</a></u>pid<u>/task/</u>tid<u>/status</u>  file  contains  various  fields  that  show  the signals that a thread is
       blocking (<u>SigBlk</u>), catching (<u>SigCgt</u>), or ignoring (<u>SigIgn</u>).  (The set  of  signals  that  are  caught  or
       ignored  will be the same across all threads in a process.)  Other fields show the set of pending signals
       that are directed to the thread (<u>SigPnd</u>) as well as the set of pending signals that are directed  to  the
       process  as  a whole (<u>ShdPnd</u>).  The corresponding fields in <u><a href="file:/proc/">/proc/</a></u>pid<u>/status</u> show the information for the
       main thread.  See <b><a href="../man5/proc.5.html">proc</a></b>(5) for further details.

</pre><h4><b>BUGS</b></h4><pre>
       There are six signals that can be delivered as a consequence of a  hardware  exception:  <b>SIGBUS</b>,  <b>SIGEMT</b>,
       <b>SIGFPE</b>,  <b>SIGILL</b>,  <b>SIGSEGV</b>,  and  <b>SIGTRAP</b>.   Which  of  these signals is delivered, for any given hardware
       exception, is not documented and does not always make sense.

       For example, an invalid memory access that causes delivery of <b>SIGSEGV</b> on one CPU architecture  may  cause
       delivery of <b>SIGBUS</b> on another architecture, or vice versa.

       For  another example, using the x86 <u>int</u> instruction with a forbidden argument (any number other than 3 or
       128) causes delivery of <b>SIGSEGV</b>, even though <b>SIGILL</b> would make more sense, because of how the CPU reports
       the forbidden operation to the kernel.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/kill.1.html">kill</a></b>(1), <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2), <b><a href="../man2/kill.2.html">kill</a></b>(2), <b><a href="../man2/pidfd_send_signal.2.html">pidfd_send_signal</a></b>(2),  <b><a href="../man2/restart_syscall.2.html">restart_syscall</a></b>(2),  <b><a href="../man2/rt_sigqueueinfo.2.html">rt_sigqueueinfo</a></b>(2),
       <b><a href="../man2/setitimer.2.html">setitimer</a></b>(2),   <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2),   <b><a href="../man2/sgetmask.2.html">sgetmask</a></b>(2),   <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2),   <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2),   <b><a href="../man2/signal.2.html">signal</a></b>(2),  <b><a href="../man2/signalfd.2.html">signalfd</a></b>(2),
       <b><a href="../man2/sigpending.2.html">sigpending</a></b>(2), <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2),  <b><a href="../man2/sigreturn.2.html">sigreturn</a></b>(2),  <b><a href="../man2/sigsuspend.2.html">sigsuspend</a></b>(2),  <b><a href="../man2/sigwaitinfo.2.html">sigwaitinfo</a></b>(2),  <b><a href="../man3/abort.3.html">abort</a></b>(3),  <b><a href="../man3/bsd_signal.3.html">bsd_signal</a></b>(3),
       <b><a href="../man3/killpg.3.html">killpg</a></b>(3),  <b><a href="../man3/longjmp.3.html">longjmp</a></b>(3),  <b><a href="../man3/pthread_sigqueue.3.html">pthread_sigqueue</a></b>(3),  <b><a href="../man3/raise.3.html">raise</a></b>(3), <b><a href="../man3/sigqueue.3.html">sigqueue</a></b>(3), <b><a href="../man3/sigset.3.html">sigset</a></b>(3), <b><a href="../man3/sigsetops.3.html">sigsetops</a></b>(3), <b><a href="../man3/sigvec.3.html">sigvec</a></b>(3),
       <b><a href="../man3/sigwait.3.html">sigwait</a></b>(3),  <b><a href="../man3/strsignal.3.html">strsignal</a></b>(3),  <b><a href="../man3/swapcontext.3.html">swapcontext</a></b>(3),  <b><a href="../man3/sysv_signal.3.html">sysv_signal</a></b>(3),  <b><a href="../man5/core.5.html">core</a></b>(5),  <b><a href="../man5/proc.5.html">proc</a></b>(5),  <b><a href="../man7/nptl.7.html">nptl</a></b>(7),   <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7),
       <b><a href="../man3type/sigevent.3type.html">sigevent</a></b>(3type)

Linux man-pages 6.9.1                              2024-06-17                                          <u><a href="../man7/signal.7.html">signal</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>