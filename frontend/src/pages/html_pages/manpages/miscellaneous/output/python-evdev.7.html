<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>python-evdev - python-evdev Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/python-evdev-doc">python-evdev-doc_1.9.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       python-evdev - python-evdev Documentation

       This  package provides bindings to the generic input event interface in Linux. The <u>evdev</u> interface serves
       the purpose of passing events generated in the kernel directly to  userspace  through  character  devices
       that are typically located in <b><a href="file:/dev/input/">/dev/input/</a></b>.

       This  package  also comes with bindings to <u>uinput</u>, the userspace input subsystem. <u>Uinput</u> allows userspace
       programs to create and handle input devices that can inject events directly into the input subsystem.

       In other words, <u>python-evdev</u> allows you to read and write input events on Linux. An event can be a key or
       button press, a mouse movement or a tap on a touchscreen.

</pre><h4><b>FROM</b> <b>AN</b> <b>OS</b> <b>PACKAGE</b></h4><pre>
       Python-evdev has been packaged for the following distributions:

       Consult the documentation of your OS package manager for installation instructions.

</pre><h4><b>FROM</b> <b>SOURCE</b></h4><pre>
       The latest stable version of <u>python-evdev</u> can be installed from <u>pypi</u>, provided that you have a  compiler,
       <u>pip</u>  and  the  Python  and  Linux  development  headers  installed  on  your  system. Installing these is
       distribution specific and typically falls into one of the following:

       On a Debian compatible OS:

          $ apt install python-dev python-pip gcc
          $ apt install linux-headers-$(uname -r)

       On a Redhat compatible OS:

          $ dnf install python-devel python-pip gcc
          $ dnf install kernel-headers-$(uname -r)

       On Arch Linux and derivatives:

          $ pacman -S core/linux-api-headers python-pip gcc

       Once all OS dependencies are  available,  you  may  install  <u>python-evdev</u>  using  <u>pip</u>,  preferably  in  a
       [virtualenv]:

          # Install globally (not recommended).
          $ sudo python3 -m pip install evdev

          # Install for the current user.
          $ python3 -m pip install --user evdev

          # Install in a virtual environment.
          $ python3 -m venv abc
          $ source abc/bin/activate
          $ python3 -m pip install evdev

   <b>Specifying</b> <b>header</b> <b>locations</b>
       By  default,  the  setup  script  will  look  for  the  <b>input.h</b>  and <b>input-event-codes.h</b> [1] header files
       <b><a href="file:/usr/include/linux">/usr/include/linux</a></b>.

       You may use the <b>--evdev-headers</b> option to the <b>build_ext</b> setuptools  command  to  the  location  of  these
       header files. It accepts one or more colon-separated paths. For example:

          $ python setup.py build_ext \
              --evdev-headers buildroot/input.h:buildroot/input-event-codes.h \
              --include-dirs  buildroot/ \
              install  # or any other command (e.g. develop, bdist, bdist_wheel)

</pre><h4><b>FROM</b> <b>A</b> <b>BINARY</b> <b>PACKAGE</b></h4><pre>
       You  may  choose  to  install  a  precompiled version of <u>python-evdev</u> from pypi. The <u>evdev-binary</u> package
       provides binary wheels that have been compiled on EL8 against the 4.18.0 kernel headers.

          $ python3 -m pip install evdev-binary

       While the evdev interface is stable, the precompiled version may not be fully compatible  or  expose  all
       the  features  of  your  running  kernel.  For best results, it is recommended to use an OS package or to
       install from source.

       [1]  <b>input-event-codes.h</b> is found only in recent kernel versions.

</pre><h4><b>QUICK</b> <b>START</b></h4><pre>
   <b>Listing</b> <b>accessible</b> <b>event</b> <b>devices</b>
          &gt;&gt;&gt; import evdev

          &gt;&gt;&gt; devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
          &gt;&gt;&gt; for device in devices:
          ...    print(device.path, device.name, device.phys)
          /dev/input/event1    USB Keyboard        usb-0000:00:12.1-2/input0
          /dev/input/event0    USB Optical Mouse   usb-0000:00:12.0-2/input0

       <b>NOTE:</b>
          If you do not see any devices, ensure that your user is in the correct group (typically <b>input</b>) to have
          read/write access.

   <b>Reading</b> <b>events</b> <b>from</b> <b>a</b> <b>device</b>
          &gt;&gt;&gt; import evdev

          &gt;&gt;&gt; device = evdev.InputDevice('/dev/input/event1')
          &gt;&gt;&gt; print(device)
          device /dev/input/event1, name "USB Keyboard", phys "usb-0000:00:12.1-2/input0"

          &gt;&gt;&gt; for event in device.read_loop():
          ...     if event.type == evdev.ecodes.EV_KEY:
          ...         print(evdev.categorize(event))
          ... # pressing 'a' and holding 'space'
          key event at 1337016188.396030, 30 (KEY_A), down
          key event at 1337016188.492033, 30 (KEY_A), up
          key event at 1337016189.772129, 57 (KEY_SPACE), down
          key event at 1337016190.275396, 57 (KEY_SPACE), hold
          key event at 1337016190.284160, 57 (KEY_SPACE), up

   <b>Accessing</b> <b>event</b> <b>codes</b>
       The <b>evdev.ecodes</b> module provides reverse and forward mappings between the names and values of  the  event
       subsystem constants.

          &gt;&gt;&gt; from evdev import ecodes

          &gt;&gt;&gt; ecodes.KEY_A
          ... 30
          &gt;&gt;&gt; ecodes.ecodes['KEY_A']
          ... 30
          &gt;&gt;&gt; ecodes.KEY[30]
          ... 'KEY_A'
          &gt;&gt;&gt; ecodes.bytype[ecodes.EV_KEY][30]
          ... 'KEY_A'

          # A single value may correspond to multiple event codes.
          &gt;&gt;&gt; ecodes.KEY[152]
          ... ['KEY_COFFEE', 'KEY_SCREENLOCK']

   <b>Listing</b> <b>and</b> <b>monitoring</b> <b>input</b> <b>devices</b>
       The  <u>python-evdev</u>  package  also comes with a small command-line program for listing and monitoring input
       devices:

          $ python -m evdev.evtest

</pre><h4><b>TUTORIAL</b></h4><pre>
   <b>Listing</b> <b>accessible</b> <b>event</b> <b>devices</b>
          &gt;&gt;&gt; import evdev

          &gt;&gt;&gt; devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
          &gt;&gt;&gt; for device in devices:
          &gt;&gt;&gt;     print(device.path, device.name, device.phys)
          /dev/input/event1    Dell Dell USB Keyboard   usb-0000:00:12.1-2/input0
          /dev/input/event0    Dell USB Optical Mouse   usb-0000:00:12.0-2/input0

   <b>Listing</b> <b>device</b> <b>capabilities</b>
          &gt;&gt;&gt; import evdev

          &gt;&gt;&gt; device = evdev.InputDevice('/dev/input/event0')
          &gt;&gt;&gt; print(device)
          device /dev/input/event0, name "Dell USB Optical Mouse", phys "usb-0000:00:12.0-2/input0"

          &gt;&gt;&gt; device.capabilities()
          ... { 0: [0, 1, 2], 1: [272, 273, 274, 275], 2: [0, 1, 6, 8], 4: [4] }

          &gt;&gt;&gt; device.capabilities(verbose=True)
          ... { ('EV_SYN', 0): [('SYN_REPORT', 0), ('SYN_CONFIG', 1), ('SYN_MT_REPORT', 2)],
          ...   ('EV_KEY', 1): [('BTN_MOUSE', 272), ('BTN_RIGHT', 273), ('BTN_MIDDLE', 274), ('BTN_SIDE', 275)], ...

   <b>Listing</b> <b>device</b> <b>capabilities</b> <b>(devices</b> <b>with</b> <b>absolute</b> <b>axes)</b>
          &gt;&gt;&gt; import evdev

          &gt;&gt;&gt; device = evdev.InputDevice('/dev/input/event7')
          &gt;&gt;&gt; print(device)
          device /dev/input/event7, name "Wacom Bamboo 2FG 4x5 Finger", phys ""

          &gt;&gt;&gt; device.capabilities()
          ... { 1: [272, 273, 277, 278, 325, 330, 333] ,
          ...   3: [(0, AbsInfo(min=0, max=15360, fuzz=128, flat=0)),
          ...       (1, AbsInfo(min=0, max=10240, fuzz=128, flat=0))] }

          &gt;&gt;&gt; device.capabilities(verbose=True)
          ... { ('EV_KEY', 1): [('BTN_MOUSE', 272), ('BTN_RIGHT', 273), ...],
          ...   ('EV_ABS', 3): [(('ABS_X', 0), AbsInfo(min=0, max=15360, fuzz=128, flat=0)),
          ...                   (('ABS_Y', 1), AbsInfo(min=0, max=10240, fuzz=128, flat=0)),] }

          &gt;&gt;&gt; device.capabilities(absinfo=False)
          ... { 1: [272, 273, 277, 278, 325, 330, 333],
          ...   3: [0, 1, 47, 53, 54, 57] }

   <b>Getting</b> <b>and</b> <b>setting</b> <b>LED</b> <b>states</b>
          &gt;&gt;&gt; dev.leds(verbose=True)
          ... [('LED_NUML', 0), ('LED_CAPSL', 1)]

          &gt;&gt;&gt; dev.leds()
          ... [0, 1]

          &gt;&gt;&gt; dev.set_led(ecodes.LED_NUML, 1)  # enable numlock
          &gt;&gt;&gt; dev.set_led(ecodes.LED_NUML, 0)  # disable numlock

   <b>Getting</b> <b>currently</b> <b>active</b> <b>keys</b>
          &gt;&gt;&gt; dev.active_keys(verbose=True)
          ... [('KEY_3', 4), ('KEY_LEFTSHIFT', 42)]

          &gt;&gt;&gt; dev.active_keys()
          ... [4, 42]

   <b>Reading</b> <b>events</b>
       Reading events from a single device in an endless loop.

          &gt;&gt;&gt; from evdev import InputDevice, categorize, ecodes
          &gt;&gt;&gt; dev = InputDevice('/dev/input/event1')

          &gt;&gt;&gt; print(dev)
          device /dev/input/event1, name "Dell Dell USB Keyboard", phys "usb-0000:00:12.1-2/input0"

          &gt;&gt;&gt; for event in dev.read_loop():
          ...     if event.type == ecodes.EV_KEY:
          ...         print(categorize(event))
          ... # pressing 'a' and holding 'space'
          key event at 1337016188.396030, 30 (KEY_A), down
          key event at 1337016188.492033, 30 (KEY_A), up
          key event at 1337016189.772129, 57 (KEY_SPACE), down
          key event at 1337016190.275396, 57 (KEY_SPACE), hold
          key event at 1337016190.284160, 57 (KEY_SPACE), up

   <b>Reading</b> <b>events</b> <b>(using</b> <b>asyncio)</b>
       <b>NOTE:</b>
          This requires Python 3.5+ for the async/await keywords.

          &gt;&gt;&gt; import asyncio
          &gt;&gt;&gt; from evdev import InputDevice

          &gt;&gt;&gt; dev = InputDevice('/dev/input/event1')

          &gt;&gt;&gt; async def main(dev):
          ...     async for ev in dev.async_read_loop():
          ...         print(repr(ev))

          &gt;&gt;&gt; asyncio.run(main(dev))
          InputEvent(1527363738, 348740, 4, 4, 458792)
          InputEvent(1527363738, 348740, 1, 28, 0)
          InputEvent(1527363738, 348740, 0, 0, 0)

   <b>Reading</b> <b>events</b> <b>from</b> <b>multiple</b> <b>devices</b> <b>(using</b> <b>select)</b>
          &gt;&gt;&gt; from evdev import InputDevice
          &gt;&gt;&gt; from select import select

          # A mapping of file descriptors (integers) to InputDevice instances.
          &gt;&gt;&gt; devices = map(InputDevice, ('/dev/input/event1', '/dev/input/event2'))
          &gt;&gt;&gt; devices = {dev.fd: dev for dev in devices}

          &gt;&gt;&gt; for dev in devices.values(): print(dev)
          device /dev/input/event1, name "Dell Dell USB Keyboard", phys "usb-0000:00:12.1-2/input0"
          device /dev/input/event2, name "Logitech USB Laser Mouse", phys "usb-0000:00:12.0-2/input0"

          &gt;&gt;&gt; while True:
          ...    r, w, x = select(devices, [], [])
          ...    for fd in r:
          ...        for event in devices[fd].read():
          ...            print(event)
          event at 1351116708.002230, code 01, type 02, val 01
          event at 1351116708.002234, code 00, type 00, val 00
          event at 1351116708.782231, code 04, type 04, val 458782
          event at 1351116708.782237, code 02, type 01, val 01

   <b>Reading</b> <b>events</b> <b>from</b> <b>multiple</b> <b>devices</b> <b>(using</b> <b>selectors)</b>
       This can also be achieved using the <b>selectors</b> module in Python 3.4:

          from evdev import InputDevice
          from selectors import DefaultSelector, EVENT_READ

          selector = DefaultSelector()

          mouse = InputDevice('/dev/input/event1')
          keybd = InputDevice('/dev/input/event2')

          # This works because InputDevice has a `fileno()` method.
          selector.register(mouse, EVENT_READ)
          selector.register(keybd, EVENT_READ)

          while True:
              for key, mask in selector.select():
                  device = key.fileobj
                  for event in device.read():
                      print(event)

   <b>Reading</b> <b>events</b> <b>from</b> <b>multiple</b> <b>devices</b> <b>(using</b> <b>asyncio)</b>
       Yet another possibility is the <b>asyncio</b> module from Python 3.4:

          import asyncio, evdev

          @asyncio.coroutine
          def print_events(device):
              while True:
                  events = yield from device.async_read()
                  for event in events:
                      print(device.path, evdev.categorize(event), sep=': ')

          mouse = evdev.InputDevice('/dev/input/eventX')
          keybd = evdev.InputDevice('/dev/input/eventY')

          for device in mouse, keybd:
              asyncio.async(print_events(device))

          loop = asyncio.get_event_loop()
          loop.run_forever()

       Since Python 3.5, the <u>async/await</u> syntax makes this even simpler:

          import asyncio, evdev

          mouse = evdev.InputDevice('/dev/input/event4')
          keybd = evdev.InputDevice('/dev/input/event5')

          async def print_events(device):
              async for event in device.async_read_loop():
                  print(device.path, evdev.categorize(event), sep=': ')

          for device in mouse, keybd:
              asyncio.ensure_future(print_events(device))

          loop = asyncio.get_event_loop()
          loop.run_forever()

   <b>Accessing</b> <b>evdev</b> <b>constants</b>
          &gt;&gt;&gt; from evdev import ecodes

          &gt;&gt;&gt; ecodes.KEY_A, ecodes.ecodes['KEY_A']
          ... (30, 30)
          &gt;&gt;&gt; ecodes.KEY[30]
          ... 'KEY_A'
          &gt;&gt;&gt; ecodes.bytype[ecodes.EV_KEY][30]
          ... 'KEY_A'
          &gt;&gt;&gt; ecodes.KEY[152]  # a single value may correspond to multiple codes
          ... ['KEY_COFFEE', 'KEY_SCREENLOCK']

   <b>Searching</b> <b>event</b> <b>codes</b> <b>by</b> <b>regex</b>
          &gt;&gt;&gt; from evdev import util

          &gt;&gt;&gt; res = util.find_ecodes_by_regex(r'(ABS|KEY)_BR(AKE|EAK)')
          &gt;&gt;&gt; res
          ... {1: [411], 3: [10]}
          &gt;&gt;&gt; util.resolve_ecodes_dict(res)
          ... {('EV_KEY', 1): [('KEY_BREAK', 411)], ('EV_ABS', 3): [('ABS_BRAKE', 10)]}

   <b>Getting</b> <b>exclusive</b> <b>access</b> <b>to</b> <b>a</b> <b>device</b>
          &gt;&gt;&gt; dev.grab()  # become the sole recipient of all incoming input events
          &gt;&gt;&gt; dev.ungrab()

       This functionality is also available as a context manager.

          &gt;&gt;&gt; with dev.grab_context():
          ...     pass

   <b>Associating</b> <b>classes</b> <b>with</b> <b>event</b> <b>types</b>
          &gt;&gt;&gt; from evdev import categorize, event_factory, ecodes

          &gt;&gt;&gt; class SynEvent:
          ...     def __init__(self, event):
          ...         ...

          &gt;&gt;&gt; event_factory[ecodes.EV_SYN] = SynEvent

       See <u>events</u> for more information.

   <b>Injecting</b> <b>input</b>
          &gt;&gt;&gt; from evdev import UInput, ecodes as e

          &gt;&gt;&gt; ui = UInput()

          &gt;&gt;&gt; # accepts only KEY_* events by default
          &gt;&gt;&gt; ui.write(e.EV_KEY, e.KEY_A, 1)  # KEY_A down
          &gt;&gt;&gt; ui.write(e.EV_KEY, e.KEY_A, 0)  # KEY_A up
          &gt;&gt;&gt; ui.syn()

          &gt;&gt;&gt; ui.close()

   <b>Injecting</b> <b>events</b> <b>(using</b> <b>a</b> <b>context</b> <b>manager)</b>
          &gt;&gt;&gt; ev = InputEvent(1334414993, 274296, ecodes.EV_KEY, ecodes.KEY_A, 1)
          &gt;&gt;&gt; with UInput() as ui:
          ...    ui.write_event(ev)
          ...    ui.syn()

   <b>Specifying</b> <b>uinput</b> <b>device</b> <b>options</b>
       <b>NOTE:</b>
          <b>ecodes.EV_SYN</b> cannot be in the <b>cap</b> dictionary or the device will not be created.

          &gt;&gt;&gt; from evdev import UInput, AbsInfo, ecodes as e

          &gt;&gt;&gt; cap = {
          ...     e.EV_KEY : [e.KEY_A, e.KEY_B],
          ...     e.EV_ABS : [
          ...         (e.ABS_X, AbsInfo(value=0, min=0, max=255,
          ...                           fuzz=0, flat=0, resolution=0)),
          ...         (e.ABS_Y, AbsInfo(0, 0, 255, 0, 0, 0)),
          ...         (e.ABS_MT_POSITION_X, (0, 128, 255, 0)) ]
          ... }

          &gt;&gt;&gt; ui = UInput(cap, name='example-device', version=0x3)
          &gt;&gt;&gt; print(ui)
          name "example-device", bus "BUS_USB", vendor "0001", product "0001", version "0003"
          event types: EV_KEY EV_ABS EV_SYN

          &gt;&gt;&gt; print(ui.capabilities())
          {0: [0, 1, 3],
           1: [30, 48],
           3: [(0,  AbsInfo(value=0, min=0, max=0,   fuzz=255, flat=0, resolution=0)),
               (1,  AbsInfo(value=0, min=0, max=0,   fuzz=255, flat=0, resolution=0)),
               (53, AbsInfo(value=0, min=0, max=255, fuzz=128, flat=0, resolution=0))]}

          &gt;&gt;&gt; # move mouse cursor
          &gt;&gt;&gt; ui.write(e.EV_ABS, e.ABS_X, 20)
          &gt;&gt;&gt; ui.write(e.EV_ABS, e.ABS_Y, 20)
          &gt;&gt;&gt; ui.syn()

   <b>Create</b> <b>uinput</b> <b>device</b> <b>with</b> <b>capabilities</b> <b>of</b> <b>another</b> <b>device</b>
          &gt;&gt;&gt; from evdev import UInput, InputDevice

          &gt;&gt;&gt; mouse = InputDevice('/dev/input/event1')
          &gt;&gt;&gt; keybd = '/dev/input/event2'

          &gt;&gt;&gt; ui = UInput.from_device(mouse, keybd, name='keyboard-mouse-device')
          &gt;&gt;&gt; ui.capabilities(verbose=True).keys()
          dict_keys([('EV_LED', 17), ('EV_KEY', 1), ('EV_SYN', 0), ('EV_REL', 2), ('EV_MSC', 4)])

   <b>Create</b> <b>uinput</b> <b>device</b> <b>capable</b> <b>of</b> <b>receiving</b> <b>FF-effects</b>
          import asyncio
          from evdev import UInput, categorize, ecodes

          cap = {
             ecodes.EV_FF:  [ecodes.FF_RUMBLE ],
             ecodes.EV_KEY: [ecodes.KEY_A, ecodes.KEY_B]
          }

          ui = UInput(cap, name='test-controller', version=0x3)

          async def print_events(device):
              async for event in device.async_read_loop():
                  print(categorize(event))

                  # Wait for an EV_UINPUT event that will signal us that an
                  # effect upload/erase operation is in progress.
                  if event.type != ecodes.EV_UINPUT:
                      continue

                  if event.code == ecodes.UI_FF_UPLOAD:
                      upload = device.begin_upload(event.value)
                      upload.retval = 0

                      print(f'[upload] effect_id: {upload.effect.id}, type: {upload.effect.type}')
                      device.end_upload(upload)

                  elif event.code == ecodes.UI_FF_ERASE:
                      erase = device.begin_erase(event.value)
                      print(f'[erase] effect_id {erase.effect_id}')

                      erase.retval = 0
                      device.end_erase(erase)

          asyncio.ensure_future(print_events(ui))
          loop = asyncio.get_event_loop()
          loop.run_forever()

   <b>Injecting</b> <b>an</b> <b>FF-event</b> <b>into</b> <b>first</b> <b>FF-capable</b> <b>device</b> <b>found</b>
          from evdev import ecodes, InputDevice, ff, list_devices
          import time

          # Find first EV_FF capable event device (that we have permissions to use).
          for name in list_devices():
              dev = InputDevice(name)
              if ecodes.EV_FF in dev.capabilities():
                  break

          rumble = ff.Rumble(strong_magnitude=0x0000, weak_magnitude=0xffff)
          effect_type = ff.EffectType(ff_rumble_effect=rumble)
          duration_ms = 1000

          effect = ff.Effect(
              ecodes.FF_RUMBLE, -1, 0,
              ff.Trigger(0, 0),
              ff.Replay(duration_ms, 0),
              effect_type
          )

          repeat_count = 1
          effect_id = dev.upload_effect(effect)
          dev.write(ecodes.EV_FF, effect_id, repeat_count)
          time.sleep(duration_ms / 1000)
          dev.erase_effect(effect_id)

   <b>Forwarding</b> <b>force-feedback</b> <b>from</b> <b>uinput</b> <b>to</b> <b>a</b> <b>real</b> <b>device</b>
          import evdev
          from evdev import ecodes as e

          # Find first EV_FF capable event device (that we have permissions to use).
          for name in evdev.list_devices():
              dev = evdev.InputDevice(name)
              if e.EV_FF in dev.capabilities():
                  break
          # To ensure forwarding works correctly it is important that `max_effects`
          # of the uinput device is &lt;= `dev.ff_effects_count`.
          # `from_device()` will do this automatically, but in some situations you may
          # want to set the `max_effects` parameter manually, such as when using `Uinput()`.
          # `filtered_types` is specified as by default EV_FF events are filtered
          uinput = evdev.UInput.from_device(dev, filtered_types=[e.EV_SYN])

          # Keeps track of which effects have been uploaded to the device
          effects = set()

          for event in uinput.read_loop():

              # Handle the special uinput events
              if event.type == e.EV_UINPUT:

                  if event.code == e.UI_FF_UPLOAD:
                      upload = uinput.begin_upload(event.value)

                      # Checks if this is a new effect
                      if upload.effect.id not in effects:
                          effects.add(upload.effect.id)
                          # Setting id to 1 indicates that a new effect must be allocated
                          upload.effect.id = -1

                      dev.upload_effect(upload.effect)
                      upload.retval = 0
                      uinput.end_upload(upload)

                  elif event.code == e.UI_FF_ERASE:
                      erase = uinput.begin_erase(event.value)
                      erase.retval = 0
                      dev.erase_effect(erase.effect_id)
                      effects.remove(erase.effect_id)
                      uinput.end_erase(erase)

              # Forward writes to actual rumble device.
              elif event.type == e.EV_FF:
                  dev.write(event.type, event.code, event.value)

</pre><h4><b>API</b> <b>REFERENCE</b></h4><pre>
   <b>events</b>
       This module provides the <u>InputEvent</u> class, which closely resembles  the  <b>input_event</b>  struct  defined  in
       <b>linux/input.h</b>:

          struct input_event {
              struct timeval time;
              __u16 type;
              __u16 code;
              __s32 value;
          };

       This  module  also  defines  several  <u>InputEvent</u>  sub-classes that know more about the different types of
       events (key, abs, rel etc). The <u>event_factory</u> dictionary maps event types to these classes.

       Assuming you use the <u>evdev.util.categorize()</u> function to  categorize  events  according  to  their  type,
       adding or replacing a class for a specific event type becomes a matter of modifying <u>event_factory</u>.

       All classes in this module have reasonable <b>str()</b> and <b>repr()</b> methods:

          &gt;&gt;&gt; print(event)
          event at 1337197425.477827, code 04, type 04, val 458792
          &gt;&gt;&gt; print(repr(event))
          InputEvent(1337197425L, 477827L, 4, 4, 458792L)

          &gt;&gt;&gt; print(key_event)
          key event at 1337197425.477835, 28 (KEY_ENTER), up
          &gt;&gt;&gt; print(repr(key_event))
          KeyEvent(InputEvent(1337197425L, 477835L, 1, 28, 0L))

       <b>class</b> <b>evdev.events.InputEvent(sec,</b> <b>usec,</b> <b>type,</b> <b>code,</b> <b>value)</b>
              A generic input event.

              <b>sec:</b> <b>int</b>
                     Time in seconds since epoch at which event occurred.

              <b>usec:</b> <b>int</b>
                     Microsecond portion of the timestamp.

              <b>type:</b> <b>int</b>
                     Event type - one of <b>ecodes.EV_*</b>.

              <b>code:</b> <b>int</b>
                     Event code related to the event type.

              <b>value:</b> <b>int</b>
                     Event value related to the event type.

              <b>timestamp()</b> <b>-&gt;</b> <b>float</b>
                     Return event timestamp as a float.

       <b>class</b> <b>evdev.events.KeyEvent(event:</b> <u>InputEvent</u><b>,</b> <b>allow_unknown:</b> <b>bool</b> <b>=</b> <b>False)</b>
              An event generated by a keyboard, button or other key-like devices.

              <b>key_up:</b> <b>Final[int]</b> <b>=</b> <b>0</b>

              <b>key_down:</b> <b>Final[int]</b> <b>=</b> <b>1</b>

              <b>key_hold:</b> <b>Final[int]</b> <b>=</b> <b>2</b>

              <b>scancode:</b> <b>int</b>

              <b>keystate</b>

              <b>keycode</b>

              <b>event:</b> <u>InputEvent</u>
                     Reference to an <u>InputEvent</u> instance.

       <b>class</b> <b>evdev.events.RelEvent(event:</b> <u>InputEvent</u><b>)</b>
              A relative axis event (e.g moving the mouse 5 units to the left).

              <b>event:</b> <u>InputEvent</u>
                     Reference to an <u>InputEvent</u> instance.

       <b>class</b> <b>evdev.events.SynEvent(event:</b> <u>InputEvent</u><b>)</b>
              A synchronization event. Used as markers to separate events. Events may be separated in time or in
              space, such as with the multitouch protocol.

              <b>event:</b> <u>InputEvent</u>
                     Reference to an <u>InputEvent</u> instance.

       <b>class</b> <b>evdev.events.AbsEvent(event:</b> <u>InputEvent</u><b>)</b>
              An absolute axis event (e.g the coordinates of a tap on a touchscreen).

              <b>event:</b> <u>InputEvent</u>
                     Reference to an <u>InputEvent</u> instance.

       <b>evdev.events.event_factory</b> <b>=</b> <b>{0:</b> <b>&lt;class</b> <b>'evdev.events.SynEvent'&gt;,</b> <b>1:</b> <b>&lt;class</b> <b>'evdev.events.KeyEvent'&gt;,</b> <b>2:</b>
       <b>&lt;class</b> <b>'evdev.events.RelEvent'&gt;,</b> <b>3:</b> <b>&lt;class</b> <b>'evdev.events.AbsEvent'&gt;}</b>
              A mapping of event types to <u>InputEvent</u> sub-classes. Used by <u>evdev.util.categorize()</u>

   <b>eventio</b>
       <b>class</b> <b>evdev.eventio.EventIO</b>
              Base class for reading and writing input events.

              This class is used by <b>InputDevice</b> and <b>UInput</b>.

              • On,  <b>InputDevice</b>  it used for reading user-generated events (e.g.  key presses, mouse movements)
                and writing feedback events (e.g. leds, beeps).

              • On, <b>UInput</b> it used for writing user-generated events (e.g.  key presses,  mouse  movements)  and
                reading feedback events (e.g. leds, beeps).

              <b>fileno()</b>
                     Return  the  file  descriptor  to  the  open  event  device. This makes it possible to pass
                     instances directly to <b>select.select()</b> and <b>asyncore.file_dispatcher</b>.

              <b>read_loop()</b> <b>-&gt;</b> <b>Iterator[</b><u>InputEvent</u><b>]</b>
                     Enter an endless <b>select.select()</b> loop that yields input events.

              <b>read_one()</b> <b>-&gt;</b> <u>InputEvent</u> <b>|</b> <b>None</b>
                     Read and return a single input event as an instance of <u>InputEvent</u>.

                     Return <b>None</b> if there are no pending input events.

              <b>read()</b> <b>-&gt;</b> <b>Iterator[</b><u>InputEvent</u><b>]</b>
                     Read multiple input events from device. Return a generator object  that  yields  <u>InputEvent</u>
                     instances. Raises <u>BlockingIOError</u> if there are no available events at the moment.

              <b>need_write()</b>
                     Decorator that raises <b>EvdevError</b> if there is no write access to the input device.

              <b>write_event(event)</b>
                     Inject  an  input event into the input subsystem. Events are queued until a synchronization
                     event is received.

                     <b>Parameters</b>
                            <b>event</b> (<u>InputEvent</u>) -- InputEvent instance or an object with an  <b>event</b>  attribute  (‐
                            <u>KeyEvent</u>, <u>RelEvent</u> etc).

                     Example

                     &gt;&gt;&gt; ev = InputEvent(1334414993, 274296, ecodes.EV_KEY, ecodes.KEY_A, 1)
                     &gt;&gt;&gt; ui.write_event(ev)

              <b>write(etype:</b> <b>int,</b> <b>code:</b> <b>int,</b> <b>value:</b> <b>int)</b>
                     Inject  an  input event into the input subsystem. Events are queued until a synchronization
                     event is received.

                     <b>Parameters</b>

                            • <b>etype</b> -- event type (e.g. <b>EV_KEY</b>).

                            • <b>code</b> -- event code (e.g. <b>KEY_A</b>).

                            • <b>value</b> -- event value (e.g. 0 1 2 - depends on event type).

                     Example

                     &gt;&gt;&gt; ui.write(e.EV_KEY, e.KEY_A, 1) # key A - down
                     &gt;&gt;&gt; ui.write(e.EV_KEY, e.KEY_A, 0) # key A - up

              <b>syn()</b>  Inject a <b>SYN_REPORT</b> event into the input subsystem. Events queued by <u>write()</u> will be fired.
                     If possible, events will be merged into an 'atomic' event.

              <b>close()</b>

              <b>__firstlineno__</b> <b>=</b> <b>16</b>

              <b>__static_attributes__</b> <b>=</b> <b>()</b>

              <b>__weakref__</b>
                     list of weak references to the object

   <b>eventio_async</b>
       <b>class</b> <b>evdev.eventio_async.EventIO</b>

              <b>async_read_one()</b>
                     Asyncio coroutine to read and return a single input event as an instance of <u>InputEvent</u>.

              <b>async_read()</b>
                     Asyncio coroutine to read multiple input events from device. Return a generator object that
                     yields <u>InputEvent</u> instances.

              <b>async_read_loop()</b> <b>-&gt;</b> <b>ReadIterator</b>
                     Return an iterator that yields input events. This iterator is compatible with the <b>async</b> <b>for</b>
                     syntax.

              <b>__annotations__</b> <b>=</b> <b>{}</b>

              <b>__firstlineno__</b> <b>=</b> <b>56</b>

              <b>__static_attributes__</b> <b>=</b> <b>()</b>

              <b>close()</b>

   <b>device</b>
       <b>class</b> <b>evdev.device.AbsInfo(value:</b> <b>int,</b> <b>min:</b> <b>int,</b> <b>max:</b> <b>int,</b> <b>fuzz:</b> <b>int,</b> <b>flat:</b> <b>int,</b> <b>resolution:</b> <b>int)</b>
              Absolute axis information.

              A <b>namedtuple</b> with absolute axis information - corresponds to the <b>input_absinfo</b> struct:

              <b>value</b>  Latest reported value for the axis.

                     <b>Type</b>   int

              <b>min</b>    Specifies minimum value for the axis.

                     <b>Type</b>   int

              <b>max</b>    Specifies maximum value for the axis.

                     <b>Type</b>   int

              <b>fuzz</b>   Specifies fuzz value that is used to filter noise from the event stream.

                     <b>Type</b>   int

              <b>flat</b>   Values that are within this value will be discarded by joydev interface and reported  as  0
                     instead.

                     <b>Type</b>   int

              <b>resolution</b>
                     Specifies  resolution  for  the  values  reported  for  the axis.  Resolution for main axes
                     (<b>ABS_X,</b> <b>ABS_Y,</b> <b>ABS_Z</b>) is reported  in  units  per  millimeter  (units/mm),  resolution  for
                     rotational axes (<b>ABS_RX,</b> <b>ABS_RY,</b> <b>ABS_RZ</b>) is reported in units per radian.

                     <b>Type</b>   int

              <b>NOTE:</b>
                 The  input  core  does not clamp reported values to the <b>[minimum,</b> <b>maximum]</b> limits, such task is
                 left to userspace.

              <b>value:</b> <b>int</b>
                     Alias for field number 0

              <b>min:</b> <b>int</b>
                     Alias for field number 1

              <b>max:</b> <b>int</b>
                     Alias for field number 2

              <b>fuzz:</b> <b>int</b>
                     Alias for field number 3

              <b>flat:</b> <b>int</b>
                     Alias for field number 4

              <b>resolution:</b> <b>int</b>
                     Alias for field number 5

              <b>__annotations__</b> <b>=</b> <b>{'flat':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'fuzz':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'max':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'min':</b>
              <b>&lt;class</b> <b>'int'&gt;,</b> <b>'resolution':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'value':</b> <b>&lt;class</b> <b>'int'&gt;}</b>

              <b>__firstlineno__</b> <b>=</b> <b>13</b>

              <b>__getnewargs__()</b>
                     Return self as a plain tuple.  Used by copy and pickle.

              <b>__match_args__</b> <b>=</b> <b>('value',</b> <b>'min',</b> <b>'max',</b> <b>'fuzz',</b> <b>'flat',</b> <b>'resolution')</b>

              <b>static</b> <b>__new__(_cls,</b> <b>value:</b> <b>int,</b> <b>min:</b> <b>int,</b> <b>max:</b> <b>int,</b> <b>fuzz:</b> <b>int,</b> <b>flat:</b> <b>int,</b> <b>resolution:</b> <b>int)</b>
                     Create new instance of AbsInfo(value, min, max, fuzz, flat, resolution)

              <b>__orig_bases__</b> <b>=</b> <b>(&lt;function</b> <b>NamedTuple&gt;,)</b>

              <b>__replace__(**kwds)</b>
                     Return a new AbsInfo object replacing specified fields with new values

              <b>__static_attributes__</b> <b>=</b> <b>()</b>

       <b>class</b> <b>evdev.device.KbdInfo(delay:</b> <b>int,</b> <b>repeat:</b> <b>int)</b>
              Keyboard repeat rate.

              <b>delay</b>  Amount of time  that  a  key  must  be  depressed  before  it  will  start  to  repeat  (in
                     milliseconds).

                     <b>Type</b>   int

              <b>repeat</b> Keyboard repeat rate in characters per second.

                     <b>Type</b>   int

              <b>delay:</b> <b>int</b>
                     Alias for field number 0

              <b>repeat:</b> <b>int</b>
                     Alias for field number 1

              <b>__annotations__</b> <b>=</b> <b>{'delay':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'repeat':</b> <b>&lt;class</b> <b>'int'&gt;}</b>

              <b>__firstlineno__</b> <b>=</b> <b>63</b>

              <b>__getnewargs__()</b>
                     Return self as a plain tuple.  Used by copy and pickle.

              <b>__match_args__</b> <b>=</b> <b>('delay',</b> <b>'repeat')</b>

              <b>static</b> <b>__new__(_cls,</b> <b>delay:</b> <b>int,</b> <b>repeat:</b> <b>int)</b>
                     Create new instance of KbdInfo(delay, repeat)

              <b>__orig_bases__</b> <b>=</b> <b>(&lt;function</b> <b>NamedTuple&gt;,)</b>

              <b>__replace__(**kwds)</b>
                     Return a new KbdInfo object replacing specified fields with new values

              <b>__static_attributes__</b> <b>=</b> <b>()</b>

       <b>class</b> <b>evdev.device.DeviceInfo(bustype:</b> <b>int,</b> <b>vendor:</b> <b>int,</b> <b>product:</b> <b>int,</b> <b>version:</b> <b>int)</b>

              <b>bustype</b>

                     <b>Type</b>   int

              <b>vendor</b>

                     <b>Type</b>   int

              <b>product</b>

                     <b>Type</b>   int

              <b>version</b>

                     <b>Type</b>   int

              <b>bustype:</b> <b>int</b>
                     Alias for field number 0

              <b>vendor:</b> <b>int</b>
                     Alias for field number 1

              <b>product:</b> <b>int</b>
                     Alias for field number 2

              <b>version:</b> <b>int</b>
                     Alias for field number 3

              <b>__annotations__</b> <b>=</b> <b>{'bustype':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'product':</b> <b>&lt;class</b> <b>'int'&gt;,</b> <b>'vendor':</b> <b>&lt;class</b> <b>'int'&gt;,</b>
              <b>'version':</b> <b>&lt;class</b> <b>'int'&gt;}</b>

              <b>__firstlineno__</b> <b>=</b> <b>83</b>

              <b>__getnewargs__()</b>
                     Return self as a plain tuple.  Used by copy and pickle.

              <b>__match_args__</b> <b>=</b> <b>('bustype',</b> <b>'vendor',</b> <b>'product',</b> <b>'version')</b>

              <b>static</b> <b>__new__(_cls,</b> <b>bustype:</b> <b>int,</b> <b>vendor:</b> <b>int,</b> <b>product:</b> <b>int,</b> <b>version:</b> <b>int)</b>
                     Create new instance of DeviceInfo(bustype, vendor, product, version)

              <b>__orig_bases__</b> <b>=</b> <b>(&lt;function</b> <b>NamedTuple&gt;,)</b>

              <b>__replace__(**kwds)</b>
                     Return a new DeviceInfo object replacing specified fields with new values

              <b>__static_attributes__</b> <b>=</b> <b>()</b>

       <b>class</b> <b>evdev.device.InputDevice(dev:</b> <b>str</b> <b>|</b> <b>bytes</b> <b>|</b> <b>PathLike)</b>
              A linux input device from which input events can be read.

              <b>__init__(dev:</b> <b>str</b> <b>|</b> <b>bytes</b> <b>|</b> <b>PathLike)</b>

                     <b>Parameters</b>
                            <b>dev</b> (<u>str|bytes|PathLike</u>) -- Path to input device

              <b>path</b>   Path to input device.

              <b>fd:</b> <b>int</b>
                     A non-blocking file descriptor to the device file.

              <b>info</b>   A <u>DeviceInfo</u> instance.

              <b>name:</b> <b>str</b>
                     The name of the event device.

              <b>phys:</b> <b>str</b>
                     The physical topology of the device.

              <b>uniq:</b> <b>str</b>
                     The unique identifier of the device.

              <b>version:</b> <b>int</b>
                     The evdev protocol version.

              <b>ff_effects_count</b>
                     The number of force feedback effects the device can keep in its memory.

              <b>capabilities(verbose:</b> <b>Literal[False]</b> <b>=</b> <b>False,</b> <b>absinfo:</b> <b>bool</b> <b>=</b> <b>True)</b> <b>-&gt;</b> <b>Dict[int,</b> <b>List[int]]</b>

              <b>capabilities(verbose:</b> <b>Literal[True],</b> <b>absinfo:</b> <b>bool</b> <b>=</b> <b>True)</b> <b>-&gt;</b> <b>Dict[Tuple[str,</b> <b>int],</b>
              <b>List[Tuple[str,</b> <b>int]]]</b>
                     Return  the  event types that this device supports as a mapping of supported event types to
                     lists of handled event codes.

                     Example

                     &gt;&gt;&gt; device.capabilities()
                     { 1: [272, 273, 274],
                       2: [0, 1, 6, 8] }

                     If <b>verbose</b> is <b>True</b>, event codes and types will be resolved to their names.

                        { ('EV_KEY', 1): [('BTN_MOUSE', 272),
                                          ('BTN_RIGHT', 273),
                                          ('BTN_MIDDLE', 273)],
                          ('EV_REL', 2): [('REL_X', 0),
                                          ('REL_Y', 1),
                                          ('REL_HWHEEL', 6),
                                          ('REL_WHEEL', 8)] }

                     Unknown codes or types will be resolved to <b>'?'</b>.

                     If <b>absinfo</b> is <b>True</b>, the list of capabilities will also include absolute axis information in
                     the form of <u>AbsInfo</u> instances:

                        { 3: [ (0, AbsInfo(min=0, max=255, fuzz=0, flat=0)),
                               (1, AbsInfo(min=0, max=255, fuzz=0, flat=0)) ]}

                     Combined with <b>verbose</b> the above becomes:

                        { ('EV_ABS', 3): [ (('ABS_X', 0), AbsInfo(min=0, max=255, fuzz=0, flat=0)),
                                           (('ABS_Y', 1), AbsInfo(min=0, max=255, fuzz=0, flat=0)) ]}

              <b>input_props(verbose:</b> <b>bool</b> <b>=</b> <b>False)</b>
                     Get device properties and quirks.

                     Example

                     &gt;&gt;&gt; device.input_props()
                     [0, 5]

                     If <b>verbose</b> is <b>True</b>, input properties  are  resolved  to  their  names.  Unknown  codes  are
                     resolved to <b>'?'</b>:

                        [('INPUT_PROP_POINTER', 0), ('INPUT_PROP_POINTING_STICK', 5)]

              <b>leds(verbose:</b> <b>bool</b> <b>=</b> <b>False)</b>
                     Return currently set LED keys.

                     Example

                     &gt;&gt;&gt; device.leds()
                     [0, 1, 8, 9]

                     If  <b>verbose</b> is <b>True</b>, event codes are resolved to their names. Unknown codes are resolved to
                     <b>'?'</b>:

                        [('LED_NUML', 0), ('LED_CAPSL', 1), ('LED_MISC', 8), ('LED_MAIL', 9)]

              <b>set_led(led_num:</b> <b>int,</b> <b>value:</b> <b>int)</b> <b>-&gt;</b> <b>None</b>
                     Set the state of the selected LED.

                     Example

                     &gt;&gt;&gt; device.set_led(ecodes.LED_NUML, 1)

              <b>__eq__(other)</b>
                     Two devices are equal if their <u>info</u> attributes are equal.

              <b>__fspath__()</b>

              <b>close()</b> <b>-&gt;</b> <b>None</b>

              <b>grab()</b> <b>-&gt;</b> <b>None</b>
                     Grab input device using <b>EVIOCGRAB</b> - other applications will be  unable  to  receive  events
                     until the device is released. Only one process can hold a <b>EVIOCGRAB</b> on a device.

                     <b>WARNING:</b>
                        Grabbing an already grabbed device will raise an <b>OSError</b>.

              <b>ungrab()</b> <b>-&gt;</b> <b>None</b>
                     Release device if it has been already grabbed (uses <u>EVIOCGRAB</u>).

                     <b>WARNING:</b>
                        Releasing an already released device will raise an <b>OSError('Invalid</b> <b>argument')</b>.

              <b>grab_context()</b> <b>-&gt;</b> <b>Iterator[None]</b>
                     A  context  manager  for  the  duration  of  which only the current process will be able to
                     receive events from the device.

              <b>upload_effect(effect:</b> <b>ff.Effect)</b>
                     Upload a force feedback effect to a force feedback device.

              <b>erase_effect(ff_id)</b> <b>-&gt;</b> <b>None</b>
                     Erase a force effect from a force feedback device. This also stops the effect.

              <b>property</b> <b>repeat</b>
                     Get or set the keyboard repeat rate (in characters per minute) and delay (in milliseconds).

              <b>__annotations__</b> <b>=</b> <b>{'fd':</b> <b>'int',</b> <b>'name':</b> <b>'str',</b> <b>'phys':</b> <b>'str',</b> <b>'uniq':</b> <b>'str',</b> <b>'version':</b> <b>'int'}</b>

              <b>__firstlineno__</b> <b>=</b> <b>103</b>

              <b>__hash__</b> <b>=</b> <b>None</b>

              <b>__static_attributes__</b> <b>=</b> <b>('_rawcapabilities',</b> <b>'fd',</b> <b>'ff_effects_count',</b> <b>'info',</b> <b>'name',</b> <b>'path',</b>
              <b>'phys',</b> <b>'uniq',</b> <b>'version')</b>

              <b>active_keys(verbose:</b> <b>bool</b> <b>=</b> <b>False)</b>
                     Return currently active keys.

                     Example

                     &gt;&gt;&gt; device.active_keys()
                     [1, 42]

                     If <b>verbose</b> is <b>True</b>, key codes are resolved  to  their  verbose  names.  Unknown  codes  are
                     resolved to <b>'?'</b>. For example:

                        [('KEY_ESC', 1), ('KEY_LEFTSHIFT', 42)]

              <b>absinfo(axis_num:</b> <b>int)</b>
                     Return current <u>AbsInfo</u> for input device axis

                     <b>Parameters</b>
                            <b>axis_num</b> (<u>int</u>) -- EV_ABS keycode (example <b>ecodes.ABS_X</b>)

                     Example

                     &gt;&gt;&gt; device.absinfo(ecodes.ABS_X)
                     AbsInfo(value=1501, min=-32768, max=32767, fuzz=0, flat=128, resolution=0)

              <b>set_absinfo(axis_num:</b> <b>int,</b> <b>value=None,</b> <b>min=None,</b> <b>max=None,</b> <b>fuzz=None,</b> <b>flat=None,</b> <b>resolution=None)</b>
              <b>-&gt;</b> <b>None</b>
                     Update <u>AbsInfo</u> values. Only specified values will be overwritten.

                     <b>Parameters</b>
                            <b>axis_num</b> (<u>int</u>) -- EV_ABS keycode (example <b>ecodes.ABS_X</b>)

                     Example

                     &gt;&gt;&gt; device.set_absinfo(ecodes.ABS_X, min=-2000, max=2000)

                     You can also unpack AbsInfo tuple that will overwrite all values

                     &gt;&gt;&gt; device.set_absinfo(ecodes.ABS_Y, *AbsInfo(0, -2000, 2000, 0, 15, 0))

   <b>uinput</b>
       <b>class</b> <b>evdev.uinput.UInput(events:</b> <b>Dict[int,</b> <b>Sequence[int]]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>name:</b> <b>str</b> <b>=</b> <b>'py-evdev-uinput',</b>
       <b>vendor:</b> <b>int</b> <b>=</b> <b>1,</b> <b>product:</b> <b>int</b> <b>=</b> <b>1,</b> <b>version:</b> <b>int</b> <b>=</b> <b>1,</b> <b>bustype:</b> <b>int</b> <b>=</b> <b>3,</b> <b>devnode:</b> <b>str</b> <b>=</b> <b>'/dev/uinput',</b>
       <b>phys:</b> <b>str</b> <b>=</b> <b>'py-evdev-uinput',</b> <b>input_props=None,</b> <b>max_effects=96)</b>
              A userland input device and that can inject input events into the linux input subsystem.

              <b>classmethod</b> <b>from_device(*devices:</b> <u>InputDevice</u> <b>|</b> <b>str</b> <b>|</b> <b>bytes</b> <b>|</b> <b>PathLike,</b> <b>filtered_types:</b> <b>Tuple[int]</b>
              <b>=</b> <b>(0,</b> <b>21),</b> <b>**kwargs)</b>
                     Create an UInput device with the capabilities of one or more input devices.

                     <b>Parameters</b>

                            • <b>devices</b>  (<u>InputDevice|str</u>)  --  Varargs of InputDevice instances or paths to input
                              devices.

                            • <b>filtered_types</b> (<u>Tuple[event</u> <u>type</u> <u>codes]</u>)  --  Event  types  to  exclude  from  the
                              capabilities of the uinput device.

                            • <b>**kwargs</b> -- Keyword arguments to UInput constructor (i.e. name, vendor etc.).

              <b>__init__(events:</b> <b>Dict[int,</b> <b>Sequence[int]]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>name:</b> <b>str</b> <b>=</b> <b>'py-evdev-uinput',</b> <b>vendor:</b>
              <b>int</b> <b>=</b> <b>1,</b> <b>product:</b> <b>int</b> <b>=</b> <b>1,</b> <b>version:</b> <b>int</b> <b>=</b> <b>1,</b> <b>bustype:</b> <b>int</b> <b>=</b> <b>3,</b> <b>devnode:</b> <b>str</b> <b>=</b> <b>'/dev/uinput',</b> <b>phys:</b>
              <b>str</b> <b>=</b> <b>'py-evdev-uinput',</b> <b>input_props=None,</b> <b>max_effects=96)</b>

                     <b>Parameters</b>

                            • <b>events</b>  (<u>dict</u>)  --  Dictionary of event types mapping to lists of event codes. The
                              event types and codes that the uinput device will be able to inject - defaults  to
                              all key codes.

                            • <b>name</b> -- The name of the input device.

                            • <b>vendor</b> -- Vendor identifier.

                            • <b>product</b> -- Product identifier.

                            • <b>version</b> -- Version identifier.

                            • <b>bustype</b> -- Bustype identifier.

                            • <b>phys</b> -- Physical path.

                            • <b>input_props</b> -- Input properties and quirks.

                            • <b>max_effects</b> -- Maximum simultaneous force-feedback effects.

                     <b>NOTE:</b>
                        If  you  do  not specify any events, the uinput device will be able to inject only <b>KEY_*</b>
                        and <b>BTN_*</b> event codes.

              <b>name:</b> <b>str</b>
                     Uinput device name.

              <b>vendor:</b> <b>int</b>
                     Device vendor identifier.

              <b>product:</b> <b>int</b>
                     Device product identifier.

              <b>version:</b> <b>int</b>
                     Device version identifier.

              <b>bustype:</b> <b>int</b>
                     Device bustype - e.g. <b>BUS_USB</b>.

              <b>phys:</b> <b>str</b>
                     Uinput device physical path.

              <b>devnode:</b> <b>str</b>
                     Uinput device node - e.g. <b>/dev/uinput/</b>.

              <b>fd</b>     Write-only, non-blocking file descriptor to the uinput device node.

              <b>device:</b> <u>InputDevice</u>
                     An <u>InputDevice</u> instance for the fake input device. <b>None</b> if the device cannot be opened  for
                     reading and writing.

              <b>capabilities(verbose:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>absinfo:</b> <b>bool</b> <b>=</b> <b>True)</b>
                     See <u>capabilities</u>.

   <b>util</b>
       <b>evdev.util.list_devices(input_device_dir:</b> <b>str</b> <b>|</b> <b>bytes</b> <b>|</b> <b>PathLike</b> <b>=</b> <b>'<a href="file:/dev/input">/dev/input</a>')</b> <b>-&gt;</b> <b>List[str]</b>
              List readable character devices in <b>input_device_dir</b>.

       <b>evdev.util.is_device(fn:</b> <b>str</b> <b>|</b> <b>bytes</b> <b>|</b> <b>PathLike)</b> <b>-&gt;</b> <b>bool</b>
              Check if <b>fn</b> is a readable and writable character device.

       <b>evdev.util.categorize(event:</b> <u>InputEvent</u><b>)</b> <b>-&gt;</b> <u>InputEvent</u>
              Categorize an event according to its type.

              The <u>event_factory</u> dictionary maps event types to sub-classes of <u>InputEvent</u>. If the event cannot be
              categorized, it is returned unmodified.

       <b>evdev.util.resolve_ecodes(ecode_dict,</b> <b>ecode_list,</b> <b>unknown='?')</b>
              Resolve event codes and types to their verbose names.

              Example

              &gt;&gt;&gt; resolve_ecodes(ecodes.BTN, [272, 273, 274])
              [(['BTN_LEFT', 'BTN_MOUSE'], 272), ('BTN_RIGHT', 273), ('BTN_MIDDLE', 274)]

       <b>evdev.util.resolve_ecodes_dict(typecodemap,</b> <b>unknown='?')</b>
              Resolve event codes and types to their verbose names.

              <b>Parameters</b>

                     • <b>typecodemap</b> -- mapping of event types to lists of event codes.

                     • <b>unknown</b> -- symbol to which unknown types or codes will be resolved.

              Example

              &gt;&gt;&gt; resolve_ecodes_dict({ 1: [272, 273, 274] })
              { ('EV_KEY', 1): [('BTN_MOUSE',  272),
                                ('BTN_RIGHT',  273),
                                ('BTN_MIDDLE', 274)] }

              If <b>typecodemap</b> contains absolute axis info (instances of <u>AbsInfo</u> ) the result would look like:

              &gt;&gt;&gt; resolve_ecodes_dict({ 3: [(0, AbsInfo(...))] })
              { ('EV_ABS', 3L): [(('ABS_X', 0L), AbsInfo(...))] }

   <b>ecodes</b>
       This modules exposes the integer constants defined in <b>linux/input.h</b> and <b>linux/input-event-codes.h</b>.

       Exposed constants:

          KEY, ABS, REL, SW, MSC, LED, BTN, REP, SND, ID, EV,
          BUS, SYN, FF, FF_STATUS, INPUT_PROP

       This  module  also  provides  reverse and forward mappings of the names and values of the above mentioned
       constants:

          &gt;&gt;&gt; evdev.ecodes.KEY_A
          30

          &gt;&gt;&gt; evdev.ecodes.ecodes['KEY_A']
          30

          &gt;&gt;&gt; evdev.ecodes.KEY[30]
          'KEY_A'

          &gt;&gt;&gt; evdev.ecodes.REL[0]
          'REL_X'

          &gt;&gt;&gt; evdev.ecodes.EV[evdev.ecodes.EV_KEY]
          'EV_KEY'

          &gt;&gt;&gt; evdev.ecodes.bytype[evdev.ecodes.EV_REL][0]
          'REL_X'

       Keep in mind that values in reverse mappings may point to one or more event codes. For example:

          &gt;&gt;&gt; evdev.ecodes.FF[80]
          ('FF_EFFECT_MIN', 'FF_RUMBLE')

          &gt;&gt;&gt; evdev.ecodes.FF[81]
          'FF_PERIODIC'

       <b>evdev.ecodes.keys</b> <b>{0:</b> <b>'KEY_RESERVED',</b> <b>1:</b> <b>'KEY_ESC',</b> <b>2:</b> <b>'KEY_1',</b> <b>...}</b>
              Keys are a combination of all BTN and KEY codes.

       <b>evdev.ecodes.ecodes</b> <b>{'KEY_END':</b> <b>107,</b> <b>'FF_RUMBLE':</b> <b>80,</b> <b>'KEY_KPDOT':</b> <b>83,</b> <b>'KEY_CNT':</b> <b>768,</b> <b>...}'</b>
              Mapping of names to values.

       <b>evdev.ecodes.bytype</b> <b>{0:</b> <b>{0:</b> <b>'SYN_REPORT',</b> <b>1:</b> <b>'SYN_CONFIG',</b> <b>2:</b> <b>'SYN_MT_REPORT',</b> <b>3:</b> <b>'SYN_DROPPED'},</b> <b>...}</b>
              Mapping of event types to other value/name mappings.

</pre><h4><b>SCOPE</b> <b>AND</b> <b>STATUS</b></h4><pre>
       Python-evdev exposes most of the more common interfaces defined  in  the  evdev  subsystem.  Reading  and
       injecting events is well supported and has been tested with nearly all event types.

       The  basic  functionality  for  reading and uploading force-feedback events is there, but it has not been
       exercised sufficiently. A  major  shortcoming  of  the  uinput  wrapper  is  that  it  does  not  support
       force-feedback devices at all (see issue <u>#23</u>).

       Some  characters,  such  as  <b>:</b>  (colon),  cannot be easily injected (see issue <u>#7</u>), Translating them into
       UInput events would require knowing the kernel keyboard translation table, which is beyond the  scope  of
       python-evdev.  Please  look  into  the  following  projects if you need more complete or convenient input
       injection support.

       • <u>python-uinput</u>

       • <u>uinput-mapper</u>

       • <u>pynput</u>

       • <u>pygame</u> (cross-platform)

</pre><h4><b>CHANGELOG</b></h4><pre>
   <b>1.9.0</b> <b>(Feb</b> <b>08,</b> <b>2025)</b>
       • Fix for <b>CPATH/C_INCLUDE_PATH</b> being ignored during build.

       • Slightly faster reading of events in <b>device.read()</b> and <b>device.read_one()</b>.

       • Fix FreeBSD support.

       • Drop deprecated <b>InputDevice.fn</b> (use <b>InputDevice.path</b> instead).

       • Improve type hint coverage and add a <b>py.typed</b> file to the sdist.

   <b>1.8.0</b> <b>(Jan</b> <b>25,</b> <b>2025)</b>
       • Binary wheels are now provided by the <u>evdev-binary</u> package.  The package is compiled on  manylinux_2_28
         against kernel 4.18.

       • The  <b>evdev.ecodes</b> module is now generated at install time and contains only constants. This allows type
         checking and introspection of the <b>evdev.ecodes</b> module, without having to  execute  it  first.  The  old
         module  is  available  as  <b>evdev.ecodes_runtime</b>.  In case generation of the static <b>ecodes.py</b> fails, the
         install process falls back to using <b>ecodes_runtime.py</b> as <b>ecodes.py</b>.

       • Reverse mappings in <b>evdev.ecodes</b> that point to more than one value are now tuples instead of lists. For
         example:

            &gt;&gt;&gt; ecodes.KEY[153]
            ('KEY_DIRECTION', 'KEY_ROTATE_DISPLAY')

       • Raise the minimum supported Python version to 3.8.

       • Fix keyboard delay and repeat being swapped (#227).

       • Move the <b>syn()</b> convenience method from <b>InputDevice</b> to <b>EventIO</b> (#224).

   <b>1.7.1</b> <b>(May</b> <b>8,</b> <b>2024)</b>
       • Provide fallback value for <b>FF_MAX_EFFECTS</b>, which fixes the build on EL 7 (#219).

       • Add <b>#ifdef</b> guards around <b>UI_GET_SYSNAME</b> to improve kernel compatibility (#218) .

       • Wait up to two seconds for uinput devices to appear. (#215)

   <b>1.7.0</b> <b>(Feb</b> <b>18,</b> <b>2024)</b>
       • Respect the <b>CPATH/C_INCLUDE_PATH</b> environment variables during install.

       • Add the uniq address to the string representation of <b>InputDevice</b>.

       • Improved method for finding the device node corresponding to a uinput device (<u>#206</u>).

       • Repository  TLC  (reformatted  with  ruff,  fixed  linting  warnings,  moved  packaging   metadata   to
         <b>pyproject.toml</b> etc.).

   <b>1.6.1</b> <b>(Jan</b> <b>20,</b> <b>2023)</b>
       • Fix generation of <b>ecodes.c</b> when the path to <b>sys.executable</b> contains spaces.

   <b>1.6.0</b> <b>(Jul</b> <b>17,</b> <b>2022)</b>
       • Fix Python 3.11 compatibility (<u>#174</u>).

   <b>1.5.0</b> <b>(Mar</b> <b>24,</b> <b>2022)</b>
       • Fix documentation (<u>#163</u>, <u>#160</u>).

       • Re-enable TTY echo at evtest exit (<u>#155</u>).

       • Fix <b>ImportError:</b> <b>sys.meta_path</b> <b>is</b> <b>None,</b> <b>Python</b> <b>is</b> <b>likely</b> <b>shutting</b> <b>down</b> (<u>#154</u>).

       • Closing the input device file descriptor in <b>InputDevice.close()</b> now happens in the main thread, instead
         of in a new thread (reverts <u>#146</u>).

       • Fix <b>util.find_ecodes_by_regex</b> not working across all supported Python versions (<u>#152</u>).

   <b>1.4.0</b> <b>(Jan</b> <b>16,</b> <b>2021)</b>
       • Fix <b>InputDevice.set_absinfo</b> to allow setting parameters to zero.

       • Fix  off-by-one in <b>ioctl_EVIOCG_bits</b>, which causes value at the end of the list to not be reported back
         (<u>#131</u>).

       • Fix <b>set_absinfo</b> to allow setting parameters to zero (<u>#128</u>).

       • Fix leak when returning <b>BlockingIOError</b> from a read (<u>#143</u>).

       • Fix "There is no current event loop in thread" error for non asyncio code (<u>#146</u>).

       • Prevent <b>InputDevice</b> destructor from blocking (<u>#145</u>).

       • Add missing return codes to <b>os.strerror()</b> calls and fix force feedback example in docs (<u>#138</u>).

       • Add the <b>util.find_ecodes_by_regex()</b> helper function.

   <b>1.3.0</b> <b>(Jan</b> <b>12,</b> <b>2020)</b>
       • Fix build on 32bit arches with 64bit time_t

       • Add functionality to query device properties. See <b>InputDevice.input_props</b> and the <b>input_props</b>  argument
         to <b>Uinput</b>.

       • <b>KeyEvent</b>  received  an  <b>allow_unknown</b>  constructor  argument, which determines what will happen when an
         event code cannot be mapped to a keycode.  The default and behavior so far has been to raise  <b>KeyError</b>.
         If set to <b>True</b>, the keycode will be set to the event code formatted as a hex number.

       • Add <b>InputDevice.set_absinfo()</b> and <b>InputDevice.absinfo()</b>.

       • Instruct  the  asyncio  event  loop  to  stop  monitoring the fd of the input device when the device is
         closed.

   <b>1.2.0</b> <b>(Apr</b> <b>7,</b> <b>2019)</b>
       • Add UInput support for the resolution parameter in AbsInfo. This brings support for the new  method  of
         uinput device setup, which was <u>introduced</u> <u>in</u> <u>Linux</u> <u>4.5</u> (thanks to <u>@LinusCDE</u>).

       • Vendor and product identifiers can be greater or equal to <u>0x8000</u> (thanks <u>@ivaradi</u>).

   <b>1.1.2</b> <b>(Sep</b> <b>1,</b> <b>2018)</b>
       • Fix installation on kernels &lt;= 4.4.

       • Fix uinput creation ignoring absinfo settings.

   <b>1.1.0</b> <b>(Aug</b> <b>27,</b> <b>2018)</b>
       • Add support for handling force-feedback effect uploads (many thanks to <u>@ndreys</u>).

       • Fix typo preventing ff effects that need left coefficients from working.

   <b>1.0.0</b> <b>(Jun</b> <b>02,</b> <b>2018)</b>
       • Prevent <b>Uinput</b> device creation raising <b>Objects/longobject.c:415:</b> <b>bad</b> <b>argument</b> <b>to</b> <b>internal</b> <b>function</b> when
         a non-complete <b>AbsInfo</b> structure is passed. All missing <b>AbsInfo</b> fields are set to 0.

       • Fix <b>Uinput</b> device creation raising <b>KeyError</b> when a capability filtered by default is not present.

       • The <b>InputDevice.fn</b> attribute was deprecated in favor of <b>InputDevice.path</b>.  Using the former will show a
         <b>DeprecationWarning</b>, but would otherwise continue working as before.

       • Fix <b>InputDevice</b> comparison raising <b>AttributeError</b> due to a non-existant <b>path</b> attribute.

       • Fix asyncio support in Python 3.5+.

       • Uploading FF effect now works both on Python 2.7 and Python 3+.

       • Remove the <b>asyncore</b> example from the tutorial.

   <b>0.8.1</b> <b>(Mar</b> <b>24,</b> <b>2018)</b>
       • Fix Python 2 compatibility issue in with <b>Uinput.from_device</b>.

       • Fix minor <u>evdev.evtest</u> formatting issue.

   <b>0.8.0</b> <b>(Mar</b> <b>22,</b> <b>2018)</b>
       • Fix <b>InputDevice</b> comparison on Python 2.

       • The device path is now considered when comparing two devices.

       • Fix <b>UInput.from_device</b> not correctly merging the capabilities of selected devices.

       • The list of excluded event types in <b>UInput.from_device</b> is now configurable. For example:

            UInput.from_device(dev, filtered_types=(EV_SYN, EV_FF))

         In addition, <b>ecodes.EV_FF</b> is now excluded by default.

       • Add a context manager for grabbing access to a device - <b>InputDevice.grab_context</b>. For example:

            with dev.grab_context():
                pass

       • Add  the  <b>InputDevice.uniq</b> attribute, which contains the unique identifier of the device. As with <b>phys</b>,
         this attribute may be empty (i.e. <u>''</u>).

   <b>0.7.0</b> <b>(Jun</b> <b>16,</b> <b>2017)</b>
       • <b>InputDevice</b> now accepts objects that support the path protocol.  For example:

            pth = pathlib.Path('/dev/input/event0')
            dev = evdev.InputDevice(pth)

       • Support path protocol in <b>InputDevice</b>. This means that <b>InputDevice</b> instances can be  passed  to  callers
         that expect a <b>os.PathLike</b> object.

       • Exceptions  raised  during  <b>InputDevice.async_read()</b>  (and  similar)  are now handled properly (i.e. an
         exception is set on the returned future instead of leaking that exception into the event loop) (Fixes ‐
         <u>#67</u>).

   <b>0.6.4</b> <b>(Oct</b> <b>07,</b> <b>2016)</b>
       • Exclude <b>ecodes.c</b> from source distribution (Fixes <u>#63</u>).

   <b>0.6.3</b> <b>(Oct</b> <b>06,</b> <b>2016)</b>
       • Add the <b>UInput.from_device</b> class method, which allows uinput device to be created with the capabiltiies
         of one or more existing input devices:

            ui = UInput.from_device('/dev/input1', '/dev/input2', **constructor_kwargs)

       • Add the <b>build_ecodes</b> distutils command, which generates the <b>ecodes.c</b> extension module. The new  way  of
         overwriting the evdev header locations is:

            python setup.py build \
              build_ecodes --evdev-headers path/input.h:path/input-event-codes.h \
              build_ext --include-dirs  path/ \
              install

         The  <b>build*</b>  and  <b>install</b>  commands  no  longer  have to be part of the same command-line (i.e. running
         <b>install</b> will reuse the outputs of the last <b>build</b>).

   <b>0.6.1</b> <b>(Jun</b> <b>04,</b> <b>2016)</b>
       • Disable tty echoing while evtest is running.

       • Allow evtest to listen to more than one devices.

       • The setup.py script now allows the location of the input header files to be overwritten. For example:

            python setup.py build_ext \
              --evdev-headers path/input.h:path/input-event-codes.h \
              --include-dirs  path/ \
              install

   <b>0.6.0</b> <b>(Feb</b> <b>14,</b> <b>2016)</b>
       • Asyncio and async/await support (many thanks to <u>@paulo-raca</u>).

       • Add the ability to set the <u>phys</u> property of uinput devices (thanks <u>@paulo-raca</u>).

       • Add a generic <b>InputDevice.set()</b> method (thanks <u>@paulo-raca</u>).

       • Distribute the evtest script along with evdev.

       • Fix issue with generating <b>ecodes.c</b> in recent kernels (<b>&gt;=</b> <b>4.4.0</b>).

       • Fix absinfo item indexes in <b>UInput.uinput_create()</b> (thanks <u>@forsenonlhaimaisentito</u>).

       • More robust comparison of <b>InputDevice</b> objects (thanks <u>@isia</u>).

   <b>0.5.0</b> <b>(Jun</b> <b>16,</b> <b>2015)</b>
       • Write access to the input device is no longer mandatory. Evdev will first try to open  the  device  for
         reading  and writing and fallback to read-only. Methods that require write access (e.g. <b>set_led()</b>) will
         raise <b>EvdevError</b> if the device is open only for reading.

   <b>0.4.7</b> <b>(Oct</b> <b>07,</b> <b>2014)</b>
       • Fallback to distutils if setuptools is not available.

   <b>0.4.6</b> <b>(Oct</b> <b>07,</b> <b>2014)</b>
       • Rework documentation and docstrings once more.

       • Fix install on Python 3.4 (works around <u>issue21121</u>).

       • Fix <b>ioctl()</b> requested buffer size (thanks Jakub Wojciech Klama).

   <b>0.4.5</b> <b>(Jul</b> <b>06,</b> <b>2014)</b>
       • Add method for returning a list of the currently active  keys  -  <b>InputDevice.active_keys()</b>  (thanks  ‐
         <u>@spasche</u>).

       • Fix a potential buffer overflow in <b>ioctl_capabilities()</b> (thanks <u>@spasche</u>).

   <b>0.4.4</b> <b>(Jun</b> <b>04,</b> <b>2014)</b>
       • Calling  <b>InputDevice.read_one()</b>  should  always  return <b>None</b>, when there is nothing to be read, even in
         case of a <b>EAGAIN</b> errno (thanks JPP).

   <b>0.4.3</b> <b>(Dec</b> <b>19,</b> <b>2013)</b>
       • Silence <b>OSError</b> in destructor (thanks <u>@polyphemus</u>).

       • Make <b>InputDevice.close()</b> work in cases in which stdin (fd 0) has been closed (thanks <u>@polyphemus</u>).

   <b>0.4.2</b> <b>(Dec</b> <b>13,</b> <b>2013)</b>
       • Rework documentation and docstrings.

       • Call <b>InputDevice.close()</b> from <b>InputDevice.__del__()</b>.

   <b>0.4.1</b> <b>(Jul</b> <b>24,</b> <b>2013)</b>
       • Fix   reference   counting    in    <b>InputDevice.device_read()</b>,    <b>InputDevice.device_read_many()</b>    and
         <b>ioctl_capabilities()</b>.

   <b>0.4.0</b> <b>(Jul</b> <b>01,</b> <b>2013)</b>
       • Add <b>FF_*</b> and <b>FF_STATUS</b> codes to <b>ecodes()</b> (thanks <u>@bgilbert</u>).

       • Reverse  event  code  mappings  (<b>ecodes.{KEY,FF,REL,ABS}</b>  and  etc.)   will now map to a list of codes,
         whenever a value corresponds to multiple codes:

            &gt;&gt;&gt; ecodes.KEY[152]
            ... ['KEY_COFFEE', 'KEY_SCREENLOCK']
            &gt;&gt;&gt; ecodes.KEY[30]
            ... 'KEY_A'

       • Set the state of a LED through <b>InputDevice.set_led()</b> (thanks <u>@accek</u>).

       • Open <b>InputDevice.fd</b> in <b>O_RDWR</b> mode from now on.

       • Fix segfault in <b>InputDevice.device_read_many()</b> (thanks <u>@bgilbert</u>).

   <b>0.3.3</b> <b>(May</b> <b>29,</b> <b>2013)</b>
       • Raise <b>IOError</b> from <b>InputDevice.device_read()</b> and <b>InputDevice.device_read_many()</b> when <b>InputDevice.read()</b>
         fails.

       • Several stability and style changes (thank you debian code reviewers).

   <b>0.3.2</b> <b>(Apr</b> <b>05,</b> <b>2013)</b>
       • Fix vendor id and product id order in <b>DeviceInfo()</b> (thanks <u>@kived</u>).

   <b>0.3.1</b> <b>(Nov</b> <b>23,</b> <b>2012)</b>
       • <b>InputDevice.read()</b> will return an  empty  tuple  if  the  device  has  nothing  to  offer  (instead  of
         segfaulting).

       • Exclude unnecessary package data in sdist and bdist.

   <b>0.3.0</b> <b>(Nov</b> <b>06,</b> <b>2012)</b>
       • Add ability to set/get auto-repeat settings with <b>EVIOC{SG}REP</b>.

       • Add <b>InputDevice.version()</b> - the value of <b>EVIOCGVERSION</b>.

       • Add <b>InputDevice.read_loop()</b>.

       • Add <b>InputDevice.grab()</b> and <b>InputDevice.ungrab()</b> - exposes <b>EVIOCGRAB</b>.

       • Add <b>InputDevice.leds()</b> - exposes <b>EVIOCGLED</b>.

       • Replace <b>DeviceInfo</b> class with a namedtuple.

       • Prevent <b>InputDevice.read_one()</b> from skipping events.

       • Rename <b>AbsData</b> to <b>AbsInfo</b> (as in <b>struct</b> <b>input_absinfo</b>).

   <b>0.2.0</b> <b>(Aug</b> <b>22,</b> <b>2012)</b>
       • Add the ability to set arbitrary device capabilities on uinput devices (defaults to all <b>EV_KEY</b> ecodes).

       • Add <b>UInput.device</b> which is an open <b>InputDevice</b> to the input device that uinput 'spawns'.

       • Add <b>UInput.capabilities()</b> which is just a shortcut to <b>UInput.device.capabilities()</b>.

       • Rename <b>UInput.write()</b> to <b>UInput.write_event()</b>.

       • Add a simpler <b>UInput.write(type,</b> <b>code,</b> <b>value)()</b> method.

       • Make all <b>UInput()</b> constructor arguments optional (default device name is now <b>py-evdev-uinput</b>).

       • Add  the  ability  to  set  <b>absmin</b>,  <b>absmax</b>,  <b>absfuzz</b>  and  <b>absflat</b> when specifying the uinput device's
         capabilities.

       • Remove the <b>nophys</b> argument - if a device fails the <b>EVIOCGPHYS</b> ioctl, phys will equal the empty string.

       • Make <b>InputDevice.capabilities()</b> perform a <b>EVIOCGABS</b> ioctl for devices that support  <b>EV_ABS</b>  and  return
         that info wrapped in an <b>AbsData</b> namedtuple.

       • Split <b>ioctl_devinfo</b> into <b>ioctl_devinfo</b> and <b>ioctl_capabilities</b>.

       • Split <b>UInput.uinput_open()</b> to <b>UInput.uinput_open()</b> and <b>UInput.uinput_create()</b>

       • Add more uinput usage examples and documentation.

       • Rewrite uinput tests.

       • Remove <b>mouserel</b> and <b>mouseabs</b> from <b>UInput</b>.

       • Tie the sphinx version and release to the distutils version.

       • Set 'methods-before-attributes' sorting in the docs.

       • Remove <b>KEY_CNT</b> and <b>KEY_MAX</b> from <b>ecodes.keys()</b>.

   <b>0.1.1</b> <b>(May</b> <b>18,</b> <b>2012)</b>
       • Add <b>events.keys</b>, which is a combination of all <b>BTN_</b> and <b>KEY_</b> event codes.

       • <b>ecodes.c</b> was not generated when installing through <b>pip</b>.

   <b>0.1.0</b> <b>(May</b> <b>17,</b> <b>2012)</b>
       <u>Initial</u> <u>Release</u>

       This package is released under the terms of the <u>Revised</u> <u>BSD</u> <u>License</u>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Georgi Valkov

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2012-2025, Georgi Valkov and contributors

1.9.1                                             Mar 01, 2025                                   <u><a href="../man7/PYTHON-EVDEV.7.html">PYTHON-EVDEV</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>