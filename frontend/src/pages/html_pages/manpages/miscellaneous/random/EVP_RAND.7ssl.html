<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_RAND - the random bit generator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openssl">openssl_3.5.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_RAND - the random bit generator

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;
        #include &lt;rand.h&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The default OpenSSL RAND method is based on the EVP_RAND classes to provide non-deterministic inputs to
       other cryptographic algorithms.

       While the RAND API is the 'frontend' which is intended to be used by application developers for obtaining
       random bytes, the EVP_RAND API serves as the 'backend', connecting the former with the operating
       systems's entropy sources and providing access to deterministic random bit generators (DRBG) and their
       configuration parameters.  A DRBG is a certain type of cryptographically-secure pseudo-random number
       generator (CSPRNG), which is described in [NIST SP 800-90A Rev. 1].

   <b>Disclaimer</b>
       Unless you have very specific requirements for your random generator, it is in general not necessary to
       utilize the EVP_RAND API directly.  The usual way to obtain random bytes is to use <b><a href="../man3/RAND_bytes.3.html">RAND_bytes</a></b>(3) or
       <b><a href="../man3/RAND_priv_bytes.3.html">RAND_priv_bytes</a></b>(3), see also <b><a href="../man7/RAND.7.html">RAND</a></b>(7).

   <b>Typical</b> <b>Use</b> <b>Cases</b>
       Typical examples for such special use cases are the following:

       • You  want to use your own private DRBG instances.  Multiple DRBG instances which are accessed only by a
         single thread provide additional security (because their internal states are  independent)  and  better
         scalability in multithreaded applications (because they don't need to be locked).

       • You  need  to  integrate  a  previously  unsupported entropy source.  Refer to <b><a href="../man7/provider-rand.7.html">provider-rand</a></b>(7) for the
         implementation details to support adding randomness sources to EVP_RAND.

       • You need to change the default settings of the standard OpenSSL RAND implementation  to  meet  specific
         requirements.

</pre><h4><b>EVP_RAND</b> <b>CHAINING</b></h4><pre>
       An  EVP_RAND  instance  can  be  used as the entropy source of another EVP_RAND instance, provided it has
       itself access to a valid entropy source.  The EVP_RAND instance which acts as entropy  source  is  called
       the  <u>parent</u>,  the other instance the <u>child</u>.  Typically, the child will be a DRBG because it does not make
       sense for the child to be an entropy source.

       This is called chaining. A chained EVP_RAND instance is created  by  passing  a  pointer  to  the  parent
       EVP_RAND_CTX  as  argument  to the <b>EVP_RAND_CTX_new()</b> call.  It is possible to create chains of more than
       two DRBG in a row.  It is also possible to use any EVP_RAND_CTX class as the parent, however, only a live
       entropy source may ignore and not use its parent.

</pre><h4><b>THE</b> <b>THREE</b> <b>SHARED</b> <b>DRBG</b> <b>INSTANCES</b></h4><pre>
       Currently, there are three shared DRBG instances, the &lt;primary&gt;, &lt;public&gt;, and &lt;private&gt; DRBG.  While the
       &lt;primary&gt; DRBG is a single global instance, the &lt;public&gt; and &lt;private&gt; DRBG are created  per  thread  and
       accessed through thread-local storage.

       By  default,  the  functions  <b><a href="../man3/RAND_bytes.3.html">RAND_bytes</a></b>(3)  and  <b><a href="../man3/RAND_priv_bytes.3.html">RAND_priv_bytes</a></b>(3)  use  the  thread-local &lt;public&gt; and
       &lt;private&gt; DRBG instance, respectively.

   <b>The</b> <b>&lt;primary&gt;</b> <b>DRBG</b> <b>instance</b>
       The &lt;primary&gt; DRBG is not used directly by the application, only for reseeding the  two  other  two  DRBG
       instances.  It  reseeds  itself  by  obtaining  randomness either from os entropy sources or by consuming
       randomness which was added previously by <b><a href="../man3/RAND_add.3.html">RAND_add</a></b>(3).

   <b>The</b> <b>&lt;public&gt;</b> <b>DRBG</b> <b>instance</b>
       This instance is used per default by <b><a href="../man3/RAND_bytes.3.html">RAND_bytes</a></b>(3).

   <b>The</b> <b>&lt;private&gt;</b> <b>DRBG</b> <b>instance</b>
       This instance is used per default by <b><a href="../man3/RAND_priv_bytes.3.html">RAND_priv_bytes</a></b>(3)

</pre><h4><b>LOCKING</b></h4><pre>
       The &lt;primary&gt; DRBG is intended to be accessed concurrently for reseeding by its child DRBG instances. The
       necessary locking is done internally.  It is <u>not</u> thread-safe to access the &lt;primary&gt;  DRBG  directly  via
       the  EVP_RAND  interface.  The &lt;public&gt; and &lt;private&gt; DRBG are thread-local, i.e. there is an instance of
       each per thread. So they can safely be accessed without locking via the EVP_RAND interface.

       Pointers to these DRBG instances  can  be  obtained  using  <b>RAND_get0_primary()</b>,  <b>RAND_get0_public()</b>  and
       <b>RAND_get0_private()</b>,  respectively.  Note that it is not allowed to store a pointer to one of the thread-
       local DRBG instances in a variable or other memory location  where  it  will  be  accessed  and  used  by
       multiple threads.

       All other DRBG instances created by an application don't support locking, because they are intended to be
       used  by  a  single  thread.   Instead  of  accessing  a single DRBG instance concurrently from different
       threads, it is recommended to instantiate a separate DRBG instance per thread. Using the  &lt;primary&gt;  DRBG
       as  entropy  source  for  multiple  DRBG  instances on different threads is thread-safe, because the DRBG
       instance will lock the &lt;primary&gt; DRBG automatically for obtaining random input.

</pre><h4><b>THE</b> <b>OVERALL</b> <b>PICTURE</b></h4><pre>
       The following picture gives an overview over how the DRBG instances work together and are being used.

                      +--------------------+
                      | os entropy sources |
                      +--------------------+
                               |
                               v           +-----------------------------+
            RAND_add() ==&gt; &lt;primary&gt;     &lt;-| shared DRBG (with locking)  |
                             /   \         +-----------------------------+
                            /     \              +---------------------------+
                     &lt;public&gt;     &lt;private&gt;   &lt;- | per-thread DRBG instances |
                        |             |          +---------------------------+
                        v             v
                      RAND_bytes()   RAND_priv_bytes()
                           |               ^
                           |               |
           +------------------+      +------------------------------------+
           | general purpose  |      | used for secrets like session keys |
           | random generator |      | and private keys for certificates  |
           +------------------+      +------------------------------------+

       The usual way to obtain random bytes is to call RAND_bytes(...) or RAND_priv_bytes(...). These calls  are
       roughly  equivalent  to  calling  EVP_RAND_generate(&lt;public&gt;, ...) and EVP_RAND_generate(&lt;private&gt;, ...),
       respectively.

</pre><h4><b>RESEEDING</b></h4><pre>
       A DRBG instance seeds itself automatically, pulling random input from its  entropy  source.  The  entropy
       source  can  be  either  a trusted operating system entropy source, or another DRBG with access to such a
       source.

       Automatic reseeding occurs after a predefined number of generate requests.  The selection of the  trusted
       entropy  sources  is  configured  at build time using the --with-rand-seed option. The following sections
       explain the reseeding process in more detail.

   <b>Automatic</b> <b>Reseeding</b>
       Before satisfying a generate request (<b><a href="../man3/EVP_RAND_generate.3.html">EVP_RAND_generate</a></b>(3)), the DRBG reseeds  itself  automatically,  if
       one of the following conditions holds:

       - the DRBG was not instantiated (=seeded) yet or has been uninstantiated.

       -  the  number  of  generate requests since the last reseeding exceeds a certain threshold, the so called
       <u>reseed_interval</u>.  This behaviour can be disabled by setting the <u>reseed_interval</u> to 0.

       -  the  time  elapsed  since  the  last  reseeding  exceeds  a  certain  time  interval,  the  so  called
       <u>reseed_time_interval</u>.  This can be disabled by setting the <u>reseed_time_interval</u> to 0.

       - the DRBG is in an error state.

       <b>Note</b>:  An error state is entered if the entropy source fails while the DRBG is seeding or reseeding.  The
       last case ensures that the DRBG automatically recovers from the error as soon as the  entropy  source  is
       available again.

   <b>Manual</b> <b>Reseeding</b>
       In  addition to automatic reseeding, the caller can request an immediate reseeding of the DRBG with fresh
       entropy by setting the <u>prediction</u> <u>resistance</u> parameter to 1 when calling <b><a href="../man3/EVP_RAND_generate.3.html">EVP_RAND_generate</a></b>(3).

       The document [NIST SP 800-90C] describes prediction resistance requests  in  detail  and  imposes  strict
       conditions  on  the entropy sources that are approved for providing prediction resistance.  A request for
       prediction resistance can only be satisfied by pulling fresh entropy from a live entropy source  (section
       5.5.2 of [NIST SP 800-90C]).  It is up to the user to ensure that a live entropy source is configured and
       is being used.

       For  the  three  shared  DRBGs  (and  only  for  these)  there is another way to reseed them manually: If
       <b><a href="../man3/RAND_add.3.html">RAND_add</a></b>(3) is called with a positive <u>randomness</u> argument (or <b><a href="../man3/RAND_seed.3.html">RAND_seed</a></b>(3)), then this  will  immediately
       reseed  the &lt;primary&gt; DRBG.  The &lt;public&gt; and &lt;private&gt; DRBG will detect this on their next generate call
       and reseed, pulling randomness from &lt;primary&gt;.

       The last feature has been added to support the common practice used with  previous  OpenSSL  versions  to
       call <b>RAND_add()</b> before calling <b>RAND_bytes()</b>.

   <b>Entropy</b> <b>Input</b> <b>and</b> <b>Additional</b> <b>Data</b>
       The  DRBG  distinguishes two different types of random input: <u>entropy</u>, which comes from a trusted source,
       and <u>additional</u> <u>input</u>', which can optionally be added by the user and  is  considered  untrusted.   It  is
       possible to add <u>additional</u> <u>input</u> not only during reseeding, but also for every generate request.

   <b>Configuring</b> <b>the</b> <b>Random</b> <b>Seed</b> <b>Source</b>
       In  most  cases  OpenSSL  will  automatically choose a suitable seed source for automatically seeding and
       reseeding its &lt;primary&gt; DRBG. The default seed source can be  configured  when  OpenSSL  is  compiled  by
       setting <b>-DOPENSSL_DEFAULT_SEED_SRC=SEED-SRC</b>. If not set then "SEED-SRC" is used. One can specify a third-
       party provider seed-source, or <b>-DOPENSSL_DEFAULT_SEED_SRC=JITTER</b> if available.

       In some cases however, it will be necessary to explicitly specify a seed source used by "SEED-SRC" during
       configuration,  using  the  --with-rand-seed  option. For more information, see the INSTALL instructions.
       There are also operating systems where no seed source is available and automatic reseeding is disabled by
       default.

       The following two sections describe the reseeding process of  the  primary  DRBG,  depending  on  whether
       automatic reseeding is available or not.

   <b>Reseeding</b> <b>the</b> <b>primary</b> <b>DRBG</b> <b>with</b> <b>automatic</b> <b>seeding</b> <b>enabled</b>
       Calling <b>RAND_poll()</b> or <b>RAND_add()</b> is not necessary, because the DRBG pulls the necessary entropy from its
       source automatically.  However, both calls are permitted, and do reseed the RNG.

       <b>RAND_add()</b>  can  be  used  to  add  both  kinds of random input, depending on the value of the <u>randomness</u>
       argument:

       randomness == 0:
           The random bytes are mixed as additional input into  the  current  state  of  the  DRBG.   Mixing  in
           additional input is not considered a full reseeding, hence the reseed counter is not reset.

       randomness &gt; 0:
           The  random  bytes are used as entropy input for a full reseeding (resp. reinstantiation) if the DRBG
           is instantiated (resp. uninstantiated or in an error state).  The number of random bits required  for
           reseeding  is  determined by the security strength of the DRBG. Currently it defaults to 256 bits (32
           bytes).  It is possible to  provide  less  randomness  than  required.   In  this  case  the  missing
           randomness will be obtained by pulling random input from the trusted entropy sources.

       NOTE:  Manual  reseeding is *not allowed* in FIPS mode, because [NIST SP-800-90Ar1] mandates that entropy
       *shall not* be provided by the  consuming  application  for  instantiation  (Section  9.1)  or  reseeding
       (Section  9.2).  For that reason, the <u>randomness</u> argument is ignored and the random bytes provided by the
       <b><a href="../man3/RAND_add.3.html">RAND_add</a></b>(3) and <b><a href="../man3/RAND_seed.3.html">RAND_seed</a></b>(3) calls are treated as additional data.

   <b>Reseeding</b> <b>the</b> <b>primary</b> <b>DRBG</b> <b>with</b> <b>automatic</b> <b>seeding</b> <b>disabled</b>
       Calling <b>RAND_poll()</b> will always fail.

       <b>RAND_add()</b> needs to be called for initial seeding and periodic reseeding.  At least 48 bytes  (384  bits)
       of  randomness have to be provided, otherwise the (re-)seeding of the DRBG will fail. This corresponds to
       one and a half times the security strength of the DRBG. The extra half  is  used  for  the  nonce  during
       instantiation.

       More precisely, the number of bytes needed for seeding depend on the <u>security</u> <u>strength</u> of the DRBG, which
       is set to 256 by default.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/RAND.7.html">RAND</a></b>(7), <b><a href="../man3/EVP_RAND.3.html">EVP_RAND</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       This functionality was added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2017-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                     <u><a href="../man7SSL/EVP_RAND.7SSL.html">EVP_RAND</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>