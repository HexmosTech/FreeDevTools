<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glob - globbing pathnames</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       glob - globbing pathnames

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Long  ago, in UNIX V6, there was a program <u>/etc/glob</u> that would expand wildcard patterns.  Soon afterward
       this became a shell built-in.

       These days there is also a library routine <b><a href="../man3/glob.3.html">glob</a></b>(3) that will perform this function for a user program.

       The rules are as follows (POSIX.2, 3.13).

   <b>Wildcard</b> <b>matching</b>
       A string is a wildcard pattern if it contains one of the characters '?', '*', or '['.   Globbing  is  the
       operation  that  expands a wildcard pattern into the list of pathnames matching the pattern.  Matching is
       defined by:

       A '?' (not between brackets) matches any single character.

       A '*' (not between brackets) matches any string, including the empty string.

       <b>Character</b> <b>classes</b>

       An expression "<u>[...]</u>" where the first character after the leading '[' is not  an  '!'  matches  a  single
       character,  namely  any  of the characters enclosed by the brackets.  The string enclosed by the brackets
       cannot be empty; therefore ']' can be allowed between  the  brackets,  provided  that  it  is  the  first
       character.  (Thus, "<u>[][!]</u>" matches the three characters '[', ']', and '!'.)

       <b>Ranges</b>

       There is one special convention: two characters separated by '-' denote a range.  (Thus, "<u>[A-Fa-f0-9]</u>" is
       equivalent  to  "<u>[ABCDEFabcdef0123456789]</u>".)  One may include '-' in its literal meaning by making it the
       first or last character between the brackets.  (Thus, "<u>[]-]</u>" matches just the two characters ']' and '-',
       and "<u>[--0]</u>" matches the three characters '-', '.', and '0', since '/' cannot be matched.)

       <b>Complementation</b>

       An expression "<u>[!...]</u>" matches a single character, namely any  character  that  is  not  matched  by  the
       expression  obtained  by  removing  the  first '!' from it.  (Thus, "<u>[!]a-]</u>" matches any single character
       except ']', 'a', and '-'.)

       One can remove the special meaning of '?', '*', and '[' by preceding them by a  backslash,  or,  in  case
       this  is part of a shell command line, enclosing them in quotes.  Between brackets these characters stand
       for themselves.  Thus, "<u>[[?*\]</u>" matches the four characters '[', '?', '*', and '\'.

   <b>Pathnames</b>
       Globbing is applied on each of the components of a pathname separately.  A '/' in a  pathname  cannot  be
       matched  by  a  '?'  or  '*'  wildcard,  or  by a range like "<u>[.-0]</u>".  A range containing an explicit '/'
       character is syntactically incorrect.  (POSIX requires that syntactically  incorrect  patterns  are  left
       unchanged.)

       If  a filename starts with a '.', this character must be matched explicitly.  (Thus, <u>rm</u> <u>*</u> will not remove
       .profile, and <u>tar</u> <u>c</u> <u>*</u> will not archive all your files; <u>tar</u> <u>c</u> <u>.</u> is better.)

   <b>Empty</b> <b>lists</b>
       The nice and simple rule given above: "expand a wildcard pattern into the list of matching pathnames" was
       the original UNIX definition.  It allowed one to have patterns that expand into an empty list, as in

           xv -wait 0 *.gif *.jpg

       where perhaps no *.gif files are present (and this is not an error).   However,  POSIX  requires  that  a
       wildcard  pattern is left unchanged when it is syntactically incorrect, or the list of matching pathnames
       is empty.  With <u>bash</u> one can force the classical behavior using this command:

           shopt -s nullglob

       (Similar problems occur elsewhere.  For example, where old scripts have

           rm `find . -name "*~"`

       new scripts require

           rm -f nosuchfile `find . -name "*~"`

       to avoid error messages from <u>rm</u> called with an empty argument list.)

</pre><h4><b>NOTES</b></h4><pre>
   <b>Regular</b> <b>expressions</b>
       Note that wildcard patterns are not regular expressions, although they are a bit similar.  First of  all,
       they match filenames, rather than text, and secondly, the conventions are not the same: for example, in a
       regular expression '*' means zero or more copies of the preceding thing.

       Now that regular expressions have bracket expressions where the negation is indicated by a '^', POSIX has
       declared the effect of a wildcard pattern "<u>[^...]</u>" to be undefined.

   <b>Character</b> <b>classes</b> <b>and</b> <b>internationalization</b>
       Of  course  ranges  were  originally  meant to be ASCII ranges, so that "<u>[</u> <u>-%]</u>" stands for "<u>[</u> <u>!"#$%]</u>" and
       "<u>[a-z]</u>" stands for "any lowercase letter".  Some UNIX implementations generalized this so  that  a  range
       X-Y stands for the set of characters with code between the codes for X and for Y.  However, this requires
       the  user to know the character coding in use on the local system, and moreover, is not convenient if the
       collating sequence for the local alphabet differs from the ordering of the character  codes.   Therefore,
       POSIX  extended the bracket notation greatly, both for wildcard patterns and for regular expressions.  In
       the above we saw three types of items that can occur in a bracket expression: namely  (i)  the  negation,
       (ii)  explicit  single  characters,  and (iii) ranges.  POSIX specifies ranges in an internationally more
       useful way and adds three more types:

       (iii) Ranges X-Y comprise all characters that fall between X and Y (inclusive) in the  current  collating
       sequence as defined by the <b>LC_COLLATE</b> category in the current locale.

       (iv) Named character classes, like

       [:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]
       [:digit:]  [:graph:]  [:lower:]  [:print:]
       [:punct:]  [:space:]  [:upper:]  [:xdigit:]

       so  that  one can say "<u>[[:lower:]]</u>" instead of "<u>[a-z]</u>", and have things work in Denmark, too, where there
       are three letters past 'z' in the alphabet.  These character classes are defined by the <b>LC_CTYPE</b> category
       in the current locale.

       (v) Collating symbols, like "<u>[.ch.]</u>" or "<u>[.a-acute.]</u>", where the  string  between  "<u>[.</u>"  and  "<u>.]</u>"  is  a
       collating element defined for the current locale.  Note that this may be a multicharacter element.

       (vi) Equivalence class expressions, like "<u>[=a=]</u>", where the string between "<u>[=</u>" and "<u>=]</u>" is any collating
       element  from  its equivalence class, as defined for the current locale.  For example, "<u>[[=a=]]</u>" might be
       equivalent to "<u>[aáàäâ]</u>", that is, to "<u>[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]</u>".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/sh.1.html">sh</a></b>(1), <b><a href="../man3/fnmatch.3.html">fnmatch</a></b>(3), <b><a href="../man3/glob.3.html">glob</a></b>(3), <b><a href="../man7/locale.7.html">locale</a></b>(7), <b><a href="../man7/regex.7.html">regex</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                            <u><a href="../man7/glob.7.html">glob</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>