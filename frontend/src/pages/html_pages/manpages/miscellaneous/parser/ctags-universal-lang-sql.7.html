<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ctags-lang-sql - The man page of the SQL parser for Universal Ctags</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/universal-ctags">universal-ctags_5.9.20210829.0-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ctags-lang-sql - The man page of the SQL parser for Universal Ctags

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>ctags</b> ... [--extras={guest}] --languages=+SQL ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The SQL parser supports various SQL dialects. PostgreSQL is one of them.

       PostgreSQL  allows user-defined functions to be written in other languages (<u>procedural</u> <u>languages</u>) besides
       SQL and C [PL].

       The SQL parser makes tags for language objects in the user-defined functions written  in  the  procedural
       languages if the <b>guest</b> extra is enabled.

       The  SQL  parser  looks  for  a token coming after <b>LANGUAGE</b> keyword in the source code to choose a proper
       guest parser.

          ... LANGUAGE plpythonu AS '... user-defined function ' ...
          ... AS $$ user-defined function $$ LANGUAGE plv8 ...

       In the above examples, <b>plpythonu</b> and <b>plv8</b> are the names of procedural languages. The SQL parser trims  <u>pl</u>
       at the start and <u>u</u> at the end of the name before finding a ctags parser.  For <b>plpythonu</b> and <b>plv8</b>, the SQL
       parser extracts <b>python</b> and <b>v8</b> as the candidates of guest parsers.

       For  <b>plpythonu</b>,  ctags  can  run  its  Python parser.  ctags doesn't have a parser named <b>v8</b>. However, the
       JavaScript parser in ctags has <b>v8</b> as an alias. So ctags can run the JavaScript parser as the guest parser
       for <b>plv8</b>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       tagging code including a user-defined function in a string literal [GH3006]:

       "input.sql"

          CREATE OR REPLACE FUNCTION fun1() RETURNS VARCHAR AS '
          DECLARE
                  test1_var1 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := $$ABC$$;
                  test1_var2 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := $xyz$XYZ$xyz$;
                  test1_var3     INTEGER := 1;
          BEGIN
                  RETURN  TO_CHAR(test_var3, ''000'') || test1_var1 || test1_var2;
          END;
          ' LANGUAGE plpgsql;

       "output.tags" with "--options=NONE -o - --sort=no --extras=+{guest} input.sql"

          fun1    input.sql       /^CREATE OR REPLACE FUNCTION fun1() RETURNS VARCHAR AS '$/;"    f
          test1_var1      input.sql       /^      test1_var1 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := $$ABC$$;$/;"  v
          test1_var2      input.sql       /^      test1_var2 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := $xyz$XYZ$xyz$;$/;"    v
          test1_var3      input.sql       /^      test1_var3     INTEGER := 1;$/;"        v

       tagging code including a user-defined function in a dollar quote [GH3006]:

       "input.sql"

          CREATE OR REPLACE FUNCTION fun2() RETURNS VARCHAR LANGUAGE plpgsql AS $$
          DECLARE
                  test2_var1 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := 'ABC2';
                  test2_var2 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := 'XYZ2';
                  test2_var3        INTEGER := 2;
          BEGIN
                  RETURN  TO_CHAR(test2_var3, '000') || test2_var1 || test2_var2;
          END;
          $$;

       "output.tags" with "--options=NONE -o - --sort=no --extras=+{guest} input.sql"

          fun2    input.sql       /^CREATE OR REPLACE FUNCTION fun2() RETURNS VARCHAR LANGUAGE plpgsql AS $\$$/;" f
          test2_var1      input.sql       /^      test2_var1 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := 'ABC2';$/;"   v
          test2_var2      input.sql       /^      test2_var2 <a href="../man64/VARCHAR.64.html">VARCHAR</a>(64) := 'XYZ2';$/;"   v
          test2_var3      input.sql       /^      test2_var3        INTEGER := 2;$/;"     v

       tagging code including a user-defined written in JavaScript:

          -- Derived from https://github.com/plv8/plv8/blob/r3.0alpha/sql/plv8.sql
          CREATE FUNCTION test(keys text[], vals text[]) RETURNS text AS
          $$
                  var o = {};
                  for (var i = 0; i &lt; keys.length; i++)
                          o[keys[i]] = vals[i];
                  return JSON.stringify(o);
          $$
          LANGUAGE plv8 IMMUTABLE STRICT;

       "output.tags" with "--options=NONE -o - --sort=no --extras=+{guest} input.sql"

          test    input.sql       /^CREATE FUNCTION test(keys text[], vals text[]) RETURNS text AS$/;"    f
          o       input.sql       /^      var o = {};$/;" v

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       Escape sequences (<u>''</u>) in a string literal may make a guest parser confused.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/ctags.1.html">ctags</a>(1), <a href="../man7/ctags-client-tools.7.html">ctags-client-tools</a>(7)

</pre><h4><b>REFERENCES</b></h4><pre>
       [PL] PostgreSQL      9.5.25      Documentation,      "Chapter      39.       Procedural       Languages",
            &lt;https://www.postgresql.org/docs/9.5/xplang.html&gt;

       [GH3006]
            @bagl's comment submitted to  &lt;https://github.com/universal-ctags/ctags/issues/3006&gt;

5.9.0                                                                                          <u><a href="../man7/CTAGS-LANG-SQL.7.html">CTAGS-LANG-SQL</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>