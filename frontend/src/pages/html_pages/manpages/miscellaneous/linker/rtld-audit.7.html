<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rtld-audit - auditing API for the dynamic linker</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rtld-audit - auditing API for the dynamic linker

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>             /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/link.h">link.h</a>&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  GNU  dynamic  linker  (run-time  linker)  provides  an auditing API that allows an application to be
       notified when various dynamic linking events occur.  This API is very similar to the  auditing  interface
       provided by the Solaris run-time linker.  The necessary constants and prototypes are defined by including
       <u>&lt;link.h&gt;</u>.

       To use this interface, the programmer creates a shared library that implements a standard set of function
       names.   Not  all  of  the  functions  need  to  be  implemented: in most cases, if the programmer is not
       interested in a particular class of auditing event, then no implementation needs to be provided  for  the
       corresponding auditing function.

       To  employ  the auditing interface, the environment variable <b>LD_AUDIT</b> must be defined to contain a colon-
       separated list of shared libraries, each of which can implement (parts of) the  auditing  API.   When  an
       auditable  event  occurs,  the  corresponding  function is invoked in each library, in the order that the
       libraries are listed.

   <b>la_version()</b>

       <b>unsigned</b> <b>int</b> <b>la_version(unsigned</b> <b>int</b> <u>version</u><b>);</b>

       This is the only function that <u>must</u> be defined by an auditing library: it performs the initial  handshake
       between  the  dynamic  linker  and the auditing library.  When invoking this function, the dynamic linker
       passes, in <u>version</u>, the highest version of the auditing interface that the linker supports.

       A typical implementation of this function simply returns the constant <b>LAV_CURRENT</b>,  which  indicates  the
       version of <u>&lt;link.h&gt;</u> that was used to build the audit module.  If the dynamic linker does not support this
       version  of  the  audit interface, it will refuse to activate this audit module.  If the function returns
       zero, the dynamic linker also does not activate this audit module.

       In order to enable backwards compatibility with older dynamic linkers, an audit module  can  examine  the
       <u>version</u>  argument  and  return  an  earlier  version than <b>LAV_CURRENT</b>, assuming the module can adjust its
       implementation to match the requirements of the previous version of the audit interface.  The  <b>la_version</b>
       function  should not return the value of <u>version</u> without further checks because it could correspond to an
       interface that does not match the <u>&lt;link.h&gt;</u> definitions used to build the audit module.

   <b>la_objsearch()</b>

       <b>char</b> <b>*la_objsearch(const</b> <b>char</b> <b>*</b><u>name</u><b>,</b> <b>uintptr_t</b> <b>*</b><u>cookie</u><b>,</b>
                          <b>unsigned</b> <b>int</b> <u>flag</u><b>);</b>

       The dynamic linker invokes this function to inform the auditing library that it is about to search for  a
       shared  object.   The  <u>name</u>  argument  is  the  filename  or pathname that is to be searched for.  <u>cookie</u>
       identifies the shared object that initiated the search.  <u>flag</u> is set to one of the following values:

       <b>LA_SER_ORIG</b>      This is the original name that is being searched for.  Typically, this name  comes  from
                        an ELF <b>DT_NEEDED</b> entry, or is the <u>filename</u> argument given to <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3).

       <b>LA_SER_LIBPATH</b>   <u>name</u> was created using a directory specified in <b>LD_LIBRARY_PATH</b>.

       <b>LA_SER_RUNPATH</b>   <u>name</u> was created using a directory specified in an ELF <b>DT_RPATH</b> or <b>DT_RUNPATH</b> list.

       <b>LA_SER_CONFIG</b>    <u>name</u> was found via the <b><a href="../man8/ldconfig.8.html">ldconfig</a></b>(8) cache (<u><a href="file:/etc/ld.so.cache">/etc/ld.so.cache</a></u>).

       <b>LA_SER_DEFAULT</b>   <u>name</u> was found via a search of one of the default directories.

       <b>LA_SER_SECURE</b>    <u>name</u> is specific to a secure object (unused on Linux).

       As  its  function  result,  <b>la_objsearch</b>()  returns  the  pathname that the dynamic linker should use for
       further processing.  If NULL is returned, then this pathname is ignored for further processing.  If  this
       audit library simply intends to monitor search paths, then <u>name</u> should be returned.

   <b>la_activity()</b>

       <b>void</b> <b>la_activity(</b> <b>uintptr_t</b> <b>*</b><u>cookie</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flag</u><b>);</b>

       The  dynamic  linker  calls  this  function  to  inform  the  auditing  library that link-map activity is
       occurring.  <u>cookie</u> identifies the object at the head of the link map.  When the  dynamic  linker  invokes
       this function, <u>flag</u> is set to one of the following values:

       <b>LA_ACT_ADD</b>         New objects are being added to the link map.

       <b>LA_ACT_DELETE</b>      Objects are being removed from the link map.

       <b>LA_ACT_CONSISTENT</b>  Link-map activity has been completed: the map is once again consistent.

   <b>la_objopen()</b>

       <b>unsigned</b> <b>int</b> <b>la_objopen(struct</b> <b>link_map</b> <b>*</b><u>map</u><b>,</b> <b>Lmid_t</b> <u>lmid</u><b>,</b>
                               <b>uintptr_t</b> <b>*</b><u>cookie</u><b>);</b>

       The dynamic linker calls this function when a new shared object is loaded.  The <u>map</u> argument is a pointer
       to a link-map structure that describes the object.  The <u>lmid</u> field has one of the following values

       <b>LM_ID_BASE</b>       Link map is part of the initial namespace.

       <b>LM_ID_NEWLM</b>      Link map is part of a new namespace requested via <b><a href="../man3/dlmopen.3.html">dlmopen</a></b>(3).

       <u>cookie</u>  is  a  pointer  to  an  identifier for this object.  The identifier is provided to later calls to
       functions in the auditing library in order to identify this object.  This identifier  is  initialized  to
       point  to  object's link map, but the audit library can change the identifier to some other value that it
       may prefer to use to identify the object.

       As its return value, <b>la_objopen</b>() returns a bit mask created by ORing  zero  or  more  of  the  following
       constants, which allow the auditing library to select the objects to be monitored by <b>la_symbind*</b>():

       <b>LA_FLG_BINDTO</b>    Audit symbol bindings to this object.

       <b>LA_FLG_BINDFROM</b>  Audit symbol bindings from this object.

       A  return  value  of  0  from  <b>la_objopen</b>()  indicates that no symbol bindings should be audited for this
       object.

   <b>la_objclose()</b>

       <b>unsigned</b> <b>int</b> <b>la_objclose(uintptr_t</b> <b>*</b><u>cookie</u><b>);</b>

       The dynamic linker invokes this function after any finalization code for the object  has  been  executed,
       before the object is unloaded.  The <u>cookie</u> argument is the identifier obtained from a previous invocation
       of <b>la_objopen</b>().

       In the current implementation, the value returned by <b>la_objclose</b>() is ignored.

   <b>la_preinit()</b>

       <b>void</b> <b>la_preinit(uintptr_t</b> <b>*</b><u>cookie</u><b>);</b>

       The  dynamic  linker  invokes  this function after all shared objects have been loaded, before control is
       passed to the application (i.e., before calling <u>main</u>()).  Note that <u>main</u>() may  still  later  dynamically
       load objects using <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3).

   <b>la_symbind*()</b>

       <b>uintptr_t</b> <b>la_symbind32(Elf32_Sym</b> <b>*</b><u>sym</u><b>,</b> <b>unsigned</b> <b>int</b> <u>ndx</u><b>,</b>
                              <b>uintptr_t</b> <b>*</b><u>refcook</u><b>,</b> <b>uintptr_t</b> <b>*</b><u>defcook</u><b>,</b>
                              <b>unsigned</b> <b>int</b> <b>*</b><u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>symname</u><b>);</b>
       <b>uintptr_t</b> <b>la_symbind64(Elf64_Sym</b> <b>*</b><u>sym</u><b>,</b> <b>unsigned</b> <b>int</b> <u>ndx</u><b>,</b>
                              <b>uintptr_t</b> <b>*</b><u>refcook</u><b>,</b> <b>uintptr_t</b> <b>*</b><u>defcook</u><b>,</b>
                              <b>unsigned</b> <b>int</b> <b>*</b><u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>symname</u><b>);</b>

       The dynamic linker invokes one of these functions when a symbol binding occurs between two shared objects
       that have been marked for auditing notification by <b>la_objopen</b>().  The <b>la_symbind32</b>() function is employed
       on 32-bit platforms; the <b>la_symbind64</b>() function is employed on 64-bit platforms.

       The <u>sym</u> argument is a pointer to a structure that provides information about the symbol being bound.  The
       structure  definition  is  shown  in <u>&lt;elf.h&gt;</u>.  Among the fields of this structure, <u>st_value</u> indicates the
       address to which the symbol is bound.

       The <u>ndx</u> argument gives the index of the symbol in the symbol table of the bound shared object.

       The <u>refcook</u> argument identifies the shared object that is making the symbol reference; this is  the  same
       identifier  that  is  provided  to  the <b>la_objopen</b>() function that returned <b>LA_FLG_BINDFROM</b>.  The <u>defcook</u>
       argument identifies the shared object that defines the referenced symbol; this  is  the  same  identifier
       that is provided to the <b>la_objopen</b>() function that returned <b>LA_FLG_BINDTO</b>.

       The <u>symname</u> argument points a string containing the name of the symbol.

       The  <u>flags</u>  argument  is  a  bit  mask that both provides information about the symbol and can be used to
       modify further auditing of this PLT (Procedure Linkage Table) entry.  The dynamic linker may  supply  the
       following bit values in this argument:

       <b>LA_SYMB_DLSYM</b>         The binding resulted from a call to <b><a href="../man3/dlsym.3.html">dlsym</a></b>(3).

       <b>LA_SYMB_ALTVALUE</b>      A previous <b>la_symbind*</b>() call returned an alternate value for this symbol.

       By default, if the auditing library implements <b>la_pltenter</b>() and <b>la_pltexit</b>() functions (see below), then
       these  functions  are  invoked,  after <b>la_symbind</b>(), for PLT entries, each time the symbol is referenced.
       The following flags can be ORed into <u>*flags</u> to change this default behavior:

       <b>LA_SYMB_NOPLTENTER</b>    Don't call <b>la_pltenter</b>() for this symbol.

       <b>LA_SYMB_NOPLTEXIT</b>     Don't call <b>la_pltexit</b>() for this symbol.

       The return value of <b>la_symbind32</b>() and <b>la_symbind64</b>() is the address to which control  should  be  passed
       after the function returns.  If the auditing library is simply monitoring symbol bindings, then it should
       return  <u>sym-&gt;st_value</u>.   A  different value may be returned if the library wishes to direct control to an
       alternate location.

   <b>la_pltenter()</b>
       The precise name and argument types for this function depend on the hardware platform.  (The  appropriate
       definition is supplied by <u>&lt;link.h&gt;</u>.)  Here is the definition for x86-32:

       <b>Elf32_Addr</b> <b>la_i86_gnu_pltenter(Elf32_Sym</b> <b>*</b><u>sym</u><b>,</b> <b>unsigned</b> <b>int</b> <u>ndx</u><b>,</b>
                        <b>uintptr_t</b> <b>*</b><u>refcook</u><b>,</b> <b>uintptr_t</b> <b>*</b><u>defcook</u><b>,</b>
                        <b>La_i86_regs</b> <b>*</b><u>regs</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b><u>flags</u><b>,</b>
                        <b>const</b> <b>char</b> <b>*</b><u>symname</u><b>,</b> <b>long</b> <b>*</b><u>framesizep</u><b>);</b>

       This  function  is  invoked  just before a PLT entry is called, between two shared objects that have been
       marked for binding notification.

       The <u>sym</u>, <u>ndx</u>, <u>refcook</u>, <u>defcook</u>, and <u>symname</u> are as for <b>la_symbind*</b>().

       The <u>regs</u> argument points to a structure (defined in <u>&lt;link.h&gt;</u>) containing the values of  registers  to  be
       used for the call to this PLT entry.

       The  <u>flags</u>  argument  points  to  a  bit  mask  that conveys information about, and can be used to modify
       subsequent auditing of, this PLT entry, as for <b>la_symbind*</b>().

       The <u>framesizep</u> argument points to a <u>long</u> <u>int</u> buffer that can be used to explicitly  set  the  frame  size
       used  for  the  call  to  this  PLT entry.  If different <b>la_pltenter</b>() invocations for this symbol return
       different values, then the maximum returned value is used.  The <b>la_pltexit</b>() function is called  only  if
       this buffer is explicitly set to a suitable value.

       The return value of <b>la_pltenter</b>() is as for <b>la_symbind*</b>().

   <b>la_pltexit()</b>
       The  precise name and argument types for this function depend on the hardware platform.  (The appropriate
       definition is supplied by <u>&lt;link.h&gt;</u>.)  Here is the definition for x86-32:

       <b>unsigned</b> <b>int</b> <b>la_i86_gnu_pltexit(Elf32_Sym</b> <b>*</b><u>sym</u><b>,</b> <b>unsigned</b> <b>int</b> <u>ndx</u><b>,</b>
                        <b>uintptr_t</b> <b>*</b><u>refcook</u><b>,</b> <b>uintptr_t</b> <b>*</b><u>defcook</u><b>,</b>
                        <b>const</b> <b>La_i86_regs</b> <b>*</b><u>inregs</u><b>,</b> <b>La_i86_retval</b> <b>*</b><u>outregs</u><b>,</b>
                        <b>const</b> <b>char</b> <b>*</b><u>symname</u><b>);</b>

       This function is called when a PLT entry, made between two shared  objects  that  have  been  marked  for
       binding  notification,  returns.  The function is called just before control returns to the caller of the
       PLT entry.

       The <u>sym</u>, <u>ndx</u>, <u>refcook</u>, <u>defcook</u>, and <u>symname</u> are as for <b>la_symbind*</b>().

       The <u>inregs</u> argument points to a structure (defined in <u>&lt;link.h&gt;</u>) containing the values of  registers  used
       for  the  call  to  this  PLT  entry.   The  <u>outregs</u> argument points to a structure (defined in <u>&lt;link.h&gt;</u>)
       containing return values for the call to this PLT entry.  These values can be modified by the caller, and
       the changes will be visible to the caller of the PLT entry.

       In the current GNU implementation, the return value of <b>la_pltexit</b>() is ignored.

</pre><h4><b>VERSIONS</b></h4><pre>
       This API is very similar to the Solaris API described in the Solaris <u>Linker</u> <u>and</u> <u>Libraries</u> <u>Guide</u>,  in  the
       chapter <u>Runtime</u> <u>Linker</u> <u>Auditing</u> <u>Interface</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       None.

</pre><h4><b>NOTES</b></h4><pre>
       Note the following differences from the Solaris dynamic linker auditing API:

       •  The Solaris <b>la_objfilter</b>() interface is not supported by the GNU implementation.

       •  The Solaris <b>la_symbind32</b>() and <b>la_pltexit</b>() functions do not provide a <u>symname</u> argument.

       •  The  Solaris  <b>la_pltexit</b>()  function does not provide <u>inregs</u> and <u>outregs</u> arguments (but does provide a
          <u>retval</u> argument with the function return value).

</pre><h4><b>BUGS</b></h4><pre>
       In glibc versions up to and include 2.9, specifying more than one audit library in <b>LD_AUDIT</b> results in  a
       run-time crash.  This is reportedly fixed in glibc 2.10.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;<a href="file:/usr/include/link.h">link.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       unsigned int
       la_version(unsigned int version)
       {
           printf("la_version(): version = %u; LAV_CURRENT = %u\n",
                   version, LAV_CURRENT);

           return LAV_CURRENT;
       }

       char *
       la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)
       {
           printf("la_objsearch(): name = %s; cookie = %p", name, cookie);
           printf("; flag = %s\n",
                   (flag == LA_SER_ORIG) ?    "LA_SER_ORIG" :
                   (flag == LA_SER_LIBPATH) ? "LA_SER_LIBPATH" :
                   (flag == LA_SER_RUNPATH) ? "LA_SER_RUNPATH" :
                   (flag == LA_SER_DEFAULT) ? "LA_SER_DEFAULT" :
                   (flag == LA_SER_CONFIG) ?  "LA_SER_CONFIG" :
                   (flag == LA_SER_SECURE) ?  "LA_SER_SECURE" :
                   "???");

           return name;
       }

       void
       la_activity (uintptr_t *cookie, unsigned int flag)
       {
           printf("la_activity(): cookie = %p; flag = %s\n", cookie,
                   (flag == LA_ACT_CONSISTENT) ? "LA_ACT_CONSISTENT" :
                   (flag == LA_ACT_ADD) ?        "LA_ACT_ADD" :
                   (flag == LA_ACT_DELETE) ?     "LA_ACT_DELETE" :
                   "???");
       }

       unsigned int
       la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)
       {
           printf("la_objopen(): loading \"%s\"; lmid = %s; cookie=%p\n",
                   map-&gt;l_name,
                   (lmid == LM_ID_BASE) ?  "LM_ID_BASE" :
                   (lmid == LM_ID_NEWLM) ? "LM_ID_NEWLM" :
                   "???",
                   cookie);

           return LA_FLG_BINDTO | LA_FLG_BINDFROM;
       }

       unsigned int
       la_objclose (uintptr_t *cookie)
       {
           printf("la_objclose(): %p\n", cookie);

           return 0;
       }

       void
       la_preinit(uintptr_t *cookie)
       {
           printf("la_preinit(): %p\n", cookie);
       }

       uintptr_t
       la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,
               uintptr_t *defcook, unsigned int *flags, const char *symname)
       {
           printf("la_symbind32(): symname = %s; sym-&gt;st_value = %p\n",
                   symname, sym-&gt;st_value);
           printf("        ndx = %u; flags = %#x", ndx, *flags);
           printf("; refcook = %p; defcook = %p\n", refcook, defcook);

           return sym-&gt;st_value;
       }

       uintptr_t
       la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
               uintptr_t *defcook, unsigned int *flags, const char *symname)
       {
           printf("la_symbind64(): symname = %s; sym-&gt;st_value = %p\n",
                   symname, sym-&gt;st_value);
           printf("        ndx = %u; flags = %#x", ndx, *flags);
           printf("; refcook = %p; defcook = %p\n", refcook, defcook);

           return sym-&gt;st_value;
       }

       Elf32_Addr
       la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,
               uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,
               unsigned int *flags, const char *symname, long *framesizep)
       {
           printf("la_i86_gnu_pltenter(): %s (%p)\n", symname, sym-&gt;st_value);

           return sym-&gt;st_value;
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ldd.1.html">ldd</a></b>(1), <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3), <b><a href="../man8/ld.so.8.html">ld.so</a></b>(8), <b><a href="../man8/ldconfig.8.html">ldconfig</a></b>(8)

Linux man-pages 6.9.1                              2024-06-15                                      <u><a href="../man7/RTLD-AUDIT.7.html">RTLD-AUDIT</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>