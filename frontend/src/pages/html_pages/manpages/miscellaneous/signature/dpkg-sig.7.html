<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dpkg-sig - Debian package archive (.deb) signature generation and verification tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/dpkg-sig">dpkg-sig_0.13.1+nmu4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dpkg-sig - Debian package archive (.deb) signature generation and verification tool

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the description of the source code, trying to help people to understand how <b>dpkg-sig</b> works.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <u><b>\@file_info</b></u> <b>=</b> <b>sign_deb</b> <b>(</b><u>$signing_role</u><b>,</b> <u>$file</u><b>)</b>
       Does everything needed to add a signature to <u>$file</u>:

       •   Verifies existing signatures

       •   Creates the meta-data that is actually signed

       •   Calls gpg to sign the meta-data.

       •   Adds the signature to <u>$file</u>

       Returns a reference to an array containing the new md5sum, the new size and the name of the signed deb.

   <u>$signature_name</u> <b>=</b> <b>write_deb_info</b> <b>(</b><u>$signing_role</u><b>,</b> <u>$file</u><b>)</b>
       Creates a digests.asc file with the meta-data of <u>$file</u> in dpkg-sig's tempdir:

       •   Gets the needed information from <u>$file</u>

       •   Chooses the name of the signature

       •   Writes a file in a RFC822-like format containing the meta-data

       Returns the name that should be used to add the file to the deb.

   <b>sign_hashes</b> <b>(</b><u>$file</u><b>)</b>
       Signs a .dpkg-sig-hashes <u>$file</u> containing the digests of a deb/changes file:

       •   Checks the .dpkg-sig-hashes file to see if it really was created by us

       •   Creates a new archive, containing the old control file

       •   Signs the digests and adds the clearsigned data to the the new archive

       •   Substitutes the old file by the new, signed one.

   <u>@changed_files</u> <b>=</b> <b>write_signature</b> <b>(</b><u>$file</u><b>)</b>
       Adds the signatures from a signed .dpkg-sig-hashes <u>$file</u> to the signed debs:

       •   Checks the .dpkg-sig-hashes file to see if it really was created by us

       •   Tries to find out where we find the debs that have sigs in the .dpkg-sig-hashes

       •   Checks if the debs were changed since they were signed

       •   Adds signatures from the .dpkg-sig-hashes file to the debs

       •   If needed, it corrects the changes file to reflect the new sizes/md5sums of the debs

       Returns the pathes of the debs that were changed.

   <u>@output</u> <b>=</b> <b>verify_deb</b> <b>(</b><u>$deb</u><b>,</b> <u>$verify_pattern</u><b>)</b>
       Verifies all signatures in <u>$deb</u> with names matching <u>$verify_pattern</u>:

       •   Gets the digests of all parts of <u>$deb</u>.

       •   Skips all signatures that don't match <u>$verify_pattern</u>.

       •   Writes the signatures to $tempdir/digests.asc.

       •   Calls a function to check if $tempdir/digests.asc is valid in the v4 format, then tries v3 and v2.

       Returns its output. This is needed to achieve a "silent" verification when signing a deb.

   <u>$verification_status</u> <b>=</b> <b>verify_deb_sig_v4</b> <b>(</b><u>$part_name</u><b>,</b> <u>$part_number</u><b>,</b> <u><b>\@digests</b></u><b>,</b> <u><b>\@info</b></u><b>,</b> <u><b>\@return</b></u><b>)</b>
       Verifies if $tempdir/digests is a valid (version 4) signature for the deb described with <u>\@digests</u>:

       •   Calls gpg to verify the OpenPGP signature in $tempdir/digests.asc itself.

       •   Parses the signature to get the digests that were actually signed

       •   Compare the digests of the deb and those extracted from the signature to see if the deb was changed.

       •   Check that the name in the ar archive matches the "Role" field in the signature.

       •   DON'T check the Signer- and Date-Fiels.

       •   Check that at least the digests for control.tar.gz, data.tar.gz and debian-binary were signed.

       Returns if the the signature is good, by an unknown key, or bad.

   <u>$verification_status</u> <b>=</b> <b>verify_deb_sig_v3</b> <b>(</b><u>$part_name</u><b>,</b> <u>$part_number</u><b>,</b> <u><b>\@digests</b></u><b>,</b> <u><b>\@info</b></u><b>,</b> <u><b>\@return</b></u><b>)</b>
       Verifies if $tempdir/digests is a valid (version 3) signature for the deb described with <u>\@digests</u>:

       •   Creates  a  file  in $tempdir/digests that contains the signing role and the digests from the current
           deb.

       •   Calls gpg to verify that  the  detached  OpenPGP  signature  in  $tempdir/digests.asc  is  valid  for
           $tempdir/digests.

       Returns if the the signature is good, by an unknown key, or bad.

   <u>$verification_status</u> <b>=</b> <b>verify_deb_sig_v2</b> <b>(</b><u>$part_name</u><b>,</b> <u>$part_number</u><b>,</b> <u><b>\@digests</b></u><b>,</b> <u><b>\@info</b></u><b>,</b> <u><b>\@return</b></u><b>)</b>
       Verifies if $tempdir/digests is a valid (version 2) signature for the deb described with <u>\@digests</u>:

       •   Creates a file in $tempdir/digests that contains the digests from the current deb.

       •   Calls  gpg  to  verify  that  the  detached  OpenPGP  signature  in $tempdir/digests.asc is valid for
           $tempdir/digests.

       Returns if the the signature is good, by an unknown key, or bad.

   <u>$sig_name</u> <b>=</b> <b>get_sig_name</b> <b>(</b><u>$sig_name</u><b>,</b> <u><b>\@parts</b></u><b>,</b> <u>$deb</u><b>)</b>
       Tries to find a filename for the signature. Receives the role and constructs a name not  already  present
       in <u>$deb</u>.

       Returns the final name or dies if it wasn't possible to construct a name.

   <b>correct_changes_file</b> <b>(</b><u>$changes</u><b>,</b> <u><b>\%new_deb_info</b></u><b>)</b>
       Receives  a  path to a changes file <u>$changes</u> and a hash reference <u>\%new_deb_info</u> containing new sizes and
       md5sums of debs in that changes file. It'll parse the changes file, replace the old  values  by  the  new
       ones.  If the file is signed, the signature will be stripped (as it would be invalid anyway).

   <u><b>\@new_file_info</b></u> <b>=</b> <b>add_part_to_ar_archive</b> <b>(</b><u>$file</u><b>,</b> <u>$new_data</u><b>,</b> <u>$new_name</u><b>)</b>
   <u><b>\@new_file_info</b></u> <b>=</b> <b>add_sig_to_deb</b> <b>(</b><u>$file</u><b>,</b> <u>$new_data</u><b>,</b> <u>$new_name</u><b>)</b>
       Adds <u>$new_data</u> to <u>$file</u> as new ar archiv part, using $new_name as filename. If <u>$file</u> doesn't exist, a new
       ar archive is created. Returns the new md5sum and size of <u>$file</u>.

   <u>@parts</u> <b>=</b> <b>get_ar_parts</b> <b>(</b><u>$file</u><b>)</b>
   <u>@parts</u> <b>=</b> <b>get_deb_parts</b> <b>(</b><u>$file</u><b>)</b>
       Parses <u>$file</u> as ar archive and returns all filenames included in the archive.

   <u>@debs</u> <b>=</b> <b>get_debs_from_changes</b> <b>(</b><u>$file</u><b>,</b> <u><b>\$changes_signed</b></u><b>)</b>
       Parses  <u>$file</u>  as  Debian .changes file and returns all listed debs. The dirname of <u>$file</u> is prepended to
       the debs, which means that the returned URIs should exist.  If <u>$file</u> is signed, <u>$changes_signed</u> is set to
       "yes".

   <u><b>\@digests</b></u> <b>=</b> <b>get_deb_digests</b> <b>(</b><u>$deb</u><b>)</b>
       Parses <u>$deb</u> and returns the meta-data of the included files. The  read  data  is  piped  to  md5sums  and
       sha1sums,  which  create  the  respective  digests.  The digests, the filename and the size are put in an
       anymous array looking like this: [<b>$name</b>, <b>$size</b>, <b>$sha1sum</b>, <b>$md5sum</b>].  One of these  arrays  is  pushed  to
       <u>@digests</u> for every file in <u>$deb</u>.

   <u>$md5sum</u> <b>=</b> <b>get_file_md5sum</b> <b>(</b><u>$file</u><b>)</b>
       Returns the md5sum for <u>$file</u>.

   <u>$part_data</u> <b>=</b> <b>get_archive_part</b> <b>(</b><u>$archive</u><b>,</b> <u>$part_name</u><b>)</b>
       Returns the content of <u>$part_name</u> in the ar archive <u>$archive</u>.

   <u>@file_data</u> <b>=</b> <b>read_control_file</b> <b>(</b><u>$file</u><b>)</b>
       Returns the content of <u>$file</u> as array with one line per element.

   <u>@file_info</u> <b>=</b> <b>write_control_file</b> <b>(</b><u>$file</u><b>,</b> <u><b>\@data</b></u><b>)</b>
       Writes contents of <u>\@data</u> to <u>$file</u>. Returns new md5sum and size of <u>$file</u>.

   <u>@files</u> <b>=</b> <b>glob_exp</b> <b>(</b><u>$exp</u><b>)</b>
       Returns the result of globbing <u>$exp</u> as array.

   <u>$file_readable</u> <b>=</b> <b>file_readable</b> <b>(</b><u>$file</u><b>)</b>
       Returns a true value if <u>$file</u> is readable.

   <u>@ssh_uri_parts</u> <b>=</b> <b>split_ssh_uri</b> <b>(</b><u>$uri</u><b>)</b>
       Splits an ssh URI $uri into a <b>$user</b>, <b>$host</b> and <b>$path</b> part.

   <u>@ssh_connection_info</u> <b>=</b> <b>get_ssh_connection</b> <b>(</b><u>$user</u><b>,</b> <u>$host</u><b>)</b>
       Opens  a  ssh connection to <u>$host</u> as user <u>$user</u>, directly calling <b>dpkg-sig</b>. It checks if the remote <b>dpkg-</b>
       <b>sig</b> is compatible to the current version and returns the <b>$pid</b>,  the  Read-Filehandle  <b>$readerfh</b>  and  the
       Write-Filehandle <b>$writerfh</b>.

   <b>sign_control_files</b> <b>(</b><u>$changes_file</u><b>)</b>
       This works like debsign:

       Checks if a .dsc exists.
       If the .dsc should be signed, it tries to do so..
       Writes the new .dsc with the new signature.
       Reads <u>$changes_file</u> and puts in the new size/md5sum of the .dsc.
       Signs <u>$changes_file</u> and write the signed copy back.

   <b>sign_file</b> <b>(</b><u>$in_file</u><b>,</b> <u>$out_file</u><b>,</b> <u>$no_detach</u><b>)</b>
       Signs <u>$in_file</u> with gpg and puts the detached signature in <u>$out_file</u>.

       If <u>$no_detach</u> is true, <u>$out_file</u> is a clearsigned copy of <u>$in_file</u>.

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>dpkg-sig</b>  and  this  manpage  were written by Andreas Barth und Marc Brockschmidt. They are Copyright (C)
       2003, 2004 by them and released under the GNU General Public Licence version 2  or  later;  there  is  NO
       WARRANTY.  See <u>/usr/share/doc/dpkg-sig/copyright</u> and <u><a href="file:/usr/share/common-licenses/GPL">/usr/share/common-licenses/GPL</a></u> for details.

Debian Project                                     2016-12-19                                        <u><a href="../man7/DPKG-SIG.7.html">DPKG-SIG</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>