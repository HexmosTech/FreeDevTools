<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>provider-signature - The signature library <-> provider functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openssl">openssl_3.5.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       provider-signature - The signature library &lt;-&gt; provider functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/core_dispatch.h&gt;
        #include &lt;openssl/core_names.h&gt;

        /*
         * None of these are actual functions, but are displayed like this for
         * the function signatures for functions that are offered as function
         * pointers in OSSL_DISPATCH arrays.
         */

        /* Context management */
        void *OSSL_FUNC_signature_newctx(void *provctx, const char *propq);
        void OSSL_FUNC_signature_freectx(void *ctx);
        void *OSSL_FUNC_signature_dupctx(void *ctx);

        /* Get the key types that a signature algorithm supports */
        const char **OSSL_FUNC_signature_query_key_types(void);

        /* Signing */
        int OSSL_FUNC_signature_sign_init(void *ctx, void *provkey,
                                          const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_sign(void *ctx, unsigned char *sig, size_t *siglen,
                                     size_t sigsize, const unsigned char *tbs, size_t tbslen);
        int OSSL_FUNC_signature_sign_message_init(void *ctx, void *provkey,
                                                  const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_sign_message_update(void *ctx, const unsigned char *in,
                                                    size_t inlen);
        int OSSL_FUNC_signature_sign_message_final(void *ctx, unsigned char *sig,
                                                   size_t *siglen, size_t sigsize);

        /* Verifying */
        int OSSL_FUNC_signature_verify_init(void *ctx, void *provkey,
                                            const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_verify(void *ctx, const unsigned char *sig, size_t siglen,
                                       const unsigned char *tbs, size_t tbslen);
        int OSSL_FUNC_signature_verify_message_init(void *ctx, void *provkey,
                                                    const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_verify_message_update(void *ctx, const unsigned char *in,
                                                      size_t inlen);
        /*
         * OSSL_FUNC_signature_verify_message_final requires that the signature to be
         * verified is specified via a "signature" OSSL_PARAM, which is given with a
         * previous call of OSSL_FUNC_signature_set_ctx_params().
         */
        int OSSL_FUNC_signature_verify_message_final(void *ctx);

        /* Verify Recover */
        int OSSL_FUNC_signature_verify_recover_init(void *ctx, void *provkey,
                                                    const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_verify_recover(void *ctx, unsigned char *rout,
                                               size_t *routlen, size_t routsize,
                                               const unsigned char *sig, size_t siglen);

        /* Digest Sign */
        int OSSL_FUNC_signature_digest_sign_init(void *ctx, const char *mdname,
                                                 void *provkey,
                                                 const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_digest_sign_update(void *ctx, const unsigned char *data,
                                            size_t datalen);
        int OSSL_FUNC_signature_digest_sign_final(void *ctx, unsigned char *sig,
                                                  size_t *siglen, size_t sigsize);
        int OSSL_FUNC_signature_digest_sign(void *ctx,
                                     unsigned char *sig, size_t *siglen,
                                     size_t sigsize, const unsigned char *tbs,
                                     size_t tbslen);

        /* Digest Verify */
        int OSSL_FUNC_signature_digest_verify_init(void *ctx, const char *mdname,
                                                   void *provkey,
                                                   const OSSL_PARAM params[]);
        int OSSL_FUNC_signature_digest_verify_update(void *ctx,
                                                     const unsigned char *data,
                                                     size_t datalen);
        int OSSL_FUNC_signature_digest_verify_final(void *ctx, const unsigned char *sig,
                                             size_t siglen);
        int OSSL_FUNC_signature_digest_verify(void *ctx, const unsigned char *sig,
                                       size_t siglen, const unsigned char *tbs,
                                       size_t tbslen);

        /* Signature parameters */
        int OSSL_FUNC_signature_get_ctx_params(void *ctx, OSSL_PARAM params[]);
        const OSSL_PARAM *OSSL_FUNC_signature_gettable_ctx_params(void *ctx,
                                                                  void *provctx);
        int OSSL_FUNC_signature_set_ctx_params(void *ctx, const OSSL_PARAM params[]);
        const OSSL_PARAM *OSSL_FUNC_signature_settable_ctx_params(void *ctx,
                                                                  void *provctx);
        /* MD parameters */
        int OSSL_FUNC_signature_get_ctx_md_params(void *ctx, OSSL_PARAM params[]);
        const OSSL_PARAM * OSSL_FUNC_signature_gettable_ctx_md_params(void *ctx);
        int OSSL_FUNC_signature_set_ctx_md_params(void *ctx, const OSSL_PARAM params[]);
        const OSSL_PARAM * OSSL_FUNC_signature_settable_ctx_md_params(void *ctx);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This documentation is primarily aimed at provider authors. See <b><a href="../man7/provider.7.html">provider</a></b>(7) for further information.

       The signature (OSSL_OP_SIGNATURE) operation enables providers to implement signature algorithms and make
       them available to applications via the API functions <b><a href="../man3/EVP_PKEY_sign.3.html">EVP_PKEY_sign</a></b>(3), <b><a href="../man3/EVP_PKEY_verify.3.html">EVP_PKEY_verify</a></b>(3), and
       <b><a href="../man3/EVP_PKEY_verify_recover.3.html">EVP_PKEY_verify_recover</a></b>(3) (as well as other related functions).

       All "functions" mentioned here are passed as function pointers between <u>libcrypto</u> and the provider in
       <b><a href="../man3/OSSL_DISPATCH.3.html">OSSL_DISPATCH</a></b>(3) arrays via <b><a href="../man3/OSSL_ALGORITHM.3.html">OSSL_ALGORITHM</a></b>(3) arrays that are returned by the provider's
       <b>provider_query_operation()</b> function (see "Provider Functions" in <b><a href="../man7/provider-base.7.html">provider-base</a></b>(7)).

       All these "functions" have a corresponding function type definition named <b>OSSL_FUNC_{name}_fn</b>, and a
       helper function to retrieve the function pointer from an <b><a href="../man3/OSSL_DISPATCH.3.html">OSSL_DISPATCH</a></b>(3) element named <b>OSSL_FUNC_{name}</b>.
       For example, the "function" <b>OSSL_FUNC_signature_newctx()</b> has these:

        typedef void *(OSSL_FUNC_signature_newctx_fn)(void *provctx, const char *propq);
        static ossl_inline OSSL_FUNC_signature_newctx_fn
            OSSL_FUNC_signature_newctx(const OSSL_DISPATCH *opf);

       <b><a href="../man3/OSSL_DISPATCH.3.html">OSSL_DISPATCH</a></b>(3) arrays are indexed by numbers that are provided as macros in <b><a href="../man7/openssl-core_dispatch.h.7.html">openssl-core_dispatch.h</a></b>(7),
       as follows:

        OSSL_FUNC_signature_newctx                 OSSL_FUNC_SIGNATURE_NEWCTX
        OSSL_FUNC_signature_freectx                OSSL_FUNC_SIGNATURE_FREECTX
        OSSL_FUNC_signature_dupctx                 OSSL_FUNC_SIGNATURE_DUPCTX

        OSSL_FUNC_signature_query_key_types        OSSL_FUNC_SIGNATURE_QUERY_KEY_TYPES

        OSSL_FUNC_signature_sign_init              OSSL_FUNC_SIGNATURE_SIGN_INIT
        OSSL_FUNC_signature_sign                   OSSL_FUNC_SIGNATURE_SIGN
        OSSL_FUNC_signature_sign_message_init      OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_INIT
        OSSL_FUNC_signature_sign_message_update    OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_UPDATE
        OSSL_FUNC_signature_sign_message_final     OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_FINAL

        OSSL_FUNC_signature_verify_init            OSSL_FUNC_SIGNATURE_VERIFY_INIT
        OSSL_FUNC_signature_verify                 OSSL_FUNC_SIGNATURE_VERIFY
        OSSL_FUNC_signature_verify_message_init    OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_INIT
        OSSL_FUNC_signature_verify_message_update  OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_UPDATE
        OSSL_FUNC_signature_verify_message_final   OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_FINAL

        OSSL_FUNC_signature_verify_recover_init    OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT
        OSSL_FUNC_signature_verify_recover         OSSL_FUNC_SIGNATURE_VERIFY_RECOVER

        OSSL_FUNC_signature_digest_sign_init       OSSL_FUNC_SIGNATURE_DIGEST_SIGN_INIT
        OSSL_FUNC_signature_digest_sign_update     OSSL_FUNC_SIGNATURE_DIGEST_SIGN_UPDATE
        OSSL_FUNC_signature_digest_sign_final      OSSL_FUNC_SIGNATURE_DIGEST_SIGN_FINAL
        OSSL_FUNC_signature_digest_sign            OSSL_FUNC_SIGNATURE_DIGEST_SIGN

        OSSL_FUNC_signature_digest_verify_init     OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_INIT
        OSSL_FUNC_signature_digest_verify_update   OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_UPDATE
        OSSL_FUNC_signature_digest_verify_final    OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_FINAL
        OSSL_FUNC_signature_digest_verify          OSSL_FUNC_SIGNATURE_DIGEST_VERIFY

        OSSL_FUNC_signature_get_ctx_params         OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS
        OSSL_FUNC_signature_gettable_ctx_params    OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS
        OSSL_FUNC_signature_set_ctx_params         OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS
        OSSL_FUNC_signature_settable_ctx_params    OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS

        OSSL_FUNC_signature_get_ctx_md_params      OSSL_FUNC_SIGNATURE_GET_CTX_MD_PARAMS
        OSSL_FUNC_signature_gettable_ctx_md_params OSSL_FUNC_SIGNATURE_GETTABLE_CTX_MD_PARAMS
        OSSL_FUNC_signature_set_ctx_md_params      OSSL_FUNC_SIGNATURE_SET_CTX_MD_PARAMS
        OSSL_FUNC_signature_settable_ctx_md_params OSSL_FUNC_SIGNATURE_SETTABLE_CTX_MD_PARAMS

       A signature algorithm implementation may not implement all of these functions.  In order to be a
       consistent set of functions we must have at least a set of context functions (OSSL_FUNC_signature_newctx
       and OSSL_FUNC_signature_freectx) as well as a set of "signature" functions, i.e. at least one of:

       OSSL_FUNC_signature_sign_init and OSSL_FUNC_signature_sign
       OSSL_FUNC_signature_sign_message_init and OSSL_FUNC_signature_sign
       OSSL_FUNC_signature_sign_message_init, OSSL_FUNC_signature_sign_message_update and
       OSSL_FUNC_signature_sign_message_final
       OSSL_FUNC_signature_verify_init and OSSL_FUNC_signature_verify
       OSSL_FUNC_signature_verify_message_init and OSSL_FUNC_signature_verify
       OSSL_FUNC_signature_verify_message_init, OSSL_FUNC_signature_verify_message_update and
       OSSL_FUNC_signature_verify_message_final
       OSSL_FUNC_signature_verify_recover_init and OSSL_FUNC_signature_verify_recover
       OSSL_FUNC_signature_digest_sign_init, OSSL_FUNC_signature_digest_sign_update and
       OSSL_FUNC_signature_digest_sign_final
       OSSL_FUNC_signature_digest_verify_init, OSSL_FUNC_signature_digest_verify_update and
       OSSL_FUNC_signature_digest_verify_final
       OSSL_FUNC_signature_digest_sign_init and OSSL_FUNC_signature_digest_sign
       OSSL_FUNC_signature_digest_verify_init and OSSL_FUNC_signature_digest_verify

       OSSL_FUNC_signature_set_ctx_params  and  OSSL_FUNC_signature_settable_ctx_params are optional, but if one
       of  them  is  present  then   the   other   one   must   also   be   present.   The   same   applies   to
       OSSL_FUNC_signature_get_ctx_params   and   OSSL_FUNC_signature_gettable_ctx_params,   as   well   as  the
       "md_params" functions. The OSSL_FUNC_signature_dupctx function is optional.

       A signature algorithm must also implement some mechanism for generating, loading or  importing  keys  via
       the key management (OSSL_OP_KEYMGMT) operation.  See <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7) for further details.

   <b>Context</b> <b>Management</b> <b>Functions</b>
       <b>OSSL_FUNC_signature_newctx()</b>  should create and return a pointer to a provider side structure for holding
       context information during a signature operation.  A pointer to this context will be  passed  back  in  a
       number  of  the  other signature operation function calls.  The parameter <u>provctx</u> is the provider context
       generated during provider initialisation (see <b><a href="../man7/provider.7.html">provider</a></b>(7)). The  <u>propq</u>  parameter  is  a  property  query
       string  that  may  be  (optionally)  used by the provider during any "fetches" that it may perform (if it
       performs any).

       <b>OSSL_FUNC_signature_freectx()</b> is passed a pointer to the provider  side  signature  context  in  the  <u>ctx</u>
       parameter.  This function should free any resources associated with that context.

       <b>OSSL_FUNC_signature_dupctx()</b>  should  duplicate  the provider side signature context in the <u>ctx</u> parameter
       and return the duplicate copy.

   <b>Signing</b> <b>Functions</b>
       <b>OSSL_FUNC_signature_sign_init()</b> initialises a context for signing given a provider side signature context
       in the <u>ctx</u> parameter, and a pointer to a provider key object in the <u>provkey</u> parameter.   The  <u>params</u>,  if
       not NULL, should be set on the context in a manner similar to using <b>OSSL_FUNC_signature_set_ctx_params()</b>.
       The  key object should have been previously generated, loaded or imported into the provider using the key
       management (OSSL_OP_KEYMGMT) operation (see <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).

       <b>OSSL_FUNC_signature_sign()</b> performs the  actual  signing  itself.   A  previously  initialised  signature
       context  is  passed in the <u>ctx</u> parameter.  The data to be signed is pointed to be the <u>tbs</u> parameter which
       is <u>tbslen</u> bytes long.  Unless <u>sig</u> is NULL, the signature should be written to the location pointed to  by
       the  <u>sig</u>  parameter and it should not exceed <u>sigsize</u> bytes in length.  The length of the signature should
       be written to <u>*siglen</u>.  If <u>sig</u> is NULL then the maximum length of the  signature  should  be  written  to
       <u>*siglen</u>.

   <b>Message</b> <b>Signing</b> <b>Functions</b>
       These  functions  are suitable for providers that implement algorithms that accumulate a full message and
       sign the result of that accumulation, such as RSA-SHA256.

       <b>OSSL_FUNC_signature_sign_message_init()</b> initialises a context for signing a message given a provider side
       signature context in the <u>ctx</u> parameter, and a pointer to a provider key object in the <u>provkey</u>  parameter.
       The   <u>params</u>,   if   not   NULL,   should   be   set  on  the  context  in  a  manner  similar  to  using
       <b>OSSL_FUNC_signature_set_ctx_params()</b>.  The key object should have been previously  generated,  loaded  or
       imported    into   the   provider   using   the   key   management   (OSSL_OP_KEYMGMT)   operation   (see
       <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).

       <b>OSSL_FUNC_signature_sign_message_update()</b> gathers the data pointed at by <u>in</u>, which is <u>inlen</u> bytes long.

       <b>OSSL_FUNC_signature_sign_message_final()</b> performs the actual signing on the data that was  gathered  with
       <b>OSSL_FUNC_signature_sign_message_update()</b>.

       <b>OSSL_FUNC_signature_sign()</b> can be used for one-shot signature calls.  In that case, <u>tbs</u> is expected to be
       the whole message to be signed, <u>tbslen</u> bytes long.

       For both <b>OSSL_FUNC_signature_sign_message_final()</b> and <b>OSSL_FUNC_signature_sign()</b>, if <u>sig</u> is not NULL, the
       signature  should be written to the location pointed to by <u>sig</u>, and it should not exceed <u>sigsize</u> bytes in
       length.  The length of the signature should be written to <u>*siglen</u>.  If  <u>sig</u>  is  NULL  then  the  maximum
       length of the signature should be written to <u>*siglen</u>.

   <b>Verify</b> <b>Functions</b>
       <b>OSSL_FUNC_signature_verify_init()</b>  initialises  a context for verifying a signature given a provider side
       signature context in the <u>ctx</u> parameter, and a pointer to a provider key object in the <u>provkey</u>  parameter.
       The   <u>params</u>,   if   not   NULL,   should   be   set  on  the  context  in  a  manner  similar  to  using
       <b>OSSL_FUNC_signature_set_ctx_params()</b>.  The key object should have been previously  generated,  loaded  or
       imported    into   the   provider   using   the   key   management   (OSSL_OP_KEYMGMT)   operation   (see
       <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).

       <b>OSSL_FUNC_signature_verify()</b> performs the actual verification itself.  A previously initialised signature
       context is passed in the <u>ctx</u> parameter.  The data that the signature covers is  pointed  to  be  the  <u>tbs</u>
       parameter  which  is <u>tbslen</u> bytes long.  The signature is pointed to by the <u>sig</u> parameter which is <u>siglen</u>
       bytes long.

   <b>Message</b> <b>Verify</b> <b>Functions</b>
       These functions are suitable for providers that implement algorithms that accumulate a full  message  and
       verify a signature on the result of that accumulation, such as RSA-SHA256.

       <b>OSSL_FUNC_signature_verify_message_init()</b>  initialises  a  context for verifying a signature on a message
       given a provider side signature context in the <u>ctx</u> parameter, and a pointer to a provider key  object  in
       the  <u>provkey</u>  parameter.   The  <u>params</u>,  if not NULL, should be set on the context in a manner similar to
       using <b>OSSL_FUNC_signature_set_ctx_params()</b>.  The key object should have been previously generated, loaded
       or  imported  into  the  provider   using   the   key   management   (OSSL_OP_KEYMGMT)   operation   (see
       <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).

       <b>OSSL_FUNC_signature_verify_message_update()</b> gathers the data pointed at by <u>in</u>, which is <u>inlen</u> bytes long.

       <b>OSSL_FUNC_signature_verify_message_final()</b> performs the actual verification on the data that was gathered
       with <b>OSSL_FUNC_signature_verify_message_update()</b>.  The signature itself must have been passed through the
       "signature" (<b>OSSL_SIGNATURE_PARAM_SIGNATURE</b>) Signature parameter before this function is called.

       <b>OSSL_FUNC_signature_verify()</b>  can be used for one-shot verification calls.  In that case, <u>tbs</u> is expected
       to be the whole message to be verified on, <u>tbslen</u> bytes long.

   <b>Verify</b> <b>Recover</b> <b>Functions</b>
       <b>OSSL_FUNC_signature_verify_recover_init()</b> initialises a context for recovering the signed  data  given  a
       provider  side  signature  context  in  the  <u>ctx</u> parameter, and a pointer to a provider key object in the
       <u>provkey</u> parameter.  The <u>params</u>, if not NULL, should be set on the context in a manner  similar  to  using
       <b>OSSL_FUNC_signature_set_ctx_params()</b>.   The  key  object should have been previously generated, loaded or
       imported   into   the   provider   using   the   key   management   (OSSL_OP_KEYMGMT)   operation    (see
       <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).

       <b>OSSL_FUNC_signature_verify_recover()</b> performs the actual verify recover itself.  A previously initialised
       signature context is passed in the <u>ctx</u> parameter.  The signature is pointed to by the <u>sig</u> parameter which
       is  <u>siglen</u> bytes long.  Unless <u>rout</u> is NULL, the recovered data should be written to the location pointed
       to by <u>rout</u> which should not exceed <u>routsize</u> bytes in length.  The length of the recovered data should  be
       written  to  <u>*routlen</u>.   If  <u>rout</u>  is  NULL  then the maximum size of the output buffer is written to the
       <u>routlen</u> parameter.

   <b>Digest</b> <b>Sign</b> <b>Functions</b>
       <b>OSSL_FUNC_signature_digest_sign_init()</b> initialises a context for signing given a provider side  signature
       context  in  the  <u>ctx</u>  parameter,  and  a pointer to a provider key object in the <u>provkey</u> parameter.  The
       <u>params</u>,  if  not  NULL,   should   be   set   on   the   context   in   a   manner   similar   to   using
       <b>OSSL_FUNC_signature_set_ctx_params()</b>  and <b>OSSL_FUNC_signature_set_ctx_md_params()</b>.  The key object should
       have been  previously  generated,  loaded  or  imported  into  the  provider  using  the  key  management
       (OSSL_OP_KEYMGMT)  operation (see <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).  The name of the digest to be used will be in the
       <u>mdname</u> parameter.

       <b>OSSL_FUNC_signature_digest_sign_update()</b> provides data to be signed in the <u>data</u> parameter which should be
       of length <u>datalen</u>. A previously initialised signature context  is  passed  in  the  <u>ctx</u>  parameter.  This
       function may be called multiple times to cumulatively add data to be signed.

       <b>OSSL_FUNC_signature_digest_sign_final()</b>  finalises  a  signature  operation  previously  started  through
       <b>OSSL_FUNC_signature_digest_sign_init()</b> and <b>OSSL_FUNC_signature_digest_sign_update()</b> calls. Once finalised
       no more data will be added through  <b>OSSL_FUNC_signature_digest_sign_update()</b>.  A  previously  initialised
       signature  context is passed in the <u>ctx</u> parameter. Unless <u>sig</u> is NULL, the signature should be written to
       the location pointed to by the <u>sig</u> parameter and it should not exceed <u>sigsize</u> bytes in length. The length
       of the signature should be written to <u>*siglen</u>. If <u>sig</u> is NULL then the maximum length  of  the  signature
       should be written to <u>*siglen</u>.

       <b>OSSL_FUNC_signature_digest_sign()</b>  implements  a  "one  shot"  digest  sign  operation previously started
       through <b>OSSL_FUNC_signature_digeset_sign_init()</b>. A previously initialised signature context is passed  in
       the <u>ctx</u> parameter. The data to be signed is in <u>tbs</u> which should be <u>tbslen</u> bytes long. Unless <u>sig</u> is NULL,
       the  signature should be written to the location pointed to by the <u>sig</u> parameter and it should not exceed
       <u>sigsize</u> bytes in length. The length of the signature should be written to <u>*siglen</u>. If <u>sig</u>  is  NULL  then
       the maximum length of the signature should be written to <u>*siglen</u>.

   <b>Digest</b> <b>Verify</b> <b>Functions</b>
       <b>OSSL_FUNC_signature_digeset_verify_init()</b>  initialises  a  context  for  verifying  given a provider side
       verification context in the <u>ctx</u> parameter, and a  pointer  to  a  provider  key  object  in  the  <u>provkey</u>
       parameter.    The  <u>params</u>,  if  not  NULL,  should  be  set  on  the  context  in  a  manner  similar  to
       <b>OSSL_FUNC_signature_set_ctx_params()</b> and <b>OSSL_FUNC_signature_set_ctx_md_params()</b>.  The key object  should
       have  been  previously  generated,  loaded  or  imported  into  the  provider  using  the  key management
       (OSSL_OP_KEYMGMT) operation (see <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)).  The name of the digest to be used will be in  the
       <u>mdname</u> parameter.

       <b>OSSL_FUNC_signature_digest_verify_update()</b>  provides  data  to  be  verified  in the <u>data</u> parameter which
       should be of length <u>datalen</u>.  A  previously  initialised  verification  context  is  passed  in  the  <u>ctx</u>
       parameter. This function may be called multiple times to cumulatively add data to be verified.

       <b>OSSL_FUNC_signature_digest_verify_final()</b>  finalises  a verification operation previously started through
       <b>OSSL_FUNC_signature_digest_verify_init()</b>  and  <b>OSSL_FUNC_signature_digest_verify_update()</b>   calls.   Once
       finalised  no  more  data  will be added through <b>OSSL_FUNC_signature_digest_verify_update()</b>. A previously
       initialised verification context is passed in the <u>ctx</u> parameter. The signature to be verified is  in  <u>sig</u>
       which is <u>siglen</u> bytes long.

       <b>OSSL_FUNC_signature_digest_verify()</b>  implements  a  "one shot" digest verify operation previously started
       through <b>OSSL_FUNC_signature_digeset_verify_init()</b>.  A  previously  initialised  verification  context  is
       passed  in  the  <u>ctx</u>  parameter. The data to be verified is in <u>tbs</u> which should be <u>tbslen</u> bytes long. The
       signature to be verified is in <u>sig</u> which is <u>siglen</u> bytes long.

   <b>Signature</b> <b>parameters</b>
       See   <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3)   for   further   details   on    the    parameters    structure    used    by    the
       <b>OSSL_FUNC_signature_get_ctx_params()</b> and <b>OSSL_FUNC_signature_set_ctx_params()</b> functions.

       <b>OSSL_FUNC_signature_get_ctx_params()</b>  gets  signature  parameters associated with the given provider side
       signature context <u>ctx</u> and stored them in <u>params</u>.  Passing NULL for <u>params</u> should return true.

       <b>OSSL_FUNC_signature_set_ctx_params()</b> sets the signature parameters associated  with  the  given  provider
       side  signature context <u>ctx</u> to <u>params</u>.  Any parameter settings are additional to any that were previously
       set.  Passing NULL for <u>params</u> should return true.

       Common parameters currently recognised by built-in signature algorithms are as follows.

       "digest" (<b>OSSL_SIGNATURE_PARAM_DIGEST</b>) &lt;UTF8 string&gt;
           Get or sets the name of the digest algorithm used for the input to the  signature  functions.  It  is
           required in order to calculate the "algorithm-id".

       "properties" (<b>OSSL_SIGNATURE_PARAM_PROPERTIES</b>) &lt;UTF8 string&gt;
           Sets  the  name  of  the property query associated with the "digest" algorithm.  NULL is used if this
           optional value is not set.

       Note that when implementing a signature algorithm that gathers  a  full  message,  like  RSA-SHA256,  the
       "digest"  and  "properties"  parameters should not be used.  For such implementations, it's acceptable to
       simply ignore them if they happen to be passed in a call  to  <b>OSSL_FUNC_signature_set_ctx_params()</b>.   For
       such  implementations, however, it is not acceptable to have them in the <b>OSSL_PARAM</b> array that's returned
       by <b>OSSL_FUNC_signature_settable_ctx_params()</b>.

       "signature" (<b>OSSL_SIGNATURE_PARAM_SIGNATURE</b>) &lt;octet string&gt;
           Sets the signature to verify, specifically when <b>OSSL_FUNC_signature_verify_message_final()</b> is used.

       "digest-size" (<b>OSSL_SIGNATURE_PARAM_DIGEST_SIZE</b>) &lt;unsigned integer&gt;
           Gets or sets the output size of the digest algorithm used for the input to the  signature  functions.
           The length of the "digest-size" parameter should not exceed that of a <b>size_t</b>.

       "algorithm-id" (<b>OSSL_SIGNATURE_PARAM_ALGORITHM_ID</b>) &lt;octet string&gt;
           Gets  the  DER encoded AlgorithmIdentifier that corresponds to the combination of signature algorithm
           and digest algorithm for the signature operation.

       "nonce-type" (<b>OSSL_SIGNATURE_PARAM_NONCE_TYPE</b>) &lt;unsigned integer&gt;
           Set this to 1 to use deterministic digital signature generation with ECDSA or DSA, as defined in  RFC
           6979  (see  Section  3.2 "Generation of k").  In this case, the "digest" parameter must be explicitly
           set (otherwise, deterministic nonce  generation  will  fail).   Before  using  deterministic  digital
           signature  generation,  please  read RFC 6979 Section 4 "Security Considerations".  The default value
           for "nonce-type" is 0 and results in a random value being used for the nonce <b>k</b>  as  defined  in  FIPS
           186-4 Section 6.3 "Secret Number Generation".

           The FIPS provider does not support deterministic digital signature generation.

       "kat" (<b>OSSL_SIGNATURE_PARAM_KAT</b>) &lt;unsigned integer&gt;
           Sets  a  flag  to modify the sign operation to return an error if the initial calculated signature is
           invalid.  In the normal mode of operation  -  new  random  values  are  chosen  until  the  signature
           operation  succeeds.   By default it retries until a signature is calculated.  Setting the value to 0
           causes the sign operation to retry, otherwise the sign operation  is  only  tried  once  and  returns
           whether  or  not  it  was successful.  Known answer tests can be performed if the random generator is
           overridden to supply known values that either pass or fail.

       The following parameters are used by the OpenSSL FIPS provider:

       "fips-indicator" (<b>OSSL_SIGNATURE_PARAM_FIPS_APPROVED_INDICATOR</b>) &lt;integer&gt;
           A getter that returns 1 if the operation is FIPS approved, or 0 otherwise.  This may  be  used  after
           calling  either  the  sign  or  verify final functions. It may return 0 if either the "digest-check",
           "key-check", or "sign-check" are set to 0.

       "verify-message" (<b>OSSL_SIGNATURE_PARAM_FIPS_VERIFY_MESSAGE</b> &lt;integer&gt;
           A getter that returns 1 if a signature verification operation acted on a raw  message,  or  0  if  it
           verified  a  predigested  message.   A  value  of  0  indicates likely non-approved usage of the FIPS
           provider.  This flag is set when any signature verification initialisation function is called.  It is
           also set to 1 when any signing operation is performed to signify compliance.  See FIPS 140-3 IG 2.4.B
           for further information.

       "key-check" (<b>OSSL_SIGNATURE_PARAM_FIPS_KEY_CHECK</b>) &lt;integer&gt;
           If   required   this   parameter   should   be   set   early   via    an    init    function    (e.g.
           <b>OSSL_FUNC_signature_sign_init()</b> or <b>OSSL_FUNC_signature_verify_init()</b>).  The default value of 1 causes
           an  error  during  the  init if the key is not FIPS approved (e.g. The key has a security strength of
           less than 112 bits).  Setting this to 0 will ignore the error and set the approved "indicator" to  0.
           This option breaks FIPS compliance if it causes the approved "fips-indicator" to return 0.

       "digest-check" (<b>OSSL_SIGNATURE_PARAM_FIPS_DIGEST_CHECK</b>) &lt;integer&gt;
           If  required this parameter should be set before the signature digest is set.  The default value of 1
           causes an error when the digest is set if the digest is not FIPS approved  (e.g.  SHA1  is  used  for
           signing).  Setting  this to 0 will ignore the error and set the approved "fips-indicator" to 0.  This
           option breaks FIPS compliance if it causes the approved "fips-indicator" to return 0.

       "sign-check" (<b>OSSL_SIGNATURE_PARAM_FIPS_SIGN_CHECK</b>) &lt;integer&gt;
           If required this parameter should be set early via an init function.  The default value of  1  causes
           an  error  when  a  signing  algorithm is used. (This is triggered by deprecated signing algorithms).
           Setting this to 0 will ignore the error and set the approved  "fips-indicator"  to  0.   This  option
           breaks FIPS compliance if it causes the approved "fips-indicator" to return 0.

       "sign-x931-pad-check" (<b>OSSL_SIGNATURE_PARAM_FIPS_SIGN_X931_PAD_CHECK</b>) &lt;integer&gt;
           If  required  this  parameter  should  be set before the padding mode is set.  The default value of 1
           causes an error if the padding mode is set to X9.31 padding for a RSA signing operation. Setting this
           to 0 will ignore the error and set the approved "fips-indicator"  to  0.   This  option  breaks  FIPS
           compliance if it causes the approved "fips-indicator" to return 0.

       <b>OSSL_FUNC_signature_gettable_ctx_params()</b>  and  <b>OSSL_FUNC_signature_settable_ctx_params()</b>  get a constant
       <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array that describes the gettable and settable parameters, i.e. parameters that can be used
       with <b>OSSL_FUNC_signature_get_ctx_params()</b> and <b>OSSL_FUNC_signature_set_ctx_params()</b> respectively.

   <b>MD</b> <b>parameters</b>
       See   <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3)   for   further   details   on    the    parameters    structure    used    by    the
       <b>OSSL_FUNC_signature_get_md_ctx_params()</b> and <b>OSSL_FUNC_signature_set_md_ctx_params()</b> functions.

       <b>OSSL_FUNC_signature_get_md_ctx_params()</b>  gets  digest  parameters associated with the given provider side
       digest signature context <u>ctx</u> and stores them in <u>params</u>.  Passing NULL for <u>params</u> should return true.

       <b>OSSL_FUNC_signature_set_ms_ctx_params()</b> sets the digest parameters associated  with  the  given  provider
       side  digest  signature  context  <u>ctx</u>  to <u>params</u>.  Any parameter settings are additional to any that were
       previously set.  Passing NULL for <u>params</u> should return true.

       Parameters currently recognised by built-in signature algorithms are  the  same  as  those  for  built-in
       digest algorithms. See "Digest Parameters" in <b><a href="../man7/provider-digest.7.html">provider-digest</a></b>(7) for further information.

       <b>OSSL_FUNC_signature_gettable_md_ctx_params()</b>   and   <b>OSSL_FUNC_signature_settable_md_ctx_params()</b>  get  a
       constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array that describes the gettable and settable digest parameters, i.e.  parameters
       that can be used with <b>OSSL_FUNC_signature_get_md_ctx_params()</b> and <b>OSSL_FUNC_signature_set_md_ctx_params()</b>
       respectively.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_FUNC_signature_newctx()</b>  and  <b>OSSL_FUNC_signature_dupctx()</b>  should return the newly created provider
       side signature context, or NULL on failure.

       <b>OSSL_FUNC_signature_gettable_ctx_params()</b>,                     <b>OSSL_FUNC_signature_settable_ctx_params()</b>,
       <b>OSSL_FUNC_signature_gettable_md_ctx_params()</b> and <b>OSSL_FUNC_signature_settable_md_ctx_params()</b>, return the
       gettable or settable parameters in a constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array.

       All other functions should return 1 for success or 0 on error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/provider.7.html">provider</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The  provider  SIGNATURE  interface  was  introduced  in  OpenSSL  3.0.   The Signature Parameters "fips-
       indicator", "key-check" and "digest-check" were added in OpenSSL 3.4.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2019-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                           <u><a href="../man7SSL/PROVIDER-SIGNATURE.7SSL.html">PROVIDER-SIGNATURE</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>