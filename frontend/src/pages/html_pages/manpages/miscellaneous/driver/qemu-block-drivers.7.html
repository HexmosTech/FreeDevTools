<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>qemu-block-drivers - QEMU block drivers reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/qemu-utils">qemu-utils_10.0.2+ds-1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       qemu-block-drivers - QEMU block drivers reference

</pre><h4><b>SYNOPSIS</b></h4><pre>
       QEMU block driver reference manual

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Disk</b> <b>image</b> <b>file</b> <b>formats</b>
       QEMU  supports  many  image file formats that can be used with VMs as well as with any of the tools (like
       <b>qemu-img</b>). This includes the preferred formats raw and qcow2 as well as formats that  are  supported  for
       compatibility with older QEMU versions or other hypervisors.

       Depending  on  the  image format, different options can be passed to <b>qemu-img</b> <b>create</b> and <b>qemu-img</b> <b>convert</b>
       using the <b>-o</b> option.  This section describes each format and the options that are supported for it.

       <b>raw</b>    Raw disk image format. This format has the advantage of being simple and easily exportable to  all
              other  emulators. If your file system supports <u>holes</u> (for example in ext2 or ext3 on Linux or NTFS
              on Windows), then only the written sectors will reserve space. Use <b>qemu-img</b> <b>info</b> to know the  real
              size used by the image or <b>ls</b> <b>-ls</b> on Unix/Linux.

              Supported options:

              <b>preallocation</b>
                     Preallocation  mode (allowed values: <b>off</b>, <b>falloc</b>, <b>full</b>). <b>falloc</b> mode preallocates space for
                     image by calling <b>posix_fallocate()</b>. <b>full</b> mode preallocates space for image by writing  data
                     to underlying storage. This data may or may not be zero, depending on the storage location.

       <b>qcow2</b>  QEMU  image  format,  the  most  versatile  format.  Use it to have smaller images (useful if your
              filesystem does not supports holes, for example on Windows), zlib based compression and support of
              multiple VM snapshots.

              Supported options:

              <b>compat</b> Determines the qcow2 version to use. <b>compat=0.10</b> uses the traditional image format that can
                     be read by any QEMU since 0.10.  <b>compat=1.1</b> enables image format extensions that only  QEMU
                     1.1  and  newer  understand  (this  is  the  default).  Amongst  others, this includes zero
                     clusters, which allow efficient copy-on-read for sparse images.

              <b>backing_file</b>
                     File name of a base image (see <b>create</b> subcommand)

              <b>backing_fmt</b>
                     Image format of the base image

              <b>encryption</b>
                     This option is deprecated and equivalent to <b>encrypt.format=aes</b>

              <b>encrypt.format</b>
                     If this is set to <b>luks</b>, it requests that the qcow2 payload (not qcow2 header) be  encrypted
                     using  the  LUKS  format. The passphrase to use to unlock the LUKS key slot is given by the
                     <b>encrypt.key-secret</b> parameter. LUKS encryption  parameters  can  be  tuned  with  the  other
                     <b>encrypt.*</b> parameters.

                     If  this is set to <b>aes</b>, the image is encrypted with 128-bit AES-CBC.  The encryption key is
                     given by the <b>encrypt.key-secret</b> parameter.  This encryption  format  is  considered  to  be
                     flawed by modern cryptography standards, suffering from a number of design problems:

                     • The  AES-CBC  cipher  is used with predictable initialization vectors based on the sector
                       number. This makes it vulnerable  to  chosen  plaintext  attacks  which  can  reveal  the
                       existence of encrypted data.

                     • The  user  passphrase  is  directly  used as the encryption key. A poorly chosen or short
                       passphrase will compromise the security of the encryption.

                     • In the event of the passphrase being compromised there is no way to change the passphrase
                       to protect data in any  qcow  images.  The  files  must  be  cloned,  using  a  different
                       encryption  passphrase  in  the  new file. The original file must then be securely erased
                       using a program like shred, though even this is  ineffective  with  many  modern  storage
                       technologies.

                     The  use  of  this  is no longer supported in system emulators. Support only remains in the
                     command line utilities, for the purposes of data liberation and interoperability  with  old
                     versions of QEMU. The <b>luks</b> format should be used instead.

              <b>encrypt.key-secret</b>
                     Provides  the  ID  of a <b>secret</b> object that contains the passphrase (<b>encrypt.format=luks</b>) or
                     encryption key (<b>encrypt.format=aes</b>).

              <b>encrypt.cipher-alg</b>
                     Name of the cipher algorithm and key length. Currently defaults to <b>aes-256</b>. Only used  when
                     <b>encrypt.format=luks</b>.

              <b>encrypt.cipher-mode</b>
                     Name  of  the  encryption  mode  to  use.  Currently  defaults  to  <b>xts</b>.   Only  used  when
                     <b>encrypt.format=luks</b>.

              <b>encrypt.ivgen-alg</b>
                     Name of the initialization vector generator algorithm. Currently defaults to <b>plain64</b>.  Only
                     used when <b>encrypt.format=luks</b>.

              <b>encrypt.ivgen-hash-alg</b>
                     Name  of  the hash algorithm to use with the initialization vector generator (if required).
                     Defaults to <b>sha256</b>. Only used when <b>encrypt.format=luks</b>.

              <b>encrypt.hash-alg</b>
                     Name of the hash algorithm to use for PBKDF algorithm Defaults to <b>sha256</b>.  Only  used  when
                     <b>encrypt.format=luks</b>.

              <b>encrypt.iter-time</b>
                     Amount  of  time,  in  milliseconds,  to use for PBKDF algorithm per key slot.  Defaults to
                     <b>2000</b>. Only used when <b>encrypt.format=luks</b>.

              <b>cluster_size</b>
                     Changes the qcow2 cluster size (must be between 512 and  2M).  Smaller  cluster  sizes  can
                     improve  the  image  file  size  whereas  larger  cluster  sizes  generally  provide better
                     performance.

              <b>preallocation</b>
                     Preallocation  mode  (allowed  values:  <b>off</b>,  <b>metadata</b>,  <b>falloc</b>,  <b>full</b>).  An   image   with
                     preallocated  metadata is initially larger but can improve performance when the image needs
                     to grow. <b>falloc</b> and <b>full</b> preallocations are like the same options of <b>raw</b> format,  but  sets
                     up metadata also.

              <b>lazy_refcounts</b>
                     If  this  option  is  set  to  <b>on</b>,  reference  count updates are postponed with the goal of
                     avoiding metadata I/O and improving performance.  This  is  particularly  interesting  with
                     <b>cache=writethrough</b>  which doesn't batch metadata updates. The tradeoff is that after a host
                     crash, the reference count tables must be rebuilt, i.e. on the  next  open  an  (automatic)
                     <b>qemu-img</b> <b>check</b> <b>-r</b> <b>all</b> is required, which may take some time.

                     This option can only be enabled if <b>compat=1.1</b> is specified.

              <b>nocow</b>  If this option is set to <b>on</b>, it will turn off COW of the file. It's only valid on btrfs, no
                     effect on other file systems.

                     Btrfs  has low performance when hosting a VM image file, even more when the guest on the VM
                     also using btrfs as file system. Turning off COW is a way to mitigate this bad performance.
                     Generally there are two ways to turn off COW on btrfs:

                     • Disable it by mounting with nodatacow, then all newly created files will be NOCOW.

                     • For an empty file, add the NOCOW file attribute. That's what this option does.

                     Note: this option is only valid to new or empty files. If there is an existing  file  which
                     is  COW  and  has data blocks already, it couldn't be changed to NOCOW by setting <b>nocow=on</b>.
                     One can issue <b>lsattr</b> <b>filename</b> to check if the NOCOW flag is set  or  not  (Capital  'C'  is
                     NOCOW flag).

       <b>qed</b>    Old QEMU image format with support for backing files and compact image files (when your filesystem
              or transport medium does not support holes).

              When converting QED images to qcow2, you might want to consider using the <b>lazy_refcounts=on</b> option
              to get a more QED-like behaviour.

              Supported options:

              <b>backing_file</b>
                     File name of a base image (see <b>create</b> subcommand).

              <b>backing_fmt</b>
                     Image  file format of backing file (optional).  Useful if the format cannot be autodetected
                     because it has no header, like some vhd/vpc files.

              <b>cluster_size</b>
                     Changes the cluster size (must be power-of-2 between 4K and 64K). Smaller cluster sizes can
                     improve the  image  file  size  whereas  larger  cluster  sizes  generally  provide  better
                     performance.

              <b>table_size</b>
                     Changes  the  number  of  clusters  per  L1/L2 table (must be power-of-2 between 1 and 16).
                     There is normally no need to change this  value  but  this  option  can  between  used  for
                     performance benchmarking.

       <b>qcow</b>   Old  QEMU  image  format  with  support  for  backing  files,  compact image files, encryption and
              compression.

              Supported options:

                 <b>backing_file</b>
                        File name of a base image (see <b>create</b> subcommand)

                 <b>encryption</b>
                        This option is deprecated and equivalent to <b>encrypt.format=aes</b>

                 <b>encrypt.format</b>
                        If this is set to <b>aes</b>, the image is encrypted with 128-bit AES-CBC.  The encryption  key
                        is  given  by the <b>encrypt.key-secret</b> parameter.  This encryption format is considered to
                        be flawed by modern cryptography standards, suffering from a number of  design  problems
                        enumerated previously against the <b>qcow2</b> image format.

                        The  use of this is no longer supported in system emulators. Support only remains in the
                        command line utilities, for the purposes of data liberation  and  interoperability  with
                        old versions of QEMU.

                        Users   requiring   native   encryption   should  use  the  <b>qcow2</b>  format  instead  with
                        <b>encrypt.format=luks</b>.

                 <b>encrypt.key-secret</b>
                        Provides  the   ID   of   a   <b>secret</b>   object   that   contains   the   encryption   key
                        (<b>encrypt.format=aes</b>).

       <b>luks</b>   LUKS v1 encryption format, compatible with Linux dm-crypt/cryptsetup

              Supported options:

              <b>key-secret</b>
                     Provides the ID of a <b>secret</b> object that contains the passphrase.

              <b>cipher-alg</b>
                     Name of the cipher algorithm and key length. Currently defaults to <b>aes-256</b>.

              <b>cipher-mode</b>
                     Name of the encryption mode to use. Currently defaults to <b>xts</b>.

              <b>ivgen-alg</b>
                     Name of the initialization vector generator algorithm. Currently defaults to <b>plain64</b>.

              <b>ivgen-hash-alg</b>
                     Name  of  the hash algorithm to use with the initialization vector generator (if required).
                     Defaults to <b>sha256</b>.

              <b>hash-alg</b>
                     Name of the hash algorithm to use for PBKDF algorithm Defaults to <b>sha256</b>.

              <b>iter-time</b>
                     Amount of time, in milliseconds, to use for PBKDF algorithm  per  key  slot.   Defaults  to
                     <b>2000</b>.

       <b>vdi</b>    VirtualBox 1.1 compatible image format.

              Supported options:

              <b>static</b> If this option is set to <b>on</b>, the image is created with metadata preallocation.

       <b>vmdk</b>   VMware 3 and 4 compatible image format.

              Supported options:

              <b>backing_file</b>
                     File name of a base image (see <b>create</b> subcommand).

              <b>compat6</b>
                     Create a VMDK version 6 image (instead of version 4)

              <b>hwversion</b>
                     Specify  vmdk  virtual  hardware  version.  Compat6  flag cannot be enabled if hwversion is
                     specified.

              <b>subformat</b>
                     Specifies which VMDK subformat  to  use.  Valid  options  are  <b>monolithicSparse</b>  (default),
                     <b>monolithicFlat</b>, <b>twoGbMaxExtentSparse</b>, <b>twoGbMaxExtentFlat</b> and <b>streamOptimized</b>.

       <b>vpc</b>    VirtualPC compatible image format (VHD).

              Supported options:

              <b>subformat</b>
                     Specifies which VHD subformat to use. Valid options are <b>dynamic</b> (default) and <b>fixed</b>.

       <b>VHDX</b>   Hyper-V compatible image format (VHDX).

              Supported options:

              <b>subformat</b>
                     Specifies which VHDX subformat to use. Valid options are <b>dynamic</b> (default) and <b>fixed</b>.

                     <b>block_state_zero</b>
                            Force  use  of  payload  blocks  of type 'ZERO'.  Can be set to <b>on</b> (default) or <b>off</b>.
                            When set to <b>off</b>, new blocks will  be  created  as  <b>PAYLOAD_BLOCK_NOT_PRESENT</b>,  which
                            means parsers are free to return arbitrary data for those blocks.  Do not set to <b>off</b>
                            when using <b>qemu-img</b> <b>convert</b> with <b>subformat=dynamic</b>.

                     <b>block_size</b>
                            Block size; min 1 MB, max 256 MB.  0 means auto-calculate based on image size.

                     <b>log_size</b>
                            Log size; min 1 MB.

   <b>Read-only</b> <b>formats</b>
       More disk image file formats are supported in a read-only mode.

       <b>bochs</b>  Bochs images of <b>growing</b> type.

       <b>cloop</b>  Linux  Compressed  Loop  image, useful only to reuse directly compressed CD-ROM images present for
              example in the Knoppix CD-ROMs.

       <b>dmg</b>    Apple disk image.

       <b>parallels</b>
              Parallels disk image format.

   <b>Using</b> <b>host</b> <b>drives</b>
       In addition to disk image files, QEMU can directly access host devices. We describe here  the  usage  for
       QEMU version &gt;= 0.8.3.

   <b>Linux</b>
       On  Linux,  you  can  directly use the host device filename instead of a disk image filename provided you
       have enough privileges to access it. For example, use <b>/dev/cdrom</b> to access to the CDROM.

       <b>CD</b>     You can specify a CDROM device even if no CDROM is loaded. QEMU has specific code to detect  CDROM
              insertion  or  removal.  CDROM  ejection by the guest OS is supported. Currently only data CDs are
              supported.

       <b>Floppy</b> You can specify a floppy device even if no floppy is  loaded.  Floppy  removal  is  currently  not
              detected  accurately  (if  you  change  floppy without doing floppy access while the floppy is not
              loaded, the guest OS will think that the same floppy is loaded).  Use of the host's floppy  device
              is deprecated, and support for it will be removed in a future release.

       <b>Hard</b> <b>disks</b>
              Hard  disks  can be used. Normally you must specify the whole disk (<b>/dev/hdb</b> instead of <b>/dev/hdb1</b>)
              so that the guest OS can see it as a partitioned disk. WARNING: unless you know what you do, it is
              better to only make READ-ONLY accesses to the hard disk otherwise you may corrupt your  host  data
              (use the <b>-snapshot</b> command line option or modify the device permissions accordingly).

       <b>Zoned</b> <b>block</b> <b>devices</b>
              Zoned block devices can be passed through to the guest if the emulated storage controller supports
              zoned  storage.  Use <b>--blockdev</b> <b>host_device,</b> <b>node-name=drive0,filename=/dev/nullb0,cache.direct=on</b>
              to pass through <b>/dev/nullb0</b> as <b>drive0</b>.

   <b>Windows</b>
       <b>CD</b>     The preferred syntax is the drive letter (e.g. <b>d:</b>). The  alternate  syntax  <b>\\.\d:</b>  is  supported.
              <b>/dev/cdrom</b> is supported as an alias to the first CDROM drive.

              Currently  there  is no specific code to handle removable media, so it is better to use the <b>change</b>
              or <b>eject</b> monitor commands to change or eject media.

       <b>Hard</b> <b>disks</b>
              Hard disks can be used with the syntax: <b>\\.\PhysicalDriveN</b> where <u>N</u> is the drive number (0  is  the
              first hard disk).

              WARNING:  unless  you  know  what you do, it is better to only make READ-ONLY accesses to the hard
              disk otherwise you may corrupt your host  data  (use  the  <b>-snapshot</b>  command  line  so  that  the
              modifications are written in a temporary file).

   <b>Mac</b> <b>OS</b> <b>X</b>
       <b>/dev/cdrom</b> is an alias to the first CDROM.

       Currently there is no specific code to handle removable media, so it is better to use the <b>change</b> or <b>eject</b>
       monitor commands to change or eject media.

   <b>Virtual</b> <b>FAT</b> <b>disk</b> <b>images</b>
       QEMU  can  automatically  create a virtual FAT disk image from a directory tree. In order to use it, just
       type:

          qemu-system-x86_64 linux.img -hdb fat:/my_directory

       Then you access access to all the files in the <b>/my_directory</b> directory without having to copy them  in  a
       disk image or to export them via SAMBA or NFS. The default access is <u>read-only</u>.

       Floppies can be emulated with the <b>:floppy:</b> option:

          qemu-system-x86_64 linux.img -fda fat:floppy:/my_directory

       A read/write support is available for testing (beta stage) with the <b>:rw:</b> option:

          qemu-system-x86_64 linux.img -fda fat:floppy:rw:/my_directory

       What you should <u>never</u> do:

       • use non-ASCII filenames

       • use "-snapshot" together with ":rw:"

       • expect it to work when loadvm'ing

       • write to the FAT directory on the host system while accessing it with the guest system

   <b>NBD</b> <b>access</b>
       QEMU can access directly to block device exported using the Network Block Device protocol.

          qemu-system-x86_64 linux.img -hdb nbd://my_nbd_server.mydomain.org:1024/

       If the NBD server is located on the same host, you can use an unix socket instead of an inet socket:

          qemu-system-x86_64 linux.img -hdb nbd+unix://?socket=/tmp/my_socket

       In this case, the block device must be exported using <b>qemu-nbd</b>:

          qemu-nbd --socket=/tmp/my_socket my_disk.qcow2

       The use of <b>qemu-nbd</b> allows sharing of a disk between several guests:

          qemu-nbd --socket=/tmp/my_socket --share=2 my_disk.qcow2

       and then you can use it with two guests:

          qemu-system-x86_64 linux1.img -hdb nbd+unix://?socket=/tmp/my_socket
          qemu-system-x86_64 linux2.img -hdb nbd+unix://?socket=/tmp/my_socket

       If  the  <b>nbd-server</b>  uses  named  exports  (supported  since  NBD 2.9.18, or with QEMU's own embedded NBD
       server), you must specify an export name in the URI:

          qemu-system-x86_64 -cdrom nbd://localhost/debian-500-ppc-netinst
          qemu-system-x86_64 -cdrom nbd://localhost/openSUSE-11.1-ppc-netinst

       The URI syntax for NBD is supported since QEMU 1.3.  An alternative syntax is also available.   Here  are
       some example of the older syntax:

          qemu-system-x86_64 linux.img -hdb nbd:my_nbd_server.mydomain.org:1024
          qemu-system-x86_64 linux2.img -hdb nbd:unix:/tmp/my_socket
          qemu-system-x86_64 -cdrom nbd:localhost:10809:exportname=debian-500-ppc-netinst

   <b>iSCSI</b> <b>LUNs</b>
       iSCSI is a popular protocol used to access SCSI devices across a computer network.

       There are two different ways iSCSI devices can be used by QEMU.

       The  first  method  is  to mount the iSCSI LUN on the host, and make it appear as any other ordinary SCSI
       device on the host and then to access this device as a /dev/sd device from QEMU. How to do  this  differs
       between host OSes.

       The  second  method involves using the iSCSI initiator that is built into QEMU. This provides a mechanism
       that works the same way regardless of which host OS you are running QEMU on. This section  will  describe
       this second method of using iSCSI together with QEMU.

       In QEMU, iSCSI devices are described using special iSCSI URLs. URL syntax:

          iscsi://[&lt;username&gt;[%&lt;password&gt;]@]&lt;host&gt;[:&lt;port&gt;]/&lt;target-iqn-name&gt;/&lt;lun&gt;

       Username  and  password are optional and only used if your target is set up using CHAP authentication for
       access control.  Alternatively the username and password can also be set  via  environment  variables  to
       have these not show up in the process list:

          export LIBISCSI_CHAP_USERNAME=&lt;username&gt;
          export LIBISCSI_CHAP_PASSWORD=&lt;password&gt;
          iscsi://&lt;host&gt;/&lt;target-iqn-name&gt;/&lt;lun&gt;

       Various  session  related  parameters  can  be  set  via  special options, either in a configuration file
       provided via '-readconfig' or directly on the command line.

       If   the    initiator-name    is    not    specified    qemu    will    use    a    default    name    of
       'iqn.2008-11.org.linux-kvm[:&lt;uuid&gt;']  where &lt;uuid&gt; is the UUID of the virtual machine. If the UUID is not
       specified qemu will use 'iqn.2008-11.org.linux-kvm[:&lt;name&gt;'] where &lt;name&gt; is  the  name  of  the  virtual
       machine.

       Setting a specific initiator name to use when logging in to the target:

          -iscsi initiator-name=iqn.qemu.test:my-initiator

       Controlling which type of header digest to negotiate with the target:

          -iscsi header-digest=CRC32C|CRC32C-NONE|NONE-CRC32C|NONE

       These can also be set via a configuration file:

          [iscsi]
            user = "CHAP username"
            password = "CHAP password"
            initiator-name = "iqn.qemu.test:my-initiator"
            # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
            header-digest = "CRC32C"

       Setting the target name allows different options for different targets:

          [iscsi "iqn.target.name"]
            user = "CHAP username"
            password = "CHAP password"
            initiator-name = "iqn.qemu.test:my-initiator"
            # header digest is one of CRC32C|CRC32C-NONE|NONE-CRC32C|NONE
            header-digest = "CRC32C"

       How to use a configuration file to set iSCSI configuration options:

          cat &gt;iscsi.conf &lt;&lt;EOF
          [iscsi]
            user = "me"
            password = "my password"
            initiator-name = "iqn.qemu.test:my-initiator"
            header-digest = "CRC32C"
          EOF

          qemu-system-x86_64 -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \
            -readconfig iscsi.conf

       How  to set up a simple iSCSI target on loopback and access it via QEMU: this example shows how to set up
       an iSCSI target with one CDROM and one DISK  using  the  Linux  STGT  software  target.  This  target  is
       available on Red Hat based systems as the package 'scsi-target-utils'.

          tgtd --iscsi portal=127.0.0.1:3260
          tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.qemu.test
          tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 \
              -b /IMAGES/disk.img --device-type=disk
          tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 2 \
              -b /IMAGES/cd.iso --device-type=cd
          tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL

          qemu-system-x86_64 -iscsi initiator-name=iqn.qemu.test:my-initiator \
            -boot d -drive file=iscsi://127.0.0.1/iqn.qemu.test/1 \
            -cdrom iscsi://127.0.0.1/iqn.qemu.test/2

   <b>GlusterFS</b> <b>disk</b> <b>images</b>
       GlusterFS is a user space distributed file system.

       You can boot from the GlusterFS disk image with the command:

       URI:

          qemu-system-x86_64 -drive file=gluster[+TYPE]://[HOST}[:PORT]]/VOLUME/PATH
                                       [?socket=...][,file.debug=9][,file.logfile=...]

       JSON:

          qemu-system-x86_64 'json:{"driver":"qcow2",
                                   "file":{"driver":"gluster",
                                            "volume":"testvol","path":"a.img","debug":9,"logfile":"...",
                                            "server":[{"type":"tcp","host":"...","port":"..."},
                                                      {"type":"unix","socket":"..."}]}}'

       <u>gluster</u> is the protocol.

       <u>TYPE</u>  specifies  the  transport  type  used  to  connect  to  gluster management daemon (glusterd). Valid
       transport types are tcp and unix. In the URI form, if a transport type isn't specified, then tcp type  is
       assumed.

       <u>HOST</u>  specifies  the server where the volume file specification for the given volume resides. This can be
       either a hostname or an ipv4 address.  If  transport  type  is  unix,  then  <u>HOST</u>  field  should  not  be
       specified.  Instead <u>socket</u> field needs to be populated with the path to unix domain socket.

       <u>PORT</u>  is  the  port  number  on  which  glusterd  is listening. This is optional and if not specified, it
       defaults to port 24007. If the transport type is unix, then <u>PORT</u> should not be specified.

       <u>VOLUME</u> is the name of the gluster volume which contains the disk image.

       <u>PATH</u> is the path to the actual disk image that resides on gluster volume.

       <u>debug</u> is the logging level of the gluster protocol driver. Debug levels are 0-9, with 9  being  the  most
       verbose,  and  0  representing  no  debugging output.  The default level is 4. The current logging levels
       defined in the gluster source are 0 - None, 1 - Emergency, 2 - Alert, 3  -  Critical,  4  -  Error,  5  -
       Warning, 6 - Notice, 7 - Info, 8 - Debug, 9 - Trace

       <u>logfile</u> is a commandline option to mention log file path which helps in logging to the specified file and
       also help in persisting the gfapi logs. The default is stderr.

       You can create a GlusterFS disk image with the command:

          qemu-img create gluster://HOST/VOLUME/PATH SIZE

       Examples

          qemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img
          qemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4/testvol/a.img
          qemu-system-x86_64 -drive file=gluster+tcp://1.2.3.4:24007/testvol/dir/a.img
          qemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]/testvol/dir/a.img
          qemu-system-x86_64 -drive file=gluster+tcp://[1:2:3:4:5:6:7:8]:24007/testvol/dir/a.img
          qemu-system-x86_64 -drive file=gluster+tcp://server.domain.com:24007/testvol/dir/a.img
          qemu-system-x86_64 -drive file=gluster+unix:///testvol/dir/a.img?socket=/tmp/glusterd.socket
          qemu-system-x86_64 -drive file=gluster://1.2.3.4/testvol/a.img,file.debug=9,file.logfile=/var/log/qemu-gluster.log
          qemu-system-x86_64 'json:{"driver":"qcow2",
                                   "file":{"driver":"gluster",
                                            "volume":"testvol","path":"a.img",
                                            "debug":9,"logfile":"/var/log/qemu-gluster.log",
                                            "server":[{"type":"tcp","host":"1.2.3.4","port":24007},
                                                      {"type":"unix","socket":"/var/run/glusterd.socket"}]}}'
          qemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
                                               file.debug=9,file.logfile=/var/log/qemu-gluster.log,
                                               file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
                                               file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket

   <b>Secure</b> <b>Shell</b> <b>(ssh)</b> <b>disk</b> <b>images</b>
       You can access disk images located on a remote ssh server by using the ssh protocol:

          qemu-system-x86_64 -drive file=ssh://[USER@]SERVER[:PORT]/PATH[?host_key_check=HOST_KEY_CHECK]

       Alternative syntax using properties:

          qemu-system-x86_64 -drive file.driver=ssh[,file.user=USER],file.host=SERVER[,file.port=PORT],file.path=PATH[,file.host_key_check=HOST_KEY_CHECK]

       <u>ssh</u> is the protocol.

       <u>USER</u> is the remote user.  If not specified, then the local username is tried.

       <u>SERVER</u>  specifies  the  remote  ssh  server.   Any  ssh  server  can  be  used, but it must implement the
       sftp-server protocol.  Most Unix/Linux systems should work without requiring any extra configuration.

       <u>PORT</u> is the port number on which sshd is listening.  By default the standard ssh port (22) is used.

       <u>PATH</u> is the path to the disk image.

       The optional <u>HOST_KEY_CHECK</u> parameter controls how the remote host's key is checked.  The default is  <b>yes</b>
       which  means  to use the local <b>.ssh/known_hosts</b> file.  Setting this to <b>no</b> turns off known-hosts checking.
       Or you can check that the host key matches a specific fingerprint. The fingerprint  can  be  provided  in
       <b>md5</b>,  <b>sha1</b>,  or  <b>sha256</b>  format,  however, it is strongly recommended to only use <b>sha256</b>, since the other
       options are considered insecure by modern standards. The fingerprint value must be given as a hex encoded
       string:

          host_key_check=sha256:04ce2ae89ff4295a6b9c4111640bdcb3297858ee55cb434d9dd88796e93aa795

       The key string may optionally contain ":" separators between each pair of hex digits.

       The <b>$HOME/.ssh/known_hosts</b> file contains the base64 encoded host keys. These can be  converted  into  the
       format needed for QEMU using a command such as:

          $ for key in `grep 10.33.8.112 known_hosts | awk '{print $3}'`
            do
              echo $key | base64 -d | sha256sum
            done
            6c3aa525beda9dc83eadfbd7e5ba7d976ecb59575d1633c87cd06ed2ed6e366f  -
            12214fd9ea5b408086f98ecccd9958609bd9ac7c0ea316734006bc7818b45dc8  -
            d36420137bcbd101209ef70c3b15dc07362fbe0fa53c5b135eba6e6afa82f0ce  -

       Note that there can be multiple keys present per host, each with different key ciphers. Care is needed to
       pick the key fingerprint that matches the cipher QEMU will negotiate with the remote server.

       Currently  authentication must be done using ssh-agent.  Other authentication methods may be supported in
       future.

       Note: Many ssh servers do not support an <b>fsync</b>-style operation.  The ssh  driver  cannot  guarantee  that
       disk flush requests are obeyed, and this causes a risk of disk corruption if the remote server or network
       goes down during writes.  The driver will print a warning when <b>fsync</b> is not supported:

          warning: ssh server ssh.example.com:22 does not support fsync

       With sufficiently new versions of libssh and OpenSSH, <b>fsync</b> is supported.

   <b>NVMe</b> <b>disk</b> <b>images</b>
       NVM  Express  (NVMe)  storage  controllers  can be accessed directly by a userspace driver in QEMU.  This
       bypasses the host kernel file system and block layers while retaining QEMU block  layer  functionalities,
       such  as  block  jobs, I/O throttling, image formats, etc.  Disk I/O performance is typically higher than
       with <b>-drive</b> <b>file=/dev/sda</b> using either thread pool or linux-aio.

       The controller will be exclusively used by the QEMU process once started. To be  able  to  share  storage
       between multiple VMs and other applications on the host, please use the file based protocols.

       Before starting QEMU, bind the host NVMe controller to the host vfio-pci driver.  For example:

          # modprobe vfio-pci
          # lspci -n -s 0000:06:0d.0
          06:0d.0 0401: 1102:0002 (rev 08)
          # echo 0000:06:0d.0 &gt; /sys/bus/pci/devices/0000:06:0d.0/driver/unbind
          # echo 1102 0002 &gt; /sys/bus/pci/drivers/vfio-pci/new_id

          # qemu-system-x86_64 -drive file=nvme://HOST:BUS:SLOT.FUNC/NAMESPACE

       Alternative syntax using properties:

          qemu-system-x86_64 -drive file.driver=nvme,file.device=HOST:BUS:SLOT.FUNC,file.namespace=NAMESPACE

       <u>HOST</u>:<u>BUS</u>:<u>SLOT</u>.<u>FUNC</u> is the NVMe controller's PCI device address on the host.

       <u>NAMESPACE</u> is the NVMe namespace number, starting from 1.

   <b>Disk</b> <b>image</b> <b>file</b> <b>locking</b>
       By  default,  QEMU  tries  to  protect  image  files  from  unexpected concurrent access, as long as it's
       supported by the block protocol driver and host operating system. If multiple QEMU  processes  (including
       QEMU  emulators  and  utilities) try to open the same image with conflicting accessing modes, all but the
       first one will get an error.

       This feature is currently supported by the file protocol on Linux with the  Open  File  Descriptor  (OFD)
       locking  API, and can be configured to fall back to POSIX locking if the POSIX host doesn't support Linux
       OFD locking.

       To explicitly enable image locking, specify "locking=on" in the file  protocol  driver  options.  If  OFD
       locking  is  not possible, a warning will be printed and the POSIX locking API will be used. In this case
       there is a risk that the lock will get silently lost when doing hot plugging and block jobs, due  to  the
       shortcomings of the POSIX locking API.

       QEMU transparently handles lock handover during shared storage migration.  For shared virtual disk images
       between multiple VMs, the "share-rw" device option should be used.

       By  default,  the  guest  has exclusive write access to its disk image. If the guest can safely share the
       disk image with other writers the <b>-device</b> <b>...,share-rw=on</b> parameter can be used.  This is  only  safe  if
       the  guest  is  running  software, such as a cluster file system, that coordinates disk accesses to avoid
       corruption.

       Note that share-rw=on only declares the guest's ability to share the disk.  Some QEMU features,  such  as
       image  file  formats,  require  exclusive  write  access  to the disk image and this is unaffected by the
       share-rw=on option.

       Alternatively, locking can be fully disabled by "locking=off" block device option. In the  command  line,
       the  option  is  usually in the form of "file.locking=off" as the protocol driver is normally placed as a
       "file" child under a format driver. For example:

          -blockdev driver=qcow2,file.filename=/path/to/image,file.locking=off,file.driver=file

       To check if image locking is active, check the output of the "lslocks" command on host and see  if  there
       are  locks  held  by  the QEMU process on the image file.  More than one byte could be locked by the QEMU
       instance, each byte of which reflects a particular permission  that  is  acquired  or  protected  by  the
       running block driver.

   <b>Filter</b> <b>drivers</b>
       QEMU  supports  several  filter  drivers,  which don't store any data, but perform some additional tasks,
       hooking io requests.

       <b>preallocate</b>
              The preallocate filter driver is intended to be inserted between format  and  protocol  nodes  and
              preallocates some additional space (expanding the protocol file) when writing past the file’s end.
              This can be useful for file-systems with slow allocation.

              Supported options:

              <b>prealloc-align</b>
                     On preallocation, align the file length to this value (in bytes), default 1M.

              <b>prealloc-size</b>
                     How much to preallocate (in bytes), default 128M.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The HTML documentation of QEMU for more precise information and Linux user mode emulator invocation.

</pre><h4><b>AUTHOR</b></h4><pre>
       Fabrice Bellard and the QEMU Project developers

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2025, The QEMU Project Developers

10.0.2                                            Jul 02, 2025                             <u><a href="../man7/QEMU-BLOCK-DRIVERS.7.html">QEMU-BLOCK-DRIVERS</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>