<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COPY - copy data between a file and a table</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/postgresql-client-17">postgresql-client-17_17.5-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       COPY - copy data between a file and a table

</pre><h4><b>SYNOPSIS</b></h4><pre>
       COPY <u>table_name</u> [ ( <u>column_name</u> [, ...] ) ]
           FROM { '<u>filename</u>' | PROGRAM '<u>command</u>' | STDIN }
           [ [ WITH ] ( <u>option</u> [, ...] ) ]
           [ WHERE <u>condition</u> ]

       COPY { <u>table_name</u> [ ( <u>column_name</u> [, ...] ) ] | ( <u>query</u> ) }
           TO { '<u>filename</u>' | PROGRAM '<u>command</u>' | STDOUT }
           [ [ WITH ] ( <u>option</u> [, ...] ) ]

       where <u>option</u> can be one of:

           FORMAT <u>format_name</u>
           FREEZE [ <u>boolean</u> ]
           DELIMITER '<u>delimiter_character</u>'
           NULL '<u>null_string</u>'
           DEFAULT '<u>default_string</u>'
           HEADER [ <u>boolean</u> | MATCH ]
           QUOTE '<u>quote_character</u>'
           ESCAPE '<u>escape_character</u>'
           FORCE_QUOTE { ( <u>column_name</u> [, ...] ) | * }
           FORCE_NOT_NULL { ( <u>column_name</u> [, ...] ) | * }
           FORCE_NULL { ( <u>column_name</u> [, ...] ) | * }
           ON_ERROR <u>error_action</u>
           ENCODING '<u>encoding_name</u>'
           LOG_VERBOSITY <u>verbosity</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>COPY</b> moves data between PostgreSQL tables and standard file-system files.  <b>COPY</b> <b>TO</b> copies the contents of
       a table <u>to</u> a file, while <b>COPY</b> <b>FROM</b> copies data <u>from</u> a file to a table (appending the data to whatever is
       in the table already).  <b>COPY</b> <b>TO</b> can also copy the results of a <b>SELECT</b> query.

       If a column list is specified, <b>COPY</b> <b>TO</b> copies only the data in the specified columns to the file. For
       <b>COPY</b> <b>FROM</b>, each field in the file is inserted, in order, into the specified column. Table columns not
       specified in the <b>COPY</b> <b>FROM</b> column list will receive their default values.

       <b>COPY</b> with a file name instructs the PostgreSQL server to directly read from or write to a file. The file
       must be accessible by the PostgreSQL user (the user ID the server runs as) and the name must be specified
       from the viewpoint of the server. When PROGRAM is specified, the server executes the given command and
       reads from the standard output of the program, or writes to the standard input of the program. The
       command must be specified from the viewpoint of the server, and be executable by the PostgreSQL user.
       When STDIN or STDOUT is specified, data is transmitted via the connection between the client and the
       server.

       Each backend running <b>COPY</b> will report its progress in the pg_stat_progress_copy view. See Section 27.4.3
       for details.

       By default, <b>COPY</b> will fail if it encounters an error during processing. For use cases where a best-effort
       attempt at loading the entire file is desired, the ON_ERROR clause can be used to specify some other
       behavior.

</pre><h4><b>PARAMETERS</b></h4><pre>
       <u>table_name</u>
           The name (optionally schema-qualified) of an existing table.

       <u>column_name</u>
           An optional list of columns to be copied. If no column list is specified, all columns of the table
           except generated columns will be copied.

       <u>query</u>
           A <b>SELECT</b>, <b>VALUES</b>, <b>INSERT</b>, <b>UPDATE</b>, <b>DELETE</b>, or <b>MERGE</b> command whose results are to be copied. Note that
           parentheses are required around the query.

           For <b>INSERT</b>, <b>UPDATE</b>, <b>DELETE</b>, and <b>MERGE</b> queries a RETURNING clause must be provided, and the target
           relation must not have a conditional rule, nor an ALSO rule, nor an INSTEAD rule that expands to
           multiple statements.

       <u>filename</u>
           The path name of the input or output file. An input file name can be an absolute or relative path,
           but an output file name must be an absolute path. Windows users might need to use an E'' string and
           double any backslashes used in the path name.

       PROGRAM
           A command to execute. In <b>COPY</b> <b>FROM</b>, the input is read from standard output of the command, and in
           <b>COPY</b> <b>TO</b>, the output is written to the standard input of the command.

           Note that the command is invoked by the shell, so if you need to pass any arguments that come from an
           untrusted source, you must be careful to strip or escape any special characters that might have a
           special meaning for the shell. For security reasons, it is best to use a fixed command string, or at
           least avoid including any user input in it.

       STDIN
           Specifies that input comes from the client application.

       STDOUT
           Specifies that output goes to the client application.

       <u>boolean</u>
           Specifies whether the selected option should be turned on or off. You can write TRUE, ON, or 1 to
           enable the option, and FALSE, OFF, or 0 to disable it. The <u>boolean</u> value can also be omitted, in
           which case TRUE is assumed.

       FORMAT
           Selects the data format to be read or written: text, csv (Comma Separated Values), or binary. The
           default is text.

       FREEZE
           Requests copying the data with rows already frozen, just as they would be after running the <b>VACUUM</b>
           <b>FREEZE</b> command. This is intended as a performance option for initial data loading. Rows will be
           frozen only if the table being loaded has been created or truncated in the current subtransaction,
           there are no cursors open and there are no older snapshots held by this transaction. It is currently
           not possible to perform a <b>COPY</b> <b>FREEZE</b> on a partitioned table. This option is only allowed in <b>COPY</b>
           <b>FROM</b>.

           Note that all other sessions will immediately be able to see the data once it has been successfully
           loaded. This violates the normal rules of MVCC visibility and users should be aware of the potential
           problems this might cause.

       DELIMITER
           Specifies the character that separates columns within each row (line) of the file. The default is a
           tab character in text format, a comma in CSV format. This must be a single one-byte character. This
           option is not allowed when using binary format.

       NULL
           Specifies the string that represents a null value. The default is \N (backslash-N) in text format,
           and an unquoted empty string in CSV format. You might prefer an empty string even in text format for
           cases where you don't want to distinguish nulls from empty strings. This option is not allowed when
           using binary format.

               <b>Note</b>
               When using <b>COPY</b> <b>FROM</b>, any data item that matches this string will be stored as a null value, so
               you should make sure that you use the same string as you used with <b>COPY</b> <b>TO</b>.

       DEFAULT
           Specifies the string that represents a default value. Each time the string is found in the input
           file, the default value of the corresponding column will be used. This option is allowed only in <b>COPY</b>
           <b>FROM</b>, and only when not using binary format.

       HEADER
           Specifies that the file contains a header line with the names of each column in the file. On output,
           the first line contains the column names from the table. On input, the first line is discarded when
           this option is set to true (or equivalent Boolean value). If this option is set to MATCH, the number
           and names of the columns in the header line must match the actual column names of the table, in
           order; otherwise an error is raised. This option is not allowed when using binary format. The MATCH
           option is only valid for <b>COPY</b> <b>FROM</b> commands.

       QUOTE
           Specifies the quoting character to be used when a data value is quoted. The default is double-quote.
           This must be a single one-byte character. This option is allowed only when using CSV format.

       ESCAPE
           Specifies the character that should appear before a data character that matches the QUOTE value. The
           default is the same as the QUOTE value (so that the quoting character is doubled if it appears in the
           data). This must be a single one-byte character. This option is allowed only when using CSV format.

       FORCE_QUOTE
           Forces quoting to be used for all non-NULL values in each specified column.  NULL output is never
           quoted. If * is specified, non-NULL values will be quoted in all columns. This option is allowed only
           in <b>COPY</b> <b>TO</b>, and only when using CSV format.

       FORCE_NOT_NULL
           Do not match the specified columns' values against the null string. In the default case where the
           null string is empty, this means that empty values will be read as zero-length strings rather than
           nulls, even when they are not quoted. If * is specified, the option will be applied to all columns.
           This option is allowed only in <b>COPY</b> <b>FROM</b>, and only when using CSV format.

       FORCE_NULL
           Match the specified columns' values against the null string, even if it has been quoted, and if a
           match is found set the value to NULL. In the default case where the null string is empty, this
           converts a quoted empty string into NULL. If * is specified, the option will be applied to all
           columns. This option is allowed only in <b>COPY</b> <b>FROM</b>, and only when using CSV format.

       ON_ERROR
           Specifies how to behave when encountering an error converting a column's input value into its data
           type. An <u>error_action</u> value of stop means fail the command, while ignore means discard the input row
           and continue with the next one. The default is stop.

           The ignore option is applicable only for <b>COPY</b> <b>FROM</b> when the FORMAT is text or csv.

           A NOTICE message containing the ignored row count is emitted at the end of the <b>COPY</b> <b>FROM</b> if at least
           one row was discarded. When LOG_VERBOSITY option is set to verbose, a NOTICE message containing the
           line of the input file and the column name whose input conversion has failed is emitted for each
           discarded row.

       ENCODING
           Specifies that the file is encoded in the <u>encoding_name</u>. If this option is omitted, the current
           client encoding is used. See the Notes below for more details.

       LOG_VERBOSITY
           Specify the amount of messages emitted by a <b>COPY</b> command: default or verbose. If verbose is
           specified, additional messages are emitted during processing.

           This is currently used in <b>COPY</b> <b>FROM</b> command when ON_ERROR option is set to ignore.

       WHERE
           The optional WHERE clause has the general form

               WHERE <u>condition</u>

           where <u>condition</u> is any expression that evaluates to a result of type boolean. Any row that does not
           satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns
           true when the actual row values are substituted for any variable references.

           Currently, subqueries are not allowed in WHERE expressions, and the evaluation does not see any
           changes made by the <b>COPY</b> itself (this matters when the expression contains calls to VOLATILE
           functions).

</pre><h4><b>OUTPUTS</b></h4><pre>
       On successful completion, a <b>COPY</b> command returns a command tag of the form

           COPY <u>count</u>

       The <u>count</u> is the number of rows copied.

           <b>Note</b>

           psql will print this command tag only if the command was not COPY ... TO STDOUT, or the equivalent
           psql meta-command \copy ... to stdout. This is to prevent confusing the command tag with the data
           that was just printed.

</pre><h4><b>NOTES</b></h4><pre>
       <b>COPY</b> <b>TO</b> can be used only with plain tables, not views, and does not copy rows from child tables or child
       partitions. For example, COPY <u>table</u> TO copies the same rows as SELECT * FROM ONLY <u>table</u>. The syntax COPY
       (SELECT * FROM <u>table</u>) TO ...  can be used to dump all of the rows in an inheritance hierarchy,
       partitioned table, or view.

       <b>COPY</b> <b>FROM</b> can be used with plain, foreign, or partitioned tables or with views that have INSTEAD OF
       INSERT triggers.

       You must have select privilege on the table whose values are read by <b>COPY</b> <b>TO</b>, and insert privilege on the
       table into which values are inserted by <b>COPY</b> <b>FROM</b>. It is sufficient to have column privileges on the
       column(s) listed in the command.

       If row-level security is enabled for the table, the relevant <b>SELECT</b> policies will apply to COPY <u>table</u> TO
       statements. Currently, <b>COPY</b> <b>FROM</b> is not supported for tables with row-level security. Use equivalent
       <b>INSERT</b> statements instead.

       Files named in a <b>COPY</b> command are read or written directly by the server, not by the client application.
       Therefore, they must reside on or be accessible to the database server machine, not the client. They must
       be accessible to and readable or writable by the PostgreSQL user (the user ID the server runs as), not
       the client. Similarly, the command specified with PROGRAM is executed directly by the server, not by the
       client application, must be executable by the PostgreSQL user.  <b>COPY</b> naming a file or command is only
       allowed to database superusers or users who are granted one of the roles pg_read_server_files,
       pg_write_server_files, or pg_execute_server_program, since it allows reading or writing any file or
       running a program that the server has privileges to access.

       Do not confuse <b>COPY</b> with the psql instruction <b>\copy</b>.  <b>\copy</b> invokes <b>COPY</b> <b>FROM</b> <b>STDIN</b> or <b>COPY</b> <b>TO</b> <b>STDOUT</b>,
       and then fetches/stores the data in a file accessible to the psql client. Thus, file accessibility and
       access rights depend on the client rather than the server when <b>\copy</b> is used.

       It is recommended that the file name used in <b>COPY</b> always be specified as an absolute path. This is
       enforced by the server in the case of <b>COPY</b> <b>TO</b>, but for <b>COPY</b> <b>FROM</b> you do have the option of reading from a
       file specified by a relative path. The path will be interpreted relative to the working directory of the
       server process (normally the cluster's data directory), not the client's working directory.

       Executing a command with PROGRAM might be restricted by the operating system's access control mechanisms,
       such as SELinux.

       <b>COPY</b> <b>FROM</b> will invoke any triggers and check constraints on the destination table. However, it will not
       invoke rules.

       For identity columns, the <b>COPY</b> <b>FROM</b> command will always write the column values provided in the input
       data, like the <b>INSERT</b> option OVERRIDING SYSTEM VALUE.

       <b>COPY</b> input and output is affected by <u>DateStyle</u>. To ensure portability to other PostgreSQL installations
       that might use non-default <u>DateStyle</u> settings, <u>DateStyle</u> should be set to ISO before using <b>COPY</b> <b>TO</b>. It is
       also a good idea to avoid dumping data with <u>IntervalStyle</u> set to sql_standard, because negative interval
       values might be misinterpreted by a server that has a different setting for <u>IntervalStyle</u>.

       Input data is interpreted according to ENCODING option or the current client encoding, and output data is
       encoded in ENCODING or the current client encoding, even if the data does not pass through the client but
       is read from or written to a file directly by the server.

       The <b>COPY</b> <b>FROM</b> command physically inserts input rows into the table as it progresses. If the command
       fails, these rows are left in a deleted state; these rows will not be visible, but still occupy disk
       space. This might amount to considerable wasted disk space if the failure happened well into a large copy
       operation.  <b>VACUUM</b> should be used to recover the wasted space.

       FORCE_NULL and FORCE_NOT_NULL can be used simultaneously on the same column. This results in converting
       quoted null strings to null values and unquoted null strings to empty strings.

</pre><h4><b>FILE</b> <b>FORMATS</b></h4><pre>
   <b>Text</b> <b>Format</b>
       When the text format is used, the data read or written is a text file with one line per table row.
       Columns in a row are separated by the delimiter character. The column values themselves are strings
       generated by the output function, or acceptable to the input function, of each attribute's data type. The
       specified null string is used in place of columns that are null.  <b>COPY</b> <b>FROM</b> will raise an error if any
       line of the input file contains more or fewer columns than are expected.

       End of data can be represented by a single line containing just backslash-period (\.). An end-of-data
       marker is not necessary when reading from a file, since the end of file serves perfectly well; it is
       needed only when copying data to or from client applications using pre-3.0 client protocol.

       Backslash characters (\) can be used in the <b>COPY</b> data to quote data characters that might otherwise be
       taken as row or column delimiters. In particular, the following characters <u>must</u> be preceded by a
       backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the
       current delimiter character.

       The specified null string is sent by <b>COPY</b> <b>TO</b> without adding any backslashes; conversely, <b>COPY</b> <b>FROM</b>
       matches the input against the null string before removing backslashes. Therefore, a null string such as
       \N cannot be confused with the actual data value \N (which would be represented as \\N).

       The following special backslash sequences are recognized by <b>COPY</b> <b>FROM</b>:
       ┌──────────┬────────────────────────────────────┐
       │ <b>Sequence</b> │ <b>Represents</b>                         │
       ├──────────┼────────────────────────────────────┤
       │ \b       │ Backspace (ASCII 8)                │
       ├──────────┼────────────────────────────────────┤
       │ \f       │ Form feed (ASCII 12)               │
       ├──────────┼────────────────────────────────────┤
       │ \n       │ Newline (ASCII 10)                 │
       ├──────────┼────────────────────────────────────┤
       │ \r       │ Carriage return (ASCII 13)         │
       ├──────────┼────────────────────────────────────┤
       │ \t       │ Tab (ASCII 9)                      │
       ├──────────┼────────────────────────────────────┤
       │ \v       │ Vertical tab (ASCII 11)            │
       ├──────────┼────────────────────────────────────┤
       │ \<u>digits</u>  │ Backslash followed by one to three │
       │          │ octal digits specifies             │
       │          │        the byte with that numeric  │
       │          │ code                               │
       ├──────────┼────────────────────────────────────┤
       │ \x<u>digits</u> │ Backslash x followed by one or two │
       │          │ hex digits specifies               │
       │          │        the byte with that numeric  │
       │          │ code                               │
       └──────────┴────────────────────────────────────┘

       Presently, <b>COPY</b> <b>TO</b> will never emit an octal or hex-digits backslash sequence, but it does use the other
       sequences listed above for those control characters.

       Any other backslashed character that is not mentioned in the above table will be taken to represent
       itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a
       string matching the end-of-data marker (\.) or the null string (\N by default). These strings will be
       recognized before any other backslash processing is done.

       It is strongly recommended that applications generating <b>COPY</b> data convert data newlines and carriage
       returns to the \n and \r sequences respectively. At present it is possible to represent a data carriage
       return by a backslash and carriage return, and to represent a data newline by a backslash and newline.
       However, these representations might not be accepted in future releases. They are also highly vulnerable
       to corruption if the <b>COPY</b> file is transferred across different machines (for example, from Unix to
       Windows or vice versa).

       All backslash sequences are interpreted after encoding conversion. The bytes specified with the octal and
       hex-digit backslash sequences must form valid characters in the database encoding.

       <b>COPY</b> <b>TO</b> will terminate each row with a Unix-style newline (“\n”). Servers running on Microsoft Windows
       instead output carriage return/newline (“\r\n”), but only for <b>COPY</b> to a server file; for consistency
       across platforms, <b>COPY</b> <b>TO</b> <b>STDOUT</b> always sends “\n” regardless of server platform.  <b>COPY</b> <b>FROM</b> can handle
       lines ending with newlines, carriage returns, or carriage return/newlines. To reduce the risk of error
       due to un-backslashed newlines or carriage returns that were meant as data, <b>COPY</b> <b>FROM</b> will complain if
       the line endings in the input are not all alike.

   <b>CSV</b> <b>Format</b>
       This format option is used for importing and exporting the Comma Separated Value (CSV) file format used
       by many other programs, such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard
       text format, it produces and recognizes the common CSV escaping mechanism.

       The values in each record are separated by the DELIMITER character. If the value contains the delimiter
       character, the QUOTE character, the NULL string, a carriage return, or line feed character, then the
       whole value is prefixed and suffixed by the QUOTE character, and any occurrence within the value of a
       QUOTE character or the ESCAPE character is preceded by the escape character. You can also use FORCE_QUOTE
       to force quotes when outputting non-NULL values in specific columns.

       The CSV format has no standard way to distinguish a NULL value from an empty string.  PostgreSQL's <b>COPY</b>
       handles this by quoting. A NULL is output as the NULL parameter string and is not quoted, while a
       non-NULL value matching the NULL parameter string is quoted. For example, with the default settings, a
       NULL is written as an unquoted empty string, while an empty string data value is written with double
       quotes (""). Reading values follows similar rules. You can use FORCE_NOT_NULL to prevent NULL input
       comparisons for specific columns. You can also use FORCE_NULL to convert quoted null string data values
       to NULL.

       Because backslash is not a special character in the CSV format, \., the end-of-data marker, could also
       appear as a data value. To avoid any misinterpretation, a \.  data value appearing as a lone entry on a
       line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data
       marker. If you are loading a file created by another application that has a single unquoted column and
       might have a value of \., you might need to quote that value in the input file.

           <b>Note</b>

           In CSV format, all characters are significant. A quoted value surrounded by white space, or any
           characters other than DELIMITER, will include those characters. This can cause errors if you import
           data from a system that pads CSV lines with white space out to some fixed width. If such a situation
           arises you might need to preprocess the CSV file to remove the trailing white space, before importing
           the data into PostgreSQL.

           <b>Note</b>

           CSV format will both recognize and produce CSV files with quoted values containing embedded carriage
           returns and line feeds. Thus the files are not strictly one line per table row like text-format
           files.

           <b>Note</b>

           Many programs produce strange and occasionally perverse CSV files, so the file format is more a
           convention than a standard. Thus you might encounter some files that cannot be imported using this
           mechanism, and <b>COPY</b> might produce files that other programs cannot process.

   <b>Binary</b> <b>Format</b>
       The binary format option causes all data to be stored/read as binary format rather than as text. It is
       somewhat faster than the text and CSV formats, but a binary-format file is less portable across machine
       architectures and PostgreSQL versions. Also, the binary format is very data type specific; for example it
       will not work to output binary data from a smallint column and read it into an integer column, even
       though that would work fine in text format.

       The binary file format consists of a file header, zero or more tuples containing the row data, and a file
       trailer. Headers and data are in network byte order.

           <b>Note</b>

           PostgreSQL releases before 7.4 used a different binary file format.

       <b>File</b> <b>Header</b>

           The file header consists of 15 bytes of fixed fields, followed by a variable-length header extension
           area. The fixed fields are:

           Signature
               11-byte sequence PGCOPY\n\377\r\n\0 — note that the zero byte is a required part of the
               signature. (The signature is designed to allow easy identification of files that have been munged
               by a non-8-bit-clean transfer. This signature will be changed by end-of-line-translation filters,
               dropped zero bytes, dropped high bits, or parity changes.)

           Flags field
               32-bit integer bit mask to denote important aspects of the file format. Bits are numbered from 0
               (LSB) to 31 (MSB). Note that this field is stored in network byte order (most significant byte
               first), as are all the integer fields used in the file format. Bits 16–31 are reserved to denote
               critical file format issues; a reader should abort if it finds an unexpected bit set in this
               range. Bits 0–15 are reserved to signal backwards-compatible format issues; a reader should
               simply ignore any unexpected bits set in this range. Currently only one flag bit is defined, and
               the rest must be zero:

               Bit 16
                   If 1, OIDs are included in the data; if 0, not. Oid system columns are not supported in
                   PostgreSQL anymore, but the format still contains the indicator.

           Header extension area length
               32-bit integer, length in bytes of remainder of header, not including self. Currently, this is
               zero, and the first tuple follows immediately. Future changes to the format might allow
               additional data to be present in the header. A reader should silently skip over any header
               extension data it does not know what to do with.

           The header extension area is envisioned to contain a sequence of self-identifying chunks. The flags
           field is not intended to tell readers what is in the extension area. Specific design of header
           extension contents is left for a later release.

           This design allows for both backwards-compatible header additions (add header extension chunks, or
           set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal
           such changes, and add supporting data to the extension area if needed).

       <b>Tuples</b>

           Each tuple begins with a 16-bit integer count of the number of fields in the tuple. (Presently, all
           tuples in a table will have the same count, but that might not always be true.) Then, repeated for
           each field in the tuple, there is a 32-bit length word followed by that many bytes of field data.
           (The length word does not include itself, and can be zero.) As a special case, -1 indicates a NULL
           field value. No value bytes follow in the NULL case.

           There is no alignment padding or any other extra data between fields.

           Presently, all data values in a binary-format file are assumed to be in binary format (format code
           one). It is anticipated that a future extension might add a header field that allows per-column
           format codes to be specified.

           To determine the appropriate binary format for the actual tuple data you should consult the
           PostgreSQL source, in particular the <b>*send</b> and <b>*recv</b> functions for each column's data type (typically
           these functions are found in the src/backend/utils/adt/ directory of the source distribution).

           If OIDs are included in the file, the OID field immediately follows the field-count word. It is a
           normal field except that it's not included in the field-count. Note that oid system columns are not
           supported in current versions of PostgreSQL.

       <b>File</b> <b>Trailer</b>

           The file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a
           tuple's field-count word.

           A reader should report an error if a field-count word is neither -1 nor the expected number of
           columns. This provides an extra check against somehow getting out of sync with the data.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example copies a table to the client using the vertical bar (|) as the field delimiter:

           COPY country TO STDOUT (DELIMITER '|');

       To copy data from a file into the country table:

           COPY country FROM '/usr1/proj/bray/sql/country_data';

       To copy into a file just the countries whose names start with 'A':

           COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';

       To copy into a compressed file, you can pipe the output through an external compression program:

           COPY country TO PROGRAM 'gzip &gt; /usr1/proj/bray/sql/country_data.gz';

       Here is a sample of data suitable for copying into a table from STDIN:

           AF      AFGHANISTAN
           AL      ALBANIA
           DZ      ALGERIA
           ZM      ZAMBIA
           ZW      ZIMBABWE

       Note that the white space on each line is actually a tab character.

       The following is the same data, output in binary format. The data is shown after filtering through the
       Unix utility <b>od</b> <b>-c</b>. The table has three columns; the first has type <a href="../man2/char.2.html">char</a>(2), the second has type text,
       and the third has type integer. All the rows have a null value in the third column.

           0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
           0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
           0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
           0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
           0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
           0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
           0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
           0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
           0000200   M   B   A   B   W   E 377 377 377 377 377 377

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       There is no <b>COPY</b> statement in the SQL standard.

       The following syntax was used before PostgreSQL version 9.0 and is still supported:

           COPY <u>table_name</u> [ ( <u>column_name</u> [, ...] ) ]
               FROM { '<u>filename</u>' | STDIN }
               [ [ WITH ]
                     [ BINARY ]
                     [ DELIMITER [ AS ] '<u>delimiter_character</u>' ]
                     [ NULL [ AS ] '<u>null_string</u>' ]
                     [ CSV [ HEADER ]
                           [ QUOTE [ AS ] '<u>quote_character</u>' ]
                           [ ESCAPE [ AS ] '<u>escape_character</u>' ]
                           [ FORCE NOT NULL <u>column_name</u> [, ...] ] ] ]

           COPY { <u>table_name</u> [ ( <u>column_name</u> [, ...] ) ] | ( <u>query</u> ) }
               TO { '<u>filename</u>' | STDOUT }
               [ [ WITH ]
                     [ BINARY ]
                     [ DELIMITER [ AS ] '<u>delimiter_character</u>' ]
                     [ NULL [ AS ] '<u>null_string</u>' ]
                     [ CSV [ HEADER ]
                           [ QUOTE [ AS ] '<u>quote_character</u>' ]
                           [ ESCAPE [ AS ] '<u>escape_character</u>' ]
                           [ FORCE QUOTE { <u>column_name</u> [, ...] | * } ] ] ]

       Note that in this syntax, BINARY and CSV are treated as independent keywords, not as arguments of a
       FORMAT option.

       The following syntax was used before PostgreSQL version 7.3 and is still supported:

           COPY [ BINARY ] <u>table_name</u>
               FROM { '<u>filename</u>' | STDIN }
               [ [USING] DELIMITERS '<u>delimiter_character</u>' ]
               [ WITH NULL AS '<u>null_string</u>' ]

           COPY [ BINARY ] <u>table_name</u>
               TO { '<u>filename</u>' | STDOUT }
               [ [USING] DELIMITERS '<u>delimiter_character</u>' ]
               [ WITH NULL AS '<u>null_string</u>' ]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Section 27.4.3

PostgreSQL 17.5                                       2025                                               <u><a href="../man7/COPY.7.html">COPY</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>