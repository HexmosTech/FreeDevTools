<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>path_resolution - how a pathname is resolved to a file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       path_resolution - how a pathname is resolved to a file

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Some  UNIX/Linux  system  calls  have  as  parameter  one or more filenames.  A filename (or pathname) is
       resolved as follows.

   <b>Step</b> <b>1:</b> <b>start</b> <b>of</b> <b>the</b> <b>resolution</b> <b>process</b>
       If the pathname starts with the '/' character, the starting lookup directory is the root directory of the
       calling process.  A process inherits its root directory from its parent.  Usually this will be  the  root
       directory  of  the  file hierarchy.  A process may get a different root directory by use of the <b><a href="../man2/chroot.2.html">chroot</a></b>(2)
       system  call,  or  may  temporarily  use  a  different  root  directory  by  using  <b><a href="../man2/openat2.2.html">openat2</a></b>(2)  with  the
       <b>RESOLVE_IN_ROOT</b> flag set.

       A  process  may get an entirely private mount namespace in case it—or one of its ancestors—was started by
       an invocation of the <b><a href="../man2/clone.2.html">clone</a></b>(2) system call that had the <b>CLONE_NEWNS</b> flag set.  This handles the  '/'  part
       of the pathname.

       If  the  pathname  does not start with the '/' character, the starting lookup directory of the resolution
       process is the current working directory of the process — or in the case of <b><a href="../man2/openat.2.html">openat</a></b>(2)-style system calls,
       the <u>dfd</u> argument (or the current working directory if <b>AT_FDCWD</b> is  passed  as  the  <u>dfd</u>  argument).   The
       current  working directory is inherited from the parent, and can be changed by use of the <b><a href="../man2/chdir.2.html">chdir</a></b>(2) system
       call.

       Pathnames starting with a '/' character are called absolute pathnames.  Pathnames not starting with a '/'
       are called relative pathnames.

   <b>Step</b> <b>2:</b> <b>walk</b> <b>along</b> <b>the</b> <b>path</b>
       Set the current lookup directory to the starting lookup directory.  Now, for each nonfinal  component  of
       the  pathname,  where a component is a substring delimited by '/' characters, this component is looked up
       in the current lookup directory.

       If the process does not have search permission on the  current  lookup  directory,  an  <b>EACCES</b>  error  is
       returned ("Permission denied").

       If the component is not found, an <b>ENOENT</b> error is returned ("No such file or directory").

       If  the  component is found, but is neither a directory nor a symbolic link, an <b>ENOTDIR</b> error is returned
       ("Not a directory").

       If the component is found and is a directory, we set the current lookup directory to that directory,  and
       go to the next component.

       If  the  component is found and is a symbolic link, we first resolve this symbolic link (with the current
       lookup directory as starting lookup directory).  Upon error, that error is returned.  If  the  result  is
       not  a directory, an <b>ENOTDIR</b> error is returned.  If the resolution of the symbolic link is successful and
       returns a directory, we set the current lookup directory to that directory, and go to the next component.
       Note that the resolution process here can involve recursion if the  prefix  ('dirname')  component  of  a
       pathname  contains  a  filename  that  is  a symbolic link that resolves to a directory (where the prefix
       component of that directory may contain a symbolic link, and so on).  In  order  to  protect  the  kernel
       against  stack  overflow,  and also to protect against denial of service, there are limits on the maximum
       recursion depth, and on the maximum number of symbolic links followed.  An <b>ELOOP</b> error is  returned  when
       the maximum is exceeded ("Too many levels of symbolic links").

       As  currently  implemented  on  Linux,  the  maximum number of symbolic links that will be followed while
       resolving a pathname is 40.  Before Linux 2.6.18, the limit on the recursion depth was 5.  Starting  with
       Linux  2.6.18,  this  limit  was  raised  to  8.  In Linux 4.2, the kernel's pathname-resolution code was
       reworked to eliminate the use of recursion, so that the only limit that remains  is  the  maximum  of  40
       resolutions for the entire pathname.

       The  resolution  of  symbolic  links  during  this  stage  can  be  blocked by using <b><a href="../man2/openat2.2.html">openat2</a></b>(2), with the
       <b>RESOLVE_NO_SYMLINKS</b> flag set.

   <b>Step</b> <b>3:</b> <b>find</b> <b>the</b> <b>final</b> <b>entry</b>
       The lookup of the final component of the pathname goes  just  like  that  of  all  other  components,  as
       described in the previous step, with two differences: (i) the final component need not be a directory (at
       least  as  far  as  the  path  resolution  process  is  concerned—it  may  have  to  be a directory, or a
       nondirectory, because of the requirements of the specific system call), and (ii) it is not necessarily an
       error if the component is not found—maybe we are just creating it.  The details on the treatment  of  the
       final entry are described in the manual pages of the specific system calls.

   <b>.</b> <b>and</b> <b>..</b>
       By  convention,  every directory has the entries "." and "..", which refer to the directory itself and to
       its parent directory, respectively.

       The path resolution process will assume that these entries have their conventional  meanings,  regardless
       of whether they are actually present in the physical filesystem.

       One cannot walk up past the root: "<a href="file:/..">/..</a>" is the same as "/".

   <b>Mount</b> <b>points</b>
       After a <u>mount</u> <u>dev</u> <u>path</u> command, the pathname "path" refers to the root of the filesystem hierarchy on the
       device "dev", and no longer to whatever it referred to earlier.

       One  can walk out of a mounted filesystem: "path/.." refers to the parent directory of "path", outside of
       the filesystem hierarchy on "dev".

       Traversal of mount points can be blocked by using <b><a href="../man2/openat2.2.html">openat2</a></b>(2), with the <b>RESOLVE_NO_XDEV</b> flag  set  (though
       note that this also restricts bind mount traversal).

   <b>Trailing</b> <b>slashes</b>
       If  a  pathname  ends  in  a  '/',  that  forces  resolution of the preceding component as in Step 2: the
       component preceding the slash either exists and resolves to a directory or it names a directory  that  is
       to be created immediately after the pathname is resolved.  Otherwise, a trailing '/' is ignored.

   <b>Final</b> <b>symbolic</b> <b>link</b>
       If  the  last  component of a pathname is a symbolic link, then it depends on the system call whether the
       file referred to will be the symbolic link or the  result  of  path  resolution  on  its  contents.   For
       example,  the  system call <b><a href="../man2/lstat.2.html">lstat</a></b>(2) will operate on the symbolic link, while <b><a href="../man2/stat.2.html">stat</a></b>(2) operates on the file
       pointed to by the symbolic link.

   <b>Length</b> <b>limit</b>
       There is a maximum length for pathnames.  If the pathname (or some intermediate pathname  obtained  while
       resolving symbolic links) is too long, an <b>ENAMETOOLONG</b> error is returned ("Filename too long").

   <b>Empty</b> <b>pathname</b>
       In  the original UNIX, the empty pathname referred to the current directory.  Nowadays POSIX decrees that
       an empty pathname must not be resolved successfully.  Linux returns <b>ENOENT</b> in this case.

   <b>Permissions</b>
       The permission bits of a file consist of three groups of three bits; see <b><a href="../man1/chmod.1.html">chmod</a></b>(1) and <b><a href="../man2/stat.2.html">stat</a></b>(2).  The first
       group of three is used when the effective user ID of the calling process equals the owner ID of the file.
       The second group of three is used when the group ID of the file either equals the effective group  ID  of
       the  calling  process,  or  is  one  of  the  supplementary  group  IDs of the calling process (as set by
       <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)).  When neither holds, the third group is used.

       Of the three bits used, the first bit determines read permission, the second write  permission,  and  the
       last execute permission in case of ordinary files, or search permission in case of directories.

       Linux  uses  the  fsuid instead of the effective user ID in permission checks.  Ordinarily the fsuid will
       equal the effective user ID, but the fsuid can be changed by the system call <b><a href="../man2/setfsuid.2.html">setfsuid</a></b>(2).

       (Here "fsuid" stands for something  like  "filesystem  user  ID".   The  concept  was  required  for  the
       implementation  of a user space NFS server at a time when processes could send a signal to a process with
       the same effective user ID.  It is obsolete now.  Nobody should use <b><a href="../man2/setfsuid.2.html">setfsuid</a></b>(2).)

       Similarly, Linux uses the fsgid  ("filesystem  group  ID")  instead  of  the  effective  group  ID.   See
       <b><a href="../man2/setfsgid.2.html">setfsgid</a></b>(2).

   <b>Bypassing</b> <b>permission</b> <b>checks:</b> <b>superuser</b> <b>and</b> <b>capabilities</b>
       On  a  traditional  UNIX  system,  the  superuser  (<u>root</u>,  user  ID  0) is all-powerful, and bypasses all
       permissions restrictions when accessing files.

       On Linux, superuser privileges are divided into capabilities (see <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)).  Two capabilities are
       relevant for file permissions checks: <b>CAP_DAC_OVERRIDE</b> and <b>CAP_DAC_READ_SEARCH</b>.   (A  process  has  these
       capabilities if its fsuid is 0.)

       The  <b>CAP_DAC_OVERRIDE</b>  capability  overrides  all permission checking, but grants execute permission only
       when at least one of the file's three execute permission bits is set.

       The <b>CAP_DAC_READ_SEARCH</b> capability grants read and search permission on directories, and read  permission
       on ordinary files.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/readlink.2.html">readlink</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/credentials.7.html">credentials</a></b>(7), <b><a href="../man7/symlink.7.html">symlink</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                 <u><a href="../man7/path_resolution.7.html">path_resolution</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>