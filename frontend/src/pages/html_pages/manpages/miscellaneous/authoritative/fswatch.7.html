<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fswatch  —  Ask  for  notification  when the contents of the specified files or directory hierarchies are</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/fswatch">fswatch_1.14.0+repack-13.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fswatch  —  Ask  for  notification  when the contents of the specified files or directory hierarchies are
       modified.

       This man page is kept for reference but it is not to be considered an authoritative or complete source of
       information.  Please, consult the official Info documentation shipped with .

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>fswatch</b> <b>(option)*</b> <b>path+</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>fswatch</b> command receives notifications when the contents of the specified files  or  directories  are
       modified.  fswatch implements six kind of monitors:

       -       A monitor based on the File System Events API of Apple OS X.

       -       A  monitor  based  on  kqueue,  an  event  notification  interface  introduces in FreeBSD 4.1 and
               supported on most *BSD systems (including OS X).

       -       A monitor based on the File Events Notification API of the Solaris kernel and its derivatives.

       -       A monitor based on inotify, a  Linux  kernel  subsystem  that  reports  file  system  changes  to
               applications.

       -       A monitor based on the ReadDirectoryChangesW Microsoft Windows API.

       -       A  monitor  which periodically stats the file system, saves file modification times in memory and
               manually calculates changes.

       <b>fswatch</b> writes a record for each event it receives containing:

       -       The timestamp when the event was <u>received</u> (optionally).

       -       The path affected by the current event.

       -       A space-separated list of <u>event</u> <u>types</u> (see “EVENT TYPES” ).

       <b>fswatch</b> enters an infinite loop and never returns.  When it receives a SIGABRT, SIGINT or SIGTERM signal,
       <b>fswatch</b> closes the notification streams and exits gracefully returning 0 to the calling process.

       The following options are available:

       <b>-0,</b> <b>--print0</b>
               Use the ASCII NUL character (\0) as line separator.  Since file names can potentially contain any
               character but NUL, this option assures that the output of fswatch can be safely parsed using  NUL
               as delimiter, such as using xargs -0 and the shell builtin read -d ''.

       <b>-1,</b> <b>--one-event</b>
               Exit fswatch after the first set of events is received.

       <b>--batch-marker</b> <u>marker</u>
               Print a marker at the end of every batch.  An optional marker <u>marker</u> can be specified to override
               its default value `NoOp'.

       <b>--event</b> <u>name</u>
               Filter event with the specified <u>name</u>.  This option can be used multiple times, one for each event
               <u>name</u> that must be included in the output.

       <b>-e,</b> <b>--exclude</b> <u>regexp</u>
               Exclude  paths  matching  <u>regexp</u>.   Multiple  exclude  filters can be specified using this option
               multiple times.  See “FILTERING PATHS” for further information.

       <b>-E,</b> <b>--extended</b>
               Use extended regular expressions.

       <b>-f,</b> <b>--format-time</b> <u>format</u>
               Print the event time using the specified <u>format</u>.  Supported formats are specified by <u><a href="../man3/strftime.3.html">strftime</a></u>(3).

       <b>-h,</b> <b>--help</b>
               Show the help message.

       <b>-i,</b> <b>--include</b> <u>regexp</u>
               Include paths matching <u>regexp</u>.  Multiple include filters  can  be  specified  using  this  option
               multiple times.  See “FILTERING PATHS” for further information.

       <b>-I,</b> <b>--insensitive</b>
               Use case insensitive regular expressions.

       <b>-l,</b> <b>--latency</b> <u>latency</u>
               Set  the <u>latency</u> in seconds.  The latency is a double value greater than 0.1.  Smaller values are
               currently not allowed in order not to compromise the performance  of  the  system.   The  default
               latency is 1 second.

       <b>-L,</b> <b>--follow-links</b>
               Follow symbolic links.

       <b>-M,</b> <b>--list-monitors</b>
               List the available monitors.

       <b>-m,</b> <b>--monitor</b> <u>name</u>
               Uses  the  monitor  specified  by <u>name</u>.  The list of currently available monitors can be obtained
               using the <b>-h</b> option.

       <b>-n,</b> <b>--numeric</b>
               Print the numeric value of the event flag, instead of the array of symbolic names.   The  numeric
               value  of the event flags are system-specific and may vary across different versions of OS X.  As
               a consequence, the use of numeric values is discouraged.

       <b>-o,</b> <b>--one-per-batch</b>
               Print a single message with the number of change events.

       <b>-r,</b> <b>--recursive</b>
               Watch subdirectories recursively.  This option may not be supported on all systems.

       <b>-t,</b> <b>--timestamp</b>
               Print the event timestamp.

       <b>-u,</b> <b>--utf-time</b>
               Print the event time in UTC format.  When this option is not specified, the time is printed using
               the system <u>local</u> time, as defined by <b>localtime</b> <b>(3)</b>.

       <b>-v,</b> <b>--verbose</b>
               Print verbose output.

       <b>--version</b>
               Print the version of <b>fswatch</b> and exits.

       <b>-x,</b> <b>--event-flags</b>
               Prints the event flags.

       <b>--event-flag-separator</b> <u>separator</u>
               Print event flags using the specified <u>separator</u>.

</pre><h4><b>MONITORS</b></h4><pre>
       <b>fswatch</b> acts as a front-end to system-specific monitors.  Currently, the available monitors are:

       -       The <u>FSEvents</u> <u>monitor</u>, a monitor based on the File System Events API of Apple OS X.

       -       The <u>kqueue</u> <u>monitor</u>, a monitor based on kqueue, an  event  notification  interface  introduced  in
               FreeBSD 4.1 and supported on most *BSD systems (including OS X).

       -       The <u>inotify</u> <u>monitor</u>, a Linux kernel subsystem that reports file system changes to applications.

       -       The  <u>poll</u>  <u>monitor</u>,  a  monitor which periodically stats the file system, saves file modification
               times in memory and manually calculates file system changes, which  can  work  on  any  operating
               system where <u><a href="../man2/stat.2.html">stat</a></u>(2) can be used.

       Each  monitor  has  its own strengths, weakness and peculiarities.  Although <b>fswatch</b> strives to provide a
       uniform experience no matter which monitor is used, it is still important for users to know which monitor
       they are using and to be aware of existing bugs, limitations, corner cases or pathological behaviour.

   <b>The</b> <b>FSEvents</b> <b>Monitor</b>
       The <u>FSEvents</u> <u>monitor</u>, available only on Apple OS X, has no known limitations and scales  very  well  with
       the  number of files being observed.  In fact, I observed no performance degradation when testing <b>fswatch</b>
       observing changes on a filesystem of 500 GB over long periods of time.  On OS  X,  this  is  the  default
       monitor.

   <b>The</b> <b>kqueue</b> <b>Monitor</b>
       The  <u>kqueue</u>  <u>monitor</u>,  available  on  any  *BSD system featuring kqueue, requires a file descriptor to be
       opened for every file being watched.  As a result, this monitor scales badly with  the  number  of  files
       being  observed  and  may begin to misbehave as soon as the <b>fswatch</b> process runs out of file descriptors.
       In this case, <b>fswatch</b> dumps one error on standard error for every file that  cannot  be  opened.   Beware
       that  on  some systems the maximum number of file descriptors that can be opened by a process is set to a
       very low value (values as low as 256 are not uncommon), even if the operating system  may  allow  a  much
       larger value.

       If  you  are  running out of file descriptors when using this monitor and you cannot reduce the number of
       observed items, either:

       -       Consider raising the number of maximum open file descriptors (check your OS documentation).

       -       Consider using another monitor.

   <b>The</b> <b>inotify</b> <b>Monitor</b>
       The <u>inotify</u> <u>monitor</u>, available on Linux since kernel 2.6.13, may suffer a queue overflow  if  events  are
       generated  faster  than  they  are  read  from  the queue.  In any case, the application is guaranteed to
       receive an overflow notification which can be handled to gracefully recover.  <b>fswatch</b> currently throws an
       exception if a queue overflow occurs.  Future versions  will  handle  the  overflow  by  emitting  proper
       notifications.   However,  the  odds  of  observing  a  queue overflow on a default configured mainstream
       GNU/Linux distribution is very low.

       The inotify API sends events for the direct child elements of a watched directory and  it  scales  pretty
       well  with  the  number of watched items.  For this reason, depending on the number of files to watch, it
       may sometimes be preferable to watch a common parent directory and filter  received  events  rather  than
       adding a huge number of file watches.

   <b>The</b> <b>Poll</b> <b>Monitor</b>
       The  <u>poll</u>  <u>monitor</u>  was added as a fallback mechanisms in the cases where no other monitor could be used,
       including:

       -       Operating system without any sort of file events API.

       -       Situations where the limitations of the available monitors cannot be overcome (i.e.: observing  a
               number  of  files  greater  than  the  available  file  descriptors  on a system using the kqueue
               monitor).

       The poll monitor, available on any platform, only relies on available CPU and memory to perform its  task
       (besides  the  <u><a href="../man2/stat.2.html">stat</a></u>(2)  function).   The performance of this monitor degrades linearly with the number of
       files being watched.  The authors' experience indicates that <b>fswatch</b> requires approximately 150 MB or RAM
       memory to observe a hierarchy of 500.000 files with a minimum path length of  32  characters.   A  common
       bottleneck  of  the poll monitor is disk access, since stat()-ing a great number of files may take a huge
       amount of time.  In this case, the latency should be set to a sufficiently large value in order to reduce
       the performance degradation that may result from frequent disk access.

   <b>How</b> <b>to</b> <b>Choose</b> <b>a</b> <b>Monitor</b>
       <b>fswatch</b> already chooses the "best" monitor for your platform if you  do  not  specify  any.   However,  a
       specific  monitor may be better suited to specific use cases.  Please, read the “MONITORS” section to get
       a description of all the available monitors and their limitations.

       Usage recommendations are as follows:

       -       On OS X, use only the FSEvents monitor (which is the default behaviour).

       -       On Linux, use the inotify monitor (which is the default behaviour).

       -       If the number of files to observe is sufficiently small, use the kqueue monitor.  Beware that  on
               some  systems  the maximum number of file descriptors that can be opened by a process is set to a
               very low value (values as low as 256 are not uncommon), even if the operating system may allow  a
               much larger value.  In this case, check your OS documentation to raise this limit on either a per
               process or a system-wide basis.

       -       If  feasible,  watch directories instead of watching files.  Properly crafting the receiving side
               of the events to deal with directories may sensibly reduce the monitor resource consumption.

       -       If none of the above applies, use the poll  monitor.   The  authors'  experience  indicates  that
               fswatch  requires approximately 150 MB or RAM memory to observe a hierarchy of 500.000 files with
               a minimum path length of 32 characters.  A common bottleneck of the poll monitor is disk  access,
               since  stat()-ing  a  great  number  of  files may take a huge amount of time.  In this case, the
               latency should be set  to  a  sufficiently  large  value  in  order  to  reduce  the  performance
               degradation that may result from frequent disk access.

</pre><h4><b>FILTERING</b> <b>PATHS</b></h4><pre>
       Received  events  can  be filtered by path using regular expressions.  Regular expressions can be used to
       include or exclude matching paths.  The user can specify multiple filter expression in any order and  the
       <u>first</u> matching expression wins.

       Other options govern how regular expressions are interpreted:

       -       Regular expressions can be <u>extended</u> if option <b>-E</b> is specified.

       -       Regular expressions can be <u>case</u> <u>insensitive</u> if option <b>-I</b> is specified.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Basic</b> <b>Usage</b>
       <b>fswatch</b> syntax is the following:

             <b>$</b> <b>fswatch</b> <b>[options]</b> <b>[paths]</b> <b>...</b>

       <b>fswatch</b>  will  then  output  change events to standard output. By default, only the affected file name is
       printed.  However, many options are available to format the event record, including:

       -       The possibility of adding the event timestamp.

       -       The possibility of adding the event mask in both textual and numerical form.

       The following command listens for changes in the current directory  and  events  are  delivered  every  5
       seconds:

             <b>$</b> <b>fswatch</b> <b>-l</b> <b>5</b> <b>.</b>

       The following command listens for changes in the current user home directory and <u><a href="file:/var/log">/var/log</a></u>:

             <b>$</b> <b>fswatch</b> <b>~</b> <b><a href="file:/var/log">/var/log</a></b>

   <b>Piping</b> <b>fswatch</b> <b>Output</b> <b>to</b> <b>Another</b> <b>Process</b>
       Very  often  you wish to not only receive an event, but react to it.  The simplest way to do it is piping
       fswatch output to another process.  Since in Unix and Unix-like file system file  names  may  potentially
       contain  any  character but <u>NUL</u> <u>(\0)</u> and the path separator <u>(/)</u>, <b>fswatch</b> has a specific mode of operation
       when its output must be piped to another process.  When the [<b>-0</b>] option is used, <b>fswatch</b> will use the <u>NUL</u>
       character as record separator, thus allowing any other character to appear in a path.  This is  important
       because  many  commands  and  shell  builtins  (such  as <u>read</u>) split words and lines by default using the
       characters in <u>$IFS</u>, which by default contains characters which may be present (although rarely) in a file
       name, resulting in a wrong event path being received and processed.

       Probably the simplest way to pipe <b>fswatch</b> to another program in order to respond to  an  event  is  using
       <u>xargs</u>:

             <b>$</b> <b>fswatch</b> <b>-0</b> <b>[opts]</b> <b>[paths]</b> <b>|</b> <b>xargs</b> <b>-0</b> <b>-n</b> <b>1</b> <b>-I</b> <b>{}</b> <b>[command]</b>

       -       <u>fswatch</u> <u>-0</u> will split records using the <u>NUL</u> character.

       -       <u>xargs</u>  <u>-0</u>  will  split  records  using  the  <u>NUL</u>  character.  This is required to correctly match
               impedance with <b>fswatch</b>.

       -       <u>xargs</u> <u>-n</u> <u>1</u> will invoke <u>command</u> every record.  If you want to do it  every  <u>x</u>  records,  then  use
               <u>xargs</u> <u>-n</u> <u>x</u>.

       -       <u>xargs</u>  <u>-I</u>  <u>{}</u>  will  substitute  occurrences  of  <u>{}</u> in command with the parsed argument.  If the
               command you are running does not need the event path name,  just  delete  this  option.   If  you
               prefer using another replacement string, substitute <u>{}</u> with yours.

   <b>Bubbling</b> <b>Events</b>
       An  often  requested  feature  is  being able to receive a single event "per batch", instead of receiving
       multiple events.  This use case is implemented by the [<b>-o,</b> <b>--one-per-batch</b>] option which tells <b>fswatch</b> to
       dump a record containing the number of received events, without any other detail:

             <b>$</b> <b>fswatch</b> <b>-or</b> <b>/path/to/watch</b>
             <b>1</b>
             <b>10</b>
             <b>[...]</b>

       This is useful if, for example, you want to respond to change events in a way which is (or can easily be)
       path-independent (because you are not receiving any event detail)  and  you  prefer  to  "bubble"  events
       together  to  reduce  the  overhead  of  the  command  being  executed.   A  typical  case is a directory
       synchronisation job whenever some files change.

   <b>Receiving</b> <b>a</b> <b>Single</b> <b>Event</b>
       Another requested feature is the possibility of receiving a single event and exit.  This is  most  useful
       when existing scripts processing events include the restart logic of <b>fswatch</b> This use case is implemented
       by the [<b>-1,</b> <b>--one-event</b>] option:

             <b>$</b> <b>fswatch</b> <b>-1</b> <b>/path/to/watch</b>
             <b>/path/to/watch</b>

</pre><h4><b>Compatibility</b> <b>With</b> <b>fswatch</b> <b>0.x</b></h4><pre>
       The  previous  major version of <b>fswatch</b> (v. 0.x) allowed users to run a command whenever a set of changes
       was detected with the following syntax:

             <b>$</b> <b>fswatch</b> <b>path</b> <b>program</b>

       Starting with <b>fswatch</b> v. 1.x this behaviour is no longer supported.  The rationale behind  this  decision
       includes:

       -       The old version only allows watching one path.

       -       The  command  to  execute  was  passed  as  last argument, alongside the path to watch, making it
               difficult to extend the program functionality to add multiple path support

       -       The old version forks and executes <a href="file:/bin/bash">/bin/bash</a>,  which  is  neither  portable,  nor  guaranteed  to
               succeed, nor desirable by users of other shells.

       -       No information about the change events is passed to the forked process.

       To  solve the aforementioned issues and keep <b>fswatch</b> consistent with common UNIX practices, the behaviour
       has changed and <b>fswatch</b> now prints event records to the standard output that users can process further by
       piping the output of <b>fswatch</b> to other programs.

       To fully support the old use, the [<b>-o,</b> <b>--one-per-batch</b>] option was added in v.  1.3.3.   When  specified,
       <b>fswatch</b> will only dump 1 event to standard output which can be used to trigger another program:

             <b>$</b> <b>fswatch</b> <b>-o</b> <b>path</b> | <b>xargs</b> <b>-n1</b> <b>program</b>

       In  this case, program will receive the number of change events as first argument.  If no argument should
       be passed to program, then the following command could be used:

             <b>$</b> <b>fswatch</b> <b>-o</b> <b>path</b> | <b>xargs</b> <b>-n1</b> <b>-I{}</b> <b>program</b>

       Although we encourage you to embrace the new <b>fswatch</b> behaviour and update  your  scripts,  we  provide  a
       little  wrapper  called  <u>fswatch-run</u>  which  is installed alongside <b>fswatch</b> which lets you use the legacy
       syntax:

             <b>$</b> <b>fswatch-run</b> <b>path</b> <b>[paths]</b> <b>program</b>

       Under the hood, <u>fswatch-run</u> simply calls <u>fswatch</u> <u>-o</u> piping its output to <u>xargs</u>.

       <u>fswatch-run</u> is a symbolic link to  a  shell-specific  wrapper.   Currently,  ZSH  and  Bash  scripts  are
       provided.   If  no  suitable  shells are found in the target system, the <u>fswatch-run</u> symbolic link is not
       created.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       <b>fswatch</b> may exit with one of the following exit statuses:

             <b>FSW_OK</b> <b>0</b>
             <b>FSW_ERR_UNKNOWN_ERROR</b> <b>(1</b> <b>&lt;&lt;</b> <b>0)</b>
             <b>FSW_ERR_SESSION_UNKNOWN</b> <b>(1</b> <b>&lt;&lt;</b> <b>1)</b>
             <b>FSW_ERR_MONITOR_ALREADY_EXISTS</b> <b>(1</b> <b>&lt;&lt;</b> <b>2)</b>
             <b>FSW_ERR_MEMORY</b> <b>(1</b> <b>&lt;&lt;</b> <b>3)</b>
             <b>FSW_ERR_UNKNOWN_MONITOR_TYPE</b> <b>(1</b> <b>&lt;&lt;</b> <b>4)</b>
             <b>FSW_ERR_CALLBACK_NOT_SET</b> <b>(1</b> <b>&lt;&lt;</b> <b>5)</b>
             <b>FSW_ERR_PATHS_NOT_SET</b> <b>(1</b> <b>&lt;&lt;</b> <b>6)</b>
             <b>FSW_ERR_UNKNOWN_MONITOR</b> <b>(1</b> <b>&lt;&lt;</b> <b>7)</b>
             <b>FSW_ERR_MISSING_CONTEXT</b> <b>(1</b> <b>&lt;&lt;</b> <b>8)</b>
             <b>FSW_ERR_INVALID_PATH</b> <b>(1</b> <b>&lt;&lt;</b> <b>9)</b>
             <b>FSW_ERR_INVALID_CALLBACK</b> <b>(1</b> <b>&lt;&lt;</b> <b>10)</b>
             <b>FSW_ERR_INVALID_LATENCY</b> <b>(1</b> <b>&lt;&lt;</b> <b>11)</b>
             <b>FSW_ERR_INVALID_REGEX</b> <b>(1</b> <b>&lt;&lt;</b> <b>12)</b>
             <b>FSW_ERR_MONITOR_ALREADY_RUNNING</b> <b>(1</b> <b>&lt;&lt;</b> <b>13)</b>
             <b>FSW_ERR_STALE_MONITOR_THREAD</b> <b>(1</b> <b>&lt;&lt;</b> <b>14)</b>
             <b>FSW_ERR_THREAD_FAULT</b> <b>(1</b> <b>&lt;&lt;</b> <b>15)</b>
             <b>FSW_ERR_UNSUPPORTED_OPERATION</b> <b>(1</b> <b>&lt;&lt;</b> <b>16)</b>
             <b>FSW_ERR_UNKNOWN_VALUE</b> <b>(1</b> <b>&lt;&lt;</b> <b>17)</b>

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       <b>fswatch</b> exits 0 on success, and &gt;0 if an error occurs.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       <b>fswatch</b> can be built on any system supporting at least one of the available monitors.

</pre><h4><b>BUGS</b></h4><pre>
       See https://github.com/emcrisostomo/fswatch/issues for open issues or to create a new one.

       Bugs can also be submitted to <a href="mailto:enrico.m.crisostomo@gmail.com">enrico.m.crisostomo@gmail.com</a>.

pc linux-gnu                                   September 15, 2021                                     <u><a href="../man7/fswatch.7.html">fswatch</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>