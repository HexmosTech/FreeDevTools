<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WML Macros - Writing powerful WML macros</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/wml">wml_2.32.0~ds1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       WML Macros - Writing powerful WML macros

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This tutorial is a guide for writing macros in WML.  It should help beginners to write their first
       templates, but also give useful hints to write tricky macros.  To take best benefit of this document, it
       is highly recommended to read documentation of individual passes first.

       Following examples are compiled with

         wml -q -p123 test.wml

       Most of them could be passed through <u>mp4h</u> only, but the line below is more generic.

</pre><h4><b>INTRODUCTION</b></h4><pre>
   <b>Definitions</b>
       These definitions are those used in this document, they may differ from those of the W3C because i do not
       want to enter into deep details.

       • A <u>tag</u> is a portion of text enclosed between bracket angles, like

              &lt;a&gt;
              &lt;/table&gt;
              &lt;!-- hey this is a comment --&gt;
              &lt;?xml version="1.0" encoding="UTF-8"?&gt;

       • A  <u>start</u>  tag  is  a  tag  which  begins  an <u>element</u> (see below).  It consists of a left angle bracket,
         followed by the element name, optional <u>attributes</u> (see below), and a right angle  bracket.   All  these
         are start tags:

              &lt;a href="#name"&gt;
              &lt;td&gt;
              &lt;meta name="generator" content="vi"&gt;

       • An  <u>end</u>  tag is a tag which ends an <u>element</u> (see below).  It consists of a left angle bracket, a slash,
         the element name, and a right angle bracket, like in

              &lt;/table&gt;
              &lt;/a&gt;

         This tag cannot contain attributes.

       • An <u>element</u> is an elementary unit of the document.  It mainly consists of pair of start  and  end  tags,
         like in

              &lt;a href="#name"&gt;Click here&lt;/a&gt;

       • The  <u>body</u>  of  an  element is the portion of text contained between the start and the end tags.  In the
         example above, there is one element, which name is "a", and its body is ""Click here"".

       • <u>Attributes</u> are parameters to make elements more flexible.  They must be  put  in  the  start  tag.   An
         element  may  have  any number of attributes, which are separated by one or more spaces, tabulations or
         newlines.  Each element may define which attributes are mandatory and which are optional.

              &lt;img src="logo.png" alt="Logo"
                   title="Our nice and beautiful logo"&gt;

         The "img" element has 3 attributes

       • A <u>simple</u> <u>tag</u> is an element without end tag.

       • A <u>complex</u> <u>tag</u> is an element with start and end tags.

   <b>First</b> <b>contact</b>
       Basically all macro definitions are performed with the "&lt;define-tag&gt;". Here is a trivial example:

       Input:

         1| &lt;define-tag foo&gt;
         2| bar
         3| &lt;/define-tag&gt;
         4| &lt;FOO&gt;

       Output:

         1|
         2|
         3| bar
         4|

       Whereas trivial this example shows some interesting points:

       • Newlines are preserved, there is the same number of lines on input and  output,  but  we  will  discuss
         about whitespaces in detail below.

       • Tag names are case insensitive.

   <b>About</b> <b>Simple</b> <b>Tags</b>
       In HTML simple tags are an element without end tag, e.g.

           &lt;br&gt;

       But XML specifies that simple tags must be written with one of these 2 forms:

           &lt;br&gt;&lt;/br&gt;
           &lt;br/&gt;

       i.e.  either  as  a complex tag, without body, or by adding a trailing slash to the start tag.  The first
       one will not work with WML, and also may confuse HTML browsers, and so should be  avoided.  You  have  to
       choose to write this trailing slash or not, WML works with both forms.

       In  this  document,  i  will now always write simple tags with this trailing slash, to conform to the new
       XHTML standard.  This is my preferred writing of input text, but one  may  still  continue  without  this
       trailing slash.  You decide to which syntax you want to conform to.

       On  the  other  hand, HTML browsers may be confused by XHTML syntax, so output text does not contain this
       trailing slash.  This seems contradictory, but with this  approach  our  input  files  are  ready  to  be
       processed by future XML tools, and we only have to run WML with adequate flags to produce XHTML compliant
       pages.

</pre><h4><b>DEFINING</b> <b>NEW</b> <b>TAGS</b></h4><pre>
       Each  time  a  known  element is found in input text, it is removed and its replacement text is put here.
       After that, this replacement text is scanned in case it contains other macros.

       All user macros are defined with the "define-tag" element.  Its first attribute is the macro  name  which
       is defined, and its body function is the replacement text which is inserted in lieu of this macro.

       Let us begin with a simple example:

       Input:

         1| &lt;define-tag homepage&gt;https://thewml.github.io/&lt;/define-tag&gt;
         2| &lt;homepage/&gt;

       Output:

         1|
         2| https://thewml.github.io/

       Defining a complex tag is no more difficult, just add an "endtag=required" attribute.

       Input:

         1| &lt;define-tag foo endtag=required&gt;bar&lt;/define-tag&gt;
         2| &lt;foo&gt;baz&lt;/foo&gt;

       Output:

         1|
         2| bar

   <b>Special</b> <b>Text</b>
       Some  strings  have  a  special  meaning  when  found in replacement text, to allow full customization of
       macros:

       %0 %1 ...
         Attributes: %0 is the first attribute, %1 the second, and so on.

       %name
         Macro name

       %attributes
         Space-separated list of all attributes

       %body
         Macro body (for complex tags only)

       %#
         Number of arguments

       %%
         A percent sign

       Input:

         1| &lt;define-tag foo endtag=required&gt;
         2| Macro name:          %name
         3| Number of arguments: %#
         4| First argument:      %0
         5| Second argument:     %1
         6| All arguments:       %attributes
         7| Body macro:          %body
         8| &lt;/define-tag&gt;
         9| &lt;foo Here are attributes&gt;
        10| And the body
        11| goes here.
        12| &lt;/foo&gt;

       Output:

         1|
         2|
         3| Macro name:          foo
         4| Number of arguments: 3
         5| First argument:      Here
         6| Second argument:     are
         7| All arguments:       Here are attributes
         8| Body macro:
         9| And the body
        10| goes here.
        11|
        12|

       These special strings may also be altered by modifiers, which are a set of  letters  (one  or  more)  put
       after the percent sign.  These modifiers, and their actions, are:

       U (Unexpanded)
         Text is replaced, but not expanded (see section about expansion for details).

       A (Array)
         Lists are separated by newlines instead of spaces.  This modifier makes sense with %attributes only.

         Input:

           1| &lt;define-tag foo endtag=required&gt;
           2| First argument:      %A0
           3| All arguments:       %Aattributes
           4| Body macro:          %Abody
           5| &lt;/define-tag&gt;
           6| &lt;foo Here are attributes&gt;
           7| And the body
           8| goes here.
           9| &lt;/foo&gt;

         Output:

           1|
           2|
           3| First argument:      Here
           4| All arguments:       Here
           5| are
           6| attributes
           7| Body macro:
           8| And the body
           9| goes here.
          10|
          11|

       Note  that these sequences are replaced when macro is read, after what replacement text is scanned again.
       This is very important, because you should never write constructs like

          &lt;if &lt;get-var foo /&gt; %body /&gt;

       Indded, %body is replaced <u>before</u> "&lt;if&gt;" element is scanned, which may  cause  unpredictable  results.   A
       better solution is

          &lt;if &lt;get-var foo /&gt; "%body" /&gt;

       but  it  will  cause  trouble  when  %body contains double quotes.  For this reason, you should never use
       "&lt;if&gt;" (and derivatives) tests when one of its arguments is a special sequence.  Use instead

          &lt;when &lt;get-var foo /&gt;&gt;
          %body
          &lt;/when&gt;

</pre><h4><b>WHITESPACES</b></h4><pre>
       Previous examples show that expansion prints lots of unused  newlines.   There  are  some  techniques  to
       remove  them.   The  first  one is with pass 1, by putting a backslash at end of line, which will discard
       this end of line.

       Input:

         1| &lt;define-tag foo&gt;\
         2| bar\
         3| &lt;/define-tag&gt;\
         4| &lt;FOO/&gt;

       Output:

         1| bar

       Another solution is to specify "whitespace=delete" when defining macros, e.g.

         1| &lt;define-tag foo whitespace=delete&gt;
         2| bar
         3| &lt;/define-tag&gt;
         4| &lt;FOO/&gt;

       Output:

         1|
         1| bar

       The first line is caused by newline after "&lt;/define-tag&gt;" which is not discarded.

       When this attribute is used, all trailing and leading whitespaces are removed, and also newlines  outside
       of angle brackets.

</pre><h4><b>MACROS</b> <b>WITH</b> <b>ATTRIBUTES</b></h4><pre>
       One  nice feature of WML is its ability to deal with arbitrary attributes.  There are many ways to define
       macros accepting attributes, we will discuss here the one used in all WML modules, and is so the standard
       way.

       Attributes are stored in variables, because HTML syntax "attribute=value" is very closed to assignment to
       variables.  In order to keep variables local, a mechanism of push/pop is used.  Here is an example

       Input:

         1| &lt;define-tag href whitespace=delete&gt;
         2| &lt;preserve url /&gt;
         3| &lt;preserve name /&gt;
         4| &lt;set-var %attributes /&gt;
         5| &lt;if &lt;get-var name /&gt; ""
         6|   &lt;set-var name="&lt;tt&gt;&lt;get-var url /&gt;&lt;/tt&gt;" /&gt; /&gt;
         7| &lt;a href="&lt;get-var url /&gt;"&gt;&lt;get-var name /&gt;&lt;/a&gt;
         8| &lt;restore name /&gt;
         9| &lt;restore url /&gt;
        10| &lt;/define-tag&gt;
        11| &lt;href url="<a href="http://www.w3.org/">http://www.w3.org/</a>" /&gt;

       Output:

         1|
         2| &lt;a href="<a href="http://www.w3.org/">http://www.w3.org/</a>"&gt;&lt;tt&gt;<a href="http://www.w3.org/">http://www.w3.org/</a>&lt;/tt&gt;&lt;/a&gt;

       The "&lt;preserve&gt;" tag pushes the variable passed in argument in top of a stack and clears  this  variable.
       So  this  variable  is  non-null  only  when  it  has  been  assigned  via  "&lt;set-var %attributes&gt;".  The
       "&lt;resstore&lt;gt"&gt; tag pops the value at top of the stack and sets the variable passed in argument  to  this
       value.

       In HTML some attributes are valid without value.  This attribute may be detected with

       Input:

         1| #use wml::std::info
         2| &lt;define-tag head whitespace=delete&gt;
         3| &lt;preserve title&gt;
         4| &lt;preserve info&gt;
         5| &lt;set-var info=*&gt;
         6| &lt;set-var %attributes&gt;
         7| &lt;head*&gt;
         8| &lt;ifeq "&lt;get-var info&gt;" "" &lt;info style=meta&gt;&gt;
         9| &lt;if "&lt;get-var title&gt;" "&lt;title*&gt;&lt;get-var title&gt;&lt;/title*&gt;"&gt;
        10| &lt;/head*&gt;
        11| &lt;restore info&gt;
        12| &lt;restore title&gt;
        13| &lt;/define-tag&gt;
        14| &lt;head title="Test page 1"&gt;
        15| &lt;head info title="Test page 2"&gt;

       Output:  (only non-blank lines are printed)

            &lt;head&gt;&lt;title&gt;Test page 1&lt;/title&gt;&lt;/head&gt;
            &lt;head&gt;
            &lt;nostrip&gt;&lt;meta name="Author"    content="Denis Barbier, barbier@localhost"&gt;
            &lt;meta name="Generator" content="WML 2.32.0 (31-Oct-2020)"&gt;
            &lt;meta name="Modified"  content="2000-05-09 23:57:31"&gt;
            &lt;/nostrip&gt;
            &lt;title&gt;Test page 2&lt;/title&gt;&lt;/head&gt;

</pre><h4><b>QUOTING</b> <b>AND</b> <b>GROUPING</b></h4><pre>
       In  HTML  it  is  possible to specify attributes containing several words, by quoting them with single or
       double quotes.  WML knows only double quotes.

         1| &lt;define-tag foo&gt;\
         2| Number of arguments: %#
         3| First argument:      %0
         4| &lt;/define-tag&gt;\
         5| &lt;foo Here are attributes /&gt;\
         6| &lt;foo "Here are" attributes /&gt;\

       Output:

         1| Number of arguments: 3
         2| First argument:      Here
         3| Number of arguments: 2
         4| First argument:      Here are

</pre><h4><b>EXPANSION</b></h4><pre>
       In this section, all examples are processed with the command line

          wml -W2,-dat -q -p123

       and all output lines beginning with "trace" are generated by these debug flags.

       This section is harder to understand, but one can work with WML without understanding it,  because  these
       notions are required in rare cases (mostly when writing macros for WML tutorials).

       By default, macros are expanded when tags are scanned.

       Input:

         1| &lt;define-tag foo&gt;%attributes&lt;/define-tag&gt;\
         2| &lt;define-tag bar&gt;baz&lt;/define-tag&gt;\
         3| &lt;foo name="&lt;bar/&gt;" /&gt;

       Output:

         1| trace: -1- &lt;define-tag foo&gt;
         2| trace: -1- &lt;define-tag bar&gt;
         3| trace: -2- &lt;bar&gt;
         4| trace: -1- &lt;foo name=baz&gt;
         5| name=baz

       We  see  that  the "&lt;bar&gt;" macro is processed first (digit between hyphens represent enesting level), and
       then "&lt;foo&gt;".  Indeed WML finds the "foo" name.  As this is a macro name, attributes  are  searched  for.
       When  scanning  attributes,  it finds the "&lt;bar&gt;".  As this macro has no attribute, it is now replaced by
       its replacement text, after that scanning of "&lt;foo&gt;" attributes is finished.

       Consider now

       Input:

         1| &lt;define-tag foo attributes=verbatim&gt;%attributes&lt;/define-tag&gt;\
         2| &lt;define-tag bar&gt;baz&lt;/define-tag&gt;\
         3| &lt;foo name="&lt;bar/&gt;" /&gt;

       Output:

         1| trace: -1- &lt;define-tag foo&gt;
         2| trace: -1- &lt;define-tag bar&gt;
         3| trace: -2- &lt;bar&gt;
         4| trace: -1- &lt;foo name=&lt;bar&gt;&gt;
         5| trace: -1- &lt;bar&gt;
         6| name=baz

       The "attributes=verbatim" attribute tells WML that when scanning this macro attributes, no  expansion  is
       performed.  So the four first lines are now easy to understand.  But after "&lt;foo&gt;" is expanded into

          name=&lt;bar&gt;

       this text is scanned again and "&lt;bar&gt;" is expanded in turn.

       The solution to forbid this expansion is to use the "U" modifier, explained in section <b>Special</b> <b>Text</b>.

       Input:

         1| &lt;define-tag foo attributes=verbatim&gt;%Uattributes&lt;/define-tag&gt;\
         2| &lt;define-tag bar&gt;baz&lt;/define-tag&gt;\
         3| &lt;foo name="&lt;bar/&gt;" /&gt;

       Output:

         1| trace: -1- &lt;define-tag foo&gt;
         2| trace: -1- &lt;define-tag bar&gt;
         3| trace: -2- &lt;bar&gt;
         4| trace: -1- &lt;foo name=&lt;bar&gt;&gt;
         5| name=&lt;bar&gt;

</pre><h4><b>MIXING</b> <b>MP4H</b> <b>AND</b> <b>EPERL</b></h4><pre>
       After  these  preliminaries  it is time to see how to mix <u>mp4h</u> and <u>ePerl</u>.  The following section is a bit
       tricky, you may skip to section <b>How</b> <b>to</b> <b>use</b> <b>these</b> <b>macros</b> to quickly learn which changes are needed.

   <b>Nested</b> <b>ePerl</b> <b>macros</b> <b>do</b> <b>not</b> <b>work</b>
       Consider this macro:

          &lt;define-tag show-attr&gt;&lt;: print "attrs:%attributes"; :&gt;&lt;/define-tag&gt;

       At first look, it behaves like

          &lt;define-tag show-attr-ok&gt;attrs:%attributes&lt;/define-tag&gt;

       But what happens when these macros are nested?

       Input:

         1| &lt;show-attr-ok &lt;show-attr-ok 0 /&gt; /&gt;

       Output:

         1| attrs:attrs:0

       It works fine!  On the other hand,

       Input:

         1| &lt;show-attr &lt;show-attr 0 /&gt; /&gt;

       Output:

         1| ePerl:Error: Perl parsing error (interpreter rc=255)
         2|
         3| ---- Contents of STDERR channel: ---------
         4| Backslash found where operator expected at /tmp/wml.1183.tmp1.wml line
         5| 10, near ""attrs:&lt;: print attrs:0; print "\"
         6|         (Missing operator before \?)
         7| syntax error at /tmp/wml.1183.tmp1.wml line 10, near ""attrs:&lt;: print
         8| attrs:0; print "\"
         9| Execution of /tmp/wml.1151.tmp1.wml aborted due to compilation errors.
        10| ------------------------------------------
        11| ** WML:Break: Error in Pass 3 (rc=74).

       Huh, looks like something went wrong.  Output after pass 2 is

         1| &lt;: print "attrs:&lt;: print attrs:0; :&gt;"; :&gt;

       And because ePerl commands cannot be nested, an error is reported (if you do not understand why  we  have
       this text after pass 2, reread previous section).

       This  example  is  simplistic,  and a workaround is trivial (use "&lt;show-attr-ok&gt;" instead), but there are
       many cases where these problems are much more difficult to  track.   For  instance  if  you  nest  macros
       defined in WML modules, you do not know whether they use ePerl code or not.

   <b>First</b> <b>try</b> <b>to</b> <b>solve</b> <b>this</b> <b>problem</b>
       One problem is that ePerl commands cannot be nested, according to its documentation.  So our first try is
       to count nested levels and print ePerl delimiters when in outer mode only.

       Input:

         1| &lt;set-var __perl:level=0 /&gt;\
         2| &lt;define-tag perl endtag=required whitespace=delete&gt;
         3| &lt;increment __perl:level /&gt;
         4| &lt;when &lt;eq &lt;get-var __perl:level /&gt; 1 /&gt;&gt;
         5| &lt;: %body :&gt;
         6| &lt;/when&gt;
         7| &lt;when &lt;neq &lt;get-var __perl:level /&gt; 1 /&gt;&gt;
         8| %body
         9| &lt;/when&gt;
        10| &lt;decrement __perl:level /&gt;
        11| &lt;/define-tag&gt;\
        12| &lt;define-tag add1 endtag=required&gt;\
        13| &lt;perl&gt;$a += 1; %body&lt;/perl&gt;\
        14| &lt;/define-tag&gt;\
        15| &lt;add1&gt;&lt;add1&gt;&lt;add1&gt;&lt;/add1&gt;&lt;/add1&gt;&lt;/add1&gt;
        16| &lt;:= $a :&gt;

       Output:

         1|
         2| 3

       Another example (lines 1-11 are left unchanged)

       Input:

        12| &lt;define-tag remove-letter endtag=required whitespace=delete&gt;
        13| &lt;perl&gt;
        14|   $string = q|%body|; $string =~ s|%0||g; print $string;
        15| &lt;/perl&gt;
        16| &lt;/define-tag&gt;\
        17| &lt;remove-letter e&gt;Hello this is a test&lt;/remove-letter&gt;

       Output:

         1| Hllo this is a tst

       With previous definitions, here is what happens when nesting "&lt;remove-letter&gt;" tags:

       Input:

        17| &lt;remove-letter s&gt;&lt;remove-letter e&gt;\
        18| Hello this is a test\
        19| &lt;/remove-letter&gt;&lt;/remove-letter&gt;

       Output:

         1| ePerl:Error: Perl parsing error (interpreter rc=255)
         2|
         3| ---- Contents of STDERR channel: ---------
         4| Bareword found where operator expected at /tmp/wml.1198.tmp1.wml
         5| line 10, near "q|$string = q|Hello"
         6| syntax error at /tmp/wml.1198.tmp1.wml line 10, near "q|$string =
         7| q|Hello this "syntax error at /tmp/wml.1198.tmp1.wml line 10, near ";|"
         8| Execution of /tmp/wml.1198.tmp1.wml aborted due to compilation errors.
         9| ------------------------------------------
        10| ** WML:Break: Error in Pass 3 (rc=74).

       To  understand why this error is reported, we run only the first two passes to see which input is sent to
       ePerl:

           prompt$ wml -q -p12 qaz.wml
           &lt;: $string = q|$string = q|Hello this is a test|; $string =~ s|e||g;
           print $string;|; $string =~ s|s||g; print $string; :&gt;

       As expected ePerl delimiters are only put around the whole sentence, and are not nested.  But we can  see
       this is not sufficient, because the %body directive was replaced by ePerl code, and not a string.

       In  one  word,  there  will  be  trouble whenever special sequences ("%&lt;digit&gt;", %body, %attributes, ...)
       appear within ePerl delimiters, because you can not ensure that replacement text does not  contain  ePerl
       commands too.

   <b>Macros</b> <b>defined</b> <b>by</b> <b>the</b> <b>wml::std::tags</b> <b>module</b>
       The  <u>wml::std::<a href="../man3/tags.3.html">tags</a></u>(3)  module  provides a solution to deal with nested ePerl commands.  Previous example
       may be written like this

       Input:

         1| #use wml::std::tags
         2|
         3| &lt;define-tag remove-letter endtag=required whitespace=delete&gt;
         4| &lt;perl&gt;
         5| &lt;perl:assign $string&gt;%body&lt;/perl:assign&gt;
         6| &lt;perl:assign $letter&gt;%0&lt;/perl:assign&gt;
         7| $string =~ s|$letter||g;
         8| &lt;perl:print: $string /&gt;
         9| &lt;/perl&gt;
        10| &lt;/define-tag&gt;\
        11| &lt;remove-letter s&gt;&lt;remove-letter e&gt;\
        12| Hello this is a test\
        13| &lt;/remove-letter&gt;&lt;/remove-letter&gt;

       Output:

             ...61 empty lines...
         62| Hllo thi i a tt
         63|
         64|

       How this works is beyond the scope of this document, and we  will  focus  on  commands  provided  by  the
       <u>wml::std::tags</u>  module,  and how to use them.  In the list below, pseudo-perl commands show an equivalent
       form of these macros.

       &lt;perl:var /&gt;
         This macro expands to a Perl variable, which is different in all nested levels.

             $perl_var&lt;get-var __perl:level /&gt;

       &lt;perl:print&gt;string&lt;/perl:print&gt;
         This complex tag prints its body.

            print qq(string);

       &lt;perl:print: string /&gt;
         This simple tag prints its attributes.

            print string;

       &lt;perl:print:var /&gt;
         Prints the "&lt;perl:var&gt;" variable

           print $perl_var&lt;get-var __perl:level /&gt;;

       &lt;perl:assign $variable&gt;value&lt;/perl:assign&gt;
         Assign a Perl variable.  If there is no attribute, value is assigned to "&lt;perl:var&gt;".

            $variable = qq(value);

       &lt;perl:assign:sq $variable&gt;value&lt;/perl:assign&gt;
         Assign a Perl variable.  If there is no attribute, value is assigned to "&lt;perl:var&gt;".

            $variable = q(value);

   <b>How</b> <b>to</b> <b>use</b> <b>these</b> <b>macros</b>
       Now that we know our problem has a solution, you are certainly impatient to learn how to proceed.   There
       are two golden rules:

       1.
         Never write special sequences ("%&lt;digit&gt;", %body, %attributes, ...) inside a Perl statement.

       2.
         Never use the Perl "print" statement, nor its derivatives.

       First rule tells to replace

         $var1 = qq|%body|;
         $var2 = q|%body|;

       by

         &lt;perl:assign $var1&gt;%body&lt;/perl:assign&gt;
         &lt;perl:assign:sq $var2&gt;%body&lt;/perl:assign:sq&gt;

       and second rule

         print $string;
         print "&lt;img src=\"$src\" alt=\"$alt\"&gt;";

       by

         &lt;perl:print: $string&gt;
         &lt;perl:print&gt;&lt;img src="$src" alt="$alt"&gt;&lt;/perl:print&gt;

   <b>Examples</b>
       Example 1: simplified version of "wml::des::lowsrc"

       Non-nestable version:

         &lt;define-tag lowsrc&gt;
         &lt;:
         {
             my $src = '%0';
             my $lowsrc = $src;
             $lowsrc =~ s|\.([^.]+)$|.lowsrc.$1|;
             system("convert -monochrome $src $lowsrc");
             print "lowsrc=\"$lowsrc\"";
         }
         :&gt;
         &lt;/define-tag&gt;

       Nestable version:

         &lt;define-tag lowsrc&gt;
         &lt;perl&gt;
         {
             my $src;
             &lt;perl:assign:sq $src&gt;%0&lt;/perl:assign:sq&gt;
             my $lowsrc = $src;
             $lowsrc =~ s|\.([^.]+)$|.lowsrc.$1|;
             system("convert -monochrome $src $lowsrc");
             &lt;perl:print&gt; lowsrc="$lowsrc"&lt;/perl:print&gt;
         }
         &lt;/perl&gt;
         &lt;/define-tag&gt;

       The  first  change (assignment to $src) allows attribute to be an ePerl command, and second change (print
       result) allows this macro to appear inside ePerl commands.  As you see, this is  fairly  straightforward,
       and you may look how WML modules are written.

       In  all  previous  examples  and definitions, output was printed to standard output.  But sometimes it is
       printed to filehandles.  Here is how to proceed, with an example taken from "wml::fmt::xtable".

       Non-nestable version:

         &lt;define-tag xtable endtag=required&gt;
         &lt;:
         {
             my $options = qq|%attributes|;
             my $tmpfile = "&lt;get-var WML_TMPDIR&gt;/wml.table.$$.tmp";
             local (*FP);
             open(FP, "&gt;$tmpfile");
             print FP "&lt;" . "wwwtable $options&gt;\n";
             print FP &lt;&lt;'__XTABLE__EOT'
         %body
         __XTABLE__EOT
         ;
             print FP "&lt;" . "/wwwtable&gt;\n";
             close(FP);
             open(FP, "$WML_LOC_LIBDIR/exec/freetable -w $tmpfile|");
             local ($/) = undef;
             print &lt;FP&gt;;
             close(FP);
             unlink("$tmpfile");
         }
         :&gt;
         &lt;/define-tag&gt;

       Nestable version:

         &lt;set-var __xtable:level=0 /&gt;
         &lt;define-tag xtable endtag=required&gt;
         &lt;increment __xtable:level /&gt;
         &lt;perl filehandle="FH_XTABLE"&gt;
         {
             my $tmpfile = "&lt;get-var WML_TMPDIR /&gt;/wml.table.$$.tmp";
             my $options;
             &lt;perl:assign $options&gt;%attributes&lt;/perl:assign&gt;;
             &lt;when &lt;eq &lt;get-var __xtable:level /&gt; 1 /&gt;&gt;
             local *FH_XTABLE;
             open(FH_XTABLE, "&gt;$tmpfile");
             &lt;/when&gt;
             &lt;perl:assign&gt;
             &lt;wwwtable $options&gt;
                 %body
             &lt;/wwwtable&gt;
             &lt;/perl:assign&gt;
         &lt;/perl&gt;
         #   we cut here to change filehandle
         &lt;perl&gt;
             &lt;when &lt;eq &lt;get-var __xtable:level /&gt; 1 /&gt;&gt;
             print FH_XTABLE &lt;perl:var/&gt;;
             close(FH_XTABLE);
             open(FH_XTABLE_IN,
                "&lt;get-var WML_LOC_LIBDIR /&gt;/exec/freetable -w $tmpfile |");
             local ($/) = undef;
             #  The asterisk below prevents expansion during pass 2 and is
             #  removed after this pass.
             &lt;perl:var/&gt; = &lt;*FH_XTABLE_IN&gt;;
             close(FH_XTABLE_IN);
             &lt;perl:print:var/&gt;
             unlink("$tmpfile");
             &lt;/when&gt;
         }
         &lt;/perl&gt;
         &lt;decrement __xtable:level /&gt;
         &lt;/define-tag&gt;

       Filehandles are defined via attributes to the "perl" tag.  All subsequent  calls  to  "&lt;perl:print&gt;"  are
       then printed to this filehandle.

</pre><h4><b>AUTHOR</b></h4><pre>
        Denis Barbier
        <a href="mailto:barbier@engelschall.com">barbier@engelschall.com</a>

EN Tools                                           2020-11-29                                      <u><a href="../man7/WML_MACROS.7.html">WML_MACROS</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>