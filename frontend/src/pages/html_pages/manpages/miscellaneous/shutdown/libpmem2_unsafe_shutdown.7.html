<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpmem2_unsafe_shutdown - libpmem2 unsafe shutdown</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmem2-dev">libpmem2-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>libpmem2_unsafe_shutdown</b> - libpmem2 unsafe shutdown

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In  systems  with  the persistent memory support, <u>a</u> <u>power-fail</u> <u>protected</u> <u>domain</u> covers a set of resources
       from which the platform will flush data to <u>the</u> <u>persistent</u> <u>medium</u> in case of <u>a</u> <u>power-failure</u>.  Data stored
       on <u>the</u> <u>persistent</u> <u>medium</u> is preserved across power cycles.

       The hardware guarantees the feature to flush all data stored in <u>the</u> <u>power-fail</u> <u>protected</u>  <u>domain</u>  to  <u>the</u>
       <u>persistent</u> <u>medium</u>.  However, nothing is infallible, and Persistent Memory hardware can expose a monotoni‐
       cally  increasing <u>unsafe</u> <u>shutdown</u> <u>counter</u> (<b>USC</b>) that is incremented every time a failure of the mechanism
       above is detected.  This allows software to discover situations where a running  application  was  inter‐
       rupted  by  a  power  failure  that led to an unsafe shutdown.  Undiscovered unsafe shutdowns might cause
       silent data corruption.

              Note: <u>The</u> <u>unsafe</u> <u>shutdown</u> may corrupt data stored on a device, in a file, in a set of files, and a
              mapping spanning only a part of a file.  For the sake of simplicity, all of the above  cases  will
              be called <u>file</u> below.

</pre><h4><b>UNSAFE</b> <b>SHUTDOWN</b> <b>DETECTION</b></h4><pre>
       Software  can  detect  an  unsafe shutdown by watching for the change between unsafe shutdown count value
       across application startups.  Any changes can be indicative of unsafe shutdown occurrence.

       Applications can implement a detection mechanism by  storing  the  <b>USC</b>  retrieved  from  <b>pmem2_source_de‐</b>
       <b><a href="../man3/vice_usc.3.html">vice_usc</a></b>(3) in Persistent Memory.  Then, on subsequent startups, the stored value must be compared with a
       newly retrieved one.

       However,  this  detection  method can result in false-positives.  Moving the file to different Persistent
       Memory devices with possibly different <b>USC</b> values would lead to false unsafe shutdown detection.

       Additionally, relying on <b>USC</b> value alone could result in the detection of unsafe shutdown events that oc‐
       cur when such a shutdown has no chance of impacting the data used by the application, e.g., when  nothing
       is actively using the file.

       Applications  can avoid false-positives associated with moving the file by storing device identification,
       obtained through <b><a href="../man3/pmem2_source_device_id.3.html">pmem2_source_device_id</a></b>(3), alongside the <b>USC</b>.  This enables the software to check if the
       underlying device has changed, and reinitialize the stored <b>USC</b> in such cases.

       The second behavior, detection of possibly irrelevant unsafe shutdown events, if undesirable, can be pre‐
       vented by storing a flag indicating whether the file is in use, alongside all the rest  of  the  relevant
       information.

       The application should use <b><a href="../man3/pmem2_deep_flush.3.html">pmem2_deep_flush</a></b>(3) when storing any data related to unsafe shutdown detection
       for  higher  reliability.   This  helps ensure that the detection mechanism is not reliant on the correct
       functioning of the same hardware features it is designed to safeguard.

       General-purpose software should not assume the presence of <b>USC</b> on the platform, and should instead appro‐
       priately handle any <u>PMEM2_E_NOSUPP</u> it encounters.  Doing otherwise might cause the software to be  unnec‐
       essarily restrictive about the hardware it supports and would prevent, e.g., testing on emulated PMEM.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/pmem2_deep_flush.3.html">pmem2_deep_flush</a></b>(3),   <b><a href="../man3/pmem2_persist_fn.3.html">pmem2_persist_fn</a></b>(3),   <b><a href="../man3/pmem2_source_device_id.3.html">pmem2_source_device_id</a></b>(3),  <b><a href="../man3/pmem2_source_device_usc.3.html">pmem2_source_device_usc</a></b>(3)  and
       <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>