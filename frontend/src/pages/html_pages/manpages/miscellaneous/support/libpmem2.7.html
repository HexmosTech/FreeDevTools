<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpmem2 - persistent memory support library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmem2-dev">libpmem2-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>libpmem2</b> - persistent memory support library

              NOTE:  Support for Windows and FreeBSD deprecated since PMDK 1.13.0 release and will be removed in
              the PMDK 1.14.0 release.

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmem2.h&gt;
              cc ... -lpmem2

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libpmem2</b> provides low-level <u>persistent</u> <u>memory</u> (pmem) support for applications using direct access storage
       (DAX), which is storage that supports load/store access without paging blocks from a  block  storage  de‐
       vice.   Some types of <u>non-volatile</u> <u>memory</u> <u>DIMMs</u> (NVDIMMs) provide this type of byte addressable access to
       storage.  A <u>persistent</u> <u>memory</u> <u>aware</u> <u>file</u> <u>system</u> is typically used to expose the direct access to applica‐
       tions.  Memory mapping a file from this type of file system results in the load/store,  non-paged  access
       to pmem.

       This  library  is  for applications that use persistent memory directly, without the help of any library-
       supplied transactions or memory allocation.  Higher-level libraries that <u>currently</u> build on <b>libpmem</b> (pre‐
       vious variation of libpmem2) are available and are recommended for most applications, see:

       • <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7), a general use persistent memory API, providing memory allocation and transactional oper‐
         ations on variable-sized objects.

       • <b><a href="../man7/libpmemblk.7.html">libpmemblk</a></b>(7), providing pmem-resident arrays of fixed-sized blocks with atomic updates.

       • <b><a href="../man7/libpmemlog.7.html">libpmemlog</a></b>(7), providing a pmem-resident log file.

       The <b>libpmem2</b> library provides a comprehensive set of functions for robust use of Persistent  Memory.   It
       relies  on  three core concepts: <u>struct</u> <u>pmem2_src</u> <u>source</u>, <u>struct</u> <u>pmem2_config</u> <u>config</u> and <u>struct</u> <u>pmem2_map</u>
       <u>map</u>:

       • <u>source</u> - an object describing the data source for mapping.  The data source can be a file descriptor, a
         file handle, or an anonymous mapping.  APIs dedicated for creating <u>source</u> are: <b><a href="../man3/pmem2_source_from_fd.3.html">pmem2_source_from_fd</a></b>(3),
         <b><a href="../man3/pmem2_source_from_handle.3.html">pmem2_source_from_handle</a></b>(3), <b><a href="../man3/pmem2_source_from_anon.3.html">pmem2_source_from_anon</a></b>(3).

       • <u>config</u> - an object containing parameters that are used to create a mapping from a <u>source</u>.  The configu‐
         ration structure must always be provided to create a mapping, but the only required parameter to set in
         the <u>config</u> is <u>granularity</u>.  The granularity should by set using dedicated <b>libpmem2</b> function  <b>pmem2_con‐</b>
         <b><a href="../man3/fig_set_required_store_granularity.3.html">fig_set_required_store_granularity</a></b>(3)  which  defines  a maximum permitted granularity requested by the
         user.  For more information about the granularity concept read <b>GRANULARITY</b> section below.

       In addition to the granularity setting, libpmem2 provides multiple optional functions to configure target
       mapping, e.g., <b><a href="../man3/pmem2_config_set_length.3.html">pmem2_config_set_length</a></b>(3) to set length which will be used  for  mapping,  or  <b>pmem2_con‐</b>
       <b><a href="../man3/fig_set_offset.3.html">fig_set_offset</a></b>(3)  which  will  be  used  to  map the contents from the specified location of the source,
       <b><a href="../man3/pmem2_config_set_sharing.3.html">pmem2_config_set_sharing</a></b>(3) which defines the behavior and visibility of writes to the mapping’s pages.

       • <u>map</u> - an object created by <b><a href="../man3/pmem2_map_new.3.html">pmem2_map_new</a></b>(3) using <u>source</u> and <u>config</u> as an input  parameters.   The  map
         structure can be then used to directly operate on the created mapping through the use of its associated
         set of functions: <b><a href="../man3/pmem2_map_get_address.3.html">pmem2_map_get_address</a></b>(3), <b><a href="../man3/pmem2_map_get_size.3.html">pmem2_map_get_size</a></b>(3), <b><a href="../man3/pmem2_map_get_store_granularity.3.html">pmem2_map_get_store_granularity</a></b>(3) -
         for getting address, size and effective mapping granularity.

       In  addition  to  the basic functionality of managing the virtual address mapping, <b>libpmem2</b> also provides
       optimized functions for modifying the mapped data.  This includes data flushing as well as  memory  copy‐
       ing.

       To  get  proper  function  for  data  flushing  use:  <b><a href="../man3/pmem2_get_flush_fn.3.html">pmem2_get_flush_fn</a></b>(3),  <b><a href="../man3/pmem2_get_persist_fn.3.html">pmem2_get_persist_fn</a></b>(3)  or
       <b><a href="../man3/pmem2_get_drain_fn.3.html">pmem2_get_drain_fn</a></b>(3).  To get proper function  for  copying  to  persistent  memory,  use  <u>map</u>  getters:
       <b><a href="../man3/pmem2_get_memcpy_fn.3.html">pmem2_get_memcpy_fn</a></b>(3), <b><a href="../man3/pmem2_get_memset_fn.3.html">pmem2_get_memset_fn</a></b>(3), <b><a href="../man3/pmem2_get_memmove_fn.3.html">pmem2_get_memmove_fn</a></b>(3).

       The <b>libpmem2</b> API also provides support for the badblock and unsafe shutdown state handling.

       To  read  or  clear  badblocks,  the  following  functions  are  provided: <b><a href="../man3/pmem2_badblock_context_new.3.html">pmem2_badblock_context_new</a></b>(3),
       <b><a href="../man3/pmem2_badblock_context_delete.3.html">pmem2_badblock_context_delete</a></b>(3), <b><a href="../man3/pmem2_badblock_next.3.html">pmem2_badblock_next</a></b>(3) and <b><a href="../man3/pmem2_badblock_clear.3.html">pmem2_badblock_clear</a></b>(3).

       To handle unsafe shutdown in the application, the  following  functions  are  provided:  <b>pmem2_source_de‐</b>
       <b><a href="../man3/vice_id.3.html">vice_id</a></b>(3),  <b><a href="../man3/pmem2_source_device_usc.3.html">pmem2_source_device_usc</a></b>(3).   More  detailed information about unsafe shutdown detection and
       unsafe shutdown count can be found in the <b><a href="../man7/libpmem2_unsafe_shutdown.7.html">libpmem2_unsafe_shutdown</a></b>(7) man page.

</pre><h4><b>GRANULARITY</b></h4><pre>
       The <b>libpmem2</b> library introduces the concept of granularity through which you may easily  distinguish  be‐
       tween  different  levels  of  storage performance capabilities available to the application as related to
       <u>power-fail</u> <u>protected</u> <u>domain</u>.  The way data reaches this protected domain differs based  on  the  platform
       and storage device capabilities.

       Traditional block storage devices (SSD, HDD) must use system API calls such as msync(), fsync() on Linux,
       or  FlushFileBuffers(),FlushViewOfFile()  on  Windows  to  write data reliably.  Invoking these functions
       flushes the data to the medium with page granularity.  In the <b>libpmem2</b> library, this type of flushing be‐
       havior is called <b>PMEM2_GRANULARITY_PAGE</b>.

       In systems with persistent memory support, a <u>power-fail</u> <u>protected</u> <u>domain</u> may cover different sets of  re‐
       sources: either the memory controller or the memory controller and CPU caches.  For this reason, <b>libpmem2</b>
       distinguishes   two   types  of  granularity  for  persistent  memory:  <b>PMEM2_GRANULARITY_CACHE_LINE</b>  and
       <b>PMEM2_GRANULARITY_BYTE</b>.

       If the <u>power-fail</u> <u>protected</u> <u>domain</u> covers only the memory controller, the  CPU  appropriate  cache  lines
       must  be  flushed for the data to be considered persistent.  This granularity type is called <b>PMEM2_GRANU‐</b>
       <b>LARITY_CACHE_LINE</b>.  Depending on the architecture, there are different types of machine instructions  for
       flushing <u>cache</u> <u>lines</u> (e.g., <u>CLWB</u>, <u>CLFLUSHOPT</u>, <u>CLFLUSH</u> for Intel x86_64 architecture).  Usually, to ensure
       the ordering of stores, such instructions must be followed by a barrier (e.g., <u>SFENCE</u>).

       The  third type of granularity <b>PMEM2_GRANULARITY_BYTE</b> applies to platforms where <u>power-fail</u> <u>protected</u> <u>do‐</u>
       <u>main</u> covers both the memory controller and CPU caches.  In such cases, cache flush  instructions  are  no
       longer  needed,  and the platform itself guarantees the persistence of data.  But barriers might still be
       required for ordering.

       The library declares these granularity level in <u>pmem2_granularity</u> enum, which the application must set in
       <u>pmem2_config</u> to the appropriate level for a mapping to succeed.  The software should set this config  pa‐
       rameter  to  a  value that most accurately represents the target hardware characteristics and the storage
       patterns of the application.  For example, a database storage engine that operates on large logical pages
       that reside either on SSDs or PMEM should set this value to  <b>PMEM2_GRANULARITY_PAGE</b>.   The  library  will
       create  mappings  where  the  new map granularity is lower or equal to the requested one.  For example, a
       mapping with <b>PMEM2_GRANULARITY_CACHE_LINE</b> can be created for the  required  granularity  <b>PMEM2_GRANULARI‐</b>
       <b>TY_PAGE</b>, but not vice versa.

</pre><h4><b>CAVEATS</b></h4><pre>
       <b>libpmem2</b>  relies on the library destructor being called from the main thread.  For this reason, all func‐
       tions that might trigger destruction (e.g. <a href="../man3/dlclose.3.html">dlclose</a>(3)) should be called in the  main  thread.   Otherwise
       some of the resources associated with that thread might not be cleaned up properly.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>libpmem2</b> can change its default behavior based on the following environment variables.  These are primar‐
       ily intended for testing and are generally not required.

       • <b>PMEM2_FORCE_GRANULARITY</b>=<u>val</u>

       Setting this environment variable to <u>val</u> forces <b>libpmem2</b> to use persist method specific for forced granu‐
       larity  and  skip  granularity  autodetecting  mechanism.  The concept of the granularity is described in
       <u>GRANULARITY</u> section above.  This variable is intended for use during library testing.

       The <u>val</u> argument accepts following text values:

       • <b>BYTE</b> - force byte granularity.

       • <b>CACHE_LINE</b> - force cache line granularity.

       • <b>PAGE</b> - force page granularity.

       Granularity values listed above are case-insensitive.

              NOTE: The value of <b>PMEM2_FORCE_GRANULARITY</b> is not queried (and cached) at  library  initialization
              time, but read during each <b><a href="../man3/pmem2_map_new.3.html">pmem2_map_new</a></b>(3) call.

       This  means  that <b>PMEM2_FORCE_GRANULARITY</b> may still be set or modified by the program until the first at‐
       tempt to map a file.

       • <b>PMEM_NO_CLWB</b>=1

       Setting this environment variable to 1 forces <b>libpmem2</b> to never issue the <b>CLWB</b> instruction on Intel hard‐
       ware, falling back to other cache flush instructions on that hardware instead  (<b>CLFLUSHOPT</b>  or  <b>CLFLUSH</b>).
       Without  this  setting,  <b>libpmem2</b>  will  always use the <b>CLWB</b> instruction for flushing processor caches on
       platforms that support this instruction.  This variable is intended for use during library  testing,  but
       may be required for some rare cases when using <b>CLWB</b> has a negative impact on performance.

       • <b>PMEM_NO_CLFLUSHOPT</b>=1

       Setting this environment variable to 1 forces <b>libpmem2</b> to never issue the <b>CLFLUSHOPT</b> instruction on Intel
       hardware,  falling back to the <b>CLFLUSH</b> instructions instead.  Without this environment variable, <b>libpmem2</b>
       will always use the <b>CLFLUSHOPT</b> instruction for flushing processor caches on platforms  that  support  the
       instruction, but where <b>CLWB</b> is not available.  This variable is intended for use during library testing.

       • <b>PMEM_NO_MOVNT</b>=1

       Setting this environment variable to 1 forces <b>libpmem2</b> to never use the <u>non-temporal</u> move instructions on
       Intel  hardware.   Without this environment variable, <b>libpmem2</b> will use the non-temporal instructions for
       copying larger ranges to persistent memory on platforms that support these instructions.   This  variable
       is intended for use during library testing.

       • <b>PMEM_MOVNT_THRESHOLD</b>=<u>val</u>

       This  environment  variable  allows overriding the minimum length of the <u>pmem2_memmove_fn</u> operations, for
       which <b>libpmem2</b> uses <u>non-temporal</u> move instructions.  Setting this environment variable to 0 forces  <b>libp‐</b>
       <b>mem2</b> to always use the <u>non-temporal</u> move instructions if available.  It has no effect if <b>PMEM_NO_MOVNT</b> is
       set to 1.  This variable is intended for use during library testing.

</pre><h4><b>DEBUGGING</b></h4><pre>
       Two  versions  of <b>libpmem2</b> are typically available on a development system.  The normal version, accessed
       when a program is linked using the <b>-lpmem2</b> option, is optimized  for  performance.   That  version  skips
       checks that impact performance and never logs any trace information or performs any run-time assertions.

       A  second version of <b>libpmem2</b>, accessed when a program uses the libraries under <b>/usr/lib/pmdk_debug</b>, con‐
       tains run-time assertions and trace points.  The typical way to access the debug version is  to  set  the
       environment  variable  <b>LD_LIBRARY_PATH</b>  to  <b>/usr/lib/pmdk_debug</b> or <b>/usr/lib64/pmdk_debug</b>, as appropriate.
       Debugging output is controlled using the following environment variables.  These variables have no effect
       on the non-debug version of the library.

              NOTE: On Debian/Ubuntu systems, this extra debug version of the library is shipped in the  respec‐
              tive <b>-debug</b> Debian package and placed in the <b><a href="file:/usr/lib/">/usr/lib/</a>$ARCH/pmdk_dbg/</b> directory.

       • <b>PMEM2_LOG_LEVEL</b>

       The value of <b>PMEM2_LOG_LEVEL</b> enables trace points in the debug version of the library, as follows:

       • <b>0</b>  -  This  is  the default level when <b>PMEM2_LOG_LEVEL</b> is not set.  No log messages are emitted at this
         level.

       • <b>1</b> - Additional details on any errors detected are logged, in addition to returning the <u>errno</u>-based  er‐
         rors as usual.  The same information may be retrieved using <b>pmem2_errormsg</b>().

       • <b>2</b> - A trace of basic operations is logged.

       • <b>3</b> - Enables a very verbose amount of function call tracing in the library.

       • <b>4</b>  -  Enables voluminous and fairly obscure tracing information that is likely only useful to the <b>libp‐</b>
         <b>mem2</b> developers.

       Unless <b>PMEM2_LOG_FILE</b> is set, debugging output is written to <u>stderr</u>.

       • <b>PMEM2_LOG_FILE</b>

       Specifies the name of a file where all logging information should be written.  If the last  character  in
       the  name  is  “-”, the <u>PID</u> of the current process will be appended to the file name when the log file is
       created.  If <b>PMEM2_LOG_FILE</b> is not set, output is written to <u>stderr</u>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example uses <b>libpmem2</b> to flush changes made to raw, memory-mapped persistent memory.

              WARNING: There is nothing transactional about the <u>persist</u>  from  <b><a href="../man3/pmem2_get_persist_fn.3.html">pmem2_get_persist_fn</a></b>(3)  call  in
              this example.  Interrupting the program may result in a partial write to pmem.  Use a transaction‐
              al library such as <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) to avoid torn updates.

       The  basic  example  can  be  found  in  the  repository  under  path src/examples/libpmem2/basic/basic.c
       (https://github.com/pmem/pmdk/blob/master/src/examples/libpmem2/basic/basic.c).  It is described  in  de‐
       tail here (https://pmem.io/pmdk/libpmem2/).

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       <b>libpmem2</b>  builds on the persistent memory programming model recommended by the SNIA NVM Programming Tech‐
       nical Work Group: &lt;https://snia.org/nvmp&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>FlushFileBuffers</b>(),   <b><a href="../man2/fsync.2.html">fsync</a></b>(2),   <b><a href="../man2/msync.2.html">msync</a></b>(2),    <b><a href="../man3/pmem2_config_set_length.3.html">pmem2_config_set_length</a></b>(3),    <b><a href="../man3/pmem2_config_set_offset.3.html">pmem2_config_set_offset</a></b>(3),
       <b><a href="../man3/pmem2_config_set_required_store_granularity.3.html">pmem2_config_set_required_store_granularity</a></b>(3),        <b><a href="../man3/pmem2_config_set_sharing.3.html">pmem2_config_set_sharing</a></b>(3),<b><a href="../man3/pmem2_get_drain_fn.3.html">pmem2_get_drain_fn</a></b>(3),
       <b><a href="../man3/pmem2_get_flush_fn.3.html">pmem2_get_flush_fn</a></b>(3),    <b><a href="../man3/pmem2_get_memcpy_fn.3.html">pmem2_get_memcpy_fn</a></b>(3),    <b><a href="../man3/pmem2_get_memmove_fn.3.html">pmem2_get_memmove_fn</a></b>(3),     <b><a href="../man3/pmem2_get_memset_fn.3.html">pmem2_get_memset_fn</a></b>(3),
       <b><a href="../man3/pmem2_get_persist_fn.3.html">pmem2_get_persist_fn</a></b>(3),<b><a href="../man3/pmem2_map_get_store_granularity.3.html">pmem2_map_get_store_granularity</a></b>(3),  <b><a href="../man3/pmem2_map_new.3.html">pmem2_map_new</a></b>(3), <b><a href="../man3/pmem2_source_from_anon.3.html">pmem2_source_from_anon</a></b>(3),
       <b><a href="../man3/pmem2_source_from_fd.3.html">pmem2_source_from_fd</a></b>(3), <b><a href="../man3/pmem2_source_from_handle.3.html">pmem2_source_from_handle</a></b>(3), <b><a href="../man7/libpmem2_unsafe_shutdown.7.html">libpmem2_unsafe_shutdown</a></b>(7),  <b><a href="../man7/libpmemblk.7.html">libpmemblk</a></b>(7),  <b>libp‐</b>
       <b><a href="../man7/memlog.7.html">memlog</a></b>(7), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>