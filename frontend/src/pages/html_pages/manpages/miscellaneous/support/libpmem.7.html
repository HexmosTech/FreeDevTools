<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpmem - persistent memory support library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpmem-dev">libpmem-dev_1.13.1-1.1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>libpmem</b> - persistent memory support library

              NOTE: Support for Windows and FreeBSD are deprecated since PMDK 1.13.0 release and will be removed
              in the PMDK 1.14.0 release.

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;libpmem.h&gt;
              cc ... -lpmem

   <b>Library</b> <b>API</b> <b>versioning:</b>
              const char *pmem_check_version(
                  unsigned major_required,
                  unsigned minor_required);

   <b>Error</b> <b>handling:</b>
              const char *pmem_errormsg(void);

   <b>Other</b> <b>library</b> <b>functions:</b>
       A description of other <b>libpmem</b> functions can be found on the following manual pages:

       • most commonly used functions: <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3)

       • partial flushing operations: <b><a href="../man3/pmem_flush.3.html">pmem_flush</a></b>(3)

       • copying to persistent memory: <b><a href="../man3/pmem_memmove_persist.3.html">pmem_memmove_persist</a></b>(3)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libpmem</b>  provides low-level <u>persistent</u> <u>memory</u> (pmem) support for applications using direct access storage
       (DAX), which is storage that supports load/store access without paging blocks from a  block  storage  de‐
       vice.   Some types of <u>non-volatile</u> <u>memory</u> <u>DIMMs</u> (NVDIMMs) provide this type of byte addressable access to
       storage.  A <u>persistent</u> <u>memory</u> <u>aware</u> <u>file</u> <u>system</u> is typically used to expose the direct access to applica‐
       tions.  Memory mapping a file from this type of file system results in the load/store,  non-paged  access
       to pmem.

       This  library  is  for applications that use persistent memory directly, without the help of any library-
       supplied transactions or memory allocation.  Higher-level libraries that build on <b>libpmem</b>  are  available
       and are recommended for most applications, see:

       • <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7), a general use persistent memory API, providing memory allocation and transactional oper‐
         ations on variable-sized objects.

       • <b><a href="../man7/libpmemblk.7.html">libpmemblk</a></b>(7), providing pmem-resident arrays of fixed-sized blocks with atomic updates.

       • <b><a href="../man7/libpmemlog.7.html">libpmemlog</a></b>(7), providing a pmem-resident log file.

       Under  normal  usage,  <b>libpmem</b> will never print messages or intentionally cause the process to exit.  The
       only exception to this is the debugging information, when enabled, as described under <b>DEBUGGING</b> <b>AND</b> <b>ERROR</b>
       <b>HANDLING</b> below.

</pre><h4><b>CAVEATS</b></h4><pre>
       <b>libpmem</b> relies on the library destructor being called from the main thread.  For this reason,  all  func‐
       tions  that  might trigger destruction (e.g.  <b><a href="../man3/dlclose.3.html">dlclose</a></b>(3)) should be called in the main thread.  Otherwise
       some of the resources associated with that thread might not be cleaned up properly.

</pre><h4><b>LIBRARY</b> <b>API</b> <b>VERSIONING</b></h4><pre>
       This section describes how the library API is versioned, allowing applications to work with  an  evolving
       API.

       The <b>pmem_check_version</b>() function is used to determine whether the installed <b>libpmem</b> supports the version
       of the library API required by an application.  The easiest way to do this is for the application to sup‐
       ply the compile-time version information, supplied by defines in <b>&lt;libpmem.h&gt;</b>, like this:

              reason = pmem_check_version(PMEM_MAJOR_VERSION,
                                          PMEM_MINOR_VERSION);
              if (reason != NULL) {
                  /* version check failed, reason string tells you why */
              }

       Any  mismatch  in the major version number is considered a failure, but a library with a newer minor ver‐
       sion number will pass this check since increasing minor versions imply backwards compatibility.

       An application can also check specifically for the existence of an interface by checking for the  version
       where  that  interface was introduced.  These versions are documented in this man page as follows: unless
       otherwise specified, all interfaces described here are available in version 1.0 of the  library.   Inter‐
       faces added after version 1.0 will contain the text <u>introduced</u> <u>in</u> <u>version</u> <u>x.y</u> in the section of this man‐
       ual describing the feature.

       When the version check performed by <b>pmem_check_version</b>() is successful, the return value is NULL.  Other‐
       wise the return value is a static string describing the reason for failing the version check.  The string
       returned by <b>pmem_check_version</b>() must not be modified or freed.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>libpmem</b>  can change its default behavior based on the following environment variables.  These are largely
       intended for testing and are not normally required.

       • <b>PMEM_IS_PMEM_FORCE</b>=<u>val</u>

       If <u>val</u>  is  0  (zero),  then  <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3)  will  always  return  false.   Setting  <u>val</u>  to  1  causes
       <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3) to always return true.  This variable is mostly used for testing but can be used to force
       pmem behavior on a system where a range of pmem is not detectable as pmem for some reason.

              NOTE:  Unlike  the other variables, the value of <b>PMEM_IS_PMEM_FORCE</b> is not queried (and cached) at
              library initialization time, but on the first call to <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3).  This means that in case of
              <b><a href="../man7/libpmemlog.7.html">libpmemlog</a></b>(7), <b><a href="../man7/libpmemblk.7.html">libpmemblk</a></b>(7), and <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7), <b>PMEM_IS_PMEM_FORCE</b> may still be set  or  modified
              by the program until the first attempt to create or open the persistent memory pool.

       • <b>PMEM_NO_CLWB</b>=1

       Setting  this environment variable to 1 forces <b>libpmem</b> to never issue the <b>CLWB</b> instruction on Intel hard‐
       ware, falling back to other cache flush instructions instead (<b>CLFLUSHOPT</b> or <b>CLFLUSH</b> on  Intel  hardware).
       Without  this  environment  variable, <b>libpmem</b> will always use the <b>CLWB</b> instruction for flushing processor
       caches on platforms that support the instruction.  This variable is intended for use during library test‐
       ing but may be required for some rare cases where using <b>CLWB</b> has a negative impact on performance.

       • <b>PMEM_NO_CLFLUSHOPT</b>=1

       Setting this environment variable to 1 forces <b>libpmem</b> to never issue the <b>CLFLUSHOPT</b> instruction on  Intel
       hardware,  falling  back to the <b>CLFLUSH</b> instructions instead.  Without this environment variable, <b>libpmem</b>
       will always use the <b>CLFLUSHOPT</b> instruction for flushing processor caches on platforms  that  support  the
       instruction, but where <b>CLWB</b> is not available.  This variable is intended for use during library testing.

       • <b>PMEM_NO_FLUSH</b>=1

       Setting  this  environment  variable  to  1  forces most <b>libpmem</b> functions to never issue any of <b>CLFLUSH</b>,
       <b>CLFLUSHOPT</b> or <b>CLWB</b> instructions on Intel  hardware.   The  only  exceptions  are  <b><a href="../man3/pmem_deep_flush.3.html">pmem_deep_flush</a></b>(3)  and
       <b><a href="../man3/pmem_deep_persist.3.html">pmem_deep_persist</a></b>(3) functions.

       • <b>PMEM_NO_FLUSH</b>=0

       Setting this environment variable to 0 forces to always flush CPU caches using one of <b>CLFLUSH</b>, <b>CLFLUSHOPT</b>
       or  <b>CLWB</b>  instructions  even  if  <b><a href="../man3/pmem_has_auto_flush.3.html">pmem_has_auto_flush</a></b>(3)  function returns true and the platform supports
       flushing the processor caches on power loss or system crash.

       • <b>PMEM_NO_MOVNT</b>=1

       Setting this environment variable to 1 forces <b>libpmem</b> to never use the <u>non-temporal</u> move instructions  on
       Intel  hardware.   Without  this environment variable, <b>libpmem</b> will use the non-temporal instructions for
       copying larger ranges to persistent memory on platforms that support the instructions.  This variable  is
       intended for use during library testing.

       • <b>PMEM_MOVNT_THRESHOLD</b>=<u>val</u>

       This environment variable allows overriding the minimum length of the <b><a href="../man3/pmem_memmove_persist.3.html">pmem_memmove_persist</a></b>(3) operations,
       for  which  <b>libpmem</b>  uses  <u>non-temporal</u> move instructions.  Setting this environment variable to 0 forces
       <b>libpmem</b> to always use the <u>non-temporal</u> move instructions if available.  It has no effect if <b>PMEM_NO_MOVNT</b>
       is set to 1.  This variable is intended for use during library testing.

       • <b>PMEM_MMAP_HINT</b>=<u>val</u>

       This environment variable allows overriding the hint address used by <b>pmem_map_file</b>().  If  set,  it  also
       disables mapping address randomization.  This variable is intended for use during library testing and de‐
       bugging.   Setting  it to some fairly large value (i.e. 0x10000000000) will very likely result in mapping
       the file at the specified address (if not used) or at the first unused region above given address,  with‐
       out  adding  any  random offset.  When debugging, this makes it easier to calculate the actual address of
       the persistent memory block, based on its offset in the file.  In case of <b>libpmemobj</b> it  simplifies  con‐
       version of a persistent object identifier (OID) into a direct pointer to the object.

              NOTE:  <b>Setting</b> <b>this</b> <b>environment</b> <b>variable</b> <b>affects</b> <b>all</b> <b>the</b> <b>PMDK</b> <b>libraries,</b> disabling mapping address
              randomization and causing the specified address to be used as a hint about where to place the map‐
              ping.

</pre><h4><b>DEBUGGING</b> <b>AND</b> <b>ERROR</b> <b>HANDLING</b></h4><pre>
       If an error is detected during the call to a <b>libpmem</b> function, the application may retrieve an error mes‐
       sage describing the reason of the failure from <b>pmem_errormsg</b>().  This function returns  a  pointer  to  a
       static buffer containing the last error message logged for the current thread.  If <u>errno</u> was set, the er‐
       ror  message  may  include a description of the corresponding error code as returned by <b><a href="../man3/strerror.3.html">strerror</a></b>(3).  The
       error message buffer is thread-local; errors encountered in one thread do not affect its value  in  other
       threads.   The  buffer is never cleared by any library function; its content is significant only when the
       return value of the immediately preceding call to a <b>libpmem</b> function indicated an error.  The application
       must not modify or free the error message string.  Subsequent calls to other library functions may modify
       the previous message.

       Two versions of <b>libpmem</b> are typically available on a development system.  The  normal  version,  accessed
       when  a  program  is  linked  using  the <b>-lpmem</b> option, is optimized for performance.  That version skips
       checks that impact performance and never logs any trace information or performs any run-time assertions.

       A second version of <b>libpmem</b>, accessed when a program uses the libraries under  <b>/usr/lib/pmdk_debug</b>,  con‐
       tains  run-time  assertions  and trace points.  The typical way to access the debug version is to set the
       environment variable <b>LD_LIBRARY_PATH</b> to <b>/usr/lib/pmdk_debug</b>  or  <b>/usr/lib64/pmdk_debug</b>,  as  appropriate.
       Debugging output is controlled using the following environment variables.  These variables have no effect
       on the non-debug version of the library.

              NOTE:  On Debian/Ubuntu systems, this extra debug version of the library is shipped in the respec‐
              tive <b>-debug</b> Debian package and placed in the <b><a href="file:/usr/lib/">/usr/lib/</a>$ARCH/pmdk_dbg/</b> directory.

       • <b>PMEM_LOG_LEVEL</b>

       The value of <b>PMEM_LOG_LEVEL</b> enables trace points in the debug version of the library, as follows:

       • <b>0</b> - This is the default level when <b>PMEM_LOG_LEVEL</b> is not set.  No log messages are emitted at this lev‐
         el.

       • <b>1</b> - Additional details on any errors detected are logged, in addition to returning the <u>errno</u>-based  er‐
         rors as usual.  The same information may be retrieved using <b>pmem_errormsg</b>().

       • <b>2</b> - A trace of basic operations is logged.

       • <b>3</b> - Enables a very verbose amount of function call tracing in the library.

       • <b>4</b> - Enables voluminous and fairly obscure tracing information that is likely only useful to the <b>libpmem</b>
         developers.

       Unless <b>PMEM_LOG_FILE</b> is set, debugging output is written to <u>stderr</u>.

       • <b>PMEM_LOG_FILE</b>

       Specifies  the  name of a file where all logging information should be written.  If the last character in
       the name is “-”, the <u>PID</u> of the current process will be appended to the file name when the  log  file  is
       created.  If <b>PMEM_LOG_FILE</b> is not set, output is written to <u>stderr</u>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example uses <b>libpmem</b> to flush changes made to raw, memory-mapped persistent memory.

              WARNING:  There  is nothing transactional about the <b><a href="../man3/pmem_persist.3.html">pmem_persist</a></b>(3) or <b><a href="../man3/pmem_msync.3.html">pmem_msync</a></b>(3) calls in this
              example.  Interrupting the program may result in a partial write to pmem.  Use a transactional li‐
              brary such as <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) to avoid torn updates.

              #include &lt;sys/types.h&gt;
              #include &lt;sys/stat.h&gt;
              #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
              #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
              #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
              #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
              #include &lt;libpmem.h&gt;

              /* using 4k of pmem for this example */
              #define PMEM_LEN 4096

              #define PATH "/pmem-fs/myfile"

              int
              main(int argc, char *argv[])
              {
                  char *pmemaddr;
                  size_t mapped_len;
                  int is_pmem;

                  /* create a pmem file and memory map it */

                  if ((pmemaddr = pmem_map_file(PATH, PMEM_LEN, PMEM_FILE_CREATE,
                          0666, &amp;mapped_len, &amp;is_pmem)) == NULL) {
                      perror("pmem_map_file");
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  /* store a string to the persistent memory */
                  strcpy(pmemaddr, "hello, persistent memory");

                  /* flush above strcpy to persistence */
                  if (is_pmem)
                      pmem_persist(pmemaddr, mapped_len);
                  else
                      pmem_msync(pmemaddr, mapped_len);

                  /*
                   * Delete the mappings. The region is also
                   * automatically unmapped when the process is
                   * terminated.
                   */
                  pmem_unmap(pmemaddr, mapped_len);
              }

       See &lt;https://pmem.io/pmdk/libpmem&gt; for more examples using the <b>libpmem</b> API.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       <b>libpmem</b> builds on the persistent memory programming model recommended by the SNIA NVM Programming Techni‐
       cal Work Group: &lt;https://snia.org/nvmp&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/dlclose.3.html">dlclose</a></b>(3), <b><a href="../man3/pmem_flush.3.html">pmem_flush</a></b>(3), <b><a href="../man3/pmem_is_pmem.3.html">pmem_is_pmem</a></b>(3), <b><a href="../man3/pmem_memmove_persist.3.html">pmem_memmove_persist</a></b>(3), <b><a href="../man3/pmem_msync.3.html">pmem_msync</a></b>(3), <b><a href="../man3/pmem_persist.3.html">pmem_persist</a></b>(3), <b>str‐</b>
       <b><a href="../man3/error.3.html">error</a></b>(3), <b><a href="../man7/libpmemblk.7.html">libpmemblk</a></b>(7), <b><a href="../man7/libpmemlog.7.html">libpmemlog</a></b>(7), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>
</pre>
 </div>
</div></section>
</div>
</body>
</html>