<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>drm-memory - DRM Memory Management</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdrm-dev">libdrm-dev_2.4.125-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       drm-memory - DRM Memory Management

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;xf86drm.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Many modern high-end GPUs come with their own memory managers. They even include several different caches
       that  need to be synchronized during access.  Textures, framebuffers, command buffers and more need to be
       stored in memory that can be accessed quickly by the GPU. Therefore, memory management on GPUs is  highly
       driver- and hardware-dependent.

       However,  there  are several frameworks in the kernel that are used by more than one driver. These can be
       used for trivial mode-setting without  requiring  driver-dependent  code.  But  for  hardware-accelerated
       rendering you need to read the manual pages for the driver you want to work with.

   <b>Dumb-Buffers</b>
       Almost  all in-kernel DRM hardware drivers support an API called <u>Dumb-Buffers</u>.  This API allows to create
       buffers of arbitrary size that can be used for scanout. These buffers can be memory mapped via <b><a href="../man2/mmap.2.html">mmap</a></b>(2) so
       you can render into them on the CPU. However,  GPU  access  to  these  buffers  is  often  not  possible.
       Therefore, they are fine for simple tasks but not suitable for complex compositions and renderings.

       The  <b>DRM_IOCTL_MODE_CREATE_DUMB</b>  ioctl  can  be  used  to create a dumb buffer.  The kernel will return a
       32-bit handle that can be used to manage the buffer with the DRM API. You can  create  framebuffers  with
       <b><a href="../man3/drmModeAddFB.3.html">drmModeAddFB</a></b>(3) and use it for mode-setting and scanout. To access the buffer, you first need to retrieve
       the  offset  of  the  buffer. The <b>DRM_IOCTL_MODE_MAP_DUMB</b> ioctl requests the DRM subsystem to prepare the
       buffer for memory-mapping and returns a fake-offset that can be used with <b><a href="../man2/mmap.2.html">mmap</a></b>(2).

       The <b>DRM_IOCTL_MODE_CREATE_DUMB</b> ioctl takes as argument a structure of type <b>struct</b> <b>drm_mode_create_dumb</b>:

          struct drm_mode_create_dumb {
              __u32 height;
              __u32 width;
              __u32 bpp;
              __u32 flags;

              __u32 handle;
              __u32 pitch;
              __u64 size;
          };

       The fields <u>height</u>, <u>width</u>, <u>bpp</u> and <u>flags</u> have to be provided by the caller. The other fields are filled by
       the kernel with the return values.  <u>height</u> and <u>width</u> are the dimensions of the rectangular buffer that is
       created. <u>bpp</u> is the number of bits-per-pixel and must be a multiple of 8. You most commonly want to  pass
       32  here.  The flags field is currently unused and must be zeroed. Different flags to modify the behavior
       may be added in the future. After calling the ioctl, the handle, pitch and size fields are filled by  the
       kernel.  <u>handle</u>  is  a  32-bit gem handle that identifies the buffer. This is used by several other calls
       that take a gem-handle or memory-buffer as argument. The <u>pitch</u> field is the pitch (or stride) of the  new
       buffer.  Most  drivers  use  32-bit or 64-bit aligned stride-values. The size field contains the absolute
       size in bytes of the buffer. This can normally also be computed with <b>(height</b> <b>*</b> <b>pitch</b> <b>+</b> <b>width)</b> <b>*</b> <b>bpp</b> <b>/</b> <b>4</b>.

       To prepare the buffer for <b><a href="../man2/mmap.2.html">mmap</a></b>(2) you need to use the <b>DRM_IOCTL_MODE_MAP_DUMB</b> ioctl. It takes as argument
       a structure of type <b>struct</b> <b>drm_mode_map_dumb</b>:

          struct drm_mode_map_dumb {
              __u32 handle;
              __u32 pad;

              __u64 offset;
          };

       You need to put the gem-handle that was previously  retrieved  via  <b>DRM_IOCTL_MODE_CREATE_DUMB</b>  into  the
       <u>handle</u> field. The <u>pad</u> field is unused padding and must be zeroed. After completion, the <u>offset</u> field will
       contain an offset that can be used with <b><a href="../man2/mmap.2.html">mmap</a></b>(2) on the DRM file-descriptor.

       If  you don't need your dumb-buffer, anymore, you have to destroy it with <b>DRM_IOCTL_MODE_DESTROY_DUMB</b>. If
       you close the DRM file-descriptor, all open dumb-buffers are automatically destroyed. This ioctl takes as
       argument a structure of type <b>struct</b> <b>drm_mode_destroy_dumb</b>:

          struct drm_mode_destroy_dumb {
              __u32 handle;
          };

       You only need to put your handle into the <u>handle</u> field. After this call, the handle is invalid and may be
       reused for new buffers by the dumb-API.

   <b>TTM</b>
       <u>TTM</u> stands for <u>Translation</u> <u>Table</u> <u>Manager</u> and is a generic memory-manager provided by the kernel. It  does
       not  provide  a common user-space API so you need to look at each driver interface if you want to use it.
       See for instance the radeon man pages for more information on memory-management with radeon and TTM.

   <b>GEM</b>
       <u>GEM</u> stands for <u>Graphics</u> <u>Execution</u> <u>Manager</u> and is a generic DRM memory-management framework in the kernel,
       that is used by many different drivers. GEM is designed to manage graphics memory, control access to  the
       graphics  device  execution  context  and  handle  essentially NUMA environment unique to modern graphics
       hardware. GEM allows multiple applications to  share  graphics  device  resources  without  the  need  to
       constantly  reload  the  entire  graphics card. Data may be shared between multiple applications with gem
       ensuring that the correct memory synchronization occurs.

       GEM provides simple mechanisms to manage graphics data and control execution flow within  the  linux  DRM
       subsystem.  However,  GEM  is  not  a  complete  framework  that is fully driver independent. Instead, if
       provides many functions that are shared between many drivers, but each driver has to  implement  most  of
       memory-management  with  driver-dependent ioctls. This manpage tries to describe the semantics (and if it
       applies, the syntax) that is shared between all drivers that use GEM.

       All GEM APIs are defined as <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) on the DRM file descriptor. An application must  be  authorized  via
       <b><a href="../man3/drmAuthMagic.3.html">drmAuthMagic</a></b>(3) to the current DRM-Master to access the GEM subsystem. A driver that does not support GEM
       will  return  <b>ENODEV</b>  for all these ioctls. Invalid object handles return <b>EINVAL</b> and invalid object names
       return <b>ENOENT</b>.

       Gem provides explicit memory management primitives.  System  pages  are  allocated  when  the  object  is
       created,  either  as  the  fundamental  storage  for hardware where system memory is used by the graphics
       processor directly, or as backing store for graphics-processor resident memory.

       Objects are referenced from user-space using handles. These are, for all intents and purposes, equivalent
       to file descriptors but avoid the  overhead.   Newer  kernel  drivers  also  support  the  <b>drm-prime</b>  (7)
       infrastructure  which  can  return  real  file-descriptor  for  GEM-handles  using the linux DMA-BUF API.
       Objects may be published with a name so that other applications and processes can access them.  The  name
       remains  valid as long as the object exists.  GEM-objects are reference counted in the kernel. The object
       is only destroyed when all handles from user-space were closed.

       GEM-buffers cannot be created with a generic API. Each driver provides its own API to create GEM-buffers.
       See for example <b>DRM_I915_GEM_CREATE</b>, <b>DRM_NOUVEAU_GEM_NEW</b> or <b>DRM_RADEON_GEM_CREATE</b>. Each of  these  ioctls
       returns  a  GEM-handle that can be passed to different generic ioctls. The <u>libgbm</u> library from the <u>mesa3D</u>
       distribution tries to provide a driver-independent API to create GBM buffers and retrieve a GBM-handle to
       them.  It allows to create buffers for different use-cases  including  scanout,  rendering,  cursors  and
       CPU-access.  See  the  libgbm library for more information or look at the driver-dependent man-pages (for
       example <b><a href="../man7/drm-intel.7.html">drm-intel</a></b>(7) or <b><a href="../man7/drm-radeon.7.html">drm-radeon</a></b>(7)).

       GEM-buffers can be closed with <b><a href="../man3/drmCloseBufferHandle.3.html">drmCloseBufferHandle</a></b>(3). It takes as argument the GEM-handle to be closed.
       After this call the GEM handle cannot be used by this process anymore and  may  be  reused  for  new  GEM
       objects by the GEM API.

       If  you  want  to  share GEM-objects between different processes, you can create a name for them and pass
       this name to other processes which can then open this GEM-object. Names are currently 32-bit integer  IDs
       and  have  no  special protection. That is, if you put a name on your GEM-object, every other client that
       has access to the DRM device and is authenticated via <b><a href="../man3/drmAuthMagic.3.html">drmAuthMagic</a></b>(3)  to  the  current  DRM-Master,  can
       <u>guess</u>  the  name and open or access the GEM-object. If you want more fine-grained access control, you can
       use the new <b><a href="../man7/drm-prime.7.html">drm-prime</a></b>(7) API to retrieve file-descriptors  for  GEM-handles.  To  create  a  name  for  a
       GEM-handle,  you  use  the  <b>DRM_IOCTL_GEM_FLINK</b>  ioctl.  It  takes as argument a structure of type <b>struct</b>
       <b>drm_gem_flink</b>:

          struct drm_gem_flink {
              __u32 handle;
              __u32 name;
          };

       You have to put your handle into the <u>handle</u> field. After completion, the kernel has put  the  new  unique
       name  into  the  name field. You can now pass this name to other processes which can then import the name
       with the <b>DRM_IOCTL_GEM_OPEN</b> ioctl. It takes as argument a structure of type <b>struct</b> <b>drm_gem_open</b>:

          struct drm_gem_open {
              __u32 name;

              __u32 handle;
              __u32 size;
          };

       You have to fill in the <u>name</u> field with the name of the GEM-object that you want to open. The kernel will
       fill in the <u>handle</u> and <u>size</u> fields with the new handle and size of the GEM-object. You can now access the
       GEM-object via the handle as if you created it with the GEM API.

       Besides generic buffer management, the  GEM  API  does  not  provide  any  generic  access.  Each  driver
       implements  its  own  functionality  on top of this API. This includes execution-buffers, GTT management,
       context creation, CPU access, GPU I/O and more. The next higher-level API is <u>OpenGL</u>. So if  you  want  to
       use  more  GPU features, you should use the <u>mesa3D</u> library to create OpenGL contexts on DRM devices. This
       does <u>not</u> require any windowing-system like X11, but can also be done on raw DRM devices. However, this is
       beyond the scope of this man-page. You may have a look at other mesa3D man pages,  including  libgbm  and
       libEGL.  2D  software-rendering  (rendering  with  the CPU) can be achieved with the dumb-buffer-API in a
       driver-independent fashion, however, for hardware-accelerated 2D or 3D rendering you must use OpenGL. Any
       other API that tries to abstract the driver-internals  to  access  GEM-execution-buffers  and  other  GPU
       internals,  would simply reinvent OpenGL so it is not provided. But if you need more detailed information
       for  a  specific  driver,  you  may  have  a  look  into  the  driver-manpages,  including  <b><a href="../man7/drm-intel.7.html">drm-intel</a></b>(7),
       <b><a href="../man7/drm-radeon.7.html">drm-radeon</a></b>(7)  and  <b><a href="../man7/drm-nouveau.7.html">drm-nouveau</a></b>(7).  However,  the <b><a href="../man7/drm-prime.7.html">drm-prime</a></b>(7) infrastructure and the generic GEM API as
       described here allow display-managers to handle graphics-buffers and render-clients  without  any  deeper
       knowledge of the GPU that is used. Moreover, it allows to move objects between GPUs and implement complex
       display-servers that don't do any rendering on their own. See its man-page for more information.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This section includes examples for basic memory-management tasks.

   <b>Dumb-Buffers</b>
       This  examples shows how to create a dumb-buffer via the generic DRM API.  This is driver-independent (as
       long as the driver supports dumb-buffers) and  provides  memory-mapped  buffers  that  can  be  used  for
       scanout.  This  example creates a full-HD 1920x1080 buffer with 32 bits-per-pixel and a color-depth of 24
       bits. The buffer is then bound to a framebuffer which can be used for  scanout  with  the  KMS  API  (see
       <b><a href="../man7/drm-kms.7.html">drm-kms</a></b>(7)).

          struct drm_mode_create_dumb creq;
          struct drm_mode_destroy_dumb dreq;
          struct drm_mode_map_dumb mreq;
          uint32_t fb;
          int ret;
          void *map;

          /* create dumb buffer */
          memset(&amp;creq, 0, sizeof(creq));
          creq.width = 1920;
          creq.height = 1080;
          creq.bpp = 32;
          ret = drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;creq);
          if (ret &lt; 0) {
              /* buffer creation failed; see "errno" for more error codes */
              ...
          }
          /* creq.pitch, creq.handle and creq.size are filled by this ioctl with
           * the requested values and can be used now. */

          /* create framebuffer object for the dumb-buffer */
          ret = drmModeAddFB(fd, 1920, 1080, 24, 32, creq.pitch, creq.handle, &amp;fb);
          if (ret) {
              /* frame buffer creation failed; see "errno" */
              ...
          }
          /* the framebuffer "fb" can now used for scanout with KMS */

          /* prepare buffer for memory mapping */
          memset(&amp;mreq, 0, <a href="../manmreq/sizeof.mreq.html">sizeof</a>(mreq));
          mreq.handle = creq.handle;
          ret = drmIoctl(fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;mreq);
          if (ret) {
              /* DRM buffer preparation failed; see "errno" */
              ...
          }
          /* mreq.offset now contains the new offset that can be used with mmap() */

          /* perform actual memory mapping */
          map = mmap(0, creq.size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, mreq.offset);
          if (map == MAP_FAILED) {
              /* memory-mapping failed; see "errno" */
              ...
          }

          /* clear the framebuffer to 0 */
          memset(map, 0, creq.size);

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Bugs in this manual should be reported to
        &lt;https://gitlab.freedesktop.org/mesa/libdrm/-/issues&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/drm.7.html">drm</a></b>(7),    <b><a href="../man7/drm-kms.7.html">drm-kms</a></b>(7),    <b><a href="../man7/drm-prime.7.html">drm-prime</a></b>(7),   <b><a href="../man3/drmAvailable.3.html">drmAvailable</a></b>(3),   <b><a href="../man3/drmOpen.3.html">drmOpen</a></b>(3),   <b><a href="../man7/drm-intel.7.html">drm-intel</a></b>(7),   <b><a href="../man7/drm-radeon.7.html">drm-radeon</a></b>(7),
       <b><a href="../man7/drm-nouveau.7.html">drm-nouveau</a></b>(7)

                                                 September 2012                                    <u><a href="../man7/DRM-MEMORY.7.html">DRM-MEMORY</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>