<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gitsubmodules - Mounting one repository inside another</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/git-man">git-man_2.50.0-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gitsubmodules - Mounting one repository inside another

</pre><h4><b>SYNOPSIS</b></h4><pre>
       .gitmodules, $GIT_DIR/config

       git submodule
       git &lt;command&gt; --recurse-submodules

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A submodule is a repository embedded inside another repository. The submodule has its own history; the
       repository it is embedded in is called a superproject.

       On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory
       located under the <b>$GIT_DIR/modules/</b> directory of its superproject, (ii) a working directory inside the
       superproject’s working directory, and a <b>.git</b> file at the root of the submodule’s working directory
       pointing to (i).

       Assuming the submodule has a Git directory at <b>$GIT_DIR/modules/foo/</b> and a working directory at
       <b>path/to/bar/</b>, the superproject tracks the submodule via a <b>gitlink</b> entry in the tree at <b>path/to/bar</b> and an
       entry in its <b>.gitmodules</b> file (see <b><a href="../man5/gitmodules.5.html">gitmodules</a></b>(5)) of the form <b>submodule.foo.path</b> <b>=</b> <b>path/to/bar</b>.

       The <b>gitlink</b> entry contains the object name of the commit that the superproject expects the submodule’s
       working directory to be at.

       The section <b>submodule.foo.*</b> in the <b>.gitmodules</b> file gives additional hints to Git’s porcelain layer. For
       example, the <b>submodule.foo.url</b> setting specifies where to obtain the submodule.

       Submodules can be used for at least two different use cases:

        1. Using another project while maintaining independent history. Submodules allow you to contain the
           working tree of another project within your own working tree while keeping the history of both
           projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be
           independently developed without affecting the superproject, allowing the superproject project to fix
           itself to new versions only when desired.

        2. Splitting a (logically single) project into multiple repositories and tying them back together. This
           can be used to overcome current limitations of Git’s implementation to have finer grained access:

           •   Size of the Git repository: In its current form Git scales up poorly for large repositories
               containing content that is not compressed by delta computation between trees. For example, you
               can use submodules to hold large binary assets and these repositories can be shallowly cloned
               such that you do not have a large history locally.

           •   Transfer size: In its current form Git requires the whole working tree present. It does not allow
               partial trees to be transferred in fetch or clone. If the project you work on consists of
               multiple repositories tied together as submodules in a superproject, you can avoid fetching the
               working trees of the repositories you are not interested in.

           •   Access control: By restricting user access to submodules, this can be used to implement
               read/write policies for different users.

</pre><h4><b>THE</b> <b>CONFIGURATION</b> <b>OF</b> <b>SUBMODULES</b></h4><pre>
       Submodule operations can be configured using the following mechanisms (from highest to lowest
       precedence):

       •   The command line for those commands that support taking submodules as part of their pathspecs. Most
           commands have a boolean flag <b>--recurse-submodules</b> which specifies whether to recurse into submodules.
           Examples are <b>grep</b> and <b>checkout</b>. Some commands take enums, such as <b>fetch</b> and <b>push</b>, where you can
           specify how submodules are affected.

       •   The configuration inside the submodule. This includes <b>$GIT_DIR/config</b> in the submodule, but also
           settings in the tree such as a <b>.gitattributes</b> or <b>.gitignore</b> files that specify behavior of commands
           inside the submodule.

           For example an effect from the submodule’s <b>.gitignore</b> file would be observed when you run <b>git</b> <b>status</b>
           <b>--ignore-submodules=none</b> in the superproject. This collects information from the submodule’s working
           directory by running <b>status</b> in the submodule while paying attention to the <b>.gitignore</b> file of the
           submodule.

           The submodule’s <b>$GIT_DIR/config</b> file would come into play when running <b>git</b> <b>push</b>
           <b>--recurse-submodules=check</b> in the superproject, as this would check if the submodule has any changes
           not published to any remote. The remotes are configured in the submodule as usual in the
           <b>$GIT_DIR/config</b> file.

       •   The configuration file <b>$GIT_DIR/config</b> in the superproject. Git only recurses into active submodules
           (see "ACTIVE SUBMODULES" section below).

           If the submodule is not yet initialized, then the configuration inside the submodule does not exist
           yet, so where to obtain the submodule from is configured here for example.

       •   The <b>.gitmodules</b> file inside the superproject. A project usually uses this file to suggest defaults
           for the upstream collection of repositories for the mapping that is required between a submodule’s
           name and its path.

           This file mainly serves as the mapping between the name and path of submodules in the superproject,
           such that the submodule’s Git directory can be located.

           If the submodule has never been initialized, this is the only place where submodule configuration is
           found. It serves as the last fallback to specify where to obtain the submodule from.

</pre><h4><b>FORMS</b></h4><pre>
       Submodules can take the following forms:

       •   The basic form described in DESCRIPTION with a Git directory, a working directory, a <b>gitlink</b>, and a
           <b>.gitmodules</b> entry.

       •   "Old-form" submodule: A working directory with an embedded <b>.git</b> directory, and the tracking <b>gitlink</b>
           and <b>.gitmodules</b> entry in the superproject. This is typically found in repositories generated using
           older versions of Git.

           It is possible to construct these old form repositories manually.

           When deinitialized or deleted (see below), the submodule’s Git directory is automatically moved to
           <b>$GIT_DIR/modules/</b><u>&lt;name&gt;</u><b>/</b> of the superproject.

       •   Deinitialized submodule: A <b>gitlink</b>, and a <b>.gitmodules</b> entry, but no submodule working directory. The
           submodule’s Git directory may be there as after deinitializing the Git directory is kept around. The
           directory which is supposed to be the working directory is empty instead.

           A submodule can be deinitialized by running <b>git</b> <b>submodule</b> <b>deinit</b>. Besides emptying the working
           directory, this command only modifies the superproject’s <b>$GIT_DIR/config</b> file, so the superproject’s
           history is not affected. This can be undone using <b>git</b> <b>submodule</b> <b>init</b>.

       •   Deleted submodule: A submodule can be deleted by running <b>git</b> <b>rm</b> <u>&lt;submodule-path&gt;</u> &amp;&amp; <b>git</b> <b>commit</b>. This
           can be undone using <b>git</b> <b>revert</b>.

           The deletion removes the superproject’s tracking data, which are both the <b>gitlink</b> entry and the
           section in the <b>.gitmodules</b> file. The submodule’s working directory is removed from the file system,
           but the Git directory is kept around as it to make it possible to checkout past commits without
           requiring fetching from another repository.

           To completely remove a submodule, manually delete <b>$GIT_DIR/modules/</b><u>&lt;name&gt;</u><b>/</b>.

</pre><h4><b>ACTIVE</b> <b>SUBMODULES</b></h4><pre>
       A submodule is considered active,

        1. if <b>submodule.</b><u>&lt;name&gt;</u><b>.active</b> is set to <b>true</b>

           or

        2. if the submodule’s path matches the pathspec in <b>submodule.active</b>

           or

        3. if <b>submodule.</b><u>&lt;name&gt;</u><b>.url</b> is set.

       and these are evaluated in this order.

       For example:

           [submodule "foo"]
             active = false
             url = https://example.org/foo
           [submodule "bar"]
             active = true
             url = https://example.org/bar
           [submodule "baz"]
             url = https://example.org/baz

       In the above config only the submodules <u>bar</u> and <u>baz</u> are active, <u>bar</u> due to (1) and <u>baz</u> due to (3). <u>foo</u> is
       inactive because (1) takes precedence over (3)

       Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule
       is not active. In other words, if we have a <b>submodule.</b><u>&lt;name&gt;</u><b>.active</b> set to <b>false</b> or if the submodule’s
       path is excluded in the pathspec in <b>submodule.active</b>, the url doesn’t matter whether it is present or
       not. This is illustrated in the example that follows.

           [submodule "foo"]
             active = true
             url = https://example.org/foo
           [submodule "bar"]
             url = https://example.org/bar
           [submodule "baz"]
             url = https://example.org/baz
           [submodule "bob"]
             ignore = true
           [submodule]
             active = b*
             active = :(exclude) baz

       In here all submodules except <u>baz</u> (foo, bar, bob) are active. <u>foo</u> due to its own active flag and all the
       others due to the submodule active pathspec, which specifies that any submodule starting with <u>b</u> except
       <u>baz</u> are also active, regardless of the presence of the .url field.

</pre><h4><b>WORKFLOW</b> <b>FOR</b> <b>A</b> <b>THIRD</b> <b>PARTY</b> <b>LIBRARY</b></h4><pre>
           # Add a submodule
           git submodule add &lt;URL&gt; &lt;path&gt;

           # Occasionally update the submodule to a new version:
           git -C &lt;path&gt; checkout &lt;new-version&gt;
           git add &lt;path&gt;
           git commit -m "update submodule to new version"

           # See the list of submodules in a superproject
           git submodule status

           # See FORMS on removing submodules

</pre><h4><b>WORKFLOW</b> <b>FOR</b> <b>AN</b> <b>ARTIFICIALLY</b> <b>SPLIT</b> <b>REPO</b></h4><pre>
           # Enable recursion for relevant commands, such that
           # regular commands recurse into submodules by default
           git config --global submodule.recurse true

           # Unlike most other commands below, clone still needs
           # its own recurse flag:
           git clone --recurse &lt;URL&gt; &lt;directory&gt;
           cd &lt;directory&gt;

           # Get to know the code:
           git grep foo
           git ls-files --recurse-submodules

           <b>Note</b>

           <b>git</b> <b>ls-files</b> also requires its own <b>--recurse-submodules</b> flag.

           # Get new code
           git fetch
           git pull --rebase

           # Change worktree
           git checkout
           git reset

</pre><h4><b>IMPLEMENTATION</b> <b>DETAILS</b></h4><pre>
       When cloning or pulling a repository containing submodules the submodules will not be checked out by
       default; you can instruct <b>clone</b> to recurse into submodules. The <b>init</b> and <b>update</b> subcommands of <b>git</b>
       <b>submodule</b> will maintain submodules checked out and at an appropriate revision in your working tree.
       Alternatively you can set <b>submodule.recurse</b> to have <b>checkout</b> recurse into submodules (note that
       <b>submodule.recurse</b> also affects other Git commands, see <b><a href="../man1/git-config.1.html">git-config</a></b>(1) for a complete list).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/git-submodule.1.html">git-submodule</a></b>(1), <b><a href="../man5/gitmodules.5.html">gitmodules</a></b>(5).

</pre><h4><b>GIT</b></h4><pre>
       Part of the <b><a href="../man1/git.1.html">git</a></b>(1) suite

Git 2.50.0                                         07/03/2025                                   <u><a href="../man7/GITSUBMODULES.7.html">GITSUBMODULES</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>