<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aio - POSIX asynchronous I/O overview</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       aio - POSIX asynchronous I/O overview

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  POSIX  asynchronous  I/O  (AIO) interface allows applications to initiate one or more I/O operations
       that are performed asynchronously (i.e., in the background).  The application can elect to be notified of
       completion of the I/O operation in a variety of ways: by delivery of a  signal,  by  instantiation  of  a
       thread, or no notification at all.

       The POSIX AIO interface consists of the following functions:

       <b><a href="../man3/aio_read.3.html">aio_read</a></b>(3)
              Enqueue a read request.  This is the asynchronous analog of <b><a href="../man2/read.2.html">read</a></b>(2).

       <b><a href="../man3/aio_write.3.html">aio_write</a></b>(3)
              Enqueue a write request.  This is the asynchronous analog of <b><a href="../man2/write.2.html">write</a></b>(2).

       <b><a href="../man3/aio_fsync.3.html">aio_fsync</a></b>(3)
              Enqueue  a  sync  request  for  the I/O operations on a file descriptor.  This is the asynchronous
              analog of <b><a href="../man2/fsync.2.html">fsync</a></b>(2) and <b><a href="../man2/fdatasync.2.html">fdatasync</a></b>(2).

       <b><a href="../man3/aio_error.3.html">aio_error</a></b>(3)
              Obtain the error status of an enqueued I/O request.

       <b><a href="../man3/aio_return.3.html">aio_return</a></b>(3)
              Obtain the return status of a completed I/O request.

       <b><a href="../man3/aio_suspend.3.html">aio_suspend</a></b>(3)
              Suspend the caller until one or more of a specified set of I/O requests completes.

       <b><a href="../man3/aio_cancel.3.html">aio_cancel</a></b>(3)
              Attempt to cancel outstanding I/O requests on a specified file descriptor.

       <b><a href="../man3/lio_listio.3.html">lio_listio</a></b>(3)
              Enqueue multiple I/O requests using a single function call.

       The <u>aiocb</u> ("asynchronous I/O control block") structure defines parameters that control an I/O  operation.
       An  argument  of  this  type  is employed with all of the functions listed above.  This structure has the
       following form:

           #include &lt;aiocb.h&gt;

           struct aiocb {
               /* The order of these fields is implementation-dependent */

               int             aio_fildes;     /* File descriptor */
               off_t           aio_offset;     /* File offset */
               volatile void  *aio_buf;        /* Location of buffer */
               size_t          aio_nbytes;     /* Length of transfer */
               int             aio_reqprio;    /* Request priority */
               struct sigevent aio_sigevent;   /* Notification method */
               int             aio_lio_opcode; /* Operation to be performed;
                                                  lio_listio() only */

               /* Various implementation-internal fields not shown */
           };

           /* Operation codes for 'aio_lio_opcode': */

           enum { LIO_READ, LIO_WRITE, LIO_NOP };

       The fields of this structure are as follows:

       <u>aio_fildes</u>
              The file descriptor on which the I/O operation is to be performed.

       <u>aio_offset</u>
              This is the file offset at which the I/O operation is to be performed.

       <u>aio_buf</u>
              This is the buffer used to transfer data for a read or write operation.

       <u>aio_nbytes</u>
              This is the size of the buffer pointed to by <u>aio_buf</u>.

       <u>aio_reqprio</u>
              This field specifies a value that is subtracted from the calling thread's  real-time  priority  in
              order  to determine the priority for execution of this I/O request (see <b><a href="../man3/pthread_setschedparam.3.html">pthread_setschedparam</a></b>(3)).
              The specified value must be between 0 and the value returned  by  <u>sysconf(_SC_AIO_PRIO_DELTA_MAX)</u>.
              This field is ignored for file synchronization operations.

       <u>aio_sigevent</u>
              This  field  is  a structure that specifies how the caller is to be notified when the asynchronous
              I/O  operation  completes.   Possible  values  for   <u>aio_sigevent.sigev_notify</u>   are   <b>SIGEV_NONE</b>,
              <b>SIGEV_SIGNAL</b>, and <b>SIGEV_THREAD</b>.  See <b><a href="../man3type/sigevent.3type.html">sigevent</a></b>(3type) for further details.

       <u>aio_lio_opcode</u>
              The type of operation to be performed; used only for <b><a href="../man3/lio_listio.3.html">lio_listio</a></b>(3).

       In addition to the standard functions listed above, the GNU C library provides the following extension to
       the POSIX AIO API:

       <b><a href="../man3/aio_init.3.html">aio_init</a></b>(3)
              Set parameters for tuning the behavior of the glibc POSIX AIO implementation.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> The  <u>aio_reqprio</u>  field  of  the  <u>aiocb</u>  structure  was less than 0, or was greater than the limit
              returned by the call <u>sysconf(_SC_AIO_PRIO_DELTA_MAX)</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001.  glibc 2.1.

</pre><h4><b>NOTES</b></h4><pre>
       It is a good idea to zero out the control block buffer before use (see  <b><a href="../man3/memset.3.html">memset</a></b>(3)).   The  control  block
       buffer  and  the buffer pointed to by <u>aio_buf</u> must not be changed while the I/O operation is in progress.
       These buffers must remain valid until the I/O operation completes.

       Simultaneous asynchronous read or write  operations  using  the  same  <u>aiocb</u>  structure  yield  undefined
       results.

       The  current  Linux  POSIX  AIO  implementation is provided in user space by glibc.  This has a number of
       limitations, most notably that maintaining multiple threads to perform I/O operations  is  expensive  and
       scales poorly.  Work has been in progress for some time on a kernel state-machine-based implementation of
       asynchronous  I/O (see <b><a href="../man2/io_submit.2.html">io_submit</a></b>(2), <b><a href="../man2/io_setup.2.html">io_setup</a></b>(2), <b><a href="../man2/io_cancel.2.html">io_cancel</a></b>(2), <b><a href="../man2/io_destroy.2.html">io_destroy</a></b>(2), <b><a href="../man2/io_getevents.2.html">io_getevents</a></b>(2)), but this
       implementation hasn't yet matured to the point where the  POSIX  AIO  implementation  can  be  completely
       reimplemented using the kernel system calls.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below opens each of the files named in its command-line arguments and queues a request on the
       resulting file descriptor using <b><a href="../man3/aio_read.3.html">aio_read</a></b>(3).  The program then loops, periodically monitoring each of the
       I/O  operations  that  is  still  in  progress using <b><a href="../man3/aio_error.3.html">aio_error</a></b>(3).  Each of the I/O requests is set up to
       provide notification by delivery of a signal.   After  all  I/O  requests  have  completed,  the  program
       retrieves their status using <b><a href="../man3/aio_return.3.html">aio_return</a></b>(3).

       The  <b>SIGQUIT</b>  signal (generated by typing control-\) causes the program to request cancelation of each of
       the outstanding requests using <b><a href="../man3/aio_cancel.3.html">aio_cancel</a></b>(3).

       Here is an example of what we might see when running this program.  In this example, the  program  queues
       two requests to standard input, and these are satisfied by two lines of input containing "abc" and "x".

           $ <b>./a.out</b> <b><a href="file:/dev/stdin">/dev/stdin</a></b> <b><a href="file:/dev/stdin">/dev/stdin</a></b>
           opened <a href="file:/dev/stdin">/dev/stdin</a> on descriptor 3
           opened <a href="file:/dev/stdin">/dev/stdin</a> on descriptor 4
           aio_error():
               for request 0 (descriptor 3): In progress
               for request 1 (descriptor 4): In progress
           <b>abc</b>
           I/O completion signal received
           aio_error():
               for request 0 (descriptor 3): I/O succeeded
               for request 1 (descriptor 4): In progress
           aio_error():
               for request 1 (descriptor 4): In progress
           <b>x</b>
           I/O completion signal received
           aio_error():
               for request 1 (descriptor 4): I/O succeeded
           All I/O requests completed
           aio_return():
               for request 0 (descriptor 3): 4
               for request 1 (descriptor 4): 2

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/aio.h">aio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

       #define BUF_SIZE 20     /* Size of buffers for read operations */

       #define <a href="../manmsg/errExit.msg.html">errExit</a>(msg) do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       struct ioRequest {      /* Application-defined structure for tracking
                                  I/O requests */
           int           reqNum;
           int           status;
           struct aiocb *aiocbp;
       };

       static volatile sig_atomic_t gotSIGQUIT = 0;
                               /* On delivery of SIGQUIT, we attempt to
                                  cancel all outstanding I/O requests */

       static void             /* Handler for SIGQUIT */
       quitHandler(int sig)
       {
           gotSIGQUIT = 1;
       }

       #define IO_SIGNAL SIGUSR1   /* Signal used to notify I/O completion */

       static void                 /* Handler for I/O completion signal */
       aioSigHandler(int sig, siginfo_t *si, void *ucontext)
       {
           if (si-&gt;si_code == SI_ASYNCIO) {
               write(STDOUT_FILENO, "I/O completion signal received\n", 31);

               /* The corresponding ioRequest structure would be available as
                      struct ioRequest *ioReq = si-&gt;si_value.sival_ptr;
                  and the file descriptor would then be available via
                      ioReq-&gt;aiocbp-&gt;aio_fildes */
           }
       }

       int
       main(int argc, char *argv[])
       {
           struct sigaction sa;
           int s;
           int numReqs;        /* Total number of queued I/O requests */
           int openReqs;       /* Number of I/O requests still in progress */

           if (argc &lt; 2) {
               fprintf(stderr, "Usage: %s &lt;pathname&gt; &lt;pathname&gt;...\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           numReqs = argc - 1;

           /* Allocate our arrays. */

           struct ioRequest *ioList = calloc(numReqs, sizeof(*ioList));
           if (ioList == NULL)
               errExit("calloc");

           struct aiocb *aiocbList = calloc(numReqs, sizeof(*aiocbList));
           if (aiocbList == NULL)
               errExit("calloc");

           /* Establish handlers for SIGQUIT and the I/O completion signal. */

           sa.sa_flags = SA_RESTART;
           sigemptyset(&amp;sa.sa_mask);

           sa.sa_handler = quitHandler;
           if (sigaction(SIGQUIT, &amp;sa, NULL) == -1)
               errExit("sigaction");

           sa.sa_flags = SA_RESTART | SA_SIGINFO;
           sa.sa_sigaction = aioSigHandler;
           if (sigaction(IO_SIGNAL, &amp;sa, NULL) == -1)
               errExit("sigaction");

           /* Open each file specified on the command line, and queue
              a read request on the resulting file descriptor. */

           for (size_t j = 0; j &lt; numReqs; j++) {
               ioList[j].reqNum = j;
               ioList[j].status = EINPROGRESS;
               ioList[j].aiocbp = &amp;aiocbList[j];

               ioList[j].aiocbp-&gt;aio_fildes = open(argv[j + 1], O_RDONLY);
               if (ioList[j].aiocbp-&gt;aio_fildes == -1)
                   errExit("open");
               printf("opened %s on descriptor %d\n", argv[j + 1],
                       ioList[j].aiocbp-&gt;aio_fildes);

               ioList[j].aiocbp-&gt;aio_buf = malloc(BUF_SIZE);
               if (ioList[j].aiocbp-&gt;aio_buf == NULL)
                   errExit("malloc");

               ioList[j].aiocbp-&gt;aio_nbytes = BUF_SIZE;
               ioList[j].aiocbp-&gt;aio_reqprio = 0;
               ioList[j].aiocbp-&gt;aio_offset = 0;
               ioList[j].aiocbp-&gt;aio_sigevent.sigev_notify = SIGEV_SIGNAL;
               ioList[j].aiocbp-&gt;aio_sigevent.sigev_signo = IO_SIGNAL;
               ioList[j].aiocbp-&gt;aio_sigevent.sigev_value.sival_ptr =
                                       &amp;ioList[j];

               s = aio_read(ioList[j].aiocbp);
               if (s == -1)
                   errExit("aio_read");
           }

           openReqs = numReqs;

           /* Loop, monitoring status of I/O requests. */

           while (openReqs &gt; 0) {
               <a href="../man3/sleep.3.html">sleep</a>(3);       /* Delay between each monitoring step */

               if (gotSIGQUIT) {

                   /* On receipt of SIGQUIT, attempt to cancel each of the
                      outstanding I/O requests, and display status returned
                      from the cancelation requests. */

                   printf("got SIGQUIT; canceling I/O requests: \n");

                   for (size_t j = 0; j &lt; numReqs; j++) {
                       if (ioList[j].status == EINPROGRESS) {
                           printf("    Request %zu on descriptor %d:", j,
                                   ioList[j].aiocbp-&gt;aio_fildes);
                           s = aio_cancel(ioList[j].aiocbp-&gt;aio_fildes,
                                   ioList[j].aiocbp);
                           if (s == AIO_CANCELED)
                               printf("I/O canceled\n");
                           else if (s == AIO_NOTCANCELED)
                               printf("I/O not canceled\n");
                           else if (s == AIO_ALLDONE)
                               printf("I/O all done\n");
                           else
                               perror("aio_cancel");
                       }
                   }

                   gotSIGQUIT = 0;
               }

               /* Check the status of each I/O request that is still
                  in progress. */

               printf("aio_error():\n");
               for (size_t j = 0; j &lt; numReqs; j++) {
                   if (ioList[j].status == EINPROGRESS) {
                       printf("    for request %zu (descriptor %d): ",
                               j, ioList[j].aiocbp-&gt;aio_fildes);
                       ioList[j].status = aio_error(ioList[j].aiocbp);

                       switch (ioList[j].status) {
                       case 0:
                           printf("I/O succeeded\n");
                           break;
                       case EINPROGRESS:
                           printf("In progress\n");
                           break;
                       case ECANCELED:
                           printf("Canceled\n");
                           break;
                       default:
                           perror("aio_error");
                           break;
                       }

                       if (ioList[j].status != EINPROGRESS)
                           openReqs--;
                   }
               }
           }

           printf("All I/O requests completed\n");

           /* Check status return of all I/O requests. */

           printf("aio_return():\n");
           for (size_t j = 0; j &lt; numReqs; j++) {
               ssize_t s;

               s = aio_return(ioList[j].aiocbp);
               printf("    for request %zu (descriptor %d): %zd\n",
                       j, ioList[j].aiocbp-&gt;aio_fildes, s);
           }

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/io_cancel.2.html">io_cancel</a></b>(2), <b><a href="../man2/io_destroy.2.html">io_destroy</a></b>(2), <b><a href="../man2/io_getevents.2.html">io_getevents</a></b>(2), <b><a href="../man2/io_setup.2.html">io_setup</a></b>(2), <b><a href="../man2/io_submit.2.html">io_submit</a></b>(2), <b><a href="../man3/aio_cancel.3.html">aio_cancel</a></b>(3), <b><a href="../man3/aio_error.3.html">aio_error</a></b>(3),
       <b><a href="../man3/aio_init.3.html">aio_init</a></b>(3), <b><a href="../man3/aio_read.3.html">aio_read</a></b>(3), <b><a href="../man3/aio_return.3.html">aio_return</a></b>(3), <b><a href="../man3/aio_write.3.html">aio_write</a></b>(3), <b><a href="../man3/lio_listio.3.html">lio_listio</a></b>(3)

       "Asynchronous I/O Support in Linux 2.5", Bhattacharya, Pratt, Pulavarty, and Morgan, Proceedings of the
       Linux Symposium, 2003, https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf

Linux man-pages 6.9.1                              2024-06-15                                             <u><a href="../man7/AIO.7.html">AIO</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>