<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pipe - overview of pipes and FIFOs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pipe - overview of pipes and FIFOs

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pipes  and FIFOs (also known as named pipes) provide a unidirectional interprocess communication channel.
       A pipe has a <u>read</u> <u>end</u> and a <u>write</u> <u>end</u>.  Data written to the write end of a pipe can be read from the read
       end of the pipe.

       A pipe is created using <b><a href="../man2/pipe.2.html">pipe</a></b>(2), which creates a new pipe and returns two file descriptors, one referring
       to the read end of the pipe, the other referring to the write  end.   Pipes  can  be  used  to  create  a
       communication channel between related processes; see <b><a href="../man2/pipe.2.html">pipe</a></b>(2) for an example.

       A  FIFO (short for First In First Out) has a name within the filesystem (created using <b><a href="../man3/mkfifo.3.html">mkfifo</a></b>(3)), and is
       opened using <b><a href="../man2/open.2.html">open</a></b>(2).  Any process may open a FIFO, assuming the file permissions allow it.  The read end
       is opened using the <b>O_RDONLY</b> flag; the write end is opened using the  <b>O_WRONLY</b>  flag.   See  <b><a href="../man7/fifo.7.html">fifo</a></b>(7)  for
       further  details.   <u>Note</u>: although FIFOs have a pathname in the filesystem, I/O on FIFOs does not involve
       operations on the underlying device (if there is one).

   <b>I/O</b> <b>on</b> <b>pipes</b> <b>and</b> <b>FIFOs</b>
       The only difference between pipes and FIFOs is the manner in which they are  created  and  opened.   Once
       these tasks have been accomplished, I/O on pipes and FIFOs has exactly the same semantics.

       If  a process attempts to read from an empty pipe, then <b><a href="../man2/read.2.html">read</a></b>(2) will block until data is available.  If a
       process attempts to write to a full pipe (see below), then <b><a href="../man2/write.2.html">write</a></b>(2) blocks until sufficient data has been
       read from the pipe to allow the write to complete.

       Nonblocking I/O is possible by using the <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_SETFL</b> operation to enable the  <b>O_NONBLOCK</b>  open  file
       status flag or by opening a <b><a href="../man7/fifo.7.html">fifo</a></b>(7) with <b>O_NONBLOCK</b>.  If any process has the pipe open for writing, reads
       fail with <b>EAGAIN</b>; otherwise—with no potential writers—reads succeed and return empty.

       The communication channel provided by a pipe is a <u>byte</u> <u>stream</u>: there is no concept of message boundaries.

       If all file descriptors referring to the write end of a pipe have been closed, then an attempt to <b><a href="../man2/read.2.html">read</a></b>(2)
       from  the  pipe  will  see end-of-file (<b><a href="../man2/read.2.html">read</a></b>(2) will return 0).  If all file descriptors referring to the
       read end of a pipe have been closed, then a <b><a href="../man2/write.2.html">write</a></b>(2) will cause a <b>SIGPIPE</b> signal to be generated for  the
       calling  process.   If  the  calling  process is ignoring this signal, then <b><a href="../man2/write.2.html">write</a></b>(2) fails with the error
       <b>EPIPE</b>.  An application that uses <b><a href="../man2/pipe.2.html">pipe</a></b>(2)  and  <b><a href="../man2/fork.2.html">fork</a></b>(2)  should  use  suitable  <b><a href="../man2/close.2.html">close</a></b>(2)  calls  to  close
       unnecessary  duplicate  file  descriptors;  this ensures that end-of-file and <b>SIGPIPE</b>/<b>EPIPE</b> are delivered
       when appropriate.

       It is not possible to apply <b><a href="../man2/lseek.2.html">lseek</a></b>(2) to a pipe.

   <b>Pipe</b> <b>capacity</b>
       A pipe has a limited capacity.  If the pipe is full, then a <b><a href="../man2/write.2.html">write</a></b>(2) will block  or  fail,  depending  on
       whether  the <b>O_NONBLOCK</b> flag is set (see below).  Different implementations have different limits for the
       pipe capacity.  Applications should not rely on a particular capacity: an application should be  designed
       so  that  a  reading process consumes data as soon as it is available, so that a writing process does not
       remain blocked.

       Before Linux 2.6.11, the capacity of a pipe was the same as the system page size  (e.g.,  4096  bytes  on
       i386).   Since  Linux  2.6.11,  the pipe capacity is 16 pages (i.e., 65,536 bytes in a system with a page
       size of 4096 bytes).  Since Linux 2.6.35, the default pipe capacity is 16 pages, but the capacity can  be
       queried  and  set  using  the  <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2)  <b>F_GETPIPE_SZ</b> and <b>F_SETPIPE_SZ</b> operations.  See <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) for more
       information.

       The following <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operation, which can be applied to a file descriptor that refers to either end  of
       a  pipe,  places  a  count  of the number of unread bytes in the pipe in the <u>int</u> buffer pointed to by the
       final argument of the call:

           ioctl(fd, FIONREAD, &amp;nbytes);

       The <b>FIONREAD</b> operation is not specified in any standard, but is provided on many implementations.

   <b><a href="file:/proc">/proc</a></b> <b>files</b>
       On Linux, the following files control how much memory can be used for pipes:

       <u>/proc/sys/fs/pipe-max-pages</u> (only in Linux 2.6.34)
              An  upper  limit,  in  pages,  on  the  capacity  that  an  unprivileged  user  (one  without  the
              <b>CAP_SYS_RESOURCE</b> capability) can set for a pipe.

              The  default  value  for  this  limit is 16 times the default pipe capacity (see above); the lower
              limit is two pages.

              This interface was removed in Linux 2.6.35, in favor of <u><a href="file:/proc/sys/fs/pipe-max-size">/proc/sys/fs/pipe-max-size</a></u>.

       <u><a href="file:/proc/sys/fs/pipe-max-size">/proc/sys/fs/pipe-max-size</a></u> (since Linux 2.6.35)
              The maximum  size  (in  bytes)  of  individual  pipes  that  can  be  set  by  users  without  the
              <b>CAP_SYS_RESOURCE</b>  capability.   The  value assigned to this file may be rounded upward, to reflect
              the value actually employed for a convenient implementation.  To determine the  rounded-up  value,
              display the contents of this file after assigning a value to it.

              The  default  value  for  this file is 1048576 (1 MiB).  The minimum value that can be assigned to
              this file is the system page size.  Attempts to set a limit less than the page size cause <b><a href="../man2/write.2.html">write</a></b>(2)
              to fail with the error <b>EINVAL</b>.

              Since Linux 4.9, the value on this file also acts as a ceiling on the default capacity  of  a  new
              pipe or newly opened FIFO.

       <u><a href="file:/proc/sys/fs/pipe-user-pages-hard">/proc/sys/fs/pipe-user-pages-hard</a></u> (since Linux 4.5)
              The  hard  limit on the total size (in pages) of all pipes created or set by a single unprivileged
              user (i.e., one with neither the <b>CAP_SYS_RESOURCE</b> nor the <b>CAP_SYS_ADMIN</b> capability).  So  long  as
              the  total  number  of pages allocated to pipe buffers for this user is at this limit, attempts to
              create new pipes will be denied, and attempts to increase a pipe's capacity will be denied.

              When the value of this limit is zero (which is the default), no hard limit is applied.

       <u><a href="file:/proc/sys/fs/pipe-user-pages-soft">/proc/sys/fs/pipe-user-pages-soft</a></u> (since Linux 4.5)
              The soft limit on the total size (in pages) of all pipes created or set by a  single  unprivileged
              user  (i.e.,  one with neither the <b>CAP_SYS_RESOURCE</b> nor the <b>CAP_SYS_ADMIN</b> capability).  So long as
              the total number of pages allocated to pipe buffers for this user is  at  this  limit,  individual
              pipes  created  by  a user will be limited to one page, and attempts to increase a pipe's capacity
              will be denied.

              When the value of this limit is zero, no soft limit is applied.  The default value for  this  file
              is 16384, which permits creating up to 1024 pipes with the default capacity.

       Before  Linux  4.9,  some bugs affected the handling of the <u>pipe-user-pages-soft</u> and <u>pipe-user-pages-hard</u>
       limits; see BUGS.

   <b>PIPE_BUF</b>
       POSIX.1 says that writes of less than <b>PIPE_BUF</b> bytes must be atomic: the output data is  written  to  the
       pipe  as  a  contiguous  sequence.   Writes  of more than <b>PIPE_BUF</b> bytes may be nonatomic: the kernel may
       interleave the data with data written by other processes.  POSIX.1 requires <b>PIPE_BUF</b> to be at  least  512
       bytes.   (On Linux, <b>PIPE_BUF</b> is 4096 bytes.)  The precise semantics depend on whether the file descriptor
       is nonblocking (<b>O_NONBLOCK</b>), whether there are multiple writers to the pipe, and  on  <u>n</u>,  the  number  of
       bytes to be written:

       <b>O_NONBLOCK</b> disabled, <u>n</u> &lt;= <b>PIPE_BUF</b>
              All  <u>n</u>  bytes  are  written  atomically; <b><a href="../man2/write.2.html">write</a></b>(2) may block if there is not room for <u>n</u> bytes to be
              written immediately

       <b>O_NONBLOCK</b> enabled, <u>n</u> &lt;= <b>PIPE_BUF</b>
              If there is room to write <u>n</u> bytes to the pipe, then <b><a href="../man2/write.2.html">write</a></b>(2) succeeds immediately, writing  all  <u>n</u>
              bytes; otherwise <b><a href="../man2/write.2.html">write</a></b>(2) fails, with <u>errno</u> set to <b>EAGAIN</b>.

       <b>O_NONBLOCK</b> disabled, <u>n</u> &gt; <b>PIPE_BUF</b>
              The  write  is  nonatomic:  the  data given to <b><a href="../man2/write.2.html">write</a></b>(2) may be interleaved with <b><a href="../man2/write.2.html">write</a></b>(2)s by other
              process; the <b><a href="../man2/write.2.html">write</a></b>(2) blocks until <u>n</u> bytes have been written.

       <b>O_NONBLOCK</b> enabled, <u>n</u> &gt; <b>PIPE_BUF</b>
              If the pipe is full, then <b><a href="../man2/write.2.html">write</a></b>(2) fails, with <u>errno</u> set to <b>EAGAIN</b>.  Otherwise, from 1 to <u>n</u>  bytes
              may  be  written (i.e., a "partial write" may occur; the caller should check the return value from
              <b><a href="../man2/write.2.html">write</a></b>(2) to see how many bytes were actually written), and these bytes  may  be  interleaved  with
              writes by other processes.

   <b>Open</b> <b>file</b> <b>status</b> <b>flags</b>
       The  only  open  file  status flags that can be meaningfully applied to a pipe or FIFO are <b>O_NONBLOCK</b> and
       <b>O_ASYNC</b>.

       Setting the <b>O_ASYNC</b> flag for the read end of a pipe causes a signal (<b>SIGIO</b> by default)  to  be  generated
       when  new  input becomes available on the pipe.  The target for delivery of signals must be set using the
       <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_SETOWN</b> command.  On Linux, <b>O_ASYNC</b> is supported for pipes and FIFOs only since Linux 2.6.

   <b>Portability</b> <b>notes</b>
       On some systems (but not Linux), pipes are bidirectional: data can  be  transmitted  in  both  directions
       between  the  pipe ends.  POSIX.1 requires only unidirectional pipes.  Portable applications should avoid
       reliance on bidirectional pipe semantics.

   <b>BUGS</b>
       Before Linux 4.9, some bugs affected the handling of the  <u>pipe-user-pages-soft</u>  and  <u>pipe-user-pages-hard</u>
       limits when using the <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) <b>F_SETPIPE_SZ</b> operation to change a pipe's capacity:

       (a)  When  increasing  the  pipe  capacity, the checks against the soft and hard limits were made against
            existing consumption, and excluded the memory required for the increased  pipe  capacity.   The  new
            increase in pipe capacity could then push the total memory used by the user for pipes (possibly far)
            over a limit.  (This could also trigger the problem described next.)

            Starting with Linux 4.9, the limit checking includes the memory required for the new pipe capacity.

       (b)  The  limit  checks  were  performed  even when the new pipe capacity was less than the existing pipe
            capacity.  This could lead to problems if a user set a large pipe capacity, and then the limits were
            lowered, with the result that the user could no longer decrease the pipe capacity.

            Starting with Linux 4.9, checks against the limits are  performed  only  when  increasing  a  pipe's
            capacity; an unprivileged user can always decrease a pipe's capacity.

       (c)  The accounting and checking against the limits were done as follows:

            (1)  Test whether the user has exceeded the limit.
            (2)  Make the new pipe buffer allocation.
            (3)  Account new allocation against the limits.

            This  was  racey.   Multiple  processes  could pass point (1) simultaneously, and then allocate pipe
            buffers that were accounted for only in step (3), with  the  result  that  the  user's  pipe  buffer
            allocation could be pushed over the limit.

            Starting  with  Linux  4.9,  the  accounting  step is performed before doing the allocation, and the
            operation fails if the limit would be exceeded.

       Before Linux 4.9, bugs similar to points (a) and (c) could also occur when the  kernel  allocated  memory
       for a new pipe buffer; that is, when calling <b><a href="../man2/pipe.2.html">pipe</a></b>(2) and when opening a previously unopened FIFO.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/mkfifo.1.html">mkfifo</a></b>(1),  <b><a href="../man2/dup.2.html">dup</a></b>(2),  <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2),  <b><a href="../man2/open.2.html">open</a></b>(2),  <b><a href="../man2/pipe.2.html">pipe</a></b>(2), <b><a href="../man2/poll.2.html">poll</a></b>(2), <b><a href="../man2/select.2.html">select</a></b>(2), <b><a href="../man2/socketpair.2.html">socketpair</a></b>(2), <b><a href="../man2/splice.2.html">splice</a></b>(2), <b><a href="../man2/stat.2.html">stat</a></b>(2),
       <b><a href="../man2/tee.2.html">tee</a></b>(2), <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2), <b><a href="../man3/mkfifo.3.html">mkfifo</a></b>(3), <b><a href="../man7/epoll.7.html">epoll</a></b>(7), <b><a href="../man7/fifo.7.html">fifo</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                            <u><a href="../man7/pipe.7.html">pipe</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>