<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>roff - concepts and history of roff typesetting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/groff">groff_1.23.0-9_amd64</a> <br><br><pre>
</pre><h4><b>Name</b></h4><pre>
       roff - concepts and history of <u>roff</u> typesetting

</pre><h4><b>Description</b></h4><pre>
       The  term  <u>roff</u>  denotes  a  family  of document formatting systems known by names like <u>troff</u>, <u>nroff</u>, and
       <u>ditroff</u>.  A <u>roff</u> system consists of an interpreter for an extensible text formatting language and  a  set
       of programs for preparing output for various devices and file formats.  Unix-like operating systems often
       distribute  a  <u>roff</u>  system.   The  manual  pages  on Unix systems (“man pages”) and bestselling books on
       software engineering, including Brian Kernighan and Dennis Ritchie's <u>The</u> <u>C</u> <u>Programming</u>  <u>Language</u>  and  W.
       Richard Stevens's <u>Advanced</u> <u>Programming</u> <u>in</u> <u>the</u> <u>Unix</u> <u>Environment</u> have been written using <u>roff</u> systems.  GNU
       <u>roff</u>—<u>groff</u>—is arguably the most widespread <u>roff</u> implementation.

       Below we present typographical concepts that form the background of all <u>roff</u> implementations, narrate the
       development  history  of  some  <u>roff</u> systems, detail the command pipeline managed by <u><a href="../man1/groff.1.html">groff</a></u>(1), survey the
       formatting language, suggest tips for editing <u>roff</u> input, and recommend further reading materials.

</pre><h4><b>Concepts</b></h4><pre>
       <u>roff</u> input files contain text interspersed with instructions to  control  the  formatter.   Even  in  the
       absence  of  such  instructions,  a <u>roff</u> formatter still processes its input in several ways, by filling,
       hyphenating, breaking, and adjusting it, and supplementing it with inter-sentence space.  These processes
       are basic to typesetting, and can be controlled at the input document's discretion.

       When a device-independent <u>roff</u> formatter starts up, it obtains information about the device for which  it
       is preparing output from the latter's description file (see <u><a href="../man5/groff_font.5.html">groff_font</a></u>(5)).  An essential property is the
       length of the output line, such as “6.5 inches”.

       The  formatter  interprets  plain text files employing the Unix line-ending convention.  It reads input a
       character at a time, collecting words as it goes, and fits as many words together on an output line as it
       can—this is known as <u>filling.</u>  To a <u>roff</u> system, a <u>word</u> is any sequence of one or  more  characters  that
       aren't spaces or newlines.  The exceptions separate words.

       A  <u>roff</u> formatter attempts to detect boundaries between sentences, and supplies additional inter-sentence
       space between them.  It flags certain characters (normally “<b>!</b>”, “<b>?</b>”, and “<b>.</b>”)  as  potentially  ending  a
       sentence.   When  the formatter encounters one of these <u>end-of-sentence</u> <u>characters</u> at the end of an input
       line, or one of them is followed by two (unescaped) spaces on the same input line, it appends  an  inter-
       word space followed by an inter-sentence space in the output.  The dummy character escape sequence <b>\&amp;</b> can
       be  used  after an end-of-sentence character to defeat end-of-sentence detection on a per-instance basis.
       Normally, the occurrence of a visible non-end-of-sentence character  (as  opposed  to  a  space  or  tab)
       immediately  after  an  end-of-sentence  character  cancels detection of the end of a sentence.  However,
       several characters are treated <u>transparently</u> after the occurrence of an end-of-sentence character.   That
       is,  a  <u>roff</u>  does  not  cancel  end-of-sentence  detection when it processes them.  This is because such
       characters are often used as footnote markers or to close quotations and parentheticals.  The default set
       is <b>"</b>, <b>'</b>, <b>)</b>, <b>]</b>, <b>*</b>, <b>\[dg]</b>, <b>\[dd]</b>, <b>\[rq]</b>, and <b>\[cq]</b>.  The last four  are  examples  of  <u>special</u>  <u>characters,</u>
       escape  sequences  whose  purpose is to obtain glyphs that are not easily typed at the keyboard, or which
       have special meaning to the formatter (like <b>\</b>).

       When an output line is nearly full, it is uncommon for the next word collected from the input to  exactly
       fill  it—typically,  there  is room left over only for part of the next word.  The process of splitting a
       word so that it appears partially on one line (with a hyphen to indicate to the reader that the word  has
       been  broken)  with  its  remainder  on  the  next  is  <u>hyphenation.</u>   Hyphenation points can be manually
       specified; <u>groff</u> also uses a hyphenation algorithm and language-specific pattern files  to  decide  which
       words can be hyphenated and where.  Hyphenation does not always occur even when the hyphenation rules for
       a  word allow it; it can be disabled, and when not disabled there are several parameters that can prevent
       it in certain circumstances.

       Once an output line is full, the next word (or remainder of a hyphenated one) is placed  on  a  different
       output  line;  this  is called a <u>break.</u>  In this document and in <u>roff</u> discussions generally, a “break” if
       not further qualified always refers to the termination of an output line.  When the formatter is  filling
       text,  it introduces breaks automatically to keep output lines from exceeding the configured line length.
       After an automatic break, a <u>roff</u> formatter <u>adjusts</u> the line if applicable (see below), and  then  resumes
       collecting and filling text on the next output line.

       Sometimes,  a  line  cannot  be broken automatically.  This usually does not happen with natural language
       text unless the output line length  has  been  manipulated  to  be  extremely  short,  but  it  can  with
       specialized  text  like  program  source code.  <u>groff</u> provides a means of telling the formatter where the
       line may be broken without hyphens.  This is done with the non-printing break point escape sequence <b>\:</b>.

       There are several ways to cause a break at a predictable location.  A blank input line not only causes  a
       break, but by default it also outputs a one-line vertical space (effectively a blank output line).  Macro
       packages may discourage or disable this “blank line method” of paragraphing in favor of their own macros.
       A line that begins with one or more spaces causes a break.  The spaces are output at the beginning of the
       next  line  without  being  <u>adjusted</u>  (see  below).   Again,  macro packages may provide other methods of
       producing indented paragraphs.  Trailing spaces on <u>text</u> <u>lines</u> (see below)  are  discarded.   The  end  of
       input causes a break.

       After  the formatter performs an automatic break, it may then <u>adjust</u> the line, widening inter-word spaces
       until the text reaches the right margin.  Extra spaces between words are preserved.  Leading and trailing
       spaces are handled as noted above.  Text can be aligned to the left or right margin  only,  or  centered,
       using <u>requests.</u>

       A  <u>roff</u>  formatter  translates  horizontal  tab  characters, also called simply “tabs”, in the input into
       movements to the next tab stop.  These tab stops are by default located every half inch measured from the
       current position on the input line.  With them, simple tables can be made.  However, this method  can  be
       deceptive,  as the appearance (and width) of the text in an editor and the results from the formatter can
       vary greatly, particularly when proportional typefaces are used.  A tab character does not cause a  break
       and  therefore  does  not  interrupt  filling.  The formatter provides facilities for sophisticated table
       composition; there are many details to track when using the “tab” and “field” low-level features, so most
       users turn to the <u><a href="../man1/tbl.1.html">tbl</a></u>(1) preprocessor to lay out tables.

   <b>Requests</b> <b>and</b> <b>macros</b>
       A <u>request</u> is an instruction to the formatter that occurs after a <u>control</u> <u>character,</u> which  is  recognized
       at the beginning of an input line.  The regular control character is a dot “<b>.</b>”.  Its counterpart, the <u>no-</u>
       <u>break</u>  <u>control</u> <u>character,</u> a neutral apostrophe “<b>'</b>”, suppresses the break implied by some requests.  These
       characters were chosen because it is uncommon for lines of text in natural languages to begin with  them.
       If  you  require  a formatted period or apostrophe (closing single quotation mark) where the formatter is
       expecting a control character, prefix the dot or neutral  apostrophe  with  the  dummy  character  escape
       sequence, “<b>\&amp;</b>”.

       An  input  line beginning with a control character is called a <u>control</u> <u>line.</u>  Every line of input that is
       not a control line is a <u>text</u> <u>line.</u>

       Requests often take <u>arguments,</u> words (separated from the request name and  each  other  by  spaces)  that
       specify  details of the action the formatter is expected to perform.  If a request is meaningless without
       arguments, it is typically ignored.  Of key importance are the requests that define macros.   Macros  are
       invoked like requests, enabling the request repertoire to be extended or overridden.

       A  <u>macro</u>  can be thought of as an abbreviation you can define for a collection of control and text lines.
       When the macro is <u>called</u> by giving its name after a control character, it is replaced with what it stands
       for.  The process of textual replacement is known as <u>interpolation.</u>  Interpolations are handled  as  soon
       as  they are recognized, and once performed, a <u>roff</u> formatter scans the replacement for further requests,
       macro calls, and escape sequences.

       In <u>roff</u> systems, the “<b>de</b>” request defines a macro.

   <b>Page</b> <b>geometry</b>
       <u>roff</u> systems format text under certain assumptions about the size of the output medium, or page.  For the
       formatter to correctly break a line it is filling, it must know the line length, which  it  derives  from
       the  page  width.  For it to decide whether to write an output line to the current page or wait until the
       next one, it must know the page length.  A device's <u>resolution</u> converts practical units  like  inches  or
       centimeters  to  <u>basic</u>  <u>units,</u>  a  convenient  length  measure for the output device or file format.  The
       formatter and output driver use basic units to reckon page measurements.   The  device  description  file
       defines its resolution and page dimensions (see <u><a href="../man5/groff_font.5.html">groff_font</a></u>(5)).

       A  <u>page</u>  is  a two-dimensional structure upon which a <u>roff</u> system imposes a rectangular coordinate system
       with its upper left corner as the origin.  Coordinate values are in basic units and increase down and  to
       the right.  Useful ones are therefore always positive and within numeric ranges corresponding to the page
       boundaries.

       While  the  formatter  (and,  later,  output  driver) is processing a page, it keeps track of its <u>drawing</u>
       <u>position,</u> which is the location at which the next glyph will be written, from which the next motion  will
       be  measured, or where a geometric object will commence rendering.  Notionally, glyphs are drawn from the
       text baseline upward and to the right.  (<u>groff</u> does not yet support  right-to-left  scripts.)   The  <u>text</u>
       <u>baseline</u>  is  a  (usually  invisible)  line  upon  which  the  glyphs of a typeface are aligned.  A glyph
       therefore “starts” at its bottom-left corner.  If drawn at the origin, a typical letter glyph  would  lie
       partially  or  wholly  off  the  page,  depending on whether, like “g”, it features a descender below the
       baseline.

       Such a situation is nearly always undesirable.  It is furthermore conventional not to write  or  draw  at
       the  extreme edges of the page.  Therefore the initial drawing position of a <u>roff</u> formatter is not at the
       origin, but below and to the right of it.  This rightward shift from the left edge is known as  the  <u>page</u>
       <u>offset.</u>  (<u>groff</u>'s terminal output devices have page offsets of zero.)  The downward shift leaves room for
       a text output line.

       Text  is  arranged on a one-dimensional lattice of text baselines from the top to the bottom of the page.
       <u>Vertical</u> <u>spacing</u> is the distance between  adjacent  text  baselines.   Typographic  tradition  sets  this
       quantity to 120% of the type size.  The initial vertical drawing position is one unit of vertical spacing
       below the page top.  Typographers term this unit a <u>vee.</u>

       Vertical spacing has an impact on page-breaking decisions.  Generally, when a break occurs, the formatter
       moves  the  drawing  position  to  the  next  text baseline automatically.  If the formatter were already
       writing to the last line that would fit on the page, advancing by one  vee  would  place  the  next  text
       baseline  off the page.  Rather than let that happen, <u>roff</u> formatters instruct the output driver to eject
       the page, start a new one, and again set the drawing position to one vee below the page top;  this  is  a
       <u>page</u> <u>break.</u>

       When  the  last  line  of input text corresponds to the last output line that fits on the page, the break
       caused by the end of input will also break the page, producing a useless blank one.  Macro packages  keep
       users  from  having  to  confront this difficulty by setting “traps”; moreover, all but the simplest page
       layouts tend to have headers and footers, or at least bear vertical margins larger than one vee.

   <b>Other</b> <b>language</b> <b>elements</b>
       <u>Escape</u> <u>sequences</u> start with the <u>escape</u> <u>character,</u> a backslash  <b>\</b>,  and  are  followed  by  at  least  one
       additional character.  They can appear anywhere in the input.

       With requests, the escape and control characters can be changed; further, escape sequence recognition can
       be turned off and back on.

       <u>Strings</u> store character sequences.  In <u>groff</u>, they can be parameterized as macros can.

       <u>Registers</u>  store  numerical  values,  including  measurements.   The latter are generally in basic units;
       <u>scaling</u> <u>units</u>  can  be  appended  to  numeric  expressions  to  clarify  their  meaning  when  stored  or
       interpolated.  Some read-only predefined registers interpolate text.

       <u>Fonts</u> are identified either by a name or by a mounting position (a non-negative number).  Four styles are
       available  on  all  devices.   <b>R</b> is “roman”: normal, upright text.  <b>B</b> is <b>bold</b>, an upright typeface with a
       heavier weight.  <b>I</b> is <u>italic</u>, a face that is oblique on typesetter output devices and usually  underlined
       instead  on  terminal  devices.   <b>BI</b>  is  <u><b>bold-italic</b></u>,  combining both of the foregoing style variations.
       Typesetting devices group these four styles into <u>families</u> of text fonts; they also typically offer one or
       more <u>special</u> fonts that provide unstyled glyphs; see <u><a href="../man7/groff_char.7.html">groff_char</a></u>(7).

       <u>groff</u> supports named <u>colors</u> for glyph rendering and drawing of geometric objects.  Stroke and fill colors
       are distinct; the stroke color is used for glyphs.

       <u>Glyphs</u> are visual representation forms of <u>characters.</u>   In  <u>groff,</u>  the  distinction  between  those  two
       elements is not always obvious (and a full discussion is beyond our scope).  In brief, “A” is a character
       when  we  consider it in the abstract: to make it a glyph, we must select a typeface with which to render
       it, and determine its type size and color.  The formatting process turns  input  characters  into  output
       glyphs.   A  few characters commonly seen on keyboards are treated specially by the <u>roff</u> language and may
       not look correct in output if used unthinkingly; they are the (double) quotation mark  (<b>"</b>),  the  neutral
       apostrophe  (<b>'</b>),  the  minus  sign  (<b>-</b>), the backslash (<b>\</b>), the caret or circumflex accent (<b>^</b>), the grave
       accent (<b>`</b>), and the tilde (<b>~</b>).  All of these and more can  be  produced  with  <u>special</u>  <u>character</u>  escape
       sequences; see <u><a href="../man7/groff_char.7.html">groff_char</a></u>(7).

       <u>groff</u>  offers  <u>streams</u>, identifiers for writable files, but for security reasons this feature is disabled
       by default.

       A further few  language  elements  arise  as  page  layouts  become  more  sophisticated  and  demanding.
       <u>Environments</u>  collect  formatting parameters like line length and typeface.  A <u>diversion</u> stores formatted
       output for later use.  A <u>trap</u> is a condition  on  the  input  or  output,  tested  automatically  by  the
       formatter, that is associated with a macro, calling it when that condition is fulfilled.

       Footnote support often exercises all three of the foregoing features.  A simple implementation might work
       as  follows.  A pair of macros is defined: one starts a footnote and the other ends it.  The author calls
       the first macro where a footnote marker is desired.  The  macro  establishes  a  diversion  so  that  the
       footnote  text  is  collected  at  the place in the body text where its corresponding marker appears.  An
       environment is created for the footnote so that it is set at a smaller typeface.  The  footnote  text  is
       formatted  in  the  diversion  using  that  environment,  but  it does not yet appear in the output.  The
       document author calls the footnote end macro, which returns to the  previous  environment  and  ends  the
       diversion.  Later, after much more body text in the document, a trap, set a small distance above the page
       bottom,  is  sprung.   The  macro  called  by  the trap draws a line across the page and emits the stored
       diversion.  Thus, the footnote is rendered.

</pre><h4><b>History</b></h4><pre>
       Computer-driven document formatting dates back to the 1960s.  The <u>roff</u>  system  is  intimately  connected
       with Unix, but its origins lie with the earlier operating systems CTSS, GECOS, and Multics.

   <b>The</b> <b>predecessor—</b><u><b>RUNOFF</b></u>
       <u>roff</u>'s  ancestor  <u>RUNOFF</u>  was written in the MAD language by Jerry Saltzer to prepare his Ph.D. thesis on
       the Compatible Time Sharing System (CTSS), a project of the Massachusetts Institute of Technology  (MIT).
       This  program  is  referred  to  in  full capitals, both to distinguish it from its many descendants, and
       because bits were expensive in those days; five- and six-bit character encodings were still in widespread
       usage, and mixed-case alphabetics in file names seen as a luxury.  <u>RUNOFF</u> introduced a syntax of inlining
       formatting directives amid document text, by beginning a line with a period (an  unlikely  occurrence  in
       human-readable  material)  followed  by a “control word”.  Control words with obvious meaning like “.line
       length <u>n</u>” were supported as well as an abbreviation system; the latter came to overwhelm  the  former  in
       popular  usage  and  later derivatives of the program.  A sample of control words from a <u>RUNOFF</u> manual of
       December 1966  was  documented  as  follows  (with  the  parameter  notation  slightly   altered).    The
       abbreviations will be familiar to <u>roff</u> veterans.

                                            Abbreviation   Control word
                                                     <b>.ad</b>   .adjust
                                                     <b>.bp</b>   .begin page
                                                     <b>.br</b>   .break
                                                     <b>.ce</b>   .center
                                                     <b>.in</b>   .indent <u>n</u>
                                                     <b>.ll</b>   .line length <u>n</u>
                                                     <b>.nf</b>   .nofill
                                                     <b>.pl</b>   .paper length <u>n</u>
                                                     <b>.sp</b>   .space [<u>n</u>]

       In  1965,  MIT's  Project  MAC  teamed  with  Bell  Telephone  Laboratories  and General Electric (GE) to
       inaugurate the Multics project.  After a few years, Bell Labs discontinued its participation in  Multics,
       famously  prompting the development of Unix.  Meanwhile, Saltzer's <u>RUNOFF</u> proved influential, seeing many
       ports and derivations elsewhere.

       In 1969, Doug McIlroy wrote one such reimplementation, adding extensions, in the BCPL language for  a  GE
       645  running  GECOS  at  the  Bell  Labs location in Murray Hill, New Jersey.  In its manual, the control
       commands were termed “requests”, their two-letter names were canonical, and  the  control  character  was
       configurable  with  a  <b>.cc</b>  request.  Other familiar requests emerged at this time; no-adjust (<b>.na</b>), need
       (<b>.ne</b>), page offset (<b>.po</b>), tab configuration (<b>.ta</b>, though it worked differently), temporary indent  (<b>.ti</b>),
       character  translation  (<b>.tr</b>),  and  automatic  underlining  (<b>.ul</b>;  on  <u>RUNOFF</u>  you  had to backspace and
       underscore in the input yourself).  <b>.fi</b> to enable filling of output lines got the name it retains to this
       day.  McIlroy's program also featured a heuristic system for automatically  placing  hyphenation  points,
       designed and implemented by Molly Wagner.  It furthermore introduced numeric variables, termed registers.
       By  1971, this program had been ported to Multics and was known as <u>roff</u>, a name McIlroy attributes to Bob
       Morris, to distinguish it from CTSS <u>RUNOFF</u>.

   <b>Unix</b> <b>and</b> <u><b>roff</b></u>
       McIlroy's <u>roff</u> was one of the first Unix programs.  In Ritchie's term, it was “transliterated” from  BCPL
       to  DEC  PDP-7  assembly  language  for  the  fledgling Unix operating system.  Automatic hyphenation was
       managed with <b>.hc</b> and <b>.hy</b> requests, line spacing control was generalized with the <b>.ls</b>  request,  and  what
       later  <u>roff</u>s  would  call diversions were available via “footnote” requests.  This <u>roff</u> indirectly funded
       operating systems research at Murray Hill; AT&amp;T prepared patent applications to the U.S. government  with
       it.   This  arrangement  enabled the group to acquire a PDP-11; <u>roff</u> promptly proved equal to the task of
       formatting the manual for what would become known as “First Edition Unix”, dated November 1971.

       Output from all of the foregoing programs was limited to line printers and paper terminals  such  as  the
       IBM  2471  (based  on  the  Selectric  line  of  typewriters)  and  the  Teletype  Corporation  Model 37.
       Proportionally spaced type was unavailable.

   <b>New</b> <u><b>roff</b></u> <b>and</b> <b>Typesetter</b> <u><b>roff</b></u>
       The first years of Unix were spent in rapid evolution.   The  practicalities  of  preparing  standardized
       documents  like patent applications (and Unix manual pages), combined with McIlroy's enthusiasm for macro
       languages, perhaps created an irresistible pressure  to  make  <u>roff</u>  extensible.   Joe  Ossanna's  <u>nroff</u>,
       literally  a  “new  roff”,  was  the  outlet  for this pressure.  By the time of Unix Version 3 (February
       1973)—and still in PDP-11 assembly language—it sported a swath of features now  considered  essential  to
       <u>roff</u>  systems:  definition  of  macros (<b>.de</b>), diversion of text thither (<b>.di</b>), and removal thereof (<b>.rm</b>);
       trap  planting  (<b>.wh</b>;  “when”)  and  relocation  (<b>.ch</b>;  “change”);  conditional  processing  (<b>.if</b>);   and
       environments (<b>.ev</b>).  Incremental improvements included assignment of the next page number (<b>.pn</b>); no-space
       mode  (<b>.ns</b>)  and  restoration  of  vertical  spacing (<b>.rs</b>); the saving (<b>.sv</b>) and output (<b>.os</b>) of vertical
       space; specification of replacement characters for tabs (<b>.tc</b>) and leaders (<b>.lc</b>); configuration of the no-
       break control character (<b>.c2</b>); shorthand to disable automatic hyphenation (<b>.nh</b>); a condensation  of  what
       were  formerly  six  different requests for configuration of page “titles” (headers and footers) into one
       (<b>.tl</b>) with a length controlled separately from the line length (<b>.lt</b>);  automatic  line  numbering  (<b>.nm</b>);
       interactive  input  (<b>.rd</b>),  which  necessitated buffer-flushing (<b>.fl</b>), and was made convenient with early
       program cessation (<b>.ex</b>); source file inclusion in its modern form (<b>.so</b>; though <u>RUNOFF</u>  had  an  “.append”
       control  word for a similar purpose) and early advance to the next file argument (<b>.nx</b>); ignorable content
       (<b>.ig</b>); and programmable abort (<b>.ab</b>).

       Third Edition Unix also brought the <u><a href="../man2/pipe.2.html">pipe</a></u>(2) system call, the explosive growth of a  componentized  system
       based around it, and a “filter model” that remains perceptible today.  Equally importantly, the Bell Labs
       site  in  Murray Hill acquired a Graphic Systems C/A/T phototypesetter, and with it came the necessity of
       expanding the capabilities of a <u>roff</u> system to cope with a variety of proportionally spaced typefaces  at
       multiple  sizes.   Ossanna  wrote a parallel implementation of <u>nroff</u> for the C/A/T, dubbing it <u>troff</u> (for
       “typesetter roff”).  Unfortunately, surviving  documentation  does  not  illustrate  what  requests  were
       implemented  at this time for C/A/T support; the <u><a href="../man1/troff.1.html">troff</a></u>(1) man page in Fourth Edition Unix (November 1973)
       does not feature a request list, unlike <u><a href="../man1/nroff.1.html">nroff</a></u>(1).  Apart from typesetter-driven features, Unix Version  4
       <u>roff</u>s  added string definitions (<b>.ds</b>); made the escape character configurable (<b>.ec</b>); and enabled the user
       to write diagnostics to the standard error stream (<b>.tm</b>).   Around  1974,  empowered  with  multiple  type
       sizes, italics, and a symbol font specially commissioned by Bell Labs from Graphic Systems, Kernighan and
       Lorinda  Cherry  implemented  <u>eqn</u> for typesetting mathematics.  In the same year, for Fifth Edition Unix,
       Ossanna combined and reimplemented the two <u>roff</u>s in C, using that  language's  preprocessor  to  generate
       both from a single source tree.

       Ossanna  documented the syntax of the input language to the <u>nroff</u> and <u>troff</u> programs in the “Troff User's
       Manual”, first published in 1976, with further revisions as late as 1992  by  Kernighan.   (The  original
       version was entitled “Nroff/Troff User's Manual”, which may partially explain why <u>roff</u> practitioners have
       tended  to refer to it by its AT&amp;T document identifier, “CSTR #54”.)  Its final revision serves as the <u>de</u>
       <u>facto</u> specification of AT&amp;T <u>troff</u>, and all subsequent implementors of <u>roff</u> systems have done  so  in  its
       shadow.

       A small and simple set of <u>roff</u> macros was first used for the manual pages of Unix Version 4 and persisted
       for  two  further  releases, but the first macro package to be formally described and installed was <u>ms</u> by
       Michael Lesk in Version 6.  He also wrote a manual, “Typing Documents on the Unix System”, describing  <u>ms</u>
       and basic <u>nroff</u>/<u>troff</u> usage, updating it as the package accrued features.  Sixth Edition additionally saw
       the debut of the <u>tbl</u> preprocessor for formatting tables, also by Lesk.

       For  Unix  Version 7 (January 1979), McIlroy designed, implemented, and documented the <u>man</u> macro package,
       introducing most of the macros described in <u><a href="../man7/groff_man.7.html">groff_man</a></u>(7) today, and edited volume  1  of  the  Version  7
       manual using it.  Documents composed using <u>ms</u> featured in volume 2, edited by Kernighan.

       Meanwhile,  <u>troff</u>  proved  popular  even  at  Unix  sites  that lacked a C/A/T device.  Tom Ferrin of the
       University of California at San Francisco combined it  with  Allen  Hershey's  popular  vector  fonts  to
       produce  <u>vtroff</u>,  which  translated  <u>troff</u>'s  output to the command language used by Versatec and Benson-
       Varian plotters.

       Ossanna had passed away unexpectedly in 1977, and  after  the  release  of  Version  7,  with  the  C/A/T
       typesetter  becoming  supplanted  by alternative devices such as the Mergenthaler Linotron 202, Kernighan
       undertook a revision and  rewrite  of  <u>troff</u>  to  generalize  its  design.   To  implement  this  revised
       architecture, he developed the font and device description file formats and the page description language
       that  remain in use today.  He described these novelties in the article “A Typesetter-independent TROFF”,
       last revised in 1982, and like the <u>troff</u> manual itself, it is widely known by a shorthand, “CSTR #97”.

       Kernighan's innovations prepared <u>troff</u> well for the introduction of the Adobe PostScript language in 1982
       and a vibrant market in laser  printers  with  built-in  interpreters  for  it.   An  output  driver  for
       PostScript,  <u>dpost</u>,  was  swiftly developed.  However, AT&amp;T's software licensing practices kept Ossanna's
       <u>troff</u>, with its tight coupling to  the  C/A/T's  capabilities,  in  parallel  distribution  with  device-
       independent  <u>troff</u>  throughout  the  1980s.   Today,  however,  all  actively  maintained  <u>troff</u>s  follow
       Kernighan's device-independent design.

   <u><b>groff</b></u><b>—a</b> <b>free</b> <u><b>roff</b></u> <b>from</b> <b>GNU</b>
       The most important free <u>roff</u> project historically has  been  <u>groff</u>,  the  GNU  implementation  of  <u>troff</u>,
       developed  by  James  Clark starting in 1989 and distributed under copyleft licenses, ensuring to all the
       availability of source code and the freedom to modify and redistribute it,  properties  unprecedented  in
       <u>roff</u>  systems  to  that point.  <u>groff</u> rapidly attracted contributors, and has served as a replacement for
       almost all applications of AT&amp;T <u>troff</u>  (exceptions  include  <u>mv</u>,  a  macro  package  for  preparation  of
       viewgraphs   and   slides,  and  the  <u>ideal</u>  preprocessor,  which  produces  diagrams  from  mathematical
       constraints).  Beyond that, it has added numerous features; see <u><a href="../man7/groff_diff.7.html">groff_diff</a></u>(7).  Since its  inception  and
       for at least the following three decades, it has been used by practically all GNU/Linux and BSD operating
       systems.

       <u>groff</u>  continues to be developed, is available for almost all operating systems in common use (along with
       several obscure ones), and is free.  These factors make <u>groff</u> the <u>de</u> <u>facto</u> <u>roff</u> standard today.

   <b>Other</b> <b>free</b> <u><b>roff</b></u><b>s</b>
       In 2007, Caldera/SCO and Sun Microsystems, having acquired rights to AT&amp;T  Documenter's  Workbench  (DWB)
       <u>troff</u>  (a descendant of the Bell Labs code), released it under a free but GPL-incompatible license.  This
       implementation was made portable to modern POSIX systems, and adopted and enhanced first by Gunnar Ritter
       and then Carsten Kunze to produce Heirloom Doctools <u>troff</u>.

       In July 2013, Ali Gholami Rudi announced <u>neatroff</u>, a permissively licensed new implementation.

       Another descendant of DWB <u>troff</u> is part of Plan 9 from User Space.   Since  2021,  this  <u>troff</u>  has  been
       available under permissive terms.

<b>Using</b> <u><b>roff</b></u>
       When  you  read  a man page, often a <u>roff</u> is the program rendering it.  Some <u>roff</u> implementations provide
       wrapper programs that make it easy to use the <u>roff</u> system from the shell's command line.   These  can  be
       specific  to  a  macro  package, like <u><a href="../man1/mmroff.1.html">mmroff</a></u>(1), or more general.  <u><a href="../man1/groff.1.html">groff</a></u>(1) provides command-line options
       sparing the user from constructing the long, order-dependent pipelines  familiar  to  AT&amp;T  <u>troff</u>  users.
       Further,  a  heuristic  program,  <u><a href="../man1/grog.1.html">grog</a></u>(1),  is  available to infer from a document's contents which <u>groff</u>
       arguments should be used to process it.

   <b>The</b> <u><b>roff</b></u> <b>pipeline</b>
       A typical <u>roff</u> document is prepared by running one  or  more  processors  in  series,  followed  by  a  a
       formatter  program  and  then an output driver (or “device postprocessor”).  Commonly, these programs are
       structured into a pipeline; that is, each is run in sequence such that the output of one is taken as  the
       input  to  the next, without passing through secondary storage.  (On non-Unix systems, pipelines may have
       to be simulated with temporary files.)

              $ <u>preproc1</u> <b>&lt;</b> <u>input-file</u> <b>|</b> <u>preproc2</u> <b>|</b> ... <b>|</b> <b>troff</b> [<u>option</u>] ... <b>\</b>
                  <b>|</b> <u>output-driver</u>

       Once all preprocessors have run, they deliver pure <u>roff</u> language input to the formatter,  which  in  turn
       generates  a  document  in  a  page  description language that is then interpreted by a postprocessor for
       viewing, printing, or further processing.

       Each program interprets input in  a  language  that  is  independent  of  the  others;  some  are  purely
       descriptive, as with <u><a href="../man1/tbl.1.html">tbl</a></u>(1) and <u>roff</u> output, and some permit the definition of macros, as with <u><a href="../man1/eqn.1.html">eqn</a></u>(1) and
       <u>roff</u>  input.   Most  <u>roff</u> input files employ the macros of a document formatting package, intermixed with
       instructions for one or more preprocessors, and seasoned with escape sequences and requests from the <u>roff</u>
       language.  Some documents are simpler still, since their formatting packages  discourage  direct  use  of
       <u>roff</u>  requests;  man pages are a prominent example.  Many features of the <u>roff</u> language are seldom needed
       by users; only authors of macro packages require a substantial command of them.

   <b>Preprocessors</b>
       A <u>roff</u> preprocessor is a program that, directly or ultimately, generates output  in  the  <u>roff</u>  language.
       Typically,  each  preprocessor defines a language of its own that transforms its input into that for <u>roff</u>
       or another preprocessor.  As an example of the latter,  <u>chem</u>  produces  <u>pic</u>  input.   Preprocessors  must
       consequently  be  run  in an appropriate order; <u><a href="../man1/groff.1.html">groff</a></u>(1) handles this automatically for all preprocessors
       supplied by the GNU <u>roff</u> system.

       Portions of the document written in preprocessor languages are usually bracketed by tokens that look like
       <u>roff</u> macro calls.  <u>roff</u> preprocessor programs transform only the regions of  the  document  intended  for
       them.   When  a  preprocessor  language  is used by a document, its corresponding program must process it
       before the input is seen by the formatter, or incorrect rendering is almost guaranteed.

       GNU <u>roff</u> provides several preprocessors, including <u>eqn</u>, <u>grn</u>, <u>pic</u>, <u>tbl</u>, <u>refer</u>, and <u>soelim</u>.   See  <u><a href="../man1/groff.1.html">groff</a></u>(1)
       for a complete list.  Other preprocessors for <u>roff</u> systems are known.

              <u>dformat</u>   depicts data structures;
              <u>grap</u>      constructs statistical charts; and
              <u>ideal</u>     draws diagrams using a constraint-based language.

   <b>Formatter</b> <b>programs</b>
       A  <u>roff</u>  formatter  transforms  <u>roff</u>  language  input  into a single file in a page description language,
       described in <u><a href="../man5/groff_out.5.html">groff_out</a></u>(5), intended for processing by a selected device.  This page description  language
       is  specialized  in  its  parameters,  but not its syntax, for the selected device; the format is device-
       <u>independent</u>, but not device-<u>agnostic</u>.  The parameters the formatter uses  to  arrange  the  document  are
       stored in <u>device</u> and <u>font</u> <u>description</u> <u>files</u>; see <u><a href="../man5/groff_font.5.html">groff_font</a></u>(5).

       AT&amp;T  Unix  had  two formatters—<u>nroff</u> for terminals, and <u>troff</u> for typesetters.  Often, the name <u>troff</u> is
       used loosely to refer to both.  When generalizing thus, <u>groff</u> documentation prefers the term “<u>roff</u>”.   In
       GNU <u>roff</u>, the formatter program is always <u><a href="../man1/troff.1.html">troff</a></u>(1).

   <b>Devices</b> <b>and</b> <b>output</b> <b>drivers</b>
       To  a  <u>roff</u>  system,  a <u>device</u> is a hardware interface like a printer, a text or graphical terminal, or a
       standardized file format that unrelated software can interpret.  An  <u>output</u>  <u>driver</u>  is  a  program  that
       parses  the  output of <u>troff</u> and produces instructions specific to the device or file format it supports.
       An output driver might support multiple devices, particularly if they are similar.

       The names of the devices and their driver programs are not standardized.  Technological fashions  evolve;
       the  devices  used  for document preparation when AT&amp;T <u>troff</u> was first written in the 1970s are no longer
       used in production environments.  Device capabilities have tended to increase, improving  resolution  and
       font  repertoire,  and adding color output and hyperlinking.  Further, to reduce file size and processing
       time, AT&amp;T <u>troff</u>'s page description language placed low limits on the magnitudes of  some  quantities  it
       could represent.  Its PostScript output driver, <u><a href="../man1/dpost.1.html">dpost</a></u>(1), had a resolution of 720 units per inch; <u>groff</u>'s
       <u><a href="../man1/grops.1.html">grops</a></u>(1) uses 72,000.

<u><b>roff</b></u> <b>programming</b>
       Documents  using <u>roff</u> are normal text files interleaved with <u>roff</u> formatting elements.  The <u>roff</u> language
       is powerful enough to support arbitrary computation and it supplies facilities that encourage  extension.
       The primary such facility is macro definition; with this feature, macro packages have been developed that
       are tailored for particular applications.

   <b>Macro</b> <b>packages</b>
       Macro  packages  can  have  a  much  smaller  vocabulary than <u>roff</u> itself; this trait combined with their
       domain-specific nature can make them easy to acquire and master.  The macro definitions of a package  are
       typically  kept  in  a  file  called <u>name</u><b>.tmac</b> (historically, <b>tmac.</b><u>name</u>).  Find details on the naming and
       placement of macro packages in <u><a href="../man5/groff_tmac.5.html">groff_tmac</a></u>(5).

       A macro package anticipated for use in a document can be declared to the formatter  by  the  command-line
       option  <b>-m</b>;  see  <u><a href="../man1/troff.1.html">troff</a></u>(1).  It can alternatively be specified within a document using the <b>mso</b> request of
       the <u>groff</u> language; see <u><a href="../man7/groff.7.html">groff</a></u>(7).

       Well-known macro packages include <u>man</u> for traditional man pages and  <u>mdoc</u>  for  BSD-style  manual  pages.
       Macro  packages  for  typesetting  books, articles, and letters include <u>ms</u> (from “manuscript macros”), <u>me</u>
       (named by a system administrator from the first name of its creator, Eric Allman), <u>mm</u>  (from  “memorandum
       macros”),  and  <u>mom</u>,  a  punningly named package exercising many <u>groff</u> extensions.  See <u><a href="../man5/groff_tmac.5.html">groff_tmac</a></u>(5) for
       more.

   <b>The</b> <u><b>roff</b></u> <b>formatting</b> <b>language</b>
       The <u>roff</u> language provides requests, escape sequences, macro  definition  facilities,  string  variables,
       registers  for storage of numbers or dimensions, and control of execution flow.  The theoretically minded
       will observe that a <u>roff</u> is not a mere markup language, but Turing-complete.  It has storage (registers),
       it can perform tests (as in conditional expressions like “<b>(\n[i]</b> <b>&gt;=</b> <b>1)</b>”), its “<b>if</b>” and  related  requests
       alter the flow of control, and macro definition permits unbounded recursion.

       <u>Requests</u> and <u>escape</u> <u>sequences</u> are instructions, predefined parts of the language, that perform formatting
       operations,  interpolate  stored  material,  or  otherwise  change the state of the parser.  The user can
       define their own request-like elements by composing together text,  requests,  and  escape  sequences  <u>ad</u>
       <u>libitum.</u>   A document writer will not (usually) note any difference in usage for requests or macros; both
       are found on control lines.  However, there is a distinction; requests take  either  a  fixed  number  of
       arguments  (sometimes zero), silently ignoring any excess, or consume the rest of the input line, whereas
       macros can take a variable number of arguments.  Since arguments are separated by spaces, macros  require
       a  means  of  embedding  a  space  in  an  argument;  in other words, of quoting it.  This then demands a
       mechanism of embedding the quoting character itself, in case <u>it</u> is needed literally in a macro  argument.
       AT&amp;T  <u>troff</u>  had complex rules involving the placement and repetition of the double quote to achieve both
       aims.  <u>groff</u> cuts this knot by supporting a special character escape  sequence  for  the  neutral  double
       quote, “<b>\[dq]</b>”, which never performs quoting in the typesetting language, but is simply a glyph, ‘<b>"</b>’.

       <u>Escape</u> <u>sequences</u> start with a backslash, “<b>\</b>”.  They can appear almost anywhere, even in the midst of text
       on  a  line, and implement various features, including the insertion of special characters with “<b>\(</b><u><b>xx</b></u>” or
       “<b>\[</b><u><b>xxx</b></u><b>]</b>”, break suppression at input line endings with “<b>\c</b>”, font changes with “<b>\f</b>”,  type  size  changes
       with “<b>\s</b>”, in-line comments with “<b>\"</b>”, and many others.

       <u>Strings</u>  store  text.   They  are  populated  with  the  <b>ds</b>  request and interpolated using the <b>\*</b> escape
       sequence.

       <u>Registers</u> store numbers and measurements.  A register can be set with the request <b>nr</b> and its value can be
       retrieved by the escape sequence <b>\n</b>.

</pre><h4><b>File</b> <b>naming</b> <b>conventions</b></h4><pre>
       The structure or content of a file name, beyond its location in the file system, is  not  significant  to
       <u>roff</u>  tools.  <u>roff</u> documents employing “full-service” macro packages (see <u><a href="../man5/groff_tmac.5.html">groff_tmac</a></u>(5)) tend to be named
       with a suffix identifying the package; we thus see file names ending in <u>.man</u>, <u>.ms</u>, <u>.me</u>,  <u>.mm</u>,  and  <u>.mom</u>,
       for instance.  When installed, man pages tend to be named with the manual's section number as the suffix.
       For  example,  the  file  name  for  this  document is <u>roff.7</u>.  Practice for “raw” <u>roff</u> documents is less
       consistent; they are sometimes seen with a <u>.t</u> suffix.

</pre><h4><b>Input</b> <b>conventions</b></h4><pre>
       Since <u>troff</u> fills text automatically, it is  common  practice  in  the  <u>roff</u>  language  to  avoid  visual
       composition  of  text  in  input  files:  the  esthetic  appeal  of the formatted output is what matters.
       Therefore, <u>roff</u> input should be arranged such that it is easy for authors and maintainers to compose  and
       develop  the  document,  understand  the syntax of <u>roff</u> requests, macro calls, and preprocessor languages
       used, and predict the behavior of the formatter.  Several traditions have accrued  in  service  of  these
       goals.

       • Follow  sentence  endings  in  the  input  with  newlines  to ease their recognition.  It is frequently
         convenient to end text  lines  after  colons  and  semicolons  as  well,  as  these  typically  precede
         independent  clauses.   Consider  doing  so after commas; they often occur in lists that become easy to
         scan when itemized by line, or constitute supplements to the  sentence  that  are  added,  deleted,  or
         updated to clarify it.  Parenthetical and quoted phrases are also good candidates for placement on text
         lines by themselves.

       • Set  your  text editor's line length to 72 characters or fewer; see the subsections below.  This limit,
         combined with the previous item of advice, makes it less common that an input line will  wrap  in  your
         text  editor, and thus will help you perceive excessively long constructions in your text.  Recall that
         natural languages originate in speech, not writing, and that punctuation is correlated with pauses  for
         breathing and changes in prosody.

       • Use  <b>\&amp;</b> after “<b>!</b>”, “<b>?</b>”, and “<b>.</b>” if they are followed by space, tab, or newline characters and don't end
         a sentence.

       • In filled text lines, use <b>\&amp;</b> before “<b>.</b>” and “<b>'</b>” if they are preceded by space, so  that  reflowing  the
         input doesn't turn them into control lines.

       • Do not use spaces to perform indentation or align columns of a table.  Leading spaces are reliable when
         text is not being filled.

       • Comment  your  document.  It is never too soon to apply comments to record information of use to future
         document maintainers (including your future self).  The <b>\"</b> escape sequence causes <u>troff</u> to  ignore  the
         remainder of the input line.

       • Use  the  empty  request—a  control  character  followed  immediately  by  a newline—to visually manage
         separation of material in input files.  Many of the <u>groff</u> project's own documents use an empty  request
         between  sentences,  after  macro  definitions,  and  where a break is expected, and two empty requests
         between paragraphs or other requests or macro  calls  that  will  introduce  vertical  space  into  the
         document.   You  can  combine  the empty request with the comment escape sequence to include whole-line
         comments in your document, and even “comment out” sections of it.

       An example sufficiently long to illustrate most of the above suggestions in practice follows.  An arrow →
       indicates a tab character.

              .\"   nroff this_file.roff | less
              .\"   groff -T ps this_file.roff &gt; this_file.ps
              →The theory of relativity is intimately connected with
              the theory of space and time.
              .
              I shall therefore begin with a brief investigation of
              the origin of our ideas of space and time,
              although in doing so I know that I introduce a
              controversial subject.  \" remainder of paragraph elided
              .
              .

              →The experiences of an individual appear to us arranged
              in a series of events;
              in this series the single events which we remember
              appear to be ordered according to the criterion of
              \[lq]earlier\[rq] and \[lq]later\[rq], \" punct swapped
              which cannot be analysed further.
              .
              There exists,
              therefore,
              for the individual,
              an I-time,
              or subjective time.
              .
              This itself is not measurable.
              .
              I can,
              indeed,
              associate numbers with the events,
              in such a way that the greater number is associated with
              the later event than with an earlier one;
              but the nature of this association may be quite
              arbitrary.
              .
              This association I can define by means of a clock by
              comparing the order of events furnished by the clock
              with the order of a given series of events.
              .
              We understand by a clock something which provides a
              series of events which can be counted,
              and which has other properties of which we shall speak
              later.
              .\" Albert Einstein, _The Meaning of Relativity_, 1922

   <b>Editing</b> <b>with</b> <b>Emacs</b>
       Official GNU doctrine holds that the best program for editing a <u>roff</u> document is Emacs; see <u><a href="../man1/emacs.1.html">emacs</a></u>(1).  It
       provides an <u>nroff</u> major mode that is suitable for all kinds of <u>roff</u> dialects.  This mode can be activated
       by the following methods.

       When editing a file within Emacs the mode can be changed by typing “<u>M-x</u> <b>nroff-mode</b>”, where <u>M-x</u>  means  to
       hold down the meta key (often labelled “Alt”) while pressing and releasing the “x” key.

       It is also possible to have the mode automatically selected when a <u>roff</u> file is loaded into the editor.

       • The  most  general  method  is  to  include  file-local  variables  at the end of the file; we can also
         configure the fill column this way.

                .\" Local Variables:
                .\" fill-column: 72
                .\" mode: nroff
                .\" End:

       • Certain file name extensions, such  as  those  commonly  used  by  man  pages,  trigger  the  automatic
         activation of the <u>nroff</u> mode.

       • Technically, having the sequence

                .\" -*- nroff -*-

         in  the  first line of a file will cause Emacs to enter the <u>nroff</u> major mode when it is loaded into the
         buffer.  Unfortunately, some implementations of the <u><a href="../man1/man.1.html">man</a></u>(1) program are confused by this practice, so we
         discourage it.

   <b>Editing</b> <b>with</b> <b>Vim</b>
       Other editors provide support for <u>roff</u>-style files too,  such  as  <u><a href="../man1/vim.1.html">vim</a></u>(1),  an  extension  of  the  <u><a href="../man1/vi.1.html">vi</a></u>(1)
       program.   Vim's highlighting can be made to recognize <u>roff</u> files by setting the <b>filetype</b> option in a Vim
       <u>modeline</u>.  For this feature to work, your copy of <u>vim</u> must be built with support for, and  configured  to
       enable,  several  features;  consult  the  editor's  online  help  topics “auto-setting”, “filetype”, and
       “syntax”.  Then put the following at the end of your <u>roff</u> files, after any Emacs configuration:

                     .\" vim: set filetype=groff textwidth=72:

       Replace “groff” in the above with “nroff” if you want highlighting that does <u>not</u> recognize  many  of  the
       GNU extensions to <u>roff</u>, such as request, register, and string names longer than two characters.

</pre><h4><b>Authors</b></h4><pre>
       This document was written by Bernd Warken and G. Branden Robinson.

</pre><h4><b>See</b> <b>also</b></h4><pre>
       Much  <u>roff</u>  documentation is available.  The Bell Labs papers describing AT&amp;T <u>troff</u> remain available, and
       <u>groff</u> is documented comprehensively.

   <b>Internet</b> <b>sites</b>
       <u>Unix</u> <u>Text</u> <u>Processing</u>, by Dale Dougherty and Tim O'Reilly, 1987, Hayden Books.   This  well-regarded  text
       brings  the  reader  from a state of no knowledge of Unix or text editing (if necessary) to sophisticated
       computer-aided typesetting.  It has been placed under a free software license by its authors and  updated
       by a team of <u>groff</u> contributors and enthusiasts.

       “History of Unix Manpages”,  an  online article maintained by the mdocml project, provides an overview of
       <u>roff</u> development from Saltzer's <u>RUNOFF</u> to 2008, with links to original documentation and recollections of
       the authors and their contemporaries.

       troff.org, Ralph Corderoy's <u>troff</u> site, provides  an  overview  and  pointers  to  much  historical  <u>roff</u>
       information.

       Multicians,  a  site  by  Multics enthusiasts, contains a lot of information on the MIT projects CTSS and
       Multics, including <u>RUNOFF</u>; it is especially useful for its glossary and  the  many  links  to  historical
       documents.

       The Unix Archive,  curated  by  the  Unix Heritage Society, provides the source code and some binaries of
       historical Unices (including the source code of some versions of <u>troff</u> and its documentation) contributed
       by their copyright holders.

       Jerry Saltzer's home page stores some documents using the original <u>RUNOFF</u> formatting language.

       <u>groff</u>, GNU <u>roff</u>'s web site, provides convenient access to <u>groff</u>'s source code  repository,  bug  tracker,
       and mailing lists (including archives and the subscription interface).

   <b>Historical</b> <u><b>roff</b></u> <b>documentation</b>
       Many  AT&amp;T <u>troff</u> documents are available online, and can be found at Ralph Corderoy's site (see above) or
       via Internet search.

       Of foremost significance are two mentioned in section “History” above, describing the  language  and  its
       device-independent implementation, respectively.

       “Troff  User's  Manual”  by  Joseph  F.  Ossanna,  1976  (revised by Brian W. Kernighan, 1992), AT&amp;T Bell
       Laboratories Computing Science Technical Report No. 54.

       “A Typesetter-independent TROFF” by Brian W. Kernighan, 1982, AT&amp;T Bell  Laboratories  Computing  Science
       Technical Report No. 97.

       You  can  obtain  many  relevant  Bell  Labs  papers  in  PDF from Bernd Warken's “roff classical” GitHub
       repository.

   <b>Manual</b> <b>pages</b>
       As a system of multiple components, a <u>roff</u> system potentially has many  man  pages,  each  describing  an
       aspect  of  it.   Unfortunately, there is no consistent naming scheme for these pages among the different
       <u>roff</u> implementations.

       For GNU <u>roff</u>, the <u><a href="../man1/groff.1.html">groff</a></u>(1) man page enumerates all man pages distributed with the system, and  individual
       pages  frequently  refer  to external resources as well as manuals distributed with <u>groff</u> on a variety of
       topics.

       With other <u>roff</u>s, you are on your own, but <u><a href="../man1/troff.1.html">troff</a></u>(1) might be a good starting point.

groff 1.23.0                                       3 June 2025                                           <u><a href="../man7/roff.7.html">roff</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>