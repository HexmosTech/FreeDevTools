<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>packet - packet interface on device level</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       packet - packet interface on device level

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/linux/if_packet.h">linux/if_packet.h</a>&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/net/ethernet.h">net/ethernet.h</a>&gt;</b> <b>/*</b> <b>the</b> <b>L2</b> <b>protocols</b> <b>*/</b>

       <b>packet_socket</b> <b>=</b> <b>socket(AF_PACKET,</b> <b>int</b> <u>socket_type</u><b>,</b> <b>int</b> <u>protocol</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Packet  sockets  are  used to receive or send raw packets at the device driver (OSI Layer 2) level.  They
       allow the user to implement protocol modules in user space on top of the physical layer.

       The <u>socket_type</u> is either <b>SOCK_RAW</b> for raw packets including the  link-level  header  or  <b>SOCK_DGRAM</b>  for
       cooked  packets  with the link-level header removed.  The link-level header information is available in a
       common format in a <u>sockaddr_ll</u> structure.  <u>protocol</u> is the IEEE 802.3 protocol  number  in  network  byte
       order.  See the <u>&lt;linux/if_ether.h&gt;</u> include file for a list of allowed protocols.  When protocol is set to
       <b>htons(ETH_P_ALL)</b>,  then  all  protocols are received.  All incoming packets of that protocol type will be
       passed to the packet socket before they are passed to  the  protocols  implemented  in  the  kernel.   If
       <u>protocol</u>  is  set  to  zero,  no  packets  are received.  <b><a href="../man2/bind.2.html">bind</a></b>(2) can optionally be called with a nonzero
       <u>sll_protocol</u> to start receiving packets for the protocols specified.

       In order to create a packet socket, a process must have the <b>CAP_NET_RAW</b> capability in the user  namespace
       that governs its network namespace.

       <b>SOCK_RAW</b>  packets  are passed to and from the device driver without any changes in the packet data.  When
       receiving a packet, the address is still parsed and passed in a standard <u>sockaddr_ll</u>  address  structure.
       When  transmitting  a  packet,  the  user-supplied buffer should contain the physical-layer header.  That
       packet is then queued unmodified to the network driver  of  the  interface  defined  by  the  destination
       address.   Some  device drivers always add other headers.  <b>SOCK_RAW</b> is similar to but not compatible with
       the obsolete <b>AF_INET/SOCK_PACKET</b> of Linux 2.0.

       <b>SOCK_DGRAM</b> operates on a slightly higher level.  The physical header is  removed  before  the  packet  is
       passed to the user.  Packets sent through a <b>SOCK_DGRAM</b> packet socket get a suitable physical-layer header
       based on the information in the <u>sockaddr_ll</u> destination address before they are queued.

       By  default,  all  packets  of the specified protocol type are passed to a packet socket.  To get packets
       only from a specific interface use <b><a href="../man2/bind.2.html">bind</a></b>(2) specifying an address in a  <u>struct</u>  <u>sockaddr_ll</u>  to  bind  the
       packet  socket  to  an  interface.   Fields  used  for  binding  are  <u>sll_family</u>  (should  be <b>AF_PACKET</b>),
       <u>sll_protocol</u>, and <u>sll_ifindex</u>.

       The <b><a href="../man2/connect.2.html">connect</a></b>(2) operation is not supported on packet sockets.

       When the <b>MSG_TRUNC</b> flag is passed to <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2), <b><a href="../man2/recv.2.html">recv</a></b>(2), or <b><a href="../man2/recvfrom.2.html">recvfrom</a></b>(2), the real length of  the  packet
       on the wire is always returned, even when it is longer than the buffer.

   <b>Address</b> <b>types</b>
       The <u>sockaddr_ll</u> structure is a device-independent physical-layer address.

           struct sockaddr_ll {
               unsigned short sll_family;   /* Always AF_PACKET */
               unsigned short sll_protocol; /* Physical-layer protocol */
               int            sll_ifindex;  /* Interface number */
               unsigned short sll_hatype;   /* ARP hardware type */
               unsigned char  sll_pkttype;  /* Packet type */
               unsigned char  sll_halen;    /* Length of address */
               unsigned char  sll_addr[8];  /* Physical-layer address */
           };

       The fields of this structure are as follows:

       <u>sll_protocol</u>
              is  the standard ethernet protocol type in network byte order as defined in the <u>&lt;linux/if_ether.h&gt;</u>
              include file.  It defaults to the socket's protocol.

       <u>sll_ifindex</u>
              is the interface index of  the  interface  (see  <b><a href="../man7/netdevice.7.html">netdevice</a></b>(7));  0  matches  any  interface  (only
              permitted  for  binding).   <u>sll_hatype</u>  is  an ARP type as defined in the <u>&lt;linux/if_arp.h&gt;</u> include
              file.

       <u>sll_pkttype</u>
              contains the packet type.  Valid types are <b>PACKET_HOST</b> for a packet addressed to the  local  host,
              <b>PACKET_BROADCAST</b>  for  a  physical-layer broadcast packet, <b>PACKET_MULTICAST</b> for a packet sent to a
              physical-layer multicast address, <b>PACKET_OTHERHOST</b> for a packet to some other host that  has  been
              caught  by  a device driver in promiscuous mode, and <b>PACKET_OUTGOING</b> for a packet originating from
              the local host that is looped back to a packet socket.  These types make sense only for receiving.

       <u>sll_addr</u>
       <u>sll_halen</u>
              contain the physical-layer (e.g., IEEE 802.3) address and its length.   The  exact  interpretation
              depends on the device.

       When  you  send  packets,  it  is  enough  to  specify  <u>sll_family</u>, <u>sll_addr</u>, <u>sll_halen</u>, <u>sll_ifindex</u>, and
       <u>sll_protocol</u>.  The other fields should be 0.  <u>sll_hatype</u> and <u>sll_pkttype</u> are set on received packets  for
       your information.

   <b>Socket</b> <b>options</b>
       Packet socket options are configured by calling <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2) with level <b>SOL_PACKET</b>.

       <b>PACKET_ADD_MEMBERSHIP</b>
       <b>PACKET_DROP_MEMBERSHIP</b>
              Packet  sockets  can  be  used  to  configure  physical-layer  multicasting  and promiscuous mode.
              <b>PACKET_ADD_MEMBERSHIP</b> adds a binding and <b>PACKET_DROP_MEMBERSHIP</b> drops  it.   They  both  expect  a
              <u>packet_mreq</u> structure as argument:

                  struct packet_mreq {
                      int            mr_ifindex;    /* interface index */
                      unsigned short mr_type;       /* action */
                      unsigned short mr_alen;       /* address length */
                      unsigned char  mr_address[8]; /* physical-layer address */
                  };

              <u>mr_ifindex</u>  contains  the  interface  index for the interface whose status should be changed.  The
              <u>mr_type</u> field specifies which action to perform.  <b>PACKET_MR_PROMISC</b> enables receiving all  packets
              on  a  shared  medium (often known as "promiscuous mode"), <b>PACKET_MR_MULTICAST</b> binds the socket to
              the physical-layer multicast group specified in <u>mr_address</u>  and  <u>mr_alen</u>,  and  <b>PACKET_MR_ALLMULTI</b>
              sets the socket up to receive all multicast packets arriving at the interface.

              In  addition,  the traditional ioctls <b>SIOCSIFFLAGS</b>, <b>SIOCADDMULTI</b>, <b>SIOCDELMULTI</b> can be used for the
              same purpose.

       <b>PACKET_AUXDATA</b> (since Linux 2.6.21)
              If this binary option is enabled, the packet socket passes a metadata structure  along  with  each
              packet in the <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2) control field.  The structure can be read with <b><a href="../man3/cmsg.3.html">cmsg</a></b>(3).  It is defined as

                  struct tpacket_auxdata {
                      __u32 tp_status;
                      __u32 tp_len;      /* packet length */
                      __u32 tp_snaplen;  /* captured length */
                      __u16 tp_mac;
                      __u16 tp_net;
                      __u16 tp_vlan_tci;
                      __u16 tp_vlan_tpid; /* Since Linux 3.14; earlier, these
                                             were unused padding bytes */
                  };

       <b>PACKET_FANOUT</b> (since Linux 3.1)
              To  scale  processing  across threads, packet sockets can form a fanout group.  In this mode, each
              matching packet is enqueued onto only one socket in the group.  A socket joins a fanout  group  by
              calling  <b><a href="../man2/setsockopt.2.html">setsockopt</a></b>(2) with level <b>SOL_PACKET</b> and option <b>PACKET_FANOUT</b>.  Each network namespace can
              have up to 65536 independent groups.  A socket selects a group by encoding the ID in the first  16
              bits  of the integer option value.  The first packet socket to join a group implicitly creates it.
              To successfully join an existing group, subsequent packet sockets must  have  the  same  protocol,
              device settings, fanout mode, and flags (see below).  Packet sockets can leave a fanout group only
              by closing the socket.  The group is deleted when the last socket is closed.

              Fanout supports multiple algorithms to spread traffic between sockets, as follows:

              •  The  default  mode,  <b>PACKET_FANOUT_HASH</b>, sends packets from the same flow to the same socket to
                 maintain per-flow ordering.  For each packet, it chooses a socket by  taking  the  packet  flow
                 hash  modulo the number of sockets in the group, where a flow hash is a hash over network-layer
                 address and optional transport-layer port fields.

              •  The load-balance mode <b>PACKET_FANOUT_LB</b> implements a round-robin algorithm.

              •  <b>PACKET_FANOUT_CPU</b> selects the socket based on the CPU that the packet arrived on.

              •  <b>PACKET_FANOUT_ROLLOVER</b> processes all data on a single socket,  moving  to  the  next  when  one
                 becomes backlogged.

              •  <b>PACKET_FANOUT_RND</b> selects the socket using a pseudo-random number generator.

              •  <b>PACKET_FANOUT_QM</b>   (available   since  Linux  3.14)  selects  the  socket  using  the  recorded
                 queue_mapping of the received skb.

              Fanout modes can take additional options.  IP fragmentation causes packets from the same  flow  to
              have  different  flow  hashes.   The  flag <b>PACKET_FANOUT_FLAG_DEFRAG</b>, if set, causes packets to be
              defragmented before fanout is applied, to preserve order even  in  this  case.   Fanout  mode  and
              options  are  communicated  in  the  second  16  bits  of  the  integer  option  value.   The flag
              <b>PACKET_FANOUT_FLAG_ROLLOVER</b> enables the roll over mechanism as a backup strategy: if the  original
              fanout algorithm selects a backlogged socket, the packet rolls over to the next available one.

       <b>PACKET_LOSS</b> (with <b>PACKET_TX_RING</b>)
              When  a  malformed packet is encountered on a transmit ring, the default is to reset its <u>tp_status</u>
              to <b>TP_STATUS_WRONG_FORMAT</b> and abort the transmission immediately.   The  malformed  packet  blocks
              itself  and  subsequently  enqueued  packets from being sent.  The format error must be fixed, the
              associated <u>tp_status</u> reset to <b>TP_STATUS_SEND_REQUEST</b>, and the transmission process  restarted  via
              <b><a href="../man2/send.2.html">send</a></b>(2).   However,  if  <b>PACKET_LOSS</b>  is  set, any malformed packet will be skipped, its <u>tp_status</u>
              reset to <b>TP_STATUS_AVAILABLE</b>, and the transmission process continued.

       <b>PACKET_RESERVE</b> (with <b>PACKET_RX_RING</b>)
              By default, a packet receive ring writes packets immediately following the metadata structure  and
              alignment padding.  This integer option reserves additional headroom.

       <b>PACKET_RX_RING</b>
              Create  a memory-mapped ring buffer for asynchronous packet reception.  The packet socket reserves
              a contiguous region of application address space, lays it out into an array of  packet  slots  and
              copies  packets  (up  to <u>tp_snaplen</u>) into subsequent slots.  Each packet is preceded by a metadata
              structure similar to <u>tpacket_auxdata</u>.  The protocol fields encode the offset to the data from  the
              start  of  the  metadata  header.   <u>tp_net</u>  stores the offset to the network layer.  If the packet
              socket is of type <b>SOCK_DGRAM</b>, then <u>tp_mac</u> is the same.  If it is of type <b>SOCK_RAW</b>, then that field
              stores the offset to the link-layer frame.  Packet socket and application communicate the head and
              tail of the ring through the <u>tp_status</u> field.  The packet socket owns  all  slots  with  <u>tp_status</u>
              equal  to  <b>TP_STATUS_KERNEL</b>.   After filling a slot, it changes the status of the slot to transfer
              ownership to the application.  During normal operation, the new <u>tp_status</u> value has at  least  the
              <b>TP_STATUS_USER</b> bit set to signal that a received packet has been stored.  When the application has
              finished  processing  a  packet,  it transfers ownership of the slot back to the socket by setting
              <u>tp_status</u> equal to <b>TP_STATUS_KERNEL</b>.

              Packet sockets implement multiple variants of the packet ring.   The  implementation  details  are
              described in <u>Documentation/networking/packet_mmap.rst</u> in the Linux kernel source tree.

       <b>PACKET_STATISTICS</b>
              Retrieve packet socket statistics in the form of a structure

                  struct tpacket_stats {
                      unsigned int tp_packets;  /* Total packet count */
                      unsigned int tp_drops;    /* Dropped packet count */
                  };

              Receiving  statistics resets the internal counters.  The statistics structure differs when using a
              ring of variant <b>TPACKET_V3</b>.

       <b>PACKET_TIMESTAMP</b> (with <b>PACKET_RX_RING</b>; since Linux 2.6.36)
              The packet receive ring always stores a timestamp in the metadata header.  By default, this  is  a
              software  generated  timestamp  generated  when  the packet is copied into the ring.  This integer
              option selects the type of timestamp.  Besides the default, it support the  two  hardware  formats
              described in <u>Documentation/networking/timestamping.rst</u> in the Linux kernel source tree.

       <b>PACKET_TX_RING</b> (since Linux 2.6.31)
              Create  a  memory-mapped  ring  buffer  for  packet  transmission.   This  option  is  similar  to
              <b>PACKET_RX_RING</b> and takes the same arguments.  The  application  writes  packets  into  slots  with
              <u>tp_status</u>  equal  to <b>TP_STATUS_AVAILABLE</b> and schedules them for transmission by changing <u>tp_status</u>
              to <b>TP_STATUS_SEND_REQUEST</b>.  When packets are  ready  to  be  transmitted,  the  application  calls
              <b><a href="../man2/send.2.html">send</a></b>(2)  or a variant thereof.  The <u>buf</u> and <u>len</u> fields of this call are ignored.  If an address is
              passed using <b><a href="../man2/sendto.2.html">sendto</a></b>(2) or <b><a href="../man2/sendmsg.2.html">sendmsg</a></b>(2), then that  overrides  the  socket  default.   On  successful
              transmission,  the  socket  resets  <u>tp_status</u>  to  <b>TP_STATUS_AVAILABLE</b>.  It immediately aborts the
              transmission on error unless <b>PACKET_LOSS</b> is set.

       <b>PACKET_VERSION</b> (with <b>PACKET_RX_RING</b>; since Linux 2.6.27)
              By default, <b>PACKET_RX_RING</b> creates a packet receive ring of variant <b>TPACKET_V1</b>.  To create another
              variant, configure the desired variant by setting this integer option before creating the ring.

       <b>PACKET_QDISC_BYPASS</b> (since Linux 3.14)
              By default, packets sent through packet sockets pass through the kernel's qdisc (traffic  control)
              layer,  which  is fine for the vast majority of use cases.  For traffic generator appliances using
              packet sockets that intend to brute-force flood the network—for example,  to  test  devices  under
              load  in  a similar fashion to pktgen—this layer can be bypassed by setting this integer option to
              1.  A side effect is that packet buffering in the qdisc layer  is  avoided,  which  will  lead  to
              increased drops when network device transmit queues are busy; therefore, use at your own risk.

   <b>Ioctls</b>
       <b>SIOCGSTAMP</b>  can  be  used  to  receive  the  timestamp of the last received packet.  Argument is a <u>struct</u>
       <u>timeval</u> variable.

       In addition, all standard ioctls defined in <b><a href="../man7/netdevice.7.html">netdevice</a></b>(7) and <b><a href="../man7/socket.7.html">socket</a></b>(7) are valid on packet sockets.

   <b>Error</b> <b>handling</b>
       Packet sockets do no error handling other than errors occurred while passing the  packet  to  the  device
       driver.  They don't have the concept of a pending error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EADDRNOTAVAIL</b>
              Unknown multicast group address passed.

       <b>EFAULT</b> User passed invalid memory address.

       <b>EINVAL</b> Invalid argument.

       <b>EMSGSIZE</b>
              Packet is bigger than interface MTU.

       <b>ENETDOWN</b>
              Interface is not up.

       <b>ENOBUFS</b>
              Not enough memory to allocate the packet.

       <b>ENODEV</b> Unknown device name or interface index specified in interface address.

       <b>ENOENT</b> No packet received.

       <b>ENOTCONN</b>
              No interface address passed.

       <b>ENXIO</b>  Interface address contained an invalid interface index.

       <b>EPERM</b>  User has insufficient privileges to carry out this operation.

       In addition, other errors may be generated by the low-level driver.

</pre><h4><b>VERSIONS</b></h4><pre>
       <b>AF_PACKET</b> is a new feature in Linux 2.2.  Earlier Linux versions supported only <b>SOCK_PACKET</b>.

</pre><h4><b>NOTES</b></h4><pre>
       For portable programs it is suggested to use <b>AF_PACKET</b> via <b><a href="../man3/pcap.3.html">pcap</a></b>(3); although this covers only a subset of
       the <b>AF_PACKET</b> features.

       The  <b>SOCK_DGRAM</b>  packet  sockets  make no attempt to create or parse the IEEE 802.2 LLC header for a IEEE
       802.3 frame.  When <b>ETH_P_802_3</b> is specified as protocol for sending the kernel creates  the  802.3  frame
       and  fills  out the length field; the user has to supply the LLC header to get a fully conforming packet.
       Incoming 802.3 packets are not multiplexed on the DSAP/SSAP protocol fields; instead they are supplied to
       the user as protocol <b>ETH_P_802_2</b> with the LLC header prefixed.  It  is  thus  not  possible  to  bind  to
       <b>ETH_P_802_3</b>; bind to <b>ETH_P_802_2</b> instead and do the protocol multiplex yourself.  The default for sending
       is the standard Ethernet DIX encapsulation with the protocol filled in.

       Packet sockets are not subject to the input or output firewall chains.

   <b>Compatibility</b>
       In Linux 2.0, the only way to get a packet socket was with the call:

           socket(AF_INET, SOCK_PACKET, protocol)

       This  is  still  supported, but deprecated and strongly discouraged.  The main difference between the two
       methods is that <b>SOCK_PACKET</b> uses the old <u>struct</u> <u>sockaddr_pkt</u>  to  specify  an  interface,  which  doesn't
       provide physical-layer independence.

           struct sockaddr_pkt {
               unsigned short spkt_family;
               unsigned char  spkt_device[14];
               unsigned short spkt_protocol;
           };

       <u>spkt_family</u>  contains  the  device  type,  <u>spkt_protocol</u>  is  the  IEEE 802.3 protocol type as defined in
       <u>&lt;sys/if_ether.h&gt;</u> and <u>spkt_device</u> is the device name as a null-terminated string, for example, eth0.

       This structure is obsolete and should not be used in new code.

</pre><h4><b>BUGS</b></h4><pre>
   <b>LLC</b> <b>header</b> <b>handling</b>
       The IEEE 802.2/803.3 LLC handling could be considered as a bug.

   <b>MSG_TRUNC</b> <b>issues</b>
       The <b>MSG_TRUNC</b> <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2) extension is an ugly hack and should be replaced by a control message.  There is
       currently no way to get the original destination address of packets via <b>SOCK_DGRAM</b>.

   <b>spkt_device</b> <b>device</b> <b>name</b> <b>truncation</b>
       The <u>spkt_device</u> field of <u>sockaddr_pkt</u> has a size of 14 bytes, which is less than  the  constant  <b>IFNAMSIZ</b>
       defined  in  <u>&lt;net/if.h&gt;</u>  which  is  16 bytes and describes the system limit for a network interface name.
       This means the names of network devices longer than 14 bytes will be truncated to fit  into  <u>spkt_device</u>.
       All these lengths include the terminating null byte ('\0')).

       Issues  from  this with old code typically show up with very long interface names used by the <b>Predictable</b>
       <b>Network</b> <b>Interface</b> <b>Names</b> feature enabled by default in many modern Linux distributions.

       The preferred solution is to rewrite code to avoid <b>SOCK_PACKET</b>.  Possible user solutions are  to  disable
       <b>Predictable</b> <b>Network</b> <b>Interface</b> <b>Names</b> or to rename the interface to a name of at most 13 bytes, for example
       using the <b><a href="../man8/ip.8.html">ip</a></b>(8) tool.

   <b>Documentation</b> <b>issues</b>
       Socket filters are not documented.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/socket.2.html">socket</a></b>(2), <b><a href="../man3/pcap.3.html">pcap</a></b>(3), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/ip.7.html">ip</a></b>(7), <b><a href="../man7/raw.7.html">raw</a></b>(7), <b><a href="../man7/socket.7.html">socket</a></b>(7), <b><a href="../man8/ip.8.html">ip</a></b>(8),

       RFC 894 for the standard IP Ethernet encapsulation.  RFC 1700 for the IEEE 802.3 IP encapsulation.

       The <u>&lt;linux/if_ether.h&gt;</u> include file for physical-layer protocols.

       The Linux kernel source tree.  <u>Documentation/networking/filter.rst</u> describes how to apply Berkeley Packet
       Filters  to packet sockets.  <u>tools/testing/selftests/net/psock_tpacket.c</u> contains example source code for
       all available versions of <b>PACKET_RX_RING</b> and <b>PACKET_TX_RING</b>.

Linux man-pages 6.9.1                              2024-06-15                                          <u><a href="../man7/packet.7.html">packet</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>