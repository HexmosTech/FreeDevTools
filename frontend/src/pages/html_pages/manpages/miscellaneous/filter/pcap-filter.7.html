<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pcap-filter - packet filter syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcap0.8t64">libpcap0.8t64_1.10.5-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pcap-filter - packet filter syntax

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b><a href="../man3PCAP/pcap_compile.3PCAP.html">pcap_compile</a></b>(3PCAP)  is used to compile a string into a filter program.  The resulting filter program can
       then  be  applied  to  some  stream  of  packets  to  determine  which  packets  will  be   supplied   to
       <b><a href="../man3PCAP/pcap_loop.3PCAP.html">pcap_loop</a></b>(3PCAP), <b><a href="../man3PCAP/pcap_dispatch.3PCAP.html">pcap_dispatch</a></b>(3PCAP), <b><a href="../man3PCAP/pcap_next.3PCAP.html">pcap_next</a></b>(3PCAP), or <b><a href="../man3PCAP/pcap_next_ex.3PCAP.html">pcap_next_ex</a></b>(3PCAP).

       The  <u>filter</u>  <u>expression</u> consists of one or more <u>primitives</u>.  Primitives usually consist of an <u>id</u> (name or
       number) preceded by one or more qualifiers.  There are three different kinds of qualifier:

       <u>type</u>   <u>type</u> qualifiers say what kind of thing the id name or number refers to.  Possible types are  <b>host</b>,
              <b>net</b>,  <b>port</b>  and  <b>portrange</b>.   E.g., `<b>host</b> foo', `<b>net</b> 128.3', `<b>port</b> 20', `<b>portrange</b> 6000-6008'.  If
              there is no type qualifier, <b>host</b> is assumed.

       <u>dir</u>    <u>dir</u> qualifiers specify a particular transfer direction to and/or from <u>id</u>.  Possible directions are
              <b>src</b>, <b>dst</b>, <b>src</b> <b>or</b> <b>dst</b>, <b>src</b> <b>and</b> <b>dst</b>, <b>ra</b>, <b>ta</b>, <b>addr1</b>, <b>addr2</b>, <b>addr3</b>, and <b>addr4</b>.  E.g., `<b>src</b> foo',  `<b>dst</b>
              <b>net</b>  128.3',  `<b>src</b>  <b>or</b> <b>dst</b> <b>port</b> ftp-data'.  If there is no dir qualifier, `<b>src</b> <b>or</b> <b>dst</b>' is assumed.
              The <b>ra</b>, <b>ta</b>, <b>addr1</b>, <b>addr2</b>, <b>addr3</b>, and <b>addr4</b> qualifiers are only valid for IEEE 802.11 Wireless  LAN
              link layers.

       <u>proto</u>  <u>proto</u>  qualifiers  restrict  the  match  to a particular protocol.  Possible protocols are: <b>ether</b>,
              <b>fddi</b>, <b>tr</b>, <b>wlan</b>, <b>ip</b>, <b>ip6</b>, <b>arp</b>, <b>rarp</b>, <b>decnet</b>, <b>sctp</b>, <b>tcp</b> and <b>udp</b>.  E.g., `<b>ether</b> <b>src</b>  foo',  `<b>arp</b>  <b>net</b>
              128.3',  `<b>tcp</b> <b>port</b> 21', `<b>udp</b> <b>portrange</b> 7000-7009', `<b>wlan</b> <b>addr2</b> 0:2:3:4:5:6'.  If there is no <u>proto</u>
              qualifier, all protocols consistent with the type are assumed.  E.g., `<b>src</b> foo' means `<b>(ip6</b> <b>or</b>  <b>ip</b>
              <b>or</b>  <b>arp</b> <b>or</b> <b>rarp)</b> <b>src</b> foo', `<b>net</b> bar' means `<b>(ip</b> <b>or</b> <b>arp</b> <b>or</b> <b>rarp)</b> <b>net</b> bar' and `<b>port</b> 53' means `<b>(tcp</b>
              <b>or</b> <b>udp</b> <b>or</b> <b>sctp)</b> <b>port</b>  53'  (note  that  these  examples  use  invalid  syntax  to  illustrate  the
              principle).

       [<b>fddi</b> is actually an alias for <b>ether</b>; the parser treats them identically as meaning ``the data link level
       used  on  the  specified  network interface''.  FDDI headers contain Ethernet-like source and destination
       addresses, and often contain Ethernet-like packet types, so you can filter on these FDDI fields  just  as
       with  the  analogous  Ethernet  fields.  FDDI headers also contain other fields, but you cannot name them
       explicitly in a filter expression.

       Similarly, <b>tr</b> and <b>wlan</b> are aliases for <b>ether</b>; the previous paragraph's statements about FDDI headers also
       apply to Token Ring and 802.11 wireless LAN headers.  For 802.11 headers, the destination address is  the
       DA field and the source address is the SA field; the BSSID, RA, and TA fields aren't tested.]

       In  addition  to  the  above,  there are some special `primitive' keywords that don't follow the pattern:
       <b>gateway</b>, <b>broadcast</b>, <b>less</b>, <b>greater</b> and arithmetic expressions.  All of these are described below.

       More complex filter expressions are built up by using the words <b>and</b>, <b>or</b> and <b>not</b> (or  equivalently:  `<b>&amp;&amp;</b>',
       `<b>||</b>'  and  `<b>!</b>'  respectively)  to combine primitives.  E.g., `<b>host</b> foo <b>and</b> <b>not</b> <b>port</b> ftp <b>and</b> <b>not</b> <b>port</b> ftp-
       data'.  To save typing, identical qualifier lists can be omitted.  E.g., `<b>tcp</b> <b>dst</b> <b>port</b> ftp <b>or</b> ftp-data <b>or</b>
       domain' is exactly the same as `<b>tcp</b> <b>dst</b> <b>port</b> ftp <b>or</b> <b>tcp</b> <b>dst</b> <b>port</b> ftp-data <b>or</b> <b>tcp</b> <b>dst</b> <b>port</b> domain'.

       Allowable primitives are:

       <b>dst</b> <b>host</b> <u>hostnameaddr</u>
              True if the IPv4/v6 destination field of the packet  is  <u>hostnameaddr</u>,  which  may  be  either  an
              address or a name.

       <b>src</b> <b>host</b> <u>hostnameaddr</u>
              True if the IPv4/v6 source field of the packet is <u>hostnameaddr</u>.

       <b>host</b> <u>hostnameaddr</u>
              True if either the IPv4/v6 source or destination of the packet is <u>hostnameaddr</u>.

              Any of the above host expressions can be prepended with the keywords, <b>ip</b>, <b>arp</b>, <b>rarp</b>, or <b>ip6</b> as in:
                   <b>ip</b> <b>host</b> <u>hostnameaddr</u>
              which is equivalent to:
                   <b>ether</b> <b>proto</b> <b>\</b>ip <b>and</b> <b>host</b> <u>hostnameaddr</u>
              If  <u>hostnameaddr</u>  is  a  name  with multiple IPv4/v6 addresses, each address will be checked for a
              match.

       <b>ether</b> <b>dst</b> <u>ethernameaddr</u>
              True if the Ethernet destination address is <u>ethernameaddr</u>.  <u>ethernameaddr</u> may  be  either  a  name
              from  /etc/ethers or a numerical MAC address of the form "xx:xx:xx:xx:xx:xx", "xx.xx.xx.xx.xx.xx",
              "xx-xx-xx-xx-xx-xx", "xxxx.xxxx.xxxx", "xxxxxxxxxxxx", or various mixes  of  ':',  '.',  and  '-',
              where each "x" is a hex digit (0-9, a-f, or A-F).

       <b>ether</b> <b>src</b> <u>ethernameaddr</u>
              True if the Ethernet source address is <u>ethernameaddr</u>.

       <b>ether</b> <b>host</b> <u>ethernameaddr</u>
              True if either the Ethernet source or destination address is <u>ethernameaddr</u>.

       <b>gateway</b> <u>host</u>
              True  if  the packet used <u>host</u> as a gateway.  I.e., the Ethernet source or destination address was
              <u>host</u> but neither the IP source nor the IP destination was <u>host</u>.  <u>Host</u> must be a name and  must  be
              found  both  by  the machine's host-name-to-IP-address resolution mechanisms (host name file, DNS,
              NIS, etc.) and by the machine's host-name-to-Ethernet-address resolution  mechanism  (/etc/ethers,
              etc.).  (An equivalent expression is
                   <b>ether</b> <b>host</b> <u>ethernameaddr</u> <b>and</b> <b>not</b> <b>host</b> <u>hostnameaddr</u>
              which  can  be  used  with either names or numbers for <u>hostnameaddr</u> <u>/</u> <u>ethernameaddr</u>.)  This syntax
              does not work in IPv6-enabled configuration at this moment.

       <b>dst</b> <b>net</b> <u>netnameaddr</u>
              True if the IPv4/v6 destination address of the packet has a network number  of  <u>netnameaddr</u>.   <u>Net</u>
              may  be  either  a  name from the networks database (<a href="file:/etc/networks">/etc/networks</a>, etc.) or a network number.  An
              IPv4 network number can be written as a dotted quad  (e.g.,  192.168.1.0),  dotted  triple  (e.g.,
              192.168.1), dotted pair (e.g, 172.16), or single number (e.g., 10); the netmask is 255.255.255.255
              for  a dotted quad (which means that it's really a host match), 255.255.255.0 for a dotted triple,
              255.255.0.0 for a dotted pair, or 255.0.0.0 for a single number.  An IPv6 network number  must  be
              written  out  fully;  the  netmask  is  ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff, so IPv6 "network"
              matches are really always host matches, and a network match requires a netmask length.

       <b>src</b> <b>net</b> <u>netnameaddr</u>
              True if the IPv4/v6 source address of the packet has a network number of <u>netnameaddr</u>.

       <b>net</b> <u>netnameaddr</u>
              True if either the IPv4/v6 source or destination address of the packet has  a  network  number  of
              <u>netnameaddr</u>.

       <b>net</b> <u>netaddr</u> <b>mask</b> <u>netmask</u>
              True  if the IPv4 address matches <u>netaddr</u> with the specific <u>netmask</u>.  May be qualified with <b>src</b> or
              <b>dst</b>.  Note that this syntax is not valid for IPv6 <u>netaddr</u>.

       <b>net</b> <u>netaddr</u>/<u>len</u>
              True if the IPv4/v6 address matches <u>netaddr</u> with a netmask <u>len</u> bits wide.  May be  qualified  with
              <b>src</b> or <b>dst</b>.

       <b>dst</b> <b>port</b> <u>portnamenum</u>
              True  if  the  packet is IPv4/v6 TCP, UDP or SCTP and has a destination port value of <u>portnamenum</u>.
              The <u>portnamenum</u> can be a number or a name used in <a href="file:/etc/services">/etc/services</a> (see <b><a href="../man4P/tcp.4P.html">tcp</a></b>(4P) and <b><a href="../man4P/udp.4P.html">udp</a></b>(4P)).   If  a
              name  is  used,  both  the port number and protocol are checked.  If a number or ambiguous name is
              used, only the port number is checked (e.g., `<b>dst</b> <b>port</b> 513' will print both tcp/login traffic  and
              udp/who traffic, and `<b>port</b> domain' will print both tcp/domain and udp/domain traffic).

       <b>src</b> <b>port</b> <u>portnamenum</u>
              True if the packet has a source port value of <u>portnamenum</u>.

       <b>port</b> <u>portnamenum</u>
              True if either the source or destination port of the packet is <u>portnamenum</u>.

       <b>dst</b> <b>portrange</b> <u>portnamenum1-portnamenum2</u>
              True  if  the  packet  is  IPv4/v6  TCP,  UDP  or  SCTP  and  has a destination port value between
              <u>portnamenum1</u> and <u>portnamenum2</u> (both inclusive).  <u>portnamenum1</u> and <u>portnamenum2</u> are interpreted  in
              the same fashion as the <u>portnamenum</u> parameter for <b>port</b>.

       <b>src</b> <b>portrange</b> <u>portnamenum1-portnamenum2</u>
              True if the packet has a source port value between <u>portnamenum1</u> and <u>portnamenum2</u> (both inclusive).

       <b>portrange</b> <u>portnamenum1-portnamenum2</u>
              True  if  either  the  source  or  destination  port  of  the  packet  is between <u>portnamenum1</u> and
              <u>portnamenum2</u> (both inclusive).

              Any of the above port or port range expressions can be prepended with the keywords,  <b>tcp</b>,  <b>udp</b>  or
              <b>sctp</b>, as in:
                   <b>tcp</b> <b>src</b> <b>port</b> <u>portnamenum</u>
              which matches only TCP packets whose source port is <u>portnamenum</u>.

       <b>less</b> <u>length</u>
              True if the packet has a length less than or equal to <u>length</u>.  This is equivalent to:
                   <b>len</b> <b>&lt;=</b> <u>length</u>

       <b>greater</b> <u>length</u>
              True if the packet has a length greater than or equal to <u>length</u>.  This is equivalent to:
                   <b>len</b> <b>&gt;=</b> <u>length</u>

       <b>ip</b> <b>proto</b> <u>protocol</u>
              True  if  the  packet is an IPv4 packet (see <b><a href="../man4P/ip.4P.html">ip</a></b>(4P)) of protocol type <u>protocol</u>.  <u>Protocol</u> can be a
              number or one of the names recognized by <b><a href="../man3/getprotobyname.3.html">getprotobyname</a></b>(3) (as  in  e.g.  `<b><a href="../man1/getent.1.html">getent</a></b>(1)  protocols'),
              typically  from  an  entry in <u><a href="file:/etc/protocols">/etc/protocols</a></u>, for example: <b>ah</b>, <b>esp</b>, <b>eigrp</b> (only in Linux, FreeBSD,
              NetBSD, DragonFly BSD, and macOS), <b>icmp</b>, <b>igmp</b>, <b>igrp</b> (only in OpenBSD),  <b>pim</b>,  <b>sctp</b>,  <b>tcp</b>,  <b>udp</b>  or
              <b>vrrp</b>.   Note  that  most  of  these  example identifiers are also keywords and must be escaped via
              backslash (\).  Note that this primitive does not chase the protocol header chain.

       <b>icmp</b>   Abbreviation for:
                   <b>ip</b> <b>proto</b> 1

       <b>ip6</b> <b>proto</b> <u>protocol</u>
              True if the packet is an IPv6 packet of protocol type <u>protocol</u>.  (See `<b>ip</b>  <b>proto</b>'  above  for  the
              meaning  of <u>protocol</u>.)  Note that the IPv6 variant of ICMP uses a different protocol number, named
              <b>ipv6-icmp</b> in AIX, FreeBSD, illumos, Linux, macOS, NetBSD, OpenBSD, Solaris and Windows.  Note that
              this primitive does not chase the protocol header chain.

       <b>icmp6</b>  Abbreviation for:
                   <b>ip6</b> <b>proto</b> 58

       <b>proto</b> <u>protocol</u>
              True if the packet is an IPv4 or IPv6 packet of protocol type <u>protocol</u>.  (See `<b>ip</b> <b>proto</b>' above for
              the meaning of <u>protocol</u>.)  Note that this primitive does not chase the protocol header chain.

       <b>ah</b>, <b>esp</b>, <b>pim</b>, <b>sctp</b>, <b>tcp</b>, <b>udp</b>
              Abbreviations for:
                   <b>proto</b> <b>\</b><u>protocol</u>
              where <u>protocol</u> is one of the above protocols.

       <b>ip6</b> <b>protochain</b> <u>protocol</u>
              True if the packet is IPv6 packet, and contains protocol header with type <u>protocol</u> in its protocol
              header chain.  (See `<b>ip</b> <b>proto</b>' above for the meaning of <u>protocol</u>.)  For example,
                   <b>ip6</b> <b>protochain</b> 6
              matches any IPv6 packet with TCP protocol header in the protocol header  chain.   The  packet  may
              contain,  for example, authentication header, routing header, or hop-by-hop option header, between
              IPv6 header and TCP header.  The BPF code emitted by this  primitive  is  complex  and  cannot  be
              optimized by the BPF optimizer code, and is not supported by filter engines in the kernel, so this
              can be somewhat slow, and may cause more packets to be dropped.

       <b>ip</b> <b>protochain</b> <u>protocol</u>
              Equivalent  to  <b>ip6</b>  <b>protochain</b>  <u>protocol</u>,  but  this  is for IPv4.  (See `<b>ip</b> <b>proto</b>' above for the
              meaning of <u>protocol</u>.)

       <b>protochain</b> <u>protocol</u>
              True if the packet is an IPv4 or IPv6 packet of protocol type <u>protocol</u>.  (See `<b>ip</b> <b>proto</b>' above for
              the meaning of <u>protocol</u>.)  Note that this primitive chases the protocol header chain.

       <b>ether</b> <b>broadcast</b>
              True if the packet is an Ethernet broadcast packet.  The <b>ether</b> keyword is optional.

       <b>ip</b> <b>broadcast</b>
              True if the packet is an IPv4 broadcast packet.  It checks for both the  all-zeroes  and  all-ones
              broadcast conventions, and looks up the subnet mask on the interface on which the capture is being
              done.

              If  the  subnet  mask of the interface on which the capture is being done is not available, either
              because the interface on which capture is being done has no netmask  or  because  the  capture  is
              being  done on the Linux "any" interface, which can capture on more than one interface, this check
              will not work correctly.

       <b>ether</b> <b>multicast</b>
              True if the packet is an Ethernet multicast packet.  The  <b>ether</b>  keyword  is  optional.   This  is
              shorthand for `<b>ether[</b>0<b>]</b> <b>&amp;</b> 1 <b>!=</b> 0'.

       <b>ip</b> <b>multicast</b>
              True if the packet is an IPv4 multicast packet.

       <b>ip6</b> <b>multicast</b>
              True if the packet is an IPv6 multicast packet.

       <b>ether</b> <b>proto</b> <u>protocol</u>
              True  if the packet is of ether type <u>protocol</u>.  <u>Protocol</u> can be a number or one of the names <b>aarp</b>,
              <b>arp</b>, <b>atalk</b>, <b>decnet</b>, <b>ip</b>, <b>ip6</b>, <b>ipx</b>, <b>iso</b>, <b>lat</b>, <b>loopback</b>, <b>mopdl</b>, <b>moprc</b>, <b>netbeui</b>,  <b>rarp</b>,  <b>sca</b>  or  <b>stp</b>.
              Note these identifiers (except <b>loopback</b>) are also keywords and must be escaped via backslash (\).

              [In  the  case  of  FDDI  (e.g.,  `<b>fddi</b> <b>proto</b> <b>\arp</b>'), Token Ring (e.g., `<b>tr</b> <b>proto</b> <b>\arp</b>'), and IEEE
              802.11 wireless LANs (e.g., `<b>wlan</b>  <b>proto</b>  <b>\arp</b>'),  for  most  of  those  protocols,  the  protocol
              identification comes from the 802.2 Logical Link Control (LLC) header, which is usually layered on
              top of the FDDI, Token Ring, or 802.11 header.

              When  filtering  for  most  protocol identifiers on FDDI, Token Ring, or 802.11, the filter checks
              only the protocol ID field of an LLC header in so-called SNAP format with an  Organizational  Unit
              Identifier (OUI) of 0x000000, for encapsulated Ethernet; it doesn't check whether the packet is in
              SNAP format with an OUI of 0x000000.  The exceptions are:

              <b>iso</b>    the  filter  checks  the  DSAP  (Destination Service Access Point) and SSAP (Source Service
                     Access Point) fields of the LLC header;

              <b>stp</b> and <b>netbeui</b>
                     the filter checks the DSAP of the LLC header;

              <b>atalk</b>  the filter checks for a SNAP-format packet with an OUI of 0x080007 and the AppleTalk etype.

              In the case of Ethernet, the filter checks the Ethernet type field for most  of  those  protocols.
              The exceptions are:

              <b>iso</b>, <b>stp</b>, and <b>netbeui</b>
                     the  filter  checks  for an 802.3 frame and then checks the LLC header as it does for FDDI,
                     Token Ring, and 802.11;

              <b>atalk</b>  the filter checks both for the AppleTalk etype in an Ethernet frame and for  a  SNAP-format
                     packet as it does for FDDI, Token Ring, and 802.11;

              <b>aarp</b>   the  filter checks for the AppleTalk ARP etype in either an Ethernet frame or an 802.2 SNAP
                     frame with an OUI of 0x000000;

              <b>ipx</b>    the filter checks for the IPX etype in an Ethernet frame, the IPX DSAP in the  LLC  header,
                     the 802.3-with-no-LLC-header encapsulation of IPX, and the IPX etype in a SNAP frame.

       <b>ip</b>, <b>ip6</b>, <b>arp</b>, <b>rarp</b>, <b>atalk</b>, <b>aarp</b>, <b>decnet</b>, <b>iso</b>, <b>stp</b>, <b>ipx</b>, <b>netbeui</b>
              Abbreviations for:
                   <b>ether</b> <b>proto</b> <b>\</b><u>protocol</u>
              where <u>protocol</u> is one of the above protocols.

       <b>lat</b>, <b>moprc</b>, <b>mopdl</b>
              Abbreviations for:
                   <b>ether</b> <b>proto</b> <b>\</b><u>protocol</u>
              where  <u>protocol</u>  is  one of the above protocols.  Note that not all applications using <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP)
              currently know how to parse these protocols.

       <b>decnet</b> <b>src</b> <u>decnetaddr</u>
              True if the DECnet source address is <u>decnetaddr</u>, which may be an address of the  form  ``10.123'',
              or  a  DECnet  host  name.  [DECnet host name support is only available on ULTRIX systems that are
              configured to run DECnet.]

       <b>decnet</b> <b>dst</b> <u>decnetaddr</u>
              True if the DECnet destination address is <u>decnetaddr</u>.

       <b>decnet</b> <b>host</b> <u>decnetaddr</u>
              True if either the DECnet source or destination address is <u>decnetaddr</u>.

       <b>llc</b>    True if the packet has an 802.2 LLC header.  This includes:

              Ethernet packets with a length field rather than a type field that aren't  raw  NetWare-over-802.3
              packets;

              IEEE 802.11 data packets;

              Token Ring packets (no check is done for LLC frames);

              FDDI packets (no check is done for LLC frames);

              LLC-encapsulated ATM packets, for SunATM on Solaris.

       <b>llc</b> <u>type</u>
              True if the packet has an 802.2 LLC header and has the specified <u>type</u>.  <u>type</u> can be one of:

              <b>i</b>      Information (I) PDUs

              <b>s</b>      Supervisory (S) PDUs

              <b>u</b>      Unnumbered (U) PDUs

              <b>rr</b>     Receiver Ready (RR) S PDUs

              <b>rnr</b>    Receiver Not Ready (RNR) S PDUs

              <b>rej</b>    Reject (REJ) S PDUs

              <b>ui</b>     Unnumbered Information (UI) U PDUs

              <b>ua</b>     Unnumbered Acknowledgment (UA) U PDUs

              <b>disc</b>   Disconnect (DISC) U PDUs

              <b>sabme</b>  Set Asynchronous Balanced Mode Extended (SABME) U PDUs

              <b>test</b>   Test (TEST) U PDUs

              <b>xid</b>    Exchange Identification (XID) U PDUs

              <b>frmr</b>   Frame Reject (FRMR) U PDUs

       <b>inbound</b>
              Packet  was received by the host performing the capture rather than being sent by that host.  This
              is only supported for certain link-layer types, such as SLIP and the ``cooked'' Linux capture mode
              used for the ``any'' device and for some other device types.

       <b>outbound</b>
              Packet was sent by the host performing the capture rather than being received by that host.   This
              is only supported for certain link-layer types, such as SLIP and the ``cooked'' Linux capture mode
              used for the ``any'' device and for some other device types.

       <b>ifindex</b> <u>interface_index</u>
              True  if  the packet was logged via the specified interface (applies only to packets logged by the
              Linux "any" cooked v2 interface).

       <b>ifname</b> <u>interface</u>
              True if the packet was logged as coming from the specified  interface  (applies  only  to  packets
              logged by OpenBSD's or FreeBSD's <b><a href="../man4/pf.4.html">pf</a></b>(4)).

       <b>on</b> <u>interface</u>
              Synonymous with the <b>ifname</b> modifier.

       <b>rnr</b> <u>num</u>
              True  if  the  packet was logged as matching the specified PF rule number (applies only to packets
              logged by OpenBSD's or FreeBSD's <b><a href="../man4/pf.4.html">pf</a></b>(4)).

       <b>rulenum</b> <u>num</u>
              Synonymous with the <b>rnr</b> modifier.

       <b>reason</b> <u>code</u>
              True if the packet was logged with the specified PF reason code.   The  known  codes  are:  <b>match</b>,
              <b>bad-offset</b>, <b>fragment</b>, <b>short</b>, <b>normalize</b>, and <b>memory</b> (applies only to packets logged by OpenBSD's or
              FreeBSD's <b><a href="../man4/pf.4.html">pf</a></b>(4)).

       <b>rset</b> <u>name</u>
              True  if  the  packet  was logged as matching the specified PF ruleset name of an anchored ruleset
              (applies only to packets logged by OpenBSD's or FreeBSD's <b><a href="../man4/pf.4.html">pf</a></b>(4)).

       <b>ruleset</b> <u>name</u>
              Synonymous with the <b>rset</b> modifier.

       <b>srnr</b> <u>num</u>
              True if the packet was logged as matching the specified PF rule  number  of  an  anchored  ruleset
              (applies only to packets logged by OpenBSD's or FreeBSD's <b><a href="../man4/pf.4.html">pf</a></b>(4)).

       <b>subrulenum</b> <u>num</u>
              Synonymous with the <b>srnr</b> modifier.

       <b>action</b> <u>act</u>
              True  if  PF  took  the  specified action when the packet was logged.  Known actions are: <b>pass</b> and
              <b>block</b> and, with later versions of <b><a href="../man4/pf.4.html">pf</a></b>(4), <b>nat</b>, <b>rdr</b>, <b>binat</b> and <b>scrub</b> (applies only to packets logged
              by OpenBSD's or FreeBSD's <b><a href="../man4/pf.4.html">pf</a></b>(4)).

       <b>wlan</b> <b>ra</b> <u>ehost</u>
              True if the IEEE 802.11 RA is <u>ehost</u>.  The RA field is used in all  frames  except  for  management
              frames.

       <b>wlan</b> <b>ta</b> <u>ehost</u>
              True  if  the  IEEE  802.11 TA is <u>ehost</u>.  The TA field is used in all frames except for management
              frames and CTS (Clear To Send) and ACK (Acknowledgment) control frames.

       <b>wlan</b> <b>addr1</b> <u>ehost</u>
              True if the first IEEE 802.11 address is <u>ehost</u>.

       <b>wlan</b> <b>addr2</b> <u>ehost</u>
              True if the second IEEE 802.11 address, if present, is <u>ehost</u>.  The second address field is used in
              all frames except for CTS (Clear To Send) and ACK (Acknowledgment) control frames.

       <b>wlan</b> <b>addr3</b> <u>ehost</u>
              True if the third IEEE 802.11 address, if present, is <u>ehost</u>.  The third address field is  used  in
              management and data frames, but not in control frames.

       <b>wlan</b> <b>addr4</b> <u>ehost</u>
              True  if  the  fourth IEEE 802.11 address, if present, is <u>ehost</u>.  The fourth address field is only
              used for WDS (Wireless Distribution System) frames.

       <b>type</b> <u>wlan_type</u>
              True if the IEEE 802.11 frame type matches the specified <u>wlan_type</u>.  Valid  <u>wlan_type</u>s  are:  <b>mgt</b>,
              <b>ctl</b> and <b>data</b>.

       <b>type</b> <u>wlan_type</u> <b>subtype</b> <u>wlan_subtype</u>
              True  if  the IEEE 802.11 frame type matches the specified <u>wlan_type</u> and frame subtype matches the
              specified <u>wlan_subtype</u>.

              If the specified <u>wlan_type</u> is <b>mgt</b>, then valid <u>wlan_subtype</u>s are: <b>assoc-req</b>,  <b>assoc-resp</b>,  <b>reassoc-</b>
              <b>req</b>, <b>reassoc-resp</b>, <b>probe-req</b>, <b>probe-resp</b>, <b>beacon</b>, <b>atim</b>, <b>disassoc</b>, <b>auth</b> and <b>deauth</b>.

              If  the  specified  <u>wlan_type</u> is <b>ctl</b>, then valid <u>wlan_subtype</u>s are: <b>ps-poll</b>, <b>rts</b>, <b>cts</b>, <b>ack</b>, <b>cf-end</b>
              and <b>cf-end-ack</b>.

              If the specified <u>wlan_type</u> is <b>data</b>, then valid <u>wlan_subtype</u>s are: <b>data</b>, <b>data-cf-ack</b>, <b>data-cf-poll</b>,
              <b>data-cf-ack-poll</b>, <b>null</b>, <b>cf-ack</b>, <b>cf-poll</b>, <b>cf-ack-poll</b>, <b>qos-data</b>, <b>qos-data-cf-ack</b>, <b>qos-data-cf-poll</b>,
              <b>qos-data-cf-ack-poll</b>, <b>qos</b>, <b>qos-cf-poll</b> and <b>qos-cf-ack-poll</b>.

       <b>subtype</b> <u>wlan_subtype</u>
              True if the IEEE 802.11 frame subtype matches the specified <u>wlan_subtype</u> and frame has the type to
              which the specified <u>wlan_subtype</u> belongs.

       <b>dir</b> <u>direction</u>
              True if the IEEE 802.11 frame direction matches the specified <u>direction</u>.   Valid  directions  are:
              <b>nods</b>, <b>tods</b>, <b>fromds</b>, <b>dstods</b>, or a numeric value.

       <b>vlan</b> <u>[vlan_id]</u>
              True if the packet is an IEEE 802.1Q VLAN packet.  If the optional <u>vlan_id</u> is specified, only true
              if  the  packet  has  the  specified  <u>vlan_id</u>.  Note that the first <b>vlan</b> keyword encountered in an
              expression changes the decoding offsets for the remainder of the expression on the assumption that
              the packet is a VLAN packet.  The `<b>vlan</b> <u>[vlan_id]</u>` keyword may be used more than once,  to  filter
              on VLAN hierarchies.  Each use of that keyword increments the filter offsets by 4.

              For example:
                   <b>vlan</b> 100 <b>&amp;&amp;</b> <b>vlan</b> 200
              filters on VLAN 200 encapsulated within VLAN 100, and
                   <b>vlan</b> <b>&amp;&amp;</b> <b>vlan</b> 300 <b>&amp;&amp;</b> <b>ip</b>
              filters IPv4 protocol encapsulated in VLAN 300 encapsulated within any higher order VLAN.

       <b>mpls</b> <u>[label_num]</u>
              True  if  the  packet is an MPLS packet.  If the optional <u>label_num</u> is specified, only true if the
              packet has the specified <u>label_num</u>.  Note that the first <b>mpls</b> keyword encountered in an expression
              changes the decoding offsets for the remainder of the expression on the assumption that the packet
              is a MPLS-encapsulated IP packet.  The `<b>mpls</b> <u>[label_num]</u>` keyword may be used more than  once,  to
              filter on MPLS hierarchies.  Each use of that keyword increments the filter offsets by 4.

              For example:
                   <b>mpls</b> 100000 <b>&amp;&amp;</b> <b>mpls</b> 1024
              filters packets with an outer label of 100000 and an inner label of 1024, and
                   <b>mpls</b> <b>&amp;&amp;</b> <b>mpls</b> 1024 <b>&amp;&amp;</b> <b>host</b> 192.9.200.1
              filters packets to or from 192.9.200.1 with an inner label of 1024 and any outer label.

       <b>pppoed</b> True if the packet is a PPP-over-Ethernet Discovery packet (Ethernet type 0x8863).

       <b>pppoes</b> <u>[session_id]</u>
              True  if the packet is a PPP-over-Ethernet Session packet (Ethernet type 0x8864).  If the optional
              <u>session_id</u> is specified, only true if the packet has the  specified  <u>session_id</u>.   Note  that  the
              first  <b>pppoes</b>  keyword encountered in an expression changes the decoding offsets for the remainder
              of the expression on the assumption that the packet is a PPPoE session packet.

              For example:
                   <b>pppoes</b> 0x27 <b>&amp;&amp;</b> <b>ip</b>
              filters IPv4 protocol encapsulated in PPPoE session id 0x27.

       <b>geneve</b> <u>[vni]</u>
              True if the packet is a Geneve packet (UDP port 6081). If the optional <u>vni</u> is specified, only true
              if the packet has the specified <u>vni</u>.  Note that when the  <b>geneve</b>  keyword  is  encountered  in  an
              expression,  it changes the decoding offsets for the remainder of the expression on the assumption
              that the packet is a Geneve packet.

              For example:
                   <b>geneve</b> 0xb <b>&amp;&amp;</b> <b>ip</b>
              filters IPv4 protocol encapsulated in Geneve with VNI 0xb. This  will  match  both  IPv4  directly
              encapsulated in Geneve as well as IPv4 contained inside an Ethernet frame.

       <b>iso</b> <b>proto</b> <u>protocol</u>
              True if the packet is an OSI packet of protocol type <u>protocol</u>.  <u>Protocol</u> can be a number or one of
              the names <b>clnp</b>, <b>esis</b>, or <b>isis</b>.

       <b>clnp</b>, <b>esis</b>, <b>isis</b>
              Abbreviations for:
                   <b>iso</b> <b>proto</b> <b>\</b><u>protocol</u>
              where <u>protocol</u> is one of the above protocols.

       <b>l1</b>, <b>l2</b>, <b>iih</b>, <b>lsp</b>, <b>snp</b>, <b>csnp</b>, <b>psnp</b>
              Abbreviations for IS-IS PDU types.

       <b>vpi</b> <u>n</u>  True if the packet is an ATM packet, for SunATM on Solaris, with a virtual path identifier of <u>n</u>.

       <b>vci</b> <u>n</u>  True  if  the packet is an ATM packet, for SunATM on Solaris, with a virtual channel identifier of
              <u>n</u>.

       <b>lane</b>   True if the packet is an ATM packet, for SunATM on Solaris, and is an ATM LANE packet.  Note  that
              the first <b>lane</b> keyword encountered in an expression changes the tests done in the remainder of the
              expression  on  the assumption that the packet is either a LANE emulated Ethernet packet or a LANE
              LE Control packet.  If <b>lane</b> isn't specified, the tests are done  under  the  assumption  that  the
              packet is an LLC-encapsulated packet.

       <b>oamf4s</b> True  if  the  packet  is  an ATM packet, for SunATM on Solaris, and is a segment OAM F4 flow cell
              (VPI=0 &amp; VCI=3).

       <b>oamf4e</b> True if the packet is an ATM packet, for SunATM on Solaris, and is an end-to-end OAM F4 flow  cell
              (VPI=0 &amp; VCI=4).

       <b>oamf4</b>  True  if the packet is an ATM packet, for SunATM on Solaris, and is a segment or end-to-end OAM F4
              flow cell (VPI=0 &amp; (VCI=3 | VCI=4)).

       <b>oam</b>    True if the packet is an ATM packet, for SunATM on Solaris, and is a segment or end-to-end OAM  F4
              flow cell (VPI=0 &amp; (VCI=3 | VCI=4)).

       <b>metac</b>  True  if  the  packet  is an ATM packet, for SunATM on Solaris, and is on a meta signaling circuit
              (VPI=0 &amp; VCI=1).

       <b>bcc</b>    True if the packet is an ATM packet, for SunATM on  Solaris,  and  is  on  a  broadcast  signaling
              circuit (VPI=0 &amp; VCI=2).

       <b>sc</b>     True if the packet is an ATM packet, for SunATM on Solaris, and is on a signaling circuit (VPI=0 &amp;
              VCI=5).

       <b>ilmic</b>  True  if  the  packet  is an ATM packet, for SunATM on Solaris, and is on an ILMI circuit (VPI=0 &amp;
              VCI=16).

       <b>connectmsg</b>
              True if the packet is an ATM packet, for SunATM on Solaris, and is on a signaling circuit and is a
              Q.2931 Setup, Call Proceeding, Connect, Connect Ack, Release, or Release Done message.

       <b>metaconnect</b>
              True if the packet is an ATM packet, for SunATM on Solaris, and is on a meta signaling circuit and
              is a Q.2931 Setup, Call Proceeding, Connect, Release, or Release Done message.

       <u>expr1</u> <u>relop</u> <u>expr2</u>
              True if the relation holds.  <u>Relop</u> is one of {<b>&gt;</b>, <b>&lt;</b>, <b>&gt;=</b>, <b>&lt;=</b>, <b>=</b>, <b>==</b>, <b>!=</b>} (where <b>=</b> means the same  as
              <b>==</b>).  Each of <u>expr1</u> and <u>expr2</u> is an arithmetic expression composed of integer constants (expressed
              in  standard  C  syntax),  the  normal binary operators {<b>+</b>, <b>-</b>, <b>*</b>, <b>/</b>, <b>%</b>, <b>&amp;</b>, <b>|</b>, <b>^</b>, <b>&lt;&lt;</b>, <b>&gt;&gt;</b>}, a length
              operator, and special packet data accessors.  Note that all comparisons are unsigned, so that, for
              example, 0x80000000 and 0xffffffff are &gt; 0.

              The <b>%</b> and <b>^</b> operators are currently only supported for  filtering  in  the  kernel  on  particular
              operating  systems  (for example: FreeBSD, Linux with 3.7 and later kernels, NetBSD); on all other
              systems (for example: AIX, illumos, Solaris, OpenBSD), if those operators are used, filtering will
              be done in user mode, which will increase the overhead of capturing packets  and  may  cause  more
              packets to be dropped.

              The length operator, indicated by the keyword <b>len</b>, gives the length of the packet.

              To access data inside the packet, use the following syntax:
                   <u>proto</u> <b>[</b> <u>expr</u> <b>:</b> <u>size</u> <b>]</b>
              <u>Proto</u>  is  one  of  <b>arp</b>,  <b>atalk</b>, <b>carp</b>, <b>decnet</b>, <b>ether</b>, <b>fddi</b>, <b>icmp</b>, <b>icmp6</b>, <b>igmp</b>, <b>igrp</b>, <b>ip</b>, <b>ip6</b>, <b>lat</b>,
              <b>link</b>, <b>mopdl</b>, <b>moprc</b>, <b>pim</b>, <b>ppp</b>, <b>radio</b>, <b>rarp</b>, <b>sca</b>, <b>sctp</b>, <b>slip</b>,  <b>tcp</b>,  <b>tr</b>,  <b>udp</b>,  <b>vrrp</b>  or  <b>wlan</b>,  and
              indicates  the protocol layer for the index operation.  (<b>ether</b>, <b>fddi</b>, <b>link</b>, <b>ppp</b>, <b>slip</b>, <b>tr</b> and <b>wlan</b>
              all refer to the link layer. <b>radio</b> refers to the "radio header" added to  some  802.11  captures.)
              Note that <b>tcp</b>, <b>udp</b> and other upper-layer protocol types only apply to IPv4, not IPv6 (this will be
              fixed  in  the  future).   The  byte offset, relative to the indicated protocol layer, is given by
              <u>expr</u>.  <u>Size</u> is optional and indicates the number of bytes in the field  of  interest;  it  can  be
              either one, two, or four, and defaults to one.

              For example, `<b>ether[</b>0<b>]</b> <b>&amp;</b> 1 <b>!=</b> 0' catches all multicast traffic.  The expression `<b>ip[</b>0<b>]</b> <b>&amp;</b> 0xf <b>!=</b> 5'
              catches  all  IPv4  packets  with  options.   The  expression  `<b>ip[</b>6:2<b>]</b> <b>&amp;</b> 0x1fff <b>=</b> 0' catches only
              unfragmented IPv4 datagrams and frag zero of fragmented IPv4 datagrams.  This check is  implicitly
              applied  to the <b>tcp</b> and <b>udp</b> index operations.  For instance, <b>tcp[</b>0<b>]</b> always means the first byte of
              the TCP <u>header</u>, and never means the first byte of an intervening fragment.

              Some offsets and field values may be expressed as  names  rather  than  as  numeric  values.   The
              following  protocol  header  field  offsets  are  available: <b>icmptype</b> (ICMP type field), <b>icmp6type</b>
              (ICMPv6 type field), <b>icmpcode</b> (ICMP code field), <b>icmp6code</b> (ICMPv6 code field) and  <b>tcpflags</b>  (TCP
              flags field).

              The   following   ICMP   type   field   values   are   available:   <b>icmp-echoreply</b>,  <b>icmp-unreach</b>,
              <b>icmp-sourcequench</b>, <b>icmp-redirect</b>, <b>icmp-echo</b>, <b>icmp-routeradvert</b>, <b>icmp-routersolicit</b>, <b>icmp-timxceed</b>,
              <b>icmp-paramprob</b>,   <b>icmp-tstamp</b>,   <b>icmp-tstampreply</b>,   <b>icmp-ireq</b>,   <b>icmp-ireqreply</b>,    <b>icmp-maskreq</b>,
              <b>icmp-maskreply</b>.

              The    following    ICMPv6    type   field   values   are   available:   <b>icmp6-destinationunreach</b>,
              <b>icmp6-packettoobig</b>,  <b>icmp6-timeexceeded</b>,  <b>icmp6-parameterproblem</b>,   <b>icmp6-echo</b>,   <b>icmp6-echoreply</b>,
              <b>icmp6-multicastlistenerquery</b>,     <b>icmp6-multicastlistenerreportv1</b>,    <b>icmp6-multicastlistenerdone</b>,
              <b>icmp6-routersolicit</b>,     <b>icmp6-routeradvert</b>,     <b>icmp6-neighborsolicit</b>,      <b>icmp6-neighboradvert</b>,
              <b>icmp6-redirect</b>,   <b>icmp6-routerrenum</b>,   <b>icmp6-nodeinformationquery</b>,  <b>icmp6-nodeinformationresponse</b>,
              <b>icmp6-ineighbordiscoverysolicit</b>, <b>icmp6-ineighbordiscoveryadvert</b>,  <b>icmp6-multicastlistenerreportv2</b>,
              <b>icmp6-homeagentdiscoveryrequest</b>,     <b>icmp6-homeagentdiscoveryreply</b>,     <b>icmp6-mobileprefixsolicit</b>,
              <b>icmp6-mobileprefixadvert</b>,               <b>icmp6-certpathsolicit</b>,               <b>icmp6-certpathadvert</b>,
              <b>icmp6-multicastrouteradvert</b>, <b>icmp6-multicastroutersolicit</b>, <b>icmp6-multicastrouterterm</b>.

              The  following TCP flags field values are available: <b>tcp-fin</b>, <b>tcp-syn</b>, <b>tcp-rst</b>, <b>tcp-push</b>, <b>tcp-ack</b>,
              <b>tcp-urg</b>, <b>tcp-ece</b>, <b>tcp-cwr</b>.

       Primitives may be combined using:

              A parenthesized group of primitives and operators.

              Negation (`<b>!</b>' or `<b>not</b>').

              Concatenation (`<b>&amp;&amp;</b>' or `<b>and</b>').

              Alternation (`<b>||</b>' or `<b>or</b>').

       Negation has the highest precedence.  Alternation and concatenation have equal precedence  and  associate
       left to right.

       If an identifier is given without a keyword, the most recent keyword is assumed.  For example,
            <b>not</b> <b>host</b> vs <b>and</b> ace
       is short for
            <b>not</b> <b>host</b> vs <b>and</b> <b>host</b> ace
       which should not be confused with
            <b>not</b> <b>(host</b> vs <b>or</b> ace<b>)</b>

</pre><h4><b>EXAMPLES</b></h4><pre>
       To select all packets arriving at or departing from `sundown':
              <b>host</b> sundown

       To select traffic between `helios' and either `hot' or `ace':
              <b>host</b> helios <b>and</b> <b>(</b>hot <b>or</b> ace<b>)</b>

       To select all IPv4 packets between `ace' and any host except `helios':
              <b>ip</b> <b>host</b> ace <b>and</b> <b>not</b> helios

       To select all traffic between local hosts and hosts at Berkeley:
              <b>net</b> ucb-ether

       To select all FTP traffic through Internet gateway `snup':
              <b>gateway</b> snup <b>and</b> <b>(port</b> ftp <b>or</b> ftp-data<b>)</b>

       To  select  IPv4  traffic  neither sourced from nor destined for local hosts (if you gateway to one other
       net, this stuff should never make it onto your local net).
              <b>ip</b> <b>and</b> <b>not</b> <b>net</b> localnet

       To select the start and end packets (the SYN and FIN packets) of each TCP conversation  that  involves  a
       non-local host.
              <b>tcp[tcpflags]</b> <b>&amp;</b> <b>(tcp-syn|tcp-fin)</b> <b>!=</b> 0 <b>and</b> <b>not</b> <b>src</b> <b>and</b> <b>dst</b> <b>net</b> localnet

       To  select  the  TCP packets with flags RST and ACK both set.  (i.e. select only the RST and ACK flags in
       the flags field, and if the result is "RST and ACK both set", match)
              <b>tcp[tcpflags]</b> <b>&amp;</b> <b>(tcp-rst|tcp-ack)</b> <b>==</b> <b>(tcp-rst|tcp-ack)</b>

       To select all IPv4 HTTP packets to and from port 80, i.e. print only packets that contain data, not,  for
       example, SYN and FIN packets and ACK-only packets.  (IPv6 is left as an exercise for the reader.)
              <b>tcp</b> <b>port</b> 80 <b>and</b> <b>(((ip[</b>2:2<b>]</b> <b>-</b> <b>((ip[</b>0<b>]&amp;</b>0xf<b>)&lt;&lt;</b>2<b>))</b> <b>-</b> <b>((tcp[</b>12<b>]&amp;</b>0xf0<b>)&gt;&gt;</b>2<b>))</b> <b>!=</b> 0<b>)</b>

       To select IPv4 packets longer than 576 bytes sent through gateway `snup':
              <b>gateway</b> snup <b>and</b> <b>ip[</b>2:2<b>]</b> <b>&gt;</b> 576

       To select IPv4 broadcast or multicast packets that were <u>not</u> sent via Ethernet broadcast or multicast:
              <b>ether[</b>0<b>]</b> <b>&amp;</b> 1 <b>=</b> 0 <b>and</b> <b>ip[</b>16<b>]</b> <b>&gt;=</b> 224

       To select all ICMP packets that are not echo requests/replies (i.e., not ping packets):
              <b>icmp[icmptype]</b> <b>!=</b> <b>icmp-echo</b> <b>and</b> <b>icmp[icmptype]</b> <b>!=</b> <b>icmp-echoreply</b>
              <b>icmp6[icmp6type]</b> <b>!=</b> <b>icmp6-echo</b> <b>and</b> <b>icmp6[icmp6type]</b> <b>!=</b> <b>icmp6-echoreply</b>

</pre><h4><b>BACKWARD</b> <b>COMPATIBILITY</b></h4><pre>
       The ICMPv6 type code names, as well as the <b>tcp-ece</b> and <b>tcp-cwr</b> TCP flag names became available in libpcap
       1.9.0.

       The <b>geneve</b> keyword became available in libpcap 1.8.0.

       The <b>ifindex</b> keyword became available in libpcap 1.10.0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP)

</pre><h4><b>BUGS</b></h4><pre>
       To report a security issue please send an e-mail to <a href="mailto:security@tcpdump.org">security@tcpdump.org</a>.

       To  report  bugs  and other problems, contribute patches, request a feature, provide generic feedback etc
       please see the file <u>CONTRIBUTING.md</u> in the libpcap source tree root.

       Filter expressions on fields other than those in Token Ring headers will  not  correctly  handle  source-
       routed Token Ring packets.

       Filter  expressions  on  fields  other than those in 802.11 headers will not correctly handle 802.11 data
       packets with both To DS and From DS set.

       `<b>ip6</b> <b>proto</b>' should chase header chain, but at this moment it does not.  `<b>ip6</b> <b>protochain</b>' is supplied  for
       this behavior.  For example, to match IPv6 fragments: `<b>ip6</b> <b>protochain</b> 44'

       Arithmetic  expression  against transport layer headers, like <b>tcp[0]</b>, does not work against IPv6 packets.
       It only looks at IPv4 packets.

                                                  13 June 2023                                    <u><a href="../man7/PCAP-FILTER.7.html">PCAP-FILTER</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>