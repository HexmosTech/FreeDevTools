<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>persistent_table - persistent data base (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       persistent_table - persistent data base (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Here is a convenient way to implement a persistent data base of big object that are long to initialize
       and then used only in a read-only mode, via accessors, no modifiers. Examples of such objects in
       scientific computing are are finite element meshes (see <b><a href="../man2/geo.2.html">geo</a>(2)</b>), that are long to load from file and
       requires large memory, or high-order polynomial basis (see <b><a href="../man2/basis.2.html">basis</a>(2)</b>), that are long to initialize (e.g.
       Vandermonde matrix inversion). When such objects are created independently in different parts of a code,
       both memory size and computation time could be save by reusing them when these objects was already
       created.

       The aim of the <b>persistent_table</b> class is to automate the implementation of a persistent data base for a
       generic object, that could be e.g. a finite element mesh or a polynomial basis. It requires very few
       modification of a pre-existing object. The implementation of the <b>persistent_table</b> class bases on those of
       <b><a href="../man7/smart_pointer.7.html">smart_pointer</a>(7)</b> class for handling reference counting. When shared object in the data base are not
       modifiable, the idea is to use the smart_pointer_nocopy class. Otherwise, when the object has to be
       modified, the name of the object, that is used as a key in an hashtable, should also be modified, in
       order to address the new modified object. Here is a small minimalist example of the class.

</pre><h4><b>EXAMPLE</b></h4><pre>
       struct A_rep {
         public:
           A_rep (const string&amp; name1) : _name(name1) { /* long init */ }
           ~A_rep();
           string name() const { return _name; }
           static A_rep* make_ptr (const string&amp; name) { return new A_rep (name); }
         // data:
         protected:
           string _name;
       };
       struct A : public smart_pointer_nocopy&lt;A_rep&gt;, public persistent_table&lt;A&gt; {
         public:
           using rep  = A_rep;
           using base = smart_pointer_nocopy&lt;rep&gt;;
           A (const string&amp; name = "");
           string name() const { return base::data().name(); }
       };
       // implementation of members:
       A::A (const string&amp; name)
         : base(),
           persistent_table&lt;A&gt;()
       {
         if (name == "") return;
         base::operator= (persistent_table&lt;A&gt;::load (name));
       }
       A_rep::~A_rep()
       {
         persistent_table&lt;A&gt;::unload (_name);
       }
       int main() {
         persistent_table&lt;A&gt;::set_verbose (true); // trace table load/unload
         A a("a");     // "a" created
         {
           A b("b");   // "b" created
           A c("a");   // "a" reused from table
         }             // "b" destroyed and erased from table
         {
           A b("b");   // "b" created
           A c("a");   // "a" reused from table
         }             // "b" destroyed and erased from table
       }               // "a" destroyed and erased from table

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file util/lib/persistent_table.h

       template&lt;class A&gt;
       class persistent_table {
         public:
           static A    load   (const std::string&amp; name);
           static void unload (const std::string&amp; name);
           static bool verbose () { return _verbose; }
           static void set_verbose (bool v) { _verbose = v; }
         protected:
           using  loaded_map_type = std::unordered_map&lt;std::string,void*&gt;;
           static loaded_map_type&amp; get_loaded_map() { return _loaded_map; }
         // data:
           static loaded_map_type     _loaded_map;
           static bool                _verbose;
       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                        <u><a href="../man7rheolef/persistent_table.7rheolef.html">persistent_table</a></u>(7rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>