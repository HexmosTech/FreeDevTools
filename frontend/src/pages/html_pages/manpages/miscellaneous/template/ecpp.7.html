<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ecpp - template language for tntnet(8)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtntnet-dev">libtntnet-dev_3.0-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ecpp - template language for <a href="../man8/tntnet.8.html">tntnet</a>(8)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ecpp</b> is the template language used by the tntnet system to generate dynamic content.

       A template consists of normal content (normally html data) enriched with special tags, which trigger some
       special handling.

       One  ecpp file is compiled into a C++ class. The C++ class is placed into the namespace component. A ecpp
       file compiled into a C++ class is called component.  The name of the class is the basename of the file.

   <b>request</b>, <b>reply</b>, <b>qparam</b>
       Each component has 3 parameters: <b>request</b>, <b>reply</b> and <b>qparam</b>.  <b>request</b> holds information about  the  client
       request  like  http  headers  and  the  url,  but also additional parameters specified in the config file
       <a href="../man7/tntnet.xml.7.html">tntnet.xml</a>(7). The type of request is <b>tnt::HttpRequest</b>.

       <b>reply</b> receives the answer from the component. The component can set additional  http  headers  here,  set
       cookies  and  -  most  important  -  generate output. The most important methods here are <b>reply.out()</b> and
       <b>reply.sout()</b>. Both return a <b>std::ostream</b>, which receives the output of the component. <b>reply.sout()</b> has  a
       filter  installed,  which  translates some characters, with special meanings in html to the corresponding
       html entities. The characters are <b>&lt;</b>, <b>&gt;</b>, , <b>"</b> and <b>'</b>. This is useful for printing values from  variables  to
       the html code.

       <b>qparam</b>  holds the query parameters parsed from GET- or POST-parameters or received from other components.
       The type of <b>qparam</b> is <b>tnt::QueryParams</b>.  Normally you use a <b>&lt;%args&gt;</b> block to specify the parameters,  but
       there are special cases, where it is useful to access these directly.

   <b>component</b> <b>addressing</b>
       Each  component  has  a  unique name. The name is composed from the class name, the character '@' and the
       name of the shared library, it is located. Components can have internal sub components.  The name of  the
       internal sub component is appended to the class name separated by a dot (.).

   <b>special</b> <b>rule</b> <b>for</b> <b>line</b> <b>feeds</b> <b>after</b> <b>a</b> <b>&lt;/%something&gt;</b>-tag
       A  line  feed  immediately  after  a  closing  tag  for all <b>&lt;%something&gt;</b> blocks are ignored. Hence blocks
       followed immediately one after  another  does  not  generate  white  space  in  output,  which  is  often
       undesirable.

   <b>errorhandling</b>
       Error  handling is done by exception. Tntnet catches all exceptions thrown by components and handles them
       properly. Exceptions must be derived from std::exception. Exceptions  derived  from  <b>tnt::HttpError</b>,  are
       handled  separately. They carry a http return code, which is sent to the client. Other exceptions derived
       from std::exception, result in a http error code 500 (Internal Server Error).

</pre><h4><b>TAGS</b></h4><pre>
       <b>&lt;$</b> <b>expr</b> <b>$&gt;</b>
         Print expressions <b>expr</b> to the output stream. The characters <b>&lt;</b>, <b>&gt;</b>, , <b>"</b>
         and <b>'</b>, which have special meanings in html, are translated to the
         corresponding html entities.

       <b>&lt;$$</b> <b>expr</b> <b>$&gt;</b>
         Print expressions <b>expr</b> without translating characters with special meaning in
         html to html entities to the output stream.

       <b>&lt;?</b> <b>cond</b> <b>?</b> <b>expr</b> <b>?&gt;</b>
         Conditional output. Print expression <b>expr</b> to the output stream, if <b>cond</b>
         evaluates to true. Characters with special meaning in html are translated to
         the corresponding html entities.

       <b>&lt;??</b> <b>cond</b> <b>?</b> <b>expr</b> <b>?&gt;</b>
         Conditional output. Print expression <b>expr</b> to the output stream, if <b>cond</b>
         evaluates to true. Characters with special meaning in html are not translated
         to the corresponding html entities.

       <b>&lt;</b> <b>component</b> <b>[</b> <b>arguments</b> <b>]</b> <b>&gt;</b>
         Call the specified component. The output of the component is printed into the
         output stream. If the component name does not start with a letter, the
         ecpp compiler treats it as a expression, which returns the name of the
         component. You must surround the expression in brackets, if it contains
         spaces.

       The arguments part specify the parameters, the component will receive.
         Arguments are name value pairs separated by '='. They are put in the
         <b>qparam</b> parameter of the component and are normally declared in the
         <b>&lt;%args&gt;</b> block. Values can be specified in 3 forms:

       As a plain word without spaces

       As a string enclosed in quotation marks

       As a expression enclosed in brackets

       A single plain word in the argument list is treated as a variable of type
         <b>cxxtools::QueryParams</b> and a copy is passed to the component. Other
         parameters are added to this copy. If you want to pass all parameters of the
         current component put the variable <b>qparam</b> as a plain word in the argument
         list.

       <b>&lt;/component&gt;</b>
         Closing tag for a component call. When components are called, this
         closing tag might occur later. The code in <b>&lt;%close&gt;</b> block is placed here.

       <b>&lt;{...}&gt;</b>
         C++ inline processing block. The code in this block is copied into the
         C++ class unchanged.

       A linefeed after the closing tag is not ignored.

       <b>&lt;#...#&gt;</b>
         Comment block. Everything in this block is ignored.

       <b>&lt;%application</b> <b>[</b> <b>scope="component|page|shared|global"</b> <b>]</b> <b>&gt;...&lt;/%application&gt;</b>
         Variables defined here, have the lifetime of the application.

       Application scope is automatically locked.

       <b>&lt;%args&gt;...&lt;/%args&gt;</b>
         Defines GET or POST parameters received by the component.

       Each argument has a name and optionally a default value. The default value is
         delimited by '=' from the name. A single argument definition followed by a
         semicolon (;). In the component a variable with the same name of type
         std::string is defined, which receives the value.

       A argument name can be prefixed by a type definition. The ecpp compiler
         generates code, which tries to convert the value with the <b>cxxtools</b>
         deserialization operator. If the argument can't be converted, the default
         value is set.

       Argument names can be postfixed by empty square brackets. This defines a
         std::vector with the specified type or std::string, if no type is specified.
         This way multiple values with the same name can be received. If a type is
         specified, each value is converted to the target type.

       <b>&lt;%attr&gt;...&lt;/%attr&gt;</b>
         Components may define attributes, which can be queried from other components.
         These values are strings and are defined by specifying a name followed by '='
         and the string value. No type is allowed here.

       A other component can the fetch a reference to the component using
         <b>fetchComp(name)</b>. <b>fetchComp</b> is a member of the base class
         <b>tnt::EcppComponent</b> of components built with ecpp.

       The component has then a member method <b>getAttribute(name)</b>, which returns the
         attribute or a empty string when not found. A different default string can be
         passed as a second parameter to <b>getAttribute</b>.

   <b>Example:</b>
       A content component specifies a title:

              &lt;%attr&gt;
              title = "my title";
              &lt;/%attr&gt;

       A component <b>webmain</b> want to add a title depending on a content component:

              &lt;head&gt;
                &lt;title&gt;
                  &lt;$ fetchComp("theContent").getAttribute("title", "default title") $&gt;
                &lt;/title&gt;
                ...

       To separate the C++ code from the html, the actual doing can be moved to a C++
         section. The component can then be also called later to generate the content:

              &lt;%cpp&gt;
                tnt::Component theContent = fetchComp("theContent");
                std::string title = theContent.getAttribute("title", "default title");
              &lt;/%cpp&gt;
              &lt;head&gt;
                &lt;title&gt;&lt;$ title $&gt;&lt;/title&gt;
                ...
                &lt;div id="contnent"&gt;
                  &lt;{ theContent(request, reply, qparam); }&gt;
                &lt;/div&gt;

       <b>&lt;%close&gt;...&lt;/%close&gt;</b>
         Code in these tags is placed into the calling component, when a closing tag
         <b>&lt;/component&gt;</b> is found.

       The <b>&lt;%close&gt;</b> receives the same parameters like the corresponding normal
         component call.

       This tag is deprecated and should not be used any more.

       <b>&lt;%config&gt;...&lt;/%config&gt;</b>
         Often web applications need some configuration like database names or
         login information to the database. These configuration variables can be read
         from the tntnet.xml. Variable names ended with a semicolon are defined as
         static std::string variables and filled from tntnet.xml. A variable can be
         prepended by a type. The value from tntnet.xml is then converted with a
         <b>std::istream</b>.

       You can also specify a default value by appending a '=' and the value to the
         variable.

   <b>Example:</b>
              &lt;%config&gt;
                dburl = "sqlite:db=mydbfile.sqlite";
                int maxvalue = 10;
              &lt;/%config&gt;

       tntnet.xml:
           <b>&lt;dburl&gt;postgresql:dbname=mydb&lt;/dburl&gt;</b>

       <b>&lt;%cpp&gt;...&lt;/%cpp&gt;</b>
         C++ processing block. The code between these tags are copied into the
         C++ class unchanged.

       A linefeed after the closing tag is ignored.

       <b>&lt;%def</b> <b>name&gt;...&lt;/%def&gt;</b>
         Defines a internal sub component with the name name, which can be called like
         other components.

       <b>&lt;%doc&gt;...&lt;/%doc&gt;</b>
         Comment block. Everything in this block is ignored.

       A linefeed after the closing tag is ignored.

       <b>&lt;%get&gt;...&lt;/%get&gt;</b>
         Works like a <b>&lt;%args&gt;</b> block but receives only GET parameters.

       <b>&lt;%include&gt;filename&lt;/%include&gt;</b>
         The specified file is read and compiled.

       <b>&lt;%param&gt;...&lt;/%param&gt;</b>
         Defines parameter received from calling components. In contrast to
         query parameters these variables can be of any type. The syntax (and the
         underlying technology) is the same like in scoped variables. See the
         description about scoped variables to see how to define parameters. The main
         difference is, that a parameter variable has no scope, since the parameter is
         always local to the component.

       <b>&lt;%out&gt;</b> <b>expr</b> <b>&lt;/%out&gt;</b>
         Same as <b>&lt;$$</b> <b>...</b> <b>$&gt;</b>. Prints the contained C++ expression <b>expr</b>.

       <b>&lt;%post&gt;...&lt;/%post&gt;</b>
         Works like a <b>&lt;%args&gt;</b> block but receives only POST parameters.

       <b>&lt;%pre&gt;...&lt;/%pre&gt;</b>
         Defines C++ code, which is placed outside the C++ class and outside the
         namespace definition.  This is a good place to define #include directives.

       <b>&lt;%request</b> <b>[</b> <b>scope="component|page|shared|global"</b> <b>]</b> <b>&gt;...&lt;/%request&gt;</b>
         Define request scope variables. Variables defined here, has the lifetime of
         the request.

       <b>&lt;%session</b> <b>[</b> <b>scope="component|page|shared|global"</b> <b>]</b> <b>&gt;...&lt;/%session&gt;</b>
         Variables defined here, has the lifetime of the session.

       Sessions are identified with cookies. If a <b>&lt;%session&gt;</b> block is defined
         somewhere in a component, a session cookie is sent to the client.

       Sessions are automatically locked.

       <b>&lt;%securesession</b> <b>[</b> <b>scope="component|page|shared|global"</b> <b>]</b> <b>&gt;...&lt;/%securesession&gt;</b>
         Secure session is just like session but a secure cookie is used to identify
         the session. Secure cookies are transferred only over a ssl connection from
         the browser and hence the variables are only kept in a ssl secured
         application.

       If a variable defined here is used in a non ssl page, the variable values are
         lost after the current request.

       <b>&lt;%sout&gt;</b> <b>expr</b> <b>&lt;/%sout&gt;</b>
         Same as <b>&lt;$</b> <b>...</b> <b>$&gt;</b>. Prints the contained C++ expression <b>expr</b>. The characters
         <b>&lt;</b>, <b>&gt;</b>, , <b>"</b> and <b>'</b>, which have special meanings in html, are translated to the
         corresponding html entities.

       <b>&lt;%thread</b> <b>[</b> <b>scope="component|page|shared|global"</b> <b>]</b> <b>&gt;...&lt;/%thread&gt;</b>
         Variables defined here, has the lifetime of the thread. Each thread has his
         own instance of these variables.

       Thread scope variables do not need to be locked at all, because they are only
         valid in the current thread.

</pre><h4><b>SCOPED</b> <b>VARIABLES</b></h4><pre>
       Scoped variables are c++ variables, whose lifetime is handled by tntnet. These variables has  a  lifetime
       and  a scope. The lifetime is defined by the tag, used to declare the variable and the scope is passed as
       a parameter to the tag.

       There are 5 different lifetimes for scoped variables:

       <b>request</b>
         The variable is valid in the current request. The tag is <b>&lt;%request&gt;</b>.

       <b>application</b>
         The variable is valid in the application. The tag is <b>&lt;%application&gt;</b>. The
         application is specified by the shared library of the top level component.

       <b>session</b>
         The variable is valid for the current session. The tag is <b>&lt;%session&gt;</b>. If at
         least session variable is declared in the current request, a session cookie is
         sent to the client.

       <b>thread</b>
         The variable is valid in the current thread. The tag is <b>&lt;%thread&gt;</b>.

       <b>param</b>
         The variable receives parameters. The tag is <b>&lt;%param&gt;</b>.

       And 3 scopes:

       <b>component</b>
         The variable is only valid in the same component. This is the default scope.

       <b>page</b>
         The variable is shared between the components in a single ecpp file. You can
         specify multiple internal sub components in a <b>&lt;%def&gt;</b> block. Variables,
         defined in page scope are shared between these sub components.

       <b>global</b> or <b>shared</b>
         Variables are shared between all components. If you define the same variable
         with shared scope in different components, they must have the same type. This
         is achieved most easily defining them in a separate file and include them
         with a <b>&lt;%include&gt;</b> block. The <b>global</b> and <b>shared</b> are just synonyms.

       Variables are automatically locked as needed.  If you use session variables,
         tntnet ensures, that all requests of the same session are serialized. If you
         use application variables, tntnet serializes all requests to the same
         application scope. Request and thread scope variables do not need to be
         locked at all, because they are not shared between threads.

   <b>Syntax</b> <b>of</b> <b>scoped</b> <b>variables</b>
       Scoped variables are declared with exactly the same syntax as normal variables in c++ code. They  can  be
       of  any type and are instantiated, when needed.  Objects, which do not have default constructors, need to
       be specified with proper constructor parameters in brackets or separated by '='. The parameters are  only
       used,  if  the  variable  need  to be instantiated. This means, that parameters to e.g. application scope
       variables are only used once. When the same component is called later in the same or another request, the
       parameters are not used any more.

   <b>Examples</b>
       Specify a application specific shared variable, which is initialized with 0:

              &lt;%application&gt;
              unsigned count = 0;
              &lt;/%application&gt;

       Specify a variable with a user defined type, which holds the state of the session:

              &lt;%session&gt;
              MyClass sessionState;
              &lt;/%session&gt;

       Specify a persistent database connection, which is initialized,  when  first  needed  and  hold  for  the
       lifetime of the current thread. This variable may be used in other components:

              &lt;%thread scope="shared"&gt;
              tntdb::Connection conn(dburl);
              &lt;/%thread&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written by Tommi Mäkitalo ⟨<a href="mailto:tommi@tntnet.org">tommi@tntnet.org</a>⟩.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/tntnet.8.html">tntnet</a>(8), <a href="../man1/ecppc.1.html">ecppc</a>(1)

Tntnet                                             2006-07-23                                            <u><a href="../man7/ecpp.7.html">ecpp</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>