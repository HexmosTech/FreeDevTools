<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sco - SCO transport</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbluetooth-dev">libbluetooth-dev_5.83-1~exp1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sco - SCO transport

</pre><h4><b>SYNOPSIS</b></h4><pre>
          #include &lt;sys/socket.h&gt;
          #include &lt;bluetooth/bluetooth.h&gt;
          #include &lt;bluetooth/sco.h&gt;

          sco_socket = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_SCO);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  SCO  logical  transport, is a symmetric, point-to-point transport between the Central and a specific
       Peripheral.  The  SCO  logical  transport  reserves  slots  and  can  therefore  be   considered   as   a
       circuit-switched connection between the Central and the Peripheral.

       In  addition  to  the reserved slots, when eSCO is supported, a retransmission window follows immediately
       after. Together, the reserved slots and the retransmission window form the complete eSCO window.

</pre><h4><b>SOCKET</b> <b>ADDRESS</b></h4><pre>
          struct sockaddr_sco {
              sa_family_t     sco_family;
              bdaddr_t        sco_bdaddr;
          };

       Example:

          struct sockaddr_sco addr;

          memset(&amp;addr, 0, sizeof(addr));
          addr.sco_family = AF_BLUETOOTH;
          bacpy(&amp;addr.sco_bdaddr, bdaddr);

</pre><h4><b>SOCKET</b> <b>OPTIONS</b></h4><pre>
       The socket options listed below can be set by using <b><a href="../man2/setsockopt.2.html">setsockopt</a>(2)</b> and read with  <b><a href="../man2/getsockopt.2.html">getsockopt</a>(2)</b>  with  the
       socket level set to SOL_BLUETOOTH.

   <b>BT_SECURITY</b> <b>(since</b> <b>Linux</b> <b>2.6.30)</b>
       Channel security level, possible values:
                ┌────────────────────┬──────────────────────┬────────────────────────┬──────────────┐
                │ Value              │ Security Level       │ Link Key Type          │ Encryption   │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_SDP</b>    │ 0 (SDP Only)         │ None                   │ Not required │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_LOW</b>    │ 1 (Low)              │ Unauthenticated        │ Not required │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_MEDIUM</b> │ 2 (Medium - default) │ Unauthenticated        │ Desired      │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_HIGH</b>   │ 3 (High)             │ Authenticated          │ Required     │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_FIPS</b>   │ 4 (Secure Only)      │ Authenticated   (P-256 │ Required     │
                │ (since Linux 3.15) │                      │ based  Secure   Simple │              │
                │                    │                      │ Pairing   and   Secure │              │
                │                    │                      │ Authentication)        │              │
                └────────────────────┴──────────────────────┴────────────────────────┴──────────────┘

       Example:

          int level = BT_SECURITY_HIGH;
          int err = setsockopt(sco_socket, SOL_BLUETOOTH, BT_SECURITY, &amp;level,
                               sizeof(level));
          if (err == -1) {
              perror("setsockopt");
              return 1;
          }

   <b>BT_DEFER_SETUP</b> <b>(since</b> <b>Linux</b> <b>2.6.30)</b>
       Channel defer connection setup, this control if the  connection  procedure  needs  to  be  authorized  by
       userspace before responding which allows authorization at profile level, possible values:
                                    ┌───────┬───────────────────┬───────────────┐
                                    │ Value │ Description       │ Authorization │
                                    ├───────┼───────────────────┼───────────────┤
                                    │ <b>0</b>     │ Disable (default) │ Not required  │
                                    ├───────┼───────────────────┼───────────────┤
                                    │ <b>1</b>     │ Enable            │ Required      │
                                    └───────┴───────────────────┴───────────────┘

       Example:

          int defer_setup = 1;
          int err = setsockopt(sco_socket, SOL_BLUETOOTH, BT_DEFER_SETUP,
                               &amp;defer_setup, sizeof(defer_setup));
          if (err == -1) {
              perror("setsockopt");
              return err;
          }

          err = listen(sco_socket, 5);
          if (err) {
              perror("listen");
              return err;
          }

          struct sockaddr_sco remote_addr = {0};
          socklen_t addr_len = sizeof(remote_addr);
          int new_socket = accept(sco_socket, (struct sockaddr*)&amp;remote_addr,
                                  &amp;addr_len);
          if (new_socket &lt; 0) {
              perror("accept");
              return new_socket;
          }

          /* To complete the connection setup of new_socket read 1 byte */
          char c;
          struct pollfd pfd;

          memset(&amp;pfd, 0, sizeof(pfd));
          pfd.fd = new_socket;
          pfd.events = POLLOUT;

          err = poll(&amp;pfd, 1, 0);
          if (err) {
              perror("poll");
              return err;
          }

          if (!(pfd.revents &amp; POLLOUT)) {
              err = read(sk, &amp;c, 1);
              if (err &lt; 0) {
                  perror("read");
                  return err;
              }
          }

   <b>BT_VOICE</b> <b>(since</b> <b>Linux</b> <b>3.11)</b>
       Transport voice settings, possible values:

          struct bt_voice {
              uint16_t setting;
          };
                        ┌────────────────────────────┬────────┬──────────────────────────────┐
                        │ Define                     │ Value  │ Description                  │
                        ├────────────────────────────┼────────┼──────────────────────────────┤
                        │ <b>BT_VOICE_TRANSPARENT</b>       │ 0x0003 │ Transparent output           │
                        ├────────────────────────────┼────────┼──────────────────────────────┤
                        │ <b>BT_VOICE_CVSD_16BIT</b>        │ 0x0060 │ C-VSD   output   PCM  16-bit │
                        │                            │        │ input                        │
                        ├────────────────────────────┼────────┼──────────────────────────────┤
                        │ <b>BT_VOICE_TRANSPARENT_16BIT</b> │ 0x0063 │ Transparent    output    PCM │
                        │                            │        │ 16-bit input                 │
                        └────────────────────────────┴────────┴──────────────────────────────┘

       Example:

          struct bt_voice voice;

          memset(&amp;voice, 0, sizeof(voice));
          voice.setting = BT_VOICE_TRANSPARENT;
          int err = setsockopt(sco_socket, SOL_BLUETOOTH, BT_VOICE, &amp;voice,
                               sizeof(voice));
          if (err == -1) {
              perror("setsockopt");
              return 1;
          }

   <b>BT_PHY</b> <b>(since</b> <b>Linux</b> <b>5.10)</b>
       Transport supported PHY(s), possible values:
                                   ┌────────────────────┬───────┬─────────────────┐
                                   │ Define             │ Value │ Description     │
                                   ├────────────────────┼───────┼─────────────────┤
                                   │ <b>BT_PHY_BR_1M_1SLOT</b> │ BIT 0 │ BR 1Mbps 1SLOT  │
                                   ├────────────────────┼───────┼─────────────────┤
                                   │ <b>BT_PHY_BR_1M_3SLOT</b> │ BIT 1 │ BR 1Mbps 3SLOT  │
                                   ├────────────────────┼───────┼─────────────────┤
                                   │ <b>BT_PHY_BR_2M_1SLOT</b> │ BIT 3 │ EDR 2Mbps 1SLOT │
                                   ├────────────────────┼───────┼─────────────────┤
                                   │ <b>BT_PHY_BR_2M_3SLOT</b> │ BIT 4 │ EDR 2Mbps 3SLOT │
                                   ├────────────────────┼───────┼─────────────────┤
                                   │ <b>BT_PHY_BR_3M_1SLOT</b> │ BIT 6 │ EDR 3Mbps 1SLOT │
                                   ├────────────────────┼───────┼─────────────────┤
                                   │ <b>BT_PHY_BR_3M_3SLOT</b> │ BIT 7 │ EDR 3Mbps 3SLOT │
                                   └────────────────────┴───────┴─────────────────┘

   <b>BT_CODEC</b> <b>(since</b> <b>Linux</b> <b>5.14)</b>
       Transport codec offload, possible values:

          struct bt_codec {
              uint8_t id;
              uint16_t cid;
              uint16_t vid;
              uint8_t data_path_id;
              uint8_t num_caps;
              struct codec_caps {
                  uint8_t len;
                  uint8_t data[];
              } caps[];
          } __attribute__((packed));

          struct bt_codecs {
              uint8_t num_codecs;
              struct bt_codec codecs[];
          } __attribute__((packed));

       Example:

          char buffer[sizeof(struct bt_codecs) + sizeof(struct bt_codec)];
          struct bt_codec *codecs = (void *)buffer;

          memset(codecs, 0, sizeof(codecs));
          codec-&gt;num_codecs = 1;
          codecs-&gt;codecs[0].id = 0x05;
          codecs-&gt;codecs[0].data_path_id = 1;

          int err = setsockopt(sco_socket, SOL_BLUETOOTH, BT_CODEC, codecs,
                               sizeof(buffer));
          if (err == -1) {
              perror("setsockopt");
              return 1;
          }

</pre><h4><b>RESOURCES</b></h4><pre>
        &lt;<a href="http://www.bluez.org">http://www.bluez.org</a>&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
        &lt;<a href="mailto:linux-bluetooth@vger.kernel.org">linux-bluetooth@vger.kernel.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man7/socket.7.html">socket</a>(7), <a href="../man1/scotest.1.html">scotest</a>(1)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Free use of this software is granted under the terms of the GNU Lesser General Public Licenses (LGPL).

BlueZ                                              March 2025                                             <u><a href="../man7/SCO.7.html">SCO</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>