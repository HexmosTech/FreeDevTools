<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ecm-find-modules - ECM Find Modules Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/extra-cmake-modules">extra-cmake-modules_6.17.0-0ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ecm-find-modules - ECM Find Modules Reference

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Find  modules are used by the CMake <b>find_package</b> command to search for packages that do not provide their
       own CMake package config files. CMake provides an extensive set of find modules, and Extra CMake  Modules
       (ECM) adds to that.

       To  use  ECM’s  find  modules,  you  need  to  tell  CMake  to  find the ECM package, and then add either
       <b>${ECM_MODULE_PATH}</b> or <b>${ECM_FIND_MODULE_DIR}</b> to the <b>CMAKE_MODULE_PATH</b> variable:

          find_package(ECM REQUIRED NO_MODULE)
          set(CMAKE_MODULE_PATH ${ECM_FIND_MODULE_DIR})

       Using <b>${ECM_MODULE_PATH}</b> will also make the modules intended for direct use by  CMake  scripts  available
       (see <u><a href="../man7/ecm-modules.7.html">ecm-modules</a>(7)</u> and <u><a href="../man7/ecm-kde-modules.7.html">ecm-kde-modules</a>(7)</u>).

       You   can  also  make  local  copies  of  find  modules  using  the  <b>ecm_use_find_modules</b>  function  from
       <u>ECMUseFindModules</u>, which is automatically included when ECM is found:

          find_package(ECM REQUIRED NO_MODULE)
          ecm_use_find_modules(
              DIR "${CMAKE_BINARY_DIR}/cmake"
              MODULES FindEGL.cmake
          )
          set(CMAKE_MODULE_PATH "${CMAKE_BINARY_DIR}/cmake")

       This allows selective use of ECM’s find modules, and the NO_OVERRIDE argument can be used to ensure  that
       if CMake ships its own version of that find module, it will be used instead.

</pre><h4><b>ALL</b> <b>FIND</b> <b>MODULES</b></h4><pre>
   <b>Find7Zip</b>
       Try to find 7-Zip.

       If  the  7-Zip  executable is not in your PATH, you can provide an alternative name or full path location
       with the <b>7Zip_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>7Zip_FOUND</b>
              TRUE if 7-Zip is available

       <b>7Zip_EXECUTABLE</b>
              Path to 7-Zip executable

       If <b>7Zip_FOUND</b> is TRUE, it will also define the following imported target:

       <b>7Zip::7Zip</b>
              Path to 7-Zip executable

       <b>NOTE:</b>
          It will see to only find the original 7-Zip, not one of the  p7zip forks.

       Since 5.113.0.

   <b>Find7z</b>
       Try to find 7z.

       If the 7z executable is not in your PATH, you can provide an alternative name or full path location  with
       the <b>7z_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>7z_FOUND</b>
              TRUE if 7z is available

       <b>7z_EXECUTABLE</b>
              Path to 7z executable

       If <b>7z_FOUND</b> is TRUE, it will also define the following imported target:

       <b>7z::7z</b> Path to 7z executable

       <b>NOTE:</b>
          Only works on Windows.

       Deprecated: since 5.113, use  <u>Find7Zip</u>.

       Since 5.85.0.

   <b>FindCanberra</b>
       Try to find Canberra event sound library.

       This will define the following variables:

       <b>Canberra_FOUND</b>
              True if (the requested version of) Canberra is available

       <b>Canberra_VERSION</b>
              The version of Canberra

       <b>Canberra_LIBRARIES</b>
              The libraries of Canberra for use with target_link_libraries()

       <b>Canberra_INCLUDE_DIRS</b>
              The include dirs of Canberra for use with target_include_directories()

       If <b>Canberra_FOUND</b> is TRUE, it will also define the following imported target:

       <b>Canberra::Canberra</b>
              The Canberra library

       In  general  we recommend using the imported target, as it is easier to use.  Bear in mind, however, that
       if the target is in the link interface of an exported library, it must be made available by  the  package
       config file.

       Since 5.56.0.

   <b>FindEGL</b>
       Try to find EGL.

       This will define the following variables:

       <b>EGL_FOUND</b>
              True if (the requested version of) EGL is available

       <b>EGL_VERSION</b>
              The  version  of  EGL;  note  that this is the API version defined in the headers, rather than the
              version of the implementation (eg: Mesa)

       <b>EGL_LIBRARIES</b>
              This can be passed to target_link_libraries() instead of the <b>EGL::EGL</b> target

       <b>EGL_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the target is not used for linking

       <b>EGL_DEFINITIONS</b>
              This should be passed to target_compile_options() if the target is not used for linking

       If <b>EGL_FOUND</b> is TRUE, it will also define the following imported target:

       <b>EGL::EGL</b>
              The EGL library

       In general we recommend using the imported target, as it is easier to use.  Bear in mind,  however,  that
       if  the  target is in the link interface of an exported library, it must be made available by the package
       config file.

       Since pre-1.0.0.

   <b>FindGLIB2</b>
       Try to locate the GLib2 library.  If found, this will define the following variables:

       <b>GLIB2_FOUND</b>
              True if the GLib2 library is available

       <b>GLIB2_INCLUDE_DIRS</b>
              The GLib2 include directories

       <b>GLIB2_LIBRARIES</b>
              The GLib2 libraries for linking

       <b>GLIB2_INCLUDE_DIR</b>
              Deprecated, use <b>GLIB2_INCLUDE_DIRS</b>

       <b>GLIB2_LIBRARY</b>
              Deprecated, use <b>GLIB2_LIBRARIES</b>

       If <b>GLIB2_FOUND</b> is TRUE, it will also define the following imported target:

       <b>GLIB2::GLIB2</b>
              The GLIB2 library

       <b>GLIB2::GTHREAD2</b>
              The GThread2 library (since 6.7.0)

       <b>GLIB2::GOBJECT</b>
              The GObject library (since 6.7.0)

       <b>GLIB2::GIO</b>
              The GIO library (since 6.7.0)

       Since 5.41.0.

   <b>FindGperf</b>
       Try to find GNU gperf.

       If the gperf executable is not in your PATH, you can provide an alternative name or  full  path  location
       with the <b>Gperf_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>Gperf_FOUND</b>
              True if gperf is available.

       <b>Gperf_EXECUTABLE</b>
              The gperf executable.

       <b>Gperf_VERSION</b>
              The gperf version. (since 5.85)

       If <b>Gperf_FOUND</b> is TRUE, it will also define the following imported target:

       <b>GPerf::Gperf</b>
              The gperf executable.

       and the following public function:

          ecm_gperf_generate(&lt;GperfInput&gt; &lt;OutputFile&gt; &lt;OutputVariable(|target (since 5.83))&gt;
                             [GENERATION_FLAGS &lt;flags&gt;])

       Run  <b>gperf</b>  on  <b>&lt;GperfInput&gt;</b>  to  generate <b>&lt;OutputFile&gt;</b>, adding it to the <b>&lt;OutputVariable&gt;</b> variable which
       contains the source for the target where <b>&lt;OutputFile&gt;</b> is going to be built or,  since  KF  5.83,  if  the
       given  argument  is  a  target,  to the list of private sources of that target. The target must not be an
       alias. The optional <b>GENERATION_FLAGS</b> argument is needed to pass  extra  parameters  to  <b>gperf</b>  (note  you
       cannot override that way the output file).

       A simple invocation would be:

          ecm_gperf_generate(simple.gperf ${CMAKE_CURRENT_BINARY_DIR}/simple.h MySources)

       Since 5.35.0.

   <b>FindGradle</b>
       Provides the ability to build Android AAR libraries using Gradle.

       This relies on the Qt provided Gradle, so a Qt for Android installation is required.

          gradle_add_aar(&lt;target&gt;
                         BUIDLFILE build.gradle
                         NAME &lt;aar-name&gt;)

       This builds an Android AAR library using the given <b>build.gradle</b> file.

          gradle_install_aar(&lt;target&gt;
                             DESTINATION &lt;dest&gt;)

       Installs a Android AAR library that has been created with <b>gradle_add_aar</b>.

       Since 5.76.0.

   <b>FindIcoTool</b>
       Try to find icotool.

       If  the icotool executable is not in your PATH, you can provide an alternative name or full path location
       with the <b>IcoTool_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>IcoTool_FOUND</b>
              True if icotool is available.

       <b>IcoTool_EXECUTABLE</b>
              The icotool executable.

       If <b>IcoTool_FOUND</b> is TRUE, it will also define the following imported target:

       <b>IcoTool::IcoTool</b>
              The icotool executable.

       Since 5.49.

   <b>FindInotify</b>
       <b>Try</b> <b>to</b> <b>find</b> <b>inotify</b> <b>on</b> <b>this</b> <b>system.</b> <b>This</b> <b>finds:</b>

              • libinotify on Unix like systems, or

              • the kernel’s inotify on Linux systems.

       This will define the following variables:

       <b>Inotify_FOUND</b>
              True if inotify is available

       <b>Inotify_LIBRARIES</b>
              This has to be passed to target_link_libraries()

       <b>Inotify_INCLUDE_DIRS</b>
              This has to be passed to target_include_directories()

       On Linux and SunOS, the libraries and include directories are empty, even though <b>Inotify_FOUND</b> may be set
       to TRUE. This is because no special includes or libraries are needed.  On  other  systems  these  may  be
       needed to use inotify.

       Since 5.32.0.

   <b>FindIsoCodes</b>
       Try to find iso-codes data files.  Once done this will define:

       <b>IsoCodes_FOUND</b>
              Whether the system has iso-codes

       <b>IsoCodes_PREFIX</b>
              The location in which the iso-codes data files are found

       <b>IsoCodes_DOMAINS</b>
              The available domains provided by iso-codes

       Since 5.80.0.

   <b>FindKF5</b>
       Find KDE Frameworks 5 with a single find_package() call.

       This  will  use the package config files provided by the individual frameworks.  For example, if you wish
       to find KArchive, which presents itself to CMake as KF5Archive (ie: you would do <b>find_package(KF5Archive)</b>
       to find it directly), you can do

          find_package(KF5 COMPONENTS Archive)

       If all the required components (those given in the COMPONENTS  argument,  but  not  those  given  in  the
       OPTIONAL_COMPONENTS  argument)  are  found,  <b>KF5_FOUND</b>  will be set to true. Otherwise, it will be set to
       false.

       Since pre-1.0.0.

   <b>FindLibExiv2</b>
       Try to find the Exiv2 library.

       This will define the following variables:

       <b>LibExiv2_FOUND</b>
              True if (the requested version of) Exiv2 is available

       <b>LibExiv2_VERSION</b>
              The version of Exiv2

       <b>LibExiv2_INCLUDE_DIRS</b>
              The include dirs of Exiv2 for use with target_include_directories()

       <b>LibExiv2_LIBRARIES</b>
              The  Exiv2  library   for   use   with   target_link_libraries().    This   can   be   passed   to
              target_link_libraries() instead of the <b>LibExiv2::LibExiv2</b> target

       If <b>LibExiv2_FOUND</b> is TRUE, it will also define the following imported target:

       <b>LibExiv2::LibExiv2</b>
              The Exiv2 library

       In  general  we recommend using the imported target, as it is easier to use.  Bear in mind, however, that
       if the target is in the link interface of an exported library, it must be made available by  the  package
       config file.

       Since 5.53.0.

   <b>FindLibGit2</b>
       Try to find libgit2 on a Unix system.

       This will define the following variables:

       <b>LIBGIT2_FOUND</b>
              True if (the requested version of) libgit2 is available

       <b>LIBGIT2_VERSION</b>
              The version of libgit2

       <b>LIBGIT2_LIBRARIES</b>
              This can be passed to target_link_libraries() instead of the <b>LibGit2::LibGit2</b> target

       <b>LIBGIT2_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the target is not used for linking

       <b>LIBGIT2_DEFINITIONS</b>
              This should be passed to target_compile_options() if the target is not used for linking

       If <b>LIBGIT2_FOUND</b> is TRUE, it will also define the following imported target:

       <b>LibGit2::LibGit2</b>
              The libgit2 library

       In  general  we recommend using the imported target, as it is easier to use.  Bear in mind, however, that
       if the target is in the link interface of an exported library, it must be made available by  the  package
       config file.

       Since 1.3.0.

   <b>FindLibMount</b>
       Try to find the libmount library (part of util-linux), once done this will define:

       <b>LibMount_FOUND</b>
              LibMount was found on the system.

       <b>LibMount_INCLUDE_DIRS</b>
              The libmount include directory.

       <b>LibMount_LIBRARIES</b>
              The libmount libraries.

       <b>LibMount_VERSION</b>
              The libmount version.

       If <b>LibMount_FOUND</b> is TRUE, it will also define the following imported target:

       <b>LibMount::LibMount</b>
              The libmount library

       Since 5.83.0

   <b>FindLibcap</b>
       Try to find the setcap binary and cap libraries

       This will define:

       <b>Libcap_FOUND</b>
              system has the cap library and setcap binary

       <b>Libcap_LIBRARIES</b>
              cap libraries to link against

       <b>SETCAP_EXECUTABLE</b>
              path of the setcap binary

       <b>In</b> <b>addition,</b> <b>the</b> <b>following</b> <b>targets</b> <b>are</b> <b>defined:</b>
              <b>Libcap::SetCapabilities</b>

       Since 5.80.0

   <b>FindOpenEXR</b>
       Try to find the OpenEXR libraries.

       This will define the following variables:

       <b>OpenEXR_FOUND</b>
              True if OpenEXR is available

       <b>OpenEXR_LIBRARIES</b>
              Link to these to use OpenEXR

       <b>OpenEXR_INCLUDE_DIRS</b>
              Include directory for OpenEXR

       <b>OpenEXR_DEFINITIONS</b>
              Compiler flags required to link against OpenEXR

       and the following imported targets:

       <b>OpenEXR::IlmImf</b>
              The OpenEXR core library

       In  general  we recommend using the imported target, as it is easier to use.  Bear in mind, however, that
       if the target is in the link interface of an exported library, it must be made available by  the  package
       config file.

       Since pre-1.0.0.

   <b>FindPhoneNumber</b>
       Try to find PhoneNumber.

       This  is  a  component-based  find  module,  which  makes  use  of the COMPONENTS and OPTIONAL_COMPONENTS
       arguments to find_module.  The following components are available:

          PhoneNumber  GeoCoding

       If no components  are  specified,  this  module  will  act  as  though  all  components  were  passed  to
       OPTIONAL_COMPONENTS.

       This module will define the following variables, independently of the components searched for or found:

       <b>PhoneNumber_FOUND</b>
              True if (the requestion version of) PhoneNumber is available

       For  each searched-for components, <b>PhoneNumber_&lt;component&gt;_FOUND</b> will be set to TRUE if the corresponding
       library was found, and FALSE otherwise.  If <b>PhoneNumber_&lt;component&gt;_FOUND</b> is TRUE,  the  imported  target
       <b>PhoneNumber::&lt;component&gt;</b> will be defined.

       Since 5.54.0.

   <b>FindPoppler</b>
       Try to find Poppler.

       This  is  a  component-based  find  module,  which  makes  use  of the COMPONENTS and OPTIONAL_COMPONENTS
       arguments to find_module.  The following components are available:

          Core  Cpp  Qt5  Qt4  Glib

       If no components  are  specified,  this  module  will  act  as  though  all  components  were  passed  to
       OPTIONAL_COMPONENTS.

       This module will define the following variables, independently of the components searched for or found:

       <b>Poppler_FOUND</b>
              TRUE if (the requested version of) Poppler is available

       <b>Poppler_VERSION</b>
              Found Poppler version

       <b>Poppler_TARGETS</b>
              A  list  of  all  targets imported by this module (note that there may be more than the components
              that were requested)

       <b>Poppler_LIBRARIES</b>
              This can be passed to target_link_libraries() instead of the imported targets

       <b>Poppler_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the targets are not used for linking

       <b>Poppler_DEFINITIONS</b>
              This should be passed to target_compile_options() if the targets are not used for linking

       For each searched-for components, <b>Poppler_&lt;component&gt;_FOUND</b> will be set  to  TRUE  if  the  corresponding
       Poppler  library  was  found,  and  FALSE  otherwise.  If <b>Poppler_&lt;component&gt;_FOUND</b> is TRUE, the imported
       target  <b>Poppler::&lt;component&gt;</b>  will  be  defined.   This   module   will   also   attempt   to   determine
       <b>Poppler_*_VERSION</b>  variables  for  each  imported  target,  although  <b>Poppler_VERSION</b>  should normally be
       sufficient.

       In general we recommend using the imported targets, as they are easier to use and provide  more  control.
       Bear  in  mind,  however,  that if any target is in the link interface of an exported library, it must be
       made available by the package config file.

       Since 5.19

   <b>FindPulseAudio</b>
       Try to locate the PulseAudio library.  If found, this will define the following variables:

       <b>PulseAudio_FOUND</b>
              True if the system has the PulseAudio library of at least the minimum version specified by  either
              the version parameter to find_package() or the variable PulseAudio_MINIMUM_VERSION

       <b>PulseAudio_INCLUDE_DIRS</b>
              The PulseAudio include directory

       <b>PulseAudio_LIBRARIES</b>
              The PulseAudio libraries for linking

       <b>PulseAudio_MAINLOOP_LIBRARY</b>
              The libraries needed to use PulseAudio Mainloop

       <b>PulseAudio_VERSION</b>
              The version of PulseAudio that was found

       <b>PulseAudio_INCLUDE_DIR</b>
              Deprecated, use <b>PulseAudio_INCLUDE_DIRS</b>

       <b>PulseAudio_LIBRARY</b>
              Deprecated, use <b>PulseAudio_LIBRARIES</b>

       If <b>PulseAudio_FOUND</b> is TRUE, it will also define the following imported target:

       <b>PulseAudio::PulseAudio</b>
              The PulseAudio library

       Since 5.41.0.

   <b>FindQtWaylandScanner</b>
       Try to find qtwaylandscanner.

       If  the qtwaylandscanner executable is not in your PATH, you can provide an alternative name or full path
       location with the <b>QtWaylandScanner_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>QtWaylandScanner_FOUND</b>
              True if qtwaylandscanner is available

       <b>QtWaylandScanner_EXECUTABLE</b>
              The qtwaylandscanner executable.

       If <b>QtWaylandScanner_FOUND</b> is TRUE, it will also define the following imported target:

       <b>Wayland::QtScanner</b>
              The qtwaylandscanner executable.

       This module provides the following functions to generate C++ protocol implementations:

          • <b>ecm_add_qtwayland_client_protocol</b>

          • <b>ecm_add_qtwayland_server_protocol</b>

          ecm_add_qtwayland_client_protocol(&lt;target&gt;
                                            PROTOCOL &lt;xmlfile&gt;
                                            BASENAME &lt;basename&gt;
                                            [PREFIX &lt;prefix&gt;]
                                            [PRIVATE_CODE])

          ecm_add_qtwayland_client_protocol(&lt;source_files_var&gt;
                                            PROTOCOL &lt;xmlfile&gt;
                                            BASENAME &lt;basename&gt;
                                            [PREFIX &lt;prefix&gt;]
                                            [PRIVATE_CODE])

       Generate C++ wrapper to Wayland client protocol files from <b>&lt;xmlfile&gt;</b> XML definition  for  the  <b>&lt;basename&gt;</b>
       interface  and  append  those files to <b>&lt;source_files_var&gt;</b> or <b>&lt;target&gt;</b>.  Pass the <b>&lt;prefix&gt;</b> argument if the
       interface names don’t start with <b>qt_</b> or <b>wl_</b>.  <b>PRIVATE_CODE</b> instructs wayland-scanner to hide  marshalling
       code from the compiled DSO for use in other DSOs. The default is to export this code.

       WaylandScanner is required and will be searched for.

          ecm_add_qtwayland_server_protocol(&lt;target&gt;
                                            PROTOCOL &lt;xmlfile&gt;
                                            BASENAME &lt;basename&gt;
                                            [PREFIX &lt;prefix&gt;]
                                            [PRIVATE_CODE])

          ecm_add_qtwayland_server_protocol(&lt;source_files_var&gt;
                                            PROTOCOL &lt;xmlfile&gt;
                                            BASENAME &lt;basename&gt;
                                            [PREFIX &lt;prefix&gt;]
                                            [PRIVATE_CODE])

       Generate  C++  wrapper  to Wayland server protocol files from <b>&lt;xmlfile&gt;</b> XML definition for the <b>&lt;basename&gt;</b>
       interface and append those files to <b>&lt;source_files_var&gt;</b> or <b>&lt;target&gt;</b>.  Pass the <b>&lt;prefix&gt;</b>  argument  if  the
       interface  names don’t start with <b>qt_</b> or <b>wl_</b>.  <b>PRIVATE_CODE</b> instructs wayland-scanner to hide marshalling
       code from the compiled DSO for use in other DSOs. The default is to export this code.

       WaylandScanner is required and will be searched for.

       Since 1.4.0.

   <b>FindSasl2</b>
       Try to find the SASL2 library.

       This will define the following variables:

       <b>Sasl2_FOUND</b>
              System has SASL2.

       <b>Sasl2_VERSION</b>
              The version of SASL2.

       <b>Sasl2_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the target is not used for linking.

       <b>Sasl2_LIBRARIES</b>
              The SASL2 library.  This can be passed to  target_link_libraries()  instead  of  the  <b>Sasl2::Sasl2</b>
              target

       If <b>Sasl2_FOUND</b> is TRUE, the following imported target will be available:

       <b>Sasl2::Sasl2</b>
              The SASL2 library

       Since 5.41.0.

   <b>FindSeccomp</b>
       Try to locate the libseccomp library.

       This will define the following variables:

       <b>Seccomp_FOUND</b>
              True if the seccomp library is available

       <b>Seccomp_INCLUDE_DIRS</b>
              The seccomp include directories

       <b>Seccomp_LIBRARIES</b>
              The seccomp libraries for linking

       If <b>Seccomp_FOUND</b> is TRUE, it will also define the following imported target:

       <b>Seccomp::Seccomp</b>
              The Seccomp library

       Since 5.44.0.

   <b>FindSharedMimeInfo</b>
       Try to find the shared-mime-info package.

       This will define the following variables:

       <b>SharedMimeInfo_FOUND</b>
              True if system has the shared-mime-info package

       <b>UPDATE_MIME_DATABASE_EXECUTABLE</b>
              The update-mime-database executable

       and the following imported targets:

       <b>SharedMimeInfo::UpdateMimeDatabase</b>
              The update-mime-database executable

       The follow macro is available:

          update_xdg_mimetypes(&lt;path&gt;)

       Updates  the XDG mime database at install time (unless the <b>$DESTDIR</b> environment variable is set, in which
       case it is up to package managers to perform this task).

       Since pre-1.0.0.

   <b>FindTaglib</b>
       Try to find the Taglib library.

       This will define the following variables:

       <b>Taglib_FOUND</b>
              True if the system has the taglib library of at least the minimum version specified by the version
              parameter to find_package()

       <b>Taglib_INCLUDE_DIRS</b>
              The taglib include dirs for use with target_include_directories

       <b>Taglib_LIBRARIES</b>
              The taglib libraries for use with target_link_libraries()

       <b>Taglib_VERSION</b>
              The version of taglib that was found

       If <b>Taglib_FOUND</b> is TRUE, it will also define the following imported target:

       <b>Taglib::Taglib</b>
              The Taglib library

       Since 5.72.0

   <b>FindUDev</b>
       Try to find the UDev library.

       This will define the following variables:

       <b>UDev_FOUND</b>
              System has UDev.

       <b>UDev_INCLUDE_DIRS</b>
              The libudev include directory.

       <b>UDev_LIBRARIES</b>
              The libudev libraries.

       <b>UDev_VERSION</b>
              The libudev version.

       If <b>UDev_FOUND</b> is TRUE, it will also define the following imported target:

       <b>UDev::UDev</b>
              The UDev library

       Since 5.57.0.

   <b>FindWayland</b>
       Try to find Wayland.

       This is a component-based find  module,  which  makes  use  of  the  COMPONENTS  and  OPTIONAL_COMPONENTS
       arguments to find_module.  The following components are available:

          Client  Server  Cursor  Egl

       If  no  components  are  specified,  this  module  will  act  as  though  all  components  were passed to
       OPTIONAL_COMPONENTS.

       This module will define the following variables, independently of the components searched for or found:

       <b>Wayland_FOUND</b>
              TRUE if (the requested version of) Wayland is available

       <b>Wayland_VERSION</b>
              Found Wayland version

       <b>Wayland_TARGETS</b>
              A list of all targets imported by this module (note that there may be  more  than  the  components
              that were requested)

       <b>Wayland_LIBRARIES</b>
              This can be passed to target_link_libraries() instead of the imported targets

       <b>Wayland_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the targets are not used for linking

       <b>Wayland_DEFINITIONS</b>
              This should be passed to target_compile_options() if the targets are not used for linking

       <b>Wayland_DATADIR</b>
              The core wayland protocols data directory Since 5.73.0

       For  each  searched-for  components,  <b>Wayland_&lt;component&gt;_FOUND</b>  will be set to TRUE if the corresponding
       Wayland library was found, and FALSE otherwise.   If  <b>Wayland_&lt;component&gt;_FOUND</b>  is  TRUE,  the  imported
       target   <b>Wayland::&lt;component&gt;</b>   will   be   defined.    This   module  will  also  attempt  to  determine
       <b>Wayland_*_VERSION</b> variables for  each  imported  target,  although  <b>Wayland_VERSION</b>  should  normally  be
       sufficient.

       In  general  we recommend using the imported targets, as they are easier to use and provide more control.
       Bear in mind, however, that if any target is in the link interface of an exported  library,  it  must  be
       made available by the package config file.

       Since pre-1.0.0.

   <b>FindWaylandProtocols</b>
       Try to find wayland-protocols on a Unix system.

       This will define the following variables:

       <b>WaylandProtocols_FOUND</b>
              True if (the requested version of) wayland-protocols is available

       <b>WaylandProtocols_VERSION</b>
              The version of wayland-protocols

       <b>WaylandProtocols_DATADIR</b>
              The wayland protocols data directory

   <b>FindWaylandScanner</b>
       Try to find wayland-scanner.

       If  the  wayland-scanner executable is not in your PATH, you can provide an alternative name or full path
       location with the <b>WaylandScanner_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>WaylandScanner_FOUND</b>
              True if wayland-scanner is available.

       <b>WaylandScanner_EXECUTABLE</b>
              The wayland-scanner executable.

       If <b>WaylandScanner_FOUND</b> is TRUE, it will also define the following imported target:

       <b>Wayland::Scanner</b>
              The wayland-scanner executable.

       This module provides the following functions to generate C protocol implementations:

          • <b>ecm_add_wayland_client_protocol</b>

          • <b>ecm_add_wayland_server_protocol</b>

          ecm_add_wayland_client_protocol(&lt;target&gt;
                                          PROTOCOL &lt;xmlfile&gt;
                                          BASENAME &lt;basename&gt;
                                          [PRIVATE_CODE])

          ecm_add_wayland_client_protocol(&lt;source_files_var&gt;
                                          PROTOCOL &lt;xmlfile&gt;
                                          BASENAME &lt;basename&gt;
                                          [PRIVATE_CODE])

       Generate Wayland client protocol files from <b>&lt;xmlfile&gt;</b> XML definition for  the  <b>&lt;basename&gt;</b>  interface  and
       append those files to <b>&lt;source_files_var&gt;</b> or <b>&lt;target&gt;</b>.

       <b>PRIVATE_CODE</b>  instructs  wayland-scanner  to hide marshalling code from the compiled DSO for use in other
       DSOs. The default is to export this code.

          ecm_add_wayland_server_protocol(&lt;target&gt;
                                          PROTOCOL &lt;xmlfile&gt;
                                          BASENAME &lt;basename&gt;
                                          [PRIVATE_CODE])

          ecm_add_wayland_server_protocol(&lt;source_files_var&gt;
                                          PROTOCOL &lt;xmlfile&gt;
                                          BASENAME &lt;basename&gt;
                                          [PRIVATE_CODE])

       Generate Wayland server protocol files from <b>&lt;xmlfile&gt;</b> XML definition for  the  <b>&lt;basename&gt;</b>  interface  and
       append those files to <b>&lt;source_files_var&gt;</b> or <b>&lt;target&gt;</b>.

       <b>PRIVATE_CODE</b>  instructs  wayland-scanner  to hide marshalling code from the compiled DSO for use in other
       DSOs. The default is to export this code.

       Since 1.4.0.

   <b>FindX11_XCB</b>
       Try to find the X11 XCB compatibility library.

       This will define the following variables:

       <b>X11_XCB_FOUND</b>
              True if (the requested version of) libX11-xcb is available

       <b>X11_XCB_VERSION</b>
              The version of libX11-xcb (this is not guaranteed to be set even when X11_XCB_FOUND is true)

       <b>X11_XCB_LIBRARIES</b>
              This can be passed to target_link_libraries() instead of the <b>EGL::EGL</b> target

       <b>X11_XCB_INCLUDE_DIR</b>
              This should be passed to target_include_directories() if the target is not used for linking

       <b>X11_XCB_DEFINITIONS</b>
              This should be passed to target_compile_options() if the target is not used for linking

       If <b>X11_XCB_FOUND</b> is TRUE, it will also define the following imported target:

       <b>X11::XCB</b>
              The X11 XCB compatibility library

       In general we recommend using the imported target, as it is easier to use.  Bear in mind,  however,  that
       if  the  target is in the link interface of an exported library, it must be made available by the package
       config file.

       Since pre-1.0.0.

   <b>FindXCB</b>
       Try to find XCB.

       This is a component-based find  module,  which  makes  use  of  the  COMPONENTS  and  OPTIONAL_COMPONENTS
       arguments to find_module.  The following components are available:

          XCB
          ATOM         AUX          COMPOSITE    CURSOR       DAMAGE
          DPMS         DRI2         DRI3         EVENT        EWMH
          GLX          ICCCM        IMAGE        KEYSYMS      PRESENT
          RANDR        RECORD       RENDER       RENDERUTIL   RES
          SCREENSAVER  SHAPE        SHM          SYNC         UTIL
          XF86DRI      XFIXES       XINERAMA     XINPUT       XKB
          XTEST        XV           XVMC

       If  no  components  are  specified,  this  module  will  act  as  though  all  components  were passed to
       OPTIONAL_COMPONENTS. Before 5.82 this excluded XINPUT. Since 5.82 all components are searched for.

       This module will define the following variables, independently of the components searched for or found:

       <b>XCB_FOUND</b>
              True if (the requestion version of) xcb is available

       <b>XCB_VERSION</b>
              Found xcb version

       <b>XCB_TARGETS</b>
              A list of all targets imported by this module (note that there may be  more  than  the  components
              that were requested)

       <b>XCB_LIBRARIES</b>
              This can be passed to target_link_libraries() instead of the imported targets

       <b>XCB_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the targets are not used for linking

       <b>XCB_DEFINITIONS</b>
              This should be passed to target_compile_options() if the targets are not used for linking

       For  each  searched-for  components,  <b>XCB_&lt;component&gt;_FOUND</b>  will be set to true if the corresponding xcb
       library was  found,  and  false  otherwise.   If  <b>XCB_&lt;component&gt;_FOUND</b>  is  true,  the  imported  target
       <b>XCB::&lt;component&gt;</b> will be defined.  This module will also attempt to determine <b>XCB_*_VERSION</b> variables for
       each imported target, although <b>XCB_VERSION</b> should normally be sufficient.

       In  general  we recommend using the imported targets, as they are easier to use and provide more control.
       Bear in mind, however, that if any target is in the link interface of an exported  library,  it  must  be
       made available by the package config file.

       Since pre-1.0.0.

   <b>Findepoxy</b>
       Try to find libepoxy on a Unix system.

       This will define the following variables:

       <b>epoxy_FOUND</b>
              True if (the requested version of) libepoxy is available

       <b>epoxy_VERSION</b>
              The version of libepoxy

       <b>epoxy_LIBRARIES</b>
              This should be passed to target_link_libraries() if the target is not used for linking

       <b>epoxy_INCLUDE_DIRS</b>
              This should be passed to target_include_directories() if the target is not used for linking

       <b>epoxy_DEFINITIONS</b>
              This should be passed to target_compile_options() if the target is not used for linking

       <b>epoxy_HAS_GLX</b>
              True if GLX support is available

       If <b>epoxy_FOUND</b> is TRUE, it will also define the following imported target:

       <b>epoxy::epoxy</b>
              The epoxy library

       In  general  we recommend using the imported target, as it is easier to use.  Bear in mind, however, that
       if the target is in the link interface of an exported library, it must be made available by  the  package
       config file.

   <b>Findgzip</b>
       Try to find gzip.

       If  the  gzip  executable  is not in your PATH, you can provide an alternative name or full path location
       with the <b>gzip_EXECUTABLE</b> variable.

       This will define the following variables:

       <b>gzip_FOUND</b>
              TRUE if gzip is available

       <b>gzip_EXECUTABLE</b>
              Path to gzip executable

       If <b>gzip_FOUND</b> is TRUE, it will also define the following imported target:

       <b>gzip::gzip</b>
              Path to gzip executable

       Since 5.85.0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man7/ecm.7.html">ecm</a>(7)</u>, <u><a href="../man7/ecm-modules.7.html">ecm-modules</a>(7)</u>, <u><a href="../man7/ecm-kde-modules.7.html">ecm-kde-modules</a>(7)</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       KDE Developers

6.17                                              Aug 08, 2025                               <u><a href="../man7/ECM-FIND-MODULES.7.html">ECM-FIND-MODULES</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>