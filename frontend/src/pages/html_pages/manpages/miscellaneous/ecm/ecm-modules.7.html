<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ecm-modules - ECM Modules Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/extra-cmake-modules">extra-cmake-modules_6.17.0-0ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ecm-modules - ECM Modules Reference

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Extra  CMake  Modules (ECM) provides various modules that provide useful functions for CMake scripts. ECM
       actually provides three types of modules that can be used from  CMake  scripts:  those  that  extend  the
       functionality  of  the  <b>find_package</b>  command  are  documented in <u><a href="../man7/ecm-find-modules.7.html">ecm-find-modules</a>(7)</u>; those that provide
       standard settings for software produced by the KDE community are documented in  <u><a href="../man7/ecm-kde-modules.7.html">ecm-kde-modules</a>(7)</u>.   The
       rest provide macros and functions for general use by CMake scripts and are documented here.

       To  use  these  modules,  you  need  to  tell  CMake  to  find  the  ECM  package,  and  then  add either
       <b>${ECM_MODULE_PATH}</b> or <b>${ECM_MODULE_DIR}</b> to the <b>CMAKE_MODULE_PATH</b> variable:

          find_package(ECM REQUIRED NO_MODULE)
          set(CMAKE_MODULE_PATH ${ECM_MODULE_DIR})

       Using <b>${ECM_MODULE_PATH}</b> will also make the find modules and KDE modules available.

       Note that there are also toolchain modules, documented in <u><a href="../man7/ecm-toolchains.7.html">ecm-toolchains</a>(7)</u>, but these are used by  users
       building the software rather than developers writing CMake scripts.

</pre><h4><b>ALL</b> <b>MODULES</b></h4><pre>
   <b>CheckAtomic</b>
       Check if the compiler supports std:atomic out of the box or if libatomic is needed for atomic support. If
       it  is  needed  libatomicis  added  to <b>CMAKE_REQUIRED_LIBRARIES</b>. So after running CheckAtomic you can use
       std:atomic.

       Since 5.75.0.

   <b>ECMAddAndroidApk</b>
       Functions for creating Android APK packages using Qt6’s <b>androiddeployqt</b> tool as well  as  the  associated
       Fastlane metadata.

          ecm_add_android_apk(&lt;target&gt;
              [ANDROID_DIR &lt;dir&gt;]
              [PACKAGE_NAME &lt;name&gt;]
              # TODO extra args?
          )

       Creates an Android APK for the given target.

       If  <b>ANDROID_DIR</b> is given, the Android manifest file as well as any potential Gradle build system files or
       Java/Kotlin source files are taken from that directory.  If not set, the standard template  shipped  with
       Qt6 is used, which in usually not what you want for production applications.

       If  <b>PACKAGE_NAME</b>  is given, it is used as name for the Android APK.  If not set, the <b>target</b> name is used.
       Since 6.10.0

       The use of this function creates a build target called <b>create-apk-&lt;target&gt;</b> which will run <b>androiddeployqt</b>
       to produce an (unsigned) APK, as well as convert Appstream application metadata  (if  present)  into  the
       Fastlane format used by F-Droid and Play store automation.

       There’s also a <b>create-apk</b> convenience target being created that will build all APKs defined in a project.

       When building for another platform than Android, this function does nothing.

       The following variables impact the behavior: <b>ECM_ADDITIONAL_FIND_ROOT_PATH</b>
          See documentation in the Android toolchain file.

       <b>ECM_APK_STAGING_ROOT_PATH</b>
              For use with Craft’s image directory. If set this is used as the source for all content of the APK
              rather  than  the  search paths used for building.  This allows to separate e.g. development files
              from what ends up in the APK.

       Since 6.0.0

       For automatically deriving APK versions from CMake this creates a <b>ecm-version.gradle</b> file  which  defines
       the  following variables: <b>ecmVersionName</b>: Set to <b>PROJECT_VERSION</b> <b>ecmVersionCode</b>: Derived from the current
       time in local builds, and from <b>CI_PIPELINE_CREATED_AT</b>
          in builds from Gitlab  pipelines.  This  ensures  a  strictly  increasing  version  code  as  well  as
          synchronized version codes for APKs of multiple architectures when build in a Gitlab pipeline.

       This  can  be  included by calling <b>apply</b> <b>from:</b> <b>'../ecm-version.gradle'</b> in the project’s <b>build.gradle</b> file
       and is typically used in manifest placeholders:

       ``
       ` defaultConfig {
          versionName   ecmVersionName   versionCode   ecmVersionCode   manifestPlaceholders   =   [versionName:
          ecmVersionName, versionCode: ecmVersionCode] …

   <b>}</b>
       Since 6.12.0

   <b>ECMAddAppIcon</b>
       Add icons to executable files and packages.

          ecm_add_app_icon(&lt;sources_var_name(|target (since 5.83))&gt;
                           ICONS &lt;icon&gt; [&lt;icon&gt; [...]]
                           [SIDEBAR_ICONS &lt;icon&gt; [&lt;icon&gt; [...]] # Since 5.49
                           [OUTFILE_BASENAME &lt;name&gt;]) # Since 5.49
                           )

       The given icons, whose names must match the pattern:

          &lt;size&gt;-&lt;other_text&gt;.png

       will  be added as platform-specific application icons to the variable named <b>&lt;sources_var_name&gt;</b> or, if the
       first argument is a target (since 5.83), to the <b>SOURCES</b> property of <b>&lt;target&gt;</b>.  Any target must be created
       with add_executable() and not be an alias.

       Other icon files are ignored but on macOS SVG files can be supported and it is thus possible to mix those
       with png files in a single macro call.

       The platforms currently supported are Windows and macOS, on all others the call  has  no  effect  and  is
       ignored.

       <b>&lt;size&gt;</b>  is  a  numeric  pixel size (typically 16, 32, 48, 64, 128 or 256).  <b>&lt;other_text&gt;</b> can be any other
       text. See the platform notes below for any recommendations about icon sizes.

       <b>SIDEBAR_ICONS</b> can be used to add macOS sidebar icons to the generated  iconset.  They  are  used  when  a
       folder monitored by the application is dragged into Finder’s sidebar. Since 5.49.

       <b>OUTFILE_BASENAME</b> will be used as the basename for the icon file. If you specify it, the icon file will be
       called  <b>&lt;OUTFILE_BASENAME&gt;.icns</b>  on macOS and <b>&lt;OUTFILE_BASENAME&gt;.ico</b> on Windows. If you don’t specify it,
       it defaults to <b>&lt;sources_var_name&gt;.&lt;ext&gt;</b>. Since 5.49.

       <b>Windows</b> <b>notes</b>

              • Icons are compiled into the executable using a resource file.

              • Icons may not show  up  in  Windows  Explorer  if  the  executable  target  does  not  have  the
                <b>WIN32_EXECUTABLE</b> property set.

              • Icotool (see <u>FindIcoTool</u>) is required.

              • Supported sizes: 16, 24, 32, 48, 64, 128, 256, 512 and 1024.

       <b>macOS</b> <b>notes</b>

              • The executable target must have the <b>MACOSX_BUNDLE</b> property set.

              • Icons are added to the bundle.

              • If  the  ksvg2icns  tool  from  KIconThemes is available, .svg and .svgz files are accepted; the
                first that is converted successfully to .icns will provide the application icon. SVG  files  are
                ignored otherwise.

              • The tool iconutil (provided by Apple) is required for bitmap icons.

              • Supported sizes: 16, 32, 64, 128, 256 (and 512, 1024 after OS X 10.9).

              • At least a 128x128px (or an SVG) icon is required.

              • Larger   sizes   are   automatically   used   to   substitute  for  smaller  sizes  on  “Retina”
                (high-resolution) displays. For example, a 32px icon, if provided, will be used as a  32px  icon
                on  standard-resolution  displays,  and  as  a  16px-equivalent  icon  (with  an  “@2x”  tag) on
                high-resolution displays. That is why you should provide 64px and 1024px icons although they are
                not supported anymore directly. Instead they will be used as <u>32px@2x</u> and  <u>512px@2x</u>.  If  an  SVG
                icon  is  provided,  ksvg2icns will be used internally to automatically generate all appropriate
                sizes, including the high-resolution ones.

              • This function sets the <b>MACOSX_BUNDLE_ICON_FILE</b> variable to the name of the generated icns  file,
                so  that  it  will  be  used  as  the  <b>MACOSX_BUNDLE_ICON_FILE</b>  target  property  when  you call
                <b>add_executable</b>.

              • Sidebar icons should typically provided in 16, 32, 64, 128 and 256px.

       Since 1.7.0.

   <b>ECMAddQch</b>
       This module provides the <b>ecm_add_qch</b> function for generating API documentation files in the  QCH  format,
       and  the  <b>ecm_install_qch_export</b>  function  for generating and installing exported CMake targets for such
       generated QCH files to enable builds of other software with generation of QCH files to create links  into
       the given QCH files.

          ecm_add_qch(&lt;target_name&gt;
              NAME &lt;name&gt;
              VERSION &lt;version&gt;
              QCH_INSTALL_DESTINATION &lt;qchfile_install_path&gt;
              TAGFILE_INSTALL_DESTINATION &lt;tagsfile_install_path&gt;
              [COMPONENT &lt;component&gt;]
              [BASE_NAME &lt;basename&gt;]
              [SOURCE_DIRS &lt;dir&gt; [&lt;dir2&gt; [...]]]
              [SOURCES &lt;file&gt; [&lt;file2&gt; [...]]]
              |MD_MAINPAGE &lt;md_file&gt;]
              [INCLUDE_DIRS &lt;incdir&gt; [&lt;incdir2&gt; [...]]]
              [IMAGE_DIRS &lt;idir&gt; [&lt;idir2&gt; [...]]]
              [EXAMPLE_DIRS &lt;edir&gt; [&lt;edir2&gt; [...]]]
              [ORG_DOMAIN &lt;domain&gt;]
              [NAMESPACE &lt;namespace&gt;]
              [LINK_QCHS &lt;qch&gt; [&lt;qch2&gt; [...]]]
              [PREDEFINED_MACROS &lt;macro[=content]&gt; [&lt;macro2[=content]&gt; [...]]]
              [BLANK_MACROS &lt;macro&gt; [&lt;macro2&gt; [...]]]
              [CONFIG_TEMPLATE &lt;configtemplate_file&gt;]
              [VERBOSE]
          )

       This  macro adds a target called &lt;target_name&gt; for the creation of an API documentation manual in the QCH
       format from the given sources.  It currently uses doxygen, future versions might  optionally  also  allow
       other  tools.   Next  to  the  QCH  file the target will generate a corresponding doxygen tag file, which
       enables creating links from other documentation into the generated QCH file.

       It is recommended to make the use of this macro optional, by depending the call to <b>ecm_add_qch</b> on a CMake
       option being set, with a name like <b>BUILD_QCH</b> and being <b>TRUE</b> by default. This will allow the developers to
       saves resources on normal source development build cycles by setting this option to FALSE.

       The macro  will  set  the  target  properties  <b>DOXYGEN_TAGFILE</b>,  <b>QHP_NAMESPACE</b>,  <b>QHP_NAMESPACE_VERSIONED</b>,
       <b>QHP_VIRTUALFOLDER</b>  and  <b>LINK_QCHS</b>  to the respective values, to allow other code access to them, e.g. the
       macro <b>ecm_install_qch_export</b>.  To enable the use of the target &lt;target_name&gt; as  item  for  <b>LINK_QCHS</b>  in
       further  <b>ecm_add_qch</b>  calls in the current build, additionally a target property <b>DOXYGEN_TAGFILE_BUILD</b> is
       set, with the path of the created doxygen tag file in the build dir.  If existing, <b>ecm_add_qch</b>  will  use
       this property instead of <b>DOXYGEN_TAGFILE</b> for access to the tags file.

       <b>NAME</b> specifies the name for the generated documentation.

       <b>VERSION</b> specifies the version of the library for which the documentation is created.

       <b>BASE_NAME</b> specifies the base name for the generated files.  The default basename is <b>&lt;name&gt;</b>.

       <b>SOURCE_DIRS</b>  specifies  the  dirs  (incl.  subdirs) with the source files for which the API documentation
       should be generated.  Dirs can be relative to the current source dir. Dependencies to the  files  in  the
       dirs are not tracked currently, other than with the <b>SOURCES</b> argument. So do not use for sources generated
       during the build.  Needs to be used when <b>SOURCES</b> or <b>CONFIG_TEMPLATE</b> are not used.

       <b>SOURCES</b> specifies the source files for which the API documentation should be generated.  Needs to be used
       when <b>SOURCE_DIRS</b> or <b>CONFIG_TEMPLATE</b> are not used.

       <b>MD_MAINPAGE</b> specifies a file in Markdown format that should be used as main page. This page will overrule
       any <b>\mainpage</b> command in the included sources.

       <b>INCLUDE_DIRS</b>  specifies  the  dirs which should be searched for included headers. Dirs can be relative to
       the current source dir. Since 5.63.

       <b>IMAGE_DIRS</b> specifies the dirs which contain images that are included in the documentation.  Dirs  can  be
       relative to the current source dir.

       <b>EXAMPLE_DIRS</b>  specifies  the dirs which contain examples that are included in the documentation. Dirs can
       be relative to the current source dir.

       <b>QCH_INSTALL_DESTINATION</b> specifies where the generated QCH file will be installed.

       <b>TAGFILE_INSTALL_DESTINATION</b> specifies where the generated tag file will be installed.

       <b>COMPONENT</b> specifies the installation component name with which the install rules for  the  generated  QCH
       file and tag file are associated.

       <b>NAMESPACE</b>  can be used to set a custom namespace &lt;namespace&gt; of the generated QCH file. The namepspace is
       used as the unique id by QHelpEngine  (cmp.   <u>https://doc.qt.io/qt-5/qthelpproject.html#namespace</u>).   The
       default namespace is <b>&lt;domain&gt;.&lt;name&gt;</b>.  Needs to be used when <b>ORG_DOMAIN</b> is not used.

       <b>ORG_DOMAIN</b>  can  be  used  to  define  the  organization  domain  prefix for the default namespace of the
       generated QCH file.  Needs to be used when <b>NAMESPACE</b> is not used.

       <b>LINK_QCHS</b> specifies a list of other QCH targets which should be  used  for  creating  references  to  API
       documentation  of  code in external libraries.  For each target &lt;qch&gt; in the list these target properties
       are expected to be defined: <b>DOXYGEN_TAGFILE</b>, <b>QHP_NAMESPACE</b> and <b>QHP_VIRTUALFOLDER</b>.  If any of these is not
       existing, &lt;qch&gt; will be ignored.  Use the macro <b>ecm_install_qch_export</b> for exporting a target with  these
       properties  with  the  CMake config of a library.  Any target &lt;qch&gt; can also be one created before in the
       same buildsystem by another call of <b>ecm_add_qch</b>.

       <b>PREDEFINED_MACROS</b> specifies a list of C/C++ macros which should be  handled  as  given  by  the  API  dox
       generation  tool.   Examples are macros only defined in generated files, so whose definition might be not
       available to the tool.

       <b>BLANK_MACROS</b> specifies a list of C/C++ macro names which should be ignored by the API dox generation tool
       and handled as if they resolve to empty strings.  Examples are export macros only  defined  in  generated
       files, so whose definition might be not available to the tool.

       <b>CONFIG_TEMPLATE</b> specifies a custom cmake template file for the config file that is created to control the
       execution  of  the  API  dox  generation  tool.   The  following  CMake  variables  need  to  be  used: -
       <b>ECM_QCH_DOXYGEN_QHELPGENERATOR_EXECUTABLE</b>   -   <b>ECM_QCH_DOXYGEN_FILEPATH,</b>   <b>ECM_QCH_DOXYGEN_TAGFILE</b>   The
       following  CMake  variables can be used: - <b>ECM_QCH_DOXYGEN_PROJECTNAME</b> - <b>ECM_QCH_DOXYGEN_PROJECTVERSION</b> -
       <b>ECM_QCH_DOXYGEN_VIRTUALFOLDER</b>    -    <b>ECM_QCH_DOXYGEN_FULLNAMESPACE</b>    -    <b>ECM_QCH_DOXYGEN_TAGFILES</b>    -
       <b>ECM_QCH_DOXYGEN_WARN_LOGFILE</b> - <b>ECM_QCH_DOXYGEN_QUIET</b> There is no guarantue that the other CMake variables
       currently used in the default config file template will also be present with the same semantics in future
       versions of this macro.

       <b>VERBOSE</b> tells the API dox generation tool to be more verbose about its activity.

       The  default  config  file  for  the  API dox generation tool, so the one when not using <b>CONFIG_TEMPLATE</b>,
       allows code to handle the case of being processed by the tool by defining the  C/C++  preprocessor  macro
       <b>K_DOXYGEN</b>    when    run    (since    v5.67.0).    For   backward-compatibility   also   the   definition
       <b>DOXYGEN_SHOULD_SKIP_THIS</b> is set, but its usage is deprecated.

       Example usage:

          ecm_add_qch(
              MyLib_QCH
              NAME MyLib
              VERSION "0.42.0"
              ORG_DOMAIN org.myorg
              SOURCE_DIRS
                  src
              LINK_QCHS
                  Qt5Core_QCH
                  Qt5Xml_QCH
                  Qt5Gui_QCH
                  Qt5Widgets_QCH
              BLANK_MACROS
                  MyLib_EXPORT
                  MyLib_DEPRECATED
              TAGFILE_INSTALL_DESTINATION ${CMAKE_INSTALL_PREFIX}/share/docs/tags
              QCH_INSTALL_DESTINATION ${CMAKE_INSTALL_PREFIX}/share/docs/qch
              COMPONENT Devel
          )

       Example usage (with two QCH files, second linking first):

          ecm_add_qch(
              MyLib_QCH
              NAME MyLib
              VERSION ${MyLib_VERSION}
              ORG_DOMAIN org.myorg
              SOURCES ${MyLib_PUBLIC_HEADERS}
              MD_MAINPAGE src/mylib/README.md
              LINK_QCHS Qt5Core_QCH
              TAGFILE_INSTALL_DESTINATION ${CMAKE_INSTALL_PREFIX}/share/docs/tags
              QCH_INSTALL_DESTINATION ${CMAKE_INSTALL_PREFIX}/share/docs/qch
              COMPONENT Devel
          )
          ecm_add_qch(
              MyOtherLib_QCH
              NAME MyOtherLib
              VERSION ${MyOtherLib_VERSION}
              ORG_DOMAIN org.myorg
              SOURCES ${MyOtherLib_PUBLIC_HEADERS}
              MD_MAINPAGE src/myotherlib/README.md
              LINK_QCHS Qt5Core_QCH MyLib_QCH
              TAGFILE_INSTALL_DESTINATION ${CMAKE_INSTALL_PREFIX}/share/docs/tags
              QCH_INSTALL_DESTINATION ${CMAKE_INSTALL_PREFIX}/share/docs/qch
              COMPONENT Devel
          )

          ecm_install_qch_export(
              TARGETS [&lt;name&gt; [&lt;name2&gt; [...]]]
              FILE &lt;file&gt;
              DESTINATION &lt;dest&gt;
              [COMPONENT &lt;component&gt;]
          )

       This macro creates and installs a CMake file &lt;file&gt; which exports the given QCH targets &lt;name&gt;  etc.,  so
       they  can  be  picked  up  by  CMake-based  builds  of other software that also generate QCH files (using
       <b>ecm_add_qch</b>) and which should include links to the QCH files created by the given targets.  The installed
       CMake file &lt;file&gt; is expected to be included by the CMake  config  file  created  for  the  software  the
       related QCH files are documenting.

       <b>TARGETS</b>  specifies  the QCH targets which should be exported. If a target does not exist or does not have
       all needed properties, a warning will be generated and the target skipped.  This behaviour  might  change
       in future versions to result in a fail instead.

       <b>FILE</b> specifies the name of the created CMake file, typically with a .cmake extension.

       <b>DESTINATION</b>  specifies  the directory on disk to which the file will be installed. It usually is the same
       as the one where the CMake config files for this software are installed.

       <b>COMPONENT</b> specifies the installation component name with which the install rule is associated.

       Example usage:

          ecm_install_qch_export(
              TARGETS MyLib_QCH
              FILE MyLibQCHTargets.cmake
              DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/cmake/MyLib"
              COMPONENT Devel
          )

       Since 5.36.0.

   <b>ECMAddQtDesignerPlugin</b>
       This module provides the <b>ecm_add_qtdesignerplugin</b> function for generating Qt Designer plugins for  custom
       widgets. Each of those widgets is described using a second function <b>ecm_qtdesignerplugin_widget</b>.

          ecm_add_qtdesignerplugin(&lt;target_name&gt;
              NAME &lt;name&gt;
              WIDGETS &lt;widgetid&gt; [&lt;widgetid2&gt; [...]]
              LINK_LIBRARIES &lt;lib&gt; [&lt;lib2&gt; [...]]
              INSTALL_DESTINATION &lt;install_path&gt;
              [OUTPUT_NAME &lt;output_name&gt;]
              [DEFAULT_GROUP &lt;group&gt;]
              [DEFAULT_HEADER_CASE &lt;SAME_CASE|LOWER_CASE|UPPER_CASE&gt;]
              [DEFAULT_HEADER_EXTENSION &lt;header_extension&gt;]
              [DEFAULT_ICON_DIR &lt;icon_dir&gt;]
              [INCLUDE_FILES &lt;include_file&gt; [&lt;include_file2&gt; [...]]]
              [SOURCES &lt;src&gt; [&lt;src2&gt; [...]]]
              [COMPONENT &lt;component&gt;]
          )

       <b>NAME</b> specifies the base name to use in the generated sources.  The default is &lt;target_name&gt;.

       <b>WIDGETS</b>  specifies  the widgets the plugin should support. Each widget has to be defined before by a call
       of <b>ecm_qtdesignerplugin_widget</b> with the respective &lt;widgetid&gt;, in a scope including the current call.

       <b>LINK_LIBRARIES</b> specifies the libraries to link against. This will be at least the library  providing  the
       widget class(es).

       <b>INSTALL_DESTINATION</b> specifies where the generated plugin binary will be installed.

       <b>OUTPUT_NAME</b> specifies the name of the plugin binary. The default is “&lt;target_name&gt;”.

       <b>DEFAULT_GROUP</b> specifies the default group in Qt Designer where the widgets will be placed. The default is
       “Custom”.

       <b>DEFAULT_HEADER_CASE</b>  specifies  how  the  name  of the header is derived from the widget class name.  The
       default is “LOWER_CASE”.

       <b>DEFAULT_HEADER_EXTENSION</b> specifies what file name extension is used for the header file derived from  the
       class name.  The default is “h”.

       <b>DEFAULT_ICON_DIR</b>  specifies  what  file name extension is used for the header file derived from the class
       name.  The default is “pics”.

       <b>INCLUDE_FILES</b> specifies additional include files to include with the generated source file. This  can  be
       needed for custom code used in initializing or creating widgets.

       <b>SOURCES</b> specifies additional source files to build the plugin from.  This can be needed to support custom
       code used in initializing or creating widgets.

       <b>COMPONENT</b> specifies the installation component name with which the install rules for the generated plugin
       are associated.

          ecm_qtdesignerplugin_widget(&lt;widgetid&gt;
              [CLASS_NAME &lt;class_name&gt;]
              [INCLUDE_FILE &lt;include_file&gt;]
              [CONTAINER]
              [ICON &lt;iconfile&gt;]
              [TOOLTIP &lt;tooltip&gt;]
              [WHATSTHIS &lt;whatsthis&gt;]
              [GROUP &lt;group&gt;]
              [CREATE_WIDGET_CODE_FROM_VARIABLE &lt;create_widget_code_variable&gt;]
              [INITIALIZE_CODE_FROM_VARIABLE &lt;initialize_code_variable]
              [DOM_XML_FROM_VARIABLE &lt;dom_xml_variable&gt;]
              [IMPL_CLASS_NAME &lt;impl_class_name&gt;]
              [CONSTRUCTOR_ARGS_CODE &lt;constructor_args_code&gt;]
              [CONSTRUCTOR_ARGS_CODE_FROM_VARIABLE &lt;constructor_args_code_variable&gt;]
          )

       <b>CLASS_NAME</b> specifies the name of the widget class, including namespaces.  The default is “&lt;widgetid&gt;”.

       <b>INCLUDE_FILE</b>  specifies the include file to use for the class of this widget. The default is derived from
       &lt;class_name&gt; as configured by the <b>DEFAULT_HEADER_*</b> options of  <b>ecm_add_qtdesignerplugin</b>,  also  replacing
       any namespace separators with “/”.

       <b>CONTAINER</b> specifies, if set, that this widget is a container for other widgets.

       <b>ICON</b>  specifies  the  icon  file  to  use  as  symbol  for  this  widget.   The  default  is “{lowercased
       &lt;class_name&gt;}.png”  in  the  default  icons  dir  as  configured  by  the  <b>DEFAULT_ICON_DIR</b>   option   of
       <b>ecm_add_qtdesignerplugin</b>, if such a file exists.

       <b>TOOLTIP</b> specifies the tooltip text to use for this widget. Default is “&lt;class_name&gt; Widget”.

       <b>WHATSTHIS</b> specifies the What’s-This text to use for this widget.  Defaults to the tooltip.

       <b>GROUP</b>  specifies  the  group  in  Qt  Designer  where  the  widget will be placed.  The default is set as
       configured by the <b>DEFAULT_GROUP</b> option of <b>ecm_add_qtdesignerplugin</b>.

       <b>CREATE_WIDGET_CODE_FROM_VARIABLE</b> specifies the variable to get from the C++ code to use as  factory  code
       to      create      an      instance      of      the      widget,      for      the      override     of
       <b>QDesignerCustomWidgetInterface::createWidget(QWidget*</b>   <b>parent)</b>.    The   default    is    “return    new
       &lt;impl_class_name&gt;&lt;constructor_args_code&gt;;”.

       <b>INITIALIZE_CODE_FROM_VARIABLE</b> specifies the variable to get from the C++ code to use with the override of
       <b>QDesignerCustomWidgetInterface::initialize(QDesignerFormEditorInterface*</b>  <b>core)</b>.  The code has to use the
       present class member <b>m_initialized</b>  to  track  and  update  the  state.  The  default  code  simply  sets
       <b>m_initialized</b> to <b>true</b>, if it was not before.

       <b>DOM_XML_FROM_VARIABLE</b>  specifies the variable to get from the string to use with the optional override of
       <b>QDesignerCustomWidgetInterface::domXml()</b>.  Default does not override.

       <b>IMPL_CLASS_NAME</b> specifies the name of the widget class to use for the widget instance with  Qt  Designer.
       The default is “&lt;class_name&gt;”.

       <b>CONSTRUCTOR_ARGS_CODE</b>  specifies  the  C++  code to use for the constructor arguments with the default of
       <b>CREATE_WIDGET_CODE_FROM_VARIABLE</b>. Note that the parentheses are required. The default is “(parent)”.

       <b>CONSTRUCTOR_ARGS_CODE_FROM_VARIABLE</b> specifies the variable to get from the C++ code instead of passing it
       directly via <b>CONSTRUCTOR_ARGS_CODE</b>.  This can be needed if the code is more complex and e.g. includes “;”
       chars.

       Example usage:

          ecm_qtdesignerplugin_widget(FooWidget
              TOOLTIP "Enables to browse foo."
              GROUP "Views (Foo)"
          )

          set(BarWidget_CREATE_WIDGET_CODE
          "
              auto* widget = new BarWidget(parent);
              widget-&gt;setBar("Example bar");
              return widget;
          ")

          ecm_qtdesignerplugin_widget(BarWidget
              TOOLTIP "Displays bars."
              GROUP "Display (Foo)"
              CREATE_WIDGET_CODE_FROM_VARIABLE BarWidget_CREATE_WIDGET_CODE
          )

          ecm_add_qtdesignerplugin(foowidgets
              NAME FooWidgets
              OUTPUT_NAME foo2widgets
              WIDGETS
                  FooWidget
                  BarWidget
              LINK_LIBRARIES
                  Foo::Widgets
              INSTALL_DESTINATION "${KDE_INSTALL_QTPLUGINDIR}/designer"
              COMPONENT Devel
          )

       Since 5.62.0.

   <b>ECMAddTests</b>
       Convenience functions for adding tests.

          ecm_add_tests(&lt;sources&gt;
              [COMPILE_DEFINITIONS &lt;definition&gt; [&lt;definition&gt; [...]]] # Since 6.13.0
              [ENVIRONMENT &lt;list&gt;]  # Since 6.13.0
              LINK_LIBRARIES &lt;library&gt; [&lt;library&gt; [...]]
              [NAME_PREFIX &lt;prefix&gt;]
              [GUI]
              [TARGET_NAMES_VAR &lt;target_names_var&gt;]
              [TEST_NAMES_VAR &lt;test_names_var&gt;]
              [WORKING_DIRECTORY &lt;dir&gt;] #  Since 5.111
          )

       A convenience function for adding multiple tests, each consisting of a single source file. For each  file
       in  &lt;sources&gt;,  an executable target is created (whose name is the base name of the source file) with the
       compiler definitions passed with <b>COMPILE_DEFINITIONS</b>. This will be linked  against  the  libraries  given
       with  <b>LINK_LIBRARIES</b>.  Each  executable  will  be  added  as  a  test  with the same name and can have an
       environment provided by <b>ENVIRONMENT</b>.

       If <b>NAME_PREFIX</b> is given, this prefix will be prepended to the test names, but not the target names. As  a
       result,  it  will not prevent clashes between tests with the same name in different parts of the project,
       but it can be used to give an indication of where to look for a failing test.

       If the flag <b>GUI</b> is passed the test binaries will be GUI executables,  otherwise  the  resulting  binaries
       will  be console applications (regardless of the value of <b>CMAKE_WIN32_EXECUTABLE</b> or <b>CMAKE_MACOSX_BUNDLE</b>).
       Be aware that this changes the executable entry point on Windows (although some frameworks, such  as  Qt,
       abstract this difference away).

       The  tests  will  be  build  with <b>-DQT_FORCE_ASSERTS</b> to enable assertions in the test executable even for
       release builds.

       The <b>TARGET_NAMES_VAR</b> and <b>TEST_NAMES_VAR</b> arguments, if given, should specify a variable  name  to  receive
       the  list  of generated target and test names, respectively. This makes it convenient to apply properties
       to them as a whole, for example, using <b>set_target_properties()</b> or  <b>set_tests_properties()</b>.

       The generated target executables will have the effects  of  <b>ecm_mark_as_test()</b>  (from  the  <u>ECMMarkAsTest</u>
       module) applied to it.

       <b>WORKING_DIRECTORY</b>  sets  the test property <u>WORKING_DIRECTORY</u> in which to execute the test. By default the
       test will be run in <b>${CMAKE_CURRENT_BINARY_DIR}</b>. The working directory can be specified  using  generator
       expressions. Since 5.111.

          ecm_add_test(
              &lt;sources&gt;
              [COMPILE_DEFINITIONS &lt;definition&gt; [&lt;definition&gt; [...]]] # Since 6.13.0
              [ENVIRONMENT &lt;list&gt;]  # Since 6.13.0
              LINK_LIBRARIES &lt;library&gt; [&lt;library&gt; [...]]
              [TEST_NAME &lt;name&gt;]
              [NAME_PREFIX &lt;prefix&gt;]
              [GUI]
              [WORKING_DIRECTORY &lt;dir&gt;] #  Since 5.111
          )

       This  is  a  single-test  form of <b>ecm_add_tests</b> that allows multiple source files to be used for a single
       test. If using multiple source files, <b>TEST_NAME</b> must be given; this will be used for both the target  and
       test names (and, as with <b>ecm_add_tests()</b>, the <b>NAME_PREFIX</b> argument will be prepended to the test name).

       <b>WORKING_DIRECTORY</b>  sets  the test property <u>WORKING_DIRECTORY</u> in which to execute the test. By default the
       test will be run in <b>${CMAKE_CURRENT_BINARY_DIR}</b>. The working directory can be specified  using  generator
       expressions. Since 5.111.

       Since pre-1.0.0.

   <b>ECMCheckOutboundLicense</b>
       Assert  that  source  file  licenses  are compatible with a desired outbound license of a compiled binary
       artifact (e.g., library, plugin or application).

       This module provides the <b>ecm_check_outbound_license</b> function that generates unit tests for  checking  the
       compatibility of license statements.  The license statements in all tested files are required to be added
       by using the SPDX marker <b>SPDX-License-Identifier</b>.

       During the CMake configuration of the project, a temporary license bill of materials (BOM) in SPDX format
       is  generated  by  calling  the REUSE tool (see &lt;<u>https://reuse.software</u>&gt;). That BOM is parsed and license
       computations based on an internal compatibility matrix are performed.

       <b>Preconditions</b> <b>for</b> <b>using</b> <b>this</b> <b>module:</b>

              • All tested input source files must contain the SPDX-License-Identifier tag.

              • Python3 must be available.

              • The REUSE tool must be available, which generates the bill-of-materials by running <b>reuse</b> <b>spdx</b> on
                the tested directory.

       When this module is included, a <b>SKIP_LICENSE_TESTS</b> option is added (default <b>OFF</b>). Turning this option  on
       skips  the  generation of license tests, which might be convenient if licenses shall not be tested in all
       build configurations.

          ecm_check_outbound_license(LICENSES &lt;outbound-licenses&gt;
                                     FILES &lt;source-files&gt;
                                     [TEST_NAME &lt;name&gt;]
                                     [WILL_FAIL])

       This method adds a custom unit test to ensure the specified outbound license to be  compatible  with  the
       specified  license  headers.  Note  that  a  convenient way is to use the CMake <b>GLOB</b> argument of the <b>FILE</b>
       function.

       <b>LICENSES</b> <b>(List</b> <b>of</b> <b>one</b> <b>or</b> <b>multiple</b> <b>outbound</b> <b>license</b> <b>regarding</b> <b>which</b> <b>the</b> <b>compatibility</b> <b>of</b> <b>the</b> <b>source</b> <b>code</b>
       <b>files</b> <b>shall</b> <b>be</b> <b>tested.)</b>

              <b>Currently,</b> <b>the</b> <b>following</b> <b>values</b> <b>are</b> <b>supported</b> <b>(values</b> <b>are</b> <b>SPDX</b> <b>registry</b> <b>identifiers):</b>

                     • MIT

                     • BSD-2-Clause

                     • BSD-3-Clause

                     • LGPL-2.0-only

                     • LGPL-2.1-only

                     • LGPL-3.0-only

                     • GPL-2.0-only

                     • GPL-3.0-only

       <b>FILES:</b> <b>(List</b> <b>of</b> <b>source</b> <b>files</b> <b>that</b> <b>contain</b> <b>valid</b> <b>SPDX-License-Identifier</b> <b>markers.)</b>
              The paths can be relative to the CMake file that generates the test case or be absolute paths.

       <b>TEST_NAME</b> <b>(Optional</b> <b>parameter</b> <b>that</b> <b>defines</b> <b>the</b> <b>name</b> <b>of</b> <b>the</b> <b>generated</b> <b>test</b> <b>case.)</b>
              If no name is defined, the relative path to the test directory with appended license name is used.
              Every test has <b>licensecheck_</b> as prefix.

       <b>WILL_FAIL</b> <b>(Optional</b> <b>parameter</b> <b>that</b> <b>inverts</b> <b>the</b> <b>test</b> <b>result.</b> <b>This</b> <b>parameter</b> <b>is</b> <b>usually</b> <b>only)</b>
              used for tests of the module.

       Since 5.75.0

   <b>ECMConfiguredInstall</b>
       Takes a list of files, runs <b>configure_file</b> on each and installs the resultant  configured  files  in  the
       given location.

       Any  suffix  of  “.in”  in  the  passed  file  names will be stripped from the file name at the installed
       location.

          ecm_install_configured_files(
              INPUT &lt;file&gt; [&lt;file2&gt; [...]]
              DESTINATION &lt;INSTALL_DIRECTORY&gt;
              [COPYONLY]
              [ESCAPE_QUOTES]
              [@ONLY]
              [COMPONENT &lt;component&gt;])

       Example usage:

          ecm_install_configured_files(INPUT foo.txt.in DESTINATION ${KDE_INSTALL_DATADIR} @ONLY)

       This will install the file as foo.txt with any cmake variable replacements made into the data directory.

       Since 5.73.0.

   <b>ECMCoverageOption</b>
       Allow users to easily enable GCov code coverage support.

       Code coverage allows you to check how much of your codebase is covered by your tests. This  module  makes
       it easy to build with support for <u>GCov</u>.

       When  this  module  is  included,  a <b>BUILD_COVERAGE</b> option is added (default <b>OFF</b>). Turning this option on
       enables GCC’s coverage instrumentation, and links against <b>libgcov</b>.

       <b>NOTE:</b>
          This will probably break the build if you are not using GCC.

       Since 1.3.0.

   <b>ECMCreateQmFromPoFiles</b>
       <b>WARNING:</b>
          This module is deprecated and will be removed by ECM 1.0. Use <u>ECMPoQmTools</u> instead.

       Generate QTranslator (.qm) catalogs from Gettext (.po) catalogs.

          ecm_create_qm_from_po_files(PO_FILES &lt;file1&gt;... &lt;fileN&gt;
                                      [CATALOG_NAME &lt;catalog_name&gt;]
                                      [INSTALL_DESTINATION &lt;install_destination&gt;])

       Creates the necessary rules to compile .po files into .qm files, and install them.

       The .qm files are installed in <b>&lt;install_destination&gt;/&lt;lang&gt;/LC_MESSAGES</b>, where  &lt;install_destination&gt;  is
       the INSTALL_DESTINATION argument and &lt;lang&gt; is extracted from the “Language” field inside the .po file.

       INSTALL_DESTINATION    defaults    to    <b>${LOCALE_INSTALL_DIR}</b>    if    defined,    otherwise   it   uses
       <b>${CMAKE_INSTALL_LOCALEDIR}</b> if that is defined, otherwise it uses <b>share/locale</b>.

       CATALOG_NAME defines the name of the installed .qm  files.  If  set,  .qm  files  will  be  installed  as
       <b>&lt;catalog_name&gt;.qm</b>. If not set .qm files will be named after the name of their source .po file.

       Setting the catalog name is useful when all .po files for a target are kept in a single source directory.
       For example, the “mylib” probject might keep all its translations in a “po” directory, like this:

          po/
              es.po
              fr.po

       Without setting CATALOG_NAME, those .po will be turned into .qm and installed as:

          share/locale/fr/LC_MESSAGES/fr.qm
          share/locale/es/LC_MESSAGES/es.qm

       If CATALOG_NAME is set to “mylib”, they will be installed as:

          share/locale/fr/LC_MESSAGES/mylib.qm
          share/locale/es/LC_MESSAGES/mylib.qm

       Which is what the loader created by ecm_create_qm_loader() expects.

       ecm_create_qm_from_po_files()  creates  a “translation” target. This target builds all .po files into .qm
       files.

          ecm_create_qm_loader(&lt;source_files_var&gt; &lt;catalog_name&gt;)

       ecm_create_qm_loader() generates a C++ file  which  ensures  translations  are  automatically  loaded  at
       startup. The path of the .cpp file is appended to &lt;source_files_var&gt;.  Typical usage is like:

          set(mylib_SRCS foo.cpp bar.cpp)
          ecm_create_qm_loader(mylib_SRCS mylib)
          add_library(mylib ${mylib_SRCS})

       This  generates  a  C++  file  which  loads  “mylib.qm”  at  startup,  assuming  it has been installed by
       ecm_create_qm_from_po_files(), and compiles it into <b>mylib</b>.

       Since pre-1.0.0.

   <b>ECMDeprecationSettings</b>
       This module provides the <b>ecm_set_disabled_deprecation_versions</b> function setting the excluding  deprecated
       API for Qt and KF projects.

       This  method  expects  pairs  of  the  identifier  and  deprecation  version.  For the identifier <b>QT</b> this
       functions adds the definition <b>QT_DISABLE_DEPRECATED_BEFORE</b>  with  the  given  version  in  a  hexadecimal
       format.       Otherwise      the      name      for     the     definition     is     generated     using
       <b>${IDENTIFIER}_DISABLE_DEPRECATED_BEFORE_AND_AT</b>,  following  the  naming  of   the   generated   code   in
       <u>ECMGenerateExportHeader</u>.   The  version for the definition can be overwritten, by passing definition name
       and the deprecation version as a CMake definition. This allows one to exclude deprecations without having
       to edit the CMakeLists.txt file.

       This module provides the following function:

          ecm_set_disabled_deprecation_versions(
              [DISABLE_NEWER_WARNINGS] # since 5.96
              [&lt;identifier&gt; &lt;deprecation_version&gt;]
              [&lt;identifier2&gt; &lt;deprecation_version2&gt;]
          )

       <b>DISABLE_NEWER_WARNINGS</b> disables additionally the compiler warnings for API deprecated in  newer  versions
       of the same major version.

       Example usage:

          set(QT_MIN_VERSION "5.15.2")
          set(KF5_MIN_VERSION "5.90")

          ecm_set_disabled_deprecation_versions(
            QT ${QT_MIN_VERSION}
            KF ${KF5_MIN_VERSION}
            KCOREADDONS 5.89.0 # In case we depend on deprecated KCoreAddons API
          )

       Since 5.91

   <b>ECMEnableSanitizers</b>
       Enable compiler sanitizer flags.

       The following sanitizers are supported:

       • Address Sanitizer

       • Memory Sanitizer

       • Thread Sanitizer

       • Leak Sanitizer

       • Undefined Behaviour Sanitizer

       All of them are implemented in Clang, depending on your version, and there is an work in progress in GCC,
       where some of them are currently implemented.

       This  module  will check your current compiler version to see if it supports the sanitizers that you want
       to enable

   <b>Usage</b>
       Simply add:

          include(ECMEnableSanitizers)

       to your <b>CMakeLists.txt</b>. Note that this module is included in <u>KDECompilerSettings</u>, so projects using  that
       module do not need to also include this one.

       The  sanitizers  are  not enabled by default. Instead, you must set <b>ECM_ENABLE_SANITIZERS</b> (either in your
       <b>CMakeLists.txt</b> or on the command line) to a semicolon-separated list of sanitizers you  wish  to  enable.
       The options are:

       • address

       • memory

       • thread

       • leak

       • undefined

       • fuzzer

       The sanitizers “address”, “memory” and “thread” are mutually exclusive.  You cannot enable two of them in
       the same build.

       “leak” requires the  “address” sanitizer.

       <b>NOTE:</b>
          To  reduce  the  overhead  induced  by  the instrumentation of the sanitizers, it is advised to enable
          compiler optimizations (<b>-O1</b> or higher).

   <b>Example</b>
       This is an example of usage:

          mkdir build
          cd build
          cmake -DECM_ENABLE_SANITIZERS='address;leak;undefined' ..

       <b>NOTE:</b>
          Most of the sanitizers will require Clang. To enable it, use:

              -DCMAKE_CXX_COMPILER=clang++

       Since 1.3.0.

   <b>ECMFindModuleHelpers</b>
       Helper macros for find modules: <b>ecm_find_package_version_check()</b>, <b>ecm_find_package_parse_components()</b> and
       <b>ecm_find_package_handle_library_components()</b>.

          ecm_find_package_version_check(&lt;name&gt;)

       Prints warnings if the CMake version or the project’s required CMake version is older than that  required
       by extra-cmake-modules.

          ecm_find_package_parse_components(&lt;name&gt;
              RESULT_VAR &lt;variable&gt;
              KNOWN_COMPONENTS &lt;component1&gt; [&lt;component2&gt; [...]]
              [SKIP_DEPENDENCY_HANDLING])

       This  macro  will  populate  &lt;variable&gt;  with a list of components found in &lt;name&gt;_FIND_COMPONENTS, after
       checking that all those components are in  the  list  of  <b>KNOWN_COMPONENTS</b>;  if  there  are  any  unknown
       components,  it  will print an error or warning (depending on the value of &lt;name&gt;_FIND_REQUIRED) and call
       <b>return()</b>.

       The order of components in  &lt;variable&gt;  is  guaranteed  to  match  the  order  they  are  listed  in  the
       <b>KNOWN_COMPONENTS</b> argument.

       If <b>SKIP_DEPENDENCY_HANDLING</b> is not set, for each component the variable &lt;name&gt;_&lt;component&gt;_component_deps
       will  be  checked for dependent components.  If &lt;component&gt; is listed in &lt;name&gt;_FIND_COMPONENTS, then all
       its (transitive) dependencies will also be added to &lt;variable&gt;.

          ecm_find_package_handle_library_components(&lt;name&gt;
              COMPONENTS &lt;component&gt; [&lt;component&gt; [...]]
              [SKIP_DEPENDENCY_HANDLING])
              [SKIP_PKG_CONFIG])

       Creates an imported library target for each component.  The  operation  of  this  macro  depends  on  the
       presence of a number of CMake variables.

       The    &lt;name&gt;_&lt;component&gt;_lib    variable    should    contain    the   name   of   this   library,   and
       &lt;name&gt;_&lt;component&gt;_header variable should contain the name of a header file associated with it  (whatever
       relative path is normally passed to ‘#include’). &lt;name&gt;_&lt;component&gt;_header_subdir variable can be used to
       specify    which    subdirectory    of    the    include   path   the   headers   will   be   found   in.
       <b>ecm_find_package_components()</b>  will  then  search  for  the  library  and  include  directory   (creating
       appropriate cache variables) and create an imported library target named &lt;name&gt;::&lt;component&gt;.

       Additional variables can be used to provide additional information:

       If  <b>SKIP_PKG_CONFIG</b>,  the  &lt;name&gt;_&lt;component&gt;_pkg_config  variable  is  set, and pkg-config is found, the
       pkg-config module given by &lt;name&gt;_&lt;component&gt;_pkg_config will be searched for and used to help locate the
       library and header file.  It will also be used to set &lt;name&gt;_&lt;component&gt;_VERSION.

       Note that if version information is found via pkg-config, &lt;name&gt;_&lt;component&gt;_FIND_VERSION can be  set  to
       require a particular version for each component.

       If  <b>SKIP_DEPENDENCY_HANDLING</b> is not set, the <b>INTERFACE_LINK_LIBRARIES</b> property of the imported target for
       &lt;component&gt;  will  be  set  to  contain   the   imported   targets   for   the   components   listed   in
       &lt;name&gt;_&lt;component&gt;_component_deps.   &lt;component&gt;_FOUND will also be set to <b>FALSE</b> if any of the components
       in   &lt;name&gt;_&lt;component&gt;_component_deps   are   not   found.    This   requires    the    components    in
       &lt;name&gt;_&lt;component&gt;_component_deps to be listed before &lt;component&gt; in the <b>COMPONENTS</b> argument.

       The following variables will be set:

       <b>&lt;name&gt;_TARGETS</b>
              the imported targets

       <b>&lt;name&gt;_LIBRARIES</b>
              the found libraries

       <b>&lt;name&gt;_INCLUDE_DIRS</b>
              the combined required include directories for the components

       <b>&lt;name&gt;_DEFINITIONS</b>
              the “other” CFLAGS provided by pkg-config, if any

       <b>&lt;name&gt;_VERSION</b>
              the  value  of <b>&lt;name&gt;_&lt;component&gt;_VERSION</b> for the first component that has this variable set (note
              that components are searched for in the order they are passed to the macro),  although  if  it  is
              already set, it will not be altered

       <b>NOTE:</b>
          These  variables  are  never  cleared,  so  if  <b>ecm_find_package_handle_library_components()</b> is called
          multiple times with different components (typically because of  multiple  <b>find_package()</b>  calls)  then
          <b>&lt;name&gt;_TARGETS</b>, for example, will contain all the targets found in any call (although no duplicates).

       Since pre-1.0.0.

   <b>ECMFindQmlModule</b>
       Finds QML import modules to set them as runtime dependencies.

       Because  QML  modules  are  not  compile  time  requirements,  they  can be easy to miss by packagers and
       developers, causing QML apps to fail to display.  Use this  CMake  module  to  ensure  a  QML  module  is
       installed at compile time during CMake configuration.

       Internally, this CMake module looks for the qmldir and, if needed, uses qmlplugindump to find the plugins
       and set them up as runtime dependencies.

          ecm_find_qmlmodule(&lt;module_name&gt;
            &lt;version&gt; # Optional for Qt6 builds
            [REQUIRED] # Since 6.0
          )

       Usage example:

          ecm_find_qmlmodule(org.kde.kirigami 2.1)
          ecm_find_qmlmodule(org.kde.kirigami 2.1 REQUIRED) # CMake will fail if the required version is not found
          ecm_find_qmlmodule(org.kde.kirigami) # Find it without a given version
          ecm_find_qmlmodule(org.kde.kirigami REQUIRED) # CMake will fail if it is not found

       Since 5.38.0.

   <b>ECMGenerateDBusServiceFile</b>
       This  module  provides  the <b>ecm_generate_dbus_service_file</b> function for generating and installing a D-Bus
       service file.

          ecm_generate_dbus_service_file(
              NAME &lt;service name&gt;
              EXECUTABLE &lt;executable&gt;
              [SYSTEMD_SERVICE &lt;systemd service&gt;]
              DESTINATION &lt;install_path&gt;
              [RENAME &lt;dbus service filename&gt;] # Since 5.75
          )

       A D-Bus service file <b>&lt;service</b> <b>name&gt;.service</b> will be generated and installed in the relevant D-Bus  config
       location. This filename can be customized with RENAME.

       <b>&lt;executable&gt;</b>  must  be  an  absolute  path  to  the  installed  service  executable.  When  using it with
       <u>KDEInstallDirs</u> it needs to be the <b>_FULL_</b> variant of the path variable.

       <b>NOTE:</b>
          On Windows, the macro will only use the file name part of <b>&lt;executable&gt;</b> since D-Bus service executables
          are to be installed in the same directory as the D-Bus daemon.

       Optionally, a <b>&lt;systemd</b> <b>service&gt;</b> can be specified to launch the corresponding systemd service  instead  of
       the <b>&lt;executable&gt;</b> if the D-Bus daemon is started by systemd.

       Example usage:

          ecm_generate_dbus_service_file(
              NAME org.kde.kded5
              EXECUTABLE ${KDE_INSTALL_FULL_BINDIR}/kded5
              DESTINATION ${KDE_INSTALL_DBUSSERVICEDIR}
          )

          ecm_generate_dbus_service_file(
              NAME org.kde.kded5
              EXECUTABLE ${KDE_INSTALL_FULL_BINDIR}/kded5
              SYSTEMD_SERVICE plasma-kded.service
              DESTINATION ${KDE_INSTALL_DBUSSERVICEDIR}
              RENAME org.kde.daemon.service
          )

       Since 5.73.0.

   <b>ECMGenerateExportHeader</b>
       This  module  provides the <b>ecm_generate_export_header</b> function for generating export macros for libraries
       with version-based control over visibility of and compiler warnings for deprecated API  for  the  library
       user, as well as over excluding deprecated API and their implementation when building the library itself.

       For    preparing    some    values    useful    in    the   context   it   also   provides   a   function
       <b>ecm_export_header_format_version</b>.

          ecm_generate_export_header(&lt;library_target_name&gt;
              VERSION &lt;version&gt;
              [BASE_NAME &lt;base_name&gt;]
              [GROUP_BASE_NAME &lt;group_base_name&gt;]
              [EXPORT_MACRO_NAME &lt;export_macro_name&gt;]
              [EXPORT_FILE_NAME &lt;export_file_name&gt;]
              [DEPRECATED_MACRO_NAME &lt;deprecated_macro_name&gt;]
              [NO_EXPORT_MACRO_NAME &lt;no_export_macro_name&gt;]
              [INCLUDE_GUARD_NAME &lt;include_guard_name&gt;]
              [STATIC_DEFINE &lt;static_define&gt;]
              [PREFIX_NAME &lt;prefix_name&gt;]
              [DEPRECATED_BASE_VERSION &lt;deprecated_base_version&gt;]
              [DEPRECATION_VERSIONS &lt;deprecation_version&gt; [&lt;deprecation_version2&gt; [...]]]
              [EXCLUDE_DEPRECATED_BEFORE_AND_AT &lt;exclude_deprecated_before_and_at_version&gt;]
              [NO_BUILD_SET_DEPRECATED_WARNINGS_SINCE]
              [NO_DEFINITION_EXPORT_TO_BUILD_INTERFACE]
              [USE_VERSION_HEADER [&lt;version_file_name&gt;]] #  Since 5.106
              [VERSION_BASE_NAME &lt;version_base_name&gt;] #  Since 5.106
              [VERSION_MACRO_NAME &lt;version_macro_name&gt;] #  Since 5.106
              [CUSTOM_CONTENT_FROM_VARIABLE &lt;variable&gt;]
          )

       <b>VERSION</b> specifies the version of the library, given in the format “&lt;major&gt;.&lt;minor&gt;.&lt;patchlevel&gt;”.

       <b>GROUP_BASE_NAME</b> specifies the name to use for the macros defining library group default values.  If  set,
       this       will       generate       code       supporting      <b>&lt;group_base_name&gt;_NO_DEPRECATED_WARNINGS</b>,
       <b>&lt;group_base_name&gt;_DISABLE_DEPRECATED_BEFORE_AND_AT</b>,   <b>&lt;group_base_name&gt;_DEPRECATED_WARNINGS_SINCE</b>     and
       <b>&lt;group_base_name&gt;_NO_DEPRECATED</b> (see below).  If not set, the generated code will ignore any such macros.

       <b>DEPRECATED_BASE_VERSION</b>  specifies  the  default  version before and at which deprecated API is disabled.
       Possible values are “0”, “CURRENT” (which resolves to &lt;version&gt;) and  a  version  string  in  the  format
       “&lt;major&gt;.&lt;minor&gt;.&lt;patchlevel&gt;”.  The default is the value of “&lt;exclude_deprecated_before_and_at_version&gt;”
       if set, or “&lt;major&gt;.0.0”, with &lt;major&gt; taken from &lt;version&gt;.

       <b>DEPRECATION_VERSIONS</b> specifies versions in “&lt;major&gt;.&lt;minor&gt;” format in which API was declared deprecated.
       Any version used with the generated macro <b>&lt;prefix_name&gt;&lt;base_name&gt;_DEPRECATED_VERSION(major,</b> <b>minor,</b> <b>text)</b>
       or <b>&lt;prefix_name&gt;&lt;base_name&gt;_DEPRECATED_VERSION_BELATED(major,</b> <b>minor,</b> <b>textmajor,</b> <b>textminor,</b> <b>text)</b> needs to
       be listed here, otherwise the macro will fail to work.

       <b>EXCLUDE_DEPRECATED_BEFORE_AND_AT</b> specifies the version for which all API deprecated before and at  should
       be  excluded  from the build completely.  Possible values are “0” (default), “CURRENT” (which resolves to
       &lt;version&gt;) and a version string in the format “&lt;major&gt;.&lt;minor&gt;.&lt;patchlevel&gt;”.

       <b>NO_BUILD_SET_DEPRECATED_WARNINGS_SINCE</b>          specifies          that          the           definition
       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED_WARNINGS_SINCE</b>  will  not be set for the library inside its
       own build, and thus will be defined by either explicit definition in the build system configuration or by
       the default value mechanism (see below).  The default is that it is set for the  build,  to  the  version
       specified by <b>EXCLUDE_DEPRECATED_BEFORE_AND_AT</b>, so no deprecation warnings are done for any own deprecated
       API used in the library implementation itself.

       <b>NO_DEFINITION_EXPORT_TO_BUILD_INTERFACE</b>          specifies          that          the          definition
       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DISABLE_DEPRECATED_BEFORE_AND_AT</b>  will  not  be  set  in  the   public
       interface    of   the   library   inside   its   own   build,   and   the   same   for   the   definition
       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED_WARNINGS_SINCE</b>       (if       not       disabled        by
       <b>NO_BUILD_SET_DEPRECATED_WARNINGS_SINCE</b>  already).   The  default  is  that  they  are set, to the version
       specified  by  <b>EXCLUDE_DEPRECATED_BEFORE_AND_AT</b>,  so  e.g.  test  and  examples  part  of   the   project
       automatically  build  against the full API included in the build and without any deprecation warnings for
       it.

       <b>USE_VERSION_HEADER</b> defines whether a given header file <b>&lt;version_file_name&gt;</b>  providing  macros  specifying
       the  library  version should be included in the generated header file. By default angle-brackets are used
       for the include statement. To generate includes with double quotes, add double  quotes  to  the  argument
       string  (needs  escaping),  e.g.  <b>\"version.h\"</b>.   The macro from the included version header holding the
       library version is given as <b>&lt;version_macro_name&gt;</b> by the  argument  <b>VERSION_MACRO_NAME</b>  and  used  in  the
       generated code for calculating defaults. If not specified, the defaults for the version file name and the
       version macro are derived from <b>&lt;version_base_name&gt;</b> as passed with <b>VERSION_BASE_NAME</b>, which again defaults
       to    <b>&lt;base_name&gt;</b>    or    otherwise    <b>&lt;library_target_name&gt;</b>.     The    macro    name    defaults    to
       <b>&lt;uppercase_version_base_name&gt;_VERSION</b>, the version file name to  <b>&lt;lowercase_version_base_name&gt;_version.h</b>.
       Since 5.106.

       <b>CUSTOM_CONTENT_FROM_VARIABLE</b>  specifies  the name of a variable whose content will be appended at the end
       of the generated file, before any final inclusion guard closing. Note that before 5.98  this  was  broken
       and would only append the string passed as argument value.

       The  function  <b>ecm_generate_export_header</b> defines C++ preprocessor macros in the generated export header,
       some for use in the sources of the library the header is generated for, other for use by projects linking
       agsinst the library.

       The  macros  for  use  in  the  library  C++  sources  are  these,  next  to  those  also  defined  by  ‐
       <u>GenerateExportHeader</u>:

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED_VERSION(major,</b> <b>minor,</b> <b>text)</b>
              to  use  to  conditionally  set a <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED</b> macro for a class,
              struct or function (other  elements  to  be  supported  in  future  versions),  depending  on  the
              visibility macro flags set (see below)

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED_VERSION_BELATED(major,</b> <b>minor,</b> <b>textmajor,</b> <b>textminor,</b> <b>text)</b>
              to  use  to  conditionally  set a <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED</b> macro for a class,
              struct or function (other  elements  to  be  supported  in  future  versions),  depending  on  the
              visibility  macro  flags set (see below), with <b>major</b> &amp; <b>minor</b> applied for the logic and <b>textmajor</b> &amp;
              <b>textminor</b> for the warnings message.  Useful for  retroactive  tagging  of  API  for  the  compiler
              without  injecting  the  API  into  the  compiler warning conditions of already released versions.
              Since 5.71.

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_ENUMERATOR_DEPRECATED_VERSION(major,</b> <b>minor,</b> <b>text)</b>
              to  use  to  conditionally  set  a  <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED</b>  macro  for   an
              enumerator,  depending on the warnings macro flags set (see below). In builds using C++14 standard
              or earlier, where enumerator attributes are not yet supported, the  macro  will  always  yield  an
              empty string.  With MSVC it is also always an empty string for now.  Since 5.82.

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_ENUMERATOR_DEPRECATED_VERSION_BELATED(major,</b> <b>minor,</b> <b>textmajor,</b>
       <b>textminor,</b> <b>text)</b>
              to   use  to  conditionally  set  a  <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED</b>  macro  for  an
              enumerator, depending on the warnings macro flags set (see below), with <b>major</b> &amp; <b>minor</b> applied  for
              the  logic  and <b>textmajor</b> &amp; <b>textminor</b> for the warnings message.  In builds using C++14 standard or
              earlier, where enumerator attributes are not yet supported, the macro will always yield  an  empty
              string.  Useful for retroactive tagging of API for the compiler without injecting the API into the
              compiler  warning  conditions  of already released versions.  With MSVC it is also always an empty
              string for now.  Since 5.82.

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_ENABLE_DEPRECATED_SINCE(major,</b> <b>minor)</b>
              evaluates to <b>TRUE</b> or <b>FALSE</b> depending on the visibility macro flags set (see  below).  To  be  used
              mainly  with  <b>#if</b>/<b>#endif</b>  to  mark  sections  of  code  which  should be included depending on the
              visibility requested.

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_BUILD_DEPRECATED_SINCE(major,</b> <b>minor)</b>
              evaluates to <b>TRUE</b> or <b>FALSE</b> depending on the value of <b>EXCLUDE_DEPRECATED_BEFORE_AND_AT</b>. To be  used
              mainly  with  <b>#if</b>/<b>#endif</b> to mark sections of two types of code: implementation code for deprecated
              API and declaration code of deprecated API which only may be disabled at build time of the library
              for BC reasons (e.g. virtual methods, see notes below).

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_EXCLUDE_DEPRECATED_BEFORE_AND_AT</b>
              holds the version used to exclude deprecated API at build time of the library.

       The macros used to control visibility when building against the library are:

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DISABLE_DEPRECATED_BEFORE_AND_AT</b>
              definition to set to a value in single hex number version notation (<b>0x&lt;major&gt;&lt;minor&gt;&lt;patchlevel&gt;</b>).

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_NO_DEPRECATED</b>
              flag  to   define   to   disable   all   deprecated   API,   being   a   shortcut   for   settings
              <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DISABLE_DEPRECATED_BEFORE_AND_AT</b>  to  the  current  version. If
              both are set, this flag overrules.

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED_WARNINGS_SINCE</b>
              definition to set to a value in single hex number version notation (<b>0x&lt;major&gt;&lt;minor&gt;&lt;patchlevel&gt;</b>).
              Warnings will be  only  activated  for  API  deprecated  up  to  and  including  the  version.  If
              <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DISABLE_DEPRECATED_BEFORE_AND_AT</b>  is  set  (directly or via the
              group default), it will default to that version, resulting in no warnings. Otherwise  the  default
              is the current version, resulting in warnings for all deprecated API.

       <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_NO_DEPRECATED_WARNINGS</b>
              flag   to   define   to   disable   all   deprecation  warnings,  being  a  shortcut  for  setting
              <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_DEPRECATED_WARNINGS_SINCE</b> to “0”. If both are  set,  this  flag
              overrules.

       When  the  <b>GROUP_BASE_NAME</b> has been used, the same macros but with the given <b>&lt;group_base_name&gt;</b> prefix are
       available to define the defaults of these macros, if not explicitly set.

       <b>WARNING:</b>
          The tricks applied here for hiding deprecated API to the compiler when building against a  library  do
          not work for all deprecated API:

          • virtual  methods  need  to  stay  visible  to the compiler to build proper virtual method tables for
            subclasses

          • enumerators from enums  cannot  be  simply  removed,  as  this  changes  auto  values  of  following
            enumerators, also can poke holes in enumerator series used as index into tables

          In  such  cases  the  API can be only “hidden” at build time of the library, itself, by generated hard
          coded macro settings, using <b>&lt;prefix_name&gt;&lt;uppercase_base_name&gt;_BUILD_DEPRECATED_SINCE(major,</b> <b>minor)</b>.

       Examples:

       Preparing a library “Foo” created by target “foo”, which is part of a group  of  libraries  “Bar”,  where
       some API of “Foo” got deprecated at versions 5.0 &amp; 5.12:

          ecm_generate_export_header(foo
              GROUP_BASE_NAME BAR
              VERSION ${FOO_VERSION}
              DEPRECATION_VERSIONS 5.0 5.12
          )

       In  the  library  “Foo”  sources  in the headers the API would be prepared like this, using the generated
       macros <b>FOO_ENABLE_DEPRECATED_SINCE</b> and <b>FOO_DEPRECATED_VERSION</b>:

          #include &lt;foo_export.h&gt;

          #if FOO_ENABLE_DEPRECATED_SINCE(5, 0)
          /**
            * @deprecated Since 5.0
            */
          FOO_EXPORT
          FOO_DEPRECATED_VERSION(5, 0, "Use doFoo2()")
          void doFoo();
          #endif

          #if FOO_ENABLE_DEPRECATED_SINCE(5, 12)
          /**
            * @deprecated Since 5.12
            */
          FOO_EXPORT
          FOO_DEPRECATED_VERSION(5, 12, "Use doBar2()")
          void doBar();
          #endif

       Projects linking against the “Foo” library can control which part of its deprecated API should be  hidden
       to  the compiler by adding a definition using the <b>FOO_DISABLE_DEPRECATED_BEFORE_AND_AT</b> macro variable set
       to the desired value (in version hex number notation):

          add_definitions(-DFOO_DISABLE_DEPRECATED_BEFORE_AND_AT=0x050000)

       Or using the macro variable of the group:

          add_definitions(-DBAR_DISABLE_DEPRECATED_BEFORE_AND_AT=0x050000)

       If both are specified, <b>FOO_DISABLE_DEPRECATED_BEFORE_AND_AT</b> will take precedence.

       To build a variant of a library with some deprecated API completely left out from  the  build,  not  only
       optionally  invisible to consumers, one uses the <b>EXCLUDE_DEPRECATED_BEFORE_AND_AT</b> parameter. This is best
       combined with a cached CMake variable.

          set(EXCLUDE_DEPRECATED_BEFORE_AND_AT 0 CACHE STRING "Control the range of deprecated API excluded from the build [default=0].")

          ecm_generate_export_header(foo
              VERSION ${FOO_VERSION}
              EXCLUDE_DEPRECATED_BEFORE_AND_AT ${EXCLUDE_DEPRECATED_BEFORE_AND_AT}
              DEPRECATION_VERSIONS 5.0 5.12
          )

       The macros used in the headers for library consumers are reused for disabling the  API  excluded  in  the
       build  of  the  library. For disabling the implementation of that API as well as for disabling deprecated
       API which only can be disabled at build time of the library for BC reasons, one uses the generated  macro
       <b>FOO_BUILD_DEPRECATED_SINCE</b>, like this:

          #include &lt;foo_export.h&gt;

          enum Bars {
              One,
          #if FOO_BUILD_DEPRECATED_SINCE(5, 0)
              Two FOO_ENUMERATOR_DEPRECATED_VERSION(5, 0, "Use Three"), // macro available since 5.82
          #endif
              Three,
          };

          #if FOO_ENABLE_DEPRECATED_SINCE(5, 0)
          /**
            * @deprecated Since 5.0
            */
          FOO_EXPORT
          FOO_DEPRECATED_VERSION(5, 0, "Use doFoo2()")
          void doFoo();
          #endif

          #if FOO_ENABLE_DEPRECATED_SINCE(5, 12)
          /**
            * @deprecated Since 5.12
            */
          FOO_EXPORT
          FOO_DEPRECATED_VERSION(5, 12, "Use doBar2()")
          void doBar();
          #endif

          class FOO_EXPORT Foo {
          public:
          #if FOO_BUILD_DEPRECATED_SINCE(5, 0)
              /**
                * @deprecated Since 5.0
                */
              FOO_DEPRECATED_VERSION(5, 0, "Feature removed")
              virtual void doWhat();
          #endif
          };

          #if FOO_BUILD_DEPRECATED_SINCE(5, 0)
          void doFoo()
          {
              // [...]
          }
          #endif

          #if FOO_BUILD_DEPRECATED_SINCE(5, 12)
          void doBar()
          {
              // [...]
          }
          #endif

          #if FOO_BUILD_DEPRECATED_SINCE(5, 0)
          void Foo::doWhat()
          {
              // [...]
          }
          #endif

       So  e.g. if <b>EXCLUDE_DEPRECATED_BEFORE_AND_AT</b> is set to “5.0.0”, the enumerator <b>Two</b> as well as the methods
       <b>::doFoo()</b> and <b>Foo::doWhat()</b> will be not available to library consumers. The methods will  not  have  been
       compiled   into   the   library   binary,   and   the  declarations  will  be  hidden  to  the  compiler,
       <b>FOO_DISABLE_DEPRECATED_BEFORE_AND_AT</b> also cannot be used to reactivate them.

       When using the <b>NO_DEFINITION_EXPORT_TO_BUILD_INTERFACE</b> and the project for  the  “Foo”  library  includes
       also  tests  and  examples linking against the library and using deprecated API (like tests covering it),
       one better explicitly sets <b>FOO_DISABLE_DEPRECATED_BEFORE_AND_AT</b> for those targets to the  version  before
       and  at which all deprecated API has been excluded from the build.  Even more when building against other
       libraries from the same group “Bar” and disabling some deprecated API of those libraries using the  group
       macro      <b>BAR_DISABLE_DEPRECATED_BEFORE_AND_AT</b>,      which     also     works     as     default     for
       <b>FOO_DISABLE_DEPRECATED_BEFORE_AND_AT</b>.

       To get the hex number style value the helper macro <b>ecm_export_header_format_version()</b> will be used:

          set(EXCLUDE_DEPRECATED_BEFORE_AND_AT 0 CACHE STRING "Control what part of deprecated API is excluded from build [default=0].")

          ecm_generate_export_header(foo
              VERSION ${FOO_VERSION}
              GROUP_BASE_NAME BAR
              EXCLUDE_DEPRECATED_BEFORE_AND_AT ${EXCLUDE_DEPRECATED_BEFORE_AND_AT}
              NO_DEFINITION_EXPORT_TO_BUILD_INTERFACE
              DEPRECATION_VERSIONS 5.0 5.12
          )

          ecm_export_header_format_version(${EXCLUDE_DEPRECATED_BEFORE_AND_AT}
              CURRENT_VERSION ${FOO_VERSION}
              HEXNUMBER_VAR foo_no_deprecated_before_and_at
          )

          # disable all deprecated API up to 5.9.0 from all other libs of group "BAR" that we use ourselves
          add_definitions(-DBAR_DISABLE_DEPRECATED_BEFORE_AND_AT=0x050900)

          add_executable(app app.cpp)
          target_link_libraries(app foo)
          target_compile_definitions(app
               PRIVATE "FOO_DISABLE_DEPRECATED_BEFORE_AND_AT=${foo_no_deprecated_before_and_at}")

       Since 5.64.0.

   <b>ECMGenerateHeaders</b>
       Generate C/C++ CamelCase forwarding headers.

          ecm_generate_headers(&lt;camelcase_forwarding_headers_var&gt;
              HEADER_NAMES &lt;CamelCaseName&gt; [&lt;CamelCaseName&gt; [...]]
              [ORIGINAL &lt;CAMELCASE|LOWERCASE&gt;]
              [HEADER_EXTENSION &lt;header_extension&gt;]
              [OUTPUT_DIR &lt;output_dir&gt;]
              [PREFIX &lt;prefix&gt;]
              [REQUIRED_HEADERS &lt;variable&gt;]
              [COMMON_HEADER &lt;HeaderName&gt;]
              [RELATIVE &lt;relative_path&gt;])

       For each CamelCase header name passed to <b>HEADER_NAMES</b>, a file of that name will be  generated  that  will
       include  a  version  with <b>.h</b> or, if set, <b>.&lt;header_extension&gt;</b> appended.  For example, the generated header
       <b>ClassA</b> will include <b>classa.h</b> (or <b>ClassA.h</b>, see  <b>ORIGINAL</b>).   If  a  CamelCaseName  consists  of  multiple
       comma-separated files, e.g.  <b>ClassA,ClassB,ClassC</b>, then multiple camelcase header files will be generated
       which  are  redirects  to  the  first header file.  The file locations of these generated headers will be
       stored in &lt;camelcase_forwarding_headers_var&gt;.

       <b>ORIGINAL</b> specifies how the name of the original header is written: lowercased or  also  camelcased.   The
       default is “LOWERCASE”. Since 1.8.0.

       <b>HEADER_EXTENSION</b>  specifies  what  file name extension is used for the header files.  The default is “h”.
       Since 5.48.0.

       <b>PREFIX</b> places the generated headers in subdirectories.  This should be  a  CamelCase  name  like  <b>KParts</b>,
       which  will  cause  the  CamelCase  forwarding  headers  to  be  placed  in  the  <b>KParts</b>  directory (e.g.
       <b>KParts/Part</b>).  It will also, for the convenience of code in the source distribution, generate  forwarding
       headers  based  on  the  original  names  (e.g.  <b>kparts/part.h</b>).   This  allows  includes  like <b>"#include</b>
       <b>&lt;kparts/part.h&gt;"</b>  to  be  used  before  installation,  as  long  as  the  include_directories   are   set
       appropriately.

       <b>OUTPUT_DIR</b>  specifies  where  the  files will be generated; this should be within the build directory. By
       default, <b>${CMAKE_CURRENT_BINARY_DIR}</b> will be used.  This option can be used to avoid file conflicts.

       <b>REQUIRED_HEADERS</b> specifies an output variable name where all the required headers  will  be  appended  so
       that they can be installed together with the generated ones.  This is mostly intended as a convenience so
       that  adding  a  new  header  to  a  project  only  requires  specifying  the  CamelCase  variant  in the
       CMakeLists.txt file; the original variant will then be added to this variable.

       <b>COMMON_HEADER</b> generates an additional convenience header which includes all other header files.

       The  <b>RELATIVE</b>  argument   indicates   where   the   original   headers   can   be   found   relative   to
       <b>CMAKE_CURRENT_SOURCE_DIR</b>.    It   does   not   affect  the  generated  CamelCase  forwarding  files,  but
       <b>ecm_generate_headers()</b> uses it when checking that the original header exists, and to generate  originally
       named forwarding headers when <b>PREFIX</b> is set.

       To  allow  other  parts  of  the  source  distribution  (eg:  tests)  to use the generated headers before
       installation, it may be desirable to set the <b>INCLUDE_DIRECTORIES</b>  property  for  the  library  target  to
       output_dir.  For example, if <b>OUTPUT_DIR</b> is <b>CMAKE_CURRENT_BINARY_DIR</b> (the default), you could do

          target_include_directories(MyLib PUBLIC "$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}&gt;")

       Example usage (without <b>PREFIX</b>):

          ecm_generate_headers(
              MyLib_FORWARDING_HEADERS
              HEADERS
                  MLFoo
                  MLBar
                  # etc
              REQUIRED_HEADERS MyLib_HEADERS
              COMMON_HEADER MLGeneral
          )
          install(FILES ${MyLib_FORWARDING_HEADERS} ${MyLib_HEADERS}
                  DESTINATION ${CMAKE_INSTALL_PREFIX}/include
                  COMPONENT Devel)

       Example usage (with <b>PREFIX</b>):

          ecm_generate_headers(
              MyLib_FORWARDING_HEADERS
              HEADERS
                  Foo
                  # several classes are contained in bar.h, so generate
                  # additional files
                  Bar,BarList
                  # etc
              PREFIX MyLib
              REQUIRED_HEADERS MyLib_HEADERS
          )
          install(FILES ${MyLib_FORWARDING_HEADERS}
                  DESTINATION ${CMAKE_INSTALL_PREFIX}/include/MyLib
                  COMPONENT Devel)
          install(FILES ${MyLib_HEADERS}
                  DESTINATION ${CMAKE_INSTALL_PREFIX}/include/mylib
                  COMPONENT Devel)

       Since pre-1.0.0.

   <b>ECMGeneratePkgConfigFile</b>
       Generate a <u>pkg-config</u> file for the benefit of <u>autotools</u>-based projects.

          ecm_generate_pkgconfig_file(BASE_NAME &lt;baseName&gt;
                                [LIB_NAME &lt;libName&gt;]
                                [DEPS [PRIVATE|PUBLIC] &lt;dep&gt; [[PRIVATE|PUBLIC] &lt;dep&gt; [...]]]
                                [FILENAME_VAR &lt;filename_variable&gt;]
                                [INCLUDE_INSTALL_DIR &lt;dir&gt;]
                                [LIB_INSTALL_DIR &lt;dir&gt;]
                                [DEFINES -D&lt;variable=value&gt;...]
                                [DESCRIPTION &lt;library description&gt;] # since 5.41.0
                                [URL &lt;url&gt;] # since 5.89.0
                                [INSTALL])

       <b>BASE_NAME</b> is the name of the module. It’s the name projects will use to find the module.

       <b>LIB_NAME</b>  is  the  name  of  the  library  that  is  being exported. If undefined, it will default to the
       <b>BASE_NAME</b>. That means the <b>LIB_NAME</b> will be set as the name field as well as the library to link to.

       <b>DEPS</b> is the list of libraries required by this library. Libraries that are not  exposed  to  applications
       should  be marked with <b>PRIVATE</b>. The default is <b>PUBLIC</b>, but note that according to the <u>Guide</u> <u>to</u> <u>pkg-config</u>
       marking dependencies as private is usually preferred. The <b>PUBLIC</b> and <b>PRIVATE</b> keywords are supported since
       5.89.0.

       <b>FILENAME_VAR</b> is specified with a variable name. This variable will receive the location of the  generated
       file  will  be  set,  within  the  build  directory.  This  way it can be used in case some processing is
       required. See also <b>INSTALL</b>.

       <b>INCLUDE_INSTALL_DIR</b> specifies where the includes will be  installed.  If  it’s  not  specified,  it  will
       default  to  <b>INSTALL_INCLUDEDIR</b>,  <b>CMAKE_INSTALL_INCLUDEDIR</b> or just “include/” in case they are specified,
       with the <b>BASE_NAME</b> postfixed.

       <b>LIB_INSTALL_DIR</b> specifies where the library is being installed. If it’s not specified, it will default to
       <b>LIB_INSTALL_DIR</b>, <b>CMAKE_INSTALL_LIBDIR</b> or just “lib/” in case they are specified.

       <b>DEFINES</b> is a list of preprocessor defines that it is  recommended  users  of  the  library  pass  to  the
       compiler when using it.

       <b>DESCRIPTION</b>  describes  what  this  library  is.  If  it’s not specified, CMake will first try to get the
       description from the metainfo.yaml file or will create one based on <b>LIB_NAME</b>. Since 5.41.0.

       <b>URL</b> An URL where people can get  more  information  about  and  download  the  package.  Defaults  to  “‐
       <u>https://www.kde.org/</u>”. Since 5.89.0.

       <b>INSTALL</b>  will  cause  the module to be installed to the <b>pkgconfig</b> subdirectory of <b>LIB_INSTALL_DIR</b>, unless
       the <b>ECM_PKGCONFIG_INSTALL_DIR</b> cache variable is set to something different.

       <b>NOTE:</b>
          The  first  call   to   <b>ecm_generate_pkgconfig_file()</b>   with   the   <b>INSTALL</b>   argument   will   cause
          <b>ECM_PKGCONFIG_INSTALL_DIR</b> to be set to the cache, and will be used in any subsequent calls.

       To  properly  use  this  macro  a version needs to be set. To retrieve it, <b>ECM_PKGCONFIG_INSTALL_DIR</b> uses
       <b>PROJECT_VERSION</b>. To set it, use the <b>project()</b> command (or if you still set CMP0048 to OLD and don’t  have
       CMake &gt;= 4 the <b>ecm_setup_version()</b> macro)

       Example usage:

          ecm_generate_pkgconfig_file(
              BASE_NAME KF5Archive
              DEPS Qt5Core
              FILENAME_VAR pkgconfig_filename
              INSTALL
          )

       Since 1.3.0.

   <b>ECMGeneratePriFile</b>
       Generate a <b>.pri</b> file for the benefit of qmake-based projects.

       As  well  as  the function below, this module creates the cache variable <b>ECM_MKSPECS_INSTALL_DIR</b> and sets
       the default value to <b>mkspecs/modules</b>.  This assumes Qt and the current project are both installed to  the
       same  non-system  prefix.   Packagers  who  use  <b>-DCMAKE_INSTALL_PREFIX=<a href="file:/usr">/usr</a></b>  will  certainly want to set
       <b>ECM_MKSPECS_INSTALL_DIR</b> to something like <b>share/qt5/mkspecs/modules</b>.

       The main thing is that this should be the <b>modules</b>  subdirectory  of  either  the  default  qmake  <b>mkspecs</b>
       directory or of a directory that will be in the <b>$QMAKEPATH</b> environment variable when qmake is run.

          ecm_generate_pri_file(BASE_NAME &lt;baseName&gt;
                                LIB_NAME &lt;libName&gt;
                                [VERSION &lt;version&gt;] # since 5.83
                                [DEPS "&lt;dep&gt; [&lt;dep&gt; [...]]"]
                                [FILENAME_VAR &lt;filename_variable&gt;]
                                [INCLUDE_INSTALL_DIRS &lt;dir&gt; [&lt;dir&gt; [...]]]  # since 5.92
                                [INCLUDE_INSTALL_DIR &lt;dir&gt;] # deprecated since 5.92
                                [LIB_INSTALL_DIR &lt;dir&gt;])

       If  your  CMake project produces a Qt-based library, you may expect there to be applications that wish to
       use it that use a qmake-based build system, rather than a CMake-based one.  Creating  a  <b>.pri</b>  file  will
       make  use  of  your library convenient for them, in much the same way that CMake config files make things
       convenient for CMake-based applications. <b>ecm_generate_pri_file()</b> generates just such a file.

       <b>VERSION</b> specifies the version of the library the <b>.pri</b> file describes. If not set, the value is taken from
       the context variable <b>PROJECT_VERSION</b>.  This variable is usually  set  by  the  <b>project(...</b>  <b>VERSION</b>  <b>...)</b>
       command  or,  if  CMake  policy  CMP0048 is not <b>NEW</b>, by <u>ECMSetupVersion</u>.  For backward-compatibility with
       older ECM versions the <b>PROJECT_VERSION_STRING</b> variable as set by <u>ECMSetupVersion</u> will be  preferred  over
       <b>PROJECT_VERSION</b> if set, unless the minimum required version of ECM is 5.83 and newer. Since 5.83.

       <b>BASE_NAME</b>  specifies  the  name  qmake  project  (.pro)  files  should  use  to refer to the library (eg:
       KArchive).  <b>LIB_NAME</b> is the  name  of  the  actual  library  to  link  to  (ie:  the  first  argument  to
       add_library()).   <b>DEPS</b>  is a space-separated list of the base names of other libraries (for Qt libraries,
       use the same names you use with the <b>QT</b> variable in a qmake project file,  such  as  “core”  for  QtCore).
       <b>FILENAME_VAR</b> specifies the name of a variable to store the path to the generated file in.

       <b>INCLUDE_INSTALL_DIRS</b>  are  the  paths  (relative  to  <b>CMAKE_INSTALL_PREFIX</b>)  that  include  files will be
       installed to. It defaults to <b>${INCLUDE_INSTALL_DIR}/&lt;baseName&gt;</b> if  the  <b>INCLUDE_INSTALL_DIR</b>  variable  is
       set.  If  that variable is not set, the <b>CMAKE_INSTALL_INCLUDEDIR</b> variable is used instead, and if neither
       are set <b>include</b> is used.  <b>LIB_INSTALL_DIR</b> operates similarly for the installation location for libraries;
       it defaults to <b>${LIB_INSTALL_DIR}</b>, <b>${CMAKE_INSTALL_LIBDIR}</b> or <b>lib</b>, in that order.

       <b>INCLUDE_INSTALL_DIR</b> is the old variant of <b>INCLUDE_INSTALL_DIRS</b>, taking only one directory.

       Example usage:

          ecm_generate_pri_file(
              BASE_NAME KArchive
              LIB_NAME KF5KArchive
              DEPS "core"
              FILENAME_VAR pri_filename
              VERSION 4.2.0
          )
          install(FILES ${pri_filename} DESTINATION ${ECM_MKSPECS_INSTALL_DIR})

       A qmake-based project that wished to use this would then do:

          QT += KArchive

       in their <b>.pro</b> file.

       Since pre-1.0.0.

   <b>ECMGeneratePythonBindings</b>
       This module is experimental and internal.  The interface will likely change in the coming releases.

       Generate Python bindings using Shiboken.

          ecm_generate_python_bindings(PACKAGE_NAME &lt;pythonlibrary&gt;
                                       VERSION &lt;version&gt;
                                       WRAPPED_HEADER &lt;filename&gt;
                                       TYPESYSTEM &lt;filename&gt;
                                       [EXPORT_TYPESYSTEM]
                                       GENERATED_SOURCES &lt;filename&gt; [&lt;filename&gt; [...]]
                                       DEPENDENCIES &lt;target&gt; [&lt;target&gt; [...]]
                                       QT_VERSION &lt;version&gt;
                                       HOMEPAGE_URL &lt;url&gt;
                                       ISSUES_URL &lt;url&gt;
                                       AUTHOR &lt;string&gt;
                                       README &lt;filename&gt; )

       <b>&lt;pythonlibrary&gt;</b> is the name of the Python library that will be created.

       <b>VERSION</b> is the version of the library.

       <b>WRAPPED_HEADER</b> is a C++ header that contains all the required includes for the library.

       <b>TYPESYSTEM</b> is the XML file where the bindings are defined.

       <b>EXPORT_TYPESYSTEM</b> specifies that the typesystem XML file and the generated header are exported and can be
       used by other typesystem XML files.

       <b>GENERATED_SOURCES</b> is the list of generated C++ source files by Shiboken that will be used  to  build  the
       shared library.

       <b>QT_VERSION</b> is the minimum required Qt version of the library.

       <b>DEPENDENCIES</b> is the list of dependencies that the bindings uses.

       <b>HOMEPAGE_URL</b> is a URL to the proyect homepage.

       ``
       ISSUES_URL` is a URL where users can report bugs and feature requests.

       <b>AUTHOR</b> is a string with the author of the library.

       <b>README</b> is a Markdown file that will be used as the project’s description on the Python Package Index.

   <b>ECMGenerateQDoc</b>
       This  module  provides the <b>ecm_generate_qdoc</b> function for generating API documentation files for projects
       based on qdoc.

       It allows to generate both online HTML documentation as well as (installed) QCH files.

          ecm_generate_qdoc(&lt;target_name&gt; &lt;qdocconf_file&gt;)

       <b>target_name</b> is the library target for which the documentation is generated.

       <b>qdocconf_file</b> is the .qdocconf file that controls the documentation generation.

       If the project contains multiple libraries with documented APIs <b>ecm_generate_qdoc</b> should  be  called  for
       each one.

       Example usage:

          ecm_add_qch(KF6::CoreAddons kcoreaddons.qdocconf)

       Documentation  is  not  built  as  part  of  the normal build, it needs to be explicity invoked using the
       following build targets:

       • <b>prepare_docs</b> runs the prepare step from qdoc, which processes sources and creates index files

       • <b>generate_docs</b> runs the generate step from qdoc, generating the final documentation from the index files

       • <b>install_html_docs</b>  installs  the  generated   HTML   documentation   into   <b>KDE_INSTALL_QTQCHDIR</b>   from
         <u>KDEInstallDirs</u>

       • <b>generate_qch</b> creates QCH files out of the HTML documentation

       • <b>install_qch_docs</b> installs the QCH files into <b>KDE_INSTALL_QTQCHDIR</b> from <u>KDEInstallDirs</u>

       The following global parameters are understood:

       • <b>QDOC_BIN</b>:  This  can be used to select another qdoc executable than the one found by find_package. This
         is useful to test with different versions of the qdoc tool.

       • <b>DOC_DESTDIR</b>: This is where the HTML and index files will be generated.  This  is  useful  to  aggregate
         results from multiple projects into a single directory.

       When  combining  documentation  from  multiple  projects  the  recommended  procedure  is to use a common
       <b>DOC_DESTDIR</b> and run the prepare stage for all before running the generate stage  for  all.  This  ensures
       that the index files are all available during the generate phase and cross-linking works as expected.

       Since 6.11.0.

   <b>ECMGenerateQmlTypes</b>
       Generates plugins.qmltypes files for QML plugins.

          ecm_generate_qmltypes(&lt;org.kde.pluginname&gt; 1.3
                                DESTINATION &lt;${KDE_INSTALL_QMLDIR}/org/kde/pluginname&gt;)

       Makes  it  possible to generate plugins.qmltypes files for the QML plugins that our project offers. These
       files offer introspection upon our plugin and are useful for integrating with IDE language support of our
       plugin. It offers information about the objects its methods and their argument types.

       The developer will be in charge of making sure that these files are up to date.  The plugin.qmltypes file
       will sit in the source directory. This function will include the code that installs the file in the right
       place and a small unit test named qmltypes-pluginname-version  that  makes  sure  that  it  doesn’t  need
       updating.

       Since 5.33.0

   <b>ECMInstallIcons</b>
       Installs  icons,  sorting  them into the correct directories according to the FreeDesktop.org icon naming
       specification.

          ecm_install_icons(ICONS &lt;icon&gt; [&lt;icon&gt; [...]]
                            DESTINATION &lt;icon_install_dir&gt;
                            [LANG &lt;l10n_code&gt;]
                            [THEME &lt;theme&gt;])

       The given icons, whose names must match the pattern:

          &lt;size&gt;-&lt;group&gt;-&lt;name&gt;.&lt;ext&gt;

       will be installed to the appropriate subdirectory of <b>DESTINATION</b> according to  the  FreeDesktop.org  icon
       naming  scheme.  By default, they are installed to the “hicolor” theme, but this can be changed using the
       <b>THEME</b> argument.  If the icons are localized, the  LANG  argument  can  be  used  to  install  them  in  a
       locale-specific directory.

       <b>&lt;size&gt;</b> is a numeric pixel size (typically 16, 22, 32, 48, 64, 128 or 256) or <b>sc</b> for scalable (SVG) files,
       <b>&lt;group&gt;</b>  is  one  of  the  standard  FreeDesktop.org  icon groups (actions, animations, apps, categories,
       devices, emblems, emotes, intl, mimetypes, places, status) and <b>&lt;ext&gt;</b> is one of <b>.png</b>, <b>.mng</b> or <b>.svgz</b>.

       The typical installation directory is <b>share/icons</b>.

          ecm_install_icons(ICONS 22-actions-menu_new.png
                            DESTINATION share/icons)

       The      above      code      will      install      the      file       <b>22-actions-menu_new.png</b>       as
       <b>${CMAKE_INSTALL_PREFIX}/share/icons/&lt;theme&gt;/22x22/actions/menu_new.png</b>

       Users  of  the  <u>KDEInstallDirs</u> module would normally use <b>${KDE_INSTALL_ICONDIR}</b> as the DESTINATION, while
       users of the GNUInstallDirs module should use <b>${CMAKE_INSTALL_DATAROOTDIR}/icons</b>.

       An old form of arguments will also be accepted:

          ecm_install_icons(&lt;icon_install_dir&gt; [&lt;l10n_code&gt;])

       This matches files named like:

          &lt;theme&gt;&lt;size&gt;-&lt;group&gt;-&lt;name&gt;.&lt;ext&gt;

       where <b>&lt;theme&gt;</b> is one of

       • <b>hi</b> for hicolor

       • <b>lo</b> for locolor

       • <b>cr</b> for the Crystal icon theme

       • <b>ox</b> for the Oxygen icon theme

       • <b>br</b> for the Breeze icon theme

       With    this    syntax,    the    file    <b>hi22-actions-menu_new.png</b>    would    be     installed     into
       <b>&lt;icon_install_dir&gt;/hicolor/22x22/actions/menu_new.png</b>

       Since pre-1.0.0.

   <b>ECMMarkAsTest</b>
       Marks a target as only being required for tests.

          ecm_mark_as_test(&lt;target1&gt; [&lt;target2&gt; [...]])

       This  will  cause  the  specified targets to not be built unless either <b>BUILD_TESTING</b> is set to <b>ON</b> or the
       user invokes the <b>buildtests</b> target.

       <b>BUILD_TESTING</b> is created as a cache variable by the CTest module and by the <u>KDECMakeSettings</u> module.

       Since pre-1.0.0.

   <b>ECMMarkNonGuiExecutable</b>
       Marks an executable target as not being a GUI application.

          ecm_mark_nongui_executable(&lt;target1&gt; [&lt;target2&gt; [...]])

       This will indicate to CMake that the specified targets should not be  included  in  a  MACOSX_BUNDLE  and
       should not be WIN32_EXECUTABLEs.  On platforms other than MacOS X or Windows, this will have no effect.

       Since pre-1.0.0.

   <b>ECMOptionalAddSubdirectory</b>
       Make subdirectories optional.

          ecm_optional_add_subdirectory(&lt;dir&gt;)

       This  behaves  like <b>add_subdirectory()</b>, except that it does not complain if the directory does not exist.
       Additionally, if the directory does exist, it creates an option to allow the user to skip it. The  option
       will be named BUILD_&lt;dir&gt;.

       This is useful for “meta-projects” that combine several mostly-independent sub-projects.

       If  the  CMake variable <b>DISABLE_ALL_OPTIONAL_SUBDIRECTORIES</b> is set to <b>TRUE</b> for the first CMake run on the
       project, all optional subdirectories will be disabled by default (but can of course be  enabled  via  the
       respective  options).  For example, the following will disable all optional subdirectories except the one
       named “foo”:

          cmake -DDISABLE_ALL_OPTIONAL_SUBDIRECTORIES=TRUE -DBUILD_foo=TRUE myproject

       Since pre-1.0.0.

   <b>ECMPackageConfigHelpers</b>
       Helper macros for generating CMake package config files.

       <b>write_basic_package_version_file()</b> is the same as  the  one  provided  by  the  <u>CMakePackageConfigHelpers</u>
       module in CMake; see that module’s documentation for more information.

          ecm_configure_package_config_file(&lt;input&gt; &lt;output&gt;
              INSTALL_DESTINATION &lt;path&gt;
              [PATH_VARS &lt;var1&gt; [&lt;var2&gt; [...]]
              [NO_SET_AND_CHECK_MACRO]
              [NO_CHECK_REQUIRED_COMPONENTS_MACRO])

       This behaves in the same way as <b>configure_package_config_file()</b> from CMake 2.8.12, except that it adds an
       extra  helper  macro:  <b>find_dependency()</b>.  It  is  highly recommended that you read the <u>documentation</u> <u>for</u>
       <u>CMakePackageConfigHelpers</u> for more information, particularly with regard to the <b>PATH_VARS</b> argument.

       Note that there is no argument that will disable the <b>find_dependency()</b> macro; if you do not require  this
       macro, you should use <b>configure_package_config_file</b> from the CMakePackageConfigHelpers module.

       CMake 3.0 includes a CMakeFindDependencyMacro module that provides the <b>find_dependency()</b> macro (which you
       can  <b>include()</b>  in your package config file), so this file is only useful for projects wishing to provide
       config files that will work with CMake 2.8.12.

   <b>Additional</b> <b>Config</b> <b>File</b> <b>Macros</b>
          find_dependency(&lt;dep&gt; [&lt;version&gt; [EXACT]])

       <b>find_dependency()</b> should be used instead of <b>find_package()</b> to find package dependencies.  It forwards the
       correct parameters for <b>EXACT</b>, <b>QUIET</b> and <b>REQUIRED</b> which were passed to the original  <b>find_package()</b>  call.
       It also sets an informative diagnostic message if the dependency could not be found.

       Since pre-1.0.0.

   <b>ECMPoQmTools</b>
       This   module  provides  the  <b>ecm_process_po_files_as_qm</b>  and  <b>ecm_install_po_files_as_qm</b>  functions  for
       generating QTranslator (.qm) catalogs from Gettext (.po) catalogs, and the <b>ecm_create_qm_loader</b>  function
       for generating the necessary code to load them in a Qt application or library.

          ecm_process_po_files_as_qm(&lt;lang&gt; [ALL]
                                     [INSTALL_DESTINATION &lt;install_destination&gt;]
                                     PO_FILES &lt;pofile&gt; [&lt;pofile&gt; [...]])

       Compile .po files into .qm files for the given language.

       If <b>INSTALL_DESTINATION</b> is given, the .qm files are installed in <b>&lt;install_destination&gt;/&lt;lang&gt;/LC_MESSAGES</b>.
       Typically, <b>&lt;install_destination&gt;</b> is set to <b>share/locale</b>.

       <b>ecm_process_po_files_as_qm</b>  creates  a  “translations”  target. This target builds all .po files into .qm
       files.  If <b>ALL</b> is specified, these rules are added to the “all” target (and so  the  .qm  files  will  be
       built by default).

          ecm_create_qm_loader(&lt;sources_var_name(|target (since 5.83))&gt; &lt;catalog_name&gt;)

       Generates  C++  code  which ensures translations are automatically loaded at startup. The generated files
       are appended to the variable named <b>&lt;sources_var_name&gt;</b> or, if the first argument is a target (since 5.83),
       to the <b>SOURCES</b> property of <b>&lt;target&gt;</b>. Any target must be created with  <b>add_executable()</b>  or  <b>add_library()</b>
       and not be an alias.

       It    assumes    that    the    .qm    file    for   the   language   code   <b>&lt;lang&gt;</b>   is   installed   as
       <b>&lt;sharedir&gt;/locale/&lt;lang&gt;/LC_MESSAGES/&lt;catalog_name&gt;.qm</b>, where <b>&lt;sharedir&gt;</b> is one of the directories  given
       by the <b>GenericDataLocation</b> of <b>QStandardPaths</b>.

       Typical usage is like:

          set(mylib_SRCS foo.cpp bar.cpp)
          ecm_create_qm_loader(mylib_SRCS mycatalog)
          add_library(mylib ${mylib_SRCS})

          # Or, since 5.83:
          add_library(mylib foo.cpp bar.cpp)
          ecm_create_qm_loader(mylib mycatalog)

          ecm_install_po_files_as_qm(&lt;podir&gt;)

       Searches for .po files and installs them to the standard location.

       This  is a convenience function which relies on all .po files being kept in <b>&lt;podir&gt;/&lt;lang&gt;/</b>, where <b>&lt;lang&gt;</b>
       is the language the .po files are written in.

       For example, given the following directory structure:

          po/
            fr/
              mylib.po

       <b>ecm_install_po_files_as_qm(po)</b>    compiles    <b>mylib.po</b>    into    <b>mylib.qm</b>    and    installs    it    in
       <b>&lt;install_destination&gt;/fr/LC_MESSAGES</b>.    <b>&lt;install_destination&gt;</b>   defaults   to  <b>${LOCALE_INSTALL_DIR}</b>  if
       defined, otherwise it uses <b>${CMAKE_INSTALL_LOCALEDIR}</b> if that is defined, otherwise it uses <b>share/locale</b>.

       Since pre-1.0.0.

   <b>ECMQmlModule</b>
       Helper functions to make it easier to create QML modules.

       This CMake module lets you create QML-enabled targets, add C++ and QML files to them,  and  finalize  the
       module if needed. When using Qt 6, it allows for <u>declarative</u> <u>registration</u> <u>of</u> <u>QML</u> <u>types</u>.

       This  CMake  module  reduces boilerplate and takes care of special handling of QML modules between shared
       and static builds:

       • When building a static version of a QML module, the relevant QML source  files  are  bundled  into  the
         static library.

       • When  using  a  shared  build,  the  QML  plugin  and  relevant  QML  files  are copied to the target’s
         <b>RUNTIME_OUTPUT_DIRECTORY</b> to make it easier to run things directly from the build directory.

       Since 6.0.0, when using Qt 6, most functionality of this module has been implemented by upstream Qt. Most
       of the functions here will now forward to the similar Qt functions.

       Example usage with an executable as backing target:

          add_executable(app)
          ecm_add_qml_module(app
              URI "org.example.Example"
          )

          target_sources(app PRIVATE main.cpp)
          target_link_libraries(app PRIVATE Qt::Quick)

          ecm_target_qml_sources(app SOURCES ExampleItem.qml) # This will have 1.0 as the default version
          ecm_target_qml_sources(app SOURCES AnotherExampleItem.qml VERSION 1.5)

          install(TARGETS app ${KDE_INSTALL_TARGETS_DEFAULT_ARGS})

       The above example creates an executable target, modifies the target to allow it to accept QML  files  and
       properties, adds source files to it, and installs it.

       The executable is the backing target for the QML module, which in practical terms means the QML module is
       “embedded”  into the executable, always being loaded as part of the application, and no plugin library is
       created.

       Example usage with a separate QML module:

          add_library(ExampleModule)
          ecm_add_qml_module(ExampleModule
              URI org.example.Example
              GENERATE_PLUGIN_SOURCE
          )

          target_sources(ExampleModule PRIVATE ExamplePlugin.cpp)
          target_link_libraries(ExampleModule PRIVATE Qt::Quick)

          ecm_target_qml_sources(ExampleModule SOURCES ExampleItem.qml)

          ecm_finalize_qml_module(ExampleModule DESTINATION ${KDE_INSTALL_QMLDIR})

          install(TARGETS ExampleModule ${KDE_INSTALL_TARGETS_DEFAULT_ARGS})

       The above example creates a library target, modifies the target to allow  it  to  accept  QML  files  and
       properties, adds source files to it, and finalizes the target.

       The  library  acts  as  a  plugin  that is expected to be linked to an executable later on, in which case
       <b>GENERATE_PLUGIN_SOURCE</b> and <b>ecm_finalize_qml_module()</b> are both required.

          ecm_add_qml_module(&lt;target name&gt;
              URI &lt;module uri&gt;
              [VERSION &lt;module version&gt;]
              [NO_PLUGIN] # Deprecated since 6.0.0 when using Qt 6
              [CLASSNAME &lt;class name&gt;] # Deprecated since 6.0.0 when using Qt 6, use CLASS_NAME instead
              [QT_NO_PLUGIN] # Since 6.0.0, when using Qt 6
              [GENERATE_PLUGIN_SOURCE] # Since 6.0.0, when using Qt 6
              [DEPENDENCIES &lt;dependency&gt; ...] # Since 6.0.0, when using Qt 6, inherited from qt_add_qml_module()
              [IMPORTS &lt;import&gt; ...] # Since 6.0.0, when using Qt 6, inherited from qt_add_qml_module()
          )

       This will declare a new CMake target called <b>&lt;target</b> <b>name&gt;</b>. The <b>URI</b> argument is required and should  be  a
       proper QML module URI. The <b>URI</b> is used, among others, to generate a subdirectory where the module will be
       installed to.

       If  the  <b>VERSION</b>  argument  is  specified,  it  is used to initialize the default version that is used by
       <b>ecm_target_qml_sources</b> when adding QML files. If it  is  not  specified,  a   default  of  1.0  is  used.
       Additionally,  if  a  version greater than or equal to 2.0 is specified, the major version is appended to
       the Qt5 installation path of the module.  In case you don’t specify a version for the module, but specify
       a version for the individual sources, the latter will be set as the resulting version  for  this  module.
       This will also be used in the ECMFindQmlModule module.

       If the option <b>NO_PLUGIN</b> is set, a target is declared that is not expected to contain any C++ QML plugin.

       If  the  optional  <b>CLASSNAME</b>  argument is supplied, it will be used as class name in the generated QMLDIR
       file. If it is not specified, the target name will be used instead.

       You can add C++ and QML source files to  the  target  using  <b>target_sources</b>  and  <b>ecm_target_qml_sources</b>,
       respectively.

       Since 5.91.0

       Since  6.0.0,  when  used  with Qt 6, this will forward to <b>qt_add_qml_module</b>. Any extra arguments will be
       forwarded as well. The <b>NO_PLUGIN</b> argument is deprecated and implies <b>GENERATE_PLUGIN_SOURCE</b>, since modules
       in Qt 6 always require a plugin or backing target. If you want to use Qt’s behaviour for  <b>NO_PLUGIN</b>,  use
       <b>QT_NO_PLUGIN</b>   instead.   Additionally,   to   maintain   backward  compatibility,  by  default  we  pass
       <b>NO_GENERATE_PLUGIN_SOURCE</b> to <b>qt_add_qml_module</b>.

       If you are using the executable as backing target for  your  QML  module,  the  default  behavior  should
       suffice. If you are using a separate QML module, you will need to have Qt generate the plugin sources, in
       which case you should pass <b>GENERATE_PLUGIN_SOURCE</b>.

       The  <b>DEPENDENCIES</b> and <b>IMPORTS</b> options come from <b>qt_add_qml_module()</b> since Qt 6, and behave as in upstream
       Qt.

       Use <b>DEPENDENCIES</b> for things like “QtCore”,  “QtQuick”,  “your.custom.qmlmodule”,  as  well  as  C++  only
       dependencies.  This  is  required for QML-exposed C++ code, like when subclassing a type or using it as a
       parameter type in properties and invokables.

       Use <b>IMPORTS</b> to make a type available a part of a module’s public interface. In other words, if a QML file
       imports this module, it also imports all the modules listed under IMPORTS.

       See <u>Declaring</u> <u>module</u> <u>dependencies</u> and <u>10</u> <u>Tips</u> <u>to</u> <u>Make</u> <u>Your</u> <u>QML</u> <u>Code</u>  <u>Faster</u>  <u>and</u>  <u>More</u>  <u>Maintainable</u>  for
       details.

          ecm_add_qml_module_dependencies(&lt;target&gt; DEPENDS &lt;module string&gt; [&lt;module string&gt; ...])

       Adds  the  list  of  dependencies  specified  by the <b>DEPENDS</b> argument to be listed as dependencies in the
       generated QMLDIR file of <b>&lt;target&gt;</b>.

       Since 5.91.0

       Since 6.0.0, this is deprecated and ignored when using Qt 6, instead use  the  <b>DEPENDENCIES</b>  and  <b>IMPORTS</b>
       arguments to <b>ecm_add_qml_module</b>.

          ecm_target_qml_sources(&lt;target&gt; SOURCES &lt;source.qml&gt; [&lt;source.qml&gt; ...] [VERSION &lt;version&gt;] [PATH &lt;path&gt;] [PRIVATE])

       Adds  the  list  of  QML files specified by the <b>SOURCES</b> argument as source files to the QML module target
       <b>&lt;target&gt;</b>.

       If the optional <b>VERSION</b> argument is specified, all QML files will be added with the specified version. If
       it is not specified, they will use the version of the QML module target.

       If the optional <b>PRIVATE</b> argument is specified, the QML files will be included in the target  but  not  in
       the generated qmldir file. Any version argument will be ignored.

       The  optional <b>PATH</b> argument declares a subdirectory of the module where the files should be copied to. By
       default, files will be copied to the module root.

       This function will fail if <b>&lt;target&gt;</b> is not a QML module target or any  of  the  specified  files  do  not
       exist.

       Since 5.91.0

       Since  6.0.0,  when  used  with Qt 6, this will forward to <b>qt_target_qml_sources()</b>.  The <b>SOURCES</b> argument
       will be translated  to  <b>QML_SOURCES</b>.  <b>VERSION</b>  and  <b>PRIVATE</b>  will  set  Qt’s  <b>QT_QML_SOURCE_VERSIONS</b>  and
       <b>QT_QML_INTERNAL_TYPE</b>  properties on <b>SOURCES</b> before calling <b>qt_target_qml_sources()</b>. Since Qt includes the
       path relative to the current source dir, for each source file a resource alias will be generated with the
       path stripped. If the <b>PATH</b> argument is set, it will be prefixed to the alias.  Any  additional  arguments
       will be passed to <b>qt_target_qml_sources()</b>.

          ecm_finalize_qml_module(&lt;target&gt;
              [DESTINATION &lt;QML install destination&gt;] # Optional since 6.0
              [VERSION &lt;Project Version&gt;] # Added for 6.0 when using Qt 6
              [EXPORT &lt;export-set&gt;] # Added for 6.8 when using Qt 6
          )

       Finalizes the specified QML module target.

       This is required in case you do not use the executable as backing target.

       This  must  be  called  after  all other setup (like adding sources) on the target has been done. It will
       perform a number of tasks:

       • It will generate a qmldir file from the QML files added to the target. If the module has a C++  plugin,
         this will also be included in the qmldir file.

       • If  <b>BUILD_SHARED_LIBS</b>  is off, a QRC file is generated from the QML files added to the target. This QRC
         file will be included when compiling the C++ QML module. The built static library will be installed  in
         a   subdirectory   of  <b>DESTINATION</b>  based  on  the  QML  module’s  URI.  If  this  value  is  not  set,
         KDE_INSTALL_QMLDIR will be used. Note that if <b>NO_PLUGIN</b> is set, a C++ QML plugin will be  generated  to
         include the QRC files.

       • If  <b>BUILD_SHARED_LIBS</b> is on, all generated files, QML sources and the C++ plugin will be installed in a
         subdirectory of <b>DESTINATION</b> based on the QML module’s URI. In addition, these files will also be copied
         to the target’s <b>RUNTIME_OUTPUT_DIRECTORY</b> in a similar subdirectory.

       • If <b>BUILD_SHARED_LIBS</b> is off, <b>EXPORT</b> allows to specify a CMake export set all installed  targets  should
         be added to.

       This function will fail if <b>&lt;target&gt;</b> is not a QML module target.

       Since 5.91.0

       Since  6.0.0,  when  using  Qt 6, this will instead install the files generated by <b>qt_add_qml_module</b>. The
       optional <b>VERSION</b> argument was added that will default to <b>PROJECT_VERSION</b> and which will write a file that
       is used by <b>ECMFindQmlModule</b> to detect the version of the QML module.

       Since 6.1.0

       Enabling the global option <b>VERBOSE_QML_COMPILER</b> during CMake configuration will activate  verbose  output
       for qmlcachegen.

   <b>ECMQtDeclareLoggingCategory</b>
       This module provides the <b>ecm_qt_declare_logging_category</b> function for generating declarations for logging
       categories  in  Qt5,  and  the <b>ecm_qt_install_logging_categories</b> function for generating and installing a
       file in KDebugSettings format with the info about all those categories, as well as a file with info about
       any renamed categories if defined.  To include in that file any  logging  categories  that  are  manually
       defined also a function <b>ecm_qt_export_logging_category</b> is provided.

          ecm_qt_declare_logging_category(&lt;sources_var_name(|target (since 5.80))&gt;
              HEADER &lt;filename&gt;
              IDENTIFIER &lt;identifier&gt;
              CATEGORY_NAME &lt;category_name&gt;
              [OLD_CATEGORY_NAMES &lt;oldest_cat_name&gt; [&lt;second_oldest_cat_name&gt; [...]]]
              [DEFAULT_SEVERITY &lt;Debug|Info|Warning|Critical|Fatal&gt;]
              [EXPORT &lt;exportid&gt;]
              [DESCRIPTION &lt;description&gt;]
          )

       A header file, <b>&lt;filename&gt;</b>, will be generated along with a corresponding source file. These will provide a
       QLoggingCategory  category that can be referred to from C++ code using <b>&lt;identifier&gt;</b>, and from the logging
       configuration using <b>&lt;category_name&gt;</b>.

       The generated source file will be added to the variable with the name <b>&lt;sources_var_name&gt;</b>.  If  the  given
       argument is a target though, instead both the generated header file and the generated source file will be
       added to the target as private sources (since 5.80). The target must not be an alias.

       If <b>&lt;filename&gt;</b> is not absolute, it will be taken relative to the current binary directory.

       <b>&lt;identifier&gt;</b> may include namespaces (eg: <b>foo::bar::IDENT</b>).

       If  <b>EXPORT</b>  is  passed,  the  category  will  be  registered  for the group id <b>&lt;exportid&gt;</b>. Info about the
       categories of that group can then be generated in a  file  and  installed  by  that  group  id  with  the
       <b>ecm_qt_install_logging_categories</b>  function.  In  that case also <b>DESCRIPTION</b> will need to be passed, with
       <b>&lt;description&gt;</b> being a short single line text.  And <b>OLD_CATEGORY_NAMES</b> can be used  to  inform  about  any
       renamings of the category, so user settings can be migrated. Since 5.68.0.

       Since 5.14.0.

          ecm_qt_export_logging_category(
              IDENTIFIER &lt;identifier&gt;
              CATEGORY_NAME &lt;category_name&gt;
              [OLD_CATEGORY_NAMES &lt;oldest_category_name&gt; [&lt;second_oldest_category_name&gt; [...]]]
              EXPORT &lt;exportid&gt;
              DESCRIPTION &lt;description&gt;
              [DEFAULT_SEVERITY &lt;Debug|Info|Warning|Critical|Fatal&gt;]
          )

       Registers  a  logging category for being included in the generated and installed KDebugSettings files. To
       be used for categories who are declared by manual code or other  ways  instead  of  code  generated  with
       <b>ecm_qt_declare_logging_category</b>.

       <b>&lt;identifier&gt;</b> may include namespaces (eg: <b>foo::bar::IDENT</b>).

       <b>EXPORT</b>  specifies  the group id with which the category will be registered.  Info about the categories of
       that  group  can  then  be  generated  in  a  file  and   installed   by   that   group   id   with   the
       <b>ecm_qt_install_logging_categories</b> function.

       <b>DESCRIPTION</b> specifies a short single line text describing the category.

       <b>OLD_CATEGORY_NAMES</b>  can  be  used  to inform about any renamings of the category, so user settings can be
       migrated.

       Since 5.68.0.

          ecm_qt_install_logging_categories(
              EXPORT &lt;exportid&gt;
              [FILE &lt;filename&gt;]
              DESTINATION &lt;install_path&gt;
              [SORT]
              [COMPONENT &lt;component&gt;]
          )

       Generates and installs a file in KDebugSettings format with the info about all the categories  registered
       for the group <b>&lt;exportid&gt;</b>, as well as a file with info about any renamed categories, if there are.

       The  method  call  needs  to  be  after the last <b>ecm_qt_declare_logging_category</b> call which uses the same
       <b>&lt;exportid&gt;</b>. This can be in the same directory, or any subdirectory or parent directory.

       <b>EXPORT</b> specifies the group id of categories whose information should be stored in the file generated  and
       installed.

       <b>FILE</b>  specifies  the  name  of  the  file  generated  and  installed.  It  will  default  to  lower-cased
       <b>&lt;exportid&gt;.categories</b>. The name of the file with info about renamed categories will use  the  same  final
       base name and the suffix <b>.renamecategories</b>. Note: Before 5.113, the base name should not have any further
       <b>.</b> in the name, as its end would be defined by that.

       <b>DESTINATION</b> specifies where the generated file will be installed.

       IF <b>SORT</b> is set, entries will be sorted by identifiers.

       <b>COMPONENT</b>  specifies  the installation component name with which the install rules for the generated file
       are associated.

       Since 5.85.0 this is a no-op when building for Android,  as  KDebugSettings  is  not  available  on  that
       platform and the logging category files therefore just bloat the APK.

       Example usage:

          ecm_qt_declare_logging_category(
              MYPROJECT_SRCS
              HEADER "myproject_debug.h"
              IDENTIFIER "MYPROJECT_DEBUG"
              CATEGORY_NAME "myproject"
              OLD_CATEGORY_NAMES "myprojectlog"
              DESCRIPTION "My project"
              EXPORT MyProject
          )

          ecm_qt_export_logging_category(
              IDENTIFIER "MYPROJECT_SUBMODULE_DEBUG"
              CATEGORY_NAME "myproject.submodule"
              DESCRIPTION "My project - submodule"
              EXPORT MyProject
          )

          ecm_qt_install_logging_categories(
              EXPORT MyProject
              FILE myproject.categories
              DESTINATION "${KDE_INSTALL_LOGGINGCATEGORIESDIR}"
          )

       Since 5.68.0.

   <b>ECMQueryQt</b>
       This module can be used to query the installation paths used by Qt.

       For  Qt5  this  uses  <b>qmake</b>,  and for Qt6 this used <b>qtpaths</b> (the latter has built-in support to query the
       paths of a target platform when cross-compiling).

       This module defines the following function:

          ecm_query_qt(&lt;result_variable&gt; &lt;qt_variable&gt; [TRY])

       Passing <b>TRY</b> will result in the method not making the build fail if the executable used for  querying  has
       not been found, but instead simply print a warning message and return an empty string.

       Example usage:

          include(ECMQueryQt)
          ecm_query_qt(bin_dir QT_INSTALL_BINS)

       If the call succeeds <b>${bin_dir}</b> will be set to <b>&lt;prefix&gt;/path/to/bin/dir</b> (e.g.  <b>/usr/lib64/qt/bin/</b>).

       Since: 5.93

   <b>ECMSetupQtPluginMacroNames</b>
       Instruct CMake’s automoc about C++ preprocessor macros used to define Qt-style plugins.

          ecm_setup_qtplugin_macro_names(
              [JSON_NONE &lt;macro_name&gt; [&lt;macro_name&gt; [...]]]
              [JSON_ARG1 &lt;macro_name&gt; [&lt;macro_name&gt; [...]]]
              [JSON_ARG2 &lt;macro_name&gt; [&lt;macro_name&gt; [...]]]
              [JSON_ARG3 &lt;macro_name&gt; [&lt;macro_name&gt; [...]]]
              [CONFIG_CODE_VARIABLE &lt;variable_name&gt;] )

       CMake’s  automoc  needs some support when parsing C++ source files to detect whether moc should be run on
       those files and if there are also dependencies on other files, like those with Qt plugin metadata in JSON
       format.  Because  automoc  just  greps  overs  the  raw  plain  text  of  the  sources  without  any  C++
       preprocessor-like     processing.      CMake     in     newer    versions    provides    the    variables
       <b>CMAKE_AUTOMOC_DEPEND_FILTERS</b> (CMake &gt;= 3.9.0) and <b>CMAKE_AUTOMOC_MACRO_NAMES</b> (CMake &gt;= 3.10) to allow  the
       developer to assist automoc.

       This  macro  cares for the explicit setup needed for those variables for common cases of C++ preprocessor
       macros used for Qt-style plugins.

       <b>JSON_NONE</b> lists the names of C++ preprocessor macros for Qt-style plugins which do not refer to  external
       files with the plugin metadata.

       <b>JSON_ARG1</b> lists the names of C++ preprocessor macros for Qt-style plugins where the first argument to the
       macro is the name of the external file with the plugin metadata.

       <b>JSON_ARG2</b> is the same as <b>JSON_ARG1</b> but with the file name being the second argument.

       <b>JSON_ARG3</b> is the same as <b>JSON_ARG1</b> but with the file name being the third argument.

       <b>CONFIG_CODE_VARIABLE</b>  specifies the name of the variable which will get set as value some generated CMake
       code for instructing automoc for the given macro names, as useful in an installed CMake config file.  The
       variable  can  then  be  used  as  usual  in  the  template  file  for  such  a  CMake  config  file,  by
       <b>@&lt;variable_name&gt;@</b>.

       Example usage:

       Given  some  plugin-oriented  Qt-based  software  which  defines  a   custom   C++   preprocessor   macro
       <b>EXPORT_MYPLUGIN</b> for declaring the central plugin object:

          #define EXPORT_MYPLUGIN_WITH_JSON(classname, jsonFile) \
          class classname : public QObject \
          { \
              Q_OBJECT \
              Q_PLUGIN_METADATA(IID "myplugin" FILE jsonFile) \
              explicit classname() {} \
          };

       In the CMake buildsystem of the library one calls

          ecm_setup_qtplugin_macro_names(
              JSON_ARG2
                 EXPORT_MYPLUGIN_WITH_JSON
          )

       to instruct automoc about the usage of that macro in the sources of the library itself.

       Given  the  software installs a library including the header with the macro definition and a CMake config
       file, so 3rd-party can create additional plugins by linking against the library, one passes  additionally
       the  name  of  a variable which shall be set as value the CMake code needed to instruct automoc about the
       usage of that macro.

          ecm_setup_qtplugin_macro_names(
              JSON_ARG2
                 EXPORT_MYPLUGIN_WITH_JSON
              CONFIG_CODE_VARIABLE
                 PACKAGE_SETUP_AUTOMOC_VARIABLES
          )

       This variable then is used in  the  template  file  (e.g.   <b>MyProjectConfig.cmake.in</b>)  for  the  libary’s
       installed  CMake  config file and that way will ensure that in the 3rd-party plugin’s buildsystem automoc
       is instructed as well as needed:

          @PACKAGE_SETUP_AUTOMOC_VARIABLES@

       Since 5.45.0.

   <b>ECMSetupVersion</b>
       Handle library version information.

          ecm_setup_version(&lt;version&gt;
                            VARIABLE_PREFIX &lt;prefix&gt;
                            [SOVERSION &lt;soversion&gt;]
                            [VERSION_HEADER &lt;filename&gt;]
                            [PACKAGE_VERSION_FILE &lt;filename&gt; [COMPATIBILITY &lt;compat&gt;]] )

       This parses a version string and sets up a standard set of version variables.   It  can  optionally  also
       create a C version header file and a CMake package version file to install along with the library.

       If  the  <b>&lt;version&gt;</b>  argument is of the form <b>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</b> (or <b>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;.&lt;tweak&gt;</b>),
       The following CMake variables are set:

          &lt;prefix&gt;_VERSION_MAJOR  - &lt;major&gt;
          &lt;prefix&gt;_VERSION_MINOR  - &lt;minor&gt;
          &lt;prefix&gt;_VERSION_PATCH  - &lt;patch&gt;
          &lt;prefix&gt;_VERSION        - &lt;version&gt;
          &lt;prefix&gt;_SOVERSION      - &lt;soversion&gt;, or &lt;major&gt; if SOVERSION was not given

       For backward-compatibility also this variable is set (only if the minimum required version of  ECM  is  &lt;
       5.83):

          &lt;prefix&gt;_VERSION_STRING - &lt;version&gt; (use &lt;prefix&gt;_VERSION instead)

       With  CMake  versions  older  than  4.0.0  and  if  CMake  policy CMP0048 is not <b>NEW</b>, the following CMake
       variables will also be set:

          PROJECT_VERSION_MAJOR   - &lt;major&gt;
          PROJECT_VERSION_MINOR   - &lt;minor&gt;
          PROJECT_VERSION_PATCH   - &lt;patch&gt;
          PROJECT_VERSION         - &lt;version&gt;

       For backward-compatibility, if CMake policy CMP0048 is not <b>NEW</b>, also this variable is set  (only  if  the
       minimum required version of ECM is &lt; 5.83):

          PROJECT_VERSION_STRING  - &lt;version&gt; (use PROJECT_VERSION instead)

       If the <b>VERSION_HEADER</b> option is used, a simple C header is generated with the given filename. If filename
       is  a  relative  path,  it  is interpreted as relative to <b>CMAKE_CURRENT_BINARY_DIR</b>.  The generated header
       contains the following macros:

          &lt;prefix&gt;_VERSION_MAJOR  - &lt;major&gt; as an integer
          &lt;prefix&gt;_VERSION_MINOR  - &lt;minor&gt; as an integer
          &lt;prefix&gt;_VERSION_PATCH  - &lt;patch&gt; as an integer
          &lt;prefix&gt;_VERSION_STRING - &lt;version&gt; as a C string
          &lt;prefix&gt;_VERSION        - the version as an integer

       <b>&lt;prefix&gt;_VERSION</b> has <b>&lt;patch&gt;</b> in the bottom 8 bits, <b>&lt;minor&gt;</b>  in  the  next  8  bits  and  <b>&lt;major&gt;</b>  in  the
       remaining bits.  Note that <b>&lt;patch&gt;</b> and <b>&lt;minor&gt;</b> must be less than 256.

       If  the  <b>PACKAGE_VERSION_FILE</b>  option  is  used, a simple CMake package version file is created using the
       <b>write_basic_package_version_file()</b> macro provided by CMake. It should be installed in the  same  location
       as  the Config.cmake file of the library so that it can be found by <b>find_package()</b>.  If the filename is a
       relative path, it is interpreted as relative  to  <b>CMAKE_CURRENT_BINARY_DIR</b>.  The  optional  <b>COMPATIBILITY</b>
       option is forwarded to <b>write_basic_package_version_file()</b>, and defaults to <b>AnyNewerVersion</b>.

       With  CMake  versions  &gt;=  4.0.0 or if CMake policy CMP0048 is <b>NEW</b>, an alternative form of the command is
       available:

          ecm_setup_version(PROJECT
                            [VARIABLE_PREFIX &lt;prefix&gt;]
                            [SOVERSION &lt;soversion&gt;]
                            [VERSION_HEADER &lt;filename&gt;]
                            [PACKAGE_VERSION_FILE &lt;filename&gt;] )

       This will use the version information set by the <b>project()</b>  command.   <b>VARIABLE_PREFIX</b>  defaults  to  the
       project  name.  Note that <b>PROJECT</b> must be the first argument.  In all other respects, it behaves like the
       other form of the command.

       Since pre-1.0.0.

       <b>COMPATIBILITY</b> option available since 1.6.0.

   <b>ECMSourceVersionControl</b>
       Tries to determine whether the source is under version control (git clone, svn checkout, etc).

       <b>ECM_SOURCE_UNDER_VERSION_CONTROL</b> is set when indication is found that <b>CMAKE_SOURCE_DIR</b> is  under  version
       control.

       Since 5.63

   <b>ECMUninstallTarget</b>
       Add an <b>uninstall</b> target.

       By  including  this module, an <b>uninstall</b> target will be added to your CMake project. This will remove all
       files installed (or updated) by a previous invocation of the <b>install</b> target. It  will  not  remove  files
       created  or  modified  by  an  <b>install(SCRIPT)</b>  or  <b>install(CODE)</b>  command;  you  should  create a custom
       uninstallation target for these and use <b>add_dependency</b> to make the <b>uninstall</b> target depend on it:

          include(ECMUninstallTarget)
          install(SCRIPT install-foo.cmake)
          add_custom_target(uninstall_foo COMMAND ${CMAKE_COMMAND} -P uninstall-foo.cmake)
          add_dependency(uninstall uninstall_foo)

       The target will fail if the <b>install</b> target has not yet been run (so it is not possible to  run  CMake  on
       the project and then immediately run the <b>uninstall</b> target).

       <b>WARNING:</b>
          CMake deliberately does not provide an <b>uninstall</b> target by default on the basis that such a target has
          the potential to remove important files from a user’s computer. Use with caution.

       Since 1.7.0.

   <b>ECMUseFindModules</b>
       Selectively use some of the find modules provided by extra-cmake-modules.

       This module is automatically available once extra-cmake-modules has been found, so it is not necessary to
       <b>include(ECMUseFindModules)</b> explicitly.

          ecm_use_find_modules(DIR &lt;dir&gt;
                               MODULES module1.cmake [module2.cmake [...]]
                               [NO_OVERRIDE])

       This allows selective use of the find modules provided by ECM, including deferring to CMake’s versions of
       those  modules  if  it has them.  Rather than adding <b>${ECM_FIND_MODULE_DIR}</b> to <b>CMAKE_MODULE_PATH</b>, you use
       <b>ecm_use_find_modules()</b> to copy the modules you want to  a  local  (build)  directory,  and  add  that  to
       <b>CMAKE_MODULE_PATH</b>.

       The  find  modules given to <b>MODULES</b> will be copied to the directory given by <b>DIR</b> (which should be located
       in <b>${CMAKE_BINARY_DIR}</b> and added to <b>CMAKE_MODULE_PATH</b>).  If <b>NO_OVERRIDE</b> is given, only modules  not  also
       provided by CMake will be copied.

       Example:

          find_package(ECM REQUIRED)
          ecm_use_find_modules(
              DIR ${CMAKE_BINARY_DIR}/cmake
              MODULES FindEGL.cmake
              NO_OVERRIDE
          )
          set(CMAKE_MODULE_PATH ${CMAKE_BINARY_DIR}/cmake)

       This example will make <b>FindEGL.cmake</b> available in your project, but only as long as it is not yet part of
       CMake.  Calls  to  <b>find_package(EGL)</b>  will then make use of this copied module (or the CMake module if it
       exists).

       Another possible use for this macro is to take copies of find modules that can be  installed  along  with
       config  files  if  they are required as a dependency (for example, if targets provided by the find module
       are in the link interface of a library).

       Since pre-1.0.0.

   <b>ECMWinResolveSymlinks</b>
       Resolve pseudo-symlinks created by git when cloning on Windows.

          ecm_win_resolve_symlinks(&lt;dir&gt;)

       When git checks out a repository with UNIX symlinks on Windows machine, it creates a text file  for  each
       symlink,  containing  a  relative  path  to  the  real  file.   This function would recursively walk over
       specified directory and replace pseudo-symlinks with corresponding real file’s contents.  It  would  then
       run <b>git</b> <b>update-index</b> <b>--assume-unchanged</b> on them to trick git.

       This  is  useful  for  projects  like  “breeze-icons”  that  contain  many identical icons implemented as
       symlinks.

       Since 5.28

   <b>QtVersionOption</b>
       Adds a build option to select the major Qt version if necessary, that is, if the major Qt version has not
       yet been determined otherwise (e.g. by a corresponding <b>find_package()</b> call).  This  module  is  typically
       included by other modules requiring knowledge about the major Qt version.

       If  the  ECM version passed to find_package was at least 5.240.0 Qt6 is picked by default.  Otherwise Qt5
       is picked.

       <b>QT_MAJOR_VERSION</b> is defined to either be “5” or “6”.

       Since 5.82.0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man7/ecm.7.html">ecm</a>(7)</u>, <u><a href="../man7/ecm-find-modules.7.html">ecm-find-modules</a>(7)</u>, <u><a href="../man7/ecm-kde-modules.7.html">ecm-kde-modules</a>(7)</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       KDE Developers

6.17                                              Aug 08, 2025                                    <u><a href="../man7/ECM-MODULES.7.html">ECM-MODULES</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>