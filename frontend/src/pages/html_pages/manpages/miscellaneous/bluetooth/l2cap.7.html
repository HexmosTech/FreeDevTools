<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>l2cap - L2CAP protocol</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbluetooth-dev">libbluetooth-dev_5.83-1~exp1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       l2cap - L2CAP protocol

</pre><h4><b>SYNOPSIS</b></h4><pre>
          #include &lt;sys/socket.h&gt;
          #include &lt;bluetooth/bluetooth.h&gt;
          #include &lt;bluetooth/l2cap.h&gt;

          l2cap_socket = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       L2CAP is a protocol that provides an interface for higher-level protocols to send and receive data over a
       Bluetooth  connection.  L2CAP sits on top of the Bluetooth Host Controller Interface (HCI) and provides a
       set of channels that can be used by higher-level protocols to transmit data.

       L2CAP provides a number of services to higher-level protocols, including segmentation and  reassembly  of
       large  data packets and flow control to prevent overloading of the receiver. L2CAP also supports multiple
       channels per connection, allowing for concurrent data transmission using different protocols.

</pre><h4><b>SOCKET</b> <b>ADDRESS</b></h4><pre>
          struct sockaddr_l2 {
              sa_family_t     l2_family;
              unsigned short  l2_psm;
              bdaddr_t        l2_bdaddr;
              unsigned short  l2_cid;
              uint8_t         l2_bdaddr_type;
          };

       Example:

          struct sockaddr_l2 addr;

          memset(&amp;addr, 0, sizeof(addr));
          addr.l2_family = AF_BLUETOOTH;
          bacpy(&amp;addr.l2_bdaddr, bdaddr);

          if (cid)
              addr.l2_cid = htobs(cid);
          else
              addr.l2_psm = htobs(psm);

          addr.l2_bdaddr_type = bdaddr_type;

</pre><h4><b>SOCKET</b> <b>OPTIONS</b></h4><pre>
       The socket options listed below can be set by using <b><a href="../man2/setsockopt.2.html">setsockopt</a>(2)</b> and read with  <b><a href="../man2/getsockopt.2.html">getsockopt</a>(2)</b>  with  the
       socket level set to SOL_BLUETOOTH.

   <b>BT_SECURITY</b> <b>(since</b> <b>Linux</b> <b>2.6.30)</b>
       Channel security level, possible values:
                ┌────────────────────┬──────────────────────┬────────────────────────┬──────────────┐
                │ Value              │ Security Level       │ Link Key Type          │ Encryption   │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_SDP</b>    │ 0 (SDP Only)         │ None                   │ Not required │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_LOW</b>    │ 1 (Low)              │ Unauthenticated        │ Not required │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_MEDIUM</b> │ 2 (Medium - default) │ Unauthenticated        │ Desired      │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_HIGH</b>   │ 3 (High)             │ Authenticated          │ Required     │
                ├────────────────────┼──────────────────────┼────────────────────────┼──────────────┤
                │ <b>BT_SECURITY_FIPS</b>   │ 4 (Secure Only)      │ Authenticated   (P-256 │ Required     │
                │ (since Linux 3.15) │                      │ based  Secure   Simple │              │
                │                    │                      │ Pairing   and   Secure │              │
                │                    │                      │ Authentication)        │              │
                └────────────────────┴──────────────────────┴────────────────────────┴──────────────┘

       Example:

          int level = BT_SECURITY_HIGH;
          int err = setsockopt(l2cap_socket, SOL_BLUETOOTH, BT_SECURITY, &amp;level,
                               sizeof(level));
          if (err == -1) {
              perror("setsockopt");
              return 1;
          }

   <b>BT_DEFER_SETUP</b> <b>(since</b> <b>Linux</b> <b>2.6.30)</b>
       Channel defer connection setup, this control if the  connection  procedure  needs  to  be  authorized  by
       userspace before responding which allows authorization at profile level, possible values:
                                    ┌───────┬───────────────────┬───────────────┐
                                    │ Value │ Description       │ Authorization │
                                    ├───────┼───────────────────┼───────────────┤
                                    │ <b>0</b>     │ Disable (default) │ Not required  │
                                    ├───────┼───────────────────┼───────────────┤
                                    │ <b>1</b>     │ Enable            │ Required      │
                                    └───────┴───────────────────┴───────────────┘

       Example:

          int defer_setup = 1;
          int err = setsockopt(l2cap_socket, SOL_BLUETOOTH, BT_DEFER_SETUP,
                               &amp;defer_setup, sizeof(defer_setup));
          if (err == -1) {
              perror("setsockopt");
              return err;
          }

          err = listen(l2cap_socket, 5);
          if (err) {
              perror("listen");
              return err;
          }

          struct sockaddr_l2 remote_addr = {0};
          socklen_t addr_len = sizeof(remote_addr);
          int new_socket = accept(l2cap_socket, (struct sockaddr*)&amp;remote_addr,
                                  &amp;addr_len);
          if (new_socket &lt; 0) {
              perror("accept");
              return new_socket;
          }

          /* To complete the connection setup of new_socket read 1 byte */
          char c;
          struct pollfd pfd;

          memset(&amp;pfd, 0, sizeof(pfd));
          pfd.fd = new_socket;
          pfd.events = POLLOUT;

          err = poll(&amp;pfd, 1, 0);
          if (err) {
              perror("poll");
              return err;
          }

          if (!(pfd.revents &amp; POLLOUT)) {
              err = read(sk, &amp;c, 1);
              if (err &lt; 0) {
                  perror("read");
                  return err;
              }
          }

   <b>BT_FLUSHABLE</b> <b>(since</b> <b>Linux</b> <b>2.6.39)</b>
       Channel flushable flag, this control if the channel data can be flushed or not, possible values:
                              ┌──────────────────┬────────────────┬───────────────────┐
                              │ Define           │ Value          │ Description       │
                              ├──────────────────┼────────────────┼───────────────────┤
                              │ <b>BT_FLUSHABLE_OFF</b> │ 0x00 (default) │ Do not flush data │
                              ├──────────────────┼────────────────┼───────────────────┤
                              │ <b>BT_FLUSHABLE_ON</b>  │ 0x01           │ Flush data        │
                              └──────────────────┴────────────────┴───────────────────┘

   <b>BT_POWER</b> <b>(since</b> <b>Linux</b> <b>3.1)</b>
       Channel power policy, this control if the channel shall force exit of sniff mode or not, possible values:
                    ┌───────────────────────────┬────────────────┬──────────────────────────────┐
                    │ Define                    │ Value          │ Description                  │
                    ├───────────────────────────┼────────────────┼──────────────────────────────┤
                    │ <b>BT_POWER_FORCE_ACTIVE_OFF</b> │ 0x00           │ Don't  force  exit  of sniff │
                    │                           │                │ mode                         │
                    ├───────────────────────────┼────────────────┼──────────────────────────────┤
                    │ <b>BT_POWER_FORCE_ACTIVE_ON</b>  │ 0x01 (default) │ Force exit of sniff mode     │
                    └───────────────────────────┴────────────────┴──────────────────────────────┘

   <b>BT_CHANNEL_POLICY</b> <b>(since</b> <b>Linux</b> <b>3.10)</b>
       High-speed (AMP) channel policy, possible values:
                        ┌───────────────────────────────────┬─────────────┬──────────────────┐
                        │ Define                            │ Value       │ Description      │
                        ├───────────────────────────────────┼─────────────┼──────────────────┤
                        │ <b>BT_CHANNEL_POLICY_BREDR_ONLY</b>      │ 0 (default) │ BR/EDR only      │
                        ├───────────────────────────────────┼─────────────┼──────────────────┤
                        │ <b>BT_CHANNEL_POLICY_BREDR_PREFERRED</b> │ 1           │ BR/EDR Preferred │
                        ├───────────────────────────────────┼─────────────┼──────────────────┤
                        │ <b>BT_CHANNEL_POLICY_BREDR_PREFERRED</b> │ 2           │ AMP Preferred    │
                        └───────────────────────────────────┴─────────────┴──────────────────┘

   <b>BT_PHY</b> <b>(since</b> <b>Linux</b> <b>5.10)</b>
       Channel supported PHY(s), possible values:
                                  ┌────────────────────┬────────┬─────────────────┐
                                  │ Define             │ Value  │ Description     │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_1M_1SLOT</b> │ BIT 0  │ BR 1Mbps 1SLOT  │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_1M_3SLOT</b> │ BIT 1  │ BR 1Mbps 3SLOT  │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_1M_5SLOT</b> │ BIT 2  │ BR 1Mbps 5SLOT  │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_2M_1SLOT</b> │ BIT 3  │ EDR 2Mbps 1SLOT │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_2M_3SLOT</b> │ BIT 4  │ EDR 2Mbps 3SLOT │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_2M_5SLOT</b> │ BIT 5  │ EDR 2Mbps 5SLOT │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_3M_1SLOT</b> │ BIT 6  │ EDR 3Mbps 1SLOT │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_3M_3SLOT</b> │ BIT 7  │ EDR 3Mbps 3SLOT │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_BR_3M_5SLOT</b> │ BIT 8  │ EDR 3Mbps 5SLOT │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_LE_1M_TX</b>    │ BIT 9  │ LE 1Mbps TX     │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_LE_1M_RX</b>    │ BIT 10 │ LE 1Mbps RX     │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_LE_2M_TX</b>    │ BIT 11 │ LE 2Mbps TX     │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_LE_2M_RX</b>    │ BIT 12 │ LE 2Mbps RX     │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_LE_CODED_TX</b> │ BIT 13 │ LE Coded TX     │
                                  ├────────────────────┼────────┼─────────────────┤
                                  │ <b>BT_PHY_LE_CODED_RX</b> │ BIT 14 │ LE Coded RX     │
                                  └────────────────────┴────────┴─────────────────┘

   <b>BT_MODE</b> <b>(since</b> <b>Linux</b> <b>5.10)</b>
       Channel Mode, possible values:
                      ┌─────────────────────┬────────────────┬────────────────────────┬────────┐
                      │ Define              │ Value          │ Description            │ Link   │
                      ├─────────────────────┼────────────────┼────────────────────────┼────────┤
                      │ <b>BT_MODE_BASIC</b>       │ 0x00 (default) │ Basic mode             │ Any    │
                      ├─────────────────────┼────────────────┼────────────────────────┼────────┤
                      │ <b>BT_MODE_ERTM</b>        │ 0x01           │ Enhanced               │ BR/EDR │
                      │                     │                │ Retransmission mode    │        │
                      ├─────────────────────┼────────────────┼────────────────────────┼────────┤
                      │ <b>BT_MODE_STREAM</b>      │ 0x02           │ Stream mode            │ BR/EDR │
                      ├─────────────────────┼────────────────┼────────────────────────┼────────┤
                      │ <b>BT_MODE_LE_FLOWCTL</b>  │ 0x03           │ Credit   based    flow │ LE     │
                      │                     │                │ control mode           │        │
                      ├─────────────────────┼────────────────┼────────────────────────┼────────┤
                      │ <b>BT_MODE_EXT_FLOWCTL</b> │ 0x04           │ Extended  Credit based │ Any    │
                      │                     │                │ flow control mode      │        │
                      └─────────────────────┴────────────────┴────────────────────────┴────────┘

</pre><h4><b>RESOURCES</b></h4><pre>
        &lt;<a href="http://www.bluez.org">http://www.bluez.org</a>&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
        &lt;<a href="mailto:linux-bluetooth@vger.kernel.org">linux-bluetooth@vger.kernel.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man7/socket.7.html">socket</a>(7), <a href="../man1/l2test.1.html">l2test</a>(1)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Free use of this software is granted under the terms of the GNU Lesser General Public Licenses (LGPL).

BlueZ                                               May 2024                                            <u><a href="../man7/L2CAP.7.html">L2CAP</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>