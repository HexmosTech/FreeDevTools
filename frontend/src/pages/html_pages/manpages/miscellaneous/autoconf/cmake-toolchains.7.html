<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cmake-toolchains - CMake Toolchains Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cmake-data">cmake-data_3.31.6-2ubuntu4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cmake-toolchains - CMake Toolchains Reference

</pre><h4><b>INTRODUCTION</b></h4><pre>
       CMake  uses  a  toolchain of utilities to compile, link libraries and create archives, and other tasks to
       drive the build. The toolchain utilities available are determined by the  languages  enabled.  In  normal
       builds,  CMake  automatically  determines the toolchain for host builds based on system introspection and
       defaults. In cross-compiling scenarios, a toolchain file may be specified with information about compiler
       and utility paths.

       Added in version 3.19: One may use <u><a href="../man7/cmake-presets.7.html">cmake-presets</a>(7)</u> to specify toolchain files.

</pre><h4><b>LANGUAGES</b></h4><pre>
       Languages  are  enabled  by  the  <u>project()</u>  command.   Language-specific  built-in  variables,  such  as
       <u>CMAKE_CXX_COMPILER</u>,  <u>CMAKE_CXX_COMPILER_ID</u>  etc are set by invoking the <u>project()</u> command.  If no project
       command is in the top-level CMakeLists file, one will be implicitly generated.  By  default  the  enabled
       languages are <b>C</b> and <b>CXX</b>:

          project(C_Only C)

       A special value of <b>NONE</b> can also be used with the <u>project()</u> command to enable no languages:

          project(MyProject NONE)

       The <u>enable_language()</u> command can be used to enable languages after the <u>project()</u> command:

          enable_language(CXX)

       When  a  language  is enabled, CMake finds a compiler for that language, and determines some information,
       such as the vendor and version of the compiler, the target architecture and  bitwidth,  the  location  of
       corresponding utilities etc.

       The <u>ENABLED_LANGUAGES</u> global property contains the languages which are currently enabled.

</pre><h4><b>VARIABLES</b> <b>AND</b> <b>PROPERTIES</b></h4><pre>
       Several variables relate to the language components of a toolchain which are enabled:

       <u>CMAKE_&lt;LANG&gt;_COMPILER</u>
              The full path to the compiler used for <b>&lt;LANG&gt;</b>

       <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u>
              The compiler identifier used by CMake

       <u>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</u>
              The version of the compiler.

       <u>CMAKE_&lt;LANG&gt;_FLAGS</u>
              The  variables  and the configuration-specific equivalents contain flags that will be added to the
              compile command when compiling a file of a particular language.

       CMake needs a way to determine which compiler to use to invoke the linker.  This  is  determined  by  the
       <u>LANGUAGE</u> property of source files of the <u>target</u>, and in the case of static libraries, the <b>LANGUAGE</b> of the
       dependent libraries. The choice CMake makes may be overridden with the <u>LINKER_LANGUAGE</u> target property.

</pre><h4><b>TOOLCHAIN</b> <b>FEATURES</b></h4><pre>
       CMake   provides   the   <u>try_compile()</u>   command   and   wrapper   macros  such  as  <u>CheckSourceCompiles</u>,
       <u>CheckCXXSymbolExists</u> and <u>CheckIncludeFile</u> to  test  capability  and  availability  of  various  toolchain
       features.  These  APIs test the toolchain in some way and cache the result so that the test does not have
       to be performed again the next time CMake runs.

       Some toolchain features have built-in handling in CMake, and do not require compile-tests.  For  example,
       <u>POSITION_INDEPENDENT_CODE</u>  allows  specifying that a target should be built as position-independent code,
       if the compiler supports that feature. The <u>&lt;LANG&gt;_VISIBILITY_PRESET</u> and <u>VISIBILITY_INLINES_HIDDEN</u>  target
       properties add flags for hidden visibility, if supported by the compiler.

</pre><h4><b>CROSS</b> <b>COMPILING</b></h4><pre>
       If    <u><a href="../man1/cmake.1.html">cmake</a>(1)</u>   is   invoked   with   the   command   line   parameter   <u>--toolchain</u>   <u>path/to/file</u>   or
       <u>-DCMAKE_TOOLCHAIN_FILE=path/to/file</u>, the file will be loaded early to set values for the compilers.   The
       <u>CMAKE_CROSSCOMPILING</u> variable is set to true when CMake is cross-compiling.

       Note  that  using the <u>CMAKE_SOURCE_DIR</u> or <u>CMAKE_BINARY_DIR</u> variables inside a toolchain file is typically
       undesirable.  The toolchain file is used in contexts where these variables  have  different  values  when
       used in different places (e.g. as part of a call to <u>try_compile()</u>).  In most cases, where there is a need
       to   evaluate   paths   inside  a  toolchain  file,  the  more  appropriate  variable  to  use  would  be
       <u>CMAKE_CURRENT_LIST_DIR</u>, since it always has an unambiguous, predictable value.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Linux</b>
       A typical cross-compiling toolchain for Linux has content such as:

          set(CMAKE_SYSTEM_NAME Linux)
          set(CMAKE_SYSTEM_PROCESSOR arm)

          set(CMAKE_SYSROOT /home/devel/rasp-pi-rootfs)
          set(CMAKE_STAGING_PREFIX /home/devel/stage)

          set(tools /home/devel/gcc-4.7-linaro-rpi-gnueabihf)
          set(CMAKE_C_COMPILER ${tools}/bin/arm-linux-gnueabihf-gcc)
          set(CMAKE_CXX_COMPILER ${tools}/bin/arm-linux-gnueabihf-g++)

          set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
          set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
          set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

       Where:

       <u>CMAKE_SYSTEM_NAME</u>
              is the CMake-identifier of the target platform to build for.

       <u>CMAKE_SYSTEM_PROCESSOR</u>
              is the CMake-identifier of the target architecture.

       <u>CMAKE_SYSROOT</u>
              is optional, and may be specified if a sysroot is available.

       <u>CMAKE_STAGING_PREFIX</u>
              is also  optional.  It  may  be  used  to  specify  a  path  on  the  host  to  install  to.   The
              <u>CMAKE_INSTALL_PREFIX</u> is always the runtime installation location, even when cross-compiling.

       <u>CMAKE_&lt;LANG&gt;_COMPILER</u>
              variable  may  be set to full paths, or to names of compilers to search for in standard locations.
              For toolchains that do not support linking binaries without custom flags or scripts  one  may  set
              the  <u>CMAKE_TRY_COMPILE_TARGET_TYPE</u>  variable  to  <b>STATIC_LIBRARY</b>  to tell CMake not to try to link
              executables during its checks.

       CMake <b>find_*</b> commands will look in the sysroot, and the <u>CMAKE_FIND_ROOT_PATH</u> entries by  default  in  all
       cases,  as  well  as  looking  in  the  host  system  root  prefix.  Although this can be controlled on a
       case-by-case basis, when cross-compiling, it can be useful to exclude looking in either the host  or  the
       target  for  particular  artifacts.  Generally,  includes,  libraries and packages should be found in the
       target system prefixes, whereas executables which must be run as part of the build should be  found  only
       on the host and not on the target. This is the purpose of the <b>CMAKE_FIND_ROOT_PATH_MODE_*</b> variables.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>the</b> <b>Cray</b> <b>Linux</b> <b>Environment</b>
       Cross  compiling  for  compute nodes in the Cray Linux Environment can be done without needing a separate
       toolchain file.  Specifying <b>-DCMAKE_SYSTEM_NAME=CrayLinuxEnvironment</b>  on  the  CMake  command  line  will
       ensure  that  the appropriate build settings and search paths are configured.  The platform will pull its
       configuration from the current environment variables and will configure a project  to  use  the  compiler
       wrappers from the Cray Programming Environment's <b>PrgEnv-*</b> modules if present and loaded.

       The  default configuration of the Cray Programming Environment is to only support static libraries.  This
       can be overridden and shared libraries enabled by setting the <b>CRAYPE_LINK_TYPE</b>  environment  variable  to
       <b>dynamic</b>.

       Running  CMake  without  specifying <u>CMAKE_SYSTEM_NAME</u> will run the configure step in host mode assuming a
       standard Linux environment.  If not overridden, the <b>PrgEnv-*</b> compiler wrappers will end up getting  used,
       which  if  targeting  the either the login node or compute node, is likely not the desired behavior.  The
       exception to this would be if you are building directly on a NID instead of cross-compiling from a  login
       node.  If  trying  to build software for a login node, you will need to either first unload the currently
       loaded <b>PrgEnv-*</b> module or explicitly tell CMake to use the system compilers in <b><a href="file:/usr/bin">/usr/bin</a></b>  instead  of  the
       Cray  wrappers.   If  instead  targeting a compute node is desired, just specify the <u>CMAKE_SYSTEM_NAME</u> as
       mentioned above.

   <b>Cross</b> <b>Compiling</b> <b>using</b> <b>Clang</b>
       Some compilers such as Clang are inherently cross compilers.  The <u>CMAKE_&lt;LANG&gt;_COMPILER_TARGET</u> can be set
       to pass a value to those supported compilers when compiling:

          set(CMAKE_SYSTEM_NAME Linux)
          set(CMAKE_SYSTEM_PROCESSOR arm)

          set(triple arm-linux-gnueabihf)

          set(CMAKE_C_COMPILER clang)
          set(CMAKE_C_COMPILER_TARGET ${triple})
          set(CMAKE_CXX_COMPILER clang++)
          set(CMAKE_CXX_COMPILER_TARGET ${triple})

       Similarly, some compilers do not ship their own supplementary utilities such as linkers,  but  provide  a
       way  to  specify  the  location  of the external toolchain which will be used by the compiler driver. The
       <u>CMAKE_&lt;LANG&gt;_COMPILER_EXTERNAL_TOOLCHAIN</u> variable can be set in a toolchain file to pass the path to  the
       compiler driver.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>QNX</b>
       As   the   Clang   compiler   the   QNX   QCC   compile   is   inherently  a  cross  compiler.   And  the
       <u>CMAKE_&lt;LANG&gt;_COMPILER_TARGET</u> can be set to pass a value to those supported compilers when compiling:

          set(CMAKE_SYSTEM_NAME QNX)

          set(arch gcc_ntoarmv7le)

          set(CMAKE_C_COMPILER qcc)
          set(CMAKE_C_COMPILER_TARGET ${arch})
          set(CMAKE_CXX_COMPILER QCC)
          set(CMAKE_CXX_COMPILER_TARGET ${arch})

          set(CMAKE_SYSROOT $ENV{QNX_TARGET})

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Windows</b> <b>CE</b>
       Cross compiling for Windows CE requires the corresponding SDK being installed on your system.  These SDKs
       are usually installed under <b>C:/Program</b> <b>Files</b> <b>(x86)/Windows</b> <b>CE</b> <b>Tools/SDKs</b>.

       A toolchain file to configure a Visual Studio generator for Windows CE may look like this:

          set(CMAKE_SYSTEM_NAME WindowsCE)

          set(CMAKE_SYSTEM_VERSION 8.0)
          set(CMAKE_SYSTEM_PROCESSOR arm)

          set(CMAKE_GENERATOR_TOOLSET CE800) # Can be omitted for 8.0
          set(CMAKE_GENERATOR_PLATFORM SDK_AM335X_SK_WEC2013_V310)

       The <u>CMAKE_GENERATOR_PLATFORM</u> tells the generator which SDK to use.   Further  <u>CMAKE_SYSTEM_VERSION</u>  tells
       the  generator  what version of Windows CE to use.  Currently version 8.0 (Windows Embedded Compact 2013)
       is supported out of the box.  Other versions may  require  one  to  set  <u>CMAKE_GENERATOR_TOOLSET</u>  to  the
       correct value.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Windows</b> <b>10</b> <b>Universal</b> <b>Applications</b>
       A  toolchain  file  to configure <u>Visual</u> <u>Studio</u> <u>Generators</u> for a Windows 10 Universal Application may look
       like this:

          set(CMAKE_SYSTEM_NAME WindowsStore)
          set(CMAKE_SYSTEM_VERSION 10.0)

       A Windows  10  Universal  Application  targets  both  Windows  Store  and  Windows  Phone.   Specify  the
       <u>CMAKE_SYSTEM_VERSION</u> variable to be <b>10.0</b> or higher.

       CMake selects a Windows SDK as described by documentation of the <u>CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION</u>
       variable.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Windows</b> <b>Phone</b>
       A toolchain file to configure a Visual Studio generator for Windows Phone may look like this:

          set(CMAKE_SYSTEM_NAME WindowsPhone)
          set(CMAKE_SYSTEM_VERSION 8.1)

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Windows</b> <b>Store</b>
       A toolchain file to configure a Visual Studio generator for Windows Store may look like this:

          set(CMAKE_SYSTEM_NAME WindowsStore)
          set(CMAKE_SYSTEM_VERSION 8.1)

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>ADSP</b> <b>SHARC/Blackfin</b>
       Cross-compiling for ADSP SHARC or Blackfin can be configured by setting the <u>CMAKE_SYSTEM_NAME</u> variable to
       <b>ADSP</b>  and  the  <u>CMAKE_SYSTEM_PROCESSOR</u>  variable  to  the  "part number", excluding the <b>ADSP-</b> prefix, for
       example, <b>21594</b>, <b>SC589</b>, etc.  This value is case insensitive.

       CMake will automatically search for CCES or VDSP++ installs in their default install locations and select
       the most recent version found.  CCES will be selected over VDSP++ if both are installed.  Custom  install
       paths can be set via the <u>CMAKE_ADSP_ROOT</u> variable or the <u>ADSP_ROOT</u> environment variable.

       The  compiler  (<b>cc21k</b>  vs.  <b>ccblkfn</b>)  is selected automatically based on the <u>CMAKE_SYSTEM_PROCESSOR</u> value
       provided.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Android</b>
       A toolchain file may configure cross-compiling for Android by setting the <u>CMAKE_SYSTEM_NAME</u>  variable  to
       <b>Android</b>.  Further configuration is specific to the Android development environment to be used.

       For  <u>Visual</u>  <u>Studio</u>  <u>Generators</u>,  CMake  expects  <u>NVIDIA</u> <u>Nsight</u> <u>Tegra</u> <u>Visual</u> <u>Studio</u> <u>Edition</u> or the <u>Visual</u>
       <u>Studio</u> <u>tools</u> <u>for</u> <u>Android</u> to be installed. See those sections for further configuration details.

       For <u>Makefile</u> <u>Generators</u> and the <u>Ninja</u> generator, CMake expects one of these environments:

       • <u>NDK</u>

       • <u>Standalone</u> <u>Toolchain</u>

       CMake uses the following steps to select one of the environments:

       • If the <u>CMAKE_ANDROID_NDK</u> variable is set, the NDK at the specified location will be used.

       • Else, if the <u>CMAKE_ANDROID_STANDALONE_TOOLCHAIN</u> variable  is  set,  the  Standalone  Toolchain  at  the
         specified location will be used.

       • Else,    if    the    <u>CMAKE_SYSROOT</u>    variable    is    set    to    a    directory    of   the   form
         <b>&lt;ndk&gt;/platforms/android-&lt;api&gt;/arch-&lt;arch&gt;</b>,  the  <b>&lt;ndk&gt;</b>  part   will   be   used   as   the   value   of
         <u>CMAKE_ANDROID_NDK</u> and the NDK will be used.

       • Else,  if  the <u>CMAKE_SYSROOT</u> variable is set to a directory of the form <b>&lt;standalone-toolchain&gt;/sysroot</b>,
         the <b>&lt;standalone-toolchain&gt;</b> part will be used as the value of <u>CMAKE_ANDROID_STANDALONE_TOOLCHAIN</u> and the
         Standalone Toolchain will be used.

       • Else, if a cmake variable <b>ANDROID_NDK</b> is set it will be used as the value of <u>CMAKE_ANDROID_NDK</u>, and the
         NDK will be used.

       • Else, if a cmake variable <b>ANDROID_STANDALONE_TOOLCHAIN</b> is  set,  it  will  be  used  as  the  value  of
         <u>CMAKE_ANDROID_STANDALONE_TOOLCHAIN</u>, and the Standalone Toolchain will be used.

       • Else,  if  an environment variable <b>ANDROID_NDK_ROOT</b> or <b>ANDROID_NDK</b> is set, it will be used as the value
         of <u>CMAKE_ANDROID_NDK</u>, and the NDK will be used.

       • Else, if an environment variable <b>ANDROID_STANDALONE_TOOLCHAIN</b> is set then it will be used as the  value
         of <u>CMAKE_ANDROID_STANDALONE_TOOLCHAIN</u>, and the Standalone Toolchain will be used.

       • Else, an error diagnostic will be issued that neither the NDK or Standalone Toolchain can be found.

       Added  in  version  3.20:  If  an  Android  NDK  is  selected,  its  version  number  is  reported in the
       <u>CMAKE_ANDROID_NDK_VERSION</u> variable.

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Android</b> <b>with</b> <b>the</b> <b>NDK</b>
       A toolchain file may configure <u>Makefile</u> <u>Generators</u>, <u>Ninja</u> <u>Generators</u>,  or  <u>Visual</u>  <u>Studio</u>  <u>Generators</u>  to
       target Android for cross-compiling.

       Configure use of an Android NDK with the following variables:

       <u>CMAKE_SYSTEM_NAME</u>
              Set to <b>Android</b>.  Must be specified to enable cross compiling for Android.

       <u>CMAKE_SYSTEM_VERSION</u>
              Set to the Android API level.  If not specified, the value is determined as follows:

              • If the <u>CMAKE_ANDROID_API</u> variable is set, its value is used as the API level.

              • If the <u>CMAKE_SYSROOT</u> variable is set, the API level is detected from the NDK directory structure
                containing the sysroot.

              • Otherwise, the latest API level available in the NDK is used.

       <u>CMAKE_ANDROID_ARCH_ABI</u>
              Set  to the Android ABI (architecture).  If not specified, this variable will default to the first
              supported ABI in the list of <b>armeabi</b>, <b>armeabi-v7a</b> and <b>arm64-v8a</b>.  The <u>CMAKE_ANDROID_ARCH</u>  variable
              will  be  computed from <b>CMAKE_ANDROID_ARCH_ABI</b> automatically.  Also see the <u>CMAKE_ANDROID_ARM_MODE</u>
              and <u>CMAKE_ANDROID_ARM_NEON</u> variables.

       <u>CMAKE_ANDROID_NDK</u>
              Set to the absolute path to the Android NDK root directory.  If not specified, a default for  this
              variable will be chosen as specified <u>above</u>.

       <u>CMAKE_ANDROID_NDK_DEPRECATED_HEADERS</u>
              Set  to  a  true value to use the deprecated per-api-level headers instead of the unified headers.
              If not specified, the default will be false unless using a  NDK  that  does  not  provide  unified
              headers.

       <u>CMAKE_ANDROID_NDK_TOOLCHAIN_VERSION</u>
              On  NDK  r19 or above, this variable must be unset or set to <b>clang</b>.  On NDK r18 or below, set this
              to the version of the NDK toolchain to be selected as the compiler.  If not specified, the default
              will be the latest available GCC toolchain.

       <u>CMAKE_ANDROID_STL_TYPE</u>
              Set to specify which C++ standard library to use.  If not specified, a default will be selected as
              described in the variable documentation.

       The following variables will be computed and provided automatically:

       <u>CMAKE_&lt;LANG&gt;_ANDROID_TOOLCHAIN_PREFIX</u>
              The absolute path prefix to the binutils in the NDK toolchain.

       <u>CMAKE_&lt;LANG&gt;_ANDROID_TOOLCHAIN_SUFFIX</u>
              The host platform suffix of the binutils in the NDK toolchain.

       For example, a toolchain file might contain:

          set(CMAKE_SYSTEM_NAME Android)
          set(CMAKE_SYSTEM_VERSION 21) # API level
          set(CMAKE_ANDROID_ARCH_ABI arm64-v8a)
          set(CMAKE_ANDROID_NDK /path/to/android-ndk)
          set(CMAKE_ANDROID_STL_TYPE gnustl_static)

       Alternatively one may specify the values without a toolchain file:

          $ cmake ../src \
            -DCMAKE_SYSTEM_NAME=Android \
            -DCMAKE_SYSTEM_VERSION=21 \
            -DCMAKE_ANDROID_ARCH_ABI=arm64-v8a \
            -DCMAKE_ANDROID_NDK=/path/to/android-ndk \
            -DCMAKE_ANDROID_STL_TYPE=gnustl_static

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Android</b> <b>with</b> <b>a</b> <b>Standalone</b> <b>Toolchain</b>
       A toolchain file may configure  <u>Makefile</u>  <u>Generators</u>  or  the  <u>Ninja</u>  generator  to  target  Android  for
       cross-compiling using a standalone toolchain.

       Configure use of an Android standalone toolchain with the following variables:

       <u>CMAKE_SYSTEM_NAME</u>
              Set to <b>Android</b>.  Must be specified to enable cross compiling for Android.

       <u>CMAKE_ANDROID_STANDALONE_TOOLCHAIN</u>
              Set    to    the    absolute    path    to   the   standalone   toolchain   root   directory.    A
              <b>${CMAKE_ANDROID_STANDALONE_TOOLCHAIN}/sysroot</b> directory must exist.  If not specified,  a  default
              for this variable will be chosen as specified <u>above</u>.

       <u>CMAKE_ANDROID_ARM_MODE</u>
              When  the standalone toolchain targets ARM, optionally set this to <b>ON</b> to target 32-bit ARM instead
              of 16-bit Thumb.  See variable documentation for details.

       <u>CMAKE_ANDROID_ARM_NEON</u>
              When the standalone toolchain targets ARM v7, optionally set thisto <b>ON</b> to target ARM NEON devices.
              See variable documentation for details.

       The following variables will be computed and provided automatically:

       <u>CMAKE_SYSTEM_VERSION</u>
              The Android API level detected from the standalone toolchain.

       <u>CMAKE_ANDROID_ARCH_ABI</u>
              The Android ABI detected from the standalone toolchain.

       <u>CMAKE_&lt;LANG&gt;_ANDROID_TOOLCHAIN_PREFIX</u>
              The absolute path prefix to the <b>binutils</b> in the standalone toolchain.

       <u>CMAKE_&lt;LANG&gt;_ANDROID_TOOLCHAIN_SUFFIX</u>
              The host platform suffix of the <b>binutils</b> in the standalone toolchain.

       For example, a toolchain file might contain:

          set(CMAKE_SYSTEM_NAME Android)
          set(CMAKE_ANDROID_STANDALONE_TOOLCHAIN /path/to/android-toolchain)

       Alternatively one may specify the values without a toolchain file:

          $ cmake ../src \
            -DCMAKE_SYSTEM_NAME=Android \
            -DCMAKE_ANDROID_STANDALONE_TOOLCHAIN=/path/to/android-toolchain

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>Android</b> <b>with</b> <b>NVIDIA</b> <b>Nsight</b> <b>Tegra</b> <b>Visual</b> <b>Studio</b> <b>Edition</b>
       A toolchain file to configure one of the <u>Visual</u> <u>Studio</u> <u>Generators</u> to  build  using  NVIDIA  Nsight  Tegra
       targeting Android may look like this:

          set(CMAKE_SYSTEM_NAME Android)

       The <u>CMAKE_GENERATOR_TOOLSET</u> may be set to select the Nsight Tegra "Toolchain Version" value.

       See also target properties:

       • <u>ANDROID_ANT_ADDITIONAL_OPTIONS</u>

       • <u>ANDROID_API_MIN</u>

       • <u>ANDROID_API</u>

       • <u>ANDROID_ARCH</u>

       • <u>ANDROID_ASSETS_DIRECTORIES</u>

       • <u>ANDROID_GUI</u>

       • <u>ANDROID_JAR_DEPENDENCIES</u>

       • <u>ANDROID_JAR_DIRECTORIES</u>

       • <u>ANDROID_JAVA_SOURCE_DIR</u>

       • <u>ANDROID_NATIVE_LIB_DEPENDENCIES</u>

       • <u>ANDROID_NATIVE_LIB_DIRECTORIES</u>

       • <u>ANDROID_PROCESS_MAX</u>

       • <u>ANDROID_PROGUARD_CONFIG_PATH</u>

       • <u>ANDROID_PROGUARD</u>

       • <u>ANDROID_SECURE_PROPS_PATH</u>

       • <u>ANDROID_SKIP_ANT_STEP</u>

       • <u>ANDROID_STL_TYPE</u>

   <b>Cross</b> <b>Compiling</b> <b>for</b> <b>iOS,</b> <b>tvOS,</b> <b>visionOS,</b> <b>or</b> <b>watchOS</b>
       For  cross-compiling  to  iOS,  tvOS, visionOS, or watchOS, the <u>Xcode</u> generator is recommended.  The <u>Unix</u>
       <u>Makefiles</u> or <u>Ninja</u> generators can also be used, but they require the project to handle  more  areas  like
       target CPU selection and code signing.

       Any  of  the  Apple device platforms can be targeted by setting the <u>CMAKE_SYSTEM_NAME</u> variable to a value
       from the table below.  By default, the latest Device SDK is  chosen.   As  for  all  Apple  platforms,  a
       different SDK (e.g. a simulator) can be selected by setting the <u>CMAKE_OSX_SYSROOT</u> variable, although this
       should  rarely be necessary (see <u>Switching</u> <u>Between</u> <u>Device</u> <u>and</u> <u>Simulator</u> below).  A list of available SDKs
       can be obtained by running <b>xcodebuild</b> <b>-showsdks</b>.
               ┌──────────┬───────────────────┬─────────────────────┬──────────────────┬──────────────┐
               │ OS       │ CMAKE_SYSTEM_NAME │ Device          SDK │ Simulator SDK    │ Catalyst SDK │
               │          │                   │ (default)           │                  │              │
               ├──────────┼───────────────────┼─────────────────────┼──────────────────┼──────────────┤
               │ iOS      │ iOS               │ iphoneos            │ iphonesimulator  │ macosx       │
               ├──────────┼───────────────────┼─────────────────────┼──────────────────┼──────────────┤
               │ tvOS     │ tvOS              │ appletvos           │ appletvsimulator │ N/A          │
               ├──────────┼───────────────────┼─────────────────────┼──────────────────┼──────────────┤
               │ visionOS │ visionOS          │ xros                │ xrsimulator      │ N/A          │
               ├──────────┼───────────────────┼─────────────────────┼──────────────────┼──────────────┤
               │ watchOS  │ watchOS           │ watchos             │ watchsimulator   │ N/A          │
               └──────────┴───────────────────┴─────────────────────┴──────────────────┴──────────────┘

       For example, to create a CMake configuration for iOS, the following command is sufficient:

          cmake .. -GXcode -DCMAKE_SYSTEM_NAME=iOS

       Variable <u>CMAKE_OSX_ARCHITECTURES</u> can be used to set architectures for both device and simulator. Variable
       <u>CMAKE_OSX_DEPLOYMENT_TARGET</u> can be used to set an iOS/tvOS/visionOS/watchOS deployment target.

       The  next  example  installs  five  architectures  in a universal binary for an iOS library.  It adds the
       relevant <b>-miphoneos-version-min=9.3</b> or <b>-mios-simulator-version-min=9.3</b> compiler flag  where  appropriate.
       Note that the <u>CMAKE_IOS_INSTALL_COMBINED</u> variable used in the example is now deprecated, so this approach
       is no longer recommended.

          $ cmake -S. -B_builds -GXcode \
              -DCMAKE_SYSTEM_NAME=iOS \
              "-DCMAKE_OSX_ARCHITECTURES=armv7;armv7s;arm64;i386;x86_64" \
              -DCMAKE_OSX_DEPLOYMENT_TARGET=9.3 \
              -DCMAKE_INSTALL_PREFIX=`pwd`/_install \
              -DCMAKE_XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH=NO \
              -DCMAKE_IOS_INSTALL_COMBINED=YES

       Example:

          # CMakeLists.txt
          cmake_minimum_required(VERSION 3.14)
          project(foo)
          add_library(foo foo.cpp)
          install(TARGETS foo DESTINATION lib)

       Install:

          $ cmake --build _builds --config Release --target install

       Check library:

          $ lipo -info _install/lib/libfoo.a
          Architectures in the fat file: _install/lib/libfoo.a are: i386 armv7 armv7s x86_64 arm64

          $ otool -l _install/lib/libfoo.a | grep -A2 LC_VERSION_MIN_IPHONEOS
                cmd LC_VERSION_MIN_IPHONEOS
            cmdsize 16
            version 9.3

   <b>Code</b> <b>Signing</b>
       Some  build  artifacts  for  the  embedded  Apple platforms require mandatory code signing.  If the <u>Xcode</u>
       generator is being used and code signing is required or desired, the development team ID can be specified
       via the <b>CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM</b> CMake variable.  This team ID will then be included in the
       generated Xcode project.  By default, CMake  avoids  the  need  for  code  signing  during  the  internal
       configuration phase (i.e compiler ID and feature detection).

   <b>Switching</b> <b>Between</b> <b>Device</b> <b>and</b> <b>Simulator</b>
       When  configuring for any of the embedded platforms, one can target either real devices or the simulator.
       Both have their own separate SDK, but CMake only supports specifying a single SDK for  the  configuration
       phase.   This  means  the  developer  must select one or the other at configuration time.  When using the
       <u>Xcode</u> generator, this is less of a limitation because Xcode still allows you to build for either a device
       or a simulator, even though configuration was only performed for one of the two.  From within  the  Xcode
       IDE,  builds are performed for the selected "destination" platform.  When building from the command line,
       the desired sdk can be specified directly  by  passing  a  <b>-sdk</b>  option  to  the  underlying  build  tool
       (<b>xcodebuild</b>).  For example:

          $ cmake --build ... -- -sdk iphonesimulator

       Please note that checks made during configuration were performed against the configure-time SDK and might
       not  hold  true for other SDKs.  Commands like <u>find_package()</u>, <u>find_library()</u>, etc. store and use details
       only for the configured SDK/platform, so they can be problematic if wanting to switch between device  and
       simulator builds. You can follow the next rules to make device + simulator configuration work:

       • Use explicit <b>-l</b> linker flag, e.g. <b>target_link_libraries(foo</b> <b>PUBLIC</b> <b>"-lz")</b>

       • Use explicit <b>-framework</b> linker flag, e.g. <b>target_link_libraries(foo</b> <b>PUBLIC</b> <b>"-framework</b> <b>CoreFoundation")</b>

       • Use <u>find_package()</u> only for libraries installed with <u>CMAKE_IOS_INSTALL_COMBINED</u> feature

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2000-2024 Kitware, Inc. and Contributors

3.31.6                                           August 09, 2025                             <u><a href="../man7/CMAKE-TOOLCHAINS.7.html">CMAKE-TOOLCHAINS</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>