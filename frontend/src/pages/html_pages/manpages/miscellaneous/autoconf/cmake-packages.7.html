<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cmake-packages - CMake Packages Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cmake-data">cmake-data_3.31.6-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cmake-packages - CMake Packages Reference

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Packages  provide  dependency  information  to  CMake  based  buildsystems.   Packages are found with the
       <u>find_package()</u> command.  The result of using <u>find_package()</u> is either a set of <u>IMPORTED</u> targets, or a set
       of variables corresponding to build-relevant information.

</pre><h4><b>USING</b> <b>PACKAGES</b></h4><pre>
       CMake provides direct support for two forms of packages, <u>Config-file</u> <u>Packages</u> and  <u>Find-module</u>  <u>Packages</u>.
       Indirect  support  for  <b>pkg-config</b> packages is also provided via the <u>FindPkgConfig</u> module.  In all cases,
       the basic form of <u>find_package()</u> calls is the same:

          find_package(Qt4 4.7.0 REQUIRED) # CMake provides a Qt4 find-module
          find_package(Qt5Core 5.1.0 REQUIRED) # Qt provides a Qt5 package config file.
          find_package(LibXml2 REQUIRED) # Use pkg-config via the LibXml2 find-module

       In cases where it is known that a package configuration file is  provided  by  upstream,  and  only  that
       should be used, the <b>CONFIG</b> keyword may be passed to <u>find_package()</u>:

          find_package(Qt5Core 5.1.0 CONFIG REQUIRED)
          find_package(Qt5Gui 5.1.0 CONFIG)

       Similarly, the <b>MODULE</b> keyword says to use only a find-module:

          find_package(Qt4 4.7.0 MODULE REQUIRED)

       Specifying  the  type  of  package  explicitly  improves the error message shown to the user if it is not
       found.

       Both types of packages also support specifying  components  of  a  package,  either  after  the  <b>REQUIRED</b>
       keyword:

          find_package(Qt5 5.1.0 CONFIG REQUIRED Widgets Xml Sql)

       or as a separate <b>COMPONENTS</b> list:

          find_package(Qt5 5.1.0 COMPONENTS Widgets Xml Sql)

       or as a separate <b>OPTIONAL_COMPONENTS</b> list:

          find_package(Qt5 5.1.0 COMPONENTS Widgets
                                 OPTIONAL_COMPONENTS Xml Sql
          )

       Handling of <b>COMPONENTS</b> and <b>OPTIONAL_COMPONENTS</b> is defined by the package.

       By  setting the <u>CMAKE_DISABLE_FIND_PACKAGE_&lt;PackageName&gt;</u> variable to <b>TRUE</b>, the <b>&lt;PackageName&gt;</b> package will
       not    be    searched,     and     will     always     be     <b>NOTFOUND</b>.     Likewise,     setting     the
       <u>CMAKE_REQUIRE_FIND_PACKAGE_&lt;PackageName&gt;</u> to <b>TRUE</b> will make the package REQUIRED.

   <b>Config-file</b> <b>Packages</b>
       A config-file package is a set of files provided by upstreams for downstreams to use. CMake searches in a
       number  of  locations  for package configuration files, as described in the <u>find_package()</u> documentation.
       The most simple way for a CMake user to tell <u><a href="../man1/cmake.1.html">cmake</a>(1)</u> to search in a non-standard prefix for a package is
       to set the <b>CMAKE_PREFIX_PATH</b> cache variable.

       Config-file packages are provided by upstream vendors as part of  development  packages,  that  is,  they
       belong with the header files and any other files provided to assist downstreams in using the package.

       A  set  of  variables  which  provide  package status information are also set automatically when using a
       config-file package.  The <b>&lt;PackageName&gt;_FOUND</b> variable is set to true or false, depending on whether  the
       package  was  found.   The  <b>&lt;PackageName&gt;_DIR</b>  cache  variable  is  set  to  the  location of the package
       configuration file.

   <b>Find-module</b> <b>Packages</b>
       A find module is a file with a set of rules for finding the required pieces of  a  dependency,  primarily
       header  files  and  libraries.   Typically,  a  find module is needed when the upstream is not built with
       CMake, or is not CMake-aware enough to otherwise provide a package configuration file.  Unlike a  package
       configuration  file,  it  is  not  shipped  with upstream, but is used by downstream to find the files by
       guessing locations of files with platform-specific hints.

       Unlike the case of an  upstream-provided  package  configuration  file,  no  single  point  of  reference
       identifies  the  package  as being found, so the <b>&lt;PackageName&gt;_FOUND</b> variable is not automatically set by
       the <u>find_package()</u> command.  It can still be expected to be set by convention however and should  be  set
       by  the  author  of  the  Find-module.  Similarly there is no <b>&lt;PackageName&gt;_DIR</b> variable, but each of the
       artifacts such as library locations and header file locations provide a separate cache variable.

       See the <u><a href="../man7/cmake-developer.7.html">cmake-developer</a>(7)</u> manual for more information about creating Find-module files.

</pre><h4><b>PACKAGE</b> <b>LAYOUT</b></h4><pre>
       A config-file package consists of a <u>Package</u> <u>Configuration</u> <u>File</u> and  optionally  a  <u>Package</u>  <u>Version</u>  <u>File</u>
       provided with the project distribution.

   <b>Package</b> <b>Configuration</b> <b>File</b>
       Consider a project <b>Foo</b> that installs the following files:

          &lt;prefix&gt;/include/foo-1.2/foo.h
          &lt;prefix&gt;/lib/foo-1.2/libfoo.a

       It may also provide a CMake package configuration file:

          &lt;prefix&gt;/lib/cmake/foo-1.2/FooConfig.cmake

       with content defining <u>IMPORTED</u> targets, or defining variables, such as:

          # ...
          # (compute PREFIX relative to file location)
          # ...
          set(Foo_INCLUDE_DIRS ${PREFIX}/include/foo-1.2)
          set(Foo_LIBRARIES ${PREFIX}/lib/foo-1.2/libfoo.a)

       If  another  project wishes to use <b>Foo</b> it need only to locate the <b>FooConfig.cmake</b> file and load it to get
       all the information it needs about package content locations.  Since the package  configuration  file  is
       provided by the package installation it already knows all the file locations.

       The  <u>find_package()</u>  command  may  be  used  to  search for the package configuration file.  This command
       constructs a set of installation prefixes and searches under each prefix in several locations.  Given the
       name <b>Foo</b>, it looks for a file called <b>FooConfig.cmake</b> or <b>foo-config.cmake</b>.  The full set of  locations  is
       specified in the <u>find_package()</u> command documentation. One place it looks is:

          &lt;prefix&gt;/lib/cmake/Foo*/

       where  <b>Foo*</b> is a case-insensitive globbing expression.  In our example the globbing expression will match
       <b>&lt;prefix&gt;/lib/cmake/foo-1.2</b> and the package configuration file will be found.

       Once found, a package configuration file is immediately loaded.  It,  together  with  a  package  version
       file, contains all the information the project needs to use the package.

   <b>Package</b> <b>Version</b> <b>File</b>
       When  the  <u>find_package()</u>  command finds a candidate package configuration file it looks next to it for a
       version file. The version file is loaded to test whether the package version is an acceptable  match  for
       the  version  requested.   If  the  version file claims compatibility the configuration file is accepted.
       Otherwise it is ignored.

       The name of the package version file must match that of the package configuration  file  but  has  either
       <b>-version</b> or <b>Version</b> appended to the name before the <b>.cmake</b> extension.  For example, the files:

          &lt;prefix&gt;/lib/cmake/foo-1.3/foo-config.cmake
          &lt;prefix&gt;/lib/cmake/foo-1.3/foo-config-version.cmake

       and:

          &lt;prefix&gt;/lib/cmake/bar-4.2/BarConfig.cmake
          &lt;prefix&gt;/lib/cmake/bar-4.2/BarConfigVersion.cmake

       are each pairs of package configuration files and corresponding package version files.

       When the <u>find_package()</u> command loads a version file it first sets the following variables:

       <b>PACKAGE_FIND_NAME</b>
              The <b>&lt;PackageName&gt;</b>

       <b>PACKAGE_FIND_VERSION</b>
              Full requested version string

       <b>PACKAGE_FIND_VERSION_MAJOR</b>
              Major version if requested, else 0

       <b>PACKAGE_FIND_VERSION_MINOR</b>
              Minor version if requested, else 0

       <b>PACKAGE_FIND_VERSION_PATCH</b>
              Patch version if requested, else 0

       <b>PACKAGE_FIND_VERSION_TWEAK</b>
              Tweak version if requested, else 0

       <b>PACKAGE_FIND_VERSION_COUNT</b>
              Number of version components, 0 to 4

       The  version  file  must  use these variables to check whether it is compatible or an exact match for the
       requested version and set the following variables with results:

       <b>PACKAGE_VERSION</b>
              Full provided version string

       <b>PACKAGE_VERSION_EXACT</b>
              True if version is exact match

       <b>PACKAGE_VERSION_COMPATIBLE</b>
              True if version is compatible

       <b>PACKAGE_VERSION_UNSUITABLE</b>
              True if unsuitable as any version

       Version files are loaded in a nested scope so they are free to set any variables they  wish  as  part  of
       their  computation.  The find_package command wipes out the scope when the version file has completed and
       it has checked the output variables. When the version file claims to  be  an  acceptable  match  for  the
       requested version the find_package command sets the following variables for use by the project:

       <b>&lt;PackageName&gt;_VERSION</b>
              Full provided version string

       <b>&lt;PackageName&gt;_VERSION_MAJOR</b>
              Major version if provided, else 0

       <b>&lt;PackageName&gt;_VERSION_MINOR</b>
              Minor version if provided, else 0

       <b>&lt;PackageName&gt;_VERSION_PATCH</b>
              Patch version if provided, else 0

       <b>&lt;PackageName&gt;_VERSION_TWEAK</b>
              Tweak version if provided, else 0

       <b>&lt;PackageName&gt;_VERSION_COUNT</b>
              Number of version components, 0 to 4

       The variables report the version of the package that was actually found.  The <b>&lt;PackageName&gt;</b> part of their
       name matches the argument given to the <u>find_package()</u> command.

</pre><h4><b>CREATING</b> <b>PACKAGES</b></h4><pre>
       Usually,  the upstream depends on CMake itself and can use some CMake facilities for creating the package
       files. Consider an upstream which provides a single shared library:

          project(UpstreamLib)

          set(CMAKE_INCLUDE_CURRENT_DIR ON)
          set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)

          set(Upstream_VERSION 3.4.1)

          include(GenerateExportHeader)

          add_library(ClimbingStats SHARED climbingstats.cpp)
          generate_export_header(ClimbingStats)
          set_property(TARGET ClimbingStats PROPERTY VERSION ${Upstream_VERSION})
          set_property(TARGET ClimbingStats PROPERTY SOVERSION 3)
          set_property(TARGET ClimbingStats PROPERTY
            INTERFACE_ClimbingStats_MAJOR_VERSION 3)
          set_property(TARGET ClimbingStats APPEND PROPERTY
            COMPATIBLE_INTERFACE_STRING ClimbingStats_MAJOR_VERSION
          )

          install(TARGETS ClimbingStats EXPORT ClimbingStatsTargets
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib
            RUNTIME DESTINATION bin
            INCLUDES DESTINATION include
          )
          install(
            FILES
              climbingstats.h
              "${CMAKE_CURRENT_BINARY_DIR}/climbingstats_export.h"
            DESTINATION
              include
            COMPONENT
              Devel
          )

          include(CMakePackageConfigHelpers)
          write_basic_package_version_file(
            "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfigVersion.cmake"
            VERSION ${Upstream_VERSION}
            COMPATIBILITY AnyNewerVersion
          )

          export(EXPORT ClimbingStatsTargets
            FILE "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsTargets.cmake"
            NAMESPACE Upstream::
          )
          configure_file(cmake/ClimbingStatsConfig.cmake
            "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfig.cmake"
            COPYONLY
          )

          set(ConfigPackageLocation lib/cmake/ClimbingStats)
          install(EXPORT ClimbingStatsTargets
            FILE
              ClimbingStatsTargets.cmake
            NAMESPACE
              Upstream::
            DESTINATION
              ${ConfigPackageLocation}
          )
          install(
            FILES
              cmake/ClimbingStatsConfig.cmake
              "${CMAKE_CURRENT_BINARY_DIR}/ClimbingStats/ClimbingStatsConfigVersion.cmake"
            DESTINATION
              ${ConfigPackageLocation}
            COMPONENT
              Devel
          )

       The <u>CMakePackageConfigHelpers</u> module provides a macro for creating  a  simple  <b>ConfigVersion.cmake</b>  file.
       This  file  sets  the  version  of  the  package.   It  is read by CMake when <u>find_package()</u> is called to
       determine the compatibility with the requested  version,  and  to  set  some  version-specific  variables
       <b>&lt;PackageName&gt;_VERSION</b>, <b>&lt;PackageName&gt;_VERSION_MAJOR</b>, <b>&lt;PackageName&gt;_VERSION_MINOR</b> etc.  The <u>install(EXPORT)</u>
       command  is  used to export the targets in the <b>ClimbingStatsTargets</b> export-set, defined previously by the
       <u>install(TARGETS)</u> command. This command generates the <b>ClimbingStatsTargets.cmake</b> file to contain  <u>IMPORTED</u>
       targets,  suitable  for  use  by  downstreams and arranges to install it to <b>lib/cmake/ClimbingStats</b>.  The
       generated <b>ClimbingStatsConfigVersion.cmake</b> and a <b>cmake/ClimbingStatsConfig.cmake</b>  are  installed  to  the
       same location, completing the package.

       The  generated  <u>IMPORTED</u> targets have appropriate properties set to define their <u>usage</u> <u>requirements</u>, such
       as <u>INTERFACE_INCLUDE_DIRECTORIES</u>, <u>INTERFACE_COMPILE_DEFINITIONS</u> and other  relevant  built-in  <b>INTERFACE_</b>
       properties.   The  <b>INTERFACE</b> variant of user-defined properties listed in <u>COMPATIBLE_INTERFACE_STRING</u> and
       other <u>Compatible</u> <u>Interface</u> <u>Properties</u> are also propagated to the  generated  <u>IMPORTED</u>  targets.   In  the
       above  case,  <b>ClimbingStats_MAJOR_VERSION</b>  is  defined  as  a  string  which must be compatible among the
       dependencies of any depender.  By setting this custom defined user property in this version  and  in  the
       next  version  of <b>ClimbingStats</b>, <u><a href="../man1/cmake.1.html">cmake</a>(1)</u> will issue a diagnostic if there is an attempt to use version 3
       together with version 4.  Packages can choose to employ such a pattern if different major versions of the
       package are designed to be incompatible.

       A <b>NAMESPACE</b> with double-colons is specified when exporting the targets for installation.  This convention
       of double-colons gives CMake a hint that the name is an <u>IMPORTED</u> target when it is  used  by  downstreams
       with  the  <u>target_link_libraries()</u>  command.   This  way,  CMake  can  issue  a diagnostic if the package
       providing it has not yet been found.

       In this case, when using <u>install(TARGETS)</u> the  <b>INCLUDES</b>  <b>DESTINATION</b>  was  specified.   This  causes  the
       <b>IMPORTED</b>  targets to have their <u>INTERFACE_INCLUDE_DIRECTORIES</u> populated with the <b>include</b> directory in the
       <u>CMAKE_INSTALL_PREFIX</u>.  When the <b>IMPORTED</b> target is used by  downstream,  it  automatically  consumes  the
       entries from that property.

   <b>Creating</b> <b>a</b> <b>Package</b> <b>Configuration</b> <b>File</b>
       In this case, the <b>ClimbingStatsConfig.cmake</b> file could be as simple as:

          include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")

       As  this  allows  downstreams  to  use  the  <b>IMPORTED</b>  targets.   If any macros should be provided by the
       <b>ClimbingStats</b> package, they should be in a separate file which is installed to the same location  as  the
       <b>ClimbingStatsConfig.cmake</b> file, and included from there.

       This can also be extended to cover dependencies:

          # ...
          add_library(ClimbingStats SHARED climbingstats.cpp)
          generate_export_header(ClimbingStats)

          find_package(Stats 2.6.4 REQUIRED)
          target_link_libraries(ClimbingStats PUBLIC Stats::Types)

       As  the <b>Stats::Types</b> target is a <b>PUBLIC</b> dependency of <b>ClimbingStats</b>, downstreams must also find the <b>Stats</b>
       package  and  link  to  the  <b>Stats::Types</b>  library.   The  <b>Stats</b>  package  should   be   found   in   the
       <b>ClimbingStatsConfig.cmake</b>    file    to    ensure    this.     The   <b>find_dependency</b>   macro   from   the
       <u>CMakeFindDependencyMacro</u> helps with this by propagating whether the package is <b>REQUIRED</b>,  or  <b>QUIET</b>  etc.
       All <b>REQUIRED</b> dependencies of a package should be found in the <b>Config.cmake</b> file:

          include(CMakeFindDependencyMacro)
          find_dependency(Stats 2.6.4)

          include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
          include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsMacros.cmake")

       The  <b>find_dependency</b>  macro  also sets <b>ClimbingStats_FOUND</b> to <b>False</b> if the dependency is not found, along
       with a diagnostic that the <b>ClimbingStats</b> package can not be used without the <b>Stats</b> package.

       If  <b>COMPONENTS</b>  are  specified  when  the  downstream  uses  <u>find_package()</u>,  they  are  listed  in   the
       <b>&lt;PackageName&gt;_FIND_COMPONENTS</b>   variable.   If   a   particular   component  is  non-optional,  then  the
       <b>&lt;PackageName&gt;_FIND_REQUIRED_&lt;comp&gt;</b>  will  be  true.  This  can  be  tested  with  logic  in  the  package
       configuration file:

          include(CMakeFindDependencyMacro)
          find_dependency(Stats 2.6.4)

          include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsTargets.cmake")
          include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStatsMacros.cmake")

          set(_ClimbingStats_supported_components Plot Table)

          foreach(_comp ${ClimbingStats_FIND_COMPONENTS})
            if (NOT ";${_ClimbingStats_supported_components};" MATCHES ";${_comp};")
              set(ClimbingStats_FOUND False)
              set(ClimbingStats_NOT_FOUND_MESSAGE "Unsupported component: ${_comp}")
            endif()
            include("${CMAKE_CURRENT_LIST_DIR}/ClimbingStats${_comp}Targets.cmake")
          endforeach()

       Here,  the  <b>ClimbingStats_NOT_FOUND_MESSAGE</b>  is  set  to  a diagnosis that the package could not be found
       because an invalid component was specified.  This message variable can be set  for  any  case  where  the
       <b>_FOUND</b> variable is set to <b>False</b>, and will be displayed to the user.

   <b>Creating</b> <b>a</b> <b>Package</b> <b>Configuration</b> <b>File</b> <b>for</b> <b>the</b> <b>Build</b> <b>Tree</b>
       The  <u>export(EXPORT)</u>  command  creates  an  <u>IMPORTED</u>  targets  definition  file  which  is specific to the
       build-tree, and is not relocatable.  This can similarly be used with  a  suitable  package  configuration
       file  and  package  version  file  to  define  a  package  for  the  build tree which may be used without
       installation.  Consumers of the build tree can simply ensure  that  the  <u>CMAKE_PREFIX_PATH</u>  contains  the
       build directory, or set the <b>ClimbingStats_DIR</b> to <b>&lt;build_dir&gt;/ClimbingStats</b> in the cache.

   <b>Creating</b> <b>Relocatable</b> <b>Packages</b>
       A  relocatable  package  must  not  reference absolute paths of files on the machine where the package is
       built that will not exist on the machines where the package may be installed.

       Packages created by <u>install(EXPORT)</u> are designed to be relocatable, using paths relative to the  location
       of the package itself.  When defining the interface of a target for <b>EXPORT</b>, keep in mind that the include
       directories should be specified as relative paths which are relative to the <u>CMAKE_INSTALL_PREFIX</u>:

          target_include_directories(tgt INTERFACE
            # Wrong, not relocatable:
            $&lt;INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include/TgtName&gt;
          )

          target_include_directories(tgt INTERFACE
            # Ok, relocatable:
            $&lt;INSTALL_INTERFACE:include/TgtName&gt;
          )

       The  <b>$&lt;INSTALL_PREFIX&gt;</b>  <u>generator</u>  <u>expression</u> may be used as a placeholder for the install prefix without
       resulting in a non-relocatable package.  This is necessary if complex generator expressions are used:

          target_include_directories(tgt INTERFACE
            # Ok, relocatable:
            $&lt;INSTALL_INTERFACE:$&lt;$&lt;CONFIG:Debug&gt;:$&lt;INSTALL_PREFIX&gt;/include/TgtName&gt;&gt;
          )

       This also applies to paths referencing external dependencies.   It  is  not  advisable  to  populate  any
       properties  which  may contain paths, such as <u>INTERFACE_INCLUDE_DIRECTORIES</u> and <u>INTERFACE_LINK_LIBRARIES</u>,
       with paths relevant to dependencies.  For example, this code may not work well for a relocatable package:

          target_link_libraries(ClimbingStats INTERFACE
            ${Foo_LIBRARIES} ${Bar_LIBRARIES}
            )
          target_include_directories(ClimbingStats INTERFACE
            "$&lt;INSTALL_INTERFACE:${Foo_INCLUDE_DIRS};${Bar_INCLUDE_DIRS}&gt;"
            )

       The referenced variables may contain the absolute paths to libraries and include directories <b>as</b> <b>found</b>  <b>on</b>
       <b>the</b>  <b>machine</b>  <b>the</b> <b>package</b> <b>was</b> <b>made</b> <b>on</b>.  This would create a package with hard-coded paths to dependencies
       and not suitable for relocation.

       Ideally such dependencies should be  used  through  their  own  <u>IMPORTED</u>  <u>targets</u>  that  have  their  own
       <u>IMPORTED_LOCATION</u>  and  usage  requirement  properties  such  as  <u>INTERFACE_INCLUDE_DIRECTORIES</u> populated
       appropriately.  Those imported targets may then be used  with  the  <u>target_link_libraries()</u>  command  for
       <b>ClimbingStats</b>:

          target_link_libraries(ClimbingStats INTERFACE Foo::Foo Bar::Bar)

       With  this  approach  the package references its external dependencies only through the names of <u>IMPORTED</u>
       <u>targets</u>.   When  a  consumer  uses  the  installed  package,  the  consumer  will  run  the   appropriate
       <u>find_package()</u>  commands  (via  the  <b>find_dependency</b>  macro described above) to find the dependencies and
       populate the imported targets with appropriate paths on their own machine.

       Unfortunately many <u>modules</u> shipped  with  CMake  do  not  yet  provide  <u>IMPORTED</u>  <u>targets</u>  because  their
       development  pre-dated  this  approach.  This may improve incrementally over time.  Workarounds to create
       relocatable packages using such modules include:

       • When building the package,  specify  each  <b>Foo_LIBRARY</b>  cache  entry  as  just  a  library  name,  e.g.
         <b>-DFoo_LIBRARY=foo</b>.   This  tells  the corresponding find module to populate the <b>Foo_LIBRARIES</b> with just
         <b>foo</b> to ask the linker to search for the library instead of hard-coding a path.

       • Or, after installing the package content but  before  creating  the  package  installation  binary  for
         redistribution,  manually  replace  the  absolute  paths  with  placeholders  for  substitution  by the
         installation tool when the package is installed.

</pre><h4><b>PACKAGE</b> <b>REGISTRY</b></h4><pre>
       CMake provides two central locations to register packages that have been built or installed anywhere on a
       system:

       • <u>User</u> <u>Package</u> <u>Registry</u>

       • <u>System</u> <u>Package</u> <u>Registry</u>

       The registries are especially useful to help projects find packages in non-standard install locations  or
       directly  in their own build trees.  A project may populate either the user or system registry (using its
       own means, see below) to refer to its  location.   In  either  case  the  package  should  store  at  the
       registered  location  a  <u>Package</u>  <u>Configuration</u> <u>File</u> (<b>&lt;PackageName&gt;Config.cmake</b>) and optionally a <u>Package</u>
       <u>Version</u> <u>File</u> (<b>&lt;PackageName&gt;ConfigVersion.cmake</b>).

       The <u>find_package()</u> command searches the two package registries as two of the search  steps  specified  in
       its  documentation.  If it has sufficient permissions it also removes stale package registry entries that
       refer to directories that do not exist or do not contain a matching package configuration file.

   <b>User</b> <b>Package</b> <b>Registry</b>
       The User Package Registry is stored in a per-user location.  The <u>export(PACKAGE)</u> command may be  used  to
       register a project build tree in the user package registry.  CMake currently provides no interface to add
       install  trees  to  the  user  package  registry.   Installers  must be manually taught to register their
       packages if desired.

       On Windows the user package registry is stored in the Windows registry under a key in <b>HKEY_CURRENT_USER</b>.

       A <b>&lt;PackageName&gt;</b> may appear under registry key:

          HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\&lt;PackageName&gt;

       as a <b>REG_SZ</b> value, with arbitrary name, that specifies the directory containing the package configuration
       file.

       On UNIX platforms the user package registry is stored in the user home directory under <b><a href="file:~/.cmake/packages">~/.cmake/packages</a></b>.
       A <b>&lt;PackageName&gt;</b> may appear under the directory:

          <a href="file:~/.cmake/packages/">~/.cmake/packages/</a>&lt;PackageName&gt;

       as  a  file,  with  arbitrary  name,  whose  content  specifies  the  directory  containing  the  package
       configuration file.

   <b>System</b> <b>Package</b> <b>Registry</b>
       The  System  Package Registry is stored in a system-wide location.  CMake currently provides no interface
       to add to the system package registry.  Installers must be manually taught to register their packages  if
       desired.

       On   Windows   the   system  package  registry  is  stored  in  the  Windows  registry  under  a  key  in
       <b>HKEY_LOCAL_MACHINE</b>.  A <b>&lt;PackageName&gt;</b> may appear under registry key:

          HKEY_LOCAL_MACHINE\Software\Kitware\CMake\Packages\&lt;PackageName&gt;

       as a <b>REG_SZ</b> value, with arbitrary name, that specifies the directory containing the package configuration
       file.

       There is no system package registry on non-Windows platforms.

   <b>Disabling</b> <b>the</b> <b>Package</b> <b>Registry</b>
       In some cases using the Package Registries is not desirable. CMake allows one to disable them  using  the
       following variables:

       • The  <u>export(PACKAGE)</u>  command  does  not  populate the user package registry when <u>CMP0090</u> is set to <b>NEW</b>
         unless the <u>CMAKE_EXPORT_PACKAGE_REGISTRY</u> variable explicitly enables it.  When <u>CMP0090</u> is  <u>not</u>  set  to
         <b>NEW</b>     then     <u>export(PACKAGE)</u>     populates     the     user    package    registry    unless    the
         <u>CMAKE_EXPORT_NO_PACKAGE_REGISTRY</u> variable explicitly disables it.

       • <u>CMAKE_FIND_USE_PACKAGE_REGISTRY</u> disables the User Package Registry in all the <u>find_package()</u> calls when
         set to <b>FALSE</b>.

       • Deprecated <u>CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY</u>  disables  the  User  Package  Registry  in  all  the
         <u>find_package()</u>  calls  when  set to <b>TRUE</b>. This variable is ignored when <u>CMAKE_FIND_USE_PACKAGE_REGISTRY</u>
         has been set.

       • <u>CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY</u>  disables  the  System  Package  Registry  in   all   the
         <u>find_package()</u> calls.

   <b>Package</b> <b>Registry</b> <b>Example</b>
       A simple convention for naming package registry entries is to use content hashes.  They are deterministic
       and  unlikely  to  collide  (<u>export(PACKAGE)</u>  uses  this  approach).   The name of an entry referencing a
       specific directory is simply the content hash of the directory path itself.

       If a project arranges for package registry entries to exist, such as:

          &gt; reg query HKCU\Software\Kitware\CMake\Packages\MyPackage
          HKEY_CURRENT_USER\Software\Kitware\CMake\Packages\MyPackage
           45e7d55f13b87179bb12f907c8de6fc4 REG_SZ c:/Users/Me/Work/lib/cmake/MyPackage
           7b4a9844f681c80ce93190d4e3185db9 REG_SZ c:/Users/Me/Work/MyPackage-build

       or:

          $ cat <a href="file:~/.cmake/packages/MyPackage/7d1fb77e07ce59a81bed093bbee945bd">~/.cmake/packages/MyPackage/7d1fb77e07ce59a81bed093bbee945bd</a>
          /home/me/work/lib/cmake/MyPackage
          $ cat <a href="file:~/.cmake/packages/MyPackage/f92c1db873a1937f3100706657c63e07">~/.cmake/packages/MyPackage/f92c1db873a1937f3100706657c63e07</a>
          /home/me/work/MyPackage-build

       then the <b>CMakeLists.txt</b> code:

          find_package(MyPackage)

       will search the registered locations for package configuration files (<b>MyPackageConfig.cmake</b>).  The search
       order among package registry entries for a single package is unspecified and the entry names  (hashes  in
       this   example)   have   no   meaning.    Registered   locations   may   contain  package  version  files
       (<b>MyPackageConfigVersion.cmake</b>) to tell <u>find_package()</u> whether a specific location  is  suitable  for  the
       version requested.

   <b>Package</b> <b>Registry</b> <b>Ownership</b>
       Package  registry  entries  are  individually  owned by the project installations that they reference.  A
       package installer is  responsible  for  adding  its  own  entry  and  the  corresponding  uninstaller  is
       responsible for removing it.

       The  <u>export(PACKAGE)</u>  command  populates  the  user package registry with the location of a project build
       tree.  Build trees tend to be deleted by developers and have no  "uninstall"  event  that  could  trigger
       removal of their entries.  In order to keep the registries clean the <u>find_package()</u> command automatically
       removes  stale  entries  it  encounters if it has sufficient permissions.  CMake provides no interface to
       remove an entry referencing an existing build tree once <u>export(PACKAGE)</u> has been  invoked.   However,  if
       the  project  removes  its  package configuration file from the build tree then the entry referencing the
       location will be considered stale.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2000-2024 Kitware, Inc. and Contributors

3.31.6                                            May 23, 2025                                 <u><a href="../man7/CMAKE-PACKAGES.7.html">CMAKE-PACKAGES</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>