<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cmake-policies - CMake Policies Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cmake-data">cmake-data_3.31.6-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cmake-policies - CMake Policies Reference

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Policies in CMake are used to preserve backward compatible behavior across multiple releases.  When a new
       policy is introduced, newer CMake versions will begin to warn about the backward compatible behavior.  It
       is  possible  to  disable  the  warning by explicitly requesting the OLD, or backward compatible behavior
       using the <u>cmake_policy()</u> command.  It is  also  possible  to  request  <b>NEW</b>,  or  non-backward  compatible
       behavior  for  a  policy,  also  avoiding  the warning.  Each policy can also be set to either <b>NEW</b> or <b>OLD</b>
       behavior explicitly on the command line with the <u>CMAKE_POLICY_DEFAULT_CMP&lt;NNNN&gt;</u> variable.

       A policy is a deprecation mechanism and not a reliable feature toggle.  A policy should almost  never  be
       set  to <b>OLD</b>, except to silence warnings in an otherwise frozen or stable codebase, or temporarily as part
       of a larger migration path. The <b>OLD</b> behavior of each policy is undesirable and will be replaced  with  an
       error condition in a future release.

       The <u>cmake_minimum_required()</u> command does more than report an error if a too-old version of CMake is used
       to  build  a  project.   It  also  sets  all  policies introduced in that CMake version or earlier to <b>NEW</b>
       behavior.  To manage policies without increasing the  minimum  required  CMake  version,  the  <u>if(POLICY)</u>
       command may be used:

          if(POLICY CMP0990)
            cmake_policy(SET CMP0990 NEW)
          endif()

       This  has the effect of using the <b>NEW</b> behavior with newer CMake releases which users may be using and not
       issuing a compatibility warning.

       The setting of a policy is confined in some cases to not propagate to the parent scope.  For example,  if
       the  files  read  by the <u>include()</u> command or the <u>find_package()</u> command contain a use of <u>cmake_policy()</u>,
       that policy  setting  will  not  affect  the  caller  by  default.   Both  commands  accept  an  optional
       <b>NO_POLICY_SCOPE</b> keyword to control this behavior.

       The  <u>CMAKE_MINIMUM_REQUIRED_VERSION</u>  variable may also be used to determine whether to report an error on
       use of deprecated macros or functions.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.31</b></h4><pre>
   <b>CMP0180</b>
       Added in version 3.31.

       <u>project()</u> always sets <b>&lt;PROJECT-NAME&gt;_*</b> as normal variables.

       In CMake 3.29 and below, the <u>project()</u> command set <u>&lt;PROJECT-NAME&gt;_SOURCE_DIR</u>,  <u>&lt;PROJECT-NAME&gt;_BINARY_DIR</u>,
       and  <u>&lt;PROJECT-NAME&gt;_IS_TOP_LEVEL</u>  as  cache  entries,  but  not  as normal variables.  CMake 3.30 started
       setting them as normal variables, but only if they are already set as normal variables.  This was  needed
       to  preserve  support  for  some  <u>FetchContent</u>  use cases under policy <u>CMP0169</u>'s NEW behavior, while also
       preserving behavior of nested directories that call <u>project()</u> with the same project  name.   See  release
       notes for 3.30.3, 3.30.4, and 3.30.5 for details.

       CMake  3.31  and  later  prefer  to  always set <b>&lt;PROJECT-NAME&gt;_SOURCE_DIR</b>, <b>&lt;PROJECT-NAME&gt;_BINARY_DIR</b>, and
       <b>&lt;PROJECT-NAME&gt;_IS_TOP_LEVEL</b>, as both cache entries and normal variables,  regardless  of  what  cache  or
       normal  variables  already  exist.   This  policy  provides compatibility for projects that have not been
       updated to expect this behavior.

       The <b>OLD</b>  behavior  for  this  policy  will  only  set  normal  variables  for  <b>&lt;PROJECT-NAME&gt;_SOURCE_DIR</b>,
       <b>&lt;PROJECT-NAME&gt;_BINARY_DIR</b>,  and <b>&lt;PROJECT-NAME&gt;_IS_TOP_LEVEL</b> if there is already a normal variable by that
       name when <u>project()</u> is called.  The <b>NEW</b> behavior for this policy will always  set  normal  variables  for
       <b>&lt;PROJECT-NAME&gt;_SOURCE_DIR</b>,  <b>&lt;PROJECT-NAME&gt;_BINARY_DIR</b>,  and <b>&lt;PROJECT-NAME&gt;_IS_TOP_LEVEL</b> when <u>project()</u> is
       called.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0179</b>
       Added in version 3.31.

       De-duplication of static libraries on link lines keeps first occurrence.  This policy  is  only  relevant
       when policy <u>CMP0156</u> is set to <b>NEW</b>.

       Based  on the linker capabilities, the static libraries can be de-duplicated. See policy <u>CMP0156</u> for more
       information.

       CMake 3.30 and below may choose to keep, on some platforms, the last occurrence of the  static  libraries
       rather than the fist occurrence when they are de-duplicated.

       CMake  3.31 and above prefer to keep, on all platforms, the first occurrence of the static libraries when
       they are de-duplicated.

       The <b>OLD</b> behavior for this policy is to keep, on  some  platforms,  the  last  occurrence  of  the  static
       libraries  when they are de-duplicated.  The <b>NEW</b> behavior for this policy is to keep the first occurrence
       of the static libraries when they are de-duplicated, regardless of the platform.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0178</b>
       Added in version 3.31.

       Test command lines preserve empty arguments.

       Empty values in the <u>TEST_LAUNCHER</u> and <u>CROSSCOMPILING_EMULATOR</u> target properties  are  now  preserved  for
       tests added by the following:

       • The <u>add_test()</u> command.

       • The <u>ExternalData_Add_Test()</u> command from the <u>ExternalData</u> module.

       • The <u>gtest_add_tests()</u> or <u>gtest_discover_tests()</u> commands from the <u>GoogleTest</u> module.

       For  the <u>gtest_add_tests()</u> and <u>gtest_discover_tests()</u> commands, empty elements in the values passed after
       the <b>EXTRA_ARGS</b> keyword are also now preserved.

       The <b>OLD</b> behavior  of  this  policy  silently  discards  empty  list  items  from  the  <u>TEST_LAUNCHER</u>  and
       <u>CROSSCOMPILING_EMULATOR</u>  target properties in the above-mentioned cases.  It also silently discards empty
       items from the values  given  after  <b>EXTRA_ARGS</b>  for  the  <u>gtest_add_tests()</u>  and  <u>gtest_discover_tests()</u>
       commands.

       The   <b>NEW</b>   behavior   of   this   policy   preserves   empty   list   items  in  the  <u>TEST_LAUNCHER</u>  and
       <u>CROSSCOMPILING_EMULATOR</u> target properties, and in values given after <b>EXTRA_ARGS</b> for <u>gtest_add_tests()</u> and
       <u>gtest_discover_tests()</u>.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0177</b>
       Added in version 3.31.

       <u>install()</u> <b>DESTINATION</b> paths are normalized.

       The <u>install()</u> command has a number of different forms, and most of them take a <b>DESTINATION</b> keyword,  some
       in  more  than  one  place.  CMake 3.30 and earlier used the value given after the <b>DESTINATION</b> keyword as
       provided with no transformations.  The <u>install(EXPORT)</u> form assumes the path contains no  <b>..</b>  or  <b>.</b>  path
       components  when  computing  a  path relative to the <b>DESTINATION</b>, and if the project provided a path that
       violated that assumption, the computed path would be incorrect.

       CMake 3.31 normalizes all <b>DESTINATION</b> values given in any form of the <u>install()</u> command, except  for  the
       <b>INCLUDES</b>  <b>DESTINATION</b>  of  the <u>install(TARGETS)</u> form.  The normalization performed is the same as for the
       <u>cmake_path()</u> command (see <u>Normalization</u>).

       The <b>OLD</b> behavior of this policy performs no translation  on  the  <b>DESTINATION</b>  values  of  any  <u>install()</u>
       command.   They  are  used  exactly as provided.  If a destination path contains <b>..</b> or <b>.</b> path components,
       <u>install(EXPORT)</u> will use the same wrong paths as CMake 3.30 and earlier.

       The <b>NEW</b> behavior will normalize all <b>DESTINATION</b> values except for <b>INCLUDES</b> <b>DESTINATION</b>.  If a destination
       path contains a generator expression, it will be wrapped in a <b>$&lt;PATH:CMAKE_PATH,NORMALIZE,...&gt;</b>  generator
       expression.

       This   policy   was   introduced   in   CMake   version  3.31.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake will warn if it detects a path that would be different
       if normalized, and uses <b>OLD</b> behavior.  If a destination path contains a  generator  expression,  no  such
       warning will be issued regardless of the value.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0176</b>
       Added in version 3.31.

       <u>execute_process()</u> <b>ENCODING</b> is <b>UTF-8</b> by default.

       The <b>ENCODING</b> option is meaningful only on Windows.  It specifies the character encoding expected  in  the
       process's  output  on  stdout  and  stderr.  In CMake 3.14 and below the default encoding was <b>NONE</b>, which
       corresponds to CMake's internal UTF-8 encoding.  In CMake 3.15 through CMake 3.30  the  default  encoding
       was accidentally changed to <b>AUTO</b>, but the change went unnoticed and was not documented.

       CMake  3.31  and  above prefer the <b>ENCODING</b> default to be <b>UTF-8</b>.  This policy provides compatibility with
       projects that may have been relying on the default being <b>AUTO</b>.

       The <b>OLD</b> behavior of this policy is for <u>execute_process()</u> to  use  <b>AUTO</b>  by  default  if  no  <b>ENCODING</b>  is
       specified.  The <b>NEW</b> behavior for this policy is to use <b>UTF-8</b> as the default <b>ENCODING</b>.

       This   policy   was   introduced   in   CMake   version  3.31.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0175</b>
       Added in version 3.31.

       <u>add_custom_command()</u> rejects invalid arguments.

       CMake  3.30  and  earlier  silently ignored unsupported keywords and missing or invalid arguments for the
       different forms of the  <u>add_custom_command()</u>  command.  CMake  3.31  implements  more  rigorous  argument
       checking and will flag invalid or missing arguments as errors.

       The  <b>OLD</b>  behavior  of  this  policy will accept the same invalid keywords or arguments as CMake 3.30 and
       earlier. The <b>NEW</b> behavior will flag the following as errors that previously went unreported:

       • The <b>OUTPUT</b> form does not accept <b>PRE_BUILD</b>, <b>PRE_LINK</b>, or <b>POST_BUILD</b> keywords.

       • When  the  <b>APPEND</b>  keyword  is  given,   the   <b>OUTPUT</b>   form   also   does   not   accept   <b>BYPRODUCTS</b>,
         <b>COMMAND_EXPAND_LISTS</b>,  <b>DEPENDS_EXPLICIT_ONLY</b>,  <b>DEPFILE</b>,  <b>JOB_POOL</b>,  <b>JOB_SERVER_AWARE</b>, <b>USES_TERMINAL</b>, or
         <b>VERBATIM</b> keywords.

       • The <b>TARGET</b> form requires exactly one of <b>PRE_BUILD</b>, <b>PRE_LINK</b>, or <b>POST_BUILD</b> to be given.  Previously, if
         none were given, <b>POST_BUILD</b> was assumed, or if multiple keywords were given, the last one was used.

       • The  <b>TARGET</b>  form  does  not  accept   <b>DEPENDS</b>,   <b>DEPENDS_EXPLICIT_ONLY</b>,   <b>DEPFILE</b>,   <b>IMPLICIT_DEPENDS</b>,
         <b>MAIN_DEPENDENCY</b>, <b>JOB_POOL</b>, or <b>JOB_SERVER_AWARE</b> keywords.

       • The <b>TARGET</b> form now requires at least one <b>COMMAND</b> to be given.

       • If  a  keyword  expects  a  value  to  be given after it, but no value is provided, that was previously
         treated as though the keyword was not given at all.

       • The <b>COMMENT</b> keyword expects exactly one value after it.  If  multiple  values  are  given,  or  if  the
         <b>COMMENT</b> keyword is given more than once, this is an error.

       This   policy   was   introduced   in   CMake   version  3.31.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0174</b>
       Added in version 3.31.

       <u>cmake_parse_arguments(PARSE_ARGV)</u> defines a variable for an empty string after a single-value keyword.

       One  of  the main reasons for using the <b>PARSE_ARGV</b> form of the <u>cmake_parse_arguments()</u> command is to more
       robustly handle corner cases related to empty values.  The non-<b>PARSE_ARGV</b>  form  doesn't  preserve  empty
       arguments,  but  the  <b>PARSE_ARGV</b>  form  does.   For each single-value keyword given, a variable should be
       defined if the keyword is present, even if it is followed by an empty string.

       Prior to CMake 3.31, no variable would be defined if the value given after a single-value keyword was  an
       empty  string.   This meant the code could not detect the difference between the keyword not being given,
       and it being given but with an empty value, except by iterating over all the arguments  and  checking  if
       the keyword is present.

       For  the  <b>OLD</b> behavior of this policy, <u>cmake_parse_arguments(PARSE_ARGV)</u> does not define a variable for a
       single-value keyword followed by an empty string, or followed by no value at all.

       For the <b>NEW</b> behavior, <u>cmake_parse_arguments(PARSE_ARGV)</u> always defines a variable for each keyword  given
       in the arguments, even a single-value keyword with an empty string as its value or no value at all.  With
       the  <b>NEW</b>  behavior, the code can robustly check if a single-value keyword was given using just <b>if(DEFINED</b>
       <b>&lt;prefix&gt;_&lt;keyword&gt;)</b>.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0173</b>
       Added in version 3.31.

       The <u>CMakeFindFrameworks</u> module is removed.

       CMake's framework handling has evolved well beyond what  the  <b>CMakeFindFrameworks</b>  module  supports.  The
       module  lacks  any  handling  of  XCFrameworks,  it  never  documented  the  one command it provides, and
       <u>find_library()</u> provides superior capabilities in all respects.

       The <b>OLD</b> behavior of this policy is for  <u>CMakeFindFrameworks</u>  to  continue  to  provide  the  undocumented
       <b>cmake_find_frameworks()</b>  command.  The <b>NEW</b> behavior halts with a fatal error if anything tries to include
       the module.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0172</b>
       Added in version 3.31.

       The <u>CPack</u> module enables per-machine installation by default in the <u>CPack</u> <u>WIX</u> <u>Generator</u>.

       The <u>CPack</u> <u>WIX</u> <u>Generator</u>'s <u>CPACK_WIX_INSTALL_SCOPE</u> option controls the  scope  of  the  generated  Windows
       Installer  package.   When  <u>CPACK_WIX_VERSION</u>  is  set  to  4 or higher, the default scope is <b>perMachine</b>.
       However, when using WIX 3 the default scope is <b>NONE</b>, and CPack does  not  set  any  <b>InstallScope</b>  in  the
       package  specification.  The resulting installer requires administrative privileges and installs into the
       system-wide <b>ProgramFiles</b> directory, but the start menu entry and  uninstaller  registration  are  created
       only for the current user.

       The  <u>CPack</u>  module in CMake 3.30 and older does not specify any <u>CPACK_WIX_INSTALL_SCOPE</u> value by default,
       so CPack uses no installation scope by default with WIX 3.  CMake 3.31 and newer instead  prefer  to  set
       <u>CPACK_WIX_INSTALL_SCOPE</u> to <b>perMachine</b> by default to make the behavior consistent across all WIX versions.
       This policy provides compatibility for projects that have not been updated to expect <b>perMachine</b> behavior.

       The  <b>OLD</b> behavior for this policy is to not set <u>CPACK_WIX_INSTALL_SCOPE</u> by default.  The <b>NEW</b> behavior for
       this policy is to set <u>CPACK_WIX_INSTALL_SCOPE</u> to <b>perMachine</b> by default.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0172</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0171</b>
       Added in version 3.31.

       <b>codegen</b> is a reserved target name.

       CMake 3.30 and earlier did not reserve <b>codegen</b> as a builtin target name, leaving projects free to  create
       their own target with that name.  CMake 3.31 and later prefer to reserve <b>codegen</b> as a builtin target name
       to  drive  custom  commands created with the <b>CODEGEN</b> option to <u>add_custom_command()</u>.  In order to support
       building the <b>codegen</b> target in scripted environments, e.g., <b>cmake</b> <b>--build</b> <b>.</b> <b>--target</b> <b>codegen</b>, the <b>codegen</b>
       target needs to be generated even if no custom commands use the <b>CODEGEN</b>  option.   This  policy  provides
       compatibility for projects that have not been updated to avoid creating a target named <b>codegen</b>.

       The  <b>OLD</b>  behavior  of  this  policy  allows  projects to create a target with the name <b>codegen</b>.  The <b>NEW</b>
       behavior halts with a fatal error if a target with the name <b>codegen</b> is created.

       This  policy  was  introduced  in  CMake  version  3.31.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.30</b></h4><pre>
   <b>CMP0170</b>
       Added in version 3.30.

       When   <b>FETCHCONTENT_FULLY_DISCONNECTED</b>    is    set    to    true,    <u>FetchContent_MakeAvailable()</u>    and
       <u>FetchContent_Populate()</u>  enforce  the  constraint  that their source directory must already be populated.
       The requirement has always been documented, but it was not checked or enforced with CMake 3.29 or  older.
       This  sometimes  led to hard-to-trace errors when a project expected a dependency to have been populated,
       but its population was silently skipped.

       CMake 3.30 and above prefers to check and enforce the constraint.  This policy provides compatibility for
       situations  where  the  user   cannot   easily   prevent   <b>FETCHCONTENT_FULLY_DISCONNECTED</b>   from   being
       inappropriately set to true.

       The  <b>OLD</b>  behavior  of  this  policy  allows  <b>FETCHCONTENT_FULLY_DISCONNECTED</b> to be set to true even if a
       dependency's source directory has not been populated.  The <b>NEW</b> behavior  halts  with  a  fatal  error  if
       <b>FETCHCONTENT_FULLY_DISCONNECTED</b>  is  set  to  true and a dependency population would be skipped, but that
       dependency's source directory doesn't exist.

       This  policy  was  introduced  in  CMake  version  3.30.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0169</b>
       Added in version 3.30.

       Calling <u>FetchContent_Populate()</u> with a single argument (the name of a declared dependency) is deprecated.

       Prior to the introduction of <u>FetchContent_MakeAvailable()</u>, projects populated previously declared content
       (with <u>FetchContent_Declare()</u>) using the following pattern:

          FetchContent_GetProperties(depname)
          if(NOT depname_POPULATED)
            FetchContent_Populate(depname)
            add_subdirectory(${depname_SOURCE_DIR} ${depname_BINARY_DIR})
          endif()

       The above pattern does not support a number of features that have been added to <u>FetchContent</u>  over  time.
       It  ignores  options  like  <b>SYSTEM</b> and <b>EXCLUDE_FROM_ALL</b> which may be given to <u>FetchContent_Declare()</u>, but
       can't be made known to the above project code. It also does not support <u>dependency</u>  <u>providers</u>.   Projects
       should call <u>FetchContent_MakeAvailable()</u> instead of using the above pattern.

       CMake  3.30  and  above  prefers  to  reject calls to <u>FetchContent_Populate()</u> with the name of a declared
       dependency.  This policy provides  compatibility  for  projects  that  have  not  been  updated  to  call
       <u>FetchContent_MakeAvailable()</u> instead.

       The  <b>OLD</b>  behavior of this policy allows <u>FetchContent_Populate()</u> to be called with the name of a declared
       dependency.  The <b>NEW</b> behavior halts with a fatal error in such cases.

       <b>NOTE:</b>
          Calling <u>FetchContent_Populate()</u> with the full population details as command arguments rather than just
          a dependency name remains fully supported. Only the form calling <u>FetchContent_Populate()</u> with a single
          argument (the name of a previously declared dependency) is deprecated with this policy.

       This  policy  was  introduced  in  CMake  version  3.30.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0168</b>
       Added in version 3.30.

       The <u>FetchContent</u> module implements steps directly instead of through a sub-build.

       CMake 3.29 and below implement FetchContent as a separate  sub-build.   This  required  configuring  that
       separate  project  and  using  a  build  tool.   This  approach can be very slow with some generators and
       operating systems.  CMake 3.30 and above prefer to  implement  the  download,  update,  and  patch  steps
       directly as part of the main project.

       The <b>NEW</b> behavior has the following characteristics:

       • No  sub-build  is used. All operations are implemented directly from the main project's CMake configure
         step. When running in CMake script mode, no build tool needs to be available.

       • Generator expressions and GNU Make variables of the form <b>$(SOMEVAR)</b> are not supported. They should  not
         be used in any argument to <u>FetchContent_Declare()</u> or <u>FetchContent_Populate()</u>.

       • All  <b>LOG_...</b>  and  <b>USES_TERMINAL_...</b> options, the <b>QUIET</b> option, and the <u>FETCHCONTENT_QUIET</u> variable are
         ignored.  <u>FetchContent</u> output is always part of the main project's configure output. This also means it
         now respects the message logging level  (see  <u>CMAKE_MESSAGE_LOG_LEVEL</u>  and  <u>--log-level</u>).  The  default
         message log level should be comparable to using <b>QUIET</b> with the <b>OLD</b> policy setting, except that warnings
         will now be shown.

       • The  <b>PREFIX</b>,  <b>TMP_DIR</b>,  <b>STAMP_DIR</b>,  <b>LOG_DIR</b>,  and  <b>DOWNLOAD_DIR</b>  options and their associated directory
         properties are ignored. The <u>FetchContent</u> module controls those locations internally.

       • <u>cmake</u> <u>--fresh</u> will remove the stamp and script files used for tracking and populating  the  dependency.
         This  will  force  the  dependency's download, update, and patch steps to be re-executed. The directory
         used for downloads is not affected by <u>cmake</u> <u>--fresh</u>, so any previously downloaded  files  for  the  <b>URL</b>
         download method can still be re-used.

       The <b>OLD</b> behavior has the following characteristics:

       • A  sub-build  is  always  used to implement the download, update, and patch steps. A build tool must be
         available, even when using <u>FetchContent_Populate()</u> in CMake script mode.

       • Generator expressions and GNU Make variables of the form <b>$(SOMEVAR)</b> can be used, although such  use  is
         almost  always  inappropriate.  They are evaluated in the sub-build, so they do not see any information
         from the main build.

       • All logging, terminal control, and directory options related to the download, update,  or  patch  steps
         are supported.

       • If  the  <b>QUIET</b>  option is used, or the <u>FETCHCONTENT_QUIET</u> variable is set to true, warnings will not be
         shown in the output.

       • <u>cmake</u> <u>--fresh</u> has no effect on the dependency's stamp or script files. Previously executed  steps  will
         only re-run if details about the dependency have changed.

       There's  a  reasonably good chance that users can set the <u>CMAKE_POLICY_DEFAULT_CMP0168</u> variable to <b>NEW</b> to
       globally switch to the <b>NEW</b> behavior while waiting for the project and its dependencies to be updated  use
       the  <b>NEW</b>  policy  setting  by  default.  Projects  don't  typically make use of the features that the <b>NEW</b>
       behavior no longer supports, and even those projects that do  will  often  still  work  fine  when  those
       options  are  ignored. Before setting this behavior globally, check whether any <u>FetchContent_Declare()</u> or
       <u>FetchContent_Populate()</u> calls use the ignored options in a way that  would  change  observable  behavior,
       other than putting temporary or internally-generated files in different locations.

       This   policy   was   introduced   in   CMake   version  3.30.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0167</b>
       Added in version 3.30.

       The <u>FindBoost</u> module is removed.

       CMake  3.29  and below provide a <b>FindBoost</b> module, but it needs constant updates to keep up with upstream
       Boost releases.  Upstream Boost 1.70 and above provide a <b>BoostConfig.cmake</b>  package  configuration  file.
       <b>find_package(Boost</b> <b>CONFIG)</b> finds the upstream package directly, without the find module.

       CMake  3.30  and  above  prefer  to  not  provide the <b>FindBoost</b> module so that <b>find_package(Boost)</b> calls,
       without the <b>CONFIG</b> or <b>NO_MODULE</b> options, find  the  upstream  <b>BoostConfig.cmake</b>  directly.   This  policy
       provides compatibility for projects that have not been ported to use the upstream Boost package.

       The  <b>OLD</b>  behavior  of  this policy is for <b>find_package(Boost)</b> to load CMake's <u>FindBoost</u> module.  The <b>NEW</b>
       behavior is for <b>find_package(Boost)</b> to search for the upstream <b>BoostConfig.cmake</b>.

       This  policy  was  introduced  in  CMake  version  3.30.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0166</b>
       Added in version 3.30.

       <u>TARGET_PROPERTY</u> evaluates link properties transitively over private dependencies of static libraries.

       In  CMake   3.29   and   below,   the   <u>TARGET_PROPERTY</u>   generator   expression   evaluates   properties
       <u>INTERFACE_LINK_OPTIONS</u>, <u>INTERFACE_LINK_DIRECTORIES</u>, and <u>INTERFACE_LINK_DEPENDS</u> as if they were <u>Transitive</u>
       <u>Compile</u>  <u>Properties</u>  rather  than  <u>Transitive</u>  <u>Link</u>  <u>Properties</u>,  even when policy <u>CMP0099</u> is set to <b>NEW</b>.
       Private dependencies of static libraries, which  appear  in  their  <u>INTERFACE_LINK_LIBRARIES</u>  guarded  by
       <u>LINK_ONLY</u>  generator  expressions,  are  not  followed.  This is inconsistent with evaluation of the same
       target properties during buildsystem generation.

       CMake  3.30  and  above  prefer  that  <u>TARGET_PROPERTY</u>   evaluates   properties   <u>INTERFACE_LINK_OPTIONS</u>,
       <u>INTERFACE_LINK_DIRECTORIES</u>,  and  <u>INTERFACE_LINK_DEPENDS</u>  as <u>Transitive</u> <u>Link</u> <u>Properties</u> such that private
       dependencies of static libraries, which appear in their  <u>INTERFACE_LINK_LIBRARIES</u>  guarded  by  <u>LINK_ONLY</u>
       generator  expressions, are followed.  This policy provides compatibility for projects that have not been
       updated to expect the new behavior.

       The <b>OLD</b> behavior for this policy is for <u>TARGET_PROPERTY</u> to  evaluate  properties  <u>INTERFACE_LINK_OPTIONS</u>,
       <u>INTERFACE_LINK_DIRECTORIES</u>,  and  <u>INTERFACE_LINK_DEPENDS</u> as if they were <u>Transitive</u> <u>Compile</u> <u>Properties</u> by
       not following private dependencies of static libraries.  The <b>NEW</b> behavior for this policy is to  evaluate
       them as <u>Transitive</u> <u>Link</u> <u>Properties</u> by following private dependencies of static libraries.

       This   policy   was   introduced   in   CMake   version  3.30.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0165</b>
       Added in version 3.30.

       <u>enable_language()</u> must not be called before <u>project()</u>.

       In  CMake  3.29  and below, if a project called <u>enable_language()</u> before the first call to <u>project()</u>, the
       language would be enabled but possibly using unset details that were expected to be set.  In  CMake  3.30
       and  above,  <u>enable_language()</u>  prefers  to  reject  this  case and stop with a fatal error instead if it
       detects that <u>project()</u> has not yet been called.  This policy provides  compatibility  for  projects  that
       happened  to  work  when  <u>enable_language()</u> was called before <u>project()</u> and have not been updated to call
       these commands in the required order.

       The <b>OLD</b> behavior for this policy is to allow <u>enable_language()</u> to be called before  <u>project()</u>.   The  <b>NEW</b>
       behavior for this policy is to fail with a fatal error in such cases.

       This   policy   was   introduced   in   CMake   version  3.30.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0164</b>
       Added in version 3.30.

       <u>add_library()</u> rejects <b>SHARED</b> libraries when not supported by the platform.

       In  CMake  3.29 and below, on platforms that do not support shared libraries (<u>TARGET_SUPPORTS_SHARED_LIBS</u>
       is false), the <u>add_library()</u> command automatically converts <b>SHARED</b> libraries to <b>STATIC</b> libraries to  help
       users  build  projects  on  such  platforms.   However,  the semantics of shared and static libraries are
       different enough that such automatic conversion cannot work in general.  Projects using shared  libraries
       need to be ported to such platforms on a case-by-case basis.

       In  CMake  3.30 and above, <u>add_library()</u> prefers to reject creation of shared libraries on platforms that
       do not support them, and fail with a  fatal  error  message.   This  policy  provides  compatibility  for
       projects  that  happened  to  work  with  the  automatic conversion to static libraries and have not been
       updated with an explicit port.

       The <b>OLD</b> behavior for this policy is to implicitly create a static library with a developer warning.   The
       <b>NEW</b> behavior for this policy is to fail.

       This   policy   was   introduced   in   CMake   version  3.30.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn about the behavior change, and uses  <b>OLD</b>
       behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0163</b>
       Added in version 3.30.

       The <u>GENERATED</u> source file property is now visible in all directories.

       In CMake 3.29 and below, the <u>GENERATED</u> source file property,  like  other  source  file  properties,  was
       scoped  in  every  directory separately.  Although policy <u>CMP0118</u> allowed sources marked <b>GENERATED</b> in one
       directory to be used in other directories without manually marking them as <b>GENERATED</b> again, the <b>GENERATED</b>
       property was still not visible to <u>get_property()</u> and <u>get_source_file_property()</u> calls.

       Whether or not a source file is generated is an all-or-nothing global property of the source: a source is
       either generated or it is not.  CMake 3.30 and above prefer to treat the <u>GENERATED</u> source  file  property
       as  globally  scoped.   Once  it is set in one directory, it is immediately visible to <u>get_property()</u> and
       <u>get_source_file_property()</u> calls in other directories.  This policy provides compatibility  for  projects
       that have not been updated for this behavior.

       The  <b>OLD</b>  behavior  of  this  policy  is for the <b>GENERATED</b> source file property to be visible only in the
       directories in which it is set.  The <b>NEW</b> behavior of this policy is to allow the  <b>GENERATED</b>  source  file
       property  to  be  visible in all directories once set in any directory.  Furthermore, the <b>NEW</b> behavior of
       this policy implies the <b>NEW</b> behavior of policy <u>CMP0118</u>: the <b>GENERATED</b> property may be set only to boolean
       values, and may not be turned off once turned on.

       This  policy  was  introduced  in  CMake  version  3.30.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0162</b>
       Added in version 3.30.

       <u>Visual</u> <u>Studio</u> <u>Generators</u> add <b>UseDebugLibraries</b> indicators by default.

       The "Use Debug Libraries" setting in Visual Studio projects indicates what configurations are  considered
       debug  configurations.   In  standalone  projects,  this  may  affect MSBuild's default selection of MSVC
       runtime library, optimization flags, runtime checks, and similar settings.  CMake typically generates all
       those settings explicitly based on the project's specification, so CMake 3.29 and below do not write  any
       <b>UseDebugLibraries</b> indicators to <b>.vcxproj</b> files.

       CMake  3.30  and above prefer to write <b>UseDebugLibraries</b> indicators because they are useful for reference
       by both humans and tools, and may also affect the behavior of platform-specific SDKs.  The indicator  for
       each configuration of a target is determined as follows:

       • If  the  target  compiles  sources  for  a  known  MSVC  runtime  library  (such  as  that specified by
         <u>MSVC_RUNTIME_LIBRARY</u>), then <b>UseDebugLibraries</b> is <b>true</b> for configurations that  compile  for  a  "Debug"
         runtime library, and <b>false</b> for others.

       • Otherwise,  such  as in targets created by <u>add_custom_target()</u>, <b>UseDebugLibraries</b> is <b>true</b> for the <b>Debug</b>
         configuration, and <b>false</b> for others.

       This policy provides compatibility for projects that have not been updated to expect the indicators.  The
       policy setting is recorded by each target as it is created and used to determine the default behavior for
       that target's <b>.vcxproj</b> file.

       The <b>OLD</b> behavior for this policy is to not generate <b>UseDebugLibraries</b> indicators  by  default.   The  <b>NEW</b>
       behavior for this policy is to generate <b>UseDebugLibraries</b> indicators by default.

       If  the  <u>CMAKE_VS_USE_DEBUG_LIBRARIES</u>  variable  and/or <u>VS_USE_DEBUG_LIBRARIES</u> target property is set, it
       explicitly controls <b>UseDebugLibraries</b> generation regardless of this policy.

       This  policy  was  introduced  in  CMake  version  3.30.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.29</b></h4><pre>
   <b>CMP0161</b>
       Added in version 3.29.

       The <u>CPACK_PRODUCTBUILD_DOMAINS</u> variable defaults to true.

       Before CMake 3.29, the <u>CPACK_PRODUCTBUILD_DOMAINS</u> variable is unset by default.   When  using  the  <u>CPack</u>
       <u>productbuild</u>  <u>Generator</u>,  this disables the use of the <b>domains</b> attribute in the productbuild Distribution
       XML, and falls back to the <b>auth</b> attribute instead.  These attributes control where a productbuild package
       is allowed to be installed.  But the <b>auth</b> attribute has been deprecated  by  Apple,  so  projects  should
       migrate to using <b>domains</b> instead.

       CMake  3.29  and  above prefer to use a default value of true for <u>CPACK_PRODUCTBUILD_DOMAINS</u>, which means
       <b>domains</b> will be used by default unless the project explicitly sets <u>CPACK_PRODUCTBUILD_DOMAINS</u>  to  false.
       This  policy  provides compatibility with projects that enabled the <u>CPack</u> <u>productbuild</u> <u>Generator</u>, but did
       not explicitly set <u>CPACK_PRODUCTBUILD_DOMAINS</u>.

       The <b>OLD</b> behavior for this policy is to leave <u>CPACK_PRODUCTBUILD_DOMAINS</u> unset if it hasn't been set.  The
       <b>NEW</b> behavior for this policy is to use a default value of true for <u>CPACK_PRODUCTBUILD_DOMAINS</u>.

       This  policy  was  introduced  in  CMake  version  3.29.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       Note that a warning will only be emitted if the <u>CPACK_BINARY_PRODUCTBUILD</u> variable is set to true and the
       project is being built for an Apple platform.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0160</b>
       Added in version 3.29.

       More read-only target properties now error when trying to set them.

       The <u>set_target_properties()</u> and <u>set_property()</u> commands are  intended  to  error  out  on  all  read-only
       properties. However, CMake 3.28 and below only did this for the following properties:

       • <u>HEADER_SETS</u>

       • <u>INTERFACE_HEADER_SETS</u>

       • <u>IMPORTED_GLOBAL</u>

       • <u>MANUALLY_ADDED_DEPENDENCIES</u>

       • <u>NAME</u>

       • <u>TYPE</u>

       This policy enforces the read-only nature of the following target properties:

       • <u>ALIAS_GLOBAL</u>

       • <u>BINARY_DIR</u>

       • <u>CXX_MODULE_SETS</u>

       • <u>IMPORTED</u>

       • <u>INTERFACE_CXX_MODULE_SETS</u>

       • <u>LOCATION</u>

       • <u>LOCATION_&lt;CONFIG&gt;</u>

       • <u>SOURCE_DIR</u>

       The  <b>OLD</b>  behavior  for  this policy is to only error out for the properties <u>MANUALLY_ADDED_DEPENDENCIES</u>,
       <u>NAME</u>, and <u>TYPE</u>.  The <b>NEW</b> behavior for this policy is to error out  on  all  target  properties  that  are
       documented as read-only.

       This   policy   was   introduced   in   CMake   version  3.29.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0159</b>
       Added in version 3.29.

       <u>file(STRINGS)</u> with <b>REGEX</b> updates <u>CMAKE_MATCH_&lt;n&gt;</u>.

       In  CMake  3.28  and  below  the  <u>file(STRINGS)</u>  command's  <b>REGEX</b>  option does not affect <u>CMAKE_MATCH_&lt;n&gt;</u>
       variables.  CMake 3.29 and above prefer to update the <u>CMAKE_MATCH_&lt;n&gt;</u> variables using captures  from  the
       last  match  in  the  file,  similar  to  the  <u>string(REGEX</u>  <u>MATCHALL)</u>  command.   This  policy  provides
       compatibility for projects that have not been updated to expect the behavior.

       The <b>OLD</b> behavior for this policy is  for  <u>file(STRINGS)</u>  with  <b>REGEX</b>  to  not  store  capture  groups  in
       <u>CMAKE_MATCH_&lt;n&gt;</u> variables.  The <b>NEW</b> behavior is to store the capture groups.

       This   policy   was   introduced   in   CMake   version  3.29.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0158</b>
       Added in version 3.29.

       <u>add_test()</u> honors <u>CMAKE_CROSSCOMPILING_EMULATOR</u> only when <u>cross-compiling</u>.

       In  CMake  3.28  and  below,  <u>add_test()</u> unconditionally used the <u>CROSSCOMPILING_EMULATOR</u> target property
       (initialized by the <u>CMAKE_CROSSCOMPILING_EMULATOR</u>  variable)  to  run  test  commands  naming  executable
       targets.   CMake 3.29 and above prefer to use the emulator only when the <u>CMAKE_CROSSCOMPILING</u> variable is
       enabled.  The <u>CMAKE_TEST_LAUNCHER</u> variable may be used instead when  not  cross-compiling.   This  policy
       provides compatibility for projects that have not been updated.

       The  <b>OLD</b>  behavior  for  this policy is for <u>add_test()</u> to use the <u>CROSSCOMPILING_EMULATOR</u> target property
       unconditionally.  The <b>NEW</b> behavior for this policy is for <u>add_test()</u> to use  the  <u>CROSSCOMPILING_EMULATOR</u>
       target property only when <u>cross-compiling</u>.

       This   policy   was   introduced   in   CMake   version  3.29.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0157</b>
       Added in version 3.29.

       Swift compilation mode is selected by an abstraction.

       The  Swift  compiler  can  compile modules in different modes. The desired build mode depends whether the
       developer is iterating and wants to incrementally make changes, or if they are  building  a  release  for
       distribution and want more optimizations applied to the resulting binary.

       CMake  versions  3.26  through  3.28  build  Swift  binaries with whole-module optimizations enabled when
       configured in a non-debug build type.  For CMake versions earlier  than  3.26,  the  developer  needs  to
       specify  the  necessary  flag  manually  for  the  <u>Ninja</u>  <u>Generators</u>, and cannot not specify whole-module
       optimizations to the <u>Xcode</u> generator.

       CMake versions 3.29 and above prefer to set the compilation mode using the <u>Swift_COMPILATION_MODE</u>  target
       property, which can be initialized by the <u>CMAKE_Swift_COMPILATION_MODE</u> variable.

       This  policy  provides  compatibility  for projects that have not been updated.  The policy setting takes
       effect as of the first <u>project()</u> or <u>enable_language()</u> command that enables the <b>Swift</b> language.

       <b>NOTE:</b>
          Once the policy has taken effect at the top of a project, that choice  must  be  used  throughout  the
          tree. In projects that have nested projects in subdirectories, be sure to convert everything together.

       The  <b>OLD</b>  behavior  for  this  policy  builds  all  Swift  targets  in  <b>wholemodule</b>  mode  for  non-debug
       configurations.  <u>Ninja</u> <u>Generators</u> prepend the <b>-wmo</b> flag to the default set of  Swift  flags.   The  <u>Xcode</u>
       generator sets the <b>SWIFT_COMPILATION_MODE</b> attribute to <b>wholemodule</b> in the generated Xcode project file.

       The <b>NEW</b> behavior for this policy is to apply the compilation mode specified in the <u>Swift_COMPILATION_MODE</u>
       target property, initialized as each target is created by the <u>CMAKE_Swift_COMPILATION_MODE</u> variable.

       This   policy   was   introduced   in   CMake   version  3.29.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0156</b>
       Added in version 3.29.

       De-duplicate libraries on link lines based on linker capabilities.

       Traditional linkers maintain a set of undefined symbols during linking. The linker processes each file in
       the  order  in which it appears on the command line, until the set of undefined symbols becomes empty. An
       object file is linked into the output object when it is encountered, with its undefined symbols added  to
       the  set.  Upon encountering an archive file a traditional linker searches the objects contained therein,
       and processes those that satisfy symbols in the unresolved set.

       Handling mutually dependent archives may be awkward when using a traditional linker.  Archive  files  may
       have to be specified multiple times.

       Some  linkers  (for  instance  Apple or Windows linkers, as well as <b>LLVM</b> <b>LLD</b>) record all symbols found in
       objects and archives as they iterate over command line arguments. When one of these linkers encounters an
       undefined symbol that can be resolved by an object file contained in a previously processed archive file,
       it immediately extracts and links it into the output object.

       CMake 3.28 and below may generate link lines that repeat static libraries as a traditional  linker  would
       need,  even  when  using  a linker that does not need it.  They may also de-duplicate shared libraries by
       keeping their last occurrence, which on Windows platforms can change DLL load order.

       CMake 3.29 and above prefer to apply  different  strategies  based  on  linker  capabilities.   So,  when
       targeting  Apple and Windows platforms, all libraries are de-duplicated.  Moreover, on Windows platforms,
       libraries are de-duplicated by keeping their first  occurrence,  thus  respecting  the  project-specified
       order.   This policy provides compatibility with projects that have not been updated to expect the latter
       behavior.

       <b>NOTE:</b>
          When this policy is set to <b>NEW</b>, the policy <u>CMP0179</u> controls which occurrence of the  static  libraries
          is kept when they are de-duplicated.

       The  <b>OLD</b>  behavior for this policy is to always repeat static libraries as if using a traditional linker,
       and always de-duplicate shared libraries by keeping the last occurrence of each.  The  <b>NEW</b>  behavior  for
       this policy is to apply different strategies based on linker capabilities.

       This   policy   was   introduced   in   CMake   version  3.29.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.28</b></h4><pre>
   <b>CMP0155</b>
       Added in version 3.28.

       C++ sources in targets with at least C++20 are scanned for imports when supported.

       CMake  3.27  and  below  assume  that  C++ sources do not <b>import</b> modules.  CMake 3.28 and above prefer to
       assume that C++ sources in targets using C++20 or higher might <b>import</b> modules, and must be scanned before
       compiling, unless explicitly disabled.  This policy provides compatibility for projects that use C++20 or
       higher,  without  modules,  that  have  not  been  updated  to  turn  off   scanning,   e.g.,   via   the
       <u>CMAKE_CXX_SCAN_FOR_MODULES</u>  variable.   See the <u><a href="../man7/cmake-cxxmodules.7.html">cmake-cxxmodules</a>(7)</u> manual for more details on C++ module
       support.

       The <b>OLD</b> behavior for this policy is to assume that C++ 20 and newer sources do not import  modules.   The
       <b>NEW</b>  behavior for this policy is to assume that C++ 20 and newer files may import modules if the compiler
       understands how to scan for their dependencies, and need to be scanned.

       This  policy  was  introduced  in  CMake  version  3.28.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0154</b>
       Added in version 3.28.

       Generated files are private by default in targets using <u>File</u> <u>Sets</u>.

       CMake 3.27 and below assume that any file generated as an output or byproduct of <u>add_custom_command()</u>  or
       <u>add_custom_target()</u>  may  be  a public header file meant for inclusion by dependents' source files.  This
       requires <u>Ninja</u> <u>Generators</u> to add conservative order-only dependencies  that  prevent  a  target's  source
       files  from  compiling  before custom commands from the target's dependencies are finished, even if those
       custom commands only produce sources private to their own target.

       <u>File</u> <u>Sets</u>, introduced by CMake 3.23, provide a way to express the visibility of generated  header  files.
       CMake  3.28  and  above prefer to assume that, in targets using file sets, generated files are private to
       their own target by default.  Generated public headers must be specified  as  members  of  a  <b>PUBLIC</b>  (or
       <b>INTERFACE</b>)  <b>FILE_SET</b>,  typically  of  type <b>HEADERS</b>.  With this information, <u>Ninja</u> <u>Generators</u> may omit the
       above-mentioned conservative dependencies and produce more efficient build graphs.

       Additionally, if the custom command's output is a member of a file  set  of  type  <b>CXX_MODULES</b>,  it  will
       additionally  not  be  required  to exist before compiling other sources in the same target.  Since these
       files should not be included at compile time directly, they may not be implicitly required to  exist  for
       other compilation rules.

       This  policy  provides  compatibility for projects using file sets in targets with generated header files
       that have not been updated.  Such projects should be updated to express generated  public  headers  in  a
       file set.  For example:

          add_custom_command(
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/foo.h
            ...
          )
          target_sources(foo
            PUBLIC FILE_SET HEADERS
              BASE_DIRS ${CMAKE_CURRENT_BINARY_DIR}
              FILES     ${CMAKE_CURRENT_BINARY_DIR}/foo.h
          )

       The  <b>OLD</b>  behavior  for  this  policy is to assume generated files are public, even in targets using file
       sets, and for <u>Ninja</u> <u>Generators</u> to produce conservative build graphs.  The <b>NEW</b> behavior for this policy is
       to assume generated files are private in targets using file sets, and for  <u>Ninja</u>  <u>Generators</u>  to  produce
       more efficient build graphs.

       This   policy   was   introduced   in   CMake   version  3.28.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0153</b>
       Added in version 3.28.

       The <u>exec_program()</u> command should not be called.

       This  command  has  long  been  superseded by the <u>execute_process()</u> command and has been deprecated since
       CMake 3.0.

       CMake &gt;= 3.28 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow the
       command to be called.  The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b>  when  the  command  is
       called.

       This   policy   was   introduced   in   CMake   version  3.28.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0152</b>
       Added in version 3.28.

       <u>file(REAL_PATH)</u> resolves symlinks before collapsing ../ components.

       In  CMake  3.27  and  below,  <u>file(REAL_PATH)</u>  collapsed  any  <b>../</b>  components in a path before resolving
       symlinks.  This produced incorrect results when the <b>../</b> collapsed away a symlink.

       The <b>OLD</b> behavior for this policy is to collapse  <b>../</b>  components  before  resolving  symlinks.   The  <b>NEW</b>
       behavior for this policy is to resolve all symlinks before collapsing <b>../</b> components.

       This   policy   was   introduced   in   CMake   version  3.28.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.27</b></h4><pre>
   <b>CMP0151</b>
       Added in version 3.27.

       AUTOMOC include directory is a system include directory by default.

       Headers  generated  for  <u>AUTOMOC</u> are placed in target-specific include directories.  CMake 3.26 and older
       added these as normal include directories.  CMake 3.27 and newer prefer to add  them  as  system  include
       directories.  This policy provides compatibility for projects that have not been updated to expect this.

       If     the     <u>AUTOGEN_USE_SYSTEM_INCLUDE</u>     target     property     is    set,    perhaps    via    the
       <u>CMAKE_AUTOGEN_USE_SYSTEM_INCLUDE</u> variable, then its value is used  regardless  of  the  setting  of  this
       policy.

       The <b>OLD</b> behavior for this policy is to add autogen include directory to the target's include directories.
       The  <b>NEW</b>  behavior  for  this  policy  is to add autogen include directory to the target's system include
       directories.

       This  policy  was  introduced  in  CMake  version  3.27.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0150</b>
       Added in version 3.27.

       <u>ExternalProject_Add()</u> and <u>FetchContent_Declare()</u> commands treat relative <b>GIT_REPOSITORY</b>  paths  as  being
       relative to the parent project's remote.

       Earlier  versions  of  these commands always treated relative paths in <b>GIT_REPOSITORY</b> as local paths, but
       the base directory it was treated as relative to was both undocumented and unintuitive.  The <b>OLD</b> behavior
       for this policy is to interpret relative paths used for <b>GIT_REPOSITORY</b> as local  paths  relative  to  the
       following:

       • The parent directory of <b>SOURCE_DIR</b> for <u>ExternalProject_Add()</u>.

       • <b>FETCHCONTENT_BASE_DIR</b> for <u>FetchContent_Declare()</u>.

       The  <b>NEW</b>  behavior  is to determine the remote from the parent project and interpret the path relative to
       that remote.  The value of <u>CMAKE_CURRENT_SOURCE_DIR</u> when <u>ExternalProject_Add()</u> or  <u>FetchContent_Declare()</u>
       is  called  determines  the parent project.  The remote is selected according to the following (the first
       match is used):

       • If the parent project is checked out on a branch with an upstream remote defined, use that remote.

       • If only one remote is defined, use that remote.

       • If multiple remotes are defined and one of them is named <b>origin</b>, use <b>origin</b>'s remote but also  issue  a
         warning.

       If an appropriate remote cannot be determined from the above, a fatal error will be raised.

       This   policy   was   introduced   in   CMake   version  3.27.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns when a relative path is  encountered,  and  uses
       <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0149</b>
       Added in version 3.27.

       <u>Visual</u> <u>Studio</u> <u>Generators</u> select latest Windows SDK by default.

       Visual Studio Generators select a Windows SDK version to put in the <b>WindowsTargetPlatformVersion</b>  setting
       in  <b>.vcxproj</b> files.  CMake sets the <u>CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION</u> variable to the selected SDK
       version.

       Prior to CMake 3.27, the SDK version was  always  selected  by  the  value  of  the  <u>CMAKE_SYSTEM_VERSION</u>
       variable.   Users  or  toolchain  files  could set that variable to one of the exact Windows SDK versions
       available on the host system.  Since <u>CMAKE_SYSTEM_VERSION</u> defaults to <u>CMAKE_HOST_SYSTEM_VERSION</u>,  and  it
       is  not  guaranteed that a matching Windows SDK version is available, CMake had to fall back to using the
       latest Windows SDK version if no exact match was available.  This approach was problematic:

       • The latest Windows SDK might or might not be selected based on whether  the  host  version  of  Windows
         happens to match an available SDK version.

       • An  old  Windows  SDK  version might be selected that has not been updated for newer language standards
         such as C11.

       CMake 3.27 and higher prefer to ignore the exact value of <u>CMAKE_SYSTEM_VERSION</u> and by default select  the
       latest SDK version available.  An exact SDK version may be specified explicitly using a <b>version=</b> field in
       the <u>CMAKE_GENERATOR_PLATFORM</u> variable.  See <u>Visual</u> <u>Studio</u> <u>Platform</u> <u>Selection</u>.

       This  policy  provides  compatibility for projects, toolchain files, and build scripts that have not been
       ported away from using <u>CMAKE_SYSTEM_VERSION</u> to specify an exact SDK version.

       <b>NOTE:</b>
          This policy must be set before the first <u>project()</u> or <u>enable_language()</u> command invocation at the  top
          of the project.  That is when <u>Visual</u> <u>Studio</u> <u>Generators</u> select a Windows SDK.

       The  <b>OLD</b> behavior for this policy is to use the exact value of <u>CMAKE_SYSTEM_VERSION</u> if possible.  The <b>NEW</b>
       behavior for this policy is to ignore it.

       This  policy  was  introduced  in  CMake  version  3.27.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0148</b>
       Added in version 3.27.

       The <u>FindPythonInterp</u> and <u>FindPythonLibs</u> modules are removed.

       These modules have been deprecated since CMake 3.12.  CMake 3.27 and above  prefer  to  not  provide  the
       modules.  This policy provides compatibility for projects that have not been ported away from them.

       Projects  using  the <u>FindPythonInterp</u> and/or <u>FindPythonLibs</u> modules should be updated to use one of their
       replacements:

       • <u>FindPython3</u>

       • <u>FindPython2</u>

       • <u>FindPython</u>

       The <b>OLD</b> behavior of this policy is for <b>find_package(PythonInterp)</b> and  <b>find_package(PythonLibs)</b>  to  load
       the deprecated modules.  The <b>NEW</b> behavior is for uses of the modules to fail as if they do not exist.

       This   policy   was   introduced   in   CMake   version  3.27.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0147</b>
       Added in version 3.27.

       <u>Visual</u> <u>Studio</u> <u>Generators</u> build custom commands in parallel.

       Visual  Studio  15.8 (2017) and newer support building custom commands in parallel.  CMake 3.27 and above
       prefer to enable this behavior by adding a <b>BuildInParallel</b> setting to custom commands in <b>.vcxproj</b>  files.
       This  policy provides compatibility for projects that have not been updated to expect this, e.g., because
       their custom commands were accidentally relying on serial execution by MSBuild.

       The <b>OLD</b> behavior for this policy is to not add <b>BuildInParallel</b>.  The <b>NEW</b> behavior for this policy  is  to
       add <b>BuildInParallel</b> for VS 15.8 and newer.

       This   policy   was   introduced   in   CMake   version  3.27.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0146</b>
       Added in version 3.27.

       The <u>FindCUDA</u> module is removed.

       The <u>FindCUDA</u> module has been deprecated since CMake 3.10.  CMake 3.27 and above prefer to not provide the
       module.  This policy provides compatibility for projects that have not been ported away from it.

       Projects  using  the  <u>FindCUDA</u> module should be updated to use CMake's first-class <b>CUDA</b> language support.
       List <b>CUDA</b> among the languages named in  the  top-level  call  to  the  <u>project()</u>  command,  or  call  the
       <u>enable_language()</u> command with <b>CUDA</b>.  Then one can add CUDA (<b>.cu</b>) sources directly to targets, similar to
       other languages.

       The  <b>OLD</b>  behavior  of  this  policy  is  for  <b>find_package(CUDA)</b> to load the deprecated module.  The <b>NEW</b>
       behavior is for uses of the module to fail as if it does not exist.

       This  policy  was  introduced  in  CMake  version  3.27.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0145</b>
       Added in version 3.27.

       The <u>Dart</u> and <u>FindDart</u> modules are removed.

       These modules were added very early in CMake's development to support driving tests with a  "DART"  tool,
       but  DART has not been distributed or maintained for many years.  Projects would <b>include(Dart)</b> to use it,
       and the <b>Dart</b> module would run <b>find_package(Dart)</b> internally.  Since <u><a href="../man1/ctest.1.html">ctest</a>(1)</u> was created, the <b>Dart</b> module
       has just been a compatibility shim that finds <b>Dart</b> to support some legacy functionality and then forwards
       to the <u>CTest</u> module.

       CMake 3.27 and above prefer  to  not  provide  the  <u>Dart</u>  or  <u>FindDart</u>  modules.   This  policy  provides
       compatibility  for  projects  that  have  not been ported away from them.  Projects using the <b>Dart</b> module
       should be updated to use the <u>CTest</u> module directly.

       The <b>OLD</b> behavior of this policy is for  <b>include(Dart)</b>  and  <b>find_package(Dart)</b>  to  load  the  deprecated
       modules.  The <b>NEW</b> behavior is for uses of the modules to fail as if they do not exist.

       This   policy   was   introduced   in   CMake   version  3.27.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0144</b>
       Added in version 3.27.

       <u>find_package()</u> uses upper-case <b>&lt;PACKAGENAME&gt;_ROOT</b> variables.

       In  CMake  3.27  and above the <u>find_package(&lt;PackageName&gt;)</u> command now searches prefixes specified by the
       upper-case <u>&lt;PACKAGENAME&gt;_ROOT</u> CMake variable and the <u>&lt;PACKAGENAME&gt;_ROOT</u> environment variable in  addition
       to  the  case-preserved  <u>&lt;PackageName&gt;_ROOT</u>  and  <u>&lt;PackageName&gt;_ROOT</u> variables used since policy <u>CMP0074</u>.
       This  policy  provides  compatibility  with  projects  that  have  not  been  updated  to   avoid   using
       <b>&lt;PACKAGENAME&gt;_ROOT</b> variables for other purposes.

       The  <b>OLD</b> behavior for this policy is to ignore <b>&lt;PACKAGENAME&gt;_ROOT</b> variables if the original <b>&lt;PackageName&gt;</b>
       has lower-case characters.  The <b>NEW</b> behavior for this policy is to use <b>&lt;PACKAGENAME&gt;_ROOT</b> variables.

       This  policy  was  introduced  in  CMake  version  3.27.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.26</b></h4><pre>
   <b>CMP0143</b>
       Added in version 3.26.

       <u>USE_FOLDERS</u> global property is treated as <b>ON</b> by default.

       When using CMake 3.25 or earlier, <u>USE_FOLDERS</u> is treated as <b>OFF</b> by default  unless  projects  enable  the
       feature.  For example:

          cmake_minimum_required(VERSION 3.25)
          project(foobar LANGUAGES CXX)
          set_property(GLOBAL PROPERTY USE_FOLDERS ON)

       CMake 3.26 and later prefer to enable the feature by default.

       Note  that  it  is  the policy setting at the <u>end</u> of the top level <b>CMakeLists.txt</b> file that matters.  The
       policy setting applies globally to the whole project.

       This policy provides compatibility with projects that  have  not  been  updated  to  expect  enabling  of
       folders.  Enabling folders causes projects to appear differently in IDEs.

       This   policy   was   introduced   in   CMake   version  3.26.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.25</b></h4><pre>
   <b>CMP0142</b>
       Added in version 3.25.

       The <u>Xcode</u> generator does not append per-config suffixes to library search paths.

       In  CMake 3.24 and below, the <u>Xcode</u> generator preceded each entry of a library search path with a copy of
       itself appended with <b>$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)</b>.  This was left from very early  versions
       of CMake in which per-config directories were not well modeled.  Such paths often do not exist, resulting
       in  warnings from the toolchain.  CMake 3.25 and above prefer to not add such library search paths.  This
       policy provides compatibility for projects that may have been accidentally relying on the old behavior.

       The <b>OLD</b> behavior for this policy is to append <b>$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)</b> to  all  library
       search paths.  The <b>NEW</b> behavior is to not modify library search paths.

       This   policy   was   introduced   in   CMake   version  3.25.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0141</b>
       Added in version 3.25.

       MSVC debug information format flags are selected by an abstraction.

       Compilers  targeting  the  MSVC  ABI have flags to select the debug information format. Debug information
       format selection typically varies with build configuration.

       In  CMake   3.24   and   below,   debug   information   format   flags   are   added   to   the   default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>  cache entries by CMake automatically.  This allows users to edit their cache
       entries to adjust the flags.  However, the presence of such default flags  is  problematic  for  projects
       that  want  to  choose  a  different runtime library programmatically.  In particular, it requires string
       editing of the <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u> variables with knowledge of the CMake builtin defaults so they
       can be replaced.

       CMake  3.25  and  above  prefer  to  leave  the  debug  information  format  flags  out  of  the  default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>    values    and    instead    offer    a   first-class   abstraction.    The
       <u>CMAKE_MSVC_DEBUG_INFORMATION_FORMAT</u> variable and <u>MSVC_DEBUG_INFORMATION_FORMAT</u> target property may be set
       to select the MSVC debug information format.  If they are not set, CMake  enables  debug  information  in
       debug  configurations  using  the  default  value  <b>$&lt;$&lt;CONFIG:Debug,RelWithDebInfo&gt;:ProgramDatabase&gt;</b>,  if
       supported by the compiler, and otherwise <b>$&lt;$&lt;CONFIG:Debug,RelWithDebInfo&gt;:Embedded&gt;</b>.

       This policy provides compatibility with  projects  that  have  not  been  updated  to  be  aware  of  the
       abstraction.  The policy setting takes effect as of the first <u>project()</u> or <u>enable_language()</u> command that
       enables a language whose compiler targets the MSVC ABI.

       <b>NOTE:</b>
          Once  the  policy  has  taken  effect at the top of a project, that choice will be used throughout the
          tree.  In projects that have nested projects in subdirectories, be sure to confirm  if  everything  is
          working with the selected policy behavior.

       The  <b>OLD</b>  behavior  for  this  policy  is  to  place  MSVC  debug information format flags in the default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u> cache entries and ignore the <u>CMAKE_MSVC_DEBUG_INFORMATION_FORMAT</u> abstraction.
       The <b>NEW</b> behavior for this policy is to <u>not</u> place MSVC debug information format flags in the default cache
       entries and use the abstraction instead.

       This  policy  was  introduced  in  CMake  version  3.25.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0140</b>
       Added in version 3.25.

       The <u>return()</u> command checks its parameters.

       The <b>OLD</b> behavior for this policy is to ignore any parameters given to the command.  The <b>NEW</b>  behavior  is
       to check the validity of the parameters.

       This   policy   was   introduced   in   CMake   version  3.25.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.24</b></h4><pre>
   <b>CMP0139</b>
       Added in version 3.24.

       The <u>if()</u> command supports path comparisons using <b>PATH_EQUAL</b> operator.

       The  <b>OLD</b> behavior for this policy is to ignore the <b>PATH_EQUAL</b> operator.  The <b>NEW</b> behavior is to interpret
       the <b>PATH_EQUAL</b> operator.

       This  policy  was  introduced  in  CMake  version  3.24.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0138</b>
       Added in version 3.24.

       <u>CheckIPOSupported</u> uses flags from calling project.

       The <u>CheckIPOSupported</u> module <u>check_ipo_supported()</u> command compiles a test project to  determine  whether
       the toolchain supports <u>INTERPROCEDURAL_OPTIMIZATION</u>.  CMake 3.23 and below run the check with the default
       values  of  the  <u>CMAKE_&lt;LANG&gt;_FLAGS</u> and <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u> variables for the current environment
       and toolchain settings.  However, some projects may modify these flag variables to add flags that  affect
       availability of the toolchain's IPO features.  CMake 3.24 and above prefer to honor the calling project's
       values  for  these variables.  This policy provides compatibility for projects that have not been updated
       to expect this behavior.

       The <b>OLD</b> behavior for this policy is to ignore the calling  project's  values  of  <u>CMAKE_&lt;LANG&gt;_FLAGS</u>  and
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>.  The <b>NEW</b> behavior for this policy is to use the values of those variables as
       compiler flags in the test project.

       This   policy   was   introduced   in   CMake   version  3.24.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0137</b>
       Added in version 3.24.

       <u>try_compile()</u> passes platform variables in project mode.

       The  <u>try_compile()</u> command <u>source</u> <u>file</u> signature propagates CMake variables containing platform settings,
       and those specified  by  the  <u>CMAKE_TRY_COMPILE_PLATFORM_VARIABLES</u>  variable,  into  the  generated  test
       project.   This  helps  the  test  project drive the toolchain the same way the calling project will.  In
       CMake 3.23 and below, the <u>whole-project</u> signature does not propagate  platform  variables  automatically.
       CMake  3.24 and above prefer to propagate platform variables in the <u>whole-project</u> signature.  This policy
       provides compatibility with projects that have not been updated to expect the behavior.

       The <b>OLD</b> behavior for this policy is to not pass any additional variables to the <u>whole-project</u>  signature.
       The <b>NEW</b> behavior for this policy is to pass the same variables that the <u>source</u> <u>file</u> signature does.

       Regardless  of  the  policy  setting,  the <u>CMAKE_TRY_COMPILE_NO_PLATFORM_VARIABLES</u> variable may be set to
       suppress passing the platform variables through either signature.

       This  policy  was  introduced  in  CMake  version  3.24.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0136</b>
       Added in version 3.24.

       Watcom runtime library flags are selected by an abstraction.

       Compilers targeting the Watcom ABI have flags to select the Watcom runtime library.

       In  CMake  3.23  and  below,  Watcom  runtime  library  selection  flags  are  added   to   the   default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>  cache entries by CMake automatically.  This allows users to edit their cache
       entries to adjust the flags.  However, the presence of such default flags  is  problematic  for  projects
       that  want  to  choose  a  different runtime library programmatically.  In particular, it requires string
       editing of the <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u> variables with knowledge of the CMake builtin defaults so they
       can be replaced.

       CMake 3.24 and above prefer to leave the Watcom runtime  library  selection  flags  out  of  the  default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>    values    and    instead    offer    a   first-class   abstraction.    The
       <u>CMAKE_WATCOM_RUNTIME_LIBRARY</u> variable and <u>WATCOM_RUNTIME_LIBRARY</u> target property may be set to select the
       Watcom runtime library.  If they are not set then  CMake  uses  the  default  value  <b>MultiThreadedDLL</b>  on
       Windows and <b>SingleThreaded</b> on other platforms, which is equivalent to the original flags.

       This  policy  provides  compatibility  with  projects  that  have  not  been  updated  to be aware of the
       abstraction.  The policy setting takes effect as of the first <u>project()</u> or <u>enable_language()</u> command that
       enables a language whose compiler targets the Watcom ABI.

       <b>NOTE:</b>
          Once the policy has taken effect at the top of a project, that choice  must  be  used  throughout  the
          tree.   In  projects  that  have  nested  projects  in  subdirectories,  be sure to convert everything
          together.

       The  <b>OLD</b>  behavior  for  this  policy  is  to  place  Watcom  runtime  library  flags  in   the   default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>  cache  entries and ignore the <u>CMAKE_WATCOM_RUNTIME_LIBRARY</u> abstraction.  The
       <b>NEW</b> behavior for this policy is to <u>not</u> place Watcom runtime library flags in the  default  cache  entries
       and use the abstraction instead.

       This   policy   was   introduced   in   CMake   version  3.24.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0135</b>
       Added in version 3.24.

       When  using  the  <b>URL</b>  download method with the <u>ExternalProject_Add()</u> or <u>FetchContent_Declare()</u> commands,
       CMake 3.23 and below sets the timestamps of the extracted contents to the same as the timestamps  in  the
       archive.  When  the  <b>URL</b>  changes, the new archive is downloaded and extracted, but the timestamps of the
       extracted contents might not be newer than the previous contents. Anything that depends on the  extracted
       contents might not be rebuilt, even though the contents may change.

       CMake  3.24  and  above  prefers  to  set  the  timestamps  of  all extracted contents to the time of the
       extraction. This ensures that anything that depends on the extracted contents will  be  rebuilt  whenever
       the <b>URL</b> changes.

       The  <b>DOWNLOAD_EXTRACT_TIMESTAMP</b>  option  to the <u>ExternalProject_Add()</u> and <u>FetchContent_Declare()</u> commands
       can be used to explicitly specify how timestamps should be handled.  When  <b>DOWNLOAD_EXTRACT_TIMESTAMP</b>  is
       not  given, this policy controls the default behavior. The <b>OLD</b> behavior for this policy is to restore the
       timestamps from the archive. The <b>NEW</b> behavior sets the timestamps of extracted contents to  the  time  of
       extraction.

       This   policy   was   introduced   in   CMake   version  3.24.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0134</b>
       Added in version 3.24.

       The  default registry view is <b>TARGET</b> for the <u>find_file()</u>, <u>find_path()</u>, <u>find_library()</u>, and <u>find_package()</u>
       commands and <b>BOTH</b> for the <u>find_program()</u> command.

       The default registry views in CMake 3.23 and below are selected using the following rules:

       • if <u>CMAKE_SIZEOF_VOID_P</u> has value <b>8</b>:

         • Use view <b>64</b> for all <b>find_*</b> commands except <u>find_program()</u> command.

         • Use view <b>64_32</b> for <u>find_program()</u> command.

       • if <u>CMAKE_SIZEOF_VOID_P</u> has value <b>4</b> or is undefined:

         • Use view <b>32</b> for all <b>find_*</b> commands except <u>find_program()</u> command.

         • Use view <b>32_64</b> for <u>find_program()</u> command.

       The <b>OLD</b> behavior for this policy is to use registry views <b>64</b> and  <b>64_32</b>  or  <b>32_64</b>  and  <b>32</b>  as  default,
       depending  of  <u>CMAKE_SIZEOF_VOID_P</u>  variable  value.  The <b>NEW</b> behavior for this policy is to use registry
       views <b>TARGET</b> and <b>BOTH</b> as default.

       This  policy  was  introduced  in  CMake  version  3.24.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0133</b>
       Added in version 3.24.

       The <u>CPack</u> module disables SLA by default in the <u>CPack</u> <u>DragNDrop</u> <u>Generator</u>.

       The <u>CPack</u> <u>DragNDrop</u> <u>Generator</u> in CMake 3.22 and below attach a Software License Agreement (SLA)  to  <b>.dmg</b>
       files using the file specified by <u>CPACK_RESOURCE_FILE_LICENSE</u>, if set to a non-default value.  macOS 12.0
       deprecated  the  tools  used  to do this, so CMake 3.23 added the <u>CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE</u>
       option to control the behavior.  CMake 3.23 enables that option by default for compatibility  with  older
       versions. CMake 3.24 and above prefer to <u>not</u> enable the <u>CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE</u> option by
       default.  This  policy provides compatibility with projects that have not been updated to account for the
       lack of a SLA in their <b>.dmg</b> packages.

       The <b>OLD</b> behavior for this policy is to enable <u>CPACK_DMG_SLA_USE_RESOURCE_FILE_LICENSE</u>  by  default.   The
       <b>NEW</b> behavior for this policy is to not enable it by default.

       This   policy   was   introduced   in   CMake   version  3.24.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0133</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0132</b>
       Added in version 3.24.

       Do not set compiler environment variables on first run.

       Apart  from  when  using the Xcode generator and some Visual Studio generators, CMake 3.23 and below will
       set environment variables like <u>CC</u>, <u>CXX</u>, etc. when the  corresponding  language  is  enabled.   This  only
       occurs  on  the very first time CMake is run in a build directory, and the environment variables are only
       defined at configure time, not build time. On subsequent CMake runs, these environment variables are  not
       set, opening up the opportunity for different behavior between the first and subsequent CMake runs. CMake
       3.24  and  above  prefer  to  not set these environment variables when a language is enabled, even on the
       first run in a build directory.

       The <b>OLD</b> behavior for this policy sets the relevant environment variable on the first run when a  language
       is enabled. The <b>NEW</b> behavior for this policy does not set any such environment variables.

       This   policy   was   introduced   in   CMake   version  3.24.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0131</b>
       Added in version 3.24.

       <u>LINK_LIBRARIES</u> supports the <u>$&lt;LINK_ONLY:...&gt;</u> generator expression.

       CMake   3.23   and   below   documented  the  <u>$&lt;LINK_ONLY:...&gt;</u>  generator  expression  only  for  use  in
       <u>INTERFACE_LINK_LIBRARIES</u>.  When used in <u>LINK_LIBRARIES</u>, the content guarded inside  <u>$&lt;LINK_ONLY:...&gt;</u>  was
       always used, even when collecting non-linking usage requirements such as <u>INTERFACE_COMPILE_DEFINITIONS</u>.

       CMake  3.24  and  above  prefer  to  support  <u>$&lt;LINK_ONLY:...&gt;</u>, when used in <u>LINK_LIBRARIES</u>, by using the
       guarded content only for link dependencies and  not  other  usage  requirements.   This  policy  provides
       compatibility for projects that have not been updated to account for this change.

       The  <b>OLD</b>  behavior  for this policy is to use <u>LINK_LIBRARIES</u> content guarded by <u>$&lt;LINK_ONLY:...&gt;</u> even for
       non-linking usage requirements.  The <b>NEW</b> behavior for this policy is to use the guarded content only  for
       link dependencies.

       This   policy   was   introduced   in   CMake   version  3.24.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0130</b>
       Added in version 3.24.

       <u>while()</u> diagnoses condition evaluation errors.

       CMake  3.23  and below accidentally tolerated errors encountered while evaluating the condition passed to
       the <u>while()</u> command (but not the <u>if()</u> command).  For example, the code

          set(paren "(")
          while(${paren})
          endwhile()

       creates an unbalanced parenthesis during condition evaluation.

       CMake 3.24 and above prefer to diagnose such errors.  This policy  provides  compatibility  for  projects
       that have not been updated to fix their condition errors.

       The  <b>OLD</b>  behavior  for this policy is to ignore errors in <u>while()</u> conditions.  The <b>NEW</b> behavior for this
       policy is to diagnose errors in <u>while()</u> conditions.

       This  policy  was  introduced  in  CMake  version  3.24.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.23</b></h4><pre>
   <b>CMP0129</b>
       Added in version 3.23.

       Compiler id for MCST LCC compilers is now <b>LCC</b>, not <b>GNU</b>.

       CMake 3.23 and above recognize MCST LCC compiler as a different from <b>GNU</b>, with its own command  line  and
       set   of   capabilities.    CMake   now   prefers   to   present   this   to   projects  by  setting  the
       <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable to <b>LCC</b> instead of  <b>GNU</b>.  However,  existing  projects  may  assume  the
       compiler  id  for LCC is <b>GNU</b> as it was in CMake versions prior to 3.23.  Therefore this policy determines
       for MCST LCC compiler which compiler id to report in the <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable after language
       <b>&lt;LANG&gt;</b> is enabled by the <u>project()</u> or <u>enable_language()</u> command.  The policy must be  set  prior  to  the
       invocation of either command.

       The  <b>OLD</b> behavior for this policy is to use compiler id <b>GNU</b> (and set <u>CMAKE_&lt;LANG&gt;_COMPILER_VERSION</u> to the
       supported GNU compiler version.)  <b>NEW</b> behavior for this policy  is  to  use  compiler  id  <b>LCC</b>,  and  set
       <u>CMAKE_&lt;LANG&gt;_SIMULATE_ID</u> to <b>GNU</b>, and <u>CMAKE_&lt;LANG&gt;_SIMULATE_VERSION</u> to the supported GNU compiler version.

       This   policy   was   introduced   in   CMake   version  3.23.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0129</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.22</b></h4><pre>
   <b>CMP0128</b>
       Added in version 3.22.

       When this policy is set to <b>NEW</b>:

       • <u>&lt;LANG&gt;_EXTENSIONS</u>  is  initialized  to  <u>CMAKE_&lt;LANG&gt;_EXTENSIONS</u>  if  set,  otherwise  falling  back  to
         <u>CMAKE_&lt;LANG&gt;_EXTENSIONS_DEFAULT</u>.

       • Extensions are correctly enabled/disabled if <u>&lt;LANG&gt;_STANDARD</u> is unset or satisfied by the default.

       • Standard mode-affecting flags aren't added unless necessary to achieve the specified mode.

       The <b>OLD</b> behavior:

       • Initializes <u>&lt;LANG&gt;_EXTENSIONS</u> to <u>CMAKE_&lt;LANG&gt;_EXTENSIONS</u> if set, otherwise falling back to <b>ON</b>.

       • Always adds a flag if <u>&lt;LANG&gt;_STANDARD</u> is set and <u>&lt;LANG&gt;_STANDARD_REQUIRED</u> is <b>OFF</b>.

       • If <u>&lt;LANG&gt;_STANDARD</u> is unset:

         • Doesn't disable extensions even if <u>&lt;LANG&gt;_EXTENSIONS</u> is <b>OFF</b>.

         • Fails to enable extensions if <u>&lt;LANG&gt;_EXTENSIONS</u> is <b>ON</b> except for the <b>IAR</b> compiler.

       Code may need to be updated for the <b>NEW</b> behavior in the following cases:

       • If a standard mode flag previously overridden by CMake's and not used  during  compiler  detection  now
         takes effect due to CMake no longer adding one as the default detected is appropriate.

         Such code should be converted to either:

         • Use <u>&lt;LANG&gt;_STANDARD</u> and <u>&lt;LANG&gt;_EXTENSIONS</u> instead of manually adding flags.

         • Or ensure the manually-specified flags are used during compiler detection.

       • If  extensions  were  disabled  without  <u>&lt;LANG&gt;_STANDARD</u>  being  set CMake previously wouldn't actually
         disable extensions.

         Such code should be updated to not disable extensions if they are required.

       • If extensions were enabled/disabled when <u>&lt;LANG&gt;_STANDARD</u> was satisfied by the compiler's default  CMake
         previously wouldn't actually enable/disable extensions.

         Such code should be updated to set the correct extensions mode.

       If  compiler  flags  affecting  the  standard  mode  are used during compiler detection (for example in <u>a</u>
       <u>toolchain</u> <u>file</u> using <u>CMAKE_&lt;LANG&gt;_FLAGS_INIT</u>) then they will affect the  detected  default  <u>standard</u>  and
       <u>extensions</u>.

       This   policy   was   introduced   in   CMake   version  3.22.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0128</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0127</b>
       Added in version 3.22.

       <u>cmake_dependent_option()</u> supports full <u>Condition</u> <u>Syntax</u>.

       The <b>&lt;depends&gt;</b> parameter accepts a <u>semicolon-separated</u> <u>list</u> of conditions.  CMake 3.21 and lower evaluates
       each  <b>condition</b>  as <b>if(${condition})</b>, which does not properly handle conditions with nested paren groups.
       CMake 3.22 and above instead prefer to evaluate each <b>condition</b> as <b>if(&lt;condition&gt;)</b>, where  <b>&lt;condition&gt;</b>  is
       re-parsed as if literally written in a call to <u>if()</u>.  This allows expressions like:

          "A AND (B OR C)"

       but requires expressions like:

          "FOO MATCHES (UPPER|lower)"

       to be re-written as:

          "FOO MATCHES \"(UPPER|lower)\""

       Policy <b>CMP0127</b> provides compatibility for projects that have not been updated to expect the new behavior.

       This   policy   was   introduced   in   CMake   version  3.22.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.21</b></h4><pre>
   <b>CMP0126</b>
       Added in version 3.21.

       When  this  policy  is set to <b>NEW</b>, the <u>set(CACHE)</u> command does not remove any normal variable of the same
       name from the current scope.  The <b>OLD</b> behavior removes any normal variable of  the  same  name  from  the
       current scope in the following situations:

       • No cache variable of that name existed previously.

       • A cache variable of that name existed previously, but it had no type.  This can occur when the variable
         was set on the command line using a form like <b>cmake</b> <b>-DMYVAR=blah</b> instead of <b>cmake</b> <b>-DMYVAR:STRING=blah</b>.

       • The <b>FORCE</b> or <b>INTERNAL</b> keywords were used when setting the cache variable.

       Note  that  the  <b>NEW</b>  behavior has an important difference to the similar <b>NEW</b> behavior of policy <u>CMP0077</u>.
       The <u>set(CACHE)</u> command always sets the cache variable if it did not exist previously, regardless  of  the
       <b>CMP0126</b>  policy setting.  The <u>option()</u> command will <u>not</u> set the cache variable if a non-cache variable of
       the same name already exists and <u>CMP0077</u> is set to <b>NEW</b>.

       This  policy  was  introduced  in  CMake  version  3.21.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0126</u> variable to control the warning.

       The  <u>CMAKE_POLICY_DEFAULT_CMP0126</u>  variable  may be used to set the policy for a third-party project in a
       subdirectory without modifying it.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0125</b>
       Added in version 3.21.

       The  <u>find_file()</u>,  <u>find_path()</u>,  <u>find_library()</u>  and  <u>find_program()</u>  commands  cache their result in the
       variable specified by their first argument.  Prior to CMake 3.21,  if  a  cache  variable  of  that  name
       already  existed  before  the call but the cache variable had no type, any non-cache variable of the same
       name would be discarded and the cache variable was always used (see also  <u>CMP0126</u>  for  a  different  but
       similar behavior).  This contradicts the convention that a non-cache variable should take precedence over
       a  cache  variable  of  the same name.  Such a situation can arise if a user sets a cache variable on the
       command  line  without  specifying  a  type,  such  as  <b>cmake</b>   <b>-DMYVAR=blah</b>   <b>...</b>   instead   of   <b>cmake</b>
       <b>-DMYVAR:FILEPATH=blah</b>.

       Related  to  the above, if a cache variable of the specified name already exists and it <u>does</u> have a type,
       the various <b>find_...()</b> commands would return that value unchanged.  In  particular,  if  it  contained  a
       relative path, it would not be converted to an absolute path in this situation.

       When  policy  <b>CMP0125</b>  is  set to <b>OLD</b> or is unset, the behavior is as described above.  When it is set to
       <b>NEW</b>, the behavior is as follows:

       • If a non-cache variable of the specified name exists when the <b>find_...()</b> command is called,  its  value
         will  be  used  regardless of whether a cache variable of the same name already exists or not.  A cache
         variable will not be created in this case if no  such  cache  variable  existed  before.   If  a  cache
         variable  of  the  specified  name  did already exist, the cache will be updated to match the non-cache
         variable.

       • The various <b>find...()</b> commands will always provide an absolute path  in  the  result  variable,  except
         where a relative path provided by a cache or non-cache variable cannot be resolved to an existing path.

       This   policy   was   introduced   in   CMake   version  3.21.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0124</b>
       Added in version 3.21.

       <u>foreach()</u> loop variables are only available in the loop scope.

       CMake  3.20  and  below always leave the loop variable set at the end of the loop, either to the value it
       had before the loop, if any, or to the empty string.  CMake 3.21 and  above  prefer  to  leave  the  loop
       variable  in  the  state  it  had  before  the  loop  started, either set or unset.  This policy provides
       compatibility for projects that expect the loop variable to always be left set.

       The <b>OLD</b> behavior for this policy is to set the loop variable at the  end  of  the  loop,  either  to  its
       original  value,  or to an empty value.  The <b>NEW</b> behavior for this policy is to restore the loop variable
       to the state it had before the loop started, either set or unset.

       For example:

          set(items a b c)

          set(var1 "value")
          unset(var2)

          foreach(var1 IN LISTS items)
          endforeach()

          foreach(var2 IN LISTS items)
          endforeach()

          if(DEFINED var1)
            message("var1: ${var1}")
          endif()
          if(DEFINED var2)
            message("var2: ${var2}")
          endif()

       Under the <b>OLD</b> behavior, this code prints <b>var1:</b> <b>value</b> and <b>var2:</b>.  Under the <b>NEW</b> behavior, this code prints
       only <b>var1:</b> <b>value</b>.

       This  policy  was  introduced  in  CMake  version  3.21.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0123</b>
       Added in version 3.21.

       <b>ARMClang</b> cpu/arch compile and link flags must be set explicitly.

       CMake 3.20  and  lower  automatically  maps  the  <u>CMAKE_SYSTEM_PROCESSOR</u>  variable  and  an  undocumented
       <b>CMAKE_SYSTEM_ARCH</b>  to  compile  and link options for <b>ARMClang</b>.  For example, the <b>-mcpu=cortex-m33</b> flag is
       added when <u>CMAKE_SYSTEM_PROCESSOR</u> equals <b>cortex-m33</b>.  CMake requires projects to set either  variable  or
       it  raises  a fatal error.  However, the project may need to additionally specify CPU features using e.g.
       <b>-mcpu=cortex-m33+nodsp</b>, conflicting with the <b>-mcpu=cortex-m33</b> added by CMake.   This  results  in  either
       link errors or unusable binaries.

       CMake  3.21  and  above  prefer  instead  to  not  add any cpu/arch compile and link flags automatically.
       Instead, projects must specify them explicitly.  This policy provides  compatibility  for  projects  that
       have not been updated.

       The  <b>OLD</b> behavior of this policy requires projects that use <b>ARMClang</b> to set either <u>CMAKE_SYSTEM_PROCESSOR</u>
       or <b>CMAKE_SYSTEM_ARCH</b> and it automatically adds a compile option <b>-mcpu=</b>  or  <b>-march=</b>  and  a  link  option
       <b>--cpu=</b> based on those variables.  The <b>NEW</b> behavior does not add compile or link options, and projects are
       responsible for setting correct options.

       This   policy   was   introduced   in   CMake   version  3.21.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0122</b>
       Added in version 3.21.

       <u>UseSWIG</u> use library name conventions for <b>CSharp</b> language.

       Starting  with  CMake 3.21, <u>UseSWIG</u> generates now a library using default naming conventions. This policy
       provides compatibility with projects that expect the legacy behavior.

       This  policy  was  introduced  in  CMake  version  3.21.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0121</b>
       Added in version 3.21.

       The <u>list()</u> command now detects invalid indices.

       Prior to CMake version 3.21, the <u>list()</u> command's <b>GET</b>, <b>INSERT</b>, <b>SUBLIST</b>, and <b>REMOVE_AT</b> subcommands did not
       detect invalid index arguments.

       The <b>OLD</b> behavior of this policy is for invalid indices to be treated as their integer value (if  any)  at
       the start of the string. For example, <b>2good4you</b> is a <b>2</b> and <b>not_an_integer</b> is a <b>0</b>. The <b>NEW</b> behavior is for
       invalid indices to trigger an error.

       This   policy   was   introduced   in   CMake   version  3.21.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.20</b></h4><pre>
   <b>CMP0120</b>
       Added in version 3.20.

       The <u>WriteCompilerDetectionHeader</u> module is removed.

       CMake  versions  3.1  through  3.19 provide this module to generate a C++ compatibility layer by re-using
       information from CMake's table of preprocessor checks for <u><a href="../man7/cmake-compile-features.7.html">cmake-compile-features</a>(7)</u>.  However:

       • Those granular features have been superseded by meta-features for <u>Requiring</u> <u>Language</u> <u>Standards</u> such  as
         <b>cxx_std_11</b>.  Therefore no new granular feature checks will be added and projects will need to use other
         means to conditionally use new C++ features.

       • The module exposes some of CMake's implementation details directly to C++ translation units.

       • The  module's  approach  effectively  provides  a header file with CMake, thus tying the version of the
         header to the version of CMake.  Many projects found that  the  <u>WriteCompilerDetectionHeader</u>  was  best
         used by manually generating its header locally with a recent version of CMake and then bundling it with
         the project source so that it could be used with older CMake versions.

       For   reasons   including   the   above,   CMake   3.20   and   above   prefer   to   not   provide   the
       <u>WriteCompilerDetectionHeader</u> module.  This policy provides compatibility for projects that have not  been
       ported  away  from  it.   Projects  using  the  module  should be updated to stop using it.  Alternatives
       include:

       • Bundle a copy of the generated header in the project's source.

       • Use a third-party alternative, such as the CC0-licensed <u>Hedley</u>.

       • Drop support for compilers too old to provide the features natively.

       The <b>OLD</b> behavior of this policy is for inclusion of the deprecated <u>WriteCompilerDetectionHeader</u> module to
       work.  The <b>NEW</b> behavior is for inclusion of the module to fail as if it does not exist.

       This  policy  was  introduced  in  CMake  version  3.20.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0119</b>
       Added in version 3.20.

       <u>LANGUAGE</u> source file property explicitly compiles as specified language.

       The <u>LANGUAGE</u> source file property is documented to mean that the source file is written in the  specified
       language.   In  CMake 3.19 and below, setting this property causes CMake to compile the source file using
       the compiler for the specified language.  However, it only passes an explicit flag to tell  the  compiler
       to  treat  the  source as the specified language for MSVC-like, XL, and Embarcadero compilers for the <b>CXX</b>
       language.  CMake 3.20 and above prefer to also explicitly tell the compiler to use the specified language
       using a flag such as <b>-x</b> <b>c</b> on all compilers for which such flags are known.

       This policy provides compatibility for projects that have not been updated to expect this behavior.   For
       example,  some  projects  were setting the <b>LANGUAGE</b> property to <b>C</b> on assembly-language <b>.S</b> source files in
       order to compile them using the C compiler.  Such projects should be updated to use <b>enable_language(ASM)</b>,
       for which CMake will often choose the C compiler as the assembler on relevant platforms anyway.

       The <b>OLD</b> behavior for this policy is to interpret the <b>LANGUAGE</b>  <b>&lt;LANG&gt;</b>  property  using  its  undocumented
       meaning  to  "use  the  <b>&lt;LANG&gt;</b>  compiler".  The <b>NEW</b> behavior for this policy is to interpret the <b>LANGUAGE</b>
       <b>&lt;LANG&gt;</b> property using its documented meaning to "compile as a <b>&lt;LANG&gt;</b> source".

       This  policy  was  introduced  in  CMake  version  3.20.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0118</b>
       Added in version 3.20.

       <u>GENERATED</u> sources may be used across directories without manual marking.

       In CMake 3.19 and below, the <u>GENERATED</u> source file property,  like  other  source  file  properties,  was
       scoped  in  every directory separately.  If a source file was generated in one directory, projects had to
       manually set the <b>GENERATED</b> property in another directory in order to use the file.

       Whether or not a source file is generated is an all-or-nothing global property of the source: a source is
       either generated or it is not.  CMake 3.20 and above prefer  to  allow  source  files  generated  in  one
       directory  to be used in other directories without manually marking them as <b>GENERATED</b>.  Additionally, the
       <b>GENERATED</b> property may now be set only to boolean values, and may not be turned off once turned on.  This
       policy provides compatibility for projects that have not been updated for this behavior.

       The <b>OLD</b> behavior of this policy is to allow generated files to be used only in directories in which their
       <b>GENERATED</b> property has been turned on.  The <b>NEW</b> behavior of this policy is to allow generated files to be
       used in other directories without explicitly turning on the <b>GENERATED</b> property for those directories.

       Added in version 3.30: Policy <u>CMP0163</u> additionally makes the <u>GENERATED</u> source file  property  visible  to
       <u>get_property()</u> and <u>get_source_file_property()</u> calls in other directories.

       This   policy   was   introduced   in   CMake   version  3.20.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns  about  setting  the  <b>GENERATED</b>  property  to  a
       non-boolean value, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0117</b>
       Added in version 3.20.

       MSVC RTTI flag <b>/GR</b> is not added to <u>CMAKE_CXX_FLAGS</u> by default.

       When using MSVC-like compilers in CMake 3.19 and below, the RTTI flag <b>/GR</b> is added to <u>CMAKE_CXX_FLAGS</u>  by
       default.  This behavior is left from support for MSVC versions from Visual Studio 2003 and below that did
       not enable RTTI by default.  It is no longer necessary.  Furthermore, it is problematic for projects that
       want   to   change  to  <b>/GR-</b>  programmatically.   In  particular,  it  requires  string  editing  of  the
       <u>CMAKE_CXX_FLAGS</u> variable with knowledge of the CMake builtin default so it can be replaced.

       CMake 3.20 and above prefer to leave out <b>/GR</b> from the value of <u>CMAKE_CXX_FLAGS</u> by default.

       This policy provides compatibility with projects that have not been updated to expect the lack of the <b>/GR</b>
       flag.  The policy setting takes effect as of  the  first  <u>project()</u>  or  <u>enable_language()</u>  command  that
       initializes <u>CMAKE_CXX_FLAGS</u>.

       <b>NOTE:</b>
          Once  the  policy  has  taken effect at the top of a project for a given language, that choice must be
          used throughout the tree for that language.  In projects that have nested projects in  subdirectories,
          be sure to convert everything together.

       The  <b>OLD</b>  behavior  for  this  policy  is to place the MSVC <b>/GR</b> flag in the default <u>CMAKE_CXX_FLAGS</u> cache
       entry.  The <b>NEW</b> behavior for this policy is to <u>not</u> place the MSVC <b>/GR</b> flag in the default cache entry.

       This  policy  was  introduced  in  CMake  version  3.20.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0116</b>
       Added in version 3.20.

       Ninja generators transform <b>DEPFILE</b> s from <u>add_custom_command()</u>.

       In CMake 3.19 and below, files given to the <b>DEPFILE</b> argument of <u>add_custom_command()</u> were passed directly
       to Ninja's <b>depfile</b> variable without any path resolution. This  meant  that  if  <u>add_custom_command()</u>  was
       called  from a subdirectory (created by <u>add_subdirectory()</u>), the <b>DEPFILE</b> argument would have to be either
       an absolute path or a  path  relative  to  <u>CMAKE_BINARY_DIR</u>,  rather  than  <u>CMAKE_CURRENT_BINARY_DIR</u>.  In
       addition, no transformation was done on the file listed in <b>DEPFILE</b>, which meant that the paths within the
       <b>DEPFILE</b> had the same restrictions.

       Starting  with  CMake  3.20,  the  <b>DEPFILE</b> argument is relative to <u>CMAKE_CURRENT_BINARY_DIR</u> (unless it is
       absolute),  and  the  paths  in  the  <b>DEPFILE</b>  are  also  relative  to  <u>CMAKE_CURRENT_BINARY_DIR</u>.   CMake
       automatically  transforms the paths in the <b>DEPFILE</b> (unless they are absolute) after the custom command is
       run. The file listed in <b>DEPFILE</b> is not modified in any way. Instead, CMake writes the  transformation  to
       its  own  internal  file, and passes this internal file to Ninja's <b>depfile</b> variable.  This transformation
       happens  regardless  of  whether  or  not  <b>DEPFILE</b>  is  relative,  and  regardless  of  whether  or   not
       <u>add_custom_command()</u> is called from a subdirectory.

       The  <b>OLD</b>  behavior  for  this policy is to pass the <b>DEPFILE</b> to Ninja unaltered. The <b>NEW</b> behavior for this
       policy is to transform the <b>DEPFILE</b> after running the custom command. The status of <b>CMP0116</b> is recorded at
       the time of the custom command's creation, and you can have custom commands in the  same  directory  with
       different values for <b>CMP0116</b> by setting the policy before each custom command.

       This   policy   was   introduced   in   CMake   version  3.20.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default (unless <b>DEPFILE</b> is used in  a
       subdirectory), and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0116</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0115</b>
       Added in version 3.20.

       Source file extensions must be explicit.

       In CMake 3.19 and below, if a source file could not be found by the name specified,  it  would  append  a
       list  of  known extensions to the name to see if the file with the extension could be found. For example,
       this would allow the user to run:

          add_executable(exe main)

       and put <b>main.c</b> in the executable without specifying the extension.

       Starting in CMake 3.20, CMake prefers all source files to have their extensions explicitly listed:

          add_executable(exe main.c)

       The <b>OLD</b> behavior for this policy is to implicitly append known extensions to source files if  they  can't
       be  found.  The  <b>NEW</b>  behavior  of  this  policy is to not append known extensions and require them to be
       explicit.

       This  policy  was  introduced  in  CMake  version  3.20.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.19</b></h4><pre>
   <b>CMP0114</b>
       Added in version 3.19.

       <u>ExternalProject</u> step targets fully adopt their steps.

       The <u>ExternalProject_Add()</u> <b>STEP_TARGETS</b> option, and the <u>ExternalProject_Add_StepTargets()</u> function, can be
       used to create build targets for individual steps of an external project.

       In CMake 3.18 and below, step targets have some limitations:

       • Step targets always depend on targets named by the <u>ExternalProject_Add()</u> <b>DEPENDS</b> option even though not
         all steps need them.  In order to allow step targets to be  created  without  those  dependencies,  the
         <u>ExternalProject_Add()</u>   <b>INDEPENDENT_STEP_TARGETS</b>   option   or   the  <u>ExternalProject_Add_StepTargets()</u>
         <b>NO_DEPENDS</b> option may be used.  However, adding such "independent" step targets makes  sense  only  for
         specific  steps  such  as  <b>download</b>,  <b>update</b>,  and  <b>patch</b>  because they do not need any of the external
         project's build dependencies.  Furthermore, it does not make sense to create independent  step  targets
         for  steps that depend on non-independent steps.  Such rules are not enforced, and projects that do not
         follow them can generate build systems with confusing and generator-specific behavior.

       • Step targets hold copies of the custom commands implementing their steps that  are  separate  from  the
         copies  in  the primary target created by <u>ExternalProject_Add()</u>, and the primary target does not depend
         on the step targets.  In parallel builds that drive the primary target and step  targets  concurrently,
         multiple copies of the steps' commands may run concurrently and race each other.

         Also,  prior  to policy <u>CMP0113</u>, the step targets generated by <u>Makefile</u> <u>Generators</u> also contain all the
         custom commands on which their step depends.  This can lead to repeated execution of those  steps  even
         in serial builds.

       In CMake 3.19 and above, the <u>ExternalProject</u> module prefers a revised design to address these problems:

       • Each  step  is  classified  as  "independent"  if  it  does  not  depend  on other targets named by the
         <u>ExternalProject_Add()</u> <b>DEPENDS</b>.  The predefined steps are automatically classified by default:

         • The <b>download</b>, <b>update</b>, and <b>patch</b> steps are independent.

         • The <b>configure</b>, <b>build</b>, <b>test</b>, and <b>install</b> steps are not.

         For custom steps, the <u>ExternalProject_Add_Step()</u> command provides an <b>INDEPENDENT</b> option to mark them as
         independent.  It is an error to mark a step as independent if it depends on other steps that  are  not.
         Note  that  this use of the term "independent" refers only to independence from external targets and is
         orthogonal to a step's dependencies on other steps.

       • Step targets created by the <u>ExternalProject_Add()</u> <b>STEP_TARGETS</b> option or the <u>ExternalProject_Add_Step()</u>
         function  are  now  independent  if  and  only  if  their  steps  are  marked  as   independent.    The
         <u>ExternalProject_Add()</u>  <b>INDEPENDENT_STEP_TARGETS</b> option and <u>ExternalProject_Add_StepTargets()</u> <b>NO_DEPENDS</b>
         option are no longer allowed.

       • Step targets, when created, are fully responsible for holding the custom  commands  implementing  their
         steps.   The  primary target created by <u>ExternalProject_Add()</u> depends on the step targets, and the step
         targets depend on each other.  The target-level dependencies match the file-level dependencies used  by
         the custom commands for each step.

         When  the  <u>ExternalProject_Add()</u>  <b>UPDATE_DISCONNECTED</b>  or <b>TEST_EXCLUDE_FROM_MAIN</b> option is used, or the
         <u>ExternalProject_Add_Step()</u> <b>EXCLUDE_FROM_MAIN</b> option is used for a custom step, some step targets may be
         created automatically.  These are needed to hold the steps commonly depended upon by the primary target
         and the disconnected step targets.

       Policy <b>CMP0114</b> provides compatibility for projects that have not been updated to expect the new behavior.
       The <b>OLD</b> behavior for this policy is to use the above-documented behavior from 3.18 and  below.   The  <b>NEW</b>
       behavior for this policy is to use the above-documented behavior preferred by 3.19 and above.

       This   policy   was   introduced   in   CMake   version  3.19.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0113</b>
       Added in version 3.19.

       <u>Makefile</u> <u>Generators</u> do not repeat custom commands from target dependencies.

       Consider a chain of custom commands split across two dependent targets:

          add_custom_command(OUTPUT output-not-created
            COMMAND ... DEPENDS ...)
          set_property(SOURCE output-not-created PROPERTY SYMBOLIC 1)
          add_custom_command(OUTPUT output-created
            COMMAND ... DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/output-not-created)
          add_custom_target(first DEPENDS output-not-created)
          add_custom_target(second DEPENDS output-created)
          add_dependencies(second first)

       In  CMake  3.18 and lower, the Makefile generators put a copy of both custom commands in the Makefile for
       target <b>second</b> even though its dependency on target <b>first</b> ensures  that  the  first  custom  command  runs
       before  the  second.   Running  <b>make</b> <b>second</b> would cause the first custom command to run once in the <b>first</b>
       target and then again in the <b>second</b> target.

       CMake 3.19 and above prefer to not duplicate custom commands in a target that are  already  generated  in
       other  targets  on which the target depends (directly or indirectly).  This policy provides compatibility
       for projects that have not been updated to expect the new behavior.  In particular, projects that  relied
       on  the  duplicate  execution  or  that  did  not  properly  set the <u>SYMBOLIC</u> source file property may be
       affected.

       The <b>OLD</b> behavior for this policy is to duplicate custom commands in dependent targets.  The <b>NEW</b>  behavior
       of this policy is to not duplicate custom commands in dependent targets.

       This   policy   was   introduced   in   CMake   version  3.19.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0112</b>
       Added in version 3.19.

       Target file component generator expressions do not add target dependencies.

       The  following  target-based  generator  expressions  that query for directory or file name components no
       longer add a dependency on the evaluated target.

          • <b>TARGET_FILE_NAME</b>

          • <b>TARGET_FILE_DIR</b>

          • <b>TARGET_LINKER_FILE_BASE_NAME</b>

          • <b>TARGET_LINKER_FILE_NAME</b>

          • <b>TARGET_LINKER_FILE_DIR</b>

          • <b>TARGET_SONAME_FILE_NAME</b>

          • <b>TARGET_SONAME_FILE_DIR</b>

          • <b>TARGET_PDB_FILE_NAME</b>

          • <b>TARGET_PDB_FILE_DIR</b>

          • <b>TARGET_BUNDLE_DIR</b>

          • <b>TARGET_BUNDLE_DIR_NAME</b>

          • <b>TARGET_BUNDLE_CONTENT_DIR</b>

       In CMake 3.18 and lower a dependency on the evaluated target of the  above  generator  expressions  would
       always  be  added.   CMake  3.19  and  above  prefer  to  not  add this dependency.  This policy provides
       compatibility for projects that have not been updated to expect the new behavior.  The policy setting  is
       recorded  on  each  target when it is created, and decides whether generator expressions referencing that
       target imply a dependency on it.

       The <b>OLD</b> behavior for this policy is to add a dependency on the evaluated target for the  above  generator
       expressions.   The <b>NEW</b> behavior of this policy is to not add a dependency on the evaluated target for the
       above generator expressions.

       This  policy  was  introduced  in  CMake  version  3.19.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0112</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0111</b>
       Added in version 3.19.

       An imported target missing its location property fails during generation.

       <u>Imported</u> <u>Targets</u> for library files and executables require that their location on disk is specified in  a
       target  property  such  as  <u>IMPORTED_LOCATION</u>,  <u>IMPORTED_IMPLIB</u>, or a per-configuration equivalent.  If a
       needed location property is not set, CMake 3.18 and below generate the string  <b>&lt;TARGET_NAME&gt;-NOTFOUND</b>  in
       its  place,  which  results  in  failures of the corresponding rules at build time.  CMake 3.19 and above
       prefer instead to raise an error during generation.  This policy provides compatibility for projects that
       have not been updated to expect the new behavior.

       The <b>OLD</b> behavior of this policy is to generate the location of an  imported  unknown,  static  or  shared
       library target as <b>&lt;TARGET_NAME&gt;-NOTFOUND</b> if not set.  The <b>NEW</b> behavior is to raise an error.

       This   policy   was   introduced   in   CMake   version  3.19.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0110</b>
       Added in version 3.19.

       <u>add_test()</u> supports arbitrary characters in test names.

       <u>add_test()</u>  can  now  (officially) create tests with whitespace and other special characters in its name.
       Before CMake version 3.19 that was not allowed, however, it was possible to work around  this  limitation
       by explicitly putting escaped quotes around the test's name in the <b>add_test</b> command.

       Although  never  officially supported several projects in the wild found and implemented this workaround.
       However, the new change which officially allows the <b>add_test</b> command  to  support  whitespace  and  other
       special  characters  in  test  names  now  breaks  that  workaround.  In order for these projects to work
       smoothly with newer CMake versions, this policy was introduced.

       The <b>OLD</b> behavior of this policy is to  still  prevent  <b>add_test</b>  from  handling  whitespace  and  special
       characters  properly  (if not using the mentioned workaround).  The <b>NEW</b> behavior on the other hand allows
       names with whitespace and special characters for tests created by <b>add_test</b>.

       This  policy  was  introduced  in  CMake  version  3.19.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0109</b>
       Added in version 3.19.

       <u>find_program()</u> requires permission to execute but not to read.

       In CMake 3.18 and below, the <u>find_program()</u> command on UNIX would find files that  are  readable  without
       requiring  execute  permission, and would not find files that are executable without read permission.  In
       CMake 3.19 and above, <b>find_program</b> now prefers to require execute permission  but  not  read  permission.
       This policy provides compatibility with projects that have not been updated to expect the new behavior.

       The  <b>OLD</b>  behavior  for  this  policy  is  for  <b>find_program</b>  to  require read permission but not execute
       permission.  The <b>NEW</b> behavior for this policy is for <b>find_program</b> to require execute permission  but  not
       read permission.

       This   policy   was   introduced   in   CMake   version  3.19.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.18</b></h4><pre>
   <b>CMP0108</b>
       Added in version 3.18.

       A target is not allowed to link to itself even through an <b>ALIAS</b> target.

       In CMake 3.17 and below, a target can link to a target aliased to itself.

       The <b>OLD</b> behavior for this policy is to allow a target to link to a target aliased to itself.

       The <b>NEW</b> behavior of this policy is to prevent a target to link to itself through an <b>ALIAS</b> target.

       This   policy   was   introduced   in   CMake   version  3.17.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0107</b>
       Added in version 3.18.

       It is not allowed to create an <b>ALIAS</b> target with the same name as an another target.

       In CMake 3.17 and below, an <b>ALIAS</b> target can overwrite silently an existing target with the same name.

       The <b>OLD</b> behavior for this policy is to allow target overwrite.

       The <b>NEW</b> behavior of this policy is to prevent target overwriting.

       This   policy   was   introduced   in   CMake   version  3.17.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0106</b>
       Added in version 3.18.

       The <u>Documentation</u> module is removed.

       The  <u>Documentation</u>  was  added as a support mechanism for the VTK project and was tuned for that project.
       Instead of CMake providing this module with (now old) VTK  patterns  for  cache  variables  and  required
       packages, the module is now deprecated by CMake itself.

       The  <b>OLD</b>  behavior  of this policy is for <u>Documentation</u> to add cache variables and find VTK documentation
       dependent packages. The <b>NEW</b> behavior is to act as an empty module.

       This  policy  was  introduced  in  CMake  version  3.18.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0105</b>
       Added in version 3.18.

       <u>LINK_OPTIONS</u> and <u>INTERFACE_LINK_OPTIONS</u> target properties are now used for the device link step.

       In CMake 3.17 and below, link options are not used by the device link step.

       The <b>OLD</b> behavior for this policy is to ignore the link options during the device link step.

       The <b>NEW</b> behavior of this policy is to use the link options during the device link step.

       This  policy  was  introduced  in  CMake  version  3.18.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0104</b>
       Added in version 3.18.

       Initialize  <u>CMAKE_CUDA_ARCHITECTURES</u>  when  <u>CMAKE_CUDA_COMPILER_ID</u>  is  <b>NVIDIA</b>.   Raise   an   error   if
       <u>CUDA_ARCHITECTURES</u> is empty.

       <u>CMAKE_CUDA_ARCHITECTURES</u>  introduced in CMake 3.18 is used to initialize <u>CUDA_ARCHITECTURES</u>, which passes
       correct code generation flags to the CUDA compiler.

       Previous to this users had to manually specify the code generation flags. This policy  is  for  backwards
       compatibility with manually specifying code generation flags.

       The   <b>OLD</b>   behavior   for   this   policy   is   to   not   initialize   <u>CMAKE_CUDA_ARCHITECTURES</u>   when
       <u>CMAKE_CUDA_COMPILER_ID</u> is <b>NVIDIA</b>.  Empty <u>CUDA_ARCHITECTURES</u> is allowed.

       The <b>NEW</b> behavior of this policy is to initialize <u>CMAKE_CUDA_ARCHITECTURES</u> when <u>CMAKE_CUDA_COMPILER_ID</u>  is
       <b>NVIDIA</b> and raise an error if <u>CUDA_ARCHITECTURES</u> is empty during generation.

       If  <u>CUDA_ARCHITECTURES</u> is set to a false value no architectures flags are passed to the compiler. This is
       intended to support packagers and the rare cases where full control over the passed flags is required.

       This  policy  was  introduced  in  CMake  version  3.18.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>Examples</b>
          set_target_properties(tgt PROPERTIES CUDA_ARCHITECTURES "35;50;72")

       Generates code for real and virtual architectures <b>30</b>, <b>50</b> and <b>72</b>.

          set_property(TARGET tgt PROPERTY CUDA_ARCHITECTURES 70-real 72-virtual)

       Generates code for real architecture <b>70</b> and virtual architecture <b>72</b>.

          set_property(TARGET tgt PROPERTY CUDA_ARCHITECTURES OFF)

       CMake will not pass any architecture flags to the compiler.

   <b>CMP0103</b>
       Added in version 3.18.

       Multiple calls to <u>export()</u> command with same <b>FILE</b> without <b>APPEND</b> is no longer allowed.

       In CMake 3.17 and below, multiple calls to <u>export()</u>  command  with  the  same  <b>FILE</b>  without  <b>APPEND</b>  are
       accepted silently but only the last occurrence is taken into account during the generation.

       <b>The</b> <b>OLD</b> <b>behavior</b> <b>for</b> <b>this</b> <b>policy</b> <b>is</b> <b>to</b> <b>ignore</b> <b>the</b> <b>multiple</b> <b>occurrences</b> <b>of</b>
              <u>export()</u> command except the last one.

       The  <b>NEW</b>  behavior  of this policy is to raise an error on second call to <u>export()</u> command with same <b>FILE</b>
       without <b>APPEND</b>.

       This  policy  was  introduced  in  CMake  version  3.18.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.17</b></h4><pre>
   <b>CMP0102</b>
       Added in version 3.17.

       The <u>mark_as_advanced()</u> command no longer creates a cache entry if one does not already exist.

       In CMake 3.16  and  below,  if  a  variable  was  not  defined  at  all  or  just  defined  locally,  the
       <u>mark_as_advanced()</u> command would create a new cache entry with an <b>UNINITIALIZED</b> type and no value. When a
       <u>find_path()</u> (or other similar <b>find_</b> command) would next run, it would find this undefined cache entry and
       set  it  up  with  an  empty  string  value. This process would end up deleting the local variable in the
       process (due to the way the cache works), effectively clearing any stored <b>find_</b> results  that  were  only
       available in the local scope.

       The  <b>OLD</b>  behavior  for  this  policy  is to create the empty cache definition.  The <b>NEW</b> behavior of this
       policy is to ignore variables which do not already exist in the cache.

       This  policy  was  introduced  in  CMake  version  3.17.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0102</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0101</b>
       Added in version 3.17.

       <u>target_compile_options()</u> now always honors the <b>BEFORE</b> keyword.

       In CMake 3.16 and below, the <u>target_compile_options()</u> command ignores the <b>BEFORE</b> keyword  when  inserting
       items  into  the <u>COMPILE_OPTIONS</u> target property (<b>PRIVATE</b> and <b>PUBLIC</b> items).  CMake 3.17 and later honors
       the <b>BEFORE</b> keyword in all cases.  This policy provides compatibility for  projects  that  have  not  been
       updated to expect the new behavior.

       The  behavior of inserting items into the <u>INTERFACE_COMPILE_OPTIONS</u> target property (<b>PUBLIC</b> and <b>INTERFACE</b>
       items) is not affected by this policy.  The <b>BEFORE</b> keyword has always been honored when adding  items  to
       <u>INTERFACE_COMPILE_OPTIONS</u>.

       The  <b>OLD</b>  behavior  for  this  policy  is  to  not  honor  the  <b>BEFORE</b>  keyword  when  inserting into the
       <u>COMPILE_OPTIONS</u> property.  The <b>NEW</b> behavior for this policy is to honor the <b>BEFORE</b> keyword in all cases.

       This  policy  was  introduced  in  CMake  version  3.17.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0100</b>
       Added in version 3.17.

       Let <u>AUTOMOC</u> and <u>AUTOUIC</u> process header files that end with a <b>.hh</b> extension.

       Since version 3.17, CMake processes header files that end with a <b>.hh</b> extension in  <u>AUTOMOC</u>  and  <u>AUTOUIC</u>.
       In earlier CMake versions, these header files were ignored by <u>AUTOMOC</u> and <u>AUTOUIC</u>.

       This policy affects how header files that end with a <b>.hh</b> extension get treated in <u>AUTOMOC</u> and <u>AUTOUIC</u>.

       The <b>OLD</b> behavior for this policy is to ignore <b>.hh</b> header files in <u>AUTOMOC</u> and <u>AUTOUIC</u>.

       The  <b>NEW</b>  behavior  for this policy is to process <b>.hh</b> header files in <u>AUTOMOC</u> and <u>AUTOUIC</u> just like other
       header files.

       <b>NOTE:</b>
          To silence the <b>CMP0100</b> warning source files can be excluded from <u>AUTOMOC</u>  and  <u>AUTOUIC</u>  processing  by
          setting the source file properties <u>SKIP_AUTOMOC</u>, <u>SKIP_AUTOUIC</u> or <u>SKIP_AUTOGEN</u>.

              # Source skip example:
              set_property(SOURCE /path/to/file1.hh PROPERTY SKIP_AUTOMOC ON)
              set_property(SOURCE /path/to/file2.hh PROPERTY SKIP_AUTOUIC ON)
              set_property(SOURCE /path/to/file3.hh PROPERTY SKIP_AUTOGEN ON)

       This   policy   was   introduced   in  CMake  version  3.17.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0099</b>
       Added in version 3.17.

       Link properties are transitive over private dependencies of static libraries.

       In    CMake    3.16    and    below,    evaluation    of    target   properties   <u>INTERFACE_LINK_OPTIONS</u>,
       <u>INTERFACE_LINK_DIRECTORIES</u>, and <u>INTERFACE_LINK_DEPENDS</u> during  buildsystem  generation  does  not  follow
       private  dependencies  of  static  libraries,  which  appear in their <u>INTERFACE_LINK_LIBRARIES</u> guarded by
       <u>LINK_ONLY</u> generator expressions.  Only the libraries themselves are  propagated  to  link  the  dependent
       binary.

       CMake  3.17  and  later  prefer  to  propagate  all  interface  link  properties.   This  policy provides
       compatibility for projects that have not been updated to expect the new behavior.

       The <b>OLD</b> behavior for this policy is to not propagate interface link properties. The <b>NEW</b> behavior of  this
       policy is to propagate interface link properties.

       Added  in  version  3.30:  Policy <u>CMP0166</u> makes <u>TARGET_PROPERTY</u> evaluation of these three transitive link
       properties follow private dependencies of static libraries too.

       This  policy  was  introduced  in  CMake  version  3.17.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0098</b>
       Added in version 3.17.

       <u>FindFLEX</u> runs <b>flex</b> in directory <u>CMAKE_CURRENT_BINARY_DIR</u> when executing.

       The module provides a <b>FLEX_TARGET</b> macro which generates FLEX output.  In CMake 3.16 and below  the  macro
       would  generate  a  custom  command that runs <b>flex</b> in the current source directory.  CMake 3.17 and later
       prefer to run it in the build directory and use <u>CMAKE_CURRENT_BINARY_DIR</u> as the <b>WORKING_DIRECTORY</b> of  its
       <u>add_custom_command()</u>  invocation.  This ensures that any implicitly generated file is written relative to
       the build tree rather than the source tree, unless the generated file is provided as absolute path.

       This policy provides compatibility for projects that have not been updated to expect the new behavior.

       The <b>OLD</b> behavior for this policy is  for  <b>FLEX_TARGET</b>  to  use  the  current  source  directory  for  the
       <b>WORKING_DIRECTORY</b>  and  where  to  generate implicit files. The <b>NEW</b> behavior of this policy is to use the
       current binary directory for the <b>WORKING_DIRECTORY</b> relative to which implicit files are generated  unless
       provided as absolute path.

       This   policy   was   introduced   in   CMake   version  3.17.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.16</b></h4><pre>
   <b>CMP0097</b>
       Added in version 3.16.

       <u>ExternalProject_Add()</u> with <b>GIT_SUBMODULES</b> <b>""</b> initializes no submodules.

       The  commands  provide  a  <b>GIT_SUBMODULES</b> option which controls what submodules to initialize and update.
       Starting with CMake 3.16, explicitly setting <b>GIT_SUBMODULES</b> to an empty string means no  submodules  will
       be initialized or updated.

       This policy provides compatibility for projects that have not been updated to expect the new behavior.

       The  <b>OLD</b>  behavior  for  this  policy is for <b>GIT_SUBMODULES</b> when set to an empty string to initialize and
       update all git submodules.  The <b>NEW</b> behavior for this policy is for <b>GIT_SUBMODULES</b> when set to  an  empty
       string to initialize and update no git submodules.

       This   policy   was   introduced   in   CMake   version  3.16.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          This policy also applies to <u>FetchContent_Declare()</u>, which uses the same download and  update  features
          as  <u>ExternalProject_Add()</u>.   However, due to an implementation deficiency present since the policy was
          first introduced, CMake 3.16 and later  always  uses  the  <b>NEW</b>  behavior  for  <u>FetchContent_Declare()</u>,
          regardless  of  the  policy setting. Formally, this forcing of <b>NEW</b> behavior for <u>FetchContent_Declare()</u>
          will continue to apply in future CMake releases.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0096</b>
       Added in version 3.16.

       The <u>project()</u> command preserves leading zeros in version components.

       When  a  <b>VERSION</b>  <b>&lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</b>  argument  is given to the <u>project()</u> command, it
       stores the version  string  in  the  <b>PROJECT_VERSION</b>  variable  and  stores  individual  integer  version
       components  in  <b>PROJECT_VERSION_{MAJOR,MINOR,PATCH,TWEAK}</b> variables (see policy <u>CMP0048</u>).  CMake 3.15 and
       below dropped leading zeros from each component.  CMake 3.16 and higher prefer to preserve leading zeros.
       This policy provides compatibility for projects that have not been updated to expect the new behavior.

       The <b>OLD</b> behavior of this policy drops leading zeros in all components, e.g.  such  that  version  <b>1.07.06</b>
       becomes  <b>1.7.6</b>.  The <b>NEW</b> behavior of this policy preserves the leading zeros in all components, such that
       version <b>1.07.06</b> remains unchanged.

       This  policy  was  introduced  in  CMake  version  3.16.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0095</b>
       Added in version 3.16.

       <b>RPATH</b> entries are properly escaped in the intermediary CMake install script.

       In CMake 3.15 and earlier, <b>RPATH</b> entries set via <u>CMAKE_INSTALL_RPATH</u> or via <u>INSTALL_RPATH</u> have  not  been
       escaped  before  being inserted into the <b>cmake_install.cmake</b> script. Dynamic linkers on ELF-based systems
       (e.g. Linux and FreeBSD) allow certain keywords in <b>RPATH</b> entries, such as  <b>${ORIGIN}</b>  (More  details  are
       available  in  the  <b>ld.so</b>  man  pages  on  those systems). The syntax of these keywords can match CMake's
       variable syntax. In order to not be substituted (usually to an empty string) already by the  intermediary
       <b>cmake_install.cmake</b>    script,    the   user   had   to   double-escape   such   <b>RPATH</b>   keywords,   e.g.
       <b>set(CMAKE_INSTALL_RPATH</b> <b>"\\\${ORIGIN}<a href="file:/../lib">/../lib</a>")</b>. Since the intermediary <b>cmake_install.cmake</b> script  is  an
       implementation  detail of CMake, CMake 3.16 and later will make sure <b>RPATH</b> entries are inserted literally
       by escaping any coincidental CMake syntax.

       The <b>OLD</b> behavior of this policy is to not escape <b>RPATH</b> entries in  the  intermediary  <b>cmake_install.cmake</b>
       script. The <b>NEW</b> behavior is to properly escape coincidental CMake syntax in <b>RPATH</b> entries when generating
       the intermediary <b>cmake_install.cmake</b> script.

       This   policy   was   introduced   in   CMake   version  3.16.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns when it detects use of  CMake-like  syntax,  and
       uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.15</b></h4><pre>
   <b>CMP0094</b>
       Added in version 3.15.

       Modules <u>FindPython3</u>, <u>FindPython2</u> and <u>FindPython</u> use <b>LOCATION</b> for lookup strategy.

       Starting with CMake 3.15, Modules  <u>FindPython3</u>,  <u>FindPython2</u>  and  <u>FindPython</u>  set  value  <b>LOCATION</b>  for,
       respectively,  variables  <b>Python3_FIND_STRATEGY</b>,  <b>Python2_FIND_STRATEGY</b>  and  <b>Python_FIND_STRATEGY</b>.  This
       policy provides compatibility with projects that expect the legacy behavior.

       The  <b>OLD</b>  behavior  for  this   policy   set   value   <b>VERSION</b>   for   variables   <b>Python3_FIND_STRATEGY</b>,
       <b>Python2_FIND_STRATEGY</b> and <b>Python_FIND_STRATEGY</b>.

       This   policy   was   introduced   in   CMake   version  3.15.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0093</b>
       Added in version 3.15.

       <u>FindBoost</u> reports <b>Boost_VERSION</b> in <b>x.y.z</b> format.

       In CMake 3.14 and below the module would report the Boost version number as specified in the preprocessor
       definition  <b>BOOST_VERSION</b> in the <b>boost/version.hpp</b> file. In CMake 3.15 and later it is preferred that the
       reported version number matches the <b>x.y.z</b> format reported by the CMake package shipped with Boost  <b>1.70.0</b>
       and later. The macro value is still reported in the <b>Boost_VERSION_MACRO</b> variable.

       The  <b>OLD</b>  behavior  for  this  policy  is  for  <u>FindBoost</u>  to  report  <b>Boost_VERSION</b>  as specified in the
       preprocessor definition <b>BOOST_VERSION</b> in <b>boost/version.hpp</b>. The <b>NEW</b>  behavior  for  this  policy  is  for
       <u>FindBoost</u> to report <b>Boost_VERSION</b> in <b>x.y.z</b> format.

       This   policy   was   introduced   in   CMake   version  3.15.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0092</b>
       Added in version 3.15.

       MSVC warning flags are not in <u>CMAKE_&lt;LANG&gt;_FLAGS</u> by default.

       When  using  MSVC-like  compilers  in  CMake  3.14  and  below,  warning  flags  like  <b>/W3</b>  are  added to
       <u>CMAKE_&lt;LANG&gt;_FLAGS</u> by default.  This is problematic for projects that want to choose a different  warning
       level  programmatically.   In  particular, it requires string editing of the <u>CMAKE_&lt;LANG&gt;_FLAGS</u> variables
       with knowledge of the CMake builtin defaults so they can be replaced.

       CMake 3.15 and above prefer to leave out warning flags from the value of <u>CMAKE_&lt;LANG&gt;_FLAGS</u> by default.

       This policy provides compatibility with projects that have not been updated to expect the lack of warning
       flags.  The policy setting takes effect as of the  first  <u>project()</u>  or  <u>enable_language()</u>  command  that
       initializes <u>CMAKE_&lt;LANG&gt;_FLAGS</u> for a given language <b>&lt;LANG&gt;</b>.

       <b>NOTE:</b>
          Once  the  policy  has  taken effect at the top of a project for a given language, that choice must be
          used throughout the tree for that language.  In projects that have nested projects in  subdirectories,
          be sure to convert everything together.

       The  <b>OLD</b>  behavior for this policy is to place MSVC warning flags in the default <u>CMAKE_&lt;LANG&gt;_FLAGS</u> cache
       entries.  The <b>NEW</b> behavior for this policy is to <u>not</u> place  MSVC  warning  flags  in  the  default  cache
       entries.

       This   policy   was   introduced   in   CMake   version  3.15.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0091</b>
       Added in version 3.15.

       MSVC runtime library flags are selected by an abstraction.

       Compilers  targeting  the  MSVC  ABI  have  flags  to  select  the MSVC runtime library.  Runtime library
       selection typically varies with build configuration because there is a separate runtime library for Debug
       builds.

       In  CMake  3.14  and  below,  MSVC  runtime  library  selection  flags   are   added   to   the   default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>  cache entries by CMake automatically.  This allows users to edit their cache
       entries to adjust the flags.  However, the presence of such default flags  is  problematic  for  projects
       that  want  to  choose  a  different runtime library programmatically.  In particular, it requires string
       editing of the <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u> variables with knowledge of the CMake builtin defaults so they
       can be replaced.

       CMake 3.15 and above prefer to leave the  MSVC  runtime  library  selection  flags  out  of  the  default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u>    values    and    instead    offer    a   first-class   abstraction.    The
       <u>CMAKE_MSVC_RUNTIME_LIBRARY</u> variable and <u>MSVC_RUNTIME_LIBRARY</u> target property may be  set  to  select  the
       MSVC    runtime    library.     If   they   are   not   set   then   CMake   uses   the   default   value
       <b>MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;DLL</b> which is equivalent to the original flags.

       This policy provides compatibility with  projects  that  have  not  been  updated  to  be  aware  of  the
       abstraction.  The policy setting takes effect as of the first <u>project()</u> or <u>enable_language()</u> command that
       enables a language whose compiler targets the MSVC ABI.

       <b>NOTE:</b>
          Once  the  policy  has  taken  effect at the top of a project, that choice must be used throughout the
          tree.  In projects that have  nested  projects  in  subdirectories,  be  sure  to  convert  everything
          together.

       The   <b>OLD</b>   behavior   for   this  policy  is  to  place  MSVC  runtime  library  flags  in  the  default
       <u>CMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;</u> cache entries and ignore the <u>CMAKE_MSVC_RUNTIME_LIBRARY</u> abstraction.  The <b>NEW</b>
       behavior for this policy is to <u>not</u> place MSVC runtime library flags in the default cache entries and  use
       the abstraction instead.

       This   policy   was   introduced   in   CMake   version  3.15.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0090</b>
       Added in version 3.15.

       <u>export(PACKAGE)</u> does not populate package registry by default.

       In  CMake  3.14  and below the <u>export(PACKAGE)</u> command populated the user package registry by default and
       users needed to set the <u>CMAKE_EXPORT_NO_PACKAGE_REGISTRY</u> to disable  it,  e.g.  in  automated  build  and
       packaging  environments.   Since  the  user  package registry is stored outside the build tree, this side
       effect should not be enabled by default.  Therefore CMake 3.15 and above prefer that <u>export(PACKAGE)</u> does
       nothing unless an explicit <u>CMAKE_EXPORT_PACKAGE_REGISTRY</u> variable is  set  to  enable  it.   This  policy
       provides compatibility with projects that have not been updated.

       The  <b>OLD</b>  behavior  for  this policy is for <u>export(PACKAGE)</u> command to populate the user package registry
       unless <u>CMAKE_EXPORT_NO_PACKAGE_REGISTRY</u> is enabled.  The <b>NEW</b> behavior is for <u>export(PACKAGE)</u>  command  to
       do nothing unless the <u>CMAKE_EXPORT_PACKAGE_REGISTRY</u> is enabled.

       This   policy   was   introduced   in   CMake   version  3.15.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0089</b>
       Added in version 3.15.

       Compiler id for IBM Clang-based XL compilers is now <b>XLClang</b>.

       CMake  3.15  and  above  recognize  that  IBM's  Clang-based XL compilers that define <b>__ibmxl__</b> are a new
       front-end distinct from <b>xlc</b> with a different command line and set of capabilities.  CMake now prefers  to
       present  this  to  projects  by  setting  the <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable to <b>XLClang</b> instead of <b>XL</b>.
       However, existing projects may assume the compiler id for Clang-based XL is just <b>XL</b> as it  was  in  CMake
       versions  prior to 3.15.  Therefore this policy determines for Clang-based XL compilers which compiler id
       to report in the <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable after language <b>&lt;LANG&gt;</b> is enabled by the  <u>project()</u>  or
       <u>enable_language()</u> command.  The policy must be set prior to the invocation of either command.

       The  <b>OLD</b>  behavior  for this policy is to use compiler id <b>XL</b>.  The <b>NEW</b> behavior for this policy is to use
       compiler id <b>XLClang</b>.

       This  policy  was  introduced  in  CMake  version  3.15.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0089</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.14</b></h4><pre>
   <b>CMP0088</b>
       Added in version 3.14.

       <u>FindBISON</u> runs bison in <u>CMAKE_CURRENT_BINARY_DIR</u> when executing.

       The module provides a <b>BISON_TARGET</b> macro which generates BISON output.  In CMake 3.13 and below the macro
       would generate a custom command that runs <b>bison</b> in the source directory.  CMake 3.14 and later prefer  to
       run  it  in  the  build  directory  and  use  <u>CMAKE_CURRENT_BINARY_DIR</u>  as  the  <b>WORKING_DIRECTORY</b> of its
       <u>add_custom_command()</u> invocation.  This ensures that any implicitly generated file is written to the build
       tree rather than the source.

       This policy provides compatibility for projects that have not been updated to expect the new behavior.

       The <b>OLD</b> behavior for this policy is for  <b>BISON_TARGET</b>  to  use  the  current  source  directory  for  the
       <b>WORKING_DIRECTORY</b>  and  where  to  generate implicit files. The <b>NEW</b> behavior of this policy is to use the
       current binary directory for the <b>WORKING_DIRECTORY</b> and where to generate implicit files.

       This  policy  was  introduced  in  CMake  version  3.14.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0087</b>
       Added in version 3.14.

       <u>install(CODE)</u> and <u>install(SCRIPT)</u> support generator expressions.

       In CMake 3.13 and earlier, <u>install(CODE)</u> and <u>install(SCRIPT)</u>  did  not  evaluate  generator  expressions.
       CMake 3.14 and later will evaluate generator expressions for <u>install(CODE)</u> and <u>install(SCRIPT)</u>.

       The  <b>OLD</b>  behavior  of  this  policy  is  for <u>install(CODE)</u> and <u>install(SCRIPT)</u> to not evaluate generator
       expressions.   The  <b>NEW</b>  behavior  is  to  evaluate   generator   expressions   for   <u>install(CODE)</u>   and
       <u>install(SCRIPT)</u>.

       Note that it is the value of this policy setting at the end of the directory scope that is important, not
       its  setting  at  the  time  of  the call to <u>install(CODE)</u> or <u>install(SCRIPT)</u>.  This has implications for
       calling these commands from places that have their own policy scope but not  their  own  directory  scope
       (e.g. from files brought in via <u>include()</u> rather than <u>add_subdirectory()</u>).

       This   policy   was   introduced   in   CMake   version  3.14.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0086</b>
       Added in version 3.14.

       <u>UseSWIG</u> honors <b>SWIG_MODULE_NAME</b> via <b>-module</b> flag.

       Starting  with  CMake  3.14,  <u>UseSWIG</u>  passes  option  <b>-module</b> <b>&lt;module_name&gt;</b> to <b>SWIG</b> compiler if the file
       property <b>SWIG_MODULE_NAME</b> is specified. This policy provides compatibility with projects that expect  the
       legacy behavior.

       The  <b>OLD</b>  behavior  for this policy is to never pass <b>-module</b> option.  The <b>NEW</b> behavior is to pass <b>-module</b>
       option to <b>SWIG</b> compiler if <b>SWIG_MODULE_NAME</b> is specified.

       This  policy  was  introduced  in  CMake  version  3.14.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0085</b>
       Added in version 3.14.

       <b>$&lt;IN_LIST:...&gt;</b> handles empty list items.

       In CMake 3.13 and lower, the <b>$&lt;IN_LIST:...&gt;</b> generator expression always returned <b>0</b> if the first  argument
       was  empty,  even  if  the  list  contained an empty item. This behavior is inconsistent with the <b>IN_LIST</b>
       behavior of <u>if()</u>, which this generator expression is meant to emulate. CMake 3.14 and later handles  this
       case correctly.

       The  <b>OLD</b> behavior of this policy is for <b>$&lt;IN_LIST:...&gt;</b> to always return <b>0</b> if the first argument is empty.
       The <b>NEW</b> behavior is to return <b>1</b> if the first argument is empty and the list contains an empty item.

       This  policy  was  introduced  in  CMake  version  3.14.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0084</b>
       Added in version 3.14.

       The <u>FindQt</u> module does not exist for <u>find_package()</u>.

       The existence of <u>FindQt</u> means that for Qt upstream to provide package config files that can be  found  by
       <b>find_package(Qt)</b>,  the consuming project has to explicitly specify <b>find_package(Qt</b> <b>CONFIG)</b>. Removing this
       module gives Qt a path forward for exporting its own config files which can easily be found by  consuming
       projects.

       This  policy pretends that CMake's internal <u>FindQt</u> module does not exist for <u>find_package()</u>. If a project
       really wants to use Qt 3 or 4, it can call <b>find_package(Qt[34])</b>, <b>include(FindQt)</b>, or add <u>FindQt</u> to  their
       <u>CMAKE_MODULE_PATH</u>.

       The <b>OLD</b> behavior of this policy is for <u>FindQt</u> to exist for <u>find_package()</u>. The <b>NEW</b> behavior is to pretend
       that it doesn't exist for <u>find_package()</u>.

       This   policy   was   introduced   in   CMake   version  3.14.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0083</b>
       Added in version 3.14.

       To  control  generation  of Position Independent Executable (<b>PIE</b>) or not, some flags are required at link
       time.

       CMake 3.13 and lower did not add these link flags when <u>POSITION_INDEPENDENT_CODE</u> is set.

       The <b>OLD</b> behavior for this policy is to not manage <b>PIE</b> link flags. The <b>NEW</b> behavior is to add  link  flags
       if <u>POSITION_INDEPENDENT_CODE</u> is set:

       • Set  to  <b>TRUE</b>:  flags  to  produce a position independent executable are passed to the linker step. For
         example <b>-pie</b> for <b>GCC</b>.

       • Set to <b>FALSE</b>: flags not to produce a position independent executable are passed to the linker step. For
         example <b>-no-pie</b> for <b>GCC</b>.

       • Not set: no flags are passed to the linker step.

       Since a given linker may not support <b>PIE</b> flags in all environments  in  which  it  is  used,  it  is  the
       project's  responsibility  to  use  the  <u>CheckPIESupported</u> module to check for support to ensure that the
       <u>POSITION_INDEPENDENT_CODE</u> target property for executables will be honored at link time.

       This  policy  was  introduced  in  CMake  version  3.14.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          Android  platform  has  a  special  handling of <b>PIE</b> so it is not required to use the <u>CheckPIESupported</u>
          module to ensure flags are passed to the linker.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>Examples</b>
       Behave like CMake 3.13 and do not apply any <b>PIE</b> flags at link stage.

          cmake_minimum_required(VERSION 3.13)
          project(foo)

          # ...

          add_executable(foo ...)
          set_property(TARGET foo PROPERTY POSITION_INDEPENDENT_CODE TRUE)

       Use  the  <u>CheckPIESupported</u>  module  to  detect  whether  <b>PIE</b>  is  supported  by  the  current linker and
       environment.  Apply <b>PIE</b> flags only if the linker supports them.

          cmake_minimum_required(VERSION 3.14) # CMP0083 NEW
          project(foo)

          include(CheckPIESupported)
          check_pie_supported()

          # ...

          add_executable(foo ...)
          set_property(TARGET foo PROPERTY POSITION_INDEPENDENT_CODE TRUE)

   <b>CMP0082</b>
       Added in version 3.14.

       Install rules from <u>add_subdirectory()</u> calls are interleaved with those in caller.

       CMake 3.13 and lower ran the install rules from <u>add_subdirectory()</u> after all other install rules, even if
       <u>add_subdirectory()</u> was called before the other install rules.  CMake 3.14 and above prefer to  interleave
       these  <u>add_subdirectory()</u>  install  rules  with  the  others  so  that they are run in the order they are
       declared.  This policy provides compatibility for projects that have not been updated to expect  the  new
       behavior.

       The  <b>OLD</b>  behavior  for  this  policy is to run the install rules from <u>add_subdirectory()</u> after the other
       install rules.  The <b>NEW</b> behavior for this policy is to run all  install  rules  in  the  order  they  are
       declared.

       This   policy   was   introduced   in   CMake   version  3.14.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0082</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.13</b></h4><pre>
   <b>CMP0081</b>
       Added in version 3.13.

       Relative paths not allowed in <u>LINK_DIRECTORIES</u> target property.

       CMake 3.12 and lower allowed the <u>LINK_DIRECTORIES</u> directory property to contain relative paths.  The base
       path for such relative entries is not well defined.  CMake 3.13 and later will issue a <b>FATAL_ERROR</b> if the
       <u>LINK_DIRECTORIES</u>  target  property  (which  is  initialized  by  the <u>LINK_DIRECTORIES</u> directory property)
       contains a relative path.

       The <b>OLD</b> behavior for this policy is not to warn about  relative  paths  in  the  <u>LINK_DIRECTORIES</u>  target
       property.   The  <b>NEW</b>  behavior  for  this policy is to issue a <b>FATAL_ERROR</b> if <u>LINK_DIRECTORIES</u> contains a
       relative path.

       This  policy  was  introduced  in  CMake  version  3.13.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0080</b>
       Added in version 3.13.

       <u>BundleUtilities</u> cannot be included at configure time.

       The macros provided by <u>BundleUtilities</u> are intended  to  be  invoked  at  install  time  rather  than  at
       configure  time, because they depend on the listed targets already existing at the time they are invoked.
       If they are invoked at configure time, the targets haven't been built yet, and the commands will fail.

       This policy restricts the inclusion of <u>BundleUtilities</u> to <b>cmake</b>  <b>-P</b>  style  scripts  and  install  rules.
       Specifically, it looks for the presence of <u>CMAKE_GENERATOR</u> and throws a fatal error if it exists.

       The  <b>OLD</b>  behavior  of  this policy is to allow <u>BundleUtilities</u> to be included at configure time. The <b>NEW</b>
       behavior of this policy is to disallow such inclusion.

       This  policy  was  introduced  in  CMake  version  3.13.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0079</b>
       Added in version 3.13.

       <u>target_link_libraries()</u> allows use with targets in other directories.

       Prior to CMake 3.13 the <u>target_link_libraries()</u> command did not accept targets not created in the calling
       directory as its first argument for calls that update the <u>LINK_LIBRARIES</u> of the target  itself.   It  did
       accidentally    accept    targets    from   other   directories   on   calls   that   only   update   the
       <u>INTERFACE_LINK_LIBRARIES</u>, but would simply add entries to the property as if the call were  made  in  the
       original directory.  Thus link interface libraries specified this way were always looked up by generators
       in the scope of the original target rather than in the scope that called <u>target_link_libraries()</u>.

       CMake  3.13  now  allows  the <u>target_link_libraries()</u> command to be called from any directory to add link
       dependencies and link interface libraries to targets created in other directories.  The entries are added
       to <u>LINK_LIBRARIES</u> and <u>INTERFACE_LINK_LIBRARIES</u> using a special (internal) suffix to tell  the  generators
       to look up the names in the calling scope rather than the scope that created the target.

       This  policy  provides  compatibility  with  projects  that  already use <u>target_link_libraries()</u> with the
       <b>INTERFACE</b> keyword on a target in another directory to add <u>INTERFACE_LINK_LIBRARIES</u> entries to  be  looked
       up  in  the  target's directory.  Such projects should be updated to be aware of the new scoping rules in
       that case.

       The <b>OLD</b> behavior of this policy is to disallow <u>target_link_libraries()</u> calls naming targets from  another
       directory  except  in  the previously accidentally allowed case of using the <b>INTERFACE</b> keyword only.  The
       <b>NEW</b> behavior of this policy is to allow all such calls but use the new scoping rules.

       This  policy  was  introduced  in  CMake  version  3.13.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0078</b>
       Added in version 3.13.

       <u>UseSWIG</u> generates standard target names.

       Starting with CMake 3.13, <u>UseSWIG</u> generates now standard target names. This policy provides compatibility
       with projects that expect the legacy behavior.

       The <b>OLD</b> behavior for this policy relies on <b>UseSWIG_TARGET_NAME_PREFERENCE</b> variable that can  be  used  to
       specify an explicit preference.  The value may be one of:

       • <b>LEGACY</b>:  legacy  strategy  is  applied.  Variable <b>SWIG_MODULE_&lt;name&gt;_REAL_NAME</b> must be used to get real
         target name.  This is the default if not specified.

       • <b>STANDARD</b>: target name matches specified name.

       This  policy  was  introduced  in  CMake  version  3.13.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0077</b>
       Added in version 3.13.

       <u>option()</u> honors normal variables.

       The <u>option()</u> command is typically used to create a  cache  entry  to  allow  users  to  set  the  option.
       However,  there  are  cases in which a normal (non-cached) variable of the same name as the option may be
       defined by the project prior to calling the <u>option()</u> command.  For example, a project that embeds another
       project as a subdirectory may want to hard-code options of the subproject to build the way it needs.

       For historical reasons in CMake 3.12 and  below  the  <u>option()</u>  command  <u>removes</u>  a  normal  (non-cached)
       variable of the same name when:

       • a cache entry of the specified name does not exist at all, or

       • a  cache  entry of the specified name exists but has not been given a type (e.g. via <b>-D&lt;name&gt;=ON</b> on the
         command line).

       In both of these cases (typically on the first run in a new build tree), the <u>option()</u> command  gives  the
       cache  entry  type  <b>BOOL</b> and removes any normal (non-cached) variable of the same name.  In the remaining
       case that the cache entry of the specified name already exists and has a type (typically on later runs in
       a build tree), the <u>option()</u> command changes nothing and any normal variable of the same name remains set.

       In CMake 3.13 and above the <u>option()</u> command prefers to do nothing when a normal variable  of  the  given
       name  already exists.  It does not create or update a cache entry or remove the normal variable.  The new
       behavior is consistent between the  first  and  later  runs  in  a  build  tree.   This  policy  provides
       compatibility with projects that have not been updated to expect the new behavior.

       When the <u>option()</u> command sees a normal variable of the given name:

       • The <b>OLD</b> behavior for this policy is to proceed even when a normal variable of the same name exists.  If
         the  cache  entry does not already exist and have a type then it is created and/or given a type and the
         normal variable is removed.

       • The <b>NEW</b> behavior for this policy is to do nothing when a normal variable of the same name exists.   The
         normal variable is not removed.  The cache entry is not created or updated and is ignored if it exists.

       See  <u>CMP0126</u> for a similar policy for the <u>set(CACHE)</u> command, but note that there are some differences in
       <b>NEW</b> behavior between the two policies.

       This  policy  was  introduced  in  CMake  version  3.13.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       Use  the  <u>CMAKE_POLICY_DEFAULT_CMP0077</u>  variable  to  set  the  policy  for  a  third-party  project in a
       subdirectory without modifying it.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0076</b>
       Added in version 3.13.

       The <u>target_sources()</u> command converts relative paths to absolute.

       In CMake 3.13 and above, the <u>target_sources()</u> command now converts relative source file paths to absolute
       paths in the following cases:

       • Source files are added to the target's <u>INTERFACE_SOURCES</u> property.

       • The target's <u>SOURCE_DIR</u> property differs from <u>CMAKE_CURRENT_SOURCE_DIR</u>.

       A path that begins with a generator expression is always left unmodified.

       This policy provides compatibility with projects that have not been updated to expect this behavior.  The
       <b>OLD</b>  behavior for this policy is to leave all relative source file paths unmodified.  The <b>NEW</b> behavior of
       this policy is to convert relative paths to absolute according to above rules.

       This  policy  was  introduced  in  CMake  version  3.13.   It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.12</b></h4><pre>
   <b>CMP0075</b>
       Added in version 3.12.

       Include file check macros honor <b>CMAKE_REQUIRED_LIBRARIES</b>.

       In CMake 3.12 and above, the

       • <b>check_include_file</b> macro in the <u>CheckIncludeFile</u> module, the

       • <b>check_include_file_cxx</b> macro in the <u>CheckIncludeFileCXX</u> module, and the

       • <b>check_include_files</b> macro in the <u>CheckIncludeFiles</u> module

       now prefer to link the check executable to the libraries listed in the <b>CMAKE_REQUIRED_LIBRARIES</b> variable.
       This policy provides compatibility with projects that have not been updated to expect this behavior.

       The <b>OLD</b> behavior for this policy is to ignore <b>CMAKE_REQUIRED_LIBRARIES</b> in the include file check  macros.
       The <b>NEW</b> behavior of this policy is to honor <b>CMAKE_REQUIRED_LIBRARIES</b> in the include file check macros.

       This   policy   was   introduced   in   CMake   version  3.12.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0074</b>
       Added in version 3.12.

       <u>find_package()</u> uses <b>&lt;PackageName&gt;_ROOT</b> variables.

       In  CMake  3.12  and above the <u>find_package(&lt;PackageName&gt;)</u> command now searches prefixes specified by the
       <u>&lt;PackageName&gt;_ROOT</u> CMake variable and the <u>&lt;PackageName&gt;_ROOT</u> environment  variable.   Package  roots  are
       maintained as a stack so nested calls to all <b>find_*</b> commands inside find modules and config packages also
       search  the  roots  as  prefixes.   This  policy  provides compatibility with projects that have not been
       updated to avoid using <b>&lt;PackageName&gt;_ROOT</b> variables for other purposes.

       The <b>OLD</b> behavior for this policy is to ignore <b>&lt;PackageName&gt;_ROOT</b> variables.  The <b>NEW</b>  behavior  for  this
       policy is to use <b>&lt;PackageName&gt;_ROOT</b> variables.

       This   policy   was   introduced   in   CMake   version  3.12.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0073</b>
       Added in version 3.12.

       Do not produce legacy <b>_LIB_DEPENDS</b> cache entries.

       Ancient  CMake versions once used <b>&lt;tgt&gt;_LIB_DEPENDS</b> cache entries to propagate library link dependencies.
       This has long been done by other means, leaving the <u>export_library_dependencies()</u>  command  as  the  only
       user of these values.  That command has long been disallowed by policy <u>CMP0033</u>, but the <b>&lt;tgt&gt;_LIB_DEPENDS</b>
       cache entries were left for compatibility with possible non-standard uses by projects.

       CMake  3.12  and  above  now  prefer  to  not  produce  these cache entries at all.  This policy provides
       compatibility with projects that have not been updated to avoid using them.

       The <b>OLD</b> behavior for this policy is to set <b>&lt;tgt&gt;_LIB_DEPENDS</b> cache entries.  The <b>NEW</b>  behavior  for  this
       policy is to not set them.

       This   policy   was   introduced   in   CMake   version  3.12.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.11</b></h4><pre>
   <b>CMP0072</b>
       Added in version 3.11.

       <u>FindOpenGL</u> prefers GLVND by default when available.

       The  <u>FindOpenGL</u> module provides an <b>OpenGL::GL</b> target and an <b>OPENGL_LIBRARIES</b> variable for projects to use
       for legacy GL interfaces.  When both a legacy GL library (e.g. <b>libGL.so</b>) and GLVND libraries  for  OpenGL
       and  GLX  (e.g.  <b>libOpenGL.so</b>  and  <b>libGLX.so</b>)  are  available,  the module must choose between them.  It
       documents an <b>OpenGL_GL_PREFERENCE</b> variable that can be used to specify an explicit preference.   When  no
       such preference is set, the module must choose a default preference.

       CMake  3.11 and above prefer to choose GLVND libraries.  This policy provides compatibility with projects
       that expect the legacy GL library to be used.

       The <b>OLD</b> behavior for this policy is to set <b>OpenGL_GL_PREFERENCE</b> to <b>LEGACY</b>.  The  <b>NEW</b>  behavior  for  this
       policy is to set <b>OpenGL_GL_PREFERENCE</b> to <b>GLVND</b>.

       This   policy   was   introduced   in   CMake   version  3.11.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.10</b></h4><pre>
   <b>CMP0071</b>
       Added in version 3.10.

       Let <u>AUTOMOC</u> and <u>AUTOUIC</u> process <u>GENERATED</u> files.

       Since  version  3.10,  CMake  processes  <b>regular</b>  and  <u>GENERATED</u> source files in <u>AUTOMOC</u> and <u>AUTOUIC</u>.  In
       earlier CMake versions, only <b>regular</b> source files were processed.  <u>GENERATED</u> source  files  were  ignored
       silently.

       This policy affects how source files that are <u>GENERATED</u> get treated in <u>AUTOMOC</u> and <u>AUTOUIC</u>.

       The <b>OLD</b> behavior for this policy is to ignore <u>GENERATED</u> source files in <u>AUTOMOC</u> and <u>AUTOUIC</u>.

       The  <b>NEW</b>  behavior  for this policy is to process <u>GENERATED</u> source files in <u>AUTOMOC</u> and <u>AUTOUIC</u> just like
       regular source files.

       <b>NOTE:</b>
          To silence the <b>CMP0071</b> warning source files can be excluded from <u>AUTOMOC</u>  and  <u>AUTOUIC</u>  processing  by
          setting the source file properties <u>SKIP_AUTOMOC</u>, <u>SKIP_AUTOUIC</u> or <u>SKIP_AUTOGEN</u>.

       Source skip example:

          # ...
          set_property(SOURCE /path/to/file1.h PROPERTY SKIP_AUTOMOC ON)
          set_property(SOURCE /path/to/file2.h PROPERTY SKIP_AUTOUIC ON)
          set_property(SOURCE /path/to/file3.h PROPERTY SKIP_AUTOGEN ON)
          # ...

       This   policy   was   introduced   in   CMake   version  3.10.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0070</b>
       Added in version 3.10.

       Define <u>file(GENERATE)</u> behavior for relative paths.

       CMake 3.10 and newer define that relative paths given to <b>INPUT</b> and <b>OUTPUT</b> arguments of <b>file(GENERATE)</b> are
       interpreted relative to the current source and binary directories, respectively.  CMake 3.9 and lower did
       not define any behavior for relative paths but did not diagnose them either and accidentally treated them
       relative to the process working directory.  Policy <b>CMP0070</b> provides compatibility with projects that used
       the old undefined behavior.

       This policy affects behavior of relative paths given to <b>file(GENERATE)</b>.  The <b>OLD</b> behavior for this policy
       is to treat the paths relative to the working directory of CMake.  The <b>NEW</b> behavior for this policy is to
       interpret relative paths with respect to the current source or binary directory of the caller.

       This   policy   was   introduced   in   CMake   version  3.10.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.9</b></h4><pre>
   <b>CMP0069</b>
       Added in version 3.9.

       <u>INTERPROCEDURAL_OPTIMIZATION</u> is enforced when enabled.

       CMake  3.9 and newer prefer to add IPO flags whenever the <u>INTERPROCEDURAL_OPTIMIZATION</u> target property is
       enabled and produce an error if flags are not known to CMake for the current  compiler.   Since  a  given
       compiler  may  not  support  IPO  flags  in all environments in which it is used, it is now the project's
       responsibility  to  use  the  <u>CheckIPOSupported</u>  module  to  check  for  support  before   enabling   the
       <u>INTERPROCEDURAL_OPTIMIZATION</u>  target  property.  This approach allows a project to conditionally activate
       IPO when supported.  It also allows an end user to set the <u>CMAKE_INTERPROCEDURAL_OPTIMIZATION</u> variable in
       an environment known to support IPO even if the project does not enable the property.

       Since CMake 3.8 and lower only honored <u>INTERPROCEDURAL_OPTIMIZATION</u> for the Intel compiler on Linux, some
       projects may unconditionally enable the target property.  Policy <b>CMP0069</b> provides compatibility with such
       projects.

       This policy takes effect whenever the IPO property is enabled.  The <b>OLD</b> behavior for this  policy  is  to
       add IPO flags only for Intel compiler on Linux.  The <b>NEW</b> behavior for this policy is to add IPO flags for
       the current compiler or produce an error if CMake does not know the flags.

       This   policy   was   introduced   in   CMake   version   3.9.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>Examples</b>
       Behave like CMake 3.8 and do not apply any IPO flags except for Intel compiler on Linux:

          cmake_minimum_required(VERSION 3.8)
          project(foo)

          # ...

          set_property(TARGET ... PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)

       Use the <u>CheckIPOSupported</u> module to detect whether IPO is supported by the current compiler, environment,
       and CMake version.  Produce a fatal error if support is not available:

          cmake_minimum_required(VERSION 3.9) # CMP0069 NEW
          project(foo)

          include(CheckIPOSupported)
          check_ipo_supported()

          # ...

          set_property(TARGET ... PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)

       Apply IPO flags only if compiler supports it:

          cmake_minimum_required(VERSION 3.9) # CMP0069 NEW
          project(foo)

          include(CheckIPOSupported)

          # ...

          check_ipo_supported(RESULT result)
          if(result)
            set_property(TARGET ... PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)
          endif()

       Apply  IPO  flags  without  any  checks.   This  may  lead to build errors if IPO is not supported by the
       compiler in the current environment.  Produce an error if CMake does not know IPO flags for  the  current
       compiler:

          cmake_minimum_required(VERSION 3.9) # CMP0069 NEW
          project(foo)

          # ...

          set_property(TARGET ... PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)

   <b>CMP0068</b>
       Added in version 3.9.

       <b>RPATH</b> settings on macOS do not affect <b>install_name</b>.

       CMake  3.9 and newer remove any effect the following settings may have on the <b>install_name</b> of a target on
       macOS:

       • <u>BUILD_WITH_INSTALL_RPATH</u> target property

       • <u>SKIP_BUILD_RPATH</u> target property

       • <u>CMAKE_SKIP_RPATH</u> variable

       • <u>CMAKE_SKIP_INSTALL_RPATH</u> variable

       Previously, setting <u>BUILD_WITH_INSTALL_RPATH</u> had the effect of setting both the <b>install_name</b> of a  target
       to  <u>INSTALL_NAME_DIR</u>  and  the  <b>RPATH</b>  to <u>INSTALL_RPATH</u>.  In CMake 3.9, it only affects setting of <b>RPATH</b>.
       However, if one wants  <u>INSTALL_NAME_DIR</u>  to  apply  to  the  target  in  the  build  tree,  one  may  set
       <u>BUILD_WITH_INSTALL_NAME_DIR</u>.

       If  <u>SKIP_BUILD_RPATH</u>,  <u>CMAKE_SKIP_RPATH</u>  or  <u>CMAKE_SKIP_INSTALL_RPATH</u>  were  used  to strip the directory
       portion of the <b>install_name</b> of a target, one may set <b>INSTALL_NAME_DIR=""</b> instead.

       The <b>OLD</b> behavior of this policy is to use the <b>RPATH</b> settings for <b>install_name</b> on macOS.  The <b>NEW</b> behavior
       of this policy is to ignore the <b>RPATH</b> settings for <b>install_name</b> on macOS.

       This  policy  was  introduced  in  CMake  version  3.9.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.8</b></h4><pre>
   <b>CMP0067</b>
       Added in version 3.8.

       Honor language standard in <u>try_compile()</u> source-file signature.

       The <u>try_compile()</u> source file signature is intended to allow callers to check whether they will  be  able
       to  compile  a  given  source  file with the current toolchain.  In order to match compiler behavior, any
       language standard mode should match.  However, CMake 3.7 and below did not do this.  CMake 3.8 and  above
       prefer  to  honor  the  language  standard  settings  for  <b>C</b>, <b>CXX</b> (C++), and <b>CUDA</b> using the values of the
       variables:

       • <u>CMAKE_C_STANDARD</u>

       • <u>CMAKE_C_STANDARD_REQUIRED</u>

       • <u>CMAKE_C_EXTENSIONS</u>

       • <u>CMAKE_CXX_STANDARD</u>

       • <u>CMAKE_CXX_STANDARD_REQUIRED</u>

       • <u>CMAKE_CXX_EXTENSIONS</u>

       • <u>CMAKE_CUDA_STANDARD</u>

       • <u>CMAKE_CUDA_STANDARD_REQUIRED</u>

       • <u>CMAKE_CUDA_EXTENSIONS</u>

       This policy provides compatibility for projects that do not expect the language standard settings  to  be
       used automatically.

       The  <b>OLD</b>  behavior  of  this  policy is to ignore language standard setting variables when generating the
       <b>try_compile</b> test project.  The <b>NEW</b> behavior  of  this  policy  is  to  honor  language  standard  setting
       variables.

       This   policy   was   introduced   in   CMake   version   3.8.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0067</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.7</b></h4><pre>
   <b>CMP0066</b>
       Added in version 3.7.

       Honor per-config flags in <u>try_compile()</u> source-file signature.

       The  source file signature of the <u>try_compile()</u> command uses the value of the <u>CMAKE_&lt;LANG&gt;_FLAGS</u> variable
       in the test project so that the test compilation works as it would in the main project.   However,  CMake
       3.6   and   below   do   not   also   honor   config-specific   compiler  flags  such  as  those  in  the
       <u>CMAKE_&lt;LANG&gt;_FLAGS_DEBUG</u> variable.  CMake 3.7 and above prefer to honor  config-specific  compiler  flags
       too.   This  policy provides compatibility for projects that do not expect config-specific compiler flags
       to be used.

       The <b>OLD</b> behavior of this policy is to ignore config-specific flag variables like <u>CMAKE_&lt;LANG&gt;_FLAGS_DEBUG</u>
       and only use CMake's built-in defaults for the current compiler and platform.

       The <b>NEW</b> behavior of this policy is to honor config-specific flag variables like <u>CMAKE_&lt;LANG&gt;_FLAGS_DEBUG</u>.

       This  policy  was  introduced  in  CMake  version  3.7.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0066</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.4</b></h4><pre>
   <b>CMP0065</b>
       Added in version 3.4.

       Do not add flags to export symbols from executables without the <u>ENABLE_EXPORTS</u> target property.

       CMake 3.3 and below, for historical reasons, always linked executables on some platforms with flags  like
       <b>-rdynamic</b>  to export symbols from the executables for use by any plugins they may load via <b>dlopen</b>.  CMake
       3.4 and above prefer to do this only for executables that are explicitly marked with  the  <u>ENABLE_EXPORTS</u>
       target property.

       The  <b>OLD</b>  behavior  of  this  policy  is to always use the additional link flags when linking executables
       regardless of the value of the <u>ENABLE_EXPORTS</u> target property.

       The <b>NEW</b> behavior of this policy is to only use the additional link flags when linking executables if  the
       <u>ENABLE_EXPORTS</u> target property is set to <b>True</b>.

       This   policy   was   introduced   in   CMake   version   3.4.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0065</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0064</b>
       Added in version 3.4.

       Recognize <b>TEST</b> as a operator for the <u>if()</u> command.

       The  <b>TEST</b>  operator  was  added  to the <u>if()</u> command to determine if a given test name was created by the
       <u>add_test()</u> command.

       The <b>OLD</b> behavior for this policy is to ignore the <b>TEST</b> operator.  The <b>NEW</b> behavior is  to  interpret  the
       <b>TEST</b> operator.

       This   policy   was   introduced   in   CMake   version   3.4.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.3</b></h4><pre>
   <b>CMP0063</b>
       Added in version 3.3.

       Honor visibility properties for all target types.

       The <u>&lt;LANG&gt;_VISIBILITY_PRESET</u> and <u>VISIBILITY_INLINES_HIDDEN</u> target properties affect visibility of symbols
       during  dynamic  linking.  When first introduced these properties affected compilation of sources only in
       shared libraries, module libraries, and executables with  the  <u>ENABLE_EXPORTS</u>  property  set.   This  was
       sufficient  for  the  basic  use  cases  of shared libraries and executables with plugins.  However, some
       sources may be compiled as part of static libraries or object libraries and then  linked  into  a  shared
       library  later.   CMake 3.3 and above prefer to honor these properties for sources compiled in all target
       types.  This policy preserves compatibility for projects expecting the properties to work only  for  some
       target types.

       The  <b>OLD</b>  behavior  for  this  policy is to ignore the visibility properties for static libraries, object
       libraries, and executables without exports.  The <b>NEW</b> behavior for this policy is to honor the  visibility
       properties for all target types.

       This   policy   was   introduced   in   CMake   version   3.3.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0062</b>
       Added in version 3.3.

       Disallow <u>install()</u> of <u>export()</u> result.

       The  <u>export()</u>  command  generates  a file containing <u>Imported</u> <u>Targets</u>, which is suitable for use from the
       build directory.  It is not suitable for installation because it contains absolute paths  to  buildsystem
       locations, and is particular to a single build configuration.

       The  <u>install(EXPORT)</u>  generates  and  installs  files  which  contain  <u>Imported</u> <u>Targets</u>.  These files are
       generated with relative  paths  (unless  the  user  specifies  absolute  paths),  and  are  designed  for
       multi-configuration use.  See <u>Creating</u> <u>Packages</u> for more.

       CMake 3.3 no longer allows the use of the <u>install(FILES)</u> command with the result of the <u>export()</u> command.

       The  <b>OLD</b>  behavior  for  this  policy  is to allow installing the result of an <u>export()</u> command.  The <b>NEW</b>
       behavior for this policy is not to allow installing the result of an <u>export()</u> command.

       This  policy  was  introduced  in  CMake  version  3.3.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0061</b>
       Added in version 3.3.

       CTest does not by default tell <b>make</b> to ignore errors (<b>-i</b>).

       The <u>ctest_build()</u> and <u>build_command()</u> commands no longer generate build commands for <u>Makefile</u>  <u>Generators</u>
       with  the  <b>-i</b>  option.   Previously  this  was done to help build as much of tested projects as possible.
       However, this behavior is not consistent with other generators and also causes the  return  code  of  the
       <b>make</b> tool to be meaningless.

       Of  course  users  may  still  add this option manually by setting <u>CTEST_BUILD_COMMAND</u> or the <b>MAKECOMMAND</b>
       cache entry.  See the <u>CTest</u> <u>Build</u> <u>Step</u> <b>MakeCommand</b> setting documentation for their effects.

       The <b>OLD</b> behavior for this policy is to add <b>-i</b> to <b>make</b> calls in CTest.  The <b>NEW</b> behavior for  this  policy
       is to not add <b>-i</b>.

       This   policy   was   introduced   in   CMake   version   3.3.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0060</b>
       Added in version 3.3.

       Link libraries by full path even in implicit directories.

       Policy <u>CMP0003</u> was introduced with the intention of always linking library files by full path when a full
       path  is  given  to  the  <u>target_link_libraries()</u>  command.   However, on some platforms (e.g. HP-UX) the
       compiler  front-end  adds  alternative  library  search  paths  for  the   current   architecture   (e.g.
       <b><a href="file:/usr/lib/">/usr/lib/</a>&lt;arch&gt;</b>  has  alternatives  to  libraries  in  <b><a href="file:/usr/lib">/usr/lib</a></b>  for  the current architecture).  On such
       platforms the <u>find_library()</u> may find a library such as <b>/usr/lib/libfoo.so</b> that does not  belong  to  the
       current architecture.

       Prior to policy <u>CMP0003</u> projects would still build in such cases because the incorrect library path would
       be  converted to <b>-lfoo</b> on the link line and the linker would find the proper library in the arch-specific
       search path provided by the compiler front-end implicitly.  At the time we  chose  to  remain  compatible
       with  such  projects by always converting library files found in implicit link directories to <b>-lfoo</b> flags
       to ask the linker to search for them.  This approach allowed existing projects to continue to build while
       still linking to libraries outside implicit link directories via full path (such as those  in  the  build
       tree).

       CMake  does  allow  projects  to  override  this  behavior  by  using an <u>IMPORTED</u> <u>library</u> <u>target</u> with its
       <u>IMPORTED_LOCATION</u> property set to the desired full path to a library file.  In fact,  many  <u>Find</u>  <u>Modules</u>
       are  learning  to provide <u>Imported</u> <u>Targets</u> instead of just the traditional <b>Foo_LIBRARIES</b> variable listing
       library files.  However, this makes the link line generated for a library found by a Find  Module  depend
       on  whether  it  is  linked  through an imported target or not, which is inconsistent.  Furthermore, this
       behavior has been a source of confusion because the generated link line for a library file depends on its
       location.  It is also problematic for projects trying to link statically because flags like  <b>-Wl,-Bstatic</b>
       <b>-lfoo</b>  <b>-Wl,-Bdynamic</b>  may  be  used to help the linker select <b>libfoo.a</b> instead of <b>libfoo.so</b> but then leak
       dynamic linking to following libraries.  (See the <u>LINK_SEARCH_END_STATIC</u> target property for  a  solution
       typically used for that problem.)

       When  the  special  case  for  libraries  in  implicit  link directories was first introduced the list of
       implicit link directories was simply hard-coded (e.g. <b><a href="file:/lib">/lib</a></b>, <b><a href="file:/usr/lib">/usr/lib</a></b>, and  a  few  others).   Since  that
       time,  CMake  has  learned  to  detect  the implicit link directories used by the compiler front-end.  If
       necessary, the <u>find_library()</u> command could be taught to use this information to help find  libraries  of
       the proper architecture.

       For  these  reasons,  CMake 3.3 and above prefer to drop the special case and link libraries by full path
       even when they are in implicit link directories.  Policy  <b>CMP0060</b>  provides  compatibility  for  existing
       projects.

       The  <b>OLD</b> behavior for this policy is to ask the linker to search for libraries whose full paths are known
       to be in implicit link directories.  The <b>NEW</b> behavior for this policy is to link libraries by  full  path
       even if they are in implicit link directories.

       This   policy   was   introduced   in   CMake   version   3.3.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0060</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0059</b>
       Added in version 3.3.

       Do not treat <b>DEFINITIONS</b> as a built-in directory property.

       CMake  3.3  and  above  no  longer make a list of definitions available through the <u>DEFINITIONS</u> directory
       property.  The <u>COMPILE_DEFINITIONS</u> directory property may be used instead.

       The <b>OLD</b> behavior for this policy is to provide the list of flags given so far  to  the  <u>add_definitions()</u>
       command.  The <b>NEW</b> behavior is to behave as a normal user-defined directory property.

       This   policy   was   introduced   in   CMake   version   3.3.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0058</b>
       Added in version 3.3.

       Ninja requires custom command byproducts to be explicit.

       When  an  intermediate  file  generated during the build is consumed by an expensive operation or a large
       tree of dependents, one may reduce the work needed for  an  incremental  rebuild  by  updating  the  file
       timestamp  only  when  its  content changes.  With this approach the generation rule must have a separate
       output file that is always updated with a new timestamp that is newer than any dependencies of  the  rule
       so  that  the  build  tool re-runs the rule only when the input changes.  We refer to the separate output
       file as a rule's <u>witness</u> and the generated file as a rule's <u>byproduct</u>.

       Byproducts may not be listed as outputs because their timestamps are allowed to be older than the inputs.
       No build tools (like <b>make</b>) that existed when CMake  was  designed  have  a  way  to  express  byproducts.
       Therefore  CMake  versions  prior  to 3.2 had no way to specify them.  Projects typically left byproducts
       undeclared in the rules that generate them.  For example:

          add_custom_command(
            OUTPUT witness.txt
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
                    ${CMAKE_CURRENT_SOURCE_DIR}/input.txt
                    byproduct.txt # timestamp may not change
            COMMAND ${CMAKE_COMMAND} -E touch witness.txt
            DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/input.txt
            )
          add_custom_target(Provider DEPENDS witness.txt)
          add_custom_command(
            OUTPUT generated.c
            COMMAND expensive-task -i byproduct.txt -o generated.c
            DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/byproduct.txt
            )
          add_library(Consumer generated.c)
          add_dependencies(Consumer Provider)

       This works well for all generators except <u>Ninja</u>.  The Ninja build tool sees a rule listing  <b>byproduct.txt</b>
       as  a  dependency  and  no  rule  listing  it as an output.  Ninja then complains that there is no way to
       satisfy the dependency and stops building even though  there  are  order-only  dependencies  that  ensure
       <b>byproduct.txt</b> will exist before its consumers need it.  See discussion of this problem in <u>Ninja</u> <u>Issue</u> <u>760</u>
       for further details on why Ninja works this way.

       Instead  of leaving byproducts undeclared in the rules that generate them, Ninja expects byproducts to be
       listed along with other outputs.  Such rules may be marked with a <b>restat</b> option that tells Ninja to check
       the timestamps of outputs after the rules run.  This prevents byproducts whose timestamps do  not  change
       from causing their dependents to re-build unnecessarily.

       Since  the  above  approach  does  not  tell CMake what custom command generates <b>byproduct.txt</b>, the Ninja
       generator does not have enough information to add the byproduct as an output of any rule.   CMake  2.8.12
       and  above  work  around  this problem and allow projects using the above approach to build by generating
       <b>phony</b> build rules to tell Ninja to tolerate such missing files.  However, this workaround prevents  Ninja
       from  diagnosing  a  dependency  that  is really missing.  It also works poorly in in-source builds where
       every custom command dependency, even on source files, needs to be treated this way  because  CMake  does
       not have enough information to know which files are generated as byproducts of custom commands.

   <b>Introducing</b> <b>Byproducts</b>
       CMake  3.2 introduced the <b>BYPRODUCTS</b> option to the <u>add_custom_command()</u> and <u>add_custom_target()</u> commands.
       This option allows byproducts to be specified explicitly:

          add_custom_command(
            OUTPUT witness.txt
            BYPRODUCTS byproduct.txt # explicit byproduct specification
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
                    ${CMAKE_CURRENT_SOURCE_DIR}/input.txt
                    byproduct.txt # timestamp may not change
          ...

       The <b>BYPRODUCTS</b> option is used by the <u>Ninja</u> generator to list byproducts among the outputs of  the  custom
       commands that generate them, and is ignored by other generators.

       CMake 3.3 and above prefer to require projects to specify custom command byproducts explicitly so that it
       can  avoid  using  the  <b>phony</b>  rule  workaround  altogether.   Policy  <b>CMP0058</b>  was introduced to provide
       compatibility with existing projects that still need the workaround.

       This policy has no effect on generators other than <u>Ninja</u>.   The  <b>OLD</b>  behavior  for  this  policy  is  to
       generate  Ninja <b>phony</b> rules for unknown dependencies in the build tree.  The <b>NEW</b> behavior for this policy
       is to not generate these and instead require projects to specify custom command <b>BYPRODUCTS</b> explicitly.

       This  policy  was  introduced  in  CMake  version  3.3.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.   If  it  is  not  set,  CMake  warns  when  it  sees  unknown  dependencies in
       out-of-source build trees, and uses <b>OLD</b> behavior.

       The policy setting must be in scope at the end of the top-level <b>CMakeLists.txt</b> file of  the  project  and
       has global effect.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0057</b>
       Added in version 3.3.

       Support new <u>if()</u> IN_LIST operator.

       CMake 3.3 adds support for the new IN_LIST operator.

       The <b>OLD</b> behavior for this policy is to ignore the IN_LIST operator.  The <b>NEW</b> behavior is to interpret the
       IN_LIST operator.

       This  policy  was  introduced  in  CMake  version  3.3.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.2</b></h4><pre>
   <b>CMP0056</b>
       Added in version 3.2.

       Honor link flags in <u>try_compile()</u> source-file signature.

       The <u>try_compile()</u> command source-file signature generates a <b>CMakeLists.txt</b> file to build the source  file
       into  an  executable.  In order to compile the source the same way as it might be compiled by the calling
       project, the generated project sets the value of the <u>CMAKE_&lt;LANG&gt;_FLAGS</u> variable to that in  the  calling
       project.  The value of the <u>CMAKE_EXE_LINKER_FLAGS</u> variable may be needed in some cases too, but CMake 3.1
       and  lower  did not set it in the generated project.  CMake 3.2 and above prefer to set it so that linker
       flags are honored as well as compiler  flags.   This  policy  provides  compatibility  with  the  pre-3.2
       behavior.

       The  <b>OLD</b>  behavior  for this policy is to not set the value of the <u>CMAKE_EXE_LINKER_FLAGS</u> variable in the
       generated  test  project.   The  <b>NEW</b>  behavior  for  this  policy  is   to   set   the   value   of   the
       <u>CMAKE_EXE_LINKER_FLAGS</u> variable in the test project to the same as it is in the calling project.

       If  the project code does not set the policy explicitly, users may set it on the command line by defining
       the <u>CMAKE_POLICY_DEFAULT_CMP0056</u> variable in the cache.

       This  policy  was  introduced  in  CMake  version  3.2.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0056</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0055</b>
       Added in version 3.2.

       Strict checking for the <u>break()</u> command.

       CMake 3.1 and lower allowed calls to the <u>break()</u> command outside of a loop context and also  ignored  any
       given arguments.  This was undefined behavior.

       The  <b>OLD</b>  behavior  for this policy is to allow <u>break()</u> to be placed outside of loop contexts and ignores
       any arguments.  The <b>NEW</b> behavior for this policy is to issue  an  error  if  a  misplaced  break  or  any
       arguments are found.

       This   policy   was   introduced   in   CMake   version   3.2.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.1</b></h4><pre>
   <b>CMP0054</b>
       Added in version 3.1.

       Only interpret <u>if()</u> arguments as variables or keywords when unquoted.

       CMake  3.1  and above no longer implicitly dereference variables or interpret keywords in an <u>if()</u> command
       argument when it is a <u>Quoted</u> <u>Argument</u> or a <u>Bracket</u> <u>Argument</u>.

       The <b>OLD</b> behavior for this policy is to dereference variables and interpret  keywords  even  if  they  are
       quoted  or  bracketed.   The <b>NEW</b> behavior is to not dereference variables or interpret keywords that have
       been quoted or bracketed.

       Given the following partial example:

          set(A E)
          set(E "")

          if("${A}" STREQUAL "")
            message("Result is TRUE before CMake 3.1 or when CMP0054 is OLD")
          else()
            message("Result is FALSE in CMake 3.1 and above if CMP0054 is NEW")
          endif()

       After explicit expansion of variables this gives:

          if("E" STREQUAL "")

       With the policy set to <b>OLD</b> implicit expansion reduces this semantically to:

          if("" STREQUAL "")

       With the policy set to <b>NEW</b> the quoted arguments will not be further dereferenced:

          if("E" STREQUAL "")

       This  policy  was  introduced  in  CMake  version  3.1.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0053</b>
       Added in version 3.1.

       Simplify variable reference and escape sequence evaluation.

       CMake 3.1 introduced a much faster implementation of evaluation of the  <u>Variable</u>  <u>References</u>  and  <u>Escape</u>
       <u>Sequences</u>  documented  in  the  <u><a href="../man7/cmake-language.7.html">cmake-language</a>(7)</u>  manual.  While the behavior is identical to the legacy
       implementation in most cases, some corner cases were cleaned up to simplify the behavior.  Specifically:

       • Expansion of <b>@VAR@</b> reference syntax defined by the <u>configure_file()</u> and <u>string(CONFIGURE)</u>  commands  is
         no longer performed in other contexts.

       • Literal  <b>${VAR}</b>  reference  syntax  may  contain  only  alphanumeric characters (<b>A-Z</b>, <b>a-z</b>, <b>0-9</b>) and the
         characters <b>_</b>, <b>.</b>, <b>/</b>, <b>-</b>, and <b>+</b>.  Note that <b>$</b> is technically allowed in the <b>NEW</b> behavior, but  is  invalid
         for  <b>OLD</b>  behavior.   This is due to an oversight during the implementation of <b>CMP0053</b> and its use as a
         literal variable reference is discouraged for this reason.  Variables with other  characters  in  their
         name may still be referenced indirectly, e.g.

            set(varname "otherwise &amp; disallowed $ characters")
            message("${${varname}}")

       • The  setting  of  policy  <u>CMP0010</u> is not considered, so improper variable reference syntax is always an
         error.

       • More characters are allowed to be escaped in variable names.  Previously,  only  <b>()#"</b>  <b>\@^</b>  were  valid
         characters  to  escape.  Now  any  non-alphanumeric,  non-semicolon,  non-NUL  character may be escaped
         following the <b>escape_identity</b> production in the  <u>Escape</u>  <u>Sequences</u>  section  of  the  <u><a href="../man7/cmake-language.7.html">cmake-language</a>(7)</u>
         manual.

       The  <b>OLD</b>  behavior  for  this  policy  is to honor the legacy behavior for variable references and escape
       sequences.  The <b>NEW</b> behavior is to use the simpler variable  expansion  and  escape  sequence  evaluation
       rules.

       This   policy   was   introduced   in   CMake   version   3.1.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0052</b>
       Added in version 3.1.

       Reject source and build dirs in installed <u>INTERFACE_INCLUDE_DIRECTORIES</u>.

       CMake  3.0  and  lower  allowed  subdirectories  of  the source directory or build directory to be in the
       <u>INTERFACE_INCLUDE_DIRECTORIES</u> of installed and exported targets, if the directory was also a subdirectory
       of the installation prefix.  This makes the installation depend on the existence of  the  source  dir  or
       binary dir, and the installation will be broken if either are removed after installation.

       See <u>Include</u> <u>Directories</u> <u>and</u> <u>Usage</u> <u>Requirements</u> for more on specifying include directories for targets.

       The  <b>OLD</b>  behavior for this policy is to export the content of the <u>INTERFACE_INCLUDE_DIRECTORIES</u> with the
       source or binary directory.  The <b>NEW</b> behavior for this policy is to issue an error if such a directory is
       used.

       This  policy  was  introduced  in  CMake  version  3.1.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0051</b>
       Added in version 3.1.

       List <u>TARGET_OBJECTS</u> in SOURCES target property.

       CMake 3.0 and lower did not include the <b>TARGET_OBJECTS</b> <u>generator</u> <u>expression</u> when  returning  the  <u>SOURCES</u>
       target property.

       Configure-time  CMake  code  is  not  able  to handle generator expressions.  If using the <u>SOURCES</u> target
       property at configure time, it  may  be  necessary  to  first  remove  generator  expressions  using  the
       <u>string(GENEX_STRIP)</u>  command.   Generate-time  CMake  code  such as <u>file(GENERATE)</u> can handle the content
       without stripping.

       The <b>OLD</b> behavior for this policy is to omit <b>TARGET_OBJECTS</b> expressions from the <u>SOURCES</u> target  property.
       The <b>NEW</b> behavior for this policy is to include <b>TARGET_OBJECTS</b> expressions in the output.

       This   policy   was   introduced   in   CMake   version   3.1.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>3.0</b></h4><pre>
   <b>CMP0050</b>
       Disallow add_custom_command SOURCE signatures.

       CMake  2.8.12  and  lower  allowed  a  signature  for  <u>add_custom_command()</u> which specified an input to a
       command.  This was undocumented behavior.  Modern use of CMake  associates  custom  commands  with  their
       output, rather than their input.

       The  <b>OLD</b> behavior for this policy is to allow the use of <u>add_custom_command()</u> SOURCE signatures.  The <b>NEW</b>
       behavior for this policy is to issue an error if such a signature is used.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0049</b>
       Do not expand variables in target source entries.

       CMake 2.8.12 and lower performed an extra layer of variable expansion when evaluating source file names:

          set(a_source foo.c)
          add_executable(foo \${a_source})

       This was undocumented behavior.

       The <b>OLD</b> behavior for this policy is to expand such variables when processing the target sources.  The <b>NEW</b>
       behavior for this policy is to issue an error if such variables need to be expanded.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0048</b>
       The <u>project()</u> command manages <b>VERSION</b> variables.

       CMake version 3.0 introduced the <b>VERSION</b> option of the <u>project()</u> command to specify a project version  as
       well  as  the  name.   In  order  to  keep <u>PROJECT_VERSION</u> and related variables consistent with variable
       <u>PROJECT_NAME</u> it is necessary to set the <b>VERSION</b> variables to the empty string when no <b>VERSION</b> is given to
       <u>project()</u>.  However, this can change behavior for existing projects that set <b>VERSION</b> variables themselves
       since <u>project()</u> may now clear them.  This policy  controls  the  behavior  for  compatibility  with  such
       projects.

       The  <b>OLD</b>  behavior  for  this  policy is to leave <b>VERSION</b> variables untouched.  The <b>NEW</b> behavior for this
       policy is to set <b>VERSION</b> as documented by the <u>project()</u> command.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0047</b>
       Use <b>QCC</b> compiler id for the qcc drivers on QNX.

       CMake 3.0 and above recognize that the QNX qcc compiler driver is different from the GNU compiler.  CMake
       now prefers to present this to projects by setting the <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable to  <b>QCC</b>  instead
       of <b>GNU</b>.  However, existing projects may assume the compiler id for QNX qcc is just <b>GNU</b> as it was in CMake
       versions  prior  to 3.0.  Therefore this policy determines for QNX qcc which compiler id to report in the
       <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable after language <b>&lt;LANG&gt;</b> is enabled by the <u>project()</u> or  <u>enable_language()</u>
       command.  The policy must be set prior to the invocation of either command.

       The  <b>OLD</b> behavior for this policy is to use the <b>GNU</b> compiler id for the qcc and QCC compiler drivers. The
       <b>NEW</b> behavior for this policy is to use the <b>QCC</b> compiler id for those drivers.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0047</u> variable to control the warning.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0046</b>
       Error on non-existent dependency in add_dependencies.

       CMake 2.8.12 and lower silently  ignored  non-existent  dependencies  listed  in  the  <u>add_dependencies()</u>
       command.

       The  <b>OLD</b>  behavior  for this policy is to silently ignore non-existent dependencies. The <b>NEW</b> behavior for
       this policy is to report an error if non-existent  dependencies  are  listed  in  the  <u>add_dependencies()</u>
       command.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0045</b>
       Error on non-existent target in get_target_property.

       In  CMake  2.8.12  and  lower,  the <u>get_target_property()</u> command accepted a non-existent target argument
       without issuing any error or warning.  The result variable is set to a <b>-NOTFOUND</b> value.

       The <b>OLD</b> behavior for this policy is to issue no warning and set the result variable to a <b>-NOTFOUND</b> value.
       The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> if the command is called with  a  non-existent
       target.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0044</b>
       Case sensitive <b>&lt;LANG&gt;_COMPILER_ID</b> generator expressions

       CMake  2.8.12  introduced  the  <b>&lt;LANG&gt;_COMPILER_ID</b>  <u>generator</u>  <u>expressions</u>  to  allow  comparison  of the
       <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> with a test value.  The possible valid values are lowercase, but the  comparison
       with the test value was performed case-insensitively.

       The  <b>OLD</b>  behavior  for  this  policy  is  to perform a case-insensitive comparison with the value in the
       <b>&lt;LANG&gt;_COMPILER_ID</b> expression. The <b>NEW</b> behavior for this policy is to perform a case-sensitive comparison
       with the value in the <b>&lt;LANG&gt;_COMPILER_ID</b> expression.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0043</b>
       Ignore COMPILE_DEFINITIONS_&lt;Config&gt; properties

       CMake  2.8.12  and  lower  allowed  setting  the   <u>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</u>   target   property   and
       <u>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</u> directory property to apply configuration-specific compile definitions.

       Since  CMake  2.8.10,  the  <u>COMPILE_DEFINITIONS</u>  property has supported <u>generator</u> <u>expressions</u> for setting
       configuration-dependent content.  The continued existence of the suffixed  variables  is  redundant,  and
       causes a maintenance burden.  Population of the <u>COMPILE_DEFINITIONS_DEBUG</u> property may be replaced with a
       population of <u>COMPILE_DEFINITIONS</u> directly or via <u>target_compile_definitions()</u>:

          # Old Interfaces:
          set_property(TARGET tgt APPEND PROPERTY
            COMPILE_DEFINITIONS_DEBUG DEBUG_MODE
          )
          set_property(DIRECTORY APPEND PROPERTY
            COMPILE_DEFINITIONS_DEBUG DIR_DEBUG_MODE
          )

          # New Interfaces:
          set_property(TARGET tgt APPEND PROPERTY
            COMPILE_DEFINITIONS $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;
          )
          target_compile_definitions(tgt PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;)
          set_property(DIRECTORY APPEND PROPERTY
            COMPILE_DEFINITIONS $&lt;$&lt;CONFIG:Debug&gt;:DIR_DEBUG_MODE&gt;
          )

       The  <b>OLD</b>  behavior for this policy is to consume the content of the suffixed <u>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</u>
       target property when generating the compilation command. The <b>NEW</b> behavior for this policy  is  to  ignore
       the content of the <u>COMPILE_DEFINITIONS_&lt;CONFIG&gt;</u> target property .

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0042</b>
       <u>MACOSX_RPATH</u> is enabled by default.

       CMake  2.8.12  and  newer  has  support for using <b>@rpath</b> in a target's install name.  This was enabled by
       setting the target property <u>MACOSX_RPATH</u>.  The <b>@rpath</b> in an install name is a more flexible and  powerful
       mechanism than <b>@executable_path</b> or <b>@loader_path</b> for locating shared libraries.

       CMake  3.0  and  later  prefer  this property to be ON by default.  Projects wanting <b>@rpath</b> in a target's
       install name may remove any setting of the <u>INSTALL_NAME_DIR</u> and <u>CMAKE_INSTALL_NAME_DIR</u> variables.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0041</b>
       Error on relative include with generator expression.

       Diagnostics in CMake 2.8.12 and lower silently ignored an entry in the <u>INTERFACE_INCLUDE_DIRECTORIES</u> of a
       target if it contained a generator expression at any position.

       The path entries in that target property should not be relative. High-level API  should  ensure  that  by
       adding either a source directory or a install directory prefix, as appropriate.

       As  an  additional  diagnostic, the <u>INTERFACE_INCLUDE_DIRECTORIES</u> generated on an <u>IMPORTED</u> target for the
       install location should not contain paths in the source directory or the build directory.

       The <b>OLD</b> behavior for this policy is  to  ignore  relative  path  entries  if  they  contain  a  generator
       expression.  The  <b>NEW</b> behavior for this policy is to report an error if a generator expression appears in
       another location and the path is relative.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0040</b>
       The target in the <b>TARGET</b> signature of <u>add_custom_command()</u> must exist and must be defined in the  current
       directory.

       CMake  2.8.12  and  lower  silently  ignored  a  custom  command  created  with  the  <b>TARGET</b> signature of
       <u>add_custom_command()</u> if the target is unknown or was defined outside the current directory.

       The <b>OLD</b> behavior for this policy is to ignore custom commands for unknown targets.  The <b>NEW</b> behavior  for
       this  policy  is  to  report  an error if the target referenced in <u>add_custom_command()</u> is unknown or was
       defined outside the current directory.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0039</b>
       Utility targets may not have link dependencies.

       CMake  2.8.12  and  lower  allowed  using  utility  targets  in  the  left  hand  side  position  of  the
       <u>target_link_libraries()</u> command. This is an indicator of a bug in user code.

       The <b>OLD</b> behavior for this policy is to ignore attempts to set the link libraries of utility targets.  The
       <b>NEW</b>  behavior  for this policy is to report an error if an attempt is made to set the link libraries of a
       utility target.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0038</b>
       Targets may not link directly to themselves.

       CMake 2.8.12 and lower allowed a build target to link to itself directly with  a  <u>target_link_libraries()</u>
       call. This is an indicator of a bug in user code.

       The  <b>OLD</b>  behavior  for  this  policy  is  to  ignore  targets  which  list  themselves in their own link
       implementation.  The <b>NEW</b> behavior for this policy is to report an error if a target attempts to  link  to
       itself.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0037</b>
       Target names should not be reserved and should match a validity pattern.

       CMake   2.8.12   and   lower   allowed   creating   targets  using  <u>add_library()</u>,  <u>add_executable()</u>  and
       <u>add_custom_target()</u> with unrestricted  choice  for  the  target  name.   Newer  cmake  features  such  as
       <u><a href="../man7/cmake-generator-expressions.7.html">cmake-generator-expressions</a>(7)</u> and some diagnostics expect target names to match a restricted pattern.

       Target  names  may  contain  upper and lower case letters, numbers, the underscore character (<b>_</b>), dot(<b>.</b>),
       plus(<b>+</b>) and minus(<b>-</b>).  As a special case, <b>ALIAS</b> and <b>IMPORTED</b> targets may contain two consecutive colons.

       Target names reserved by one or more CMake generators are not allowed.  Among others these  include  <b>all</b>,
       <b>clean</b>, <b>help</b>, and <b>install</b>.

       Target  names  associated  with optional features, such as <b>test</b> and <b>package</b>, may also be reserved.  CMake
       3.10 and below always reserve them.  CMake 3.11 and  above  reserve  them  only  when  the  corresponding
       feature is enabled (e.g. by including the <u>CTest</u> or <u>CPack</u> modules).

       The  <b>OLD</b>  behavior for this policy is to allow creating targets with reserved names or which do not match
       the validity pattern.  The <b>NEW</b> behavior for this policy is to report an error if an add_* command is used
       with an invalid target name.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0036</b>
       The <u>build_name()</u> command should not be called.

       This command was added in May 2001 to compute a name  for  the  current  operating  system  and  compiler
       combination.   The  command  has long been documented as discouraged and replaced by the <u>CMAKE_SYSTEM</u> and
       <u>CMAKE_&lt;LANG&gt;_COMPILER</u> variables.

       CMake &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow  the
       command  to  be  called.   The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> when the command is
       called.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0035</b>
       The <u>variable_requires()</u> command should not be called.

       This command was introduced in November 2001 to  perform  some  conditional  logic.   It  has  long  been
       replaced by the <u>if()</u> command.

       CMake  &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow the
       command to be called.  The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b>  when  the  command  is
       called.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0034</b>
       The <u>utility_source()</u> command should not be called.

       This  command  was introduced in March 2001 to help build executables used to generate other files.  This
       approach has long been replaced by <u>add_executable()</u> combined with <u>add_custom_command()</u>.

       CMake &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow  the
       command  to  be  called.   The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> when the command is
       called.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0033</b>
       The <u>export_library_dependencies()</u> command should not be called.

       This command was added in January 2003 to export <b>&lt;tgt&gt;_LIB_DEPENDS</b> internal CMake cache entries to a file
       for installation with a project.  This was used at the time to allow transitive link dependencies to work
       for applications outside of the original build tree of a project.  The functionality has been  superseded
       by the <u>export()</u> and <u>install(EXPORT)</u> commands.

       CMake  &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow the
       command to be called.  The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b>  when  the  command  is
       called.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0032</b>
       The <u>output_required_files()</u> command should not be called.

       This  command  was  added  in  June  2001  to  expose the then-current CMake implicit dependency scanner.
       CMake's real implicit dependency scanner has evolved since then but is not exposed through this  command.
       The  scanning  capabilities  of  this  command are very limited and this functionality is better achieved
       through dedicated outside tools.

       CMake &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow  the
       command  to  be  called.   The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> when the command is
       called.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0031</b>
       The <u>load_command()</u> command should not be called.

       This command was added in August 2002 to allow projects to add arbitrary commands  implemented  in  C  or
       C++.   However,  it  does not work when the toolchain in use does not match the ABI of the CMake process.
       It has been mostly superseded by the <u>macro()</u> and <u>function()</u> commands.

       CMake &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow  the
       command  to  be  called.   The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> when the command is
       called.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0030</b>
       The <u>use_mangled_mesa()</u> command should not be called.

       This command was created in September 2001 to support VTK before modern CMake language and custom command
       capabilities.  VTK has not used it in years.

       CMake &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow  the
       command  to  be  called.   The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> when the command is
       called.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0029</b>
       The <u>subdir_depends()</u> command should not be called.

       The implementation of this command has been  empty  since  December  2001  but  was  kept  in  CMake  for
       compatibility for a long time.

       CMake  &gt;= 3.0 prefer that this command never be called.  The <b>OLD</b> behavior for this policy is to allow the
       command to be called.  The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b>  when  the  command  is
       called.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0028</b>
       Double colon in target name means <b>ALIAS</b> or <b>IMPORTED</b> target.

       CMake   2.8.12   and   lower   allowed   the   use   of   targets   and   files  with  double  colons  in
       <u>target_link_libraries()</u>, with some buildsystem generators.

       The use of double-colons is a common pattern used to namespace <b>IMPORTED</b> targets and <b>ALIAS</b> targets.   When
       computing  the  link dependencies of a target, the name of each dependency could either be a target, or a
       file on disk.  Previously, if a target was not found with a matching name, the  name  was  considered  to
       refer  to a file on disk.  This can lead to confusing error messages if there is a typo in what should be
       a target name.

       See also the <u>LINK_LIBRARIES_ONLY_TARGETS</u> target property.

       The <b>OLD</b> behavior for this policy is to search for targets, then files on disk, even if  the  search  term
       contains  double-colons.  The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> if a link dependency
       contains double-colons but is not an <b>IMPORTED</b> target or an <b>ALIAS</b> target.

       This  policy  was  introduced  in  CMake  version  3.0.    It   may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0027</b>
       Conditionally linked imported targets with missing include directories.

       CMake 2.8.11 introduced introduced the concept of <u>INTERFACE_INCLUDE_DIRECTORIES</u>, and  a  check  at  cmake
       time  that  the entries in the <u>INTERFACE_INCLUDE_DIRECTORIES</u> of an <b>IMPORTED</b> target actually exist.  CMake
       2.8.11 also introduced generator expression support in the <u>target_link_libraries()</u> command.  However,  if
       an  imported  target  is  linked  as  a  result  of a generator expression evaluation, the entries in the
       <u>INTERFACE_INCLUDE_DIRECTORIES</u> of that target were not checked for existence as they should be.

       The <b>OLD</b> behavior of this policy is to report a warning if an entry in  the  <u>INTERFACE_INCLUDE_DIRECTORIES</u>
       of a generator-expression conditionally linked <b>IMPORTED</b> target does not exist.

       The <b>NEW</b> behavior of this policy is to report an error if an entry in the <u>INTERFACE_INCLUDE_DIRECTORIES</u> of
       a generator-expression conditionally linked <b>IMPORTED</b> target does not exist.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0026</b>
       Disallow use of the LOCATION property for build targets.

       CMake 2.8.12 and lower allowed reading the <u>LOCATION</u> target property (and configuration-specific variants)
       to  determine  the  eventual location of build targets.  This relies on the assumption that all necessary
       information is available at configure-time to determine the final location and filename  of  the  target.
       However,  this  property  is  not  fully  determined until later at generate-time.  At generate time, the
       <u>$&lt;TARGET_FILE&gt;</u> generator expression can be used to determine the eventual <u>LOCATION</u> of a target output.

       Code which reads the <u>LOCATION</u>  target  property  can  be  ported  to  use  the  <u>$&lt;TARGET_FILE&gt;</u>  generator
       expression together with the <u>file(GENERATE)</u> subcommand to generate a file containing the target location.

       The <b>OLD</b> behavior for this policy is to allow reading the <u>LOCATION</u> properties from build-targets.  The <b>NEW</b>
       behavior for this policy is to not to allow reading the <u>LOCATION</u> properties from build-targets.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0025</b>
       Compiler id for Apple Clang is now <b>AppleClang</b>.

       CMake  3.0 and above recognize that Apple Clang is a different compiler than upstream Clang and that they
       have different version  numbers.   CMake  now  prefers  to  present  this  to  projects  by  setting  the
       <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u>  variable to <b>AppleClang</b> instead of <b>Clang</b>.  However, existing projects may assume
       the compiler id for Apple Clang is just <b>Clang</b> as it was in CMake versions prior to 3.0.   Therefore  this
       policy  determines  for  Apple Clang which compiler id to report in the <u>CMAKE_&lt;LANG&gt;_COMPILER_ID</u> variable
       after language <b>&lt;LANG&gt;</b> is enabled by the <u>project()</u> or <u>enable_language()</u> command.  The policy must  be  set
       prior to the invocation of either command.

       The <b>OLD</b> behavior for this policy is to use compiler id <b>Clang</b>.  The <b>NEW</b> behavior for this policy is to use
       compiler id <b>AppleClang</b>.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake does <u>not</u> warn by default, and uses <b>OLD</b> behavior.

       See documentation of the <u>CMAKE_POLICY_WARNING_CMP0025</u> variable to control the warning.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0024</b>
       Disallow include export result.

       CMake  2.8.12  and  lower  allowed  use of the <u>include()</u> command with the result of the <u>export()</u> command.
       This relies on the assumption that the <u>export()</u> command has an immediate effect at configure-time  during
       a  cmake  run.  Certain properties of targets are not fully determined until later at generate-time, such
       as the link language and complete list of link libraries.  Future refactoring will change the  effect  of
       the  <u>export()</u> command to be executed at generate-time.  Use <b>ALIAS</b> targets instead in cases where the goal
       is to refer to targets by another name.

       The <b>OLD</b> behavior for this policy is to allow including the  result  of  an  <u>export()</u>  command.   The  <b>NEW</b>
       behavior for this policy is not to allow including the result of an <u>export()</u> command.

       This   policy   was   introduced   in   CMake   version   3.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>2.8</b></h4><pre>
   <b>CMP0023</b>
       Plain and keyword <u>target_link_libraries()</u> signatures cannot be mixed.

       CMake  2.8.12  introduced  the <u>target_link_libraries()</u> signature using the <b>PUBLIC</b>, <b>PRIVATE</b>, and <b>INTERFACE</b>
       keywords to generalize the <b>LINK_PUBLIC</b> and <b>LINK_PRIVATE</b> keywords  introduced  in  CMake  2.8.7.   Use  of
       signatures  with  any  of  these  keywords sets the link interface of a target explicitly, even if empty.
       This produces confusing behavior when used in combination with  the  historical  behavior  of  the  plain
       <u>target_link_libraries()</u> signature.  For example, consider the code:

          target_link_libraries(mylib A)
          target_link_libraries(mylib PRIVATE B)

       After  the  first  line  the  link  interface  has  not  been  set explicitly so CMake would use the link
       implementation, A, as the link interface.  However, the second line sets the link interface to empty.  In
       order to avoid this subtle behavior CMake now prefers to disallow mixing the plain and keyword signatures
       of <u>target_link_libraries()</u> for a single target.

       The <b>OLD</b> behavior for this policy is to allow keyword and plain <u>target_link_libraries()</u> signatures  to  be
       mixed.  The <b>NEW</b> behavior for this policy is to not to allow mixing of the keyword and plain signatures.

       This   policy   was   introduced   in  CMake  version  2.8.12.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0022</b>
       <u>INTERFACE_LINK_LIBRARIES</u> defines the link interface.

       CMake    2.8.11   constructed   the   'link   interface'   of   a   target   from   properties   matching
       <b>(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</b>.  The modern way to specify config-sensitive content  is
       to use generator expressions and the <b>IMPORTED_</b> prefix makes uniform processing of the link interface with
       generator  expressions  impossible.   The  <u>INTERFACE_LINK_LIBRARIES</u>  target  property was introduced as a
       replacement   in   CMake   2.8.12.    This   new   property    is    named    consistently    with    the
       <b>INTERFACE_COMPILE_DEFINITIONS</b>,  <b>INTERFACE_INCLUDE_DIRECTORIES</b>  and  <b>INTERFACE_COMPILE_OPTIONS</b> properties.
       For in-build targets, CMake will use the INTERFACE_LINK_LIBRARIES property as  the  source  of  the  link
       interface  only if policy <b>CMP0022</b> is <b>NEW</b>.  When exporting a target which has this policy set to <b>NEW</b>, only
       the <u>INTERFACE_LINK_LIBRARIES</u> property will be processed and generated for the <b>IMPORTED</b> target by default.
       A new option to the <u>install(EXPORT)</u> and export commands allows export of  the  old-style  properties  for
       compatibility  with  downstream  users  of CMake versions older than 2.8.12.  The <u>target_link_libraries()</u>
       command will no longer populate the  properties  matching  <b>LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</b>  if  this
       policy is <b>NEW</b>.

       Warning-free  future-compatible  code  which  works  with CMake 2.8.7 onwards can be written by using the
       <b>LINK_PRIVATE</b> and <b>LINK_PUBLIC</b> keywords of <u>target_link_libraries()</u>.

       The <b>OLD</b> behavior for this policy is to ignore the <u>INTERFACE_LINK_LIBRARIES</u> property for in-build targets.
       The <b>NEW</b> behavior for this policy is to use the <b>INTERFACE_LINK_LIBRARIES</b> property  for  in-build  targets,
       and ignore the old properties matching <b>(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?</b>.

       This   policy   was   introduced   in  CMake  version  2.8.12.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0021</b>
       Fatal error on relative paths in <u>INCLUDE_DIRECTORIES</u> target property.

       CMake  2.8.10.2 and lower allowed the <u>INCLUDE_DIRECTORIES</u> target property to contain relative paths.  The
       base path for such relative entries is not well defined.   CMake  2.8.12  issues  a  <b>FATAL_ERROR</b>  if  the
       <u>INCLUDE_DIRECTORIES</u> property contains a relative path.

       The  <b>OLD</b>  behavior  for this policy is not to warn about relative paths in the <b>INCLUDE_DIRECTORIES</b> target
       property.  The <b>NEW</b> behavior for this policy is to issue a <b>FATAL_ERROR</b> if <b>INCLUDE_DIRECTORIES</b>  contains  a
       relative path.

       This   policy   was   introduced   in  CMake  version  2.8.12.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0020</b>
       Automatically link Qt executables to <b>qtmain</b> target on Windows.

       CMake  2.8.10 and lower required users of Qt to always specify a link dependency to the <b>qtmain.lib</b> static
       library manually on Windows.  CMake 2.8.11 gained the ability to  evaluate  generator  expressions  while
       determining  the link dependencies from <b>IMPORTED</b> targets.  This allows CMake itself to automatically link
       executables which link to Qt to the <b>qtmain.lib</b> library when using <b>IMPORTED</b> Qt targets.  For  applications
       already  linking  to <b>qtmain.lib</b>, this should have little impact.  For applications which supply their own
       alternative WinMain implementation and for applications which use the QAxServer library,  this  automatic
       linking will need to be disabled as per the documentation.

       The <b>OLD</b> behavior for this policy is not to link executables to <b>qtmain.lib</b> automatically when they link to
       the  QtCore  <b>IMPORTED</b>  target.   The  <b>NEW</b>  behavior  for this policy is to link executables to <b>qtmain.lib</b>
       automatically when they link to QtCore <b>IMPORTED</b> target.

       This  policy  was  introduced  in  CMake  version  2.8.11.   It  may  be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0019</b>
       Do not re-expand variables in include and link information.

       CMake 2.8.10 and lower re-evaluated  values  given  to  the  include_directories,  link_directories,  and
       link_libraries  commands to expand any leftover variable references at the end of the configuration step.
       This was for strict compatibility with VERY early CMake versions because all variable references are  now
       normally  evaluated  during  CMake language processing.  CMake 2.8.11 and higher prefer to skip the extra
       evaluation.

       The <b>OLD</b> behavior for this policy is to re-evaluate the values for strict compatibility.  The <b>NEW</b> behavior
       for this policy is to leave the values untouched.

       This  policy  was  introduced  in  CMake  version  2.8.11.   It  may  be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0018</b>
       Ignore <b>CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS</b> variable.

       CMake 2.8.8 and lower compiled sources in <b>SHARED</b> and <b>MODULE</b> libraries using the value of the undocumented
       <b>CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS</b> platform variable.   The  variable  contained  platform-specific  flags
       needed  to compile objects for shared libraries.  Typically it included a flag such as <b>-fPIC</b> for position
       independent code but also included other flags needed on  certain  platforms.   CMake  2.8.9  and  higher
       prefer  instead  to use the <u>POSITION_INDEPENDENT_CODE</u> target property to determine what targets should be
       position  independent,  and  new  undocumented  platform  variables  to  select  flags   while   ignoring
       <b>CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS</b> completely.

       The  default  for  either  approach  produces  identical  compilation  flags,  but  if a project modifies
       <b>CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS</b> from its original value this policy determines which approach to use.

       The <b>OLD</b> behavior for this policy is to ignore the <u>POSITION_INDEPENDENT_CODE</u> property for all targets  and
       use the modified value of <b>CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS</b> for <b>SHARED</b> and <b>MODULE</b> libraries.

       The <b>NEW</b> behavior for this policy is to ignore <b>CMAKE_SHARED_LIBRARY_&lt;Lang&gt;_FLAGS</b> whether it is modified or
       not and honor the <u>POSITION_INDEPENDENT_CODE</u> target property.

       This   policy   was   introduced   in   CMake  version  2.8.9.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0017</b>
       Prefer files from the CMake module directory when including from there.

       Starting  with  CMake  2.8.4,  if  a  cmake-module  shipped with CMake (i.e.  located in the CMake module
       directory) calls <u>include()</u> or <u>find_package()</u>, the  files  located  in  the  CMake  module  directory  are
       preferred  over  the  files  in  <u>CMAKE_MODULE_PATH</u>.   This makes sure that the modules belonging to CMake
       always get those files included which they expect, and against which they were developed and tested.   In
       all  other  cases,  the files found in <u>CMAKE_MODULE_PATH</u> still take precedence over the ones in the CMake
       module directory.  The <b>OLD</b> behavior is to always prefer files from CMAKE_MODULE_PATH over files from  the
       CMake modules directory.

       This   policy   was   introduced   in   CMake  version  2.8.4.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0016</b>
       <u>target_link_libraries()</u> reports error if its only argument is not a target.

       In  CMake 2.8.2 and lower the <u>target_link_libraries()</u> command silently ignored if it was called with only
       one argument, and this argument wasn't a valid target.  In CMake 2.8.3 and above it reports an  error  in
       this case.

       This   policy   was   introduced   in   CMake  version  2.8.3.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0015</b>
          <u>link_directories()</u> treats paths relative to the source dir.

       In  CMake  2.8.0  and lower the <u>link_directories()</u> command passed relative paths unchanged to the linker.
       In CMake 2.8.1 and above the <u>link_directories()</u> command prefers to interpret relative paths with  respect
       to  <b>CMAKE_CURRENT_SOURCE_DIR</b>, which is consistent with <u>include_directories()</u> and other commands.  The <b>OLD</b>
       behavior for this policy is to use relative paths verbatim in the linker command.  The <b>NEW</b>  behavior  for
       this  policy  is  to  convert  relative  paths  to  absolute  paths  by  appending  the  relative path to
       <b>CMAKE_CURRENT_SOURCE_DIR</b>.

       This  policy  was  introduced  in  CMake  version  2.8.1.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0014</b>
       Input directories must have <b>CMakeLists.txt</b>.

       CMake versions before 2.8 silently ignored missing <b>CMakeLists.txt</b>  files  in  directories  referenced  by
       <u>add_subdirectory()</u>  or   <u>subdirs()</u>, treating them as if present but empty.  In CMake 2.8.0 and above this
       <u>cmake_policy()</u> determines whether or not the case is an error.  The <b>OLD</b> behavior for this  policy  is  to
       silently ignore the problem.  The <b>NEW</b> behavior for this policy is to report an error.

       This   policy   was   introduced   in   CMake  version  2.8.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0013</b>
       Duplicate binary directories are not allowed.

       CMake  2.6.3  and  below  silently permitted add_subdirectory() calls to create the same binary directory
       multiple times.  During build system generation files would be written and then overwritten in the  build
       tree  and  could  lead  to  strange  behavior.   CMake 2.6.4 and above explicitly detect duplicate binary
       directories.  CMake 2.6.4 always considers this case an error.  In CMake  2.8.0  and  above  this  policy
       determines  whether  or not the case is an error.  The <b>OLD</b> behavior for this policy is to allow duplicate
       binary directories.  The NEW behavior for this policy is to disallow duplicate binary directories with an
       error.

       This  policy  was  introduced  in  CMake  version  2.8.0.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0012</b>
       <u>if()</u> recognizes numbers and boolean constants.

       In CMake versions 2.6.4 and lower the <u>if()</u> command implicitly  dereferenced  arguments  corresponding  to
       variables,  even  those named like numbers or boolean constants, except for <b>0</b> and <b>1</b>.  Numbers and boolean
       constants such as <b>true</b>, <b>false</b>, <b>yes</b>, <b>no</b>, <b>on</b>, <b>off</b>, <b>y</b>, <b>n</b>,  <b>notfound</b>,  <b>ignore</b>  (all  case  insensitive)  were
       recognized  in  some  cases  but  not all.  For example, the code <b>if(TRUE)</b> might have evaluated as <b>false</b>.
       Numbers such as 2 were recognized only in boolean expressions like <b>if(NOT</b> <b>2)</b> (leading to <b>false</b>)  but  not
       as a single-argument like <b><a href="../man2/if.2.html">if</a>(2)</b> (also leading to <b>false</b>).  Later versions of CMake prefer to treat numbers
       and boolean constants literally, so they should not be used as variable names.

       The  <b>OLD</b>  behavior  for this policy is to implicitly dereference variables named like numbers and boolean
       constants.  The <b>NEW</b> behavior for this policy is  to  recognize  numbers  and  boolean  constants  without
       dereferencing variables with such names.

       This   policy   was   introduced   in   CMake  version  2.8.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>POLICIES</b> <b>INTRODUCED</b> <b>BY</b> <b>CMAKE</b> <b>2.6</b></h4><pre>
   <b>CMP0011</b>
       Included scripts do automatic <u>cmake_policy()</u> PUSH and POP.

       In  CMake  2.6.2  and  below, CMake Policy settings in scripts loaded by the <u>include()</u> and <u>find_package()</u>
       commands would affect the includer.  Explicit invocations  of  <b>cmake_policy(PUSH)</b>  and  <b>cmake_policy(POP)</b>
       were  required  to  isolate policy changes and protect the includer.  While some scripts intend to affect
       the policies of their includer, most do not.  In CMake 2.6.3 and above, <u>include()</u> and  <u>find_package()</u>  by
       default  <b>PUSH</b>  and  <b>POP</b>  an  entry  on  the  policy  stack  around  an  included  script,  but  provide a
       <b>NO_POLICY_SCOPE</b> option to disable it.  This policy determines whether or not to imply <b>NO_POLICY_SCOPE</b> for
       compatibility.  The <b>OLD</b>  behavior  for  this  policy  is  to  imply  <b>NO_POLICY_SCOPE</b>  for  <u>include()</u>  and
       <u>find_package()</u>  commands.   The <b>NEW</b> behavior for this policy is to allow the commands to do their default
       cmake_policy <b>PUSH</b> and <b>POP</b>.

       This  policy  was  introduced  in  CMake  version  2.6.3.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0010</b>
       Bad variable reference syntax is an error.

       In CMake 2.6.2 and below, incorrect variable reference syntax such as a missing close-brace  (<b>${FOO</b>)  was
       reported  but  did  not  stop  processing  of  CMake code.  This policy determines whether a bad variable
       reference is an error.  The <b>OLD</b> behavior for this policy is to warn about the  error,  leave  the  string
       untouched, and continue.  The <b>NEW</b> behavior for this policy is to report an error.

       If <u>CMP0053</u> is set to <b>NEW</b>, this policy has no effect and is treated as always being <b>NEW</b>.

       This   policy   was   introduced   in   CMake  version  2.6.3.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0009</b>
       FILE GLOB_RECURSE calls should not follow symlinks by default.

       In  CMake  2.6.1  and  below, <u>file(GLOB_RECURSE)</u> calls would follow through symlinks, sometimes coming up
       with unexpectedly large result sets because of symlinks to top level directories that contain hundreds of
       thousands of files.

       This policy determines whether or not to follow symlinks encountered during  a  <u>file(GLOB_RECURSE)</u>  call.
       The  <b>OLD</b>  behavior for this policy is to follow the symlinks.  The <b>NEW</b> behavior for this policy is not to
       follow the symlinks by default, but only if <b>FOLLOW_SYMLINKS</b> is given as an  additional  argument  to  the
       <b>FILE</b> command.

       This   policy   was   introduced   in   CMake  version  2.6.2.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0008</b>
       Libraries linked by full-path must have a valid library file name.

       In CMake 2.4 and below it is possible to write code like

          target_link_libraries(myexe /full/path/to/somelib)

       where  <b>somelib</b>  is  supposed  to  be  a valid library file name such as <b>libsomelib.a</b> or <b>somelib.lib</b>.  For
       Makefile generators this produces an error at build time because the dependency on the full  path  cannot
       be  found.   For  <u>Visual</u> <u>Studio</u> <u>Generators</u> IDE and <u>Xcode</u> generators this used to work by accident because
       CMake would always split off the library directory and ask the linker to search for the library  by  name
       (<b>-lsomelib</b>  or  <b>somelib.lib</b>).   Despite the failure with Makefiles, some projects have code like this and
       build only with Visual Studio and/or Xcode.  This version of CMake prefers to pass the full path directly
       to the native build tool, which will fail in this case because it does not name a valid library file.

       This policy determines what to do with full paths that do not appear to name a valid library  file.   The
       <b>OLD</b>  behavior for this policy is to split the library name from the path and ask the linker to search for
       it.  The <b>NEW</b> behavior for this policy is to trust the given path and pass it directly to the native build
       tool unchanged.

       This  policy  was  introduced  in  CMake  version  2.6.1.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0007</b>
       list command no longer ignores empty elements.

       This policy determines whether the list command will ignore empty elements in the list.   CMake  2.4  and
       below  list commands ignored all empty elements in the list.  For example, <b>a;b;;c</b> would have length 3 and
       not 4.  The <b>OLD</b> behavior for this policy is to ignore empty list elements.  The  <b>NEW</b>  behavior  for  this
       policy is to correctly count empty elements in a list.

       This   policy   was   introduced   in   CMake  version  2.6.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0006</b>
       Installing <u>MACOSX_BUNDLE</u> targets requires a <b>BUNDLE</b> <b>DESTINATION</b>.

       This policy determines whether the <u>install(TARGETS)</u> command must be given a <b>BUNDLE</b> <b>DESTINATION</b> when asked
       to  install  a  target  with  the  <u>MACOSX_BUNDLE</u>  property  set.  CMake 2.4 and below did not distinguish
       application bundles from normal executables when installing targets.  CMake 2.6 provides a <b>BUNDLE</b>  option
       to  the  <u>install(TARGETS)</u>  command  that  specifies  rules  specific  to  application bundles on the Mac.
       Projects should use this option when installing a target with the <u>MACOSX_BUNDLE</u> property set.

       The <b>OLD</b> behavior for this policy is to fall back to the <b>RUNTIME</b> <b>DESTINATION</b> if a  <b>BUNDLE</b>  <b>DESTINATION</b>  is
       not  given.   The  <b>NEW</b>  behavior  for  this policy is to produce an error if a bundle target is installed
       without a <b>BUNDLE</b> <b>DESTINATION</b>.

       This  policy  was  introduced  in  CMake  version  2.6.0.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0005</b>
       Preprocessor definition values are now escaped automatically.

       This policy determines whether or not CMake should generate escaped preprocessor definition values  added
       via  add_definitions.   CMake  versions 2.4 and below assumed that only trivial values would be given for
       macros in add_definitions calls.  It did not attempt to escape non-trivial values such as string literals
       in generated build rules.  CMake versions 2.6 and above support  escaping  of  most  values,  but  cannot
       assume  the  user  has  not  added  escapes  already  in an attempt to work around limitations in earlier
       versions.

       The <b>OLD</b> behavior for this policy is to place definition values given to add_definitions directly  in  the
       generated  build  rules  without  attempting  to escape anything.  The <b>NEW</b> behavior for this policy is to
       generate  correct  escapes  for  all  native  build  tools  automatically.   See  documentation  of   the
       <b>COMPILE_DEFINITIONS</b> target property for limitations of the escaping implementation.

       This   policy   was   introduced   in   CMake  version  2.6.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0004</b>
       Libraries linked may not have leading or trailing whitespace.

       CMake  versions 2.4 and below silently removed leading and trailing whitespace from libraries linked with
       code like

          target_link_libraries(myexe " A ")

       This could lead to subtle errors in user projects.

       The <b>OLD</b> behavior for this policy is to silently remove leading and trailing whitespace.  The <b>NEW</b> behavior
       for this policy is to diagnose the existence of such whitespace as an error.  The setting for this policy
       used when checking the library names is that in effect when the target is created by an  <u>add_executable()</u>
       or <u>add_library()</u> command.

       This   policy   was   introduced   in   CMake  version  2.6.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0003</b>
       Libraries linked via full path no longer produce linker search paths.

       This  policy affects how libraries whose full paths are NOT known are found at link time, but was created
       due to a change in how CMake deals with libraries whose full paths are known.  Consider the code

          target_link_libraries(myexe /path/to/libA.so)

       CMake 2.4 and below implemented linking to libraries whose full paths are known by splitting them on  the
       link  line  into  separate  components  consisting  of  the linker search path and the library name.  The
       example code might have produced something like

          ... -L/path/to -lA ...

       in order to link to library A.  An analysis was performed to order multiple link  directories  such  that
       the linker would find library A in the desired location, but there are cases in which this does not work.
       CMake  versions  2.6  and  above  use  the  more  reliable approach of passing the full path to libraries
       directly to the linker in most cases.  The example code now produces something like

          ... /path/to/libA.so ....

       Unfortunately this change can break code like

          target_link_libraries(myexe /path/to/libA.so B)

       where <b>B</b> is meant to find <b>/path/to/libB.so</b>.  This code is wrong because the user is asking the  linker  to
       find  library  B  but has not provided a linker search path (which may be added with the link_directories
       command).  However, with the old linking implementation the code  would  work  accidentally  because  the
       linker search path added for library A allowed library B to be found.

       In  order  to  support projects depending on linker search paths added by linking to libraries with known
       full paths, the <b>OLD</b> behavior for this policy will add the linker search paths even though  they  are  not
       needed for their own libraries.  When this policy is set to <b>OLD</b>, CMake will produce a link line such as

          ... -L/path/to /path/to/libA.so -lB ...

       which  will allow library B to be found as it was previously.  When this policy is set to NEW, CMake will
       produce a link line such as

          ... /path/to/libA.so -lB ...

       which more accurately matches what the project specified.

       The setting for this policy used when generating the link line is that  in  effect  when  the  target  is
       created by an add_executable or add_library command.  For the example described above, the code

          cmake_policy(SET CMP0003 OLD) # or cmake_policy(VERSION 2.4)
          add_executable(myexe myexe.c)
          target_link_libraries(myexe /path/to/libA.so B)

       will  work  and  suppress the warning for this policy.  It may also be updated to work with the corrected
       linking approach:

          cmake_policy(SET CMP0003 NEW) # or cmake_policy(VERSION 2.6)
          link_directories(/path/to) # needed to find library B
          add_executable(myexe myexe.c)
          target_link_libraries(myexe /path/to/libA.so B)

       Even better, library B may be specified with a full path:

          add_executable(myexe myexe.c)
          target_link_libraries(myexe /path/to/libA.so /path/to/libB.so)

       When all items on the link line have known paths CMake does not check this policy so it has no effect.

       Note that the warning for this policy will be issued for at most one target.  This avoids flooding  users
       with messages for every target when setting the policy once will probably fix all targets.

       This   policy   was   introduced   in   CMake  version  2.6.0.   It  may  be  set  by  <u>cmake_policy()</u>  or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

   <b>CMP0002</b>
       Logical target names must be globally unique.

       Targets  names  created  with  <u>add_executable()</u>,  <u>add_library()</u>, or <u>add_custom_target()</u> are logical build
       target names.  Logical target names must be globally unique because:

          - Unique names may be referenced unambiguously both in CMake
            code and on make tool command lines.
          - Logical names are used by Xcode and VS IDE generators
            to produce meaningful project names for the targets.

       The logical name of executable and library targets does not have to correspond to the physical file names
       built.  Consider using the <u>OUTPUT_NAME</u> target property to create two targets with the same physical  name
       while  keeping logical names distinct.  Custom targets must simply have globally unique names (unless one
       uses the global property <u>ALLOW_DUPLICATE_CUSTOM_TARGETS</u> with a Makefiles generator).

       This  policy  was  introduced  in  CMake  version  2.6.0.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0001</b>
       <b>CMAKE_BACKWARDS_COMPATIBILITY</b> should no longer be used.

       The behavior is to check <b>CMAKE_BACKWARDS_COMPATIBILITY</b> and present it to the user.  The <b>NEW</b>  behavior  is
       to ignore CMAKE_BACKWARDS_COMPATIBILITY completely.

       In  CMake 2.4 and below the variable <b>CMAKE_BACKWARDS_COMPATIBILITY</b> was used to request compatibility with
       earlier versions of CMake.  In CMake 2.6 and above all compatibility issues are handled by  policies  and
       the  <u>cmake_policy()</u>  command.  However, CMake must still check <b>CMAKE_BACKWARDS_COMPATIBILITY</b> for projects
       written for CMake 2.4 and below.

       This  policy  was  introduced  in  CMake  version  2.6.0.   It  may   be   set   by   <u>cmake_policy()</u>   or
       <u>cmake_minimum_required()</u>.  If it is not set, CMake warns, and uses <b>OLD</b> behavior.

       <b>NOTE:</b>
          The  <b>OLD</b>  behavior  of  a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in a future version of
          CMake.

   <b>CMP0000</b>
       A minimum required CMake version must be specified.

       CMake requires that projects specify the version of CMake to which they have been written.   This  policy
       has  been  put  in  place so users trying to build the project may be told when they need to update their
       CMake.  Specifying a version also helps the project build with CMake versions newer than that  specified.
       Use the <u>cmake_minimum_required()</u> command at the top of your main <b>CMakeLists.txt</b> file:

          cmake_minimum_required(VERSION &lt;major&gt;.&lt;minor&gt;)

       where  <b>&lt;major&gt;.&lt;minor&gt;</b>  is  the  version  of  CMake you want to support (such as <b>3.14</b>).  The command will
       ensure that at least the given version of CMake is running and help newer versions be compatible with the
       project.  See documentation of <u>cmake_minimum_required()</u> for details.

       Note that the command invocation must appear in the <b>CMakeLists.txt</b> file itself; a  call  in  an  included
       file  is not sufficient.  However, the  <u>cmake_policy()</u> command may be called to set policy <b>CMP0000</b> to <b>OLD</b>
       or <b>NEW</b> behavior explicitly.  The <b>OLD</b> behavior is to silently ignore  the  missing  invocation.   The  <b>NEW</b>
       behavior  is  to  issue  an  error  instead of a warning.  An included file may set <b>CMP0000</b> explicitly to
       affect how this policy is enforced for the main <b>CMakeLists.txt</b> file.

       This policy was introduced in CMake version 2.6.0.

       <b>NOTE:</b>
          The <b>OLD</b> behavior of a policy is <u>deprecated</u> <u>by</u> <u>definition</u> and may be removed in  a  future  version  of
          CMake.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2000-2024 Kitware, Inc. and Contributors

3.31.6                                            May 23, 2025                                 <u><a href="../man7/CMAKE-POLICIES.7.html">CMAKE-POLICIES</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>