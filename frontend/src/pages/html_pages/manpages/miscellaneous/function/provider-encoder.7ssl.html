<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>provider-encoder - The OSSL_ENCODER library <-> provider functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openssl">openssl_3.5.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       provider-encoder - The OSSL_ENCODER library &lt;-&gt; provider functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/core_dispatch.h&gt;

        /*
         * None of these are actual functions, but are displayed like this for
         * the function signatures for functions that are offered as function
         * pointers in OSSL_DISPATCH arrays.
         */

        /* Encoder parameter accessor and descriptor */
        const OSSL_PARAM *OSSL_FUNC_encoder_gettable_params(void *provctx);
        int OSSL_FUNC_encoder_get_params(OSSL_PARAM params[]);

        /* Functions to construct / destruct / manipulate the encoder context */
        void *OSSL_FUNC_encoder_newctx(void *provctx);
        void OSSL_FUNC_encoder_freectx(void *ctx);
        int OSSL_FUNC_encoder_set_ctx_params(void *ctx, const OSSL_PARAM params[]);
        const OSSL_PARAM *OSSL_FUNC_encoder_settable_ctx_params(void *provctx);

        /* Functions to check selection support */
        int OSSL_FUNC_encoder_does_selection(void *provctx, int selection);

        /* Functions to encode object data */
        int OSSL_FUNC_encoder_encode(void *ctx, OSSL_CORE_BIO *out,
                                     const void *obj_raw,
                                     const OSSL_PARAM obj_abstract[],
                                     int selection,
                                     OSSL_PASSPHRASE_CALLBACK *cb,
                                     void *cbarg);

        /* Functions to import and free a temporary object to be encoded */
        void *OSSL_FUNC_encoder_import_object(void *ctx, int selection,
                                              const OSSL_PARAM params[]);
        void OSSL_FUNC_encoder_free_object(void *obj);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>We</u> <u>use</u> <u>the</u> <u>wide</u> <u>term</u> <u>"encode"</u> <u>in</u> <u>this</u> <u>manual.</u>  <u>This</u> <u>includes</u> <u>but</u> <u>is</u> <u>not</u> <u>limited</u> <u>to</u> <u>serialization.</u>

       The ENCODER operation is a generic method to encode a provider-native object (<u>obj_raw</u>) or an object
       abstraction (<u>object_abstract</u>, see <b><a href="../man7/provider-object.7.html">provider-object</a></b>(7)) into an encoded form, and write the result to the
       given OSSL_CORE_BIO.  If the caller wants to get the encoded stream to memory, it should provide a
       <b><a href="../man3/BIO_s_mem.3.html">BIO_s_mem</a></b>(3) <b>BIO</b>.

       The encoder doesn't need to know more about the <b>OSSL_CORE_BIO</b> pointer than being able to pass it to the
       appropriate BIO upcalls (see "Core functions" in <b><a href="../man7/provider-base.7.html">provider-base</a></b>(7)).

       The ENCODER implementation may be part of a chain, where data is passed from one to the next.  For
       example, there may be an implementation to encode an object to DER (that object is assumed to be
       provider-native and thereby passed via <u>obj_raw</u>), and another one that encodes DER to PEM (that one would
       receive the DER encoding via <u>obj_abstract</u>).

       The encoding using the <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array form allows a encoder to be used for data that's been exported
       from another provider, and thereby allow them to exist independently of each other.

       The encoding using a provider side object can only be safely used with provider data coming from the same
       provider, for example keys with the KEYMGMT provider.

       All "functions" mentioned here are passed as function pointers between <u>libcrypto</u> and the provider in
       <b><a href="../man3/OSSL_DISPATCH.3.html">OSSL_DISPATCH</a></b>(3) arrays via <b><a href="../man3/OSSL_ALGORITHM.3.html">OSSL_ALGORITHM</a></b>(3) arrays that are returned by the provider's
       <b>provider_query_operation()</b> function (see "Provider Functions" in <b><a href="../man7/provider-base.7.html">provider-base</a></b>(7)).

       All these "functions" have a corresponding function type definition named <b>OSSL_FUNC_{name}_fn</b>, and a
       helper function to retrieve the function pointer from an <b><a href="../man3/OSSL_DISPATCH.3.html">OSSL_DISPATCH</a></b>(3) element named <b>OSSL_FUNC_{name}</b>.
       For example, the "function" <b>OSSL_FUNC_encoder_encode()</b> has these:

        typedef int
            (OSSL_FUNC_encoder_encode_fn)(void *ctx, OSSL_CORE_BIO *out,
                                          const void *obj_raw,
                                          const OSSL_PARAM obj_abstract[],
                                          int selection,
                                          OSSL_PASSPHRASE_CALLBACK *cb, void *cbarg);
        static ossl_inline OSSL_FUNC_encoder_encode_fn
            OSSL_FUNC_encoder_encode(const OSSL_DISPATCH *opf);

       <b><a href="../man3/OSSL_DISPATCH.3.html">OSSL_DISPATCH</a></b>(3) arrays are indexed by numbers that are provided as macros in <b><a href="../man7/openssl-core_dispatch.h.7.html">openssl-core_dispatch.h</a></b>(7),
       as follows:

        OSSL_FUNC_encoder_get_params          OSSL_FUNC_ENCODER_GET_PARAMS
        OSSL_FUNC_encoder_gettable_params     OSSL_FUNC_ENCODER_GETTABLE_PARAMS

        OSSL_FUNC_encoder_newctx              OSSL_FUNC_ENCODER_NEWCTX
        OSSL_FUNC_encoder_freectx             OSSL_FUNC_ENCODER_FREECTX
        OSSL_FUNC_encoder_set_ctx_params      OSSL_FUNC_ENCODER_SET_CTX_PARAMS
        OSSL_FUNC_encoder_settable_ctx_params OSSL_FUNC_ENCODER_SETTABLE_CTX_PARAMS

        OSSL_FUNC_encoder_does_selection      OSSL_FUNC_ENCODER_DOES_SELECTION

        OSSL_FUNC_encoder_encode              OSSL_FUNC_ENCODER_ENCODE

        OSSL_FUNC_encoder_import_object       OSSL_FUNC_ENCODER_IMPORT_OBJECT
        OSSL_FUNC_encoder_free_object         OSSL_FUNC_ENCODER_FREE_OBJECT

   <b>Names</b> <b>and</b> <b>properties</b>
       The name of an implementation should match the type of object it handles.  For example, an implementation
       that encodes an RSA key should be named "RSA".  Likewise, an implementation that further encodes DER
       should be named "DER".

       Properties, as defined in the <b><a href="../man3/OSSL_ALGORITHM.3.html">OSSL_ALGORITHM</a></b>(3) array element of each decoder implementation, can be used
       to further specify details about an implementation:

       output
           This property is used to specify what type of output the implementation produces.

           This property is <u>mandatory</u>.

           OpenSSL providers recognize the following output types:

           text
               An  implementation  with that output type outputs human readable text, making that implementation
               suitable for "-text" output in diverse <b><a href="../man1/openssl.1.html">openssl</a></b>(1) commands.

           pem An implementation with that output type outputs PEM formatted data.

           der An implementation with that output type outputs DER formatted data.

           msblob
               An implementation with that output type outputs MSBLOB formatted data.

           pvk An implementation with that output type outputs PVK formatted data.

       structure
           This property is used to specify the structure that is used for the encoded object.  An example could
           be "pkcs8", to specify explicitly that an object (presumably an asymmetric key pair,  in  this  case)
           will be wrapped in a PKCS#8 structure as part of the encoding.

           This property is <u>optional</u>.

       The  possible  values  of  both  these properties is open ended.  A provider may very well specify output
       types and structures that libcrypto doesn't know anything about.

   <b>Subset</b> <b>selections</b>
       Sometimes, an object has more than one subset  of  data  that  is  interesting  to  treat  separately  or
       together.  It's possible to specify what subsets are to be encoded, with a set of bits <u>selection</u> that are
       passed in an <b>int</b>.

       This set of bits depend entirely on what kind of provider-side object is passed.  For example, those bits
       are   assumed   to   be   the  same  as  those  used  with  <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)  (see  "Key  Objects"  in
       <b><a href="../man7/provider-keymgmt.7.html">provider-keymgmt</a></b>(7)) when the object is an asymmetric keypair.

       ENCODER implementations are free to regard the <u>selection</u> as a set of hints, but must do so with care.  In
       the end, the output must make sense, and if there's a corresponding decoder, the resulting decoded object
       must match the original object that was encoded.

       <b>OSSL_FUNC_encoder_does_selection()</b> should tell  if  a  particular  implementation  supports  any  of  the
       combinations given by <u>selection</u>.

   <b>Context</b> <b>functions</b>
       <b>OSSL_FUNC_encoder_newctx()</b> returns a context to be used with the rest of the functions.

       <b>OSSL_FUNC_encoder_freectx()</b> frees the given <u>ctx</u>, if it was created by <b>OSSL_FUNC_encoder_newctx()</b>.

       <b>OSSL_FUNC_encoder_set_ctx_params()</b>  sets  context  data  according  to  parameters  from  <u>params</u>  that it
       recognises.  Unrecognised parameters should be ignored.  Passing NULL for <u>params</u> should return true.

       <b>OSSL_FUNC_encoder_settable_ctx_params()</b> returns a constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array describing the  parameters
       that <b>OSSL_FUNC_encoder_set_ctx_params()</b> can handle.

       See     <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3)     for    further    details    on    the    parameters    structure    used    by
       <b>OSSL_FUNC_encoder_set_ctx_params()</b> and <b>OSSL_FUNC_encoder_settable_ctx_params()</b>.

   <b>Import</b> <b>functions</b>
       A provider-native object may be associated with a foreign provider, and may therefore be  unsuitable  for
       direct  use  with a given ENCODER implementation.  Provided that the foreign provider's implementation to
       handle the object has a function  to  export  that  object  in  <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3)  array  form,  the  ENCODER
       implementation  should  be  able  to  import  that  array  and  create  a suitable object to be passed to
       <b>OSSL_FUNC_encoder_encode()</b>'s <u>obj_raw</u>.

       <b>OSSL_FUNC_encoder_import_object()</b> should import the subset of <u>params</u> given with  <u>selection</u>  to  create  a
       provider-native object that can be passed as <u>obj_raw</u> to <b>OSSL_FUNC_encoder_encode()</b>.

       <b>OSSL_FUNC_encoder_free_object()</b>     should     free     the     object     that    was    created    with
       <b>OSSL_FUNC_encoder_import_object()</b>.

   <b>Encoding</b> <b>functions</b>
       <b>OSSL_FUNC_encoder_encode()</b> should take a provider-native object (in <u>obj_raw</u>) or an object abstraction (in
       <u>obj_abstract</u>), and should output the object in encoded form to the <b>OSSL_CORE_BIO</b>.  The <u>selection</u> bits, if
       relevant, should determine in greater detail what will be output.  The encoding functions  also  take  an
       <b><a href="../man3/OSSL_PASSPHRASE_CALLBACK.3.html">OSSL_PASSPHRASE_CALLBACK</a></b>(3) function pointer along with a pointer to application data <u>cbarg</u>, which should
       be used when a pass phrase prompt is needed.

   <b>Encoder</b> <b>operation</b> <b>parameters</b>
       Operation parameters currently recognised by built-in encoders are as follows:

       "cipher" (<b>OSSL_ENCODER_PARAM_CIPHER</b>) &lt;UTF8 string&gt;
           The  name  of the encryption cipher to be used when generating encrypted encoding.  This is used when
           encoding private keys, as well as other objects that need protection.

           If this name is invalid for the encoding implementation, the implementation should refuse to  perform
           the  encoding,  i.e.   <b>OSSL_FUNC_encoder_encode_data()</b>  and  <b>OSSL_FUNC_encoder_encode_object()</b> should
           return an error.

       "properties" (<b>OSSL_ENCODER_PARAM_PROPERTIES</b>) &lt;UTF8 string&gt;
           The properties to be queried when trying to fetch the algorithm given with  the  "cipher"  parameter.
           This must be given together with the "cipher" parameter to be considered valid.

           The  encoding  implementation  isn't  obligated  to  use this value.  However, it is recommended that
           implementations that do not handle property strings return  an  error  on  receiving  this  parameter
           unless its value NULL or the empty string.

       "save-parameters" (<b>OSSL_ENCODER_PARAM_SAVE_PARAMETERS</b>) &lt;integer&gt;
           If  set to 0 disables saving of key domain parameters. Default is 1.  It currently has an effect only
           on DSA keys.

       Parameters currently recognised by the built-in pass phrase callback:

       "info" (<b>OSSL_PASSPHRASE_PARAM_INFO</b>) &lt;UTF8 string&gt;
           A string of information that will become part of the pass phrase prompt.  This could be used to  give
           the user information on what kind of object it's being prompted for.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_FUNC_encoder_newctx()</b> returns a pointer to a context, or NULL on failure.

       <b>OSSL_FUNC_encoder_set_ctx_params()</b>  returns  1,  unless  a  recognised parameter was invalid or caused an
       error, for which 0 is returned.

       <b>OSSL_FUNC_encoder_settable_ctx_params()</b> returns a pointer to an array of constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) elements.

       <b>OSSL_FUNC_encoder_does_selection()</b> returns 1 if the encoder implementation supports any of the  <u>selection</u>
       bits, otherwise 0.

       <b>OSSL_FUNC_encoder_encode()</b> returns 1 on success, or 0 on failure.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/provider.7.html">provider</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The ENCODER interface was introduced in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2019-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                             <u><a href="../man7SSL/PROVIDER-ENCODER.7SSL.html">PROVIDER-ENCODER</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>