<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gitcvs-migration - Git for CVS users</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/git-man">git-man_2.50.0-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gitcvs-migration - Git for CVS users

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <u>git</u> <u>cvsimport</u> *

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Git differs from CVS in that every working tree contains a repository with a full copy of the project
       history, and no repository is inherently more important than any other. However, you can emulate the CVS
       model by designating a single shared repository which people can synchronize with; this document explains
       how to do that.

       Some basic familiarity with Git is required. Having gone through <b><a href="../man7/gittutorial.7.html">gittutorial</a></b>(7) and <b><a href="../man7/gitglossary.7.html">gitglossary</a></b>(7) should
       be sufficient.

</pre><h4><b>DEVELOPING</b> <b>AGAINST</b> <b>A</b> <b>SHARED</b> <b>REPOSITORY</b></h4><pre>
       Suppose a shared repository is set up in /pub/repo.git on the host foo.com. Then as an individual
       committer you can clone the shared repository over ssh with:

           $ git clone foo.com:/pub/repo.git/ my-project
           $ cd my-project

       and hack away. The equivalent of <u>cvs</u> <u>update</u> is

           $ git pull origin

       which merges in any work that others might have done since the clone operation. If there are uncommitted
       changes in your working tree, commit them first before running git pull.

           <b>Note</b>

           The <u>pull</u> command knows where to get updates from because of certain configuration variables that were
           set by the first <u>git</u> <u>clone</u> command; see <b>git</b> <b>config</b> <b>-l</b> and the <b><a href="../man1/git-config.1.html">git-config</a></b>(1) man page for details.

       You can update the shared repository with your changes by first committing your changes, and then using
       the <u>git</u> <u>push</u> command:

           $ git push origin master

       to "push" those commits to the shared repository. If someone else has updated the repository more
       recently, <u>git</u> <u>push</u>, like <u>cvs</u> <u>commit</u>, will complain, in which case you must pull any changes before
       attempting the push again.

       In the <u>git</u> <u>push</u> command above we specify the name of the remote branch to update (<b>master</b>). If we leave
       that out, <u>git</u> <u>push</u> tries to update any branches in the remote repository that have the same name as a
       branch in the local repository. So the last <u>push</u> can be done with either of:

           $ git push origin
           $ git push foo.com:/pub/project.git/

       as long as the shared repository does not have any branches other than <b>master</b>.

</pre><h4><b>SETTING</b> <b>UP</b> <b>A</b> <b>SHARED</b> <b>REPOSITORY</b></h4><pre>
       We assume you have already created a Git repository for your project, possibly created from scratch or
       from a tarball (see <b><a href="../man7/gittutorial.7.html">gittutorial</a></b>(7)), or imported from an already existing CVS repository (see the next
       section).

       Assume your existing repo is at /home/alice/myproject. Create a new "bare" repository (a repository
       without a working tree) and fetch your project into it:

           $ mkdir /pub/my-repo.git
           $ cd /pub/my-repo.git
           $ git --bare init --shared
           $ git --bare fetch /home/alice/myproject master:master

       Next, give every team member read/write access to this repository. One easy way to do this is to give all
       the team members ssh access to the machine where the repository is hosted. If you don’t want to give them
       a full shell on the machine, there is a restricted shell which only allows users to do Git pushes and
       pulls; see <b><a href="../man1/git-shell.1.html">git-shell</a></b>(1).

       Put all the committers in the same group, and make the repository writable by that group:

           $ chgrp -R $group /pub/my-repo.git

       Make sure committers have a umask of at most 027, so that the directories they create are writable and
       searchable by other group members.

</pre><h4><b>IMPORTING</b> <b>A</b> <b>CVS</b> <b>ARCHIVE</b></h4><pre>
           <b>Note</b>

           These instructions use the <b>git-cvsimport</b> script which ships with git, but other importers may provide
           better results. See the note in <b><a href="../man1/git-cvsimport.1.html">git-cvsimport</a></b>(1) for other options.

       First, install version 2.1 or higher of cvsps from <b>https://github.com/andreyvit/cvsps</b> and make sure it is
       in your path. Then cd to a checked out CVS working directory of the project you are interested in and run
       <b><a href="../man1/git-cvsimport.1.html">git-cvsimport</a></b>(1):

           $ git cvsimport -C &lt;destination&gt; &lt;module&gt;

       This puts a Git archive of the named CVS module in the directory &lt;destination&gt;, which will be created if
       necessary.

       The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty
       revisions per second, so for a medium-sized project this should not take more than a couple of minutes.
       Larger projects or remote repositories may take longer.

       The main trunk is stored in the Git branch named <b>origin</b>, and additional CVS branches are stored in Git
       branches with the same names. The most recent version of the main trunk is also left checked out on the
       <b>master</b> branch, so you can start adding your own changes right away.

       The import is incremental, so if you call it again next month it will fetch any CVS updates that have
       been made in the meantime. For this to work, you must not modify the imported branches; instead, create
       new branches for your own changes, and merge in the imported branches as necessary.

       If you want a shared repository, you will need to make a bare clone of the imported directory, as
       described above. Then treat the imported directory as another development clone for purposes of merging
       incremental imports.

</pre><h4><b>ADVANCED</b> <b>SHARED</b> <b>REPOSITORY</b> <b>MANAGEMENT</b></h4><pre>
       Git allows you to specify scripts called "hooks" to be run at certain points. You can use these, for
       example, to send all commits to the shared repository to a mailing list. See <b><a href="../man5/githooks.5.html">githooks</a></b>(5).

       You can enforce finer grained permissions using update hooks. See <b>Controlling</b> <b>access</b> <b>to</b> <b>branches</b> <b>using</b>
       <b>update</b> <b>hooks</b>[1].

</pre><h4><b>PROVIDING</b> <b>CVS</b> <b>ACCESS</b> <b>TO</b> <b>A</b> <b>GIT</b> <b>REPOSITORY</b></h4><pre>
       It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS;
       see <b><a href="../man1/git-cvsserver.1.html">git-cvsserver</a></b>(1) for details.

</pre><h4><b>ALTERNATIVE</b> <b>DEVELOPMENT</b> <b>MODELS</b></h4><pre>
       CVS users are accustomed to giving a group of developers commit access to a common repository. As we’ve
       seen, this is also possible with Git. However, the distributed nature of Git allows other development
       models, and you may want to first consider whether one of them might be a better fit for your project.

       For example, you can choose a single person to maintain the project’s primary public repository. Other
       developers then clone this repository and each work in their own clone. When they have a series of
       changes that they’re happy with, they ask the maintainer to pull from the branch containing the changes.
       The maintainer reviews their changes and pulls them into the primary repository, which other developers
       pull from as necessary to stay coordinated. The Linux kernel and other projects use variants of this
       model.

       With a small group, developers may just pull changes from each other’s repositories without the need for
       a central maintainer.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/gittutorial.7.html">gittutorial</a></b>(7), <b><a href="../man7/gittutorial-2.7.html">gittutorial-2</a></b>(7), <b><a href="../man7/gitcore-tutorial.7.html">gitcore-tutorial</a></b>(7), <b><a href="../man7/gitglossary.7.html">gitglossary</a></b>(7), <b><a href="../man7/giteveryday.7.html">giteveryday</a></b>(7), <b>The</b> <b>Git</b> <b>User’s</b>
       <b>Manual</b>[2]

</pre><h4><b>GIT</b></h4><pre>
       Part of the <b><a href="../man1/git.1.html">git</a></b>(1) suite

</pre><h4><b>NOTES</b></h4><pre>
        1. Controlling access to branches using update hooks
           file:///usr/share/doc/git/html/howto/update-hook-example.html

        2. The Git User’s Manual
           file:///usr/share/doc/git/html/user-manual.html

Git 2.50.0                                         07/03/2025                                <u><a href="../man7/GITCVS-MIGRATION.7.html">GITCVS-MIGRATION</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>