<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>icmscript - The C-like icmake scripting language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/icmake">icmake_13.02.00-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       icmscript - The <b>C</b>-like <u>icmake</u> scripting language

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b><a href="../man1/Icmake.1.html">Icmake</a></b>(1)  is a generic tool handling program maintenance that can be used as an alternative for <b><a href="../man1/make.1.html">make</a></b>(1).
       It’s a generic tool in that <u>icmake</u>-scripts, written in a language closely resembling  the  <b>C</b>  programming
       language, can perform tasks that are traditionally the domain of scripting languages.

       <b>Icmake</b>  allows  programmers to use a programming language (closely resembling the <b>C</b>-programming language)
       to define the actions that are required for  (complex)  program  maintenance.  For  this,  <b>icmake</b>  offers
       various  special  operators  as  well  as  a set of support functions that have shown their usefulness in
       program maintenance.

       This man-page covers the <b>icmake</b> scripting language in de following sections:

       o      <b>DATA</b> <b>TYPES</b>
              - <u>int,</u> <u>list,</u> <u>string</u>, and <u>void</u> (for functions);

       o      <b>OUTLINE</b>
              - outline of <b>icmake</b> scripts: what are their requirements, the structure and organization of  their
              <u>main</u>-functions.

       o      <b>PREPROCESSOR</b> <b>DIRECTIVES</b>
              - supported preprocessor directives, like <u>#include</u> and <u>#define</u>;

       o      <b>PREDEFINED</b> <b>CONSTANTS</b>
              - like <u>O_FILE,</u> <u>OFF</u>, and <u>S_IFREG</u>;

       o      <b>OPERATORS</b>
              - like <u>+,</u> <u>younger</u>, and casts

       o      <b>FLOW</b> <b>CONTROL</b>
              - <u>if,</u> <u>for,</u> <u>while</u>, etc. (the <u>switch</u> is not available);

       o      <b>PREDEFINED</b> <b>FUNCTIONS</b>
              -  executing  programs,  changing directories, operations on <u>string</u> and <u>list</u> type variables, etc..
              Functions are marked as <u>INT</u> <u>FUNCTIONS</u>, <u>LIST</u> <u>FUNCTIONS</u>, <u>STRING</u> <u>FUNCTIONS</u>

       o      <b>USER</b> <b>DEFINED</b> <b>FUNCTIONS</b>
              - at least <u>main</u>, with or without its common parameters <u>argc,</u> <u>argv,</u> and <u>envp</u>.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>Icmake</b> supports the following five data and value types:

       o      <u>ASCII</u> <u>character</u> <u>constants</u>
              ASCII character constants are ascii-characters, surrounded by  single  or  double  quotes.  Single
              characters  (e.g., <u>’a’</u>) represent the character itself. Standard escape sequences (e.g., <u>’\n’</u>) are
              supported and are converted to their well-known values  (e.g.,  <u>’\n’</u>  represents  ascii  value  10
              (decimal)).  Non-standard  escape  sequences  (e.g.,  <u>’\x’</u>)  are  converted to the ascii character
              following the escape character (so <u>’\x’</u> equals <u>’x’</u>). Escaped sequences consisting of  three  octal
              digits  represent  the  ascii character corresponding to the octal value, modulo 256 (e.g., <u>’\113’</u>
              represents <u>’K’</u>). Escape sequences consisting of an x followed by two hexadecimal digits  represent
              the ascii character corresponding to the hexadecimal value (e.g., <u>’\x4b’</u>, also representing <u>’K’</u>);

       o      <u>int</u>
              Integral  values,  ranging  from <u>-0x8000</u> through <u>0x7fff</u>. <u>int</u> constants may be specified as decimal
              numbers (starting with digits 1 through 9), octal numbers (starting with 0,  followed  by  one  or
              more  octal  digits),  hexadecimal  numbers (starting with 0x, followed by one or more hexadecimal
              digits), or as <u>ASCII</u> character constants;

       o      <u>string</u>
              Text values: text (or `string’) constants are delimited  by  double  or  single  quotes.  Multiple
              string  constants  may  be concatenated, but a single string constant may not span multiple lines.
              Multiple string constants, only separated by white space (i.e.,  blanks,  newlines,  comment)  are
              concatenated and are considered one single string constant. To indicate an end-of-line in a string
              constant use the <u>\n</u> escape sequence;

              If  arithmetic  expressions  use  at least one <u>int</u> operand then those expressions may also contain
              single character ASCII constants using double or single quotes. In those cases they represent  the
              ascii-values of their characters.

              Conversely,  ASCII character constants using single quotes may be used in situations where  string
              operands are expected;

       o      <u>list</u>
              A <u>list</u> is a data structure containing a series of individually accessible <u>string</u>  values.  When  a
              list contains elements, its first element has index 0;

              Lists may be written to the standard output stream or to file (using <u>printf</u> or <u>fprintf</u>). Lists can
              also  be  inserted  into  <u>string</u> variables using the function <u>strformat</u>. In these cases all (space
              delimited) elements of the lists are inserted into their destinations;

              Lists can also be defined as constants. They consist of an  optional  series  of  comma  separated
              string constants surrounded by a pair of square brackets. E.g.,

                  list words = ["a", "list", "constant"];

       o      <u>void</u>
              The type <u>void</u> is used when defining functions which do not return values. Alternatively, functions
              may return <u>int,</u> <u>string</u> or <u>list</u> values (cf. section <b>USER</b> <b>DEFINED</b> <b>FUNCTIONS</b>).

       Variables  can  be  defined  at  the  global  level and inside functions (not only at the top of compound
       statements but also between statements and in the initialization section of for- and if-statements). When
       defined inside functions, the standard <b>C</b> scoping and  visibility  rules  apply.  Variables  are  strongly
       typed, and cannot have type <u>void</u>.

       Variables  may  be  initialized  when  they  are  defined.  Initializations are expressions which may use
       predefined or user-defined functions, constant values, and values of variables.  Functions  or  variables
       that are used for initialization must be visible at the initialization point.

</pre><h4><b>OUTLINE</b></h4><pre>
       <b>Icmake</b>  scripts  require  a  user-defined function <u>main</u>. The function <u>main</u> has three optional parameters,
       which may be omitted from the last one (<u>envp</u>) to the first one (<u>argc</u>), like in <b>C</b>. Its full prototype is:

           void main(int argc, list argv, list envp)

       or

           int main(int argc, list argv, list envp)

       When a <u>void</u> <u>main</u> function ends (using a <u>return;</u> statement  or  when  its  execution  reaches  its  body’s
       closing  curly) the value 0 is returned to the operating system. When <u>int</u> <u>main</u> functions end using <u>return</u>
       statements then those statements must be provided with <u>int</u>-expressions. It’s OK when the execution of  an
       <u>int</u>  <u>main</u>  function  reaches  its  body’s closing curly, in which case 0 is automatically returned to the
       operating system

       In <u>main</u> the parameter

       o      <u>argc</u> represents the number of elements in <u>argv</u>;

       o      <u>argv</u> contains the arguments, with element 0 being equal to the name of the <u>.bim</u>  file,  that  were
              passed  to  the <u>.bim</u> file. The <b>OPTIONS</b> section of the <b><a href="../man1/icmake.1.html">icmake</a></b>(1) manpage covers how these arguments
              are forwarded to the <b>icmake</b> script using options <u>-e,</u> <u>-s,</u> and <u>-t</u>.

       o      <u>envp</u> contains the `environment’ variables. The function <u>listlen</u>  can  be  used  to  determine  the
              number  of  its  elements.  Elements  in  <u>envp</u>  use  the format <u>variable=value</u>. Alternatively, the
              (predefined) function <u>getenv</u> can be used to retrieve a specific environment variable immediately.

       Example (the implementations of the user-defined functions <u>usage,</u> <u>modified,</u> and <u>compile</u> are  left  as  an
       exercise for the reader):

           void main(int argc, list argv)
           {
               if (argc == 1)
                   usage(argv[0]);

               if (list toCompile = modified("*.cc"))
               {
                   for (int idx = listlen(toCompile); idx--; )
                       compile(toCompile[idx]);
               }
           }

       When  executing  an  <b>icmake</b>  script  <b>icmake’s</b>  run-time  support  system first initializes all all global
       variables in the order of their definitions. Following this the function <u>main</u> is called. The script  ends
       when <u>main</u> returns or when the function <u>exit</u> is called by the script.

</pre><h4><b>PREPROCESSOR</b> <b>DIRECTIVES</b></h4><pre>
       Before  actually  compiling  <b>icmake</b> scripts they are first pre-processed by the <b>icmake</b> pre-processor. The
       pre-processor removes comment, includes files specified by <u>include</u>-directives, and processes <u>#define</u>  and
       comparable directives.

       The following preprocessor directives are recognized:

       o      comment:
              standard  <b>C</b> comment (everything from <u>/*</u> through <u>*/</u>) as well as comment-to-end-of-line (starting at
              <u>//</u>, continuing to the end of the line) is ignored;

       o      Shell startup: The first line of the <b>icmake</b>-script may start with <u>#!path</u>, where <u>path</u>  defines  the
              (usually  absolute)  location  of  the  <b>icmake</b> program. By making the script executable, it can be
              called without explicitly calling <b>icmake</b>.

              E.g., if the first line of an (executable) icmake script ’icm’ (without extension) contains

                  #!/usr/bin/icmake -t.

              then <u>icm</u> can be issued as a command, interpreting the remaining lines of the script as  an  <b>icmake</b>
              source  which  is compiled and then executed by <b>icmake</b>. The <b><a href="../man1/icmake.1.html">icmake</a></b>(1) man-page’s section <b>EXECUTING</b>
              <b>ICMAKE</b> <b>SCRIPTS</b> covers the elements of the first line of <b>icmake</b> scripts.

       o      <u>#include</u> <u>"filename"</u>
              The file <u>filename</u> is included at the location of the directive;

       o      <u>#include</u> <u>&lt;filename&gt;</u>
              The file <u>filename</u> is included at the location of the <u>#include</u> directive; <u>filename</u> is  searched  in
              the  colon-separated directories specified by the <u>IM</u> environment variable. The first occurrence of
              <u>filename</u> in the directories specified by the <u>IM</u> environment variable is used;

       o      <u>#define</u> <u>identifier</u> <u>[definition]</u>
              The text <u>identifier</u> is replaced by <u>definition</u>. The definition may contain  references  to  already
              defined  identifiers,  using  the  syntax  <u>${identifier}</u>. If the <u>${identifier}</u> hasn’t been defined
              (yet), the literal text  <u>${identifier}</u>  is  used.  To  prevent  infinite  recursion  at  most  100
              <u>${identifier}</u> replacements are accepted;

              If  the  last  character  on a line is a backslash (<u>\</u>) then definitions continue at the next line.
              (the backslash is not included in the definition).  The  preprocessor  concatenates  double-quoted
              strings. Double quoted strings themselves may not span multiple lines. Multiple blanks (outside of
              double quoted strings) in definitions are contracted to a single space character;

              Following the <u>#define’s</u> identifier a definition may optional be provided. If omitted, the macro is
              defined,  so  it  can  be  used  in  <u>#if(n)def</u>  directives  (see  below), but in those cases these
              intentifiers are simply removed from <b>icmake</b> code statements.

       o      <u>#ifdef</u> <u>identifier</u>
              If the <u>identifier</u> macro was defined the next block of code  (until  a  matching  <u>#else</u>  or  <u>#endif</u>
              directive was read) is byte-compiled. Otherwise, the code block is ignored;

       o      <u>#ifndef</u> <u>identifier</u>
              If  the  <u>identifier</u> macro was <u>not</u> defined the next block of code (until a matching <u>#else</u> or <u>#endif</u>
              directive was detected) is byte-compiled. Otherwise, the code block is ignored;

       o      <u>#else</u>
              Terminates <u>#ifdef</u> and <u>#ifndef</u> code blocks, reversing the acceptance decision about  the  following
              code block. Only one <u>#else</u> directive can be associated with <u>#if(n)def</u> directives;

       o      <u>#endif</u>
              Terminates  the  code  block  starting  beyond  the  matching  <u>#ifdef</u>, <u>#ifndef</u> or <u>#else</u> directive.
              Associated <u>#if(n)def,</u> <u>#else</u>, and <u>#endif</u> directives must be specified in the same file;

       o      <u>#undef</u> <u>identifier</u>
              Remove <u>identifier</u> from the set of defined symbols. This does not affect the specification  of  any
              previously  defined  symbols  using  <u>identifier’s</u>  definition. If <u>identifier</u> hasn’t been defined a
              warning is issued.

</pre><h4><b>PREDEFINED</b> <b>CONSTANTS</b></h4><pre>
       The following predefined <u>int</u> constants are available (the functions listed in the <u>intended</u> <u>for</u> column are
       described in the upcoming sections covering the predefined functions):
       ─────────────────────────────────
       symbol      value   intended for
       ─────────────────────────────────
       O_ALL       8       makelist
       O_DIR       2       makelist
       O_FILE      1       makelist
       O_SUBDIR    4       makelist
       ─────────────────────────────────
       OFF         0       echo
       ON          1       echo
       ─────────────────────────────────
       P_CHECK     0       system calls
       P_NOCHECK   1       system calls
       ─────────────────────────────────
       S_IEXEC     32      stat
       S_IFCHR     1       stat
       S_IFDIR     2       stat
       S_IFREG     4       stat
       S_IREAD     8       stat
       S_IWRITE    16      stat
       ─────────────────────────────────

       The following constants are architecture dependent:
       ──────────────────────────────────────────────────────────────
       symbol           1 when defined on the platform, otherwise 0
       ──────────────────────────────────────────────────────────────
       unix             Unix, usually with GNU’s gcc compiler
       UNIX             may alternatively be available
       linux            x86 running Linux (usually with gcc)
       LINUX            may alternatively be available
       M_SYSV, M_UNIX   x86 running SCO/Unix
       _POSIX           _SOURCE   Unix with Posix compliant compiler
       __hpux           HP-UX, with the native HP compiler
       ──────────────────────────────────────────────────────────────

</pre><h4><b>OPERATORS</b></h4><pre>
       Since <b>icmake</b> version 10.00.00 the <u>&lt;&lt;</u> operator can be used  like  the  <b>C++</b>  insertion  operator.  See  the
       description of the functions <u>printf</u> and <u>fprintf</u> below.

              <b>int-operators:</b>

       All  <b>C</b>  operators (including the ternary operator) are available (except for pointer operators, as <b>icmake</b>
       does not support pointers). They operate like their  <b>C</b>-programming  language’s  counterparts.  Comparison
       operators return 1 if the comparison is true, otherwise 0 is returned.

              <b>string-operators:</b>

       For  <u>string</u>  variables  and/or  constants  the  following operators are available (<u>lhs</u> and <u>rhs</u> are <u>string</u>
       variables or constants):

       o      <u>lhs</u> <u>+</u> <u>rhs</u>: returns a new <u>string</u> value containing the concatenation of <u>strings</u> <u>lhs</u>  and  <u>rhs</u>.  Note
              that  <u>string</u>  constants  can  also  directly be concatetated (not using the <u>+</u> operator), e.g., the
              following two lines both define the string <u>"hello</u> <u>world"</u>:

                  "hello "   "world"
                  "hello " + "world"

       o      <u>lhs</u> <u>+=</u> <u>rhs</u>: <u>lhs</u> must be a <u>string</u> variable, to which the <u>string</u> variable or value <u>rhs</u> is appended;

       o      string comparisons: operators <u>==</u> <u>!=</u> <u>&lt;=</u> <u>&gt;=</u> <u>&lt;</u> <u>&gt;</u> <u>!=</u> and <u>==</u>  return  1  if  the  comparison  is  true,
              otherwise  0.  The  ordering operators (like <u>&lt;</u> and <u>&gt;=</u>) use the (case sensitive) character ordering
              defined by the <u>ASCII</u> character set;

       o      <u>!lhs</u>: the boolean <u>!</u> (not) operator returns 1 if the <u>string</u> <u>lhs</u> is empty, otherwise 0 is  returned.
              Strings merely containing white-space characters are not empty;

       o      <u>lhs</u>  <u>younger</u>  <u>rhs,</u>  <u>lhs</u>  <u>newer</u>  <u>rhs</u>:  returns  1  if  file <u>lhs</u> is more recent than file <u>rhs</u>. E.g.,
              <u>"source.cc"</u> <u>newer</u> <u>"source.o"</u>. The files <u>lhs</u> and <u>rhs</u> do not have to exist:

              o      if both don’t exist 0 is returned,

              o      if <u>lhs</u> doesn’t exist 0 is returned,

              o      if <u>rhs</u> doesn’t exist, 1 is returned,

              o      if they are equally old 0 is returned.

              The function <u>exists()</u> (see below, section <b>PREDEFINED</b> <b>FUNCTIONS</b>) can be used to test whether a file
              exists;

       o      <u>lhs</u> <u>older</u> <u>rhs</u>: returns 1 if file <u>lhs</u> is older than file <u>rhs</u>. E.g., <u>"libprog.a"</u>  <u>older</u>  <u>"source.o"</u>.
              The files <u>lhs</u> and <u>rhs</u> do not have to exist:

              o      if both don’t exist 0 is returned,

              o      if <u>lhs</u> doesn’t exist 1 is returned,

              o      if <u>rhs</u> doesn’t exist, 0 is returned,

              o      if they are equally old 0 is returned.

       o      <u>[]</u>:  the  index  operator  returns  a  character  from  a string variable or constant. A string is
              returned as an <u>rvalue</u>. Thus, the following statement compiles OK:

                  lhs = rhs[3];

              but the following statement won’t compile (as <u>lhs[3]</u> is an <u>rvalue</u>):

                  lhs[3] = "a";

              If an invalid (out of bounds) index value is specified an empty string is returned.

       o      The <u>backtick</u> operator (<u>`string</u> <u>cmd`</u>)
              A string placed between two backticks is executed as a separate command. Different from  the  <u>exec</u>
              and  <u>system</u>  calls  the backtick operator collects the standard output produced by `cmd’ returning
              this output as a list.

              The elements of the list contain the subsequent lines of output (including  a  final  newline,  if
              present)  produced  by `cmd’. A command that could be executed but that did not produce any output
              returns a list containing one string element, which is empty.

              An empty list indicates that the command could not be executed.

              The command’s standard error stream output is ignored by the backtick operator. However,  standard
              shell redirection may be used to collect the standard error stream’s output.

              Example:

                  printf &lt;&lt; `"ls"`;   // prints the elements in
                                      // the current directory

              Note  that  the backtick operator requires a string argument: either a string constant or a string
              variable.

              The function <u>eval(string</u> <u>cmd)</u> behaves exactly like the backtick operator: they are synonyms.

              <b>list-operators:</b>

       For <u>list</u> variables and/or values the following operators are available:

       o      <u>lhs</u> <u>+</u> <u>rhs</u>: returns a new <u>list</u> value containing the concatenation of the values of  <u>lists</u>  <u>lhs</u>  and
              <u>rhs</u>.  This  is  <u>not</u>  a set operation: if an element appears both in <u>lhs</u> and in <u>rhs</u>, then both will
              appear in the resulting list (set-addition is provided by the function <u>listunion</u>);

       o      <u>lhs</u> <u>-</u> <u>rhs</u>: returns a new <u>list</u> value containing the elements in <u>lhs</u> that are not  present  in  <u>rhs</u>.
              This is a set-difference operation. The ordering of the remaining elements in the returned list is
              equal to the ordering of those elements in <u>lhs</u>;

       o      <u>lhs</u> <u>+=</u> <u>rhs</u>: elements in <u>rhs</u> are added to the elements in <u>lhs</u>, which must be a <u>list</u> variable.  This
              is <u>not</u> a set operation;

       o      <u>lhs</u>  <u>-=</u>  <u>rhs</u>:  elements in <u>rhs</u> are removed from the elements in <u>lhs</u>.  This is a set operation: all
              elements of <u>lhs</u> that are found in <u>rhs</u> are removed from <u>lhs</u>. The ordering of the remaining elements
              in <u>lhs</u> is not altered;

       o      list equality comparisons: operators <u>!=</u> and <u>==</u>  may  be  applied  to  <u>list</u>  values  or  variables.
              Operator  <u>==</u>  returns  1  if both lists have element-by-element identical elements, otherwise 0 is
              returned. Operator <u>!=</u> reverses the result of <u>==</u>;

       o      <u>!lhs</u>: the boolean <u>!</u> operator returns 1 if the <u>list</u> <u>lhs</u> is empty, otherwise 0 is returned;

       o      <u>[]</u>: the index operator retrieves an element from a list  variable:  it  returns  a  string  as  an
              <u>rvalue</u>. Thus, the following statement compiles OK:

                  // assume lst is a list, str is a string
                  str = lst[3];

              but the following statement won’t compile (as <u>lst[3]</u> is an <u>rvalue</u>):

                  lst[3] = str;

              If an invalid (out of bounds) index value is specified an empty string is returned.

              <b>casting:</b>

       Type-casts using the standard <b>C</b>-style cast-operator can be used to cast:

       o      strings to ints and vice versa (<u>(int)"123",</u> <u>(string)55</u>)
              If the content of a string does not represent a (decimal) <u>int</u> value 0 the cast returns  0;

       o      Strings  to lists (<u>list</u> <u>lst</u> <u>=</u> <u>(list)"hello"</u>): this returns a list having one element (<u>hello</u>) (note
              that casting a string to a list as shown is overkill as <u>list</u> <u>lst</u> <u>=</u>  <u>["hello"]</u>  performs  the  same
              initialization).

</pre><h4><b>FLOW</b> <b>CONTROL</b></h4><pre>
       <b>Icmake</b> offers a subset of <b>C</b>’s flow control statements. They can be used as in the <b>C</b> programming language.

       o      <u>expression</u> <u>;</u>
              The plain expression statement.

              Insert-expression  statements  are  defined  for  the  functions  <u>fprintf</u>  and  <u>printf</u>. Expression
              statements may start with <u>printf</u> <u>&lt;&lt;</u> or <u>fprintf</u> <u>&lt;&lt;</u>  <u>filename</u>  <u>&lt;&lt;</u>.  The  values  of  all  subsequent
              expressions,  separated by <u>&lt;&lt;</u> operators (which in this context are called <u>insertion</u> <u>operators</u>) are
              written to the standard output stream (when using <u>printf</u>  <u>&lt;&lt;</u>),  or  to  the  file  whose  name  is
              provided in the <u>string</u> <u>filename</u> (when using <u>fprintf</u> <u>&lt;&lt;</u> <u>filename</u> <u>&lt;&lt;</u>).  Examples:

                  printf &lt;&lt; "hello" &lt;&lt; ’ ’ &lt;&lt; "world" &lt;&lt; ’\n’;
                  fprintf &lt;&lt; "out.txt" &lt;&lt; "hello" &lt;&lt; ’ ’ &lt;&lt; "world" &lt;&lt; ’\n’;

       o      The compound statement
              Variables  may be defined and initialized inside compound statements at locations where expression
              statements can also be used. The <u>visibility</u> of variables starts at their points of definition;

       o      <u>if</u> <u>([definition;]</u> <u>condition)</u> <u>statement</u>
              The <u>[definition;]</u> phrase is optional. If used it defines a type followed by a comma-separated list
              of variables which may be provided with initialization expressions.

              The condition phrase is required, and may define and initialize a variable. E.g,

                  if (string str = getText())
                      process(str);

              In this example, <u>process</u> is not called if <u>getText()</u> returns an empty string.

              Variables defined in the definition and condition phrases do not exist either before or after  the
              <u>if</u> statement.

       o      <u>if</u> <u>([definition;]</u> <u>condition)</u> <u>statement1</u> <u>else</u> <u>statement2</u>
              Acts  like  the  previous  statement.  If  the  condition  is  true <u>statement1</u> is executed; if the
              condition is false <u>statement2</u> is executed;

       o      <u>for</u> <u>(init;</u> <u>condition;</u> <u>increment)</u> <u>statement</u>
              Variables (of a single type) may be initialized (and optionally defined) in the <u>init</u> section.  The
              condition  phrase may define and initialize a variable. The <u>init</u>, <u>condition</u> and <u>increment</u> sections
              may remain empty. An empty condition section is interpreted as `always <u>true</u>’;

       o      <u>while</u> <u>(condition)</u> <u>statement</u>
              Inside the condition a variable may be defined and initialized.

              A complementary <u>do</u> <u>...</u> <u>while()</u> statement is not available. Note that when a  variable  is  defined
              and  initialized  in  the  condition  section  the  initialization  expression is executed at each
              iteration of the <u>while</u> statement. Thus the following statement never ends, and  displays  a  never
              ending stream of values 10:

                  while (int x = 10)
                      printf(x--, "\n");

       o      <u>return;</u>, and <u>return</u> <u>expression;</u>
              Plain  <u>return</u>  statements can be used in <u>void</u> functions, and <u>return</u> <u>expression</u> statements are used
              in other type of functions.

       o      <u>break</u>
              <u>break;</u> statements can only be used in <u>for</u> and <u>while</u> statements, ending those statements;

       o      <u>continue</u>
              <u>continue;</u> statements can only  be  used  in  <u>for</u>  and  <u>while</u>  statements,  continuing  their  next
              iteration.

</pre><h4><b>PREDEFINED</b> <b>FUNCTIONS</b></h4><pre>
       <b>Icmake</b>  provides the following predefined functions, which can be used anywhere in <b>icmake</b> scripts. In the
       following overview the functions are ordered by  categories,  and  within  categories  they  are  ordered
       alphabetically by function name.

       Five categories are distinguished:

       o      Functions operating on ints (see <u>INT</u> <u>FUNCTIONS</u> below):
              these functions receive <u>int</u> arguments, processing those arguments;

       o      Functions operating on strings (see <u>STRING</u> <u>FUNCTIONS</u> below):
              these functions operate on the strings which are passed to these functions as arguments;

       o      Functions operating on lists (see <u>LIST</u> <u>FUNCTIONS</u> below):
              these functions operate on the lists which are passed to these functions as arguments;

       o      Functions manipulating file system entries (see <u>FILESYSTEM</u> <u>FUNCTIONS</u> below):
              these  functions  receive  the  names  of  file-system entries (files, directories, etc.) as their
              <u>string</u> arguments.

              Note that these functions are not listed in the <u>STRING</u> <u>FUNCTIONS</u> section, as they do not  directly
              operate on their <u>string</u> arguments, but merely use those arguments to identify file system entries.

              On  the  other  hand,  functions  like  <u>change_base</u>  do not operate on file-system entries and are
              therefore entries in the <u>STRING</u> <u>FUNCTIONS</u> section;

       o      System-related functions (see <u>SYSTEM</u> <u>FUNCTIONS</u> below):
              these functions interface to facilities provided by the operating system, like executing  programs
              or  changing  the  script’s environment variables. Some of these functions use specialized support
              functions, which are also included in this section.

              <b>INT</b> <b>FUNCTIONS:</b>

       o      <u>string</u> <u>ascii(int</u> <u>value)</u>
              returns <u>value</u> as a string: <u><a href="../man65/ascii.65.html">ascii</a>(65)</u> returns the string <u>"A"</u>;

       o      <u>echo(int</u> <u>opt)</u>
              controls echoing of called  programs  (and  their  arguments),  specify  <u>OFF</u>  if  echoing  is  not
              requested. By default <u>echo(ON)</u> is active.

              <b>STRING</b> <b>FUNCTIONS:</b>

       o      <u>int</u> <u>ascii(string</u> <u>str)</u>
              returns the first character of <u>str</u> as an in: <u>ascii("A")</u> returns 65;

       o      <u>string</u> <u>change_base(string</u> <u>file,</u> <u>string</u> <u>base)</u>
              returns  <u>file</u>  whose  base  name is changed into <u>base</u>: <u>change_base("/path/demo.im",</u> <u>"out")</u> returns
              <u>"/path/out.im"</u>;

       o      <u>string</u> <u>change_ext(string</u> <u>file,</u> <u>string</u> <u>ext)</u>
              returns <u>file</u> whose extension is changed into <u>ext</u>: <u>change_ext("source.cc",</u> <u>"o")</u> returns <u>"source.o"</u>.
              The extension of the returned <u>string</u> is separated from the file’s base name by a single dot (e.g.,
              <u>change_ext("source.",</u> <u>".cc")</u> returns <u>"source.cc"</u>);

       o      <u>string</u> <u>change_path(string</u> <u>file,</u> <u>string</u> <u>path)</u>
              return <u>file</u> whose  path  is  changed  into  <u>path</u>:  <u>change_path("tmp/binary",</u>  <u>"<a href="file:/usr/bin">/usr/bin</a>")</u>  returns
              <u>"/usr/bin/binary"</u>. To remove the path specify <u>path</u> as an empty string;

       o      <u>string</u> <u>element(int</u> <u>index,</u> <u>string</u> <u>var)</u>
              acts identically to the index operator: refer to the index (<u>[]</u>) operator in section <b>OPERATORS</b>;

       o      <u>string</u> <u>get_base(string</u> <u>file)</u>
              returns  the  base name of <u>file</u>. The base name is the file without its path prefix and without its
              extension. The extension is all information starting at the final dot in the filename. If no final
              dot is found, the file name is the base name. E.g., the base name of <u>a.b</u> equals <u>a</u>, the  base  name
              of <u>a.b.c</u> equals <u>a.b</u>, the base name of <u>a/b/c</u> equals <u>c</u>;

       o      <u>string</u> <u>get_dext(string</u> <u>file)</u>
              returns  the  extension of <u>file</u>, including the separating dot (hence the <u>d</u> in <u>dext</u>). The extension
              is all information starting at the filename’s final dot. If <u>file</u> does not have a final dot then an
              empty string is returned;

       o      <u>string</u> <u>get_ext(string</u> <u>file)</u>
              returns the extension of <u>file</u>, without the separating dot. The extension  are  all  characters  in
              <u>file</u> starting at <u>file’s</u> final dot. If no final dot is found, an empty string is returned;

       o      <u>string</u> <u>get_path(string</u> <u>file)</u>
              returns  <u>file’s</u>  path-prefix.  The  path prefix is all information up to (and including) the final
              directory separator (which is, depending on the operating system, a forward slash or a backslash).
              If <u>file</u> does not contain a path-element, then an empty string is returned;

       o      <u>string</u> <u>resize(string</u> <u>str,</u> <u>int</u> <u>newlength)</u> returns a  copy  of  string  <u>str</u>,  resized  to  <u>newlength</u>
              characters.  If <u>newlength</u> is negative then an empty string is returned, if <u>newlength</u> exceeds <u>str’s</u>
              length then the newly added characters are initialized to blank spaces;

       o      <u>int</u> <u>strchr(string</u> <u>str,</u> <u>string</u> <u>chars)</u>
              returns  the  first  index in <u>str</u> where any of the characters in <u>chars</u> is found, or -1 if <u>str</u> does
              not contain any of the characters in <u>chars</u>;

       o      <u>int</u> <u>strfind(string</u> <u>haystack,</u> <u>string</u> <u>needle)</u>
              returns index in <u>haystack</u> where <u>needle</u> is found, or -1 if <u>needle</u> is not found in <u>haystack</u>;

       o      <u>string</u> <u>strformat(string</u> <u>format,</u> <u>argument(s))</u>
              returns a string constructed from the <u>format</u> string containing placeholders %1 .. %2 to  refer  to
              arguments following the format string. The specification %1 refers to the first argument following
              the format string. If fewer arguments than <u>n</u> are provided then additional 0 arguments are provided
              by <b>icmake</b>. Example:

                  void main()
                  {
                      string s2 = = strformat("%1 %2 %1\n", 10, 20);
                      printf("s2 = ", s2);        // shows: s2 = 10 20 10
                  }

       o      <u>int</u> <u>strlen(string</u> <u>str)</u>
              returns the number of characters in <u>str</u> (not counting the terminating NUL-character);

       o      <u>string</u> <u>strlwr(string</u> <u>str)</u>
              returns a lower-case duplicate of <u>str</u>;

       o      <u>list</u> <u>strtok(string</u> <u>str,</u> <u>string</u> <u>separators)</u>
              returns  a list containing all substrings of <u>str</u> separated by one or more (consecutive) characters
              in <u>separators</u>: <u>strtok("hello</u> <u>icmake’s+world",</u> <u>"</u> <u>+")</u> returns a list containing  the  three  strings
              <u>"hello"</u>, <u>"icmake’s"</u>, and <u>"world"</u>;

       o      <u>string</u> <u>strupr(string</u> <u>str)</u>
              returns an upper-case duplicate of <u>str</u>.

       o      <u>string</u> <u>substr(string</u> <u>text,</u> <u>int</u> <u>offset,</u> <u>int</u> <u>count)</u>
              returns a substring of <u>text</u>, starting at <u>offset</u>, consisting of <u>count</u> characters. If <u>offset</u> exceeds
              (or  equals)  the string’s length or if <u>count</u> <u>&lt;=</u> <u>0</u>, then an empty string is returned. If <u>offset</u> is
              less than 0 then <u>offset</u> <u>=</u> <u>0</u> is used. If <u>offset</u> <u>+</u> <u>count</u> exceeds <u>text’s</u> length  then  the  available
              substring starting at <u>text[offset]</u> is returned (which may be empty);

       o      <u>string</u> <u>trim(string</u> <u>str)</u>
              returns a copy of <u>str</u> without leading and trailing white spaces;

       o      <u>string</u> <u>trimleft(string</u> <u>str)</u>
              returns a copy of <u>str</u> without leading white spaces;

       o      <u>string</u> <u>trimright(string</u> <u>str)</u>
              Returns a copy of <u>str</u> without trailing white spaces.

              <b>LIST</b> <b>FUNCTIONS:</b>

       o      <u>string</u> <u>element(int</u> <u>index,</u> <u>list</u> <u>var)</u>
              acts identically to the index operator: refer to the index (<u>[]</u>) operator in section <b>OPERATORS</b>;

       o      <u>int</u> <u>listfind(list</u> <u>lst,</u> <u>string</u> <u>str)</u>
              returns  the  smallest  index  in <u>lst</u> where the string <u>str</u> is found, or -1 if <u>lst</u> does not contain
              <u>str</u>;

       o      <u>int</u> <u>listlen(list</u> <u>l)</u>
              returns the number of elements in <u>list</u>;

       o      <u>list</u> <u>listunion(list</u> <u>lhs,</u> <u>list</u> <u>rhs)</u>
              returns a list containing the union of the elements in <u>lhs</u> and the elements of <u>rhs</u>.  The  original
              order of the elements in <u>lhs</u> is kept. Subsequent elements in <u>rhs</u> that are not available in <u>lhs</u> are
              added to the end of <u>lhs</u>;

       o      <u>list</u> <u>listunion(list</u> <u>lst,</u> <u>string</u> <u>str)</u>
              returns  a  list  containing  the  union of the elements in <u>lst</u> and <u>str</u>. The original order of the
              elements in <u>lhs</u> is kept. If <u>rhs</u> is not available in <u>lhs</u> then it is added to the end of <u>lhs</u>.

              <b>FILESYSTEM</b> <b>FUNCTIONS:</b>

       o      <u>string</u> <u>chdir([int</u> <u>check,]</u> <u>string</u> <u>dir)</u>
              changes the script’s working directory to <u>dir</u> (which may be specified as absolute or  relative  to
              the  script’s  current working directory). The first argument is optional: if omitted and changing
              the working directory fails then the <b>icmake</b>-script ends with exit value 1; by specifying <u>P_NOCHECK</u>
              the function won’t terminate the script but merely returns the script’s current working directory.
              The script’s working directory after completing the change-dir request is returned as an  absolute
              path, ending in a `/’ directory separator.

              Use  <u>chdir(".")</u> to merely obtain the current working directory; use <u>chdir("")</u> to change-dir to the
              script’s startup working directory;

       o      <u>int</u> <u>exists(string</u> <u>file)</u>
              if <u>file</u> exists, 1 is returned, otherwise 0 is returned;

       o      <u>list</u> <u>fgets(string</u> <u>file,</u> <u>list</u> <u>offset)</u>
              the next line found at offset value <u>offset[3]</u> is read from <u>file</u>. Pass an empty list  to  <u>fgets</u>  to
              read <u>file</u> from its beginning.

              The returned list has four elements:

              o      its first element ([0]) contains the read line (without the line’s <u>\n</u> line terminator);

              o      its  second element ([1]) contains the line’s <u>\n</u> line terminator (or an empty string if the
                     line was not terminated by a <u>\n</u>);

              o      its third element ([2]) contains the string <u>OK</u> if the line was successfully read  and  <u>FAIL</u>
                     if reading from file failed;

              o      its fourth element ([3]) contains the offset beyond the last read byte.

              To read multiple lines, pass the returned list as argument to <u>fgets</u>:

                  list ret;
                  while (ret = fgets("filename", ret))
                      process(ret);

              Be careful not to define <u>list</u> <u>ret</u> in <u>while’s</u> condition, as this will reset <u>ret</u> to an empty list at
              each iteration;

       o      <u>int</u> <u>fprintf(string</u> <u>filename,</u> <u>argument(s))</u>
              appends  all  (comma or left-shift (insertion) operator separated) arguments to the file <u>filename</u>.
              Returns the number of printed arguments.

              If the first argument (following <u>filename</u>) contains  placeholders  (<u>%1,</u>  <u>%2,</u>  <u>...</u>  <u>%n</u>)  then  that
              argument  is  considered  a format string (see also the function <u>strformat</u> in the string functions
              section for additional information about format strings). Some examples:

                  fprintf("out", "hello", "world", ’\n’);
                  fprintf &lt;&lt; "out" &lt;&lt; "hello" &lt;&lt; "world" &lt;&lt; ’\n’;

                  fprintf("out", "%1 %2\n", "hello", "world");           // 1
                  fprintf &lt;&lt; "out" &lt;&lt; "hello" &lt;&lt; ’ ’ &lt;&lt; "world" &lt;&lt; ’\n’; // 2
                  fprintf &lt;&lt; "out" &lt;&lt; "%1 %2\n" &lt;&lt; "hello" &lt;&lt; "world";   // 3

              When writing statement 1 using insertion operators (cf. the expression  statement  description  in
              section  <u>FLOW</u> <u>CONTROL</u>)  statement 2 would normally be encountered, although statement 3, using the
              format string, would still be accepted;

       o      <u>string</u> <u>getch()</u>
              returns the next pressed key as a string (pressing the `Enter’-key is not required).  The  pressed
              key is not echoed. If the key should be echoed use, e.g., <u>printf(getch())</u>;

       o      <u>string</u> <u>gets()</u>
              returns the next line read from the keyboard as a <u>string</u>. The line contains all entered characters
              until  the  `Enter’-key  was pressed. The `Enter’-key’s value itself is not stored in the returned
              string;

       o      <u>list</u> <u>makelist([int</u> <u>type</u> <u>=</u> <u>O_FILE],</u> <u>string</u> <u>mask)</u>
              the argument <u>type</u> is optional, in which case <u>O_FILE</u> is used.  <u>Makelist</u> returns a list of all  <u>type</u>
              file-system  entries  matching  <u>mask</u>.  E.g.,  <u>makelist("*.c")</u>  returns a list containing all files
              ending in <u>.c</u>. For <u>type</u> one of the following set of values can be used to obtain  a  more  specific
              selection of directory entries:
              symbol     meaning
              O_ALL      obtain all directory entries
              O_DIR      obtain all directories, including . and ..
              O_FILE     obtain a list of regular files
              O_SUBDIR   obtain all directories except for . and ..

              In  Unix-type  operating  systems the pattern <u>*</u> does not match entries starting with a dot (hidden
              entries). To obtain a list of such entries use the pattern <u>.*</u>;

       o      <u>list</u> <u>makelist([int</u> <u>type</u> <u>=</u> <u>O_FILE,]</u> <u>string</u> <u>mask,</u> <u>{newer,older,younger},</u> <u>string</u> <u>comparefile)</u>
              the (optional) parameter <u>type</u> may be specified as in the previous variant of <u>makelist</u>.  The  third
              parameter  must  be either <u>newer</u> (or <u>younger</u>) or <u>older</u>. A list of all file-system entries matching
              mask which are, resp., newer or older than a provided <u>comparefile</u> is returned. Note that <u>newer</u> and
              <u>younger</u> are operators, not strings;

       o      <u>int</u> <u>printf(argument(s))</u>
              the function’s (comma or left-shift (insertion) operator separated) arguments are written  to  the
              standard  output  file (cf.  the expression statement description in section <u>FLOW</u> <u>CONTROL</u> and this
              section’s description of the <u>fprintf</u> function). If the first argument  contains  <u>%1,</u>  <u>%2,</u>  <u>...</u>  <u>%n</u>
              specifications then it’s considered a format string (see also the function <u>strformat</u> in the <u>STRING</u>
              <u>FUNCTIONS</u>  section  for  additional information about format strings). Like <u>fprintf</u> <u>printf</u> returns
              the number of printed arguments;

       o      <u>list</u> <u>stat([int</u> <u>check,]</u> <u>string</u> <u>entry)</u>
              Returns <b><a href="../man2/stat.2.html">stat</a></b>(2) information of directory entry <u>entry</u> as a list. The first argument is optional: if
              omitted and calling the system <u>stat</u> function fails then the <b>icmake</b>-script ends with exit value  1;
              by  specifying <u>P_NOCHECK</u> the function won’t terminate the script but returns the return value (-1)
              of the system <u>stat</u> function.

              The returned list has two elements:

              its first element ([0]) holds the entry’s attributes.  Attributes are returned as  the  file  type
              and mode of the specified file (cf. <b><a href="../man2/stat.2.html">stat</a></b>(2) and <b><a href="../man7/inode.7.html">inode</a></b>(7)). E.g.,

                  S_IRUSR  - owner has read permission
                  S_IWUSR  - owner has write permission
                  S_IXUSR  - owner has execute permission

                  S_IFSOCK - socket
                  S_IFLNK  - symbolic link
                  S_IFREG  - regular file
                  S_IFBLK  - block device
                  S_IFDIR  - directory
                  S_IFCHR  - character device
                  S_IFIFO  - FIFO

              its  second  element  ([1])  contains  the  entry’s  size in bytes. If <u>P_NOCHECK</u> was specified and
              ’entry’ doesn’t exists then a list having one element is returned containing -1.

              <b>SYSTEM</b> <b>FUNCTIONS:</b>

       o      <u>void</u> <u>arghead(string</u> <u>str)</u>
              support function of <u>exec()</u> (see also below at <u>exec()</u>): defines the `argument head’  that  is  used
              with <u>exec()</u>. By default, the `argument head’ is an empty string. The argument head is text that is
              prefixed to all <u>exec</u> arguments, like a directory in which provided arguments are found;

       o      <u>void</u> <u>argtail</u> <u>(string</u> <u>str)</u>
              support  function  of  <u>exec()</u> (see also below at <u>exec()</u>): defines the `argument tail’ that is used
              with <u>exec()</u>. By default, the `argument tail’ is an empty string. The argument tail is text that is
              appended to all <u>exec</u> arguments, like the extensions of files that are passed as arguments to <u>exec</u>;

       o      <u>cmdhead(string</u> <u>str)</u>
              support function of <u>exec()</u> (see also below at <u>exec()</u>).  Defines a `command head’ that is used with
              <u>exec()</u>. By default it is an empty string. It can be used to specify, e.g., compiler  options  when
              the  arguments themselves are modified by <u>arghead</u> and <u>argtail</u>.  The <u>cmdhead</u> argument itself is not
              modified by <u>arghead</u> or <u>argtail</u>;

       o      <u>cmdtail(string</u> <u>str)</u>
              support function of <u>exec()</u> (see also below at <u>exec()</u>).  Defines a `command tail that is used  with
              <u>exec()</u>. By default it is an empty string. It can be used to specify a final argument (not modified
              by <u>arghead</u> and <u>argtail</u>);

       o      <u>list</u> <u>eval(string</u> <u>str)</u>
              this  function  can  be used instead of the backtick operator (cf. section <u>OPERATORS</u>). The example
              provided with the backtick operator could therefore also have been written like this:

                  printf &lt;&lt; eval("ls");   // prints the elements in the current
                                          // directory

              As mentioned at the backtick operator: the elements of the list contain the  subsequent  lines  of
              output (including a final newline, if present) produced by `cmd’. A command that could be executed
              but that did not produce any output returns a list containing one string element, which is empty.

              An empty list indicates that the command could not be executed.

       o      <u>int</u> <u>exec([int</u> <u>check,]</u> <u>string</u> <u>cmd,</u> <u>argument(s))</u>
              Executes  the  command  <u>cmd</u>  with  (optional)  arguments. Each argument is prefixed by <u>arghead</u> and
              postfixed by <u>argtail</u>. Note that no blanks are inserted between <u>arghead</u>, argument(s), and  <u>argtail</u>.
              The  thus  modified  arguments  are  concatenated, separated by single blanks. <u>Cmdhead</u> is inserted
              between <u>cmd</u> and the first argument (delimited by single blanks) and <u>cmdtail</u>  is  appended  to  the
              arguments, separated by a single blank. <u>PATH</u> is searched to locate <u>cmd</u>. 0 is returned.

              The  first  argument  is  optional: if omitted and the command does not return 0 the <b>icmake</b> script
              terminates. By specifying <u>P_NOCHECK</u> <u>exec</u>  won’t  terminate  the  script  but  returns  the  called
              command’s exit status, or <u>0x7f00</u> if the command wasn’t found.

              The remaining arguments may be ints, strings or lists. Int and list arguments are cast to strings.
              Their string representations are then appended to <u>cmd</u>;

       o      <u>int</u>  <u>execute([int</u>  <u>checking,]</u>  <u>string</u>  <u>cmd,</u>  <u>string</u>  <u>cmdhead,</u>  <u>string</u> <u>arghead,</u> <u>argument(s),</u> <u>string</u>
              <u>argtail,</u> <u>string</u> <u>cmdtail)</u>
              Same functionality as the previous function, but the <u>cmdhead,</u> <u>arghead,</u> <u>argtail,</u>  and  <u>cmdtail</u>  are
              explicitly specified (and are reset to empty strings after executing <u>cmd</u>);

       o      <u>exit(expression)</u>
              Ends  the  execution  of  an <b>icmake</b>-script. The <u>expression</u> must evaluate to an <u>int</u> value, which is
              used as the script’s exit value;

       o      <u>list</u> <u>getenv(string</u> <u>envvar)</u>
              returns the value of environment variable <u>envvar</u> in a list containing two elements:

              if the first element ([0]) is <u>"1"</u> then the environment variable was defined;

              environment variables are of the form <u>variable=value</u>.  If element <u>[0]</u> is  <u>"1"</u>  then  the  returned
              list’s  second element [1] holds the <u>value</u> part of the environment variable, which is empty if the
              environment variable is merely defined;

       o      <u>int</u> <u>getpid()</u>
              returns the process-id of the icmake byte code interpreter <b>icm-exec</b>;

       o      <u>int</u> <u>putenv(string</u> <u>envvar)</u>
              adds or modifies <u>envvar</u> to the current <b>icmake</b>-script environment. Use the format: <u>"VAR=value"</u>. Use
              <u>"VAR"</u> to remove <u>"VAR"</u> from the environment. The function returns 0  unless  <u>envvar</u>  is  empty,  in
              which case 1 is returned;

       o      <u>int</u> <u>system([int</u> <u>check,]</u> <u>string</u> <u>command)</u>
              executes  <u>command</u>  using  the  <b><a href="../man3/system.3.html">system</a></b>(3)  function. The first argument is optional: if omitted and
              calling the <b><a href="../man3/system.3.html">system</a></b>(3) function does not return 0 then the <b>icmake</b>-script ends with exit value 1; by
              specifying <u>P_NOCHECK</u> <b>icmake</b>’s <u>system</u> function won’t terminate the script but  returns  the  return
              value  of  the <b><a href="../man3/system.3.html">system</a></b>(3) function (normally the executed command’s exit value). The string <u>command</u>
              may use redirection and/or piping.

</pre><h4><b>USER</b> <b>DEFINED</b> <b>FUNCTIONS</b></h4><pre>
       In addition to <u>main</u> additional functions can be defined.  Once  defined,  they  can  be  called.  Forward
       referencing  of  either variables or functions is not supported, but calling functions recursively is. As
       function declarations are not supported indirect recursion cannot be used.

       Function overloading (based on differently typed parameters) is supported.

       User-defined functions must have the following elements:

       o      The function’s return type, which must be <u>void,</u> <u>int,</u> <u>string</u> or <u>list</u>. There is no default type;

       o      The function’s name, e.g., <u>compile</u>;

       o      A parameter list, defining zero or more  comma-separated  parameters.  The  parameters  themselves
              consist  of  a  type  name  (<u>int,</u>  <u>string</u>,  or <u>list</u>) followed by the parameter’s identifier. E.g.,
              <u>(string</u> <u>outfile,</u> <u>string</u> <u>source)</u>;

       o      A <u>body</u> surrounded by a pair of curly braces (<u>{</u> and <u>}</u>).

       Function bodies may contain variable definitions (optionally initialized at their definitions).  Variable
       definitions  start  with  a type name, followed by one or more comma separated and optionally initialized
       variable identifiers.

       If a variable is not explicitly initialized it is initialized by default: <u>int</u> variables  are  initialized
       to  0, <u>string</u> variables are initialized to empty strings (<u>""</u>) and <u>list</u> variables are initialized to empty
       lists.

       Function bodies may also contain zero or more statements (cf. section <b>FLOW</b> <b>CONTROL</b>). Note that  variables
       may  be defined (and optionally initialized) anywhere inside functions where expression statements can be
       used, and also in the condition sections of <u>if,</u> <u>for,</u> and  <u>while</u>  statements  and  in  the  initialization
       sections of <u>if</u> andd <u>for</u> statements.

</pre><h4><b>EXAMPLE</b></h4><pre>
       In  the  following example all <b>C++</b> source files in the current directory are compiled unless their object
       files are more recent. The main function creates a list of source files and then passes each of them to a
       function <u>inspect</u>. That function inspects whether the source file is younger than its object file, and  if
       so  it  calls  <u>compile</u>.  The  function <u>compile</u> uses <u>exec</u> to call the compiler. If a compilation fails the
       script stops so the error can be repaired.
           void compile(string src)
           {
               exec("g++ -c " + src);      // compile ’src’
           }

           void inspect(string src)
           {                               // get the obj-file’s name:
                                           // only compile if necessary
               if (src younger change_ext(src, ".o"))
                   compile(src);
           }

           int main()
           {                               // find all .cc source files
               list sources = makelist("*.cc");

               for (                       // visit all source files
                   int idx = 0, end = listlen(sources);
                       idx != end;
                           ++idx
               )
                   inspect(sources[idx]);  // compile if needed
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/icmake.1.html">icmake</a></b>(1), <b><a href="../man1/icmbuild.1.html">icmbuild</a></b>(1), <b><a href="../man7/icmconf.7.html">icmconf</a></b>(7), <b><a href="../man1/icmstart.1.html">icmstart</a></b>(1), <b><a href="../man7/icmstart.rc.7.html">icmstart.rc</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       Standard comment starting  on lines containing preprocessor  directives  may  not  extend  over  multiple
       lines.

       Path names containing blanks are not supported.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

icmake.13.02.00                                     1992-2025                                       <u><a href="../man7/icmscript.7.html">icmscript</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>