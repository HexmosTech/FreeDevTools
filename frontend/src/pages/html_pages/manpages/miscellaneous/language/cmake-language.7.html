<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cmake-language - CMake Language Reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cmake-data">cmake-data_3.31.6-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cmake-language - CMake Language Reference

</pre><h4><b>ORGANIZATION</b></h4><pre>
       CMake input files are written in the "CMake Language" in source files named <b>CMakeLists.txt</b> or ending in a
       <b>.cmake</b> file name extension.

       CMake Language source files in a project are organized into:

       • <u>Directories</u> (<b>CMakeLists.txt</b>),

       • <u>Scripts</u> (<b>&lt;script&gt;.cmake</b>), and

       • <u>Modules</u> (<b>&lt;module&gt;.cmake</b>).

   <b>Directories</b>
       When CMake processes a project source tree, the entry point is a source file called <b>CMakeLists.txt</b> in the
       top-level  source  directory.   This  file  may  contain  the  entire  build  specification  or  use  the
       <u>add_subdirectory()</u> command to add subdirectories to the build.  Each subdirectory added  by  the  command
       must  also contain a <b>CMakeLists.txt</b> file as the entry point to that directory.  For each source directory
       whose <b>CMakeLists.txt</b> file is processed CMake generates a corresponding directory in the build tree to act
       as the default working and output directory.

   <b>Scripts</b>
       An individual <b>&lt;script&gt;.cmake</b> source  file  may  be  processed  in  <u>script</u>  <u>mode</u>  by  using  the  <u><a href="../man1/cmake.1.html">cmake</a>(1)</u>
       command-line  tool  with the <u>-P</u> option.  Script mode simply runs the commands in the given CMake Language
       source file and does not generate a build system.  It does not allow CMake  commands  that  define  build
       targets or actions.

   <b>Modules</b>
       CMake  Language  code  in  either  <u>Directories</u>  or  <u>Scripts</u>  may  use  the  <u>include()</u>  command  to load a
       <b>&lt;module&gt;.cmake</b> source file in the scope of the including context.  See the <u><a href="../man7/cmake-modules.7.html">cmake-modules</a>(7)</u>  manual  page
       for documentation of modules included with the CMake distribution.  Project source trees may also provide
       their own modules and specify their location(s) in the <u>CMAKE_MODULE_PATH</u> variable.

</pre><h4><b>SYNTAX</b></h4><pre>
   <b>Encoding</b>
       A  CMake  Language  source  file  may  be  written in 7-bit ASCII text for maximum portability across all
       supported platforms.  Newlines may be encoded as either <b>\n</b> or <b>\r\n</b> but will be converted to <b>\n</b>  as  input
       files are read.

       Note  that  the  implementation  is 8-bit clean so source files may be encoded as UTF-8 on platforms with
       system APIs supporting this encoding.  In addition, CMake 3.2 and above support source files  encoded  in
       UTF-8  on  Windows  (using UTF-16 to call system APIs).  Furthermore, CMake 3.0 and above allow a leading
       UTF-8 <u>Byte-Order</u> <u>Mark</u> in source files.

   <b>Source</b> <b>Files</b>
       A CMake Language source file consists of zero or more  <u>Command</u>  <u>Invocations</u>  separated  by  newlines  and
       optionally spaces and <u>Comments</u>:

       <b>file</b>         ::= <u>file_element</u>*
       <b>file_element</b> ::= <u>command_invocation</u> <u>line_ending</u> |
                        (<u>bracket_comment</u>|<u>space</u>)* <u>line_ending</u>
       <b>line_ending</b>  ::= <u>line_comment</u>? <u>newline</u>
       <b>space</b>        ::= &lt;match '[ \t]+'&gt;
       <b>newline</b>      ::= &lt;match '\n'&gt;

       Note  that  any  source  file  line  not  inside <u>Command</u> <u>Arguments</u> or a <u>Bracket</u> <u>Comment</u> can end in a <u>Line</u>
       <u>Comment</u>.

   <b>Command</b> <b>Invocations</b>
       A <u>command</u> <u>invocation</u> is a name followed by paren-enclosed arguments separated by whitespace:

       <b>command_invocation</b>  ::= <u>space</u>* <u>identifier</u> <u>space</u>* '(' <u>arguments</u> ')'
       <b>identifier</b>          ::= &lt;match '[A-Za-z_][A-Za-z0-9_]*'&gt;
       <b>arguments</b>           ::= <u>argument</u>? <u>separated_arguments</u>*
       <b>separated_arguments</b> ::= <u>separation</u>+ <u>argument</u>? |
                               <u>separation</u>* '(' <u>arguments</u> ')'
       <b>separation</b>          ::= <u>space</u> | <u>line_ending</u>

       For example:

          add_executable(hello world.c)

       Command names are case-insensitive.  Nested unquoted parentheses in the arguments must balance.   Each  <b>(</b>
       or <b>)</b> is given to the command invocation as a literal <u>Unquoted</u> <u>Argument</u>.  This may be used in calls to the
       <u>if()</u> command to enclose conditions.  For example:

          if(FALSE AND (FALSE OR TRUE)) # evaluates to FALSE

       <b>NOTE:</b>
          CMake versions prior to 3.0 require command name identifiers to be at least 2 characters.

          CMake  versions  prior to 2.8.12 silently accept an <u>Unquoted</u> <u>Argument</u> or a <u>Quoted</u> <u>Argument</u> immediately
          following a <u>Quoted</u> <u>Argument</u> and not separated by any whitespace.  For compatibility, CMake 2.8.12  and
          higher accept such code but produce a warning.

   <b>Command</b> <b>Arguments</b>
       There are three types of arguments within <u>Command</u> <u>Invocations</u>:

       <b>argument</b> ::= <u>bracket_argument</u> | <u>quoted_argument</u> | <u>unquoted_argument</u>

   <b>Bracket</b> <b>Argument</b>
       A  <u>bracket</u>  <u>argument</u>,  inspired  by <u>Lua</u> long bracket syntax, encloses content between opening and closing
       "brackets" of the same length:

       <b>bracket_argument</b> ::= <u>bracket_open</u> <u>bracket_content</u> <u>bracket_close</u>
       <b>bracket_open</b>     ::= '[' '='* '['
       <b>bracket_content</b>  ::= &lt;any text not containing a <u>bracket_close</u> with
                            the same number of '=' as the <u>bracket_open</u>&gt;
       <b>bracket_close</b>    ::= ']' '='* ']'

       An opening bracket is written <b>[</b> followed by zero or more <b>=</b> followed  by  <b>[</b>.   The  corresponding  closing
       bracket  is  written  <b>]</b>  followed by the same number of <b>=</b> followed by <b>]</b>.  Brackets do not nest.  A unique
       length may always be chosen for the opening and closing brackets to contain  closing  brackets  of  other
       lengths.

       Bracket  argument  content consists of all text between the opening and closing brackets, except that one
       newline immediately following the opening bracket, if any, is ignored.  No  evaluation  of  the  enclosed
       content,  such  as  <u>Escape</u>  <u>Sequences</u> or <u>Variable</u> <u>References</u>, is performed.  A bracket argument is always
       given to the command invocation as exactly one argument.

       For example:

          message([=[
          This is the first line in a bracket argument with bracket length 1.
          No \-escape sequences or ${variable} references are evaluated.
          This is always one argument even though it contains a ; character.
          The text does not end on a closing bracket of length 0 like ]].
          It does end in a closing bracket of length 1.
          ]=])

       <b>NOTE:</b>
          CMake versions prior to 3.0 do not support bracket arguments.  They interpret the opening  bracket  as
          the start of an <u>Unquoted</u> <u>Argument</u>.

   <b>Quoted</b> <b>Argument</b>
       A <u>quoted</u> <u>argument</u> encloses content between opening and closing double-quote characters:

       <b>quoted_argument</b>     ::= '"' <u>quoted_element</u>* '"'
       <b>quoted_element</b>      ::= &lt;any character except '\' or '"'&gt; |
                               <u>escape_sequence</u> |
                               <u>quoted_continuation</u>
       <b>quoted_continuation</b> ::= '\' <u>newline</u>

       Quoted  argument  content consists of all text between opening and closing quotes.  Both <u>Escape</u> <u>Sequences</u>
       and <u>Variable</u> <u>References</u> are evaluated.  A quoted argument is always given to the  command  invocation  as
       exactly one argument.

       For example:

          message("This is a quoted argument containing multiple lines.
          This is always one argument even though it contains a ; character.
          Both \\-escape sequences and ${variable} references are evaluated.
          The text does not end on an escaped double-quote like \".
          It does end in an unescaped double quote.
          ")

       The  final  <b>\</b>  on  any  line ending in an odd number of backslashes is treated as a line continuation and
       ignored along with the immediately following newline character.  For example:

          message("\
          This is the first line of a quoted argument. \
          In fact it is the only line but since it is long \
          the source code uses line continuation.\
          ")

       <b>NOTE:</b>
          CMake versions prior to 3.0 do not  support  continuation  with  <b>\</b>.   They  report  errors  in  quoted
          arguments containing lines ending in an odd number of <b>\</b> characters.

   <b>Unquoted</b> <b>Argument</b>
       An  <u>unquoted</u> <u>argument</u> is not enclosed by any quoting syntax.  It may not contain any whitespace, <b>(</b>, <b>)</b>, <b>#</b>,
       <b>"</b>, or <b>\</b> except when escaped by a backslash:

       <b>unquoted_argument</b> ::= <u>unquoted_element</u>+ | <u>unquoted_legacy</u>
       <b>unquoted_element</b>  ::= &lt;any character except whitespace or one of '()#"\'&gt; |
                             <u>escape_sequence</u>
       <b>unquoted_legacy</b>   ::= &lt;see note in text&gt;

       Unquoted argument content consists of all text in a contiguous block of allowed  or  escaped  characters.
       Both  <u>Escape</u> <u>Sequences</u> and <u>Variable</u> <u>References</u> are evaluated.  The resulting value is divided in the same
       way <u>Lists</u> divide into elements.  Each non-empty  element  is  given  to  the  command  invocation  as  an
       argument.  Therefore an unquoted argument may be given to a command invocation as zero or more arguments.

       For example:

          foreach(arg
              NoSpace
              Escaped\ Space
              This;Divides;Into;Five;Arguments
              Escaped\;Semicolon
              )
            message("${arg}")
          endforeach()

       <b>NOTE:</b>
          To  support  legacy  CMake  code,  unquoted  arguments  may also contain double-quoted strings (<b>"..."</b>,
          possibly enclosing horizontal whitespace), and make-style variable references (<b>$(MAKEVAR)</b>).

          Unescaped double-quotes must balance, may not appear at the beginning of an unquoted argument, and are
          treated as part of the content.  For example, the unquoted  arguments  <b>-Da="b</b>  <b>c"</b>,  <b>-Da=$(v)</b>,  and  <b>a"</b>
          <b>"b"c"d</b> are each interpreted literally.  They may instead be written as quoted arguments <b>"-Da=\"b</b> <b>c\""</b>,
          <b>"-Da=$(v)"</b>, and <b>"a\"</b> <b>\"b\"c\"d"</b>, respectively.

          Make-style  references  are  treated  literally  as  part  of  the content and do not undergo variable
          expansion.  They are treated as part of a single argument (rather than as separate <b>$</b>, <b>(</b>, <b>MAKEVAR</b>,  and
          <b>)</b> arguments).

          The  above  "unquoted_legacy"  production represents such arguments.  We do not recommend using legacy
          unquoted arguments in new code.  Instead use a <u>Quoted</u> <u>Argument</u> or a <u>Bracket</u> <u>Argument</u> to represent  the
          content.

   <b>Escape</b> <b>Sequences</b>
       An <u>escape</u> <u>sequence</u> is a <b>\</b> followed by one character:

       <b>escape_sequence</b>  ::= <u>escape_identity</u> | <u>escape_encoded</u> | <u>escape_semicolon</u>
       <b>escape_identity</b>  ::= '\' &lt;match '[^A-Za-z0-9;]'&gt;
       <b>escape_encoded</b>   ::= '\t' | '\r' | '\n'
       <b>escape_semicolon</b> ::= '\;'

       A <b>\</b> followed by a non-alphanumeric character simply encodes the literal character without interpreting it
       as  syntax.   A  <b>\t</b>,  <b>\r</b>,  or <b>\n</b> encodes a tab, carriage return, or newline character, respectively. A <b>\;</b>
       outside of any <u>Variable</u> <u>References</u>  encodes itself but may be used in an <u>Unquoted</u> <u>Argument</u> to encode  the
       <b>;</b>  without  dividing  the  argument  value  on it.  A <b>\;</b> inside <u>Variable</u> <u>References</u> encodes the literal <b>;</b>
       character.  (See also policy <u>CMP0053</u> documentation for historical considerations.)

   <b>Variable</b> <b>References</b>
       A <u>variable</u> <u>reference</u> has the form <b>${&lt;variable&gt;}</b> and is evaluated inside a <u>Quoted</u> <u>Argument</u> or an  <u>Unquoted</u>
       <u>Argument</u>.   A variable reference is replaced by the value of the specified variable or cache entry, or if
       neither is set, by the empty string.  Variable references can nest and are evaluated from the inside out,
       e.g. <b>${outer_${inner_variable}_variable}</b>.

       Literal variable references may consist of alphanumeric characters,  the  characters  <b>/_.+-</b>,  and  <u>Escape</u>
       <u>Sequences</u>.   Nested  references  may  be used to evaluate variables of any name.  See also policy <u>CMP0053</u>
       documentation for historical considerations and reasons why the <b>$</b> is also technically  permitted  but  is
       discouraged.

       The <u>Variables</u> section documents the scope of variable names and how their values are set.

       An  <u>environment</u>  <u>variable</u> <u>reference</u> has the form <b>$ENV{&lt;variable&gt;}</b>.  See the <u>Environment</u> <u>Variables</u> section
       for more information.

       A <u>cache</u> <u>variable</u> <u>reference</u> has the form <b>$CACHE{&lt;variable&gt;}</b>, and is replaced by the value of the specified
       cache entry without checking for a normal variable of the same name.  If the cache entry does not  exist,
       it is replaced by the empty string.  See <u>CACHE</u> for more information.

       The  <u>if()</u>  command  has  a special condition syntax that allows for variable references in the short form
       <b>&lt;variable&gt;</b> instead of <b>${&lt;variable&gt;}</b>.  However, environment variables always  need  to  be  referenced  as
       <b>$ENV{&lt;variable&gt;}</b>.

   <b>Comments</b>
       A  comment  starts  with a <b>#</b> character that is not inside a <u>Bracket</u> <u>Argument</u>, <u>Quoted</u> <u>Argument</u>, or escaped
       with <b>\</b> as part of an <u>Unquoted</u> <u>Argument</u>.  There are two types of comments: a <u>Bracket</u> <u>Comment</u>  and  a  <u>Line</u>
       <u>Comment</u>.

   <b>Bracket</b> <b>Comment</b>
       A  <b>#</b>  immediately  followed  by  a  <u>bracket_open</u> forms a <u>bracket</u> <u>comment</u> consisting of the entire bracket
       enclosure:

       <b>bracket_comment</b> ::= '#' <u>bracket_argument</u>

       For example:

          #[[This is a bracket comment.
          It runs until the close bracket.]]
          message("First Argument\n" #[[Bracket Comment]] "Second Argument")

       <b>NOTE:</b>
          CMake versions prior to 3.0 do not support bracket comments.  They interpret  the  opening  <b>#</b>  as  the
          start of a <u>Line</u> <u>Comment</u>.

   <b>Line</b> <b>Comment</b>
       A <b>#</b> not immediately followed by a <u>bracket_open</u> forms a <u>line</u> <u>comment</u> that runs until the end of the line:

       <b>line_comment</b> ::= '#' &lt;any text not starting in a <u>bracket_open</u>
                        and not containing a <u>newline</u>&gt;

       For example:

          # This is a line comment.
          message("First Argument\n" # This is a line comment :)
                  "Second Argument") # This is a line comment.

</pre><h4><b>CONTROL</b> <b>STRUCTURES</b></h4><pre>
   <b>Conditional</b> <b>Blocks</b>
       The <u>if()</u>/<u>elseif()</u>/<u>else()</u>/<u>endif()</u> commands delimit code blocks to be executed conditionally.

   <b>Loops</b>
       The  <u>foreach()</u>/<u>endforeach()</u> and <u>while()</u>/<u>endwhile()</u> commands delimit code blocks to be executed in a loop.
       Inside such blocks the <u>break()</u> command may be used to terminate the loop  early  whereas  the  <u>continue()</u>
       command may be used to start with the next iteration immediately.

   <b>Command</b> <b>Definitions</b>
       The  <u>macro()</u>/<u>endmacro()</u>,  and  <u>function()</u>/<u>endfunction()</u>  commands  delimit code blocks to be recorded for
       later invocation as commands.

</pre><h4><b>VARIABLES</b></h4><pre>
       Variables are the basic unit of storage in the CMake Language.  Their values are always of  string  type,
       though  some commands may interpret the strings as values of other types.  The <u>set()</u> and <u>unset()</u> commands
       explicitly set or unset a variable, but other commands have semantics  that  modify  variables  as  well.
       Variable  names are case-sensitive and may consist of almost any text, but we recommend sticking to names
       consisting only of alphanumeric characters plus <b>_</b> and <b>-</b>.

       Variables have dynamic scope.  Each variable "set" or "unset" creates a binding in the current scope:

       <b>Block</b> <b>Scope</b>
              The <u>block()</u> command may create a new scope for variable bindings.

       <b>Function</b> <b>Scope</b>
              <u>Command</u> <u>Definitions</u> created by the <u>function()</u> command create commands that, when invoked,  process
              the  recorded commands in a new variable binding scope.  A variable "set" or "unset" binds in this
              scope and is visible for the current function and any nested calls within it, but  not  after  the
              function returns.

       <b>Directory</b> <b>Scope</b>
              Each  of  the  <u>Directories</u>  in a source tree has its own variable bindings.  Before processing the
              <b>CMakeLists.txt</b> file for a directory, CMake copies all variable bindings currently defined  in  the
              parent  directory,  if  any, to initialize the new directory scope.  CMake <u>Scripts</u>, when processed
              with <u>cmake</u> <u>-P</u>, bind variables in one "directory" scope.

              A variable "set" or "unset" not inside a function call binds to the current directory scope.

       <b>Persistent</b> <b>Cache</b>
              CMake stores a separate set of "cache" variables, or "cache entries", whose values persist  across
              multiple  runs within a project build tree.  Cache entries have an isolated binding scope modified
              only by explicit request, such as by the <b>CACHE</b> option of the <u>set()</u> and <u>unset()</u> commands.

       When evaluating <u>Variable</u> <u>References</u>, CMake first searches the function call stack, if any, for a  binding
       and  then falls back to the binding in the current directory scope, if any.  If a "set" binding is found,
       its value is used.  If an "unset" binding is found, or no binding is found, CMake  then  searches  for  a
       cache  entry.  If a cache entry is found, its value is used.  Otherwise, the variable reference evaluates
       to an empty string.  The <b>$CACHE{VAR}</b> syntax can be used to do direct cache entry lookups.

       The <u><a href="../man7/cmake-variables.7.html">cmake-variables</a>(7)</u> manual documents the many variables that are provided by CMake or have meaning  to
       CMake when set by project code.

       <b>NOTE:</b>
          CMake reserves identifiers that:

          • begin with <b>CMAKE_</b> (upper-, lower-, or mixed-case), or

          • begin with <b>_CMAKE_</b> (upper-, lower-, or mixed-case), or

          • begin with <b>_</b> followed by the name of any <u>CMake</u> <u>Command</u>.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       Environment Variables are like ordinary <u>Variables</u>, with the following differences:

       <b>Scope</b>  Environment variables have global scope in a CMake process.  They are never cached.

       <b>References</b>
              <u>Variable</u> <u>References</u> have the form <b>$ENV{&lt;variable&gt;}</b>, using the <u>ENV</u> operator.

       <b>Initialization</b>
              Initial values of the CMake environment variables are those of the calling process.  Values can be
              changed  using  the  <u>set()</u>  and  <u>unset()</u>  commands.   These commands only affect the running CMake
              process, not the system environment at large.  Changed values are not written back to the  calling
              process, and they are not seen by subsequent build or test processes.

              See the <u>cmake</u> <u>-E</u> <u>env</u> command-line tool to run a command in a modified environment.

       <b>Inspection</b>
              See the <u>cmake</u> <u>-E</u> <u>environment</u> command-line tool to display all current environment variables.

       The <u><a href="../man7/cmake-env-variables.7.html">cmake-env-variables</a>(7)</u> manual documents environment variables that have special meaning to CMake.

</pre><h4><b>LISTS</b></h4><pre>
       Although  all  values  in  CMake  are  stored  as  strings,  a string may be treated as a list in certain
       contexts, such as during evaluation of an <u>Unquoted</u> <u>Argument</u>.  In such contexts, a string is divided  into
       list  elements by splitting on <b>;</b> characters not following an unequal number of <b>[</b> and <b>]</b> characters and not
       immediately preceded by a <b>\</b>.  The sequence <b>\;</b> does not divide a  value  but  is  replaced  by  <b>;</b>  in  the
       resulting element.

       A list of elements is represented as a string by concatenating the elements separated by <b>;</b>.  For example,
       the <u>set()</u> command stores multiple values into the destination variable as a list:

          set(srcs a.c b.c c.c) # sets "srcs" to "a.c;b.c;c.c"

       Lists  are  meant  for simple use cases such as a list of source files and should not be used for complex
       data processing tasks.  Most commands that construct lists do not escape <b>;</b> characters in  list  elements,
       thus flattening nested lists:

          set(x a "b;c") # sets "x" to "a;b;c", not "a;b\;c"

       In  general,  lists  do  not  support  elements containing <b>;</b> characters.  To avoid problems, consider the
       following advice:

       • The interfaces of many CMake commands, variables,  and  properties  accept  semicolon-separated  lists.
         Avoid passing lists with elements containing semicolons to these interfaces unless they document either
         direct support or some way to escape or encode semicolons.

       • When  constructing  a  list,  substitute  an otherwise-unused placeholder for <b>;</b> in elements when.  Then
         substitute <b>;</b> for the placeholder when processing list elements.  For example, the following code uses <b>|</b>
         in place of <b>;</b> characters:

            set(mylist a "b|c")
            foreach(entry IN LISTS mylist)
              string(REPLACE "|" ";" entry "${entry}")
              # use "${entry}" normally
            endforeach()

         The <u>ExternalProject</u> module's <b>LIST_SEPARATOR</b> option is an example  of  an  interface  built  using  this
         approach.

       • In lists of <u>generator</u> <u>expressions</u>, use the <u>$&lt;SEMICOLON&gt;</u> generator expression.

       • In  command  calls,  use <u>Quoted</u> <u>Argument</u> syntax whenever possible.  The called command will receive the
         content of the argument with semicolons preserved.  An <u>Unquoted</u> <u>Argument</u> will be split on semicolons.

       • In <u>function()</u> implementations, avoid <b>ARGV</b> and <b>ARGN</b>, which do not distinguish semicolons in values  from
         those  separating  values.   Instead,  prefer  using  named positional arguments and the <b>ARGC</b> and <b>ARGV#</b>
         variables.  When using <u>cmake_parse_arguments()</u> to parse arguments,  prefer  its  <b>PARSE_ARGV</b>  signature,
         which uses the <b>ARGV#</b> variables.

         Note  that  this  approach  does  not apply to <u>macro()</u> implementations because they reference arguments
         using placeholders, not real variables.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2000-2024 Kitware, Inc. and Contributors

3.31.6                                            May 23, 2025                                 <u><a href="../man7/CMAKE-LANGUAGE.7.html">CMAKE-LANGUAGE</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>