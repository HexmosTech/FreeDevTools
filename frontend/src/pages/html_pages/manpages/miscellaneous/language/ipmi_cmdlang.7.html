<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ipmi_cmdlang - A command language interface to the IPMI library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openipmi">openipmi_2.0.37-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ipmi_cmdlang - A command language interface to the IPMI library

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>ipmi_cmdlang</b>  is  a command language designed to supply the full power of OpenIPMI on a command line.  It
       has a large number of commands and well-formed responses to each command.  Note that  this  assumes  some
       knowledge of OpenIPMI and how it works; you can get that from the IPMI document that comes with OpenIPMI.

       <b>ipmish</b>  starts  up  with  no  connections  or  anything  of that nature.  You must enter commands to make
       connections to domains.  Then you can enter commands to manipulate those domains or objects inside  those
       domains.

       Note that you may use quotes, either <b>''</b> or  to contain parameters with spaces.

</pre><h4><b>COMMENTS</b></h4><pre>
       Lines with a <b>#</b> character in the first column are ignored.

</pre><h4><b>OBJECTS</b></h4><pre>
       In  the  command  language,  you  will  deal  with  various  objects like sensors, controls, domains, and
       entities.  Each of these has a name.  The name of the domain is assigned by the user in  the  <b>domain</b>  <b>new</b>
       command,  all  the  other  names  are  based  on the domain name of the domain they belong to and various
       attributes about the object.  These names are all well-formed.  They are

       <u>&lt;domain&gt;</u> - A name of a domain.  Each registered domain in a system has a name assigned by the user.

       <u>&lt;entity&gt;</u> - Entity names are in the form:
              [<u>&lt;domain&gt;</u>[(<u>&lt;entity</u> <u>spec&gt;</u>)]]
       Notice that the <u>&lt;entity</u> <u>spec&gt;</u> is optional.  If it is not listed,  then  the  operation  is  done  on  all
       entities in the domain.  The whole thing is optional, too, if nothing is given then the operation is done
       on every entity in every domain.

       The <u>&lt;entity</u> <u>spec&gt;</u> is either
              <u>&lt;entity</u> <u>id&gt;</u>.<u>&lt;entity</u> <u>instance&gt;</u>
       for system-relative entities, or:
              r<u>&lt;channel&gt;</u>.<u>&lt;IPMB&gt;</u>.<u>&lt;entity</u> <u>id&gt;</u>.<u>&lt;entity</u> <u>instance-0x60&gt;</u>
       for  device-relative  entities.   In  IPMI,  device-relative  entity  instances always start at 0x60; the
       specification suggests that you subtract off the 0x60 from the entity instance when displaying these; the
       command language follows this suggestion.

       <u>&lt;sensor&gt;</u> -  These come in the form
              [<u>&lt;entity&gt;</u>[.<u>name</u>]]
       As with entities, only listing a domain will cause the operation to  be  done  on  every  sensor  in  the
       domain,  just listing an entity will cause it to be done to every sensor in that entity.  An empty sensor
       entry will cause an operation to be done on every sensor in every domain.

       <u>&lt;control&gt;</u> - These come in the form
              [&lt;entity&gt;[.name]]
       These work exactly like sensors.

       <u>&lt;mc&gt;</u> - A management controller.  These come in the form
              [&lt;domain&gt;[(&lt;channel&gt;.&lt;IPMB&gt;)]]
       As usual, the parts left empty will cause defaulting to all things in the previously specified parts.

       <u>&lt;connection&gt;</u> - A connection number, in the form
              [&lt;domain&gt;[.&lt;integer&gt;]]
       The number is the connection number of the domain.

       <u>&lt;pet&gt;</u> - A platform event trap id, in the form
              [&lt;domain&gt;[.&lt;integer&gt;]]
       The number is arbitrarily assigned by the system.

       <u>&lt;lanparm&gt;</u> - A LAN parameter id, in the form
              [&lt;domain&gt;[.&lt;integer&gt;]]
       The number is arbitrarily assigned by the system.

       <u>&lt;pef&gt;</u> - A PEF id, in the form
              [&lt;domain&gt;[.&lt;integer&gt;]]
       The number is arbitrarily assigned by the system.

       <u>&lt;fru&gt;</u> - A FRU id, in the form
              [&lt;domain&gt;[.&lt;integer&gt;]]
       The number is arbitrarily assigned by the system.

       In all cases, the object names have parts that are optional, and the entire object name is optional.   If
       a  part  is  left  empty,  then  all  objects  that are part of the specified parts are operated on.  For
       instance, if the system has a sensor named <b>d1(7.1).temp</b> then specifying <b>d1</b> would operation on all sensors
       in the domain named <b>d1.</b>  Specifying <b>d1(7.1)</b> Would operation on all sensors in that entity.  Specifying an
       empty name, either with  or by just entering nothing if the object is the last  thing  in  the  command's
       parameters.

       Note  this optionality gives a lot of power, but can be very dangerous.  Entering <b>domain</b> <b>close</b> will close
       every domain, for instance.

       In commands, every object operated on will generate a response for that object.  If no object is operated
       on, the command will produce an error.

</pre><h4><b>OTHER</b> <b>PARAMETERS</b></h4><pre>
       The commands and displays use a variety of other parameters for specifying various IPMI things.

       <u>&lt;guid&gt;</u> - a 16-byte globally unique ID, all globbed together in one big hexadecimal thing.

       <u>&lt;threshold&gt;</u> is a threshold for a sensor; the value it must go over/under to generate  an  event.   It  is
       always  displayed  as  one  of <b>lower</b> <b>non-critical</b> <b>lower</b> <b>critical</b> <b>lower</b> <b>non-recoverable</b> <b>upper</b> <b>non-critical</b>
       <b>upper</b> <b>critical</b> <b>upper</b> <b>non-recoverable.</b>  It may be entered as one of the above, or as <b>ln,</b> <b>lc,</b> <b>lr,</b>  <b>un,</b>  <b>uc,</b>
       <b>ur</b> as a short form.

       <u>&lt;threshold</u>  <u>enable&gt;</u>  is  the enable for a threshold.  It is like <u>&lt;threshold&gt;</u> above, but also has a <b>going-</b>
       <b>high</b> or <b>going-low</b> and an <b>assertion</b> or <b>deassertion</b> appended to the end of the name.  The short  form  will
       have  a  <b>l</b> or <b>h</b> for going-low and going high and then a <b>a</b> or <b>d</b> appended for assertion and deassertion  So
       for instance, <b>urld</b> is upper non-recoverable going-low deassertion.

       <u>&lt;discrete</u> <u>enable&gt;</u> is the enable or disable for a discrete sensor and is specified with the sensor offset.
       The long form is <b>&lt;integer&gt;</b> <b>assertion</b> or <b>&lt;integer&gt;</b> <b>deassertion</b> and the short form is  <b>&lt;integer&gt;[ad]</b>  where
       the number is the offset and <b>[ad]</b> means assertion or deassertion.

       <u>&lt;hot-swap</u>  <u>state&gt;</u>  is  one  of  <b>not_present,</b>  <b>inactive</b> <b>activation_requested</b> <b>activation_in_progress</b> <b>active</b>
       <b>deactivation_requested</b> <b>deactivation_in_progress</b> or <b>out_of_con.</b>

       <u>&lt;color&gt;</u> is one of <b>black,</b> <b>white,</b> <b>red,</b> <b>green</b> <b>blue</b> <b>yellow</b> or <b>orange.</b>

       <u>&lt;bool&gt;</u> is one of <b>true,</b> <b>on,</b> <b>t,</b> or <b>1</b> for true and one of <b>false,</b> <b>off,</b> <b>f,</b> or <b>0</b> for false.  Output  is  always
       <b>true</b> or <b>false.</b>

</pre><h4><b>COMMANDS</b></h4><pre>
       The  command  language  is  hierarchical, meaning that commands may have subcommands, and subcommands may
       have subsubcommands, etc.  So, for instance, the command to create a domain is <b>domain</b> <b>new.</b>   The  command
       to list all sensors in a domain named domain1 is <b>sensor</b> <b>list</b> <b>domain1.</b>

       Each  command  has  a reponse for each object operated on, which is listed after the command description.
       In those responses, anything that begins with a <b>%</b> is optional.  Entries of the  form  <b>**name**</b>  refer  to
       object  info  descriptions  that are listed in the object info section.  If an entry has two '.' indented
       one space below it, then that entry may occur zero or more times.

       Each section below defines the unique subcommands of a main command.

       Help for any command is available with:

       <b>help</b> <b>command</b> <b>[subcommand</b> <b>[...]]</b>  - Help for any command.

       Some commands are common to almost all subcommands.  These are:

       <b>list</b> <b>&lt;containing</b> <b>object&gt;</b> - List all objects of the specified type that are  contained  in  the  specified
       object.  For instance, <b>control</b> <b>list</b> <u>&lt;entity&gt;</u> will list all controls in the given entity.

       Response:
              &lt;containing object type&gt;
                Name: &lt;name&gt;
                 .
                 .

       <b>info</b> <b>&lt;object&gt;</b> - List static information about the given object.

       Response:
              &lt;object type&gt;
                Name: &lt;name&gt;
                **object info**

   <b>domain</b>
       These commands deal with domain objects.

       <b>new</b> <u>&lt;domain&gt;</u> <u>&lt;options&gt;</u> <u>&lt;parms&gt;</u> <b>[</b><u>&lt;parms&gt;</u><b>]</b> - Open a connection to a new domain.  <u>&lt;parms&gt;</u> are either:
              lan <u>&lt;IP&gt;</u> <u>&lt;port&gt;</u> [<u>&lt;IP&gt;</u> <u>&lt;port&gt;</u>] <u>&lt;enc&gt;</u> <u>&lt;auth&gt;</u> <u>&lt;name&gt;</u> <u>&lt;password&gt;</u>
       for a RMCP LAN connection or
              smi <u>&lt;smi</u> <u>num&gt;</u>
       for  a  system  interface connection.  Note that <u>&lt;parms&gt;</u> is listed twice (second one is optional); if the
       system support it you can make two connections to two independent management controllers in  the  system.
       Note  that  this  is  not  for  multiple  IP  addresses  to  the same BMC.  For that, notice that the LAN
       connection has an options extra IP and port for the  second  IP  address.   OpenIPMI  supports  these  IP
       addresses  and  connection,  detecting  failures,  switching  between addresses, and other fault-tolerant
       things.  It does this transparently to the user.  Mutiple connections may require  special  OEM  support,
       read the documentation about your specific system if you need this.

       The  <u>&lt;IP&gt;</u> is the IP address or host name of the LAN-capable BMC to connect with.  The <u>&lt;port&gt;</u> is generally
       623.  <u>&lt;enc&gt;</u> is the authentication type, either <b>md5,</b> <b>md2,</b> <b>straight,</b> or <b>none.</b>  <u>&lt;auth&gt;</u> is the authentication
       level, either <b>admin,</b> <b>operator</b> or <b>user.</b>  <u>&lt;name&gt;</u> and <u>&lt;password&gt;</u> are the user name and password of the  IPMI
       user  to  use  for  the connection.  The &lt;smi num&gt; is the driver number, generally 0.  Options enable and
       disable various automitic processing and are:
       <b>-[no]all</b> - all automatic handling.  This will override the other processing options and turn them all on.
              This is true by default.
       <b>-[no]sdrs</b> - sdr fetching.  This turns on fetching SDRs when they are found.  This is false by default.
       <b>-[no]frus</b> - FRU fetching  This turns on fetching FRU information when it is  found.   This  is  false  by
              default.
       <b>-[no]sel</b> - SEL fetching.    This turns on fetching SELs when they are found.  This is false by default.
       <b>-[no]ipmbscan</b>  -  IPMB  bus  scanning.   This turns on scanning IPMB busses when they are found.  This is
              false by default.
       <b>-[no]oeminit</b> - enable or disable special OEM processing (like ATCA).
       <b>-[no]seteventrcvr</b> - setting event receivers.  Note that setting event receivers and waiting til up is not
              affected by the <b>-all</b> option.  If this is true (the default) then OpenIPMI will attempt to set  the
              event receiver for an MC it finds that does not have it set to a valid destination.
       <b>-wait_til_up</b>  - wait until the domain is up before returning Note that if you specify this and the domain
              never comes up, you will never get a prompt.  This is not affected by the <b>-all</b> option.  By default
              -all and -seteventrcvr are true, which turns everything on.

       Response:
              Domain Created: &lt;domain&gt;

       <b>open</b> <u>&lt;domain&gt;</u> <u>&lt;options&gt;</u> <u>&lt;parms&gt;</u> <b>[</b><u>&lt;parms&gt;</u><b>]</b> - Open a connection to a new domain.  <u>&lt;parms&gt;</u> are either:
              lan [-U <u>&lt;username&gt;</u>] [-P <u>&lt;password&gt;</u>] [-A <u>&lt;authtype&gt;</u>]
                [-L <u>&lt;privilege&gt;</u>] [-s] [-p[2] <u>&lt;port</u> <u>number&gt;</u>]
                [-Ra <u>&lt;auth</u> <u>alg&gt;</u>] [-Ri <u>&lt;integ</u> <u>alg&gt;</u>] [-Rc <u>&lt;conf</u> <u>algo&gt;</u>]
                [-Rl] [-Rk <u>&lt;bmc</u> <u>key&gt;</u>] [-H <u>&lt;hackname&gt;</u>]
                [-M <u>&lt;max</u> <u>oustanding</u> <u>msgs</u>&gt;] <u>&lt;IP&gt;</u> [<u>&lt;IP&gt;</u>]
       for a RMCP/RMCP+ LAN connection or
              smi <u>&lt;smi</u> <u>num&gt;</u>
       for a system interface connection.  Note that <u>&lt;parms&gt;</u> is listed twice (second one is  optional);  if  the
       system  support  it you can make two connections to two independent management controllers in the system.
       Note that this is not for multiple IP addresses to the same BMC.  For that, use the  -s  option  and  the
       second  IP  (and  -p2)  for the second IP address.  OpenIPMI supports these IP addresses and connections,
       detecting failures,  switching  between  addresses,  and  other  fault-tolerant  things.   It  does  this
       transparently  to the user.  Multiple connections may require special OEM support, read the documentation
       about your specific system if you need this.

       The <u>&lt;IP&gt;</u> is the IP address or host name of the LAN-capable BMC to connect with.  The <u>&lt;port&gt;</u> defaults 623.
       <u>&lt;authtype&gt;</u> is the authentication type, either <b>rmcp+,</b> <b>md5,</b> <b>md2,</b> <b>straight,</b> or <b>none.</b>   It  defaults  to  the
       best  authentication supported by the server.  <u>&lt;auth&gt;</u> is the authentication level, either <b>admin,</b> <b>operator</b>
       or <b>user.</b>  It defaults to admin.  <u>&lt;username&gt;</u> and <u>&lt;password&gt;</u> are the user name and  password  of  the  IPMI
       user  to  use  for  the connection.  For RMCP+ connections, the authentication algorithms supported (-Ra)
       are: bmcpick, rakp_none, rakp_hmac_sha1, and rakp_hmac_md5.  The  integrity  algorithms  (-Ri)  supported
       are:  bmcpick,  none,  hmac_sha1,  hmac_md5, and md5.  The confidentiality algorithms (-Rc) are: bmcpick,
       aes_cbc_128, xrc4_128, and xrc_40.  The defaults are rackp_hmac_sha1,  hmac_sha1,  and  aes_cb_128.   -Rl
       turns  on  lookup  up  names  by  the name and the privilege level (allowing the same name with different
       privileges and different passwords), the default is straight name lookup.  -Rk sets the BMC  key,  needed
       if the system does two-key lookups.

       For SMI types, the &lt;smi num&gt; is the driver number, generally 0.

       The  <u>&lt;hackname&gt;</u>  enables certain hacks for broken platforms.  This may be listed multiple times to enable
       multiple hacks.  The currently available hacks are:
       <b>intelplus</b> - For Intel platforms that have broken RMCP+.
       <b>rakp3_wrong_rolem</b> - For systems that truncate <a href="../manm/role.m.html">role</a>(m) in the RAKP3 msg.
       <b>rmcpp_integ_sik</b> - For systems that use SIK instead of <a href="../man1/K.1.html">K</a>(1) for integrity.

              The -M option sets the maximum outstanding messages.  The default is 2, ranges 1-63.

              Options enable and disable various automitic processing and are:
       <b>-[no]all</b> - all automatic handling.  This will override the other processing options and turn them all on.
              This is true by default.
       <b>-[no]sdrs</b> - sdr fetching.  This turns on fetching SDRs when they are found.  This is false by default.
       <b>-[no]frus</b> - FRU fetching  This turns on fetching FRU information when it is  found.   This  is  false  by
              default.
       <b>-[no]sel</b> - SEL fetching.    This turns on fetching SELs when they are found.  This is false by default.
       <b>-[no]ipmbscan</b>  -  IPMB  bus  scanning.   This turns on scanning IPMB busses when they are found.  This is
              false by default.
       <b>-[no]oeminit</b> - enable or disable special OEM processing (like ATCA).
       <b>-[no]seteventrcvr</b> - setting event receivers.  Note that setting event receivers is not  affected  by  the
              <b>-all</b>  option.   If this is true (the default) then OpenIPMI will attempt to set the event receiver
              for an MC it finds that does not have it set to a valid destination.  <b>-[no]setseltime</b>  -  set  SEL
              time.   Note  that  setting the SEL time is not affected by the <b>-all</b> option.  If this is true (the
              default) then OpenIPMI will attempt to set the time in the SELs it finds.  It will set it  to  the
              current system time.
       <b>-wait_til_up</b>  - wait until the domain is up before returning Note that if you specify this and the domain
              never comes up, you will never get a prompt.  This is not affected by the <b>-all</b> option.  By default
              -all and -seteventrcvr are true, which turns everything on.

       Response:
              Domain Created: &lt;domain&gt;

       <b>fru</b> <b>&lt;domain&gt;</b> <b>&lt;is_logical&gt;</b> <b>&lt;device_address&gt;</b> <b>&lt;device_id&gt;</b> <b>&lt;lun&gt;</b> <b>&lt;private_bus&gt;</b> <b>&lt;channel&gt;</b> - dump a  fru  given
       all it's insundry information.

       Response:
              Domain
                Name: &lt;domain&gt;
                FRU
                  **FRU INFO**

       <b>msg</b>  <b>&lt;domain&gt;</b>  <b>&lt;channel&gt;</b> <b>&lt;ipmb&gt;</b> <b>&lt;LUN&gt;</b> <b>&lt;NetFN&gt;</b> <b>&lt;Cmd&gt;</b> <b>[data...]</b>  - Send a command to the given IPMB address
       on the given channel and display the response.  Note that this does not require the existance of an MC in
       OpenIPMI.

       Response:
                Domain: &lt;domain&gt;
                channel: &lt;chan&gt;
                ipmb: &lt;ipmb&gt;
                LUN: &lt;lun&gt;
                NetFN: &lt;netfn&gt;
                command: &lt;cmd&gt;
                Data: &lt;data bytes&gt;

       <b>scan</b> <b>&lt;domain&gt;</b> <b>&lt;ipmb</b> <b>addr&gt;</b> <b>[ipmb</b> <b>addr]</b> - scan an IPMB to add or remove it.  If a range is given, then scan
       all IPMBs in the range.

       Response:
              Scan done: &lt;domain&gt;

       <b>rescan_sels</b> <b>&lt;domain&gt;</b> - Rescan all the SELs in the domain.

       Response:
              SEL Rescan done: &lt;domain&gt;

       <b>presence</b> <b>&lt;domain&gt;</b> - Audit the presence of all enities in the domain.  Note  that  this  just  starts  the
       process; it will run in the background.

       Response is:
              Presence check started: &lt;domain&gt;

       <b>close</b> <b>&lt;domain&gt;</b> - close the given domain.

       Response:
              Domain closed: &lt;domain&gt;

       <b>sel_rescan_time</b>  <b>&lt;domain&gt;</b>  <b>&lt;time</b>  <b>in</b> <b>seconds&gt;</b> - Set the time between SEL rescans for all.  It affects all
       current SELs and SELs that are discovered in the future.  Zero disables scans.

       Response:
              Domain SEL rescan time set: &lt;domain&gt;

       <b>ipmb_rescan_time</b> <b>&lt;domain&gt;</b> <b>&lt;time</b> <b>in</b> <b>seconds&gt;</b> - Set the time between IPMB rescans for  this  domain.   zero
       disables scans.

       Response:
              Domain IPMB rescan time set: &lt;domain&gt;

   <b>fru</b>
       These commands deal with FRU objects.  Note that FRU objects are allocated by the domain fru command, and
       are not allocated here.

       <b>list</b> - List all the frus in the system

       Response:
              Domain
                Name: &lt;domain&gt;
                FRUs
                  Name: &lt;fru&gt;
                 .
                 .
               .
               .

       <b>info</b> <b>&lt;fru&gt;</b> - Dump information about a FRU

       Response:
              **FRU INFO**

       <b>areainfo</b> <b>&lt;fru&gt;</b> - Dump the info about the FRU's areas

       Response:
              FRU
                Name: &lt;fru&gt;
                FRU Length: &lt;integer&gt;
                Area
                  Name: &lt;area name&gt;
                  Number: &lt;integer&gt;
                  Offset: &lt;integer&gt;
                  Length: &lt;integer&gt;
                  Used Length: &lt;Integer&gt;
                 .
                 .

       <b>write</b> <b>&lt;fru&gt;</b> - Write the local FRU data out into the FRU

       Response:
              FRU written: &lt;fru&gt;

       <b>close</b> <b>&lt;fru&gt;</b> - Delete the FRU

       Response:
              FRU deleted: &lt;fru&gt;

       <b>setval</b> <b>&lt;fru&gt;</b> <b>&lt;name&gt;</b> <b>[num]</b> <b>value</b> - Set the value of a FRU element.  The name is the record name, or multi-
       record.   The  number  is  required for fields that need it (custom and multi-record).  The value is an a
       single value for integers.  For strings it is a string type (either binary, ascii, or  unicode)  and  the
       info.   Binary and unicode data is specified as numbers.  ascii data is specified in a string.  Note that
       setting a ascii value with no string will clear the value.  Zero length strings and data is valid.

       Response:
              FRU value set: &lt;fru&gt;

       <b>area_offset</b> <b>&lt;fru&gt;</b> <b>&lt;area</b> <b>name&gt;</b> <b>&lt;offset&gt;</b> - Set the offset of the given area to the given value.  Area names
       are internal_data, chassis_info, board_info, product_info, and multi_record.

       Response:
              FRU area offset set: &lt;fru&gt;

       area_length &lt;fru&gt; &lt;area name&gt; &lt;length&gt; - Set the length of the given area to the given value.  Area names
       are internal_data, chassis_info board_info, product_info, and multi_record

       Response:
              FRU area length set: &lt;fru&gt;

       area_add &lt;fru&gt; &lt;area name&gt; &lt;offset&gt; &lt;length&gt; - Add the given area to the FRU.

       Response:
              FRU area added: &lt;fru&gt;

       area_delete &lt;fru&gt; &lt;area name&gt; - Delete the given area from the FRU

       Response:
              FRU area deleted: &lt;fru&gt;

   <b>entity</b>
       These commands deal with entity objects.

       <b>list</b> <b>&lt;entity&gt;</b> - List all the entities that meed the criteria

       Response:
              Domain
                Name: &lt;domain&gt;
                Entities
                  Name: &lt;entity&gt;
                   .
                   .
               .
               .

       <b>info</b> <b>&lt;entity&gt;</b> - Dump information about an entity.

       Reponse:
              Entity
                Name: &lt;entity&gt;
                **ENTITY INFO**
               .
               .

       <b>fru</b> <b>&lt;entity&gt;</b> - Dump the FRU information about the given entity.

       Reponse:
              Entity
                Name: &lt;entity&gt;
                FRU
                  **FRU INFO**

   <b>entity</b> <b>hs</b>
       These commands deal with hot-swap of entities.  Note that there is no  info  or  list  command  for  this
       subcommand.

       <b>get_act_time</b> <b>&lt;entity&gt;</b> - Get the hot-swap auto-activate time.

       Response:
              Entity
                Name: &lt;entity&gt;
                  Auto-Activation Time: &lt;integer&gt;

       <b>set_act_time</b> <b>&lt;entity&gt;</b> - Set the hot-swap auto-activate time.

       Reponse:
              Set act time: &lt;entity&gt;

       <b>get_deact_time</b> <b>&lt;entity&gt;</b> - Get the hot-swap auto-deactivate time Response:
              Entity
                Name: &lt;entity&gt;
                   Auto-Deactivation Time: &lt;integer&gt;

       <b>set_deact_time</b> <b>&lt;entity&gt;</b> - Set the hot-swap auto-deactivate time

       Response:
              Set deact time: &lt;entity&gt;

       <b>activation_request</b>  <b>&lt;entity&gt;</b>  - Act like a user requested an activation of the entity.  This is generally
       equivalent to closing the handle latch or something like that.

       Response:
              Activation requested: &lt;entity&gt;

       <b>activate</b> <b>&lt;entity&gt;</b> - activate the given entity

       Response:
              Activated: &lt;entity&gt;

       <b>deactivate</b> <b>&lt;entity&gt;</b> - deactivate the given entity

       Response:
              Deactivated: &lt;entity&gt;

       <b>state</b> <b>&lt;entity&gt;</b> - Return the current hot-swap state of the given entity.

       Response:
              Entity
                Name: &lt;entity&gt;
                  State: &lt;hot-swap state&gt;

       <b>check</b> <b>&lt;entity&gt;</b> - Audit the entity's hot-swap state

       Response:
              Check started: &lt;entity&gt;

   <b>sensor</b>
       <b>get</b> <b>&lt;sensor&gt;</b> - Get the sensor's current reading.

       Response:
              Sensor
                Name: &lt;sensor&gt;
                Event Messages Enabled: &lt;bool&gt;
                Sensor Scanning Enabled: &lt;bool&gt;
                Initial Update In Progress: &lt;bool&gt;
       For threshold sensors, the following will be output:
              %Value: &lt;double&gt;
              %Raw Value: &lt;integer&gt;
              Threshold
                Name: &lt;threshold&gt;
                Out Of Range: &lt;bool&gt;
       For discrete sensors, the following will be output:
              Event
                Offset: &lt;integer&gt;
                %Name: &lt;string name of event offset&gt;
                Set: &lt;bool&gt;
       The name field may be custom and is not explicitly specified.

       <b>rearm</b> <b>&lt;sensor&gt;</b> <b>global</b> <b>|</b> <b>&lt;threshold</b> <b>enable&gt;</b> <b>[&lt;threshold</b> <b>enable&gt;</b> <b>..]</b> <b>|</b> <b>&lt;discrete</b> <b>enable&gt;</b> <b>[&lt;discrete</b> <b>enable&gt;</b>
       <b>..]</b>  - Rearm the sensor.  If global is specified, then rearm all events in the sensor.  Otherwise, if  it
       is  a threshold sensor, then put in a list of threshold enables.  If it is a discrete sensor, then put in
       a list of discrete enables.

       Response:
              Rearm done: &lt;sensor&gt;

       <b>get_thresholds</b> <b>&lt;sensor&gt;</b> - Get the sensor's thresholds

       Response:
              Sensor
                Name: &lt;sensor&gt;
                Threshold
                  Name: &lt;threshold&gt;
                  Value: &lt;double&gt;

       <b>set_thresholds</b> <b>&lt;sensor&gt;</b> <b>&lt;threshold&gt;</b> <b>&lt;value&gt;</b> <b>...</b>  - Set the sensor's thresholds to the given values.  If a
       threshold is not specified, it will not be modified.  Thresholds are un, uc,  ur,  lr,  lc,  ln.   The  u
       stands  for upper, l for lower, n for non-critical, c for critical, and r for non-recoverable.  The value
       is floating point.

       Response:
              Thresholds set: &lt;sensor&gt;

       <b>get_hysteresis</b> <b>&lt;sensor&gt;</b> - Get the sensor's hysteresis values

       Response:
              Sensor
                Name: &lt;sensor&gt;
                Positivie Hysteresis: &lt;integer&gt;
                Negative Hysteresis: &lt;integer&gt;

       <b>set_hysteresis</b> <b>&lt;sensor&gt;</b> <b>&lt;pos</b> <b>hyst&gt;</b> <b>&lt;neg</b> <b>hyst&gt;</b> - Set the sensor's hysteresis to the given  values.   These
       are raw integer value; hystersis is specified as a raw value and it cannot be converted to floating point
       because the function may be non-linear.

       Response:
              Hysteresis set: &lt;sensor&gt;

       <b>get_event_enables</b> <b>&lt;sensor&gt;</b> - Get the sensor's event enable values

       Response:
              Sensor
                Name: &lt;sensor&gt;
                Event Messages Enabled: &lt;bool&gt;
                Sensor Scanning Enabled: &lt;bool&gt;
                Busy: &lt;bool&gt;
       Threshold sensors report:
              Threshold
                Name: &lt;threshold&gt;
                Enabled: &lt;bool&gt;
                 .
                 .
       only supported thresholds are listed.  Discrete sensors report:
              Event
                Offset: &lt;integer&gt;
                Name: &lt;event offset name for sensor&gt;
                %Assertion Enabled: &lt;bool&gt;
                %Deassertion Enabled: &lt;bool&gt;
       only  supported  offsets are listed.  The assertion and deassertion enables are listed only if the offset
       support them.

       <b>set_event_enables</b> <b>&lt;sensor&gt;</b> <b>msg|nomsg</b> <b>scan|noscan</b> <b>[&lt;enable&gt;</b> <b>[&lt;enable&gt;</b> <b>...]]</b>   -  Set  the  sensor's  event
       enable values.  This turns sensor messages and scanning on and off and will enable all the listed enables
       and disable all over ones.  The enables are either a <u>&lt;threshold</u> <u>enable&gt;</u> or a <u>&lt;discrete</u> <u>enable&gt;</u>.

       Response:
              Event enables set: &lt;sensor&gt;

       <b>enable_events</b>  <b>&lt;sensor&gt;</b>  <b>msg|nomsg</b>  <b>scan|noscan</b>  <b>[&lt;enable&gt;</b> <b>[&lt;enable&gt;</b> <b>...]]</b>  - Enable event enable values.
       This turns sensor messages and scanning on and off and will enable all the  listed  enables.   All  other
       enables will be left alone.  The enables are either a <u>&lt;threshold</u> <u>enable&gt;</u> or a <u>&lt;discrete</u> <u>enable&gt;</u>.

       Response:
              Event enables set: &lt;sensor&gt;

       <b>disable_events</b>  <b>&lt;sensor&gt;</b>  <b>msg|nomsg</b> <b>scan|noscan</b> <b>[&lt;enable&gt;</b> <b>[&lt;enable&gt;</b> <b>...]]</b>  - Disable event enable values.
       This turns sensor messages and scanning on and off and will disable all the  listed  enable.   All  other
       enables will be left alone.  The enables are either a <u>&lt;threshold</u> <u>enable&gt;</u> or a <u>&lt;discrete</u> <u>enable&gt;</u>.

       Response:
              Event enables set: &lt;sensor&gt;

   <b>control</b>
       Commands dealing with controls.

       <b>set</b>  <b>&lt;control&gt;</b>  <b>&lt;value&gt;</b> <b>[&lt;value&gt;</b> <b>..]</b>  - Set the value of a control.  The settings depend on control type,
       most take one or more integer values depending on the number of physical things the control contains.  An
       identifier type takes one or more unsigned characters.  A light set with settings take the form
              <b>lc|nolc</b> <b>&lt;color&gt;</b> <b>&lt;on</b> <b>time&gt;</b> <b>&lt;off</b> <b>time&gt;</b>
       <b>lc</b> and <b>nolc</b> turn on or of local control, the over values should be  obvious.   Note  all  lights  support
       local control, you need to see if it supports the value.

       Response:
              Set done: &lt;control&gt;

       <b>get</b> <b>&lt;control&gt;</b> - Get the value of a control.  The reponse depends on the control type.

       Response:
              Control
                Name: &lt;control&gt;
       Response for setting lights is:
              Light
                Num: 0
                Local Control: &lt;bool&gt;
                %Color: &lt;color&gt;
                %On Time: &lt;integer&gt;
                %Off Time: &lt;integer&gt;
       Note  that  multiple  lights  may be present if the control supports multiple lights.  The options values
       (marked with <b>%</b> ) will not be present if local control is set to true.  Local control means that  the  LED
       takes  whatever  default  function it does on the device (like disk activity, ethernet activity, hot-swap
       LED, etc.).  Response for id control:
              Data: &lt;byte1&gt; &lt;byte2&gt; ...
       Response for other controls:
              Value
                Num: &lt;integer&gt;
                Value: &lt;integer&gt;
       There will be one <b>Value</b> for each value the control supports.

   <b>mc</b>
       Commands dealing with MC objects.

       <b>reset</b> <b>&lt;warm</b> <b>|</b> <b>cold&gt;</b> <b>&lt;mc&gt;</b> - Do a warm or cold reset on the given MC

       Response:
              Reset done: &lt;mc&gt;

       <b>msg</b> <b>&lt;mc&gt;</b> <b>&lt;LUN&gt;</b> <b>&lt;NetFN&gt;</b> <b>&lt;Cmd&gt;</b> <b>[data...]</b>  - Send the given command to the management controller and display
       the response.

       Response:
                MC: &lt;mc&gt;
                LUN: &lt;lun&gt;
                NetFN: &lt;netfn&gt;
                command: &lt;cmd&gt;
                Data: &lt;data bytes&gt;

       <b>set_events_enable</b> <b>&lt;mc&gt;</b> <b>&lt;enable</b> <b>|</b> <b>disable&gt;</b> - enables or disables events on the MC.

       Response:
              Events enable done: &lt;mc&gt;

       <b>get_events_enable</b> <b>&lt;mc&gt;</b> - Prints out if the events are enabled for the given MC.

       Response:
              Events Enable: &lt;bool&gt;

       <b>sdrs</b> <b>&lt;mc&gt;</b> <b>&lt;main</b> <b>|</b> <b>sensor&gt;</b> - list the SDRs for the mc.  Either gets the main SDR repository or the  sensor
       SDR repository.

       Response:
              MC
                Name: &lt;mc&gt;
                SDR
                  Record ID: &lt;integer&gt;
                  Type: &lt;integer&gt;
                  Version: &lt;integer&gt;.&lt;integer&gt;
                  Data: &lt;data bytes&gt;
       One <b>SDR</b> will be present for each SDR in the repository.

       <b>get_sel_time</b> <b>&lt;mc&gt;</b> - Get the time in the SEL for the given MC.

       Response:
              MC
                Name: &lt;mc&gt;
                SEL Time: &lt;integer&gt;

       <b>set_sel_time</b> <b>&lt;mc&gt;</b> <b>&lt;time&gt;</b> - Set the time in the SEL for the given MC.

       Response:
              MC SEL time set
                Name: &lt;mc&gt;

       <b>rescan_sel</b> <b>&lt;mc&gt;</b> - Rescan the SEL in the MC.

       Response:
              SEL Rescan done: &lt;mc&gt;

       <b>sel_rescan_time</b>  <b>&lt;mc&gt;</b>  <b>&lt;time</b> <b>in</b> <b>seconds&gt;</b> - Set the time between SEL rescans for the SEL on this MC.  Zero
       disables scans.

       Response:
              MC SEL rescan time set: &lt;domain&gt;

       <b>sel_info</b> <b>&lt;mc&gt;</b> - Dump information about the MC's SEL.

       Response:
              MC
                Name: &lt;mc&gt;
                SEL Version: &lt;integer&gt;.&lt;integer&gt;
                SEL Count: &lt;integer&gt;
                SEL Slots Used: &lt;integer&gt;
                SEL Free Bytes: &lt;integer&gt;
                SEL Last Addition Timestamp: &lt;integer&gt;
                SEL overflow: &lt;bool&gt;
                SEL Supports Delete: &lt;bool&gt;
                SEL Supports Partial Add: &lt;bool&gt;
                SEL Supports Reserve: &lt;bool&gt;
                SEL Supports Get SEL Allocation: &lt;bool&gt;

       <b>chan</b> <b>info</b> <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> - Dump information about the MC's channel.

       Response:
              Channel Info
                MC: &lt;mc&gt;
                Number: &lt;integer&gt;
                Medium: &lt;integer&gt;
                Protocol Type: &lt;integer&gt;
                Session Support: session-less|single-session|multi-session|session-based
                Vendor ID: &lt;data bytes&gt;
                Aux Info: &lt;data bytes&gt;

       <b>chan</b> <b>get_access</b> <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> <b>non-volatile|present|both</b>  -  Dump  information  about  the  MC's  channel
       access.   There  are  two different places where this is stored, the present in-use values (volatile) and
       the non-volatile storage that is loaded at startup.  Note  if  you  specify  channel  0xe,  the  response
       channel will be different; it will be the current channel.

       Response:
              Channel Access
                MC: &lt;mc&gt;
                Channel: &lt;integer&gt;
                Type: non-volatile|present
                Alerting Enabled: &lt;bool&gt;
                Per-Message Auth: &lt;bool&gt;
                User Auth: &lt;bool&gt;
                Access Mode: disable|pre-boot|always|shared
                Privilege Limit: callback|user|operator|admin|oem

       <b>chan</b>  <b>set_access</b> <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> <b>non-volatile|present|both</b> <b>&lt;parm&gt;</b> <b>&lt;value&gt;</b> <b>...</b>  - Set information about the
       MC's channel access.  There are two different places where this is  stored,  the  present  in-use  values
       (volatile)  and the non-volatile storage that is loaded at startup.  Note if you specify channel 0xe, the
       modified channel will be the current channel.  Parms are:
              alert true|false
              msg_auth true|false
              user_auth true|false
              access_mode disabled|pre-boot|always|shared
              privilege_limit callback|user|operator|admin|oem

       Response:
              Channel Access Set
                MC: &lt;mc&gt;
                Channel: &lt;integer&gt;

       <b>chan</b> <b>user</b> <b>list</b> <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> <b>[&lt;user</b> <b>num&gt;]</b> - List users associated with the channel.   Each  user  number
       has  an  associated name and password that is global in the MC (not associated with a channel).  There is
       also channel-specific information for each user.  This command lists the global user information and  the
       channel-specific  information for the channel specified.  If no user number is listed, then all users for
       the channel are listed.  Otherwise only the given user is listed.

       Response:
              Channel Access Set
                MC: &lt;mc&gt;
                Channel: &lt;integer&gt;
                Max User: &lt;integer&gt;
                Enabled Users: &lt;integer&gt;
                Fixed Users: &lt;integer&gt;
                User
                  Number: &lt;integer&gt;
                  *String Name: &lt;string&gt;
                  *Binary Name: &lt;data bytes&gt;
                 Link Auth Enabled: &lt;bool&gt;
                 Msg Auth Enabled: &lt;bool&gt;
                 Access CB Only: &lt;bool&gt;
                 Privilege Limit: &lt;integer&gt;
                 Session Limit: &lt;integer&gt;
                .
                .
       All the users are listed.  One of string name or binary name is present, if the name is not  a  printable
       string, then the binary data is dumped.

       <b>chan</b>  <b>user</b>  <b>set</b>  <b>&lt;mc&gt;</b>  <b>&lt;channel&gt;</b>  <b>&lt;user</b> <b>num&gt;</b> <b>&lt;parm&gt;</b> <b>&lt;value&gt;</b> <b>...</b>  - Set information about the user number.
       Only the specified values are modified.  The name and password are global values, all other are  channel-
       specific.  The parms are: are:
              link_enabled true|false
              msg_enabled true|false
              cb_only true|false
              privilege_limit callback|user|operator|admin|oem|no_access
              session_limit &lt;integer&gt;
              name &lt;user name string&gt;
              password &lt;password string, &lt;= 16 characters&gt;
              password2 &lt;password string, &lt;= 20 characters&gt;
              enable
              disable
       The  password  is the 16-byte IPMI 1.5 passwords., the password2 is for 20-byte IPMI 2.0 passwords.  Note
       that setting the session limit to zero means there is no session limit.  Also note that some systems have
       a bug where the session limit is not optional (as the spec says it is). If you get C7  errors  back  from
       this  command, you will have to always specify the session limit.  Note that you must enable the user for
       it to work, but there seems to be no way to get if the user is enabled or not.

       Response:
              User Info Set: &lt;mc&gt;

   <b>sel</b>
       Commands dealing with the system event log.  Note that there is no info command.

       <b>list</b> <b>&lt;domain&gt;</b> - The list command is unique in this object, so it is specified explicitly here.  List  the
       local copy of the system event log for the entire domain.

       Response:
              Domain
                Name: &lt;domain&gt;
                Entries: &lt;integer&gt;
                Slots in use: &lt;integer&gt;
                Event
                  **EVENT INFO**
                 .
                 .

       <b>mc_list</b> <b>&lt;domain&gt;</b> - List the local copy of the system event log on the given MC.

       Response:
              MC
                Name: &lt;mc&gt;
                Entries: &lt;integer&gt;
                Slots in use: &lt;integer&gt;
                Event
                  **EVENT INFO**
                 .
                 .

       <b>delete</b> <b>&lt;mc&gt;</b> <b>&lt;record</b> <b>#&gt;</b> - Delete the given event number from the SEL

       Response:
              Event deleted
                MC: &lt;mc&gt;
                Record: &lt;integer&gt;

       <b>add</b> <b>&lt;mc&gt;</b> <b>&lt;type&gt;</b> <b>&lt;13</b> <b>bytes</b> <b>of</b> <b>data&gt;</b> - Add the event data to the SEL.

       Response:
              MC
                Name: &lt;mc&gt;
                Record ID: &lt;integer&gt;

       <b>clear</b> <b>&lt;domain&gt;</b> - clear the system event log

       Response:
              SEL Clear done: &lt;domain&gt;

   <b>con</b>
       Commands dealing with connections.

       <b>activate</b> <b>&lt;connection&gt;</b> - Activate the given connection

       Response:
              Connection activated: &lt;connection&gt;

   <b>pet</b>
       Commands dealing with platform event traps.

       <b>new</b>  <b>&lt;domain&gt;</b> <b>&lt;connection&gt;</b> <b>&lt;channel&gt;</b> <b>&lt;ip</b> <b>addr&gt;</b> <b>&lt;mac_addr&gt;</b> <b>&lt;eft</b> <b>selector&gt;</b> &lt;policy num&gt; &lt;apt selector&gt; &lt;lan
       dest selector&gt; - Set up the domain to send PET traps from  the  given  connection  to  the  given  IP/MAC
       address over the given channel.

       Response:
              PET Created: &lt;pet&gt;

       <b>mcnew</b>  <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> <b>&lt;ip</b> <b>addr&gt;</b> <b>&lt;mac_addr&gt;</b> <b>&lt;eft</b> <b>selector&gt;</b> &lt;policy num&gt; &lt;apt selector&gt; &lt;lan dest selector&gt;
       - Set up the domain to send PET traps from the given connection to the  given  IP/MAC  address  over  the
       given channel.  This takes an MC instead of a connection.

       Response:
              PET Created: &lt;pet&gt;

       <b>close</b> <b>&lt;pet&gt;</b> - Close the pet.

       Response:
              PET destroyed: &lt;pet&gt;

   <b>pef</b>
       commands  dealing  with  platform even filters.  These are basically connections to the PEF configuration
       parameters in an MC.  You use a pef to fetch a pef config, which you can then modify and  write  back  to
       the MC.  Note that when you get a pef config, you claim a lock on the MC that must be unlocked.

       <b>new</b> <b>&lt;mc&gt;</b> - Create a pef for the given MC.

       Response:
              PEF: &lt;pef&gt;

       <b>unlock_mc</b> <b>&lt;mc&gt;</b> - Unlock the PEF lock on the given MC.

       Response:
              PEF unlocked: &lt;mc&gt;

       <b>close</b> <b>&lt;pef&gt;</b> - Free the given pef

       Response:
              PEF destroyed: &lt;pef&gt;

   <b>pef</b> <b>config</b>
       Commands dealing with PEF configurations.  These are the actual PEF data items.

       <b>get</b> <b>&lt;pef&gt;</b> - Fetch the pef data items from the pef and create a pef config.

       Response:
              PEF Config
                Name: &lt;pef config&gt;
                **PEF CONFIG**

       <b>update</b>  <b>&lt;pef</b>  <b>config&gt;</b>  <b>&lt;parm&gt;</b> <b>[selector]</b> <b>&lt;value&gt;</b> - Set the given parameter in the pef config to the given
       value.  If the parameter has a selector of some type, the selector must be given, otherwise  no  selector
       should be given.

       Response:
              PEF config updated: &lt;pef config&gt;

       <b>set</b> <b>&lt;pef&gt;</b> <b>&lt;pef</b> <b>config&gt;</b> - Write the pef data back to the pef.  Note that this must be the same pef used to
       create the config.

       Response:
              PEF config set: &lt;pef config&gt;

       <b>unlock</b> <b>&lt;pef&gt;</b> <b>&lt;pef</b> <b>config&gt;</b> - Unlock the lock in the MC and mark the pef config as unlocked.

       Response:
              PEF config unlocked: &lt;pef config&gt;

       <b>close</b> <b>&lt;pef</b> <b>config&gt;</b> - Free the pef config.

       Response:
              PEF config destroyed: &lt;pef config&gt;

   <b>lanparm</b>
       Commands  dealing  with lanparms.  These are basically connections to the LAN configuration parameters in
       an MC.  You use a lanparm to fetch a lanparm config, which you can then modify and write back to the  MC.
       Note that when you get a lanparm config, you claim a lock on the MC that must be unlocked.

       <b>new</b> <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> - Create a lanparm for the given MC and channel.

       Response:
              LANPARM: &lt;lanparm&gt;

       <b>unlock_mc</b> <b>&lt;mc&gt;</b> <b>&lt;channel&gt;</b> - Unlock the lanparm lock on the given MC and channel.

       Response:
              LANPARM unlocked: &lt;mc&gt;

       <b>close</b> <b>&lt;lanparm&gt;</b> - Free the given lanparm

       Response:
              LANPARM destroyed: &lt;lanparm&gt;

   <b>lanparm</b> <b>config</b>
       Commands dealing with lanparm configurations.  These are the actual lanparm data items.

       <b>get</b> <b>&lt;lanparm&gt;</b> - Fetch the lanparm data items from the lanparm and create a lanparm config.

       Response:
              LANPARM Config
                Name: &lt;lanparm config&gt;
                **LANPARM CONFIG**

       <b>set</b>  <b>&lt;lanparm&gt;</b> <b>&lt;lanparm</b> <b>config&gt;</b> - Write the lanparm data back to the lanparm.  Note that this must be the
       same lanparm used to create the config.

       Response:
              LANPARM config set: &lt;lanparm config&gt;

       <b>unlock</b> <b>&lt;lanparm&gt;</b> <b>&lt;lanparm</b> <b>config&gt;</b> - Unlock the lock in the MC and mark the lanparm config as unlocked.

       Response:
              LANPARM config unlocked: &lt;lanparm config&gt;

       <b>close</b> <b>&lt;lanparm</b> <b>config&gt;</b> - Free the lanparm config.

       Response:
              LANPARM config destroyed: &lt;lanparm config&gt;

</pre><h4><b>OTHER</b> <b>COMMANDS</b></h4><pre>
       A few general commands exist.

       <b>evinfo</b> <b>&lt;bool&gt;</b> - Turn on or off dumping object information when an event  comes  in.   This  is  false  by
       default.

       <b>debug</b> <b>&lt;type&gt;</b> <b>&lt;bool&gt;</b> - Turn the given debugging type on or off

</pre><h4><b>EVENTS</b></h4><pre>
       The command language will output events to the console when they happen.  Events all occur in the format:
                Event
                  **EVENT INFO**

       The  event info varies on the type of events.  The defined events are listed below.  Note that the output
       of some events depends on the setting of the <b>evinfo</b> command; the information about the object itself  may
       or may not be output.

       Some events have another event container; this is the IPMI event that caused the event to be output.

       The  following  event is output when the domain is completely up and operational and finished all it SDR,
       FRU, and bus scans:
                EVENT
                  Object Type: Domain
                  Name: &lt;domain&gt;
                  Operation: Domain fully up
                  Connection Number: &lt;integer&gt;
                  Port Number: &lt;integer&gt;
                  Any Connection Up: &lt;bool&gt;
                  Error: &lt;integer&gt;

       The following comes out when domain connection infomration changes:
                EVENT
                  Object Type: Domain
                  Name: &lt;domain&gt;
                  Operation: Connection Change

       The following comes out when domains are added:
                EVENT
                  Object Type: Domain
                  Name: &lt;domain&gt;
                  Operation: Add
                  %**DOMAIN INFO**

       The following comes out when domains are destroyed:
                EVENT
                  Object Type: Domain
                  Name: &lt;domain&gt;
                  Operation: Delete

       The following comes out when the domain gets an event that does not have a handler:
                EVENT
                  Object Type: Event
                  **EVENT INFO**

       The following comes out when an entity is added:
                EVENT
                  Object Type: Entity
                  Name: &lt;entity&gt;
                  Operation: Add
                  %**ENTITY INFO**

       The following comes out when an entity is deleted:
                EVENT
                  Object Type: Entity
                  Name: &lt;entity&gt;
                  Operation: Delete

       The following comes out when an entity is changed:
                EVENT
                  Object Type: Entity
                  Name: &lt;entity&gt;
                  Operation: Change
                  %**ENTITY INFO**

       The following comes out when an entity's FRU is added:
                EVENT
                  Object Type: Entity FRU
                  Name: &lt;entity&gt;
                  Operation: Add
                  %**FRU INFO**

       The following comes out when an entity's FRU is deleted:
                EVENT
                  Object Type: Entity FRU
                  Name: &lt;entity&gt;
                  Operation: Delete

       The following comes out when an entity's FRU is changed:
                EVENT
                  Object Type: Entity FRU
                  Name: &lt;entity&gt;
                  Operation: Change
                  %**FRU INFO**

       The following comes out when an entity's presence changes:
                EVENT
                  Object Type: Entity
                  Name: &lt;entity&gt;
                  Operation: Presence Change
                  Present: &lt;bool&gt;
                  %Event
                    **EVENT INFO**

       The following comes out when an entity's hot-swap state changes:
                EVENT
                  Object Type: Entity
                  Name: &lt;entity&gt;
                  Operation: Hot-Swap Change
                  Last State: &lt;hot-swap state&gt;
                  State: &lt;hot-swap state&gt;
                  %Event
                    **EVENT INFO**

       The following comes out when an MC is added:
                EVENT
                  Object Type: MC
                  Name: &lt;mc&gt;
                  Operation: Add
                  %**MC INFO**

       The following comes out when an MC is removed:
                EVENT
                  Object Type: MC
                  Name: &lt;mc&gt;
                  Operation: Delete

       The following comes out when an MC is changed:
                EVENT
                  Object Type: MC
                  Name: &lt;mc&gt;
                  Operation: Change
                  %**MC INFO**

       The following comes out when an MC changes active state:
                EVENT
                  Object Type: MC
                  Name: &lt;mc&gt;
                  Operation: Active Changed
                  Active: &lt;bool&gt;

       The following comes out when a discrete sensor gets an event:
                EVENT
                  Object Type: Sensor
                  Name: &lt;sensor&gt;
                  Operation: Event
                  Offset: &lt;integer&gt;
                  Direction: assertion | deassertion
                  Severity: &lt;integer&gt;
                  Previous Severity: &lt;integer&gt;
                  %Event
                    **EVENT INFO**

       The following comes out when a threshold sensor gets an event:
                EVENT
                  Object Type: Sensor
                  Name: &lt;sensor&gt;
                  Operation: Event
                  Threshold: &lt;threshold&gt;
                  High/Low: going-high | going-low
                  Direction: assertion | deassertion
                  %Value: &lt;double&gt;
                  %Raw Value: &lt;integer&gt;
                  %Event
                    **EVENT INFO**

       The following comes out when a sensor is added:
                EVENT
                  Object Type: Sensor
                  Name: &lt;sensor&gt;
                  Operation: Add
                  %**SENSOR INFO**

       The following comes out when a sensor is deleted:
                EVENT
                  Object Type: Sensor
                  Name: &lt;sensor&gt;
                  Operation: Delete

       The following comes out when a sensor is changed:
                EVENT
                  Object Type: Sensor
                  Name: &lt;sensor&gt;
                  Operation: Change
                  %**SENSOR INFO**

       The following comes out when a control gets an event:
                EVENT
                  Object Type: Control
                  Name: &lt;control&gt;
                  Operation: Event
                  Value
                    Number: &lt;integer&gt;
                    Value: &lt;integer&gt;
                  %Event
                    **EVENT INFO**

       The following comes out when a control is added:
                EVENT
                  Object Type: Control
                  Name: &lt;control&gt;
                  Operation: Add
                  %**CONTROL INFO**

       The following comes out when a control is deleted:
                EVENT
                  Object Type: Control
                  Name: &lt;control&gt;
                  Operation: Delete

       The following comes out when a control is changed:
                EVENT
                  Object Type: Control
                  Name: &lt;control&gt;
                  Operation: Change
                  %**CONTROL INFO**

</pre><h4><b>OBJECT</b> <b>INFO</b></h4><pre>
       Many of the command responses and events contain information about an objects.  The definitions  of  this
       information output is done here.

   <b>**EVENT</b> <b>INFO**</b>
                MC: &lt;mc&gt;
                Record ID: &lt;integer&gt;
                Event type: &lt;integer&gt;
                Timestamp: &lt;integer&gt;
                Data: &lt;data bytes&gt;

   <b>**DOMAIN</b> <b>INFO**</b>
                Type: &lt;domain type&gt;
                GUID: &lt;hex string&gt;
                SEL Rescan Time: &lt;time&gt;
                IPMB Rescan Time: &lt;time&gt;

   <b>**ENTITY</b> <b>INFO**</b>
                Type: unknown | mc | fru | generic
                Present: &lt;bool&gt;
                Presence sensor always there: &lt;bool&gt;
                Hot swappable: &lt;bool&gt;
                %Supports managed hot swap: &lt;bool&gt;
                %Parents
                  Name: &lt;entity&gt;
                  Name: &lt;entity&gt;
                   .
                   .
                %Children
                  Name: &lt;entity&gt;
                  Name: &lt;entity&gt;
                   .
                   .
                %Physical Slot: &lt;integer&gt;
                %Id: &lt;string&gt;
                Entity ID String: &lt;string&gt;

       Note that Parents and Children fields will not be present if the entity has no parents or children.  Each
       entity type except <b>unknown</b> will have its own output info.  These are:

       <b>mc</b>
                Channel: &lt;channel&gt;
                LUN: &lt;lun&gt;
                OEM: &lt;oem field from SDR&gt;
                Slave Address: &lt;ipmb&gt;
                ACPI_system_power_notify_required: &lt;bool&gt;
                ACPI_device_power_notify_required: &lt;bool&gt;
                controller_logs_init_agent_errors: &lt;bool&gt;
                log_init_agent_errors_accessing: &lt;bool&gt;
                global_init: &lt;bool&gt;
                chassis_device: &lt;bool&gt;
                bridge: &lt;bool&gt;
                IPMB_event_generator: &lt;bool&gt;
                IPMB_event_receiver: &lt;bool&gt;
                FRU_inventory_device: &lt;bool&gt;
                SEL_device: &lt;bool&gt;
                SDR_repository_device: &lt;bool&gt;
                sensor_device: &lt;bool&gt;

       <b>fru</b>
                Channel: &lt;channel&gt;
                LUN: &lt;lun&gt;
                OEM: &lt;oem field from SDR&gt;
                Slave Address: &lt;ipmb&gt;
                access_address: &lt;ipmb&gt;
                private_bus_id: &lt;integer&gt;
                device_type: &lt;integer&gt;
                device_modifier: &lt;integer&gt;
                is_logical_fru: &lt;bool&gt;
                fru_device_id: &lt;integer&gt;

       <b>generic</b>
                Channel: &lt;channel&gt;
                LUN: &lt;lun&gt;
                OEM: &lt;oem field from SDR&gt;
                access_address: &lt;ipmb&gt;
                private_bus_id: &lt;integer&gt;
                device_type: &lt;integer&gt;
                device_modifier: &lt;integer&gt;
                slave_address: &lt;ipmb&gt;
                address_span: &lt;integer&gt;

   <b>**MC</b> <b>INFO**</b>
                Active: &lt;bool&gt;
                GUID: &lt;hex string&gt;
                SEL Rescan Time: &lt;integer&gt;
                provides_device_sdrs: &lt;bool&gt;
                device_available: &lt;bool&gt;
                chassis_support: &lt;bool&gt;
                bridge_support: &lt;bool&gt;
                ipmb_event_generator: &lt;bool&gt;
                ipmb_event_receiver: &lt;bool&gt;
                fru_inventory_support: &lt;bool&gt;
                sel_device_support: &lt;bool&gt;
                sdr_repository_support: &lt;bool&gt;
                sensor_device_support: &lt;bool&gt;
                device_id: &lt;ipmb&gt;
                device_revision: &lt;integer&gt;
                fw_revision: &lt;integer&gt;.&lt;integer&gt;
                version: &lt;integer&gt;.&lt;integer&gt;
                manufacturer_id: &lt;integer&gt;
                product_id: &lt;integer&gt;
                aux_fw_revision: &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;

   <b>*SENSOR</b> <b>INFO**</b>
                LUN: &lt;integer&gt;
                Number: &lt;integer&gt;
                Event Reading Type: &lt;integer&gt;
                Event Reading Type Name: one of:
                         unspecified threshold discrete_usage discrete_state
                         discrete_predictive_failure discrete_limit_exceeded
                         discrete_performance_met discrete_severity discrete_device_presence
                         discrete_device_enable discrete_availability discrete_redundancy
                         discrete_acpi_power
                Type: &lt;integer&gt;
                Type Name: &lt;sensor type (a generic string)&gt;
                %Direction: input | output
                %Event Support: per state | entire sensor | global
                Init Scanning: &lt;bool&gt;
                Init Events: &lt;bool&gt;
                Init Thresholds: &lt;bool&gt;
                Init Hysteresis: &lt;bool&gt;
                Init Type: &lt;bool&gt;
                Init Power Up Events: &lt;bool&gt;
                Init Power Up Scanning: &lt;bool&gt;
                Ignore If No Entity: &lt;bool&gt;
                Auto Rearm: &lt;bool&gt;
                OEM1: &lt;integer&gt;
                Id: &lt;string&gt;

       For threshold sensors, the following exist:
                Threshold Access: none | readable | settable | fixed
                Threshold
                  Name: &lt;threshold&gt;
                  Readable: &lt;bool&gt;
                  Settable: &lt;bool&gt;
                  Supports: going high assertion | going low assertion
                            | going high deassertion | going low deassertion
                 .
                 .
                Hysteresis Support: none | readable | settable | fixed
                %Nominal Reading: &lt;float&gt;
                %Normal Max: &lt;float&gt;
                %Normal Min: &lt;float&gt;
                %Sensor Max: &lt;float&gt;
                %Sensor Min: &lt;float&gt;
                Base Unit: &lt;integer&gt;
                Base Unit Name: &lt;string&gt;
                %Rate Unit: &lt;integer&gt;
                %Rate Unit Name: &lt;string&gt;
                %Modifier Use: / | *
                %Modifier Unit: &lt;integer&gt;
                %Modifier Unit Name: &lt;string&gt;

       For discrete sensors, the following exist:
                Event
                  Offset: &lt;integer&gt;
                  Supports: assertion | deassertion
                 .
                 .

   <b>**CONTROL</b> <b>INFO**</b>
                Type: &lt;control type&gt;
                Generates Events: &lt;bool&gt;
                Settable: &lt;bool&gt;
                Readable: &lt;bool&gt;
                Num Values: &lt;integer&gt;
                Id: &lt;string&gt;

       Controls of type light that are set with settings have the following:
                Set with: settings
                Local Control: &lt;bool&gt;
                Color: &lt;color&gt;
                 .
                 .
       One color is listed for each supported color

       Controls of type light that are set with transitions have the following:
                Light
                  Number: &lt;integer&gt;
                  Num Values: &lt;integer&gt;
                  Value
                    Number: &lt;integer&gt;
                    Num Transitions: &lt;integer&gt;
                    Transition
                      Number: &lt;integer&gt;
                      Color: &lt;color&gt;
                      Time: &lt;integer&gt;
                     .
                     .
                   .
                   .

       Controls of type identifier have the following:
                Max Length: &lt;integer&gt;

   <b>**FRU</b> <b>INFO**</b>
                Name: &lt;fru&gt;
                record
                  Name: &lt;name&gt;
                  Type: binary | ascii | unicode | integer
                  %Number: &lt;integer&gt;
                  Data: data depending on type
                 .
                 .
                Multi-record
                  Number: &lt;integer&gt;
                  Type: binary | ascii | unicode
                  Data: &lt;data in the above format&gt;
                 .
                 .

   <b>**LANPARM</b> <b>CONFIG**</b>
                support_auth_oem: &lt;bool&gt;
                support_auth_straight: &lt;bool&gt;
                support_auth_md5: &lt;bool&gt;
                support_auth_md2: &lt;bool&gt;
                support_auth_none: &lt;bool&gt;
                ip_addr_source: &lt;integer&gt;
                num_alert_destinations: &lt;integer&gt;
                %ipv4_ttl: &lt;integer&gt;
                %ipv4_flags: &lt;integer&gt;
                %ipv4_precedence: &lt;integer&gt;
                %ipv4_tos: &lt;integer&gt;
                %ip_addr: &lt;ip addr&gt;
                %mac_addr: &lt;mac addr&gt;
                %subnet_mask: &lt;ip addr&gt;
                %primary_rmcp_port &lt;integer&gt;
                %secondary_rmcp_port &lt;integer&gt;
                %bmc_generated_arps: &lt;bool&gt;
                %bmc_generated_garps: &lt;bool&gt;
                %garp_interval: &lt;integer&gt;
                %default_gateway_ip_addr: &lt;ip addr&gt;
                %default_gateway_mac_addr: &lt;mac addr&gt;
                %backup_gateway_ip_addr: &lt;ip addr&gt;
                %backup_gateway_mac_addr: &lt;mac addr&gt;
                community_string: &lt;string&gt;
                User
                  Name: callback
                  enable_auth_oem: &lt;bool&gt;
                  enable_auth_straight: &lt;bool&gt;
                  enable_auth_md5: &lt;bool&gt;
                  enable_auth_md2: &lt;bool&gt;
                  enable_auth_none: &lt;bool&gt;
                User
                  Name: user
                  enable_auth_oem: &lt;bool&gt;
                  enable_auth_straight: &lt;bool&gt;
                  enable_auth_md5: &lt;bool&gt;
                  enable_auth_md2: &lt;bool&gt;
                  enable_auth_none: &lt;bool&gt;
                User
                  Name: operator
                  enable_auth_oem: &lt;bool&gt;
                  enable_auth_straight: &lt;bool&gt;
                  enable_auth_md5: &lt;bool&gt;
                  enable_auth_md2: &lt;bool&gt;
                  enable_auth_none: &lt;bool&gt;
                User
                  Name: admin
                  enable_auth_oem: &lt;bool&gt;
                  enable_auth_straight: &lt;bool&gt;
                  enable_auth_md5: &lt;bool&gt;
                  enable_auth_md2: &lt;bool&gt;
                  enable_auth_none: &lt;bool&gt;
                User
                  Name: oem
                  enable_auth_oem: &lt;bool&gt;
                  enable_auth_straight: &lt;bool&gt;
                  enable_auth_md5: &lt;bool&gt;
                  enable_auth_md2: &lt;bool&gt;
                  enable_auth_none: &lt;bool&gt;
                Alert Destination
                  Number: &lt;integer&gt;
                  alert_ack: &lt;bool&gt;
                  dest_type: &lt;integer&gt;
                  alert_retry_interval: &lt;integer&gt;
                  max_alert_retries: &lt;integer&gt;
                  dest_format: &lt;integer&gt;
                  gw_to_use: &lt;integer&gt;
                  dest_ip_addr: &lt;ip addr&gt;
                  dest_mac_addr: &lt;mac addr&gt;
                 .
                 .

   <b>**PEF</b> <b>CONFIG**</b>
                alert_startup_delay_enabled: &lt;bool&gt;
                startup_delay_enabled: &lt;bool&gt;
                event_messages_enabled: &lt;bool&gt;
                pef_enabled: &lt;bool&gt;
                diagnostic_interrupt_enabled: &lt;bool&gt;
                oem_action_enabled: &lt;bool&gt;
                power_cycle_enabled: &lt;bool&gt;
                reset_enabled: &lt;bool&gt;
                power_down_enabled: &lt;bool&gt;
                alert_enabled: &lt;bool&gt;
                %startup_delay: &lt;integer&gt;
                %alert_startup_delay: &lt;integer&gt;
                guid_enabled: &lt;bool&gt;
                guid_val: &lt;guid&gt;
                num_event_filters: &lt;integer&gt;
                num_alert_policies: &lt;integer&gt;
                num_alert_strings: &lt;integer&gt;
                Event Filter
                  Number: &lt;integer&gt;
                  enable_filter: &lt;bool&gt;
                  filter_type: &lt;integer&gt;
                  diagnostic_interrupt: &lt;bool&gt;
                  oem_action: &lt;bool&gt;
                  power_cycle: &lt;bool&gt;
                  reset: &lt;bool&gt;
                  power_down: &lt;bool&gt;
                  alert: &lt;bool&gt;
                  alert_policy_number: &lt;integer&gt;
                  event_severity: &lt;integer&gt;
                  generator_id_addr: &lt;integer&gt;
                  generator_id_channel_lun: &lt;integer&gt;
                  sensor_type: &lt;integer&gt;
                  sensor_number: &lt;integer&gt;
                  event_trigger: &lt;integer&gt;
                  data1_offset_mask: &lt;integer&gt;
                  data1_mask: &lt;integer&gt;
                  data1_compare1: &lt;integer&gt;
                  data1_compare2: &lt;integer&gt;
                  data2_mask: &lt;integer&gt;
                  data2_compare1: &lt;integer&gt;
                  data2_compare2: &lt;integer&gt;
                  data3_mask: &lt;integer&gt;
                  data3_compare1: &lt;integer&gt;
                  data3_compare2: &lt;integer&gt;
                 .
                 .
                Alert Policy
                  Number: &lt;integer&gt;
                  policy_num: &lt;integer&gt;
                  enabled: &lt;bool&gt;
                  policy: &lt;integer&gt;
                  channel: &lt;integer&gt;
                  destination_selector: &lt;integer&gt;
                  alert_string_event_specific: &lt;bool&gt;
                  alert_string_selector: &lt;integer&gt;
                 .
                 .
                Alert String
                  event_filter: &lt;integer&gt;
                  alert_string_set: &lt;integer&gt;
                  alert_string: &lt;string&gt;
                 .
                 .

   <b>**CONNECTION</b> <b>INFO**</b>
                Active: &lt;bool&gt;
                Up: &lt;bool&gt;
                Port
                  Number: &lt;integer&gt;
                  Info: &lt;info string&gt;
                  Up: &lt;bool&gt;
                 .
                 .

   <b>**PEF</b> <b>INFO**</b>
                MC: &lt;mc&gt;

   <b>**PET</b> <b>INFO**</b>
                MC: &lt;mc&gt;
                Channel: &lt;channel&gt;
                IP Address: &lt;ip address&gt;
                MAC Address: &lt;mac address&gt;
                EFT Selector: &lt;eft selector&gt;
                Policy Number: &lt;policy number&gt;
                APT Selector: &lt;apt selector&gt;
                LAN Dest Selector: &lt;lan dest selector&gt;

   <b>**LANPARM</b> <b>INFO**</b>
                MC: &lt;mc&gt;
                Channel: &lt;integer&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ipmish.1.html">ipmish</a></b>(1)

</pre><h4><b>KNOWN</b> <b>PROBLEMS</b></h4><pre>
       None

</pre><h4><b>AUTHOR</b></h4><pre>
       Corey Minyard &lt;<a href="mailto:cminyard@mvista.com">cminyard@mvista.com</a>&gt;

OpenIPMI                                            05/13/03                                     <u><a href="../man7/ipmi_cmdlang.7.html">ipmi_cmdlang</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>