<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fennel-tutorial - Getting Started with Fennel</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/fennel">fennel_1.5.3+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fennel-tutorial - Getting Started with Fennel

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  programming  language  is made up of <b>syntax</b> and <b>semantics</b>.  The semantics of Fennel vary only in small
       ways from Lua (all noted below).  The syntax of Fennel comes from the lisp family  of  languages.   Lisps
       have  syntax  which is very uniform and predictable, which makes it easier to write code that operates on
       code   (https://stopa.io/post/265)   as   well   as   structured   editing    (<a href="http://danmidwood.com/con">http://danmidwood.com/con</a>‐
       tent/2014/11/21/animated-paredit.html).

       If  you know Lua and a lisp already, you'll feel right at home in Fennel.  Even if not, Lua is one of the
       simplest programming languages in existence, so if you've programmed before you should be able to pick it
       up without too much trouble, especially if you've used another dynamic imperative language with closures.
       The Lua reference manual (https://www.lua.org/manual/5.4/) is a fine place to look for details, but  Fen‐
       nel's own Lua Primer (https://fennel-lang.org/lua-primer) is shorter and covers the highlights.

       If you've already got some Lua example code and you just want to see how it would look in Fennel, you can
       learn a lot from putting it in antifennel (https://fennel-lang.org/see).

</pre><h4><b>OK,</b> <b>SO</b> <b>HOW</b> <b>DO</b> <b>YOU</b> <b>DO</b> <b>THINGS?</b></h4><pre>
   <b>Functions</b> <b>and</b> <b>lambdas</b>
       Use  <b>fn</b>  to  make functions.  If you provide an optional name, the function will be bound to that name in
       local scope; otherwise it is simply an anonymous value.

              A brief note on naming: identifiers are typically  lowercase  separated  by  dashes  (aka  "kebab-
              case").   They  may contain digits too, as long as they're not at the start.  You can also use the
              question mark (typically for functions that return a true or false, ex.,  <b>at-max-velocity?</b>).   Un‐
              derscores (<b>_</b>) are often used to name a variable that we don't plan on using.

       The argument list is provided in square brackets.  The final value in the body is returned.

       (If  you've  never  used a lisp before, the main thing to note is that the function or macro being called
       goes <u>inside</u> the parens, not outside.)

              (fn print-and-add [a b c]
                (print a)
                (+ b c))

       Functions can take an optional docstring in the form of a string that immediately  follows  the  argument
       list.  Under normal compilation, this is removed from the emitted Lua, but during development in the REPL
       the docstring and function usage can be viewed with the <b>,doc</b> command:

              (fn print-sep [sep ...]
                "Prints args as a string, delimited by sep"
                (print (table.concat [...] sep)))
              ,doc print-sep ; -&gt; outputs:
              ;; (print-sep sep ...)
              ;;   Prints args as a string, delimited by sep

       Like other lisps, Fennel uses semicolons for comments.

       Functions  defined  with  <b>fn</b> are fast; they have no runtime overhead compared to Lua.  However, they also
       have no arity checking.  (That is, calling a function with the wrong number of arguments does  not  cause
       an  error.)   For  safer code you can use <b>lambda</b> which ensures you will get at least as many arguments as
       you define, unless you signify that one may be omitted by beginning its name with a <b>?</b>:

              (lambda print-calculation [x ?y z]
                (print (- x (* (or ?y 1) z))))

              (print-calculation 5) ; -&gt; error: Missing argument z

       Note that the second argument <b>?y</b> is allowed to be <b>nil</b>, but <b>z</b> is not:

              (print-calculation 5 nil 3) ; -&gt; 2

       Like <b>fn</b>, lambdas accept an optional docstring after the argument list.

   <b>Locals</b> <b>and</b> <b>variables</b>
       Locals are introduced using <b>let</b> with the names and values wrapped in a single set of square brackets:

              (let [x (+ 89 5.2)
                    f (fn [abc] (print (* 2 abc)))]
                (f x))

       Here <b>x</b> is bound to the result of adding 89 and 5.2, while <b>f</b> is bound to a function that prints twice  its
       argument.  These bindings are only valid inside the body of the <b>let</b> call.

       You  can  also introduce locals with <b>local</b>, which is nice when they'll be used across the whole file, but
       in general <b>let</b> is preferred inside functions because it's clearer at a glance  where  the  value  can  be
       used:

              (local tau-approx 6.28318)

       Locals  set  this  way cannot be given new values, but you <u>can</u> introduce new locals that shadow the outer
       names:

              (let [x 19]
                ;; (set x 88) &lt;- not allowed!
                (let [x 88]
                  (print (+ x 2))) ; -&gt; 90
                (print x)) ; -&gt; 19

       If you need to change the value of a local, you can use <b>var</b> which works like <b>local</b> except it  allows  <b>set</b>
       to work on it.  There is no nested <b>let</b>-like equivalent of <b>var</b>.

              (var x 19)
              (set x (+ x 8))
              (print x) ; -&gt; 27

   <b>Numbers</b> <b>and</b> <b>strings</b>
       Of course, all our standard arithmetic operators like <b>+</b>, <b>-</b>, <b>*</b>, and <b>/</b> work here in prefix form.  Note that
       numbers  are double-precision floats in all Lua versions prior to 5.3, which introduced integers.  On 5.3
       and up, integer division uses <b>//</b> and bitwise operations use <b>lshift</b>, <b>rshift</b>,  <b>bor</b>,  <b>band</b>,  <b>bnot</b>  and  <b>xor</b>.
       Bitwise  operators  and  integer division will not work if the host Lua environment is older than version
       5.3.

       You may also use underscores to separate sections of long numbers.  The underscores have no effect on the
       value.

              (let [x (+ 1 99)
                    y (- x 12)
                    z 100_000]
                (+ z (/ y 10)))

       Strings are essentially immutable byte arrays.  UTF-8 support is provided in the <b>utf8</b> table in  Lua  5.3+
       (https://www.lua.org/manual/5.3/manual.html#6.5)  or  from  a  3rd-party library (https://github.com/Ste‐
       pets/utf8.lua) in earlier versions.  Strings are concatenated with <b>..</b>:

              (.. "hello" " world")

   <b>Tables</b>
       In Lua (and thus in Fennel), tables are the only data structure.  The main syntax for tables  uses  curly
       braces with key/value pairs in them:

              {"key" value
               "number" 531
               "f" (fn [x] (+ x 2))}

       You can use <b>.</b> to get values out of tables:

              (let [tbl (function-which-returns-a-table)
                    key "a certain key"]
                (. tbl key))

       And <b>tset</b> to put them in:

              (let [tbl {}
                    key1 "a long string"
                    key2 12]
                (tset tbl key1 "the first value")
                (tset tbl key2 "the second one")
                tbl) ; -&gt; {"a long string" "the first value" 12 "the second one"}

   <b>Sequential</b> <b>Tables</b>
       Some  tables  are  used  to  store  data that's used sequentially; the keys in this case are just numbers
       starting with 1 and going up.  Fennel provides alternate syntax for these tables with square brackets:

              ["abc" "def" "xyz"] ; equivalent to {1 "abc" 2 "def" 3 "xyz"}

       Lua's built-in <b>table.insert</b> function is meant to be used with sequential tables; all values after the in‐
       serted value are shifted up by one index: If you don't provide an index to <b>table.insert</b> it will append to
       the end of the table.

       The <b>table.remove</b> function works similarly; it takes a table and an index (which defaults to  the  end  of
       the table) and removes the value at that index, returning it.

              (local ltrs ["a" "b" "c" "d"])

              (table.remove ltrs)       ; Removes "d"
              (table.remove ltrs 1)     ; Removes "a"
              (table.insert ltrs "d")   ; Appends "d"
              (table.insert ltrs 1 "a") ; Prepends "a"

              (. ltrs 2)                ; -&gt; "b"
              ;; ltrs is back to its original value ["a" "b" "c" "d"]

       The <b>length</b> form returns the length of sequential tables and strings:

              (let [tbl ["abc" "def" "xyz"]]
                (+ (length tbl)
                   (length (. tbl 1)))) ; -&gt; 6

       Note that the length of a table with gaps in it is undefined; it can return a number corresponding to any
       of the table's "boundary" positions between nil and non-nil values.

       Lua's  standard  library  is very small, and thus several functions you might expect to be included, such
       <b>map</b>, <b>reduce</b>, and <b>filter</b> are absent.  In Fennel macros are used for this instead; see  <b>icollect</b>,  <b>collect</b>,
       and <b>accumulate</b>.

   <b>Iteration</b>
       Looping  over  table  elements  is done with <b>each</b> and an iterator like <b>pairs</b> (used for general tables) or
       <b>ipairs</b> (for sequential tables):

              (each [key value (pairs {"key1" 52 "key2" 99})]
                (print key value))

              (each [index value (ipairs ["abc" "def" "xyz"])]
                (print index value))

       Note that whether a table is sequential or not is not an inherent property of the table  but  depends  on
       which  iterator is used with it.  You can call <b>ipairs</b> on any table, and it will only iterate over numeric
       keys starting with 1 until it hits a <b>nil</b>.

       You can use any Lua iterator (https://www.lua.org/pil/7.1.html) with <b>each</b>, but these are the most common.
       Here's an example that walks through matches in a string (https://www.lua.org/manual/5.4/manual.html#pdf-
       string.gmatch):

              (var sum 0)
              (each [digits (string.gmatch "244 127 163" "%d+")]
                (set sum (+ sum (tonumber digits))))

       If you want to get a table back, try <b>icollect</b> to get a sequential table or <b>collect</b>  to  get  a  key/value
       one.  A body which returns nil will cause that to be omitted from the resulting table.

              (icollect [_ s (ipairs [:greetings :my :darling])]
                (if (not= :my s)
                    (s:upper)))
              ;; -&gt; ["GREETINGS" "DARLING"]

              (collect [_ s (ipairs [:greetings :my :darling])]
                s (length s))
              ;; -&gt; {:darling 7 :greetings 9 :my 2}

       A  lower-level iteration construct is <b>for</b> which iterates numerically from the provided start value to the
       inclusive finish value:

              (for [i 1 10]
                (print i))

       You can specify an optional step value; this loop will only print odd numbers under ten:

              (for [i 1 10 2]
                (print i))

   <b>Looping</b>
       If you need to loop but don't know how many times, you can use <b>while</b>:

              (while (keep-looping?)
                (do-something))

   <b>Conditionals</b>
       Finally we have conditionals.  The <b>if</b> form in Fennel can be used the same way as in other lisp languages,
       but it can also be used as <b>cond</b> for multiple conditions compiling into <b>elseif</b> branches:

              (let [x (math.random 64)]
                (if (= 0 (% x 2))
                    "even"
                    (= 0 (% x 9))
                    "multiple of nine"
                    "I dunno, something else"))

       With an odd number of arguments, the final clause is interpreted as "else".

       Being a lisp, Fennel has no statements, so <b>if</b> returns a value as an expression.  Lua programmers will  be
       glad to know there is no need to construct precarious chains of <b>and</b>/<b>or</b> just to get a value!

       The  other  conditional  is  <b>when</b>,  which is used for an arbitrary number of side-effects and has no else
       clause:

              (when (currently-raining?)
                (wear "boots")
                (deploy-umbrella))

</pre><h4><b>BACK</b> <b>TO</b> <b>TABLES</b> <b>JUST</b> <b>FOR</b> <b>A</b> <b>BIT</b></h4><pre>
       Strings that don't have spaces or reserved characters in them can  use  the  <b>:shorthand</b>  syntax  instead,
       which is often used for table keys:

              {:key value :number 531}

       If  a  table  has  string keys like this, you can pull values out of it easily with a dot if the keys are
       known up front:

              (let [tbl {:x 52 :y 91}]
                (+ tbl.x tbl.y)) ; -&gt; 143

       You can also use this syntax with <b>set</b>:

              (let [tbl {}]
                (set tbl.one 1)
                (set tbl.two 2)
                tbl) ; -&gt; {:one 1 :two 2}

       If a table key has the same name as the variable you're setting it to, you can omit the key name and  use
       <b>:</b> instead:

              (let [one 1 two 2
                    tbl {: one : two}]
                tbl) ; -&gt; {:one 1 :two 2}

       Finally, <b>let</b> can destructure a table into multiple locals.

       There is positional destructuring:

              (let [data [1 2 3]
                    [fst snd thrd] data]
                (print fst snd thrd)) ; -&gt; 1       2       3

       And destructuring of tables via key:

              (let [pos {:x 23 :y 42}
                    {:x x-pos :y y-pos} pos]
                (print x-pos y-pos)) ; -&gt; 23      42

       As  above,  if a table key has the same name as the variable you're destructuring it to, you can omit the
       key name and use <b>:</b> instead:

              (let [pos {:x 23 :y 42}
                    {: x : y} pos]
                (print x y)) ; -&gt; 23      42

       This can nest and mix and match:

              (let [f (fn [] ["abc" "def" {:x "xyz" :y "abc"}])
                    [a d {:x x : y}] (f)]
                (print a d)
                (print x y))

       If the size of the table doesn't match the number of binding locals, missing values are filled  with  <b>nil</b>
       and  extra values are discarded.  Note that unlike many languages, <b>nil</b> in Lua actually represents the ab‐
       sence of a value, and thus tables cannot contain <b>nil</b>.  It is an error to try to use <b>nil</b> as a key, and us‐
       ing <b>nil</b> as a value removes whatever entry was at that key before.

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       Errors in Lua have two forms they can take.  Functions in Lua can return any number of values,  and  most
       functions which can fail will indicate failure by using two return values: <b>nil</b> followed by a failure mes‐
       sage string.  You can interact with this style of function in Fennel by destructuring with parens instead
       of square brackets:

              (case (io.open "file")
                ;; when io.open succeeds, it will return a file, but if it fails
                ;; it will return nil and an err-msg string describing why
                f (do (use-file-contents (f:read :*all))
                      (f:close))
                (nil err-msg) (print "Could not open file:" err-msg))

       You can write your own function which returns multiple values with <b>values</b>.

              (fn use-file [filename]
                (if (valid-file-name? filename)
                    (open-file filename)
                    (values nil (.. "Invalid filename: " filename))))

       <b>Note</b>:  while  errors are the most common reason to return multiple values from a function, it can be used
       in other cases as well.  This is the most complex thing about Lua, and a full discussion is out of  scope
       for  this  tutorial, but it's covered well elsewhere (https://benaiah.me/posts/everything-you-didnt-want-
       to-know-about-lua-multivals/).

       The problem with this type of error is that it does not compose well; the error status must be propagated
       all the way along the call chain from inner to outer.  To address this, you can  use  <b>error</b>.   This  will
       terminate  the  whole  process unless it's within a protected call, similar to the way in other languages
       where throwing an exception will stop the program unless it is within a try/catch.  You can make  a  pro‐
       tected call with <b>pcall</b>:

              (let [(ok? val-or-msg) (pcall potentially-disastrous-call filename)]
                (if ok?
                    (print "Got value" val-or-msg)
                    (print "Could not get value:" val-or-msg)))

       The  <b>pcall</b>  invocation  there  means  you are running <b>(potentially-disastrous-call</b> <b>filename)</b> in protected
       mode.  <b>pcall</b> takes an arbitrary number of arguments which are passed on to the  function.   You  can  see
       that  <b>pcall</b> returns a boolean (<b>ok?</b> here) to let you know if the call succeeded or not, and a second value
       (<b>val-or-msg</b>) which is the actual value if it succeeded or an error message if it didn't.

       The <b>assert</b> function takes a value and an error message; it calls <b>error</b> if the value is <b>nil</b> and returns it
       otherwise.  This can be used to turn multiple-value failures into errors (kind of the  inverse  of  <b>pcall</b>
       which turns <b>error</b>s into multiple-value failures):

              (let [f (assert (io.open filename))
                    contents (f.read f "*all")]
                (f.close f)
                contents)

       In  this example because <b>io.open</b> returns <b>nil</b> and an error message upon failure, a failure will trigger an
       <b>error</b> and halt execution.

</pre><h4><b>VARIADIC</b> <b>FUNCTIONS</b></h4><pre>
       Fennel supports variadic functions (in other words, functions which take any number  of  arguments)  like
       many  languages.   The  syntax for taking a variable number of arguments to a function is the <b>...</b> symbol,
       which must be the last parameter to a function.  This syntax is inherited from Lua rather than Lisp.

       The <b>...</b> form is not a list or first class value, it expands to multiple values inline.  To  access  indi‐
       vidual  elements of the vararg, you can destructure with parentheses, or first wrap it in a table literal
       (<b>[...]</b>) and index like a normal table, or use the <b>select</b> function from Lua's core  library.   Often,  the
       vararg can be passed directly to another function such as <b>print</b> without needing to bind it.

              (fn print-each [...]
                (each [i v (ipairs [...])]
                  (print (.. "Argument " i " is " v))))

              (print-each :a :b :c)

              (fn myprint [prefix ...]
                (io.write prefix)
                (io.write (.. (select "#" ...) " arguments given: "))
                (print ...))

              (myprint ":D " :d :e :f)

       Varargs are scoped differently than other variables as well - they are only accessible to the function in
       which  they  are  created.   Unlike normal values, functions cannot close over them.  This means that the
       following code will NOT work, as the varargs in the inner function are out of scope.

              (fn badcode [...]
                (fn []
                  (print ...)))

</pre><h4><b>STRICT</b> <b>GLOBAL</b> <b>CHECKING</b></h4><pre>
       If you get an error that says <b>unknown</b> <b>global</b> <b>in</b> <b>strict</b> <b>mode</b> it means that you're trying compile code that
       uses a global which the Fennel compiler doesn't know about.  Most of the time, this is due  to  a  coding
       mistake.  However, in some cases you may get this error with a legitimate global reference.  If this hap‐
       pens,  it may be due to an inherent limitation of Fennel's strategy.  You can use <b>_G.myglobal</b> to refer to
       it in a way that works around this check and calls attention to the fact that this is in fact a global.

       Another    possible    cause    for    this    error    is    a     modified     function     environment
       (https://www.lua.org/pil/14.3.html).  The solution depends on how you're using Fennel:

       • Embedded  Fennel can have its searcher modified to ignore certain (or all) globals via the <b>allowedGlob‐</b>
         <b>als</b> parameter.  See the Lua API (https://fennel-lang.org/api) page for instructions.

       • Fennel's CLI has the <b>--globals</b> parameter, which accepts a comma-separated list of  globals  to  ignore.
         For example, to disable strict mode for globals x, y, and z:

                fennel --globals x,y,z yourfennelscript.fnl

</pre><h4><b>GOTCHAS</b></h4><pre>
       There  are  a few surprises that might bite seasoned lispers.  Most of these result necessarily from Fen‐
       nel's insistence upon imposing zero runtime overhead over Lua.

       • The arithmetic, comparison, and boolean operators are not first-class functions.  They  can  behave  in
         surprising  ways with multiple-return-valued functions, because the number of arguments to them must be
         known at compile-time.

       • There is no <b>apply</b> function; instead use <b>table.unpack</b> or <b>unpack</b> depending on your Lua version:  <b>(f</b>  <b>1</b>  <b>3</b>
         <b>(table.unpack</b> <b>[4</b> <b>9]))</b>.

       • Tables  are  compared  for equality by identity, not based on the value of their contents, as per Baker
         (https://p.hagelb.org/equal-rights-for-functional-objects.html).

       • Return values in the repl will get pretty-printed, but calling <b>(print</b> <b>tbl)</b> will emit output like <b>table:</b>
         <b>0x55a3a8749ef0</b>.  If you don't already have one, it's recommended for  debugging  to  define  a  printer
         function  which  calls <b>fennel.view</b> on its argument before printing it: <b>(local</b> <b>fennel</b> <b>(require</b> <b>:fennel))</b>
         <b>(fn</b> <b>_G.pp</b> <b>[x]</b> <b>(print</b> <b>(fennel.view</b> <b>x)))</b>.  If you add this definition to your <b><a href="file:~/.fennelrc">~/.fennelrc</a></b> file it will be
         available in the standard repl.

       • Lua programmers should note Fennel functions cannot do early returns.

</pre><h4><b>OTHER</b> <b>STUFF</b> <b>JUST</b> <b>WORKS</b></h4><pre>
       Note that built-in functions in  Lua's  standard  library  (https://www.lua.org/manual/5.4/manual.html#6)
       like <b>math.random</b> above can be called with no fuss and no overhead.

       This  includes  features  like coroutines, which are often implemented using special syntax in other lan‐
       guages.     Coroutines    let    you    express     non-blocking     operations     without     callbacks
       (https://leafo.net/posts/itchio-and-coroutines.html).

       Tables in Lua may seem a bit limited, but metatables (https://www.lua.org/pil/13.html) allow a great deal
       more  flexibility.   All the features of metatables are accessible from Fennel code just the same as they
       would be from Lua.

</pre><h4><b>MODULES</b> <b>AND</b> <b>MULTIPLE</b> <b>FILES</b></h4><pre>
       You can use the <b>require</b> function to load code from other files.

              (let [lume (require :lume)
                    tbl [52 99 412 654]
                    plus (fn [x y] (+ x y))]
                (lume.map tbl (partial plus 2))) ; -&gt; [54 101 414 656]

       Modules in Fennel and Lua are simply tables which contain functions and other values.  The last value  in
       a Fennel file will be used as the value of the whole module.  Technically this can be any value, not just
       a table, but using a table is most common for good reason.

       To  require a module that's in a subdirectory, take the file name, replace the slashes with dots, and re‐
       move the extension, then pass that to <b>require</b>.  For instance, a file called <b>lib/ui/menu.lua</b> would be read
       when loading the module <b>lib.ui.menu</b>.

       When you run your program with the <b>fennel</b> command, you can call <b>require</b> to load Fennel  or  Lua  modules.
       But in other contexts (such as compiling to Lua and then using the <b>lua</b> command, or in programs that embed
       Lua) it will not know about Fennel modules.  You need to install the searcher that knows how to find <b>.fnl</b>
       files:

              require("fennel").install()
              local mylib = require("mylib") -- will compile and load code in mylib.fnl

       Once  you  add  this, <b>require</b> will work on Fennel files just like it does with Lua; for instance <b>(require</b>
       <b>:mylib.parser)</b> will look in "mylib/parser.fnl" on Fennel's search path (stored in  <b>fennel.path</b>  which  is
       distinct from <b>package.path</b> used to find Lua modules).  The path usually includes an entry to let you load
       things relative to the current directory by default.

</pre><h4><b>RELATIVE</b> <b>REQUIRE</b></h4><pre>
       There  are several ways to write a library which uses modules.  One of these is to rely on something like
       LuaRocks, to manage library installation and availability of it and its modules.  Another way is  to  use
       the  relative require style for loading nested modules.  With relative require, libraries don't depend on
       the root directory name or its location when resolving inner module paths.

       For example, here's a small <b>example</b> library, which contains an <b>init.fnl</b> file, and a module  at  the  root
       directory:

              ;; file example/init.fnl:
              (local a (require :example.module-a))

              {:hello-a a.hello}

       Here, the main module requires additional <b>example.module-a</b> module, which holds the implementation:

              ;; file example/module-a.fnl
              (fn hello [] (print "hello from a"))
              {:hello hello}

       The  main  issue  here is that the path to the library must be exactly <b>example</b>, e.g.  library must be re‐
       quired as <b>(require</b> <b>:example)</b> for it to work, which can't be enforced on the library user.   For  example,
       if  the  library  were moved into <b>libs</b> directory of the project to avoid cluttering, and required as <b>(re‐</b>
       <b>quire</b> <b>:libs.example)</b>, there will be a runtime error.  This happens because library itself will try to re‐
       quire <b>:example.module-a</b> and not <b>:libs.example.module-a</b>, which is now the correct module path:

              runtime error: module 'example.module-a' not found:
                      no field package.preload['example.module-a']
                      ...
                      no file './example/module-a.lua'
                      ...
              stack traceback:
                [C]: in function 'require'
                ./libs/example/init.fnl:2: in main chunk

       LuaRocks addresses this problem by enforcing both the directory name and  installation  path,  populating
       the  <b>LUA_PATH</b>  environment variable to make the library available.  This, of course, can be done manually
       by setting <b>LUA_PATH</b> per project in the build pipeline, pointing it to the right directory.  But  this  is
       not  very  transparent, and when requiring a project local library it's better to see the full path, that
       directly maps to the project's file structure, rather than looking up where the <b>LUA_PATH</b> is modified.

       In the Fennel ecosystem we encourage a simpler way of managing project dependencies.  Simply  dropping  a
       library  into  your project's tree or using git submodule is usually enough, and the require paths should
       be handled by the library itself.

       Here's how a relative require path can be specified in the <b>libs/example/init.fnl</b> to make it name/path ag‐
       nostic, assuming that we've moved our <b>example</b> library there:

              ;; file libs/example/init.fnl:
              (local a (require (.. ... :.module-a)))

              {:hello-a a.hello}

       Now, it doesn't matter how library is named or where we put it - we can require  it  from  anywhere.   It
       works  because  when  requiring the library with <b>(require</b> <b>:lib.example)</b>, the first value in <b>...</b> will hold
       the <b>"lib.example"</b> string.  This string is then concatenated with the <b>".module-a"</b>, and <b>require</b> will  prop‐
       erly  find  and load the nested module at runtime under the <b>"lib.example.module-a"</b> path.  It's a Lua fea‐
       ture, and not something Fennel specific, and it will work the same when the library is  AOT  compiled  to
       Lua.

   <b>Compile-time</b> <b>relative</b> <b>include</b>
       Since Fennel v0.10.0 this also works at compile-time, when using the <b>include</b> special or the <b>--require-as-</b>
       <b>include</b>  flag,  with the constraint that the expression can be computed at compile time.  This means that
       the expression must be self-contained, i.e.  doesn't refer to locals or globals, but  embeds  all  values
       directly.   In  other  words, the following code will only work at runtime, but not with <b>include</b> or <b>--re‐</b>
       <b>quire-as-include</b> because <b>current-module</b> is not known at compile time:

              (local current-module ...)
              (require (.. current-module :.other-module))

       This, on the other hand, will work both at runtime and at compile time:

              (require (.. ... :.other-module))

       The <b>...</b> module args are propagated during compilation, so when the application which uses this library is
       compiled, all library code is correctly included into the self-contained Lua file.

       Compiling a project that uses this <b>example</b> library with <b>--require-as-include</b> will include  the  following
       section in the resulting Lua code:

              package.preload["libs.example.module-a"] = package.preload["libs.example.module-a"] or function(...)
                local function hello()
                  return print("hello from a")
                end
                return {hello = hello}
              end

       Note  that  the  <b>package.preload</b> entry contains a fully qualified path <b>"libs.example.module-a"</b>, which was
       resolved at compile time.

   <b>Requiring</b> <b>modules</b> <b>from</b> <b>modules</b> <b>other</b> <b>than</b> <b>init.fnl</b>
       To require a module from a module other than <b>init</b> module, we must keep the path up to the current module,
       but remove the module name.  For example, let's add a <b>greet</b> module in  <b>libs/example/utils/greet.fnl</b>,  and
       require it from <b>libs/example/module-a.fnl</b>:

              ;; file libs/example/utils/greet.fnl:
              (fn greet [who] (print (.. "hello " who)))

       This module can be required as follows:

              ;; file libs/example/module-a.fnl
              (local greet (require (.. (: ... :match "(.+)%.[^.]+") :.utils.greet)))

              (fn hello [] (print "hello from a"))

              {:hello hello :greet greet}

       The  parent  module  name  is  determined  via calling the <b>match</b> method on the current module name string
       (<b>...</b>).

</pre><h4><b>AUTHORS</b></h4><pre>
       Fennel Maintainers.

fennel 1.5.3                                       2025-02-16                                 <u><a href="../man7/fennel-tutorial.7.html">fennel-tutorial</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>