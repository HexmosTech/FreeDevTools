<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>varnish-counters - Varnish counter field definitions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/varnish">varnish_7.7.0-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       varnish-counters - Varnish counter field definitions

</pre><h4><b>LCK</b> <b>–</b> <b>LOCK</b> <b>COUNTERS</b></h4><pre>
          Counters which track the activity in the different classes of mutex-locks.

          The  counts  may  be  slightly  wrong  if there are more than one lock instantiated in each class (ie:
          .creat &gt; 1)

       <b>creat</b> – <u>counter</u> - debug
          Created locks

       <b>destroy</b> – <u>counter</u> - debug
          Destroyed locks

       <b>locks</b> – <u>counter</u> - debug
          Lock Operations

       <b>dbg_busy</b> – <u>counter</u> - debug
          Contended lock operations

          If the <b>lck</b> debug bit is set: Lock operations which returned EBUSY on the first locking attempt.

          If the <b>lck</b> debug bit is unset, this counter will never be incremented  even  if  lock  operations  are
          contended.

       <b>dbg_try_fail</b> – <u>counter</u> - debug
          Contended trylock operations

          If the <b>lck</b> debug bit is set: Trylock operations which returned EBUSY.

          If  the  <b>lck</b>  debug  bit  is unset, this counter will never be incremented even if lock operations are
          contended.

</pre><h4><b>MAIN</b> <b>–</b> <b>MAIN</b> <b>COUNTERS</b></h4><pre>
       <b>summs</b> – <u>counter</u> - debug
          stat summ operations

          Number of times per-thread statistics were summed into the global counters.

       <b>uptime</b> – <u>counter</u> - info
          Child process uptime

          How long the child process has been running.

       <b>sess_conn</b> – <u>counter</u> - info
          Sessions accepted

          Count of sessions successfully accepted

       <b>sess_fail</b> – <u>counter</u> - info
          Session accept failures

          Count of failures to accept TCP connection.

          This counter is the sum of the sess_fail_* counters, which give more detailed information.

       <b>sess_fail_econnaborted</b> – <u>counter</u> - info
          Session accept failures: connection aborted

          Detailed reason for sess_fail: Connection aborted by the client, usually harmless.

       <b>sess_fail_eintr</b> – <u>counter</u> - info
          Session accept failures: interrupted system call

          Detailed reason for sess_fail: The accept() call was interrupted, usually harmless

       <b>sess_fail_emfile</b> – <u>counter</u> - info
          Session accept failures: too many open files

          Detailed reason for sess_fail: No file descriptor was available. Consider raising  RLIMIT_NOFILE  (see
          ulimit -n).

       <b>sess_fail_ebadf</b> – <u>counter</u> - info
          Session accept failures: bad file descriptor

          Detailed reason for sess_fail: The listen socket file descriptor was invalid. Should never happen.

       <b>sess_fail_enomem</b> – <u>counter</u> - info
          Session accept failures: not enough memory

          Detailed reason for sess_fail: Most likely insufficient socket buffer memory. Should never happen

       <b>sess_fail_other</b> – <u>counter</u> - info
          Session accept failures: other

          Detailed  reason  for  sess_fail:  neither  of  the  above,  see  SessError  log (varnishlog -g raw -i
          SessError).

       <b>client_req_400</b> – <u>counter</u> - info
          Client requests received, subject to 400 errors

          400 means we couldn't make sense of the request, it was malformed in some drastic way.

       <b>client_req_417</b> – <u>counter</u> - info
          Client requests received, subject to 417 errors

          417 means that something went wrong with an Expect: header.

       <b>client_req</b> – <u>counter</u> - info
          Good client requests received

          The count of parseable client requests seen.

       <b>esi_req</b> – <u>counter</u> - info
          ESI subrequests

          Number of ESI subrequests made.

       <b>cache_hit</b> – <u>counter</u> - info
          Cache hits

          Count of cache hits.  A cache hit indicates that an object has been  delivered  to  a  client  without
          fetching it from a backend server.

       <b>cache_hit_grace</b> – <u>counter</u> - info
          Cache grace hits

          Count  of  cache  hits  with grace. A cache hit with grace is a cache hit where the object is expired.
          Note that such hits are also included in the cache_hit counter.

       <b>cache_hitpass</b> – <u>counter</u> - info
          Cache hits for pass.

          Count of hits for pass. A cache hit for pass indicates that Varnish is going to pass  the  request  to
          the  backend  and  this  decision  has  been  cached in it self. This counts how many times the cached
          decision is being used.

       <b>cache_hitmiss</b> – <u>counter</u> - info
          Cache hits for miss.

          Count of hits for miss. A cache hit for miss indicates that Varnish is going to proceed as for a cache
          miss without request coalescing, and this decision has been cached. This counts  how  many  times  the
          cached decision is being used.

       <b>cache_miss</b> – <u>counter</u> - info
          Cache misses

          Count  of  misses. A cache miss indicates the object was fetched from the backend before delivering it
          to the client.

       <b>beresp_uncacheable</b> – <u>counter</u> - info
              Uncacheable backend responses

          Count of backend responses considered uncacheable.

       <b>beresp_shortlived</b> – <u>counter</u> - info
              Shortlived objects

          Count of objects created with ttl+grace+keep shorter than the 'shortlived' runtime parameter.

       <b>backend_conn</b> – <u>counter</u> - info
          Backend conn. success

          How many backend connections have successfully been established.

       <b>backend_unhealthy</b> – <u>counter</u> - info
          Backend conn. not attempted

       <b>backend_busy</b> – <u>counter</u> - info
          Backend conn. too many

       <b>backend_fail</b> – <u>counter</u> - info
          Backend conn. failures

       <b>backend_reuse</b> – <u>counter</u> - info
          Backend conn. reuses

          Count of backend connection reuses. This counter is increased whenever we reuse a recycled connection.

       <b>backend_recycle</b> – <u>counter</u> - info
          Backend conn. recycles

          Count of backend connection recycles.  This  counter  is  increased  whenever  we  have  a  keep-alive
          connection  that  is put back into the pool of connections. It has not yet been used, but it might be,
          unless the backend closes it.

       <b>backend_retry</b> – <u>counter</u> - info
          Backend conn. retry

       <b>backend_wait</b> – <u>counter</u> - info
          Backend conn. waited in queue for a connection

          Count of backend requests that waited in a backend_wait queue for a connection  to  become  available.
          The  size  of  a  backend wait queue is defined by the backend wait_limit property.  The wait queue is
          only used when max_connections to the backend are in use.

       <b>backend_wait_fail</b> – <u>counter</u> - info
          Backend conn. waited in queue and did not get a connection

          Count of backend requests that waited in a backend_wait queue for a connection to become available and
          did not get one (timed out).  The maximum time to  wait  in  the  queue  is  defined  by  the  backend
          wait_timeout property.

       <b>fetch_head</b> – <u>counter</u> - info
          Fetch no body (HEAD)

          beresp with no body because the request is HEAD.

       <b>fetch_length</b> – <u>counter</u> - info
          Fetch with Length

          beresp.body with Content-Length.

       <b>fetch_chunked</b> – <u>counter</u> - info
          Fetch chunked

          beresp.body with Chunked.

       <b>fetch_eof</b> – <u>counter</u> - info
          Fetch EOF

          beresp.body with EOF.

       <b>fetch_bad</b> – <u>counter</u> - info
          Fetch bad T-E

          beresp.body length/fetch could not be determined.

       <b>fetch_none</b> – <u>counter</u> - info
          Fetch no body

          beresp.body empty

       <b>fetch_1xx</b> – <u>counter</u> - info
          Fetch no body (1xx)

          beresp with no body because of 1XX response.

       <b>fetch_204</b> – <u>counter</u> - info
          Fetch no body (204)

          beresp with no body because of 204 response.

       <b>fetch_304</b> – <u>counter</u> - info
          Fetch no body (304)

          beresp with no body because of 304 response.

       <b>fetch_failed</b> – <u>counter</u> - info
          Fetch failed (all causes)

          beresp fetch failed.

       <b>bgfetch_no_thread</b> – <u>counter</u> - info
          Background fetch failed (no thread)

          A bgfetch triggered by a grace hit failed, no thread available.

       <b>pools</b> – <u>gauge</u> - info
          Number of thread pools

          Number  of  thread  pools. See also parameter thread_pools. NB: Presently pools cannot be removed once
          created.

       <b>threads</b> – <u>gauge</u> - info
          Total number of threads

          Number of threads in all pools. See also parameters thread_pools, thread_pool_min and thread_pool_max.

       <b>threads_limited</b> – <u>counter</u> - info
          Threads hit max

          Number of times more threads were needed, but limit was reached in a thread pool. See  also  parameter
          thread_pool_max.

       <b>threads_created</b> – <u>counter</u> - info
          Threads created

          Total number of threads created in all pools.

       <b>threads_destroyed</b> – <u>counter</u> - info
          Threads destroyed

          Total number of threads destroyed in all pools.

       <b>threads_failed</b> – <u>counter</u> - info
          Thread creation failed

          Number  of  times  creating  a  thread  failed.  See  VSL::Debug  for  diagnostics. See also parameter
          thread_fail_delay.

       <b>thread_queue_len</b> – <u>gauge</u> - info
          Length of session queue

          Length of session queue waiting for threads. NB: Only updates once  per  second.  See  also  parameter
          thread_queue_limit.

       <b>busy_sleep</b> – <u>counter</u> - info
          Number of requests sent to sleep on busy objhdr

          Number of requests sent to sleep without a worker thread because they found a busy object.

       <b>busy_wakeup</b> – <u>counter</u> - info
          Number of requests woken after sleep on busy objhdr

          Number of requests taken off the busy object sleep list and rescheduled.

       <b>busy_killed</b> – <u>counter</u> - info
          Number of requests killed after sleep on busy objhdr

          Number of requests killed from the busy object sleep list due to lack of resources.

       <b>sess_queued</b> – <u>counter</u> - info
          Sessions queued for thread

          Number of times session was queued waiting for a thread. See also parameter thread_queue_limit.

       <b>sess_dropped</b> – <u>counter</u> - info
          Sessions dropped for thread

          Number  of  times  an  HTTP/1  session  was  dropped  because the queue was too long already. See also
          parameter thread_queue_limit.

       <b>req_dropped</b> – <u>counter</u> - info
          Requests dropped

          Number of times an HTTP/2 stream was refused  because  the  queue  was  too  long  already.  See  also
          parameter thread_queue_limit.

       <b>req_reset</b> – <u>counter</u> - info
          Requests reset

          Number  of  times  a  client  left  before  the  VCL  processing of its requests completed. For HTTP/2
          sessions, either the stream was reset by  an  RST_STREAM  frame  from  the  client,  or  a  stream  or
          connection error occurred.

       <b>n_object</b> – <u>gauge</u> - info
          object structs made

          Approximate number of HTTP objects (headers + body, if present) in the cache.

       <b>n_vampireobject</b> – <u>gauge</u> - diag
          unresurrected objects

          Number of unresurrected objects

       <b>n_objectcore</b> – <u>gauge</u> - info
          objectcore structs made

          Approximate  number  of  object metadata elements in the cache. Each object needs an objectcore, extra
          objectcores are for hit-for-miss, hit-for-pass and busy objects.

       <b>n_objecthead</b> – <u>gauge</u> - info
          objecthead structs made

          Approximate number of different hash entries in the cache.

       <b>n_backend</b> – <u>gauge</u> - info
          Number of backends

          Number of backends known to us.

       <b>n_expired</b> – <u>counter</u> - info
          Number of expired objects

          Number of objects that expired from cache because of old age.

       <b>n_superseded</b> – <u>counter</u> - diag
          Number of superseded objects

          Number of times an object was superseded by a new one.

       <b>n_lru_nuked</b> – <u>counter</u> - info
          Number of LRU nuked objects

          How many objects have been forcefully evicted from storage to make room for a new object.

       <b>n_lru_moved</b> – <u>counter</u> - diag
          Number of LRU moved objects

          Number of move operations done on the LRU list.

       <b>n_lru_limited</b> – <u>counter</u> - info
          Reached nuke_limit

          Number of times more storage space were needed, but limit  was  reached  in  a  nuke_limit.  See  also
          parameter nuke_limit.

       <b>losthdr</b> – <u>counter</u> - info
          HTTP header overflows

       <b>s_sess</b> – <u>counter</u> - info
          Total sessions seen

       <b>n_pipe</b> – <u>gauge</u> - info
          Number of ongoing pipe sessions

       <b>pipe_limited</b> – <u>counter</u> - info
          Pipes hit pipe_sess_max

          Number of times more pipes were needed, but the limit was reached. See also parameter pipe_sess_max.

       <b>s_pipe</b> – <u>counter</u> - info
          Total pipe sessions seen

       <b>s_pass</b> – <u>counter</u> - info
          Total pass-ed requests seen

       <b>s_fetch</b> – <u>counter</u> - info
          Total backend fetches initiated

          Total backend fetches initiated, including background fetches.

       <b>s_bgfetch</b> – <u>counter</u> - info
          Total backend background fetches initiated

       <b>s_synth</b> – <u>counter</u> - info
          Total synthetic responses made

       <b>s_req_hdrbytes</b> – <u>counter</u> - info
          Request header bytes

          Total request header bytes received

       <b>s_req_bodybytes</b> – <u>counter</u> - info
          Request body bytes

          Total request body bytes received

       <b>s_resp_hdrbytes</b> – <u>counter</u> - info
          Response header bytes

          Total response header bytes transmitted

       <b>s_resp_bodybytes</b> – <u>counter</u> - info
          Response body bytes

          Total response body bytes transmitted

       <b>s_pipe_hdrbytes</b> – <u>counter</u> - info
          Pipe request header bytes

          Total request bytes received for piped sessions

       <b>s_pipe_in</b> – <u>counter</u> - info
          Piped bytes from client

          Total number of bytes forwarded from clients in pipe sessions

       <b>s_pipe_out</b> – <u>counter</u> - info
          Piped bytes to client

          Total number of bytes forwarded to clients in pipe sessions

       <b>sess_closed</b> – <u>counter</u> - info
          Session Closed

       <b>sess_closed_err</b> – <u>counter</u> - info
          Session Closed with error

          Total number of sessions closed with errors. See sc_* diag counters for detailed breakdown

       <b>sess_readahead</b> – <u>counter</u> - info
          Session Read Ahead

       <b>sess_herd</b> – <u>counter</u> - diag
          Session herd

          Number of times the timeout_linger triggered

       <b>sc_rem_close</b> – <u>counter</u> - diag
          Session OK  REM_CLOSE

          Number of session closes with REM_CLOSE (Client Closed)

       <b>sc_req_close</b> – <u>counter</u> - diag
          Session OK  REQ_CLOSE

          Number of session closes with REQ_CLOSE (Client requested close)

       <b>sc_req_http10</b> – <u>counter</u> - diag
          Session Err REQ_HTTP10

          Number of session closes with Error REQ_HTTP10 (Proto &lt; HTTP/1.1)

       <b>sc_rx_bad</b> – <u>counter</u> - diag
          Session Err RX_BAD

          Number of session closes with Error RX_BAD (Received bad req/resp)

       <b>sc_rx_body</b> – <u>counter</u> - diag
          Session Err RX_BODY

          Number of session closes with Error RX_BODY (Failure receiving req.body)

       <b>sc_rx_junk</b> – <u>counter</u> - diag
          Session Err RX_JUNK

          Number of session closes with Error RX_JUNK (Received junk data)

       <b>sc_rx_overflow</b> – <u>counter</u> - diag
          Session Err RX_OVERFLOW

          Number of session closes with Error RX_OVERFLOW (Received buffer overflow)

       <b>sc_rx_timeout</b> – <u>counter</u> - diag
          Session Err RX_TIMEOUT

          Number of session closes with Error RX_TIMEOUT (Receive timeout)

       <b>sc_rx_close_idle</b> – <u>counter</u> - diag
          Session Err RX_CLOSE_IDLE

          Number  of session closes with Error RX_CLOSE_IDLE: timeout_idle has been exceeded while waiting for a
          client request.

       <b>sc_tx_pipe</b> – <u>counter</u> - diag
          Session OK  TX_PIPE

          Number of session closes with TX_PIPE (Piped transaction)

       <b>sc_tx_error</b> – <u>counter</u> - diag
          Session Err TX_ERROR

          Number of session closes with Error TX_ERROR (Error transaction)

       <b>sc_tx_eof</b> – <u>counter</u> - diag
          Session OK  TX_EOF

          Number of session closes with TX_EOF (EOF transmission)

       <b>sc_resp_close</b> – <u>counter</u> - diag
          Session OK  RESP_CLOSE

          Number of session closes with RESP_CLOSE (Backend/VCL requested close)

       <b>sc_overload</b> – <u>counter</u> - diag
          Session Err OVERLOAD

          Number of session closes with Error OVERLOAD (Out of some resource)

       <b>sc_pipe_overflow</b> – <u>counter</u> - diag
          Session Err PIPE_OVERFLOW

          Number of session closes with Error PIPE_OVERFLOW (Session pipe overflow)

       <b>sc_range_short</b> – <u>counter</u> - diag
          Session Err RANGE_SHORT

          Number of session closes with Error RANGE_SHORT (Insufficient data for range)

       <b>sc_req_http20</b> – <u>counter</u> - diag
          Session Err REQ_HTTP20

          Number of session closes with Error REQ_HTTP20 (HTTP2 not accepted)

       <b>sc_vcl_failure</b> – <u>counter</u> - diag
          Session Err VCL_FAILURE

          Number of session closes with Error VCL_FAILURE (VCL failure)

       <b>sc_rapid_reset</b> – <u>counter</u> - diag
              Session Err RAPID_RESET

          Number of times we failed an http/2 session because it hit its configured limits  for  the  number  of
          permitted rapid stream resets.

       <b>sc_bankrupt</b> – <u>counter</u> - diag
          Session Err BANKRUPT

          Number  of times we failed an http/2 session because all the streams were waiting for their windows to
          be credited when h2_window_timeout triggered.

       <b>client_resp_500</b> – <u>counter</u> - diag
          Delivery failed due to insufficient workspace.

          Number of times we failed a response due to running out of workspace memory during delivery.

       <b>ws_backend_overflow</b> – <u>counter</u> - diag
          workspace_backend overflows

          Number of times we ran out of space in workspace_backend.

       <b>ws_client_overflow</b> – <u>counter</u> - diag
          workspace_client overflows

          Number of times we ran out of space in workspace_client.

       <b>ws_thread_overflow</b> – <u>counter</u> - diag
          workspace_thread overflows

          Number of times we ran out of space in workspace_thread.

       <b>ws_session_overflow</b> – <u>counter</u> - diag
          workspace_session overflows

          Number of times we ran out of space in workspace_session.

       <b>shm_records</b> – <u>counter</u> - diag
          SHM records

          Number of log records written to the shared memory log.

       <b>shm_writes</b> – <u>counter</u> - diag
          SHM writes

          Number of individual writes to the shared memory log. A single write may batch  multiple  records  for
          buffered tasks.

       <b>shm_flushes</b> – <u>counter</u> - diag
          SHM flushes due to overflow

          Number  of writes performed before the end of a buffered task because adding a record to a batch would
          exceed vsl_buffer.

       <b>shm_cont</b> – <u>counter</u> - diag
          SHM lock contention

          Number of times a write had to wait for the lock.

       <b>shm_cycles</b> – <u>counter</u> - diag
          SHM cycles through VSL space

          Number of times a write of log records would reach past the end of the shared memory log, cycling back
          to the beginning.

       <b>shm_bytes</b> – <u>counter</u> - diag
          SHM bytes

          Number of bytes written to the shared memory log.

       <b>backend_req</b> – <u>counter</u> - info
          Backend requests made

       <b>n_vcl</b> – <u>gauge</u> - info
          Number of loaded VCLs in total

       <b>n_vcl_avail</b> – <u>gauge</u> - diag
          Number of VCLs available

       <b>n_vcl_discard</b> – <u>gauge</u> - diag
          Number of discarded VCLs

       <b>vcl_fail</b> – <u>counter</u> - info
          VCL failures

          Count of failures which prevented VCL from completing.

       <b>bans</b> – <u>gauge</u> - info
          Count of bans

          Number of all bans in system, including bans superseded by newer bans and bans already checked by  the
          ban-lurker.

       <b>bans_completed</b> – <u>gauge</u> - diag
          Number of bans marked 'completed'

          Number  of  bans  which  are  no  longer  active, either because they got checked by the ban-lurker or
          superseded by newer identical bans.

       <b>bans_obj</b> – <u>gauge</u> - diag
          Number of bans using obj.*

          Number of bans which use obj.* variables.  These bans can possibly be washed by the ban-lurker.

       <b>bans_req</b> – <u>gauge</u> - diag
          Number of bans using req.*

          Number of bans which use req.* variables.  These bans cannot be washed by the ban-lurker.

       <b>bans_added</b> – <u>counter</u> - diag
          Bans added

          Counter of bans added to ban list.

       <b>bans_deleted</b> – <u>counter</u> - diag
          Bans deleted

          Counter of bans deleted from ban list.

       <b>bans_tested</b> – <u>counter</u> - diag
          Bans tested against objects (lookup)

          Count of how many bans and objects have been tested against each other during hash lookup.

       <b>bans_obj_killed</b> – <u>counter</u> - diag
          Objects killed by bans (lookup)

          Number of objects killed by bans during object lookup.

       <b>bans_lurker_tested</b> – <u>counter</u> - diag
          Bans tested against objects (lurker)

          Count of how many bans and objects have been tested against each other by the ban-lurker.

       <b>bans_tests_tested</b> – <u>counter</u> - diag
          Ban tests tested against objects (lookup)

          Count of how many tests and objects have been tested against each other during lookup. 'ban req.url ==
          foo &amp;&amp; req.http.host == bar' counts as one in 'bans_tested' and as two in 'bans_tests_tested'

       <b>bans_lurker_tests_tested</b> – <u>counter</u> - diag
          Ban tests tested against objects (lurker)

          Count of how many tests and objects have been tested  against  each  other  by  the  ban-lurker.  'ban
          req.url   ==   foo   &amp;&amp;  req.http.host  ==  bar'  counts  as  one  in  'bans_tested'  and  as  two  in
          'bans_tests_tested'

       <b>bans_lurker_obj_killed</b> – <u>counter</u> - diag
          Objects killed by bans (lurker)

          Number of objects killed by the ban-lurker.

       <b>bans_lurker_obj_killed_cutoff</b> – <u>counter</u> - diag
          Objects killed by bans for cutoff (lurker)

          Number of objects killed by the ban-lurker to keep the number of bans below ban_cutoff.

       <b>bans_dups</b> – <u>counter</u> - diag
          Bans superseded by other bans

          Count of bans replaced by later identical bans.

       <b>bans_lurker_contention</b> – <u>counter</u> - diag
          Lurker gave way for lookup

          Number of times the ban-lurker had to wait for lookups.

       <b>bans_persisted_bytes</b> – <u>gauge</u> - diag
          Bytes used by the persisted ban lists

          Number of bytes used by the persisted ban lists.

       <b>bans_persisted_fragmentation</b> – <u>gauge</u> - diag
          Extra bytes in persisted ban lists due to fragmentation

          Number of extra bytes accumulated through dropped and completed bans in the persistent ban lists.

       <b>n_purges</b> – <u>counter</u> - info
          Number of purge operations executed

       <b>n_obj_purged</b> – <u>counter</u> - info
          Number of purged objects

       <b>exp_mailed</b> – <u>counter</u> - diag
          Number of objects mailed to expiry thread

          Number of objects mailed to expiry thread for handling.

       <b>exp_received</b> – <u>counter</u> - diag
          Number of objects received by expiry thread

          Number of objects received by expiry thread for handling.

       <b>hcb_nolock</b> – <u>counter</u> - debug
          HCB Lookups without lock

       <b>hcb_lock</b> – <u>counter</u> - debug
          HCB Lookups with lock

       <b>hcb_insert</b> – <u>counter</u> - debug
          HCB Inserts

       <b>esi_errors</b> – <u>counter</u> - diag
          ESI parse errors (unlock)

       <b>esi_warnings</b> – <u>counter</u> - diag
          ESI parse warnings (unlock)

       <b>vmods</b> – <u>gauge</u> - info
          Loaded VMODs

       <b>n_gzip</b> – <u>counter</u> - info
          Gzip operations

       <b>n_gunzip</b> – <u>counter</u> - info
          Gunzip operations

       <b>n_test_gunzip</b> – <u>counter</u> - info
          Test gunzip operations

          Those operations occur when Varnish receives a compressed object from a  backend.  They  are  done  to
          verify the gzip stream while it's inserted in storage.

       <b>http1_iovs_flush</b> – <u>counter</u> - info
          Premature iovec flushes

          Number  of  additional  writes performed on HTTP1 connections because the number of IO vectors was too
          small to submit all possible IO in one go. This number is configured through the <b>http1_iovs</b>  parameter
          for client connections and implicitly defined by the amount of free workspace for backend connections.

</pre><h4><b>MEMPOOL</b> <b>–</b> <b>MEMORY</b> <b>POOL</b> <b>COUNTERS</b></h4><pre>
       <b>live</b> – <u>gauge</u> - debug
          In use

       <b>pool</b> – <u>gauge</u> - debug
          In Pool

       <b>sz_wanted</b> – <u>gauge</u> - debug
          Size requested

       <b>sz_actual</b> – <u>gauge</u> - debug
          Size allocated

       <b>allocs</b> – <u>counter</u> - debug
          Allocations

       <b>frees</b> – <u>counter</u> - debug
          Frees

       <b>recycle</b> – <u>counter</u> - debug
          Recycled from pool

       <b>timeout</b> – <u>counter</u> - debug
          Timed out from pool

       <b>toosmall</b> – <u>counter</u> - debug
          Too small to recycle

       <b>surplus</b> – <u>counter</u> - debug
          Too many for pool

       <b>randry</b> – <u>counter</u> - debug
          Pool ran dry

</pre><h4><b>MGT</b> <b>–</b> <b>MANAGEMENT</b> <b>PROCESS</b> <b>COUNTERS</b></h4><pre>
       <b>uptime</b> – <u>counter</u> - info
          Management process uptime

          Uptime in seconds of the management process

       <b>child_start</b> – <u>counter</u> - diag
          Child process started

          Number of times the child process has been started

       <b>child_exit</b> – <u>counter</u> - diag
          Child process normal exit

          Number of times the child process has been cleanly stopped

       <b>child_stop</b> – <u>counter</u> - diag
          Child process unexpected exit

          Number of times the child process has exited with an unexpected return code

       <b>child_died</b> – <u>counter</u> - diag
          Child process died (signal)

          Number of times the child process has died due to signals

       <b>child_dump</b> – <u>counter</u> - diag
          Child process core dumped

          Number of times the child process has produced core dumps

       <b>child_panic</b> – <u>counter</u> - diag
          Child process panic

          Number of times the management process has caught a child panic

</pre><h4><b>SMA</b> <b>–</b> <b>MALLOC</b> <b>STEVEDORE</b> <b>COUNTERS</b></h4><pre>
       <b>c_req</b> – <u>counter</u> - info
          Allocator requests

          Number of times the storage has been asked to provide a storage segment.

       <b>c_fail</b> – <u>counter</u> - info
          Allocator failures

          Number of times the storage has failed to provide a storage segment.

       <b>c_bytes</b> – <u>counter</u> - info
          Bytes allocated

          Number of total bytes allocated by this storage.

       <b>c_freed</b> – <u>counter</u> - info
          Bytes freed

          Number of total bytes returned to this storage.

       <b>g_alloc</b> – <u>gauge</u> - info
          Allocations outstanding

          Number of storage allocations outstanding.

       <b>g_bytes</b> – <u>gauge</u> - info
          Bytes outstanding

          Number of bytes allocated from the storage.

       <b>g_space</b> – <u>gauge</u> - info
          Bytes available

          Number of bytes left in the storage.

</pre><h4><b>SMF</b> <b>–</b> <b>FILE</b> <b>STEVEDORE</b> <b>COUNTERS</b></h4><pre>
       <b>c_req</b> – <u>counter</u> - info
          Allocator requests

          Number of times the storage has been asked to provide a storage segment.

       <b>c_fail</b> – <u>counter</u> - info
          Allocator failures

          Number of times the storage has failed to provide a storage segment.

       <b>c_bytes</b> – <u>counter</u> - info
          Bytes allocated

          Number of total bytes allocated by this storage.

       <b>c_freed</b> – <u>counter</u> - info
          Bytes freed

          Number of total bytes returned to this storage.

       <b>g_alloc</b> – <u>gauge</u> - info
          Allocations outstanding

          Number of storage allocations outstanding.

       <b>g_bytes</b> – <u>gauge</u> - info
          Bytes outstanding

          Number of bytes allocated from the storage.

       <b>g_space</b> – <u>gauge</u> - info
          Bytes available

          Number of bytes left in the storage.

       <b>g_smf</b> – <u>gauge</u> - info
          N struct smf

       <b>g_smf_frag</b> – <u>gauge</u> - info
          N small free smf

       <b>g_smf_large</b> – <u>gauge</u> - info
          N large free smf

</pre><h4><b>SMU</b> <b>–</b> <b>UMEM</b> <b>STEVEDORE</b> <b>COUNTERS</b></h4><pre>
       <b>c_req</b> – <u>counter</u> - info
          Allocator requests

          Number of times the storage has been asked to provide a storage segment.

       <b>c_fail</b> – <u>counter</u> - info
          Allocator failures

          Number of times the storage has failed to provide a storage segment.

       <b>c_bytes</b> – <u>counter</u> - info
          Bytes allocated

          Number of total bytes allocated by this storage.

       <b>c_freed</b> – <u>counter</u> - info
          Bytes freed

          Number of total bytes returned to this storage.

       <b>g_alloc</b> – <u>gauge</u> - info
          Allocations outstanding

          Number of storage allocations outstanding.

       <b>g_bytes</b> – <u>gauge</u> - info
          Bytes outstanding

          Number of bytes allocated from the storage.

       <b>g_space</b> – <u>gauge</u> - info
          Bytes available

          Number of bytes left in the storage.

</pre><h4><b>VBE</b> <b>–</b> <b>BACKEND</b> <b>COUNTERS</b></h4><pre>
       <b>happy</b> – <u>bitmap</u> - info
          Happy health probes

          Represents  the  last  probe results as a bitmap. Happy probes are bits set to 1, and the unhappy ones
          are set to 0. The highest bits represent the oldest probes.

       <b>bereq_hdrbytes</b> – <u>counter</u> - info
          Request header bytes

          Total backend request header bytes sent

       <b>bereq_bodybytes</b> – <u>counter</u> - info
          Request body bytes

          Total backend request body bytes sent

       <b>beresp_hdrbytes</b> – <u>counter</u> - info
          Response header bytes

          Total backend response header bytes received

       <b>beresp_bodybytes</b> – <u>counter</u> - info
          Response body bytes

          Total backend response body bytes received

       <b>pipe_hdrbytes</b> – <u>counter</u> - info
          Pipe request header bytes

          Total request bytes sent for piped sessions

       <b>pipe_out</b> – <u>counter</u> - info
          Piped bytes to backend

          Total number of bytes forwarded to backend in pipe sessions

       <b>pipe_in</b> – <u>counter</u> - info
          Piped bytes from backend

          Total number of bytes forwarded from backend in pipe sessions

       <b>conn</b> – <u>gauge</u> - info
          Concurrent connections used

          The number of currently used connections to the backend. This number is always less or  equal  to  the
          number  of  connections  to  the  backend (as, for example shown as ESTABLISHED for TCP connections in
          netstat) due to connection pooling.

       <b>req</b> – <u>counter</u> - info
          Backend requests sent

       <b>unhealthy</b> – <u>counter</u> - info
          Fetches not attempted due to backend being unhealthy

       <b>busy</b> – <u>counter</u> - info
          Fetches not attempted due to backend being busy

          Number of times the max_connections limit was reached

       <b>fail</b> – <u>counter</u> - info
          Connections failed

          Counter of failed opens. Detailed reasons are given in the fail_* counters (DIAG level) and in the log
          under the FetchError tag.

          This counter is the sum of all detailed fail_* counters.

          All fail_* counters may be slightly inaccurate for efficiency.

       <b>fail_eacces</b> – <u>counter</u> - diag
          Connections failed with EACCES or EPERM

       <b>fail_eaddrnotavail</b> – <u>counter</u> - diag
          Connections failed with EADDRNOTAVAIL

       <b>fail_econnrefused</b> – <u>counter</u> - diag
          Connections failed with ECONNREFUSED

       <b>fail_enetunreach</b> – <u>counter</u> - diag
          Connections failed with ENETUNREACH

       <b>fail_etimedout</b> – <u>counter</u> - diag
          Connections failed ETIMEDOUT

       <b>fail_other</b> – <u>counter</u> - diag
          Connections failed for other reason

       <b>helddown</b> – <u>counter</u> - diag
          Connection opens not attempted

          Connections not attempted during  the  backend_local_error_holddown  or  backend_remote_error_holddown
          interval after a fundamental connection issue.

</pre><h4><b>WAITER</b> <b>–</b> <b>WAITER</b> <b>COUNTERS</b></h4><pre>
       <b>conns</b> – <u>gauge</u> - debug
          Number of idle connections

          Number of idle connections being waited over.

       <b>remclose</b> – <u>counter</u> - debug
          Number of idle connections closed by peer

          Number of idle connections that experienced closure by peer while being waited for.

       <b>timeout</b> – <u>counter</u> - debug
          Number of idle connections timeout

          Number of idle connections that experienced a timeout event while being waited for.

       <b>action</b> – <u>counter</u> - debug
          Number of idle connections read events

          Number of idle connections that experienced a read event while being waited for.

</pre><h4><b>AUTHORS</b></h4><pre>
       This man page was written by Lasse Karstensen, using content from vsc2rst written by Tollef Fog Heen.

                                                                                             <u><a href="../man7/VARNISH-COUNTERS.7.html">VARNISH-COUNTERS</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>