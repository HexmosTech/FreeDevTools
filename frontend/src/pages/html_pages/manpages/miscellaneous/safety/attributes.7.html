<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>attributes - POSIX safety concepts</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       attributes - POSIX safety concepts

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Note</u>:  the  text of this man page is based on the material taken from the "POSIX Safety Concepts" section
       of the GNU C Library manual.  Further details on the topics described here can be found in that manual.

       Various function manual pages include a section ATTRIBUTES that  describes  the  safety  of  calling  the
       function in various contexts.  This section annotates functions with the following safety markings:

       <u>MT-Safe</u>
              <u>MT-Safe</u>  or  Thread-Safe  functions are safe to call in the presence of other threads.  MT, in MT-
              Safe, stands for Multi Thread.

              Being MT-Safe does not  imply  a  function  is  atomic,  nor  that  it  uses  any  of  the  memory
              synchronization  mechanisms  POSIX  exposes  to  users.   It is even possible that calling MT-Safe
              functions in sequence does not yield an MT-Safe combination.  For example, having  a  thread  call
              two  MT-Safe  functions one right after the other does not guarantee behavior equivalent to atomic
              execution of a combination of  both  functions,  since  concurrent  calls  in  other  threads  may
              interfere in a destructive way.

              Whole-program  optimizations  that  could  inline  functions  across library interfaces may expose
              unsafe reordering, and  so  performing  inlining  across  the  GNU  C  Library  interface  is  not
              recommended.   The documented MT-Safety status is not guaranteed under whole-program optimization.
              However, functions defined in user-visible headers are designed to be safe for inlining.

       <u>MT-Unsafe</u>
              <u>MT-Unsafe</u> functions are not safe to call in a multithreaded programs.

       Other keywords that appear in safety notes are defined in subsequent sections.

   <b>Conditionally</b> <b>safe</b> <b>features</b>
       For some features that make functions unsafe to call in certain contexts, there are known ways  to  avoid
       the  safety problem other than refraining from calling the function altogether.  The keywords that follow
       refer to such features, and each of their definitions  indicates  how  the  whole  program  needs  to  be
       constrained  in  order  to remove the safety problem indicated by the keyword.  Only when all the reasons
       that make a function unsafe are observed and addressed, by applying the documented constraints, does  the
       function become safe to call in a context.

       <u>init</u>   Functions  marked with <u>init</u> as an MT-Unsafe feature perform MT-Unsafe initialization when they are
              first called.

              Calling such a function at least once in single-threaded mode removes this specific cause for  the
              function  to  be regarded as MT-Unsafe.  If no other cause for that remains, the function can then
              be safely called after other threads are started.

       <u>race</u>   Functions annotated with <u>race</u> as an MT-Safety issue operate on objects in ways that may cause data
              races or similar forms of destructive interference out of concurrent execution.   In  some  cases,
              the  objects  are  passed  to the functions by users; in others, they are used by the functions to
              return values to users; in others, they are not even exposed to users.

       <u>const</u>  Functions marked with <u>const</u> as an MT-Safety issue non-atomically modify internal objects that  are
              better  regarded  as  constant,  because  a substantial portion of the GNU C Library accesses them
              without synchronization.  Unlike <u>race</u>, which causes both readers and writers of  internal  objects
              to  be  regarded  as MT-Unsafe, this mark is applied to writers only.  Writers remain MT-Unsafe to
              call, but the then-mandatory constness of objects they modify enables readers to  be  regarded  as
              MT-Safe  (as  long  as  no  other  reasons  for  them  to  be  unsafe  remain),  since the lack of
              synchronization is not a problem when the objects are effectively constant.

              The identifier that follows the <u>const</u> mark will appear by itself as  a  safety  note  in  readers.
              Programs  that  wish  to  work  around  this  safety  issue, so as to call writers, may use a non-
              recursive read-write lock associated with the identifier, and guard <u>all</u> calls to functions  marked
              with  <u>const</u>  followed  by the identifier with a write lock, and <u>all</u> calls to functions marked with
              the identifier by itself with a read lock.

       <u>sig</u>    Functions marked with <u>sig</u> as a MT-Safety issue  may  temporarily  install  a  signal  handler  for
              internal purposes, which may interfere with other uses of the signal, identified after a colon.

              This  safety  problem  can be worked around by ensuring that no other uses of the signal will take
              place for the duration of the call.  Holding a non-recursive mutex  while  calling  all  functions
              that use the same temporary signal; blocking that signal before the call and resetting its handler
              afterwards is recommended.

       <u>term</u>   Functions  marked  with  <u>term</u>  as  an  MT-Safety  issue  may  change  the terminal settings in the
              recommended way, namely: call <b><a href="../man3/tcgetattr.3.html">tcgetattr</a></b>(3), modify some flags, and then  call  <b><a href="../man3/tcsetattr.3.html">tcsetattr</a></b>(3),  this
              creates  a  window  in  which changes made by other threads are lost.  Thus, functions marked with
              <u>term</u> are MT-Unsafe.

              It is thus advisable for applications  using  the  terminal  to  avoid  concurrent  and  reentrant
              interactions  with  it,  by not using it in signal handlers or blocking signals that might use it,
              and holding a lock while calling these functions and interacting with  the  terminal.   This  lock
              should also be used for mutual exclusion with functions marked with <u>race:tcattr(fd)</u>, where <u>fd</u> is a
              file  descriptor  for the controlling terminal.  The caller may use a single mutex for simplicity,
              or use one mutex per terminal, even if referenced by different file descriptors.

   <b>Other</b> <b>safety</b> <b>remarks</b>
       Additional keywords may be attached to functions, indicating features that do not make a function  unsafe
       to call, but that may need to be taken into account in certain classes of programs:

       <u>locale</u> Functions annotated with <u>locale</u> as an MT-Safety issue read from the locale object without any form
              of  synchronization.   Functions annotated with <u>locale</u> called concurrently with locale changes may
              behave in ways that do not correspond to any of the locales active during their execution, but  an
              unpredictable mix thereof.

              We  do  not  mark  these functions as MT-Unsafe, however, because functions that modify the locale
              object are marked with <u>const:locale</u> and regarded as unsafe.  Being unsafe, the latter are  not  to
              be called when multiple threads are running or asynchronous signals are enabled, and so the locale
              can be considered effectively constant in these contexts, which makes the former safe.

       <u>env</u>    Functions  marked with <u>env</u> as an MT-Safety issue access the environment with <b><a href="../man3/getenv.3.html">getenv</a></b>(3) or similar,
              without any guards to ensure safety in the presence of concurrent modifications.

              We do not  mark  these  functions  as  MT-Unsafe,  however,  because  functions  that  modify  the
              environment  are  all  marked with <u>const:env</u> and regarded as unsafe.  Being unsafe, the latter are
              not to be called when multiple threads are running or asynchronous signals are enabled, and so the
              environment can be considered effectively constant in these contexts, which makes the former safe.

       <u>hostid</u> The function marked with <u>hostid</u> as an MT-Safety issue reads from the system-wide  data  structures
              that  hold  the  "host  ID"  of  the  machine.  These data structures cannot generally be modified
              atomically.  Since it is expected that the "host ID" will not normally change, the  function  that
              reads  from  it  (<b><a href="../man3/gethostid.3.html">gethostid</a></b>(3))  is  regarded  as  safe,  whereas  the  function  that modifies it
              (<b><a href="../man3/sethostid.3.html">sethostid</a></b>(3)) is marked with <u>const:hostid</u>, indicating it may require special care if it is to  be
              called.  In this specific case, the special care amounts to system-wide (not merely intra-process)
              coordination.

       <u>sigintr</u>
              Functions  marked  with  <u>sigintr</u>  as an MT-Safety issue access the GNU C Library <b>_</b><u>sigintr</u> internal
              data structure without any guards to ensure safety in the presence of concurrent modifications.

              We do not mark these functions as MT-Unsafe, however, because  functions  that  modify  this  data
              structure  are all marked with <u>const:sigintr</u> and regarded as unsafe.  Being unsafe, the latter are
              not to be called when multiple threads are running or asynchronous signals are enabled, and so the
              data structure can be considered effectively constant in these contexts, which  makes  the  former
              safe.

       <u>cwd</u>    Functions  marked  with  <u>cwd</u>  as  an  MT-Safety  issue  may temporarily change the current working
              directory during their execution, which may cause relative pathnames to be resolved in  unexpected
              ways in other threads or within asynchronous signal or cancelation handlers.

              This is not enough of a reason to mark so-marked functions as MT-Unsafe, but when this behavior is
              optional  (e.g.,  <b><a href="../man3/nftw.3.html">nftw</a></b>(3)  with <b>FTW_CHDIR</b>), avoiding the option may be a good alternative to using
              full pathnames or file descriptor-relative (e.g., <b><a href="../man2/openat.2.html">openat</a></b>(2)) system calls.

       <u>:identifier</u>
              Annotations may sometimes be followed by identifiers, intended to group  several  functions  that,
              for example, access the data structures in an unsafe way, as in <u>race</u> and <u>const</u>, or to provide more
              specific  information,  such  as  naming a signal in a function marked with <u>sig</u>.  It is envisioned
              that it may be applied to <u>lock</u> and <u>corrupt</u> as well in the future.

              In most cases, the identifier will name a set of functions, but it  may  name  global  objects  or
              function  arguments, or identifiable properties or logical components associated with them, with a
              notation such as, for example, <u>:buf(arg)</u> to denote a buffer associated with the argument  <u>arg</u>,  or
              <u>:tcattr(fd)</u> to denote the terminal attributes of a file descriptor <u>fd</u>.

              The  most  common use for identifiers is to provide logical groups of functions and arguments that
              need to be protected by the same synchronization primitive in order to ensure safe operation in  a
              given context.

       <u>/condition</u>
              Some  safety  annotations  may  be  conditional,  in  that they only apply if a boolean expression
              involving arguments, global variables or even  the  underlying  kernel  evaluates  to  true.   For
              example,  <u>/!ps</u>  and  <u>/one_per_line</u>  indicate the preceding marker only applies when argument <u>ps</u> is
              NULL, or global variable <u>one_per_line</u> is nonzero.

              When all marks that render a function unsafe are adorned with such conditions,  and  none  of  the
              named conditions hold, then the function can be regarded as safe.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7), <b><a href="../man7/signal-safety.7.html">signal-safety</a></b>(7)

Linux man-pages 6.9.1                              2024-05-02                                      <u><a href="../man7/attributes.7.html">attributes</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>