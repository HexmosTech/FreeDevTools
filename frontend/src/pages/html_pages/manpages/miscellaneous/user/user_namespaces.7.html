<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>user_namespaces - overview of Linux user namespaces</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       user_namespaces - overview of Linux user namespaces

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For an overview of namespaces, see <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7).

       User  namespaces  isolate  security-related identifiers and attributes, in particular, user IDs and group
       IDs  (see  <b><a href="../man7/credentials.7.html">credentials</a></b>(7)),  the  root  directory,  keys  (see  <b><a href="../man7/keyrings.7.html">keyrings</a></b>(7)),   and   capabilities   (see
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)).   A  process's user and group IDs can be different inside and outside a user namespace.
       In particular, a process can have a normal unprivileged user ID outside a user  namespace  while  at  the
       same time having a user ID of 0 inside the namespace; in other words, the process has full privileges for
       operations inside the user namespace, but is unprivileged for operations outside the namespace.

   <b>Nested</b> <b>namespaces,</b> <b>namespace</b> <b>membership</b>
       User  namespaces  can be nested; that is, each user namespace—except the initial ("root") namespace—has a
       parent user namespace, and can have zero or more child user namespaces.  The parent user namespace is the
       user namespace of the process that creates the user namespace via a call to <b><a href="../man2/unshare.2.html">unshare</a></b>(2) or  <b><a href="../man2/clone.2.html">clone</a></b>(2)  with
       the <b>CLONE_NEWUSER</b> flag.

       The  kernel  imposes  (since  Linux  3.11)  a  limit  of  32  nested levels of user namespaces.  Calls to
       <b><a href="../man2/unshare.2.html">unshare</a></b>(2) or <b><a href="../man2/clone.2.html">clone</a></b>(2) that would cause this limit to be exceeded fail with the error <b>EUSERS</b>.

       Each process is a member of exactly one user namespace.   A  process  created  via  <b><a href="../man2/fork.2.html">fork</a></b>(2)  or  <b><a href="../man2/clone.2.html">clone</a></b>(2)
       without  the  <b>CLONE_NEWUSER</b> flag is a member of the same user namespace as its parent.  A single-threaded
       process can join another user namespace with <b><a href="../man2/setns.2.html">setns</a></b>(2) if it has the <b>CAP_SYS_ADMIN</b> in that namespace; upon
       doing so, it gains a full set of capabilities in that namespace.

       A call to <b><a href="../man2/clone.2.html">clone</a></b>(2) or <b><a href="../man2/unshare.2.html">unshare</a></b>(2) with the <b>CLONE_NEWUSER</b> flag makes the new child process  (for  <b><a href="../man2/clone.2.html">clone</a></b>(2))
       or the caller (for <b><a href="../man2/unshare.2.html">unshare</a></b>(2)) a member of the new user namespace created by the call.

       The  <b>NS_GET_PARENT</b>  <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)  operation  can  be  used to discover the parental relationship between user
       namespaces; see <b><a href="../man2/ioctl_nsfs.2.html">ioctl_nsfs</a></b>(2).

       A task that changes one  of  its  effective  IDs  will  have  its  dumpability  reset  to  the  value  in
       <u><a href="file:/proc/sys/fs/suid_dumpable">/proc/sys/fs/suid_dumpable</a></u>.   This may affect the ownership of proc files of child processes and may thus
       cause the parent to lack the permissions to write to mapping files of child processes running  in  a  new
       user  namespace.   In  such  cases making the parent process dumpable, using <b>PR_SET_DUMPABLE</b> in a call to
       <b><a href="../man2/prctl.2.html">prctl</a></b>(2), before creating a child process in a new user namespace may rectify this problem.  See <b><a href="../man2/prctl.2.html">prctl</a></b>(2)
       and <b><a href="../man5/proc.5.html">proc</a></b>(5) for details on how ownership is affected.

   <b>Capabilities</b>
       The child process created by <b><a href="../man2/clone.2.html">clone</a></b>(2) with the <b>CLONE_NEWUSER</b> flag starts  out  with  a  complete  set  of
       capabilities  in  the  new  user  namespace.  Likewise, a process that creates a new user namespace using
       <b><a href="../man2/unshare.2.html">unshare</a></b>(2) or joins an existing user namespace using <b><a href="../man2/setns.2.html">setns</a></b>(2) gains a full set of  capabilities  in  that
       namespace.   On  the other hand, that process has no capabilities in the parent (in the case of <b><a href="../man2/clone.2.html">clone</a></b>(2))
       or previous (in the case of <b><a href="../man2/unshare.2.html">unshare</a></b>(2) and <b><a href="../man2/setns.2.html">setns</a></b>(2)) user namespace, even if the new namespace is created
       or joined by the root user (i.e., a process with user ID 0 in the root namespace).

       Note that a call to <b><a href="../man2/execve.2.html">execve</a></b>(2) will cause a process's capabilities to be recalculated  in  the  usual  way
       (see  <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)).  Consequently, unless the process has a user ID of 0 within the namespace, or the
       executable file has a nonempty inheritable capabilities mask, the process  will  lose  all  capabilities.
       See the discussion of user and group ID mappings, below.

       A call to <b><a href="../man2/clone.2.html">clone</a></b>(2) or <b><a href="../man2/unshare.2.html">unshare</a></b>(2) using the <b>CLONE_NEWUSER</b> flag or a call to <b><a href="../man2/setns.2.html">setns</a></b>(2) that moves the caller
       into  another  user  namespace  sets the "securebits" flags (see <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)) to their default values
       (all flags disabled) in the child (for <b><a href="../man2/clone.2.html">clone</a></b>(2)) or caller  (for  <b><a href="../man2/unshare.2.html">unshare</a></b>(2)  or  <b><a href="../man2/setns.2.html">setns</a></b>(2)).   Note  that
       because the caller no longer has capabilities in its original user namespace after a call to <b><a href="../man2/setns.2.html">setns</a></b>(2), it
       is  not  possible  for  a  process  to  reset  its  "securebits" flags while retaining its user namespace
       membership by using a pair of <b><a href="../man2/setns.2.html">setns</a></b>(2) calls to move to another user namespace and  then  return  to  its
       original user namespace.

       The rules for determining whether or not a process has a capability in a particular user namespace are as
       follows:

       •  A  process has a capability inside a user namespace if it is a member of that namespace and it has the
          capability in its effective capability  set.   A  process  can  gain  capabilities  in  its  effective
          capability  set  in  various ways.  For example, it may execute a set-user-ID program or an executable
          with associated file capabilities.  In addition, a process may gain capabilities  via  the  effect  of
          <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/unshare.2.html">unshare</a></b>(2), or <b><a href="../man2/setns.2.html">setns</a></b>(2), as already described.

       •  If  a  process  has  a  capability  in a user namespace, then it has that capability in all child (and
          further removed descendant) namespaces as well.

       •  When a user namespace is created, the kernel records the effective user ID of the creating process  as
          being  the  "owner"  of the namespace.  A process that resides in the parent of the user namespace and
          whose effective user ID matches the owner of the namespace has all capabilities in the namespace.   By
          virtue  of  the previous rule, this means that the process has all capabilities in all further removed
          descendant user namespaces as well.  The <b>NS_GET_OWNER_UID</b> <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operation can be used  to  discover
          the user ID of the owner of the namespace; see <b><a href="../man2/ioctl_nsfs.2.html">ioctl_nsfs</a></b>(2).

   <b>Effect</b> <b>of</b> <b>capabilities</b> <b>within</b> <b>a</b> <b>user</b> <b>namespace</b>
       Having  a  capability  inside  a  user  namespace  permits  a process to perform operations (that require
       privilege) only on resources governed by that namespace.  In other words, having a capability in  a  user
       namespace  permits a process to perform privileged operations on resources that are governed by (nonuser)
       namespaces owned by (associated with) the user namespace (see the next subsection).

       On the other hand, there are many privileged operations that affect resources  that  are  not  associated
       with  any  namespace  type,  for  example,  changing  the  system  (i.e.,  calendar)  time  (governed  by
       <b>CAP_SYS_TIME</b>), loading a kernel module (governed by <b>CAP_SYS_MODULE</b>), and creating a device  (governed  by
       <b>CAP_MKNOD</b>).  Only a process with privileges in the <u>initial</u> user namespace can perform such operations.

       Holding <b>CAP_SYS_ADMIN</b> within the user namespace that owns a process's mount namespace allows that process
       to create bind mounts and mount the following types of filesystems:

           •  <u><a href="file:/proc">/proc</a></u> (since Linux 3.8)
           •  <u><a href="file:/sys">/sys</a></u> (since Linux 3.8)
           •  <u>devpts</u> (since Linux 3.9)
           •  <b><a href="../man5/tmpfs.5.html">tmpfs</a></b>(5) (since Linux 3.9)
           •  <u>ramfs</u> (since Linux 3.9)
           •  <u>mqueue</u> (since Linux 3.9)
           •  <u>bpf</u> (since Linux 4.4)
           •  <u>overlayfs</u> (since Linux 5.11)

       Holding  <b>CAP_SYS_ADMIN</b>  within  the  user  namespace that owns a process's cgroup namespace allows (since
       Linux 4.6) that process to the mount  the  cgroup  version  2  filesystem  and  cgroup  version  1  named
       hierarchies (i.e., cgroup filesystems mounted with the <u>"none,name="</u> option).

       Holding  <b>CAP_SYS_ADMIN</b>  within the user namespace that owns a process's PID namespace allows (since Linux
       3.8) that process to mount <u><a href="file:/proc">/proc</a></u> filesystems.

       Note, however, that  mounting  block-based  filesystems  can  be  done  only  by  a  process  that  holds
       <b>CAP_SYS_ADMIN</b> in the initial user namespace.

   <b>Interaction</b> <b>of</b> <b>user</b> <b>namespaces</b> <b>and</b> <b>other</b> <b>types</b> <b>of</b> <b>namespaces</b>
       Starting  in  Linux  3.8,  unprivileged  processes  can  create  user  namespaces, and the other types of
       namespaces can be created with just the <b>CAP_SYS_ADMIN</b> capability in the caller's user namespace.

       When a nonuser namespace is created, it is owned by the user namespace in which the creating process  was
       a  member  at  the time of the creation of the namespace.  Privileged operations on resources governed by
       the nonuser namespace require that the process has the necessary capabilities in the user namespace  that
       owns the nonuser namespace.

       If  <b>CLONE_NEWUSER</b> is specified along with other <b>CLONE_NEW*</b> flags in a single <b><a href="../man2/clone.2.html">clone</a></b>(2) or <b><a href="../man2/unshare.2.html">unshare</a></b>(2) call,
       the user namespace is guaranteed to be created first, giving the child (<b><a href="../man2/clone.2.html">clone</a></b>(2)) or caller  (<b><a href="../man2/unshare.2.html">unshare</a></b>(2))
       privileges  over  the remaining namespaces created by the call.  Thus, it is possible for an unprivileged
       caller to specify this combination of flags.

       When a new namespace (other than a user namespace) is created via  <b><a href="../man2/clone.2.html">clone</a></b>(2)  or  <b><a href="../man2/unshare.2.html">unshare</a></b>(2),  the  kernel
       records  the user namespace of the creating process as the owner of the new namespace.  (This association
       can't be changed.)  When a process in the new namespace subsequently performs privileged operations  that
       operate  on  global resources isolated by the namespace, the permission checks are performed according to
       the process's capabilities in the user namespace that the kernel associated with the new namespace.   For
       example,  suppose that a process attempts to change the hostname (<b><a href="../man2/sethostname.2.html">sethostname</a></b>(2)), a resource governed by
       the UTS namespace.  In this case, the kernel will determine which user namespace owns the  process's  UTS
       namespace,  and  check  whether  the  process  has  the  required capability (<b>CAP_SYS_ADMIN</b>) in that user
       namespace.

       The <b>NS_GET_USERNS</b> <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operation can be used to discover the  user  namespace  that  owns  a  nonuser
       namespace; see <b><a href="../man2/ioctl_nsfs.2.html">ioctl_nsfs</a></b>(2).

   <b>User</b> <b>and</b> <b>group</b> <b>ID</b> <b>mappings:</b> <b>uid_map</b> <b>and</b> <b>gid_map</b>
       When  a  user namespace is created, it starts out without a mapping of user IDs (group IDs) to the parent
       user namespace.  The <u><a href="file:/proc/">/proc/</a></u>pid<u>/uid_map</u> and <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u> files (available since Linux 3.5) expose the
       mappings for user and group IDs inside the user namespace for the process <u>pid</u>.  These files can  be  read
       to view the mappings in a user namespace and written to (once) to define the mappings.

       The  description  in  the  following  paragraphs explains the details for <u>uid_map</u>; <u>gid_map</u> is exactly the
       same, but each instance of "user ID" is replaced by "group ID".

       The <u>uid_map</u> file exposes the mapping of user IDs from the user namespace of the process <u>pid</u> to  the  user
       namespace  of  the  process  that opened <u>uid_map</u> (but see a qualification to this point below).  In other
       words, processes that are in different user namespaces will potentially see different values when reading
       from a particular <u>uid_map</u> file, depending on the user ID mappings for the user namespaces of the  reading
       processes.

       Each  line  in  the <u>uid_map</u> file specifies a 1-to-1 mapping of a range of contiguous user IDs between two
       user namespaces.  (When a user namespace is first created, this file is  empty.)   The  specification  in
       each  line  takes  the form of three numbers delimited by white space.  The first two numbers specify the
       starting user ID in each of the two user namespaces.  The third number specifies the length of the mapped
       range.  In detail, the fields are interpreted as follows:

       (1)  The start of the range of user IDs in the user namespace of the process <u>pid</u>.

       (2)  The start of the range of user IDs to which the user IDs specified by field one map.  How field  two
            is  interpreted  depends  on  whether the process that opened <u>uid_map</u> and the process <u>pid</u> are in the
            same user namespace, as follows:

            (a)  If the two processes are in different user namespaces: field two is the start  of  a  range  of
                 user IDs in the user namespace of the process that opened <u>uid_map</u>.

            (b)  If  the  two  processes  are in the same user namespace: field two is the start of the range of
                 user IDs in the parent user namespace of the process <u>pid</u>.  This  case  enables  the  opener  of
                 <u>uid_map</u>  (the  common  case  here is opening <u><a href="file:/proc/self/uid_map">/proc/self/uid_map</a></u>) to see the mapping of user IDs
                 into the user namespace of the process that created this user namespace.

       (3)  The length of the range of user IDs that is mapped between the two user namespaces.

       System calls that return user IDs (group IDs)—for  example,  <b><a href="../man2/getuid.2.html">getuid</a></b>(2),  <b><a href="../man2/getgid.2.html">getgid</a></b>(2),  and  the  credential
       fields  in  the structure returned by <b><a href="../man2/stat.2.html">stat</a></b>(2)—return the user ID (group ID) mapped into the caller's user
       namespace.

       When a process accesses a file, its user and group IDs are mapped into the initial user namespace for the
       purpose of permission checking and assigning IDs when creating a file.  When  a  process  retrieves  file
       user  and group IDs via <b><a href="../man2/stat.2.html">stat</a></b>(2), the IDs are mapped in the opposite direction, to produce values relative
       to the process user and group ID mappings.

       The initial user namespace has no parent namespace, but, for consistency, the kernel provides dummy  user
       and  group ID mapping files for this namespace.  Looking at the <u>uid_map</u> file (<u>gid_map</u> is the same) from a
       shell in the initial namespace shows:

           $ <b>cat</b> <b><a href="file:/proc/">/proc/</a>$$/uid_map</b>
                    0          0 4294967295

       This mapping tells us that the range starting at user ID 0 in this namespace maps to a range starting  at
       0  in  the  (nonexistent)  parent  namespace,  and the length of the range is the largest 32-bit unsigned
       integer.  This leaves 4294967295 (the 32-bit signed -1 value) unmapped.  This is deliberate:  <u>(uid_t)</u>  <u>-1</u>
       is  used  in several interfaces (e.g., <b><a href="../man2/setreuid.2.html">setreuid</a></b>(2)) as a way to specify "no user ID".  Leaving <u>(uid_t)</u> <u>-1</u>
       unmapped and unusable guarantees that there will be no confusion when using these interfaces.

   <b>Defining</b> <b>user</b> <b>and</b> <b>group</b> <b>ID</b> <b>mappings:</b> <b>writing</b> <b>to</b> <b>uid_map</b> <b>and</b> <b>gid_map</b>
       After the creation of a new user namespace, the <u>uid_map</u> file of <u>one</u> of the processes in the namespace may
       be written to <u>once</u> to define the mapping of user IDs in the new user namespace.  An attempt to write more
       than once to a <u>uid_map</u> file in a user namespace fails with the error  <b>EPERM</b>.   Similar  rules  apply  for
       <u>gid_map</u> files.

       The lines written to <u>uid_map</u> (<u>gid_map</u>) must conform to the following validity rules:

       •  The three fields must be valid numbers, and the last field must be greater than 0.

       •  Lines are terminated by newline characters.

       •  There  is  a  limit  on  the  number  of lines in the file.  In Linux 4.14 and earlier, this limit was
          (arbitrarily) set at 5 lines.  Since Linux 4.15, the limit is 340 lines.  In addition, the  number  of
          bytes  written  to the file must be less than the system page size, and the write must be performed at
          the start of the file (i.e., <b><a href="../man2/lseek.2.html">lseek</a></b>(2) and <b><a href="../man2/pwrite.2.html">pwrite</a></b>(2) can't be used to write to nonzero offsets  in  the
          file).

       •  The  range  of user IDs (group IDs) specified in each line cannot overlap with the ranges in any other
          lines.  In the initial implementation (Linux 3.8), this requirement  was  satisfied  by  a  simplistic
          implementation  that  imposed  the  further requirement that the values in both field 1 and field 2 of
          successive lines must be in ascending numerical order, which prevented some otherwise valid maps  from
          being  created.   Linux  3.9  and  later fix this limitation, allowing any valid set of nonoverlapping
          maps.

       •  At least one line must be written to the file.

       Writes that violate the above rules fail with the error <b>EINVAL</b>.

       In order for a process to write to the <u><a href="file:/proc/">/proc/</a></u>pid<u>/uid_map</u> (<u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u>) file, all of  the  following
       permission requirements must be met:

       •  The  writing  process  must  have  the <b>CAP_SETUID</b> (<b>CAP_SETGID</b>) capability in the user namespace of the
          process <u>pid</u>.

       •  The writing process must either be in the user namespace of the process <u>pid</u> or be in the  parent  user
          namespace of the process <u>pid</u>.

       •  The mapped user IDs (group IDs) must in turn have a mapping in the parent user namespace.

       •  If updating <u><a href="file:/proc/">/proc/</a></u>pid<u>/uid_map</u> to create a mapping that maps UID 0 in the parent namespace, then one of
          the following must be true:

          (a)  if  writing process is in the parent user namespace, then it must have the <b>CAP_SETFCAP</b> capability
               in that user namespace; or

          (b)  if the writing process is in the child user namespace, then the process  that  created  the  user
               namespace must have had the <b>CAP_SETFCAP</b> capability when the namespace was created.

          This  rule  has been in place since Linux 5.12.  It eliminates an earlier security bug whereby a UID 0
          process that lacks the <b>CAP_SETFCAP</b> capability, which is needed to create a binary with namespaced file
          capabilities (as described in <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)), could  nevertheless  create  such  a  binary,  by  the
          following steps:

          (1)  Create a new user namespace with the identity mapping (i.e., UID 0 in the new user namespace maps
               to  UID  0  in  the parent namespace), so that UID 0 in both namespaces is equivalent to the same
               root user ID.

          (2)  Since the child process has the <b>CAP_SETFCAP</b> capability, it could create a binary with  namespaced
               file  capabilities  that  would  then be effective in the parent user namespace (because the root
               user IDs are the same in the two namespaces).

       •  One of the following two cases applies:

          (a)  <u>Either</u> the writing process  has  the  <b>CAP_SETUID</b>  (<b>CAP_SETGID</b>)  capability  in  the  <u>parent</u>  user
               namespace.

               •  No further restrictions apply: the process can make mappings to arbitrary user IDs (group IDs)
                  in the parent user namespace.

          (b)  <u>Or</u> otherwise all of the following restrictions apply:

               •  The  data  written  to  <u>uid_map</u>  (<u>gid_map</u>) must consist of a single line that maps the writing
                  process's effective user ID (group ID) in the parent user namespace to a user ID (group ID) in
                  the user namespace.

               •  The writing process must have the same effective user ID as the process that created the  user
                  namespace.

               •  In  the  case  of <u>gid_map</u>, use of the <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) system call must first be denied by writing
                  "<u>deny</u>" to the <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u> file (see below) before writing to <u>gid_map</u>.

       Writes that violate the above rules fail with the error <b>EPERM</b>.

   <b>Project</b> <b>ID</b> <b>mappings:</b> <b>projid_map</b>
       Similarly to user and group ID mappings, it is  possible  to  create  project  ID  mappings  for  a  user
       namespace.  (Project IDs are used for disk quotas; see <b><a href="../man8/setquota.8.html">setquota</a></b>(8) and <b><a href="../man2/quotactl.2.html">quotactl</a></b>(2).)

       Project ID mappings are defined by writing to the <u><a href="file:/proc/">/proc/</a></u>pid<u>/projid_map</u> file (present since Linux 3.7).

       The  validity  rules for writing to the <u><a href="file:/proc/">/proc/</a></u>pid<u>/projid_map</u> file are as for writing to the <u>uid_map</u> file;
       violation of these rules causes <b><a href="../man2/write.2.html">write</a></b>(2) to fail with the error <b>EINVAL</b>.

       The permission rules for writing to the <u><a href="file:/proc/">/proc/</a></u>pid<u>/projid_map</u> file are as follows:

       •  The writing process must either be in the user namespace of the process <u>pid</u> or be in the  parent  user
          namespace of the process <u>pid</u>.

       •  The mapped project IDs must in turn have a mapping in the parent user namespace.

       Violation of these rules causes <b><a href="../man2/write.2.html">write</a></b>(2) to fail with the error <b>EPERM</b>.

   <b>Interaction</b> <b>with</b> <b>system</b> <b>calls</b> <b>that</b> <b>change</b> <b>process</b> <b>UIDs</b> <b>or</b> <b>GIDs</b>
       In  a  user  namespace where the <u>uid_map</u> file has not been written, the system calls that change user IDs
       will fail.  Similarly, if the <u>gid_map</u> file has not been written, the system calls that change  group  IDs
       will  fail.  After the <u>uid_map</u> and <u>gid_map</u> files have been written, only the mapped values may be used in
       system calls that change user and group IDs.

       For user IDs, the relevant system calls include <b><a href="../man2/setuid.2.html">setuid</a></b>(2), <b><a href="../man2/setfsuid.2.html">setfsuid</a></b>(2),  <b><a href="../man2/setreuid.2.html">setreuid</a></b>(2),  and  <b><a href="../man2/setresuid.2.html">setresuid</a></b>(2).
       For  group  IDs, the relevant system calls include <b><a href="../man2/setgid.2.html">setgid</a></b>(2), <b><a href="../man2/setfsgid.2.html">setfsgid</a></b>(2), <b><a href="../man2/setregid.2.html">setregid</a></b>(2), <b><a href="../man2/setresgid.2.html">setresgid</a></b>(2), and
       <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2).

       Writing "<u>deny</u>" to the <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u> file  before  writing  to  <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u>  will  permanently
       disable  <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)  in  a  user  namespace  and  allow writing to <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u> without having the
       <b>CAP_SETGID</b> capability in the parent user namespace.

   <b>The</b> <u><b><a href="file:/proc/">/proc/</a></b></u><b>pid</b><u><b>/setgroups</b></u> <b>file</b>
       The <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u> file displays the string "<u>allow</u>" if processes in the user namespace that contains
       the process <u>pid</u> are permitted to employ the <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) system call; it displays "<u>deny</u>" if  <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)
       is  not  permitted  in that user namespace.  Note that regardless of the value in the <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u>
       file (and regardless of the process's capabilities), calls to <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)  are  also  not  permitted  if
       <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u> has not yet been set.

       A  privileged  process  (one  with the <b>CAP_SYS_ADMIN</b> capability in the namespace) may write either of the
       strings "<u>allow</u>" or "<u>deny</u>" to this file <u>before</u> writing a group ID mapping for this user namespace  to  the
       file  <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u>.   Writing  the  string  "<u>deny</u>"  prevents  any process in the user namespace from
       employing <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2).

       The essence of the restrictions described in the preceding paragraph is that it is permitted to write  to
       <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u>  only so long as calling <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) is disallowed because <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u> has not
       been set.  This ensures that a process cannot transition from a state where <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) is allowed to  a
       state  where  <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) is denied; a process can transition only from <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) being disallowed to
       <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) being allowed.

       The default value of this file in the initial user namespace is "<u>allow</u>".

       Once <u><a href="file:/proc/">/proc/</a></u>pid<u>/gid_map</u> has been written to (which has the effect of enabling  <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)  in  the  user
       namespace),  it  is  no longer possible to disallow <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2) by writing "<u>deny</u>" to <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u>
       (the write fails with the error <b>EPERM</b>).

       A child user namespace inherits the <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u> setting from its parent.

       If the <u>setgroups</u> file has the value "<u>deny</u>", then the  <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)  system  call  can't  subsequently  be
       reenabled  (by  writing  "<u>allow</u>"  to  the file) in this user namespace.  (Attempts to do so fail with the
       error <b>EPERM</b>.)  This restriction also propagates down to all child user namespaces of this user namespace.

       The <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u> file was added in Linux 3.19, but was backported to many  earlier  stable  kernel
       series,  because  it  addresses  a  security  issue.   The issue concerned files with permissions such as
       "rwx---rwx".  Such files give fewer permissions to "group" than they do  to  "other".   This  means  that
       dropping  groups  using  <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2)  might  allow  a process file access that it did not formerly have.
       Before the existence of user namespaces this was not a concern, since only a privileged process (one with
       the <b>CAP_SETGID</b> capability) could call <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2).  However, with the introduction of  user  namespaces,
       it  became  possible  for  an  unprivileged  process  to create a new namespace in which the user had all
       privileges.  This then allowed formerly unprivileged users to drop groups and thus gain file access  that
       they  did not previously have.  The <u><a href="file:/proc/">/proc/</a></u>pid<u>/setgroups</u> file was added to address this security issue, by
       denying any pathway for an unprivileged process to drop groups with <b><a href="../man2/setgroups.2.html">setgroups</a></b>(2).

   <b>Unmapped</b> <b>user</b> <b>and</b> <b>group</b> <b>IDs</b>
       There are various places where an unmapped user ID (group ID) may be exposed to user space.  For example,
       the first process in a new user namespace may call <b><a href="../man2/getuid.2.html">getuid</a></b>(2) before a user ID mapping  has  been  defined
       for  the  namespace.  In most such cases, an unmapped user ID is converted to the overflow user ID (group
       ID); the default value for  the  overflow  user  ID  (group  ID)  is  65534.   See  the  descriptions  of
       <u><a href="file:/proc/sys/kernel/overflowuid">/proc/sys/kernel/overflowuid</a></u> and <u><a href="file:/proc/sys/kernel/overflowgid">/proc/sys/kernel/overflowgid</a></u> in <b><a href="../man5/proc.5.html">proc</a></b>(5).

       The  cases  where  unmapped  IDs  are  mapped  in  this fashion include system calls that return user IDs
       (<b><a href="../man2/getuid.2.html">getuid</a></b>(2), <b><a href="../man2/getgid.2.html">getgid</a></b>(2), and similar), credentials passed over a UNIX domain socket,  credentials  returned
       by  <b><a href="../man2/stat.2.html">stat</a></b>(2),  <b><a href="../man2/waitid.2.html">waitid</a></b>(2),  and  the  System  V  IPC  "ctl"  <b>IPC_STAT</b>  operations,  credentials  exposed by
       <u><a href="file:/proc/">/proc/</a></u>pid<u>/status</u> and the files in <u><a href="file:/proc/sysvipc/">/proc/sysvipc/</a>*</u>, credentials returned  via  the  <u>si_uid</u>  field  in  the
       <u>siginfo_t</u>  received  with a signal (see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2)), credentials written to the process accounting file
       (see <b><a href="../man5/acct.5.html">acct</a></b>(5)), and credentials returned with POSIX message queue notifications (see <b><a href="../man3/mq_notify.3.html">mq_notify</a></b>(3)).

       There is one notable case where unmapped user and group  IDs  are  <u>not</u>  converted  to  the  corresponding
       overflow  ID  value.   When viewing a <u>uid_map</u> or <u>gid_map</u> file in which there is no mapping for the second
       field, that field is displayed as 4294967295 (-1 as an unsigned integer).

   <b>Accessing</b> <b>files</b>
       In order to determine permissions when an unprivileged process accesses a file, the  process  credentials
       (UID,  GID)  and the file credentials are in effect mapped back to what they would be in the initial user
       namespace and then compared to determine the permissions that the process has on the file.  The  same  is
       also true of other objects that employ the credentials plus permissions mask accessibility model, such as
       System V IPC objects.

   <b>Operation</b> <b>of</b> <b>file-related</b> <b>capabilities</b>
       Certain  capabilities  allow  a  process  to  bypass various kernel-enforced restrictions when performing
       operations on files owned by other users or groups.  These capabilities are: <b>CAP_CHOWN</b>, <b>CAP_DAC_OVERRIDE</b>,
       <b>CAP_DAC_READ_SEARCH</b>, <b>CAP_FOWNER</b>, and <b>CAP_FSETID</b>.

       Within a user namespace, these capabilities allow a process to bypass the rules if the  process  has  the
       relevant capability over the file, meaning that:

       •  the process has the relevant effective capability in its user namespace; and

       •  the file's user ID and group ID both have valid mappings in the user namespace.

       The  <b>CAP_FOWNER</b>  capability  is  treated  somewhat  exceptionally:  it  allows  a  process  to bypass the
       corresponding rules so long as at least the file's user ID has a mapping in the user namespace (i.e., the
       file's group ID does not need to have a valid mapping).

   <b>Set-user-ID</b> <b>and</b> <b>set-group-ID</b> <b>programs</b>
       When a process inside a user namespace executes  a  set-user-ID  (set-group-ID)  program,  the  process's
       effective  user  (group)  ID  inside  the  namespace  is changed to whatever value is mapped for the user
       (group) ID of the file.  However, if either the user <u>or</u> the group ID of the file has  no  mapping  inside
       the  namespace,  the set-user-ID (set-group-ID) bit is silently ignored: the new program is executed, but
       the process's effective user (group) ID is left unchanged.  (This mirrors the semantics  of  executing  a
       set-user-ID  or  set-group-ID  program  that  resides on a filesystem that was mounted with the <b>MS_NOSUID</b>
       flag, as described in <b><a href="../man2/mount.2.html">mount</a></b>(2).)

   <b>Miscellaneous</b>
       When a process's user and group IDs are passed over a UNIX domain socket to a process in a different user
       namespace (see the description of <b>SCM_CREDENTIALS</b> in <b><a href="../man7/unix.7.html">unix</a></b>(7)), they are translated into the corresponding
       values as per the receiving process's user and group ID mappings.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>NOTES</b></h4><pre>
       Over the years, there have been a lot of features that have been added to the Linux kernel that have been
       made available  only  to  privileged  users  because  of  their  potential  to  confuse  set-user-ID-root
       applications.   In  general,  it  becomes  safe  to  allow the root user in a user namespace to use those
       features because it is impossible, while in a user namespace, to gain more privilege than the  root  user
       of a user namespace has.

   <b>Global</b> <b>root</b>
       The term "global root" is sometimes used as a shorthand for user ID 0 in the initial user namespace.

   <b>Availability</b>
       Use  of  user  namespaces  requires  a  kernel  that  is configured with the <b>CONFIG_USER_NS</b> option.  User
       namespaces require support in a range of subsystems across the kernel.  When an unsupported subsystem  is
       configured into the kernel, it is not possible to configure user namespaces support.

       As  at Linux 3.8, most relevant subsystems supported user namespaces, but a number of filesystems did not
       have the infrastructure needed to map user and group IDs between user namespaces.  Linux  3.9  added  the
       required  infrastructure  support  for many of the remaining unsupported filesystems (Plan 9 (9P), Andrew
       File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).  Linux 3.12 added  support  for  the  last  of  the
       unsupported major filesystems, XFS.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below  is  designed  to allow experimenting with user namespaces, as well as other types of
       namespaces.  It creates namespaces as specified by command-line  options  and  then  executes  a  command
       inside those namespaces.  The comments and <u>usage</u>() function inside the program provide a full explanation
       of the program.  The following shell session demonstrates its use.

       First, we look at the run-time environment:

           $ <b>uname</b> <b>-rs</b>     # Need Linux 3.8 or later
           Linux 3.8.0
           $ <b>id</b> <b>-u</b>         # Running as unprivileged user
           1000
           $ <b>id</b> <b>-g</b>
           1000

       Now  start a new shell in new user (<u>-U</u>), mount (<u>-m</u>), and PID (<u>-p</u>) namespaces, with user ID (<u>-M</u>) and group
       ID (<u>-G</u>) 1000 mapped to 0 inside the user namespace:

           $ <b>./userns_child_exec</b> <b>-p</b> <b>-m</b> <b>-U</b> <b>-M</b> <b>'0</b> <b>1000</b> <b>1'</b> <b>-G</b> <b>'0</b> <b>1000</b> <b>1'</b> <b>bash</b>

       The shell has PID 1, because it is the first process in the new PID namespace:

           bash$ <b>echo</b> <b>$$</b>
           1

       Mounting a new <u><a href="file:/proc">/proc</a></u> filesystem and listing all of the processes visible in the new PID  namespace  shows
       that the shell can't see any processes outside the PID namespace:

           bash$ <b>mount</b> <b>-t</b> <b>proc</b> <b>proc</b> <b><a href="file:/proc">/proc</a></b>
           bash$ <b>ps</b> <b>ax</b>
             PID TTY      STAT   TIME COMMAND
               1 pts/3    S      0:00 bash
              22 pts/3    R+     0:00 ps ax

       Inside  the  user namespace, the shell has user and group ID 0, and a full set of permitted and effective
       capabilities:

           bash$ <b>cat</b> <b><a href="file:/proc/">/proc/</a>$$/status</b> <b>|</b> <b>egrep</b> <b>'^[UG]id'</b>
           Uid: 0    0    0    0
           Gid: 0    0    0    0
           bash$ <b>cat</b> <b><a href="file:/proc/">/proc/</a>$$/status</b> <b>|</b> <b>egrep</b> <b>'^Cap(Prm|Inh|Eff)'</b>
           CapInh:   0000000000000000
           CapPrm:   0000001fffffffff
           CapEff:   0000001fffffffff

   <b>Program</b> <b>source</b>

       /* userns_child_exec.c

          Licensed under GNU General Public License v2 or later

          Create a child process that executes a shell command in new
          namespace(s); allow UID and GID mappings to be specified when
          creating a user namespace.
       */
       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;<a href="file:/usr/include/limits.h">limits.h</a>&gt;
       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;

       struct child_args {
           char **argv;        /* Command to be executed by child, with args */
           int    pipe_fd[2];  /* Pipe used to synchronize parent and child */
       };

       static int verbose;

       static void
       usage(char *pname)
       {
           fprintf(stderr, "Usage: %s [options] cmd [arg...]\n\n", pname);
           fprintf(stderr, "Create a child process that executes a shell "
                   "command in a new user namespace,\n"
                   "and possibly also other new namespace(s).\n\n");
           fprintf(stderr, "Options can be:\n\n");
       #define fpe(str) fprintf(stderr, "    %s", str);
           fpe("-i          New IPC namespace\n");
           fpe("-m          New mount namespace\n");
           fpe("-n          New network namespace\n");
           fpe("-p          New PID namespace\n");
           fpe("-u          New UTS namespace\n");
           fpe("-U          New user namespace\n");
           fpe("-M uid_map  Specify UID map for user namespace\n");
           fpe("-G gid_map  Specify GID map for user namespace\n");
           fpe("-z          Map user's UID and GID to 0 in user namespace\n");
           fpe("            (equivalent to: -M '0 &lt;uid&gt; 1' -G '0 &lt;gid&gt; 1')\n");
           fpe("-v          Display verbose messages\n");
           fpe("\n");
           fpe("If -z, -M, or -G is specified, -U is required.\n");
           fpe("It is not permitted to specify both -z and either -M or -G.\n");
           fpe("\n");
           fpe("Map strings for -M and -G consist of records of the form:\n");
           fpe("\n");
           fpe("    ID-inside-ns   ID-outside-ns   len\n");
           fpe("\n");
           fpe("A map string can contain multiple records, separated"
               " by commas;\n");
           fpe("the commas are replaced by newlines before writing"
               " to map files.\n");

           exit(EXIT_FAILURE);
       }

       /* Update the mapping file 'map_file', with the value provided in
          'mapping', a string that defines a UID or GID mapping. A UID or
          GID mapping consists of one or more newline-delimited records
          of the form:

              ID_inside-ns    ID-outside-ns   length

          Requiring the user to supply a string that contains newlines is
          of course inconvenient for command-line use. Thus, we permit the
          use of commas to delimit records in this string, and replace them
          with newlines before writing the string to the file. */

       static void
       update_map(char *mapping, char *map_file)
       {
           int fd;
           size_t map_len;     /* Length of 'mapping' */

           /* Replace commas in mapping string with newlines. */

           map_len = <a href="../manmapping/strlen.mapping.html">strlen</a>(mapping);
           for (size_t j = 0; j &lt; map_len; j++)
               if (mapping[j] == ',')
                   mapping[j] = '\n';

           fd = open(map_file, O_RDWR);
           if (fd == -1) {
               fprintf(stderr, "ERROR: open %s: %s\n", map_file,
                       strerror(errno));
               exit(EXIT_FAILURE);
           }

           if (write(fd, mapping, map_len) != map_len) {
               fprintf(stderr, "ERROR: write %s: %s\n", map_file,
                       strerror(errno));
               exit(EXIT_FAILURE);
           }

           close(fd);
       }

       /* Linux 3.19 made a change in the handling of <a href="../man2/setgroups.2.html">setgroups</a>(2) and
          the 'gid_map' file to address a security issue.  The issue
          allowed *unprivileged* users to employ user namespaces in
          order to drop groups.  The upshot of the 3.19 changes is that
          in order to update the 'gid_maps' file, use of the setgroups()
          system call in this user namespace must first be disabled by
          writing "deny" to one of the /proc/PID/setgroups files for
          this namespace.  That is the purpose of the following function.  */

       static void
       proc_setgroups_write(pid_t child_pid, char *str)
       {
           char setgroups_path[PATH_MAX];
           int fd;

           snprintf(setgroups_path, PATH_MAX, "<a href="file:/proc/">/proc/</a>%jd/setgroups",
                   (intmax_t) child_pid);

           fd = open(setgroups_path, O_RDWR);
           if (fd == -1) {

               /* We may be on a system that doesn't support
                  /proc/PID/setgroups. In that case, the file won't exist,
                  and the system won't impose the restrictions that Linux 3.19
                  added. That's fine: we don't need to do anything in order
                  to permit 'gid_map' to be updated.

                  However, if the error from open() was something other than
                  the ENOENT error that is expected for that case,  let the
                  user know. */

               if (errno != ENOENT)
                   fprintf(stderr, "ERROR: open %s: %s\n", setgroups_path,
                       strerror(errno));
               return;
           }

           if (write(fd, str, strlen(str)) == -1)
               fprintf(stderr, "ERROR: write %s: %s\n", setgroups_path,
                   strerror(errno));

           close(fd);
       }

       static int              /* Start function for cloned child */
       childFunc(void *arg)
       {
           struct child_args *args = arg;
           char ch;

           /* Wait until the parent has updated the UID and GID mappings.
              See the comment in main(). We wait for end of file on a
              pipe that will be closed by the parent process once it has
              updated the mappings. */

           close(args-&gt;pipe_fd[1]);    /* Close our descriptor for the write
                                          end of the pipe so that we see EOF
                                          when parent closes its descriptor. */
           if (read(args-&gt;pipe_fd[0], &amp;ch, 1) != 0) {
               fprintf(stderr,
                       "Failure in child: read from pipe returned != 0\n");
               exit(EXIT_FAILURE);
           }

           close(args-&gt;pipe_fd[0]);

           /* Execute a shell command. */

           printf("About to exec %s\n", args-&gt;argv[0]);
           execvp(args-&gt;argv[0], args-&gt;argv);
           err(EXIT_FAILURE, "execvp");
       }

       #define STACK_SIZE (1024 * 1024)

       static char child_stack[STACK_SIZE];    /* Space for child's stack */

       int
       main(int argc, char *argv[])
       {
           int flags, opt, map_zero;
           pid_t child_pid;
           struct child_args args;
           char *uid_map, *gid_map;
           const int MAP_BUF_SIZE = 100;
           char map_buf[MAP_BUF_SIZE];
           char map_path[PATH_MAX];

           /* Parse command-line options. The initial '+' character in
              the final getopt() argument prevents GNU-style permutation
              of command-line options. That's useful, since sometimes
              the 'command' to be executed by this program itself
              has command-line options. We don't want getopt() to treat
              those as options to this program. */

           flags = 0;
           verbose = 0;
           gid_map = NULL;
           uid_map = NULL;
           map_zero = 0;
           while ((opt = getopt(argc, argv, "+imnpuUM:G:zv")) != -1) {
               switch (opt) {
               case 'i': flags |= CLONE_NEWIPC;        break;
               case 'm': flags |= CLONE_NEWNS;         break;
               case 'n': flags |= CLONE_NEWNET;        break;
               case 'p': flags |= CLONE_NEWPID;        break;
               case 'u': flags |= CLONE_NEWUTS;        break;
               case 'v': verbose = 1;                  break;
               case 'z': map_zero = 1;                 break;
               case 'M': uid_map = optarg;             break;
               case 'G': gid_map = optarg;             break;
               case 'U': flags |= CLONE_NEWUSER;       break;
               default:  usage(argv[0]);
               }
           }

           /* -M or -G without -U is nonsensical */

           if (((uid_map != NULL || gid_map != NULL || map_zero) &amp;&amp;
                       !(flags &amp; CLONE_NEWUSER)) ||
                   (map_zero &amp;&amp; (uid_map != NULL || gid_map != NULL)))
               usage(argv[0]);

           args.argv = &amp;argv[optind];

           /* We use a pipe to synchronize the parent and child, in order to
              ensure that the parent sets the UID and GID maps before the child
              calls execve(). This ensures that the child maintains its
              capabilities during the execve() in the common case where we
              want to map the child's effective user ID to 0 in the new user
              namespace. Without this synchronization, the child would lose
              its capabilities if it performed an execve() with nonzero
              user IDs (see the <a href="../man7/capabilities.7.html">capabilities</a>(7) man page for details of the
              transformation of a process's capabilities during execve()). */

           if (pipe(args.pipe_fd) == -1)
               err(EXIT_FAILURE, "pipe");

           /* Create the child in new namespace(s). */

           child_pid = clone(childFunc, child_stack + STACK_SIZE,
                             flags | SIGCHLD, &amp;args);
           if (child_pid == -1)
               err(EXIT_FAILURE, "clone");

           /* Parent falls through to here. */

           if (verbose)
               printf("%s: PID of child created by clone() is %jd\n",
                       argv[0], (intmax_t) child_pid);

           /* Update the UID and GID maps in the child. */

           if (uid_map != NULL || map_zero) {
               snprintf(map_path, PATH_MAX, "<a href="file:/proc/">/proc/</a>%jd/uid_map",
                       (intmax_t) child_pid);
               if (map_zero) {
                   snprintf(map_buf, MAP_BUF_SIZE, "0 %jd 1",
                           (intmax_t) getuid());
                   uid_map = map_buf;
               }
               update_map(uid_map, map_path);
           }

           if (gid_map != NULL || map_zero) {
               proc_setgroups_write(child_pid, "deny");

               snprintf(map_path, PATH_MAX, "<a href="file:/proc/">/proc/</a>%jd/gid_map",
                       (intmax_t) child_pid);
               if (map_zero) {
                   snprintf(map_buf, MAP_BUF_SIZE, "0 %ld 1",
                           (intmax_t) getgid());
                   gid_map = map_buf;
               }
               update_map(gid_map, map_path);
           }

           /* Close the write end of the pipe, to signal to the child that we
              have updated the UID and GID maps. */

           close(args.pipe_fd[1]);

           if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */
               err(EXIT_FAILURE, "waitpid");

           if (verbose)
               printf("%s: terminating\n", argv[0]);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/newgidmap.1.html">newgidmap</a></b>(1), <b><a href="../man1/newuidmap.1.html">newuidmap</a></b>(1), <b><a href="../man2/clone.2.html">clone</a></b>(2), <b><a href="../man2/ptrace.2.html">ptrace</a></b>(2), <b><a href="../man2/setns.2.html">setns</a></b>(2),  <b><a href="../man2/unshare.2.html">unshare</a></b>(2),  <b><a href="../man5/proc.5.html">proc</a></b>(5),  <b><a href="../man5/subgid.5.html">subgid</a></b>(5),  <b><a href="../man5/subuid.5.html">subuid</a></b>(5),
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/cgroup_namespaces.7.html">cgroup_namespaces</a></b>(7), <b><a href="../man7/credentials.7.html">credentials</a></b>(7), <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7), <b><a href="../man7/pid_namespaces.7.html">pid_namespaces</a></b>(7)

       The kernel source file <u>Documentation/admin-guide/namespaces/resource-control.rst</u>.

Linux man-pages 6.9.1                              2024-06-15                                 <u><a href="../man7/user_namespaces.7.html">user_namespaces</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>