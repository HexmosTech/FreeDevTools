<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>crypto - OpenSSL cryptographic library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/openssl">openssl_3.0.13-0ubuntu3.5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       crypto - OpenSSL cryptographic library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       See the individual manual pages for details.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The OpenSSL crypto library ("libcrypto") implements a wide range of cryptographic algorithms used in
       various Internet standards. The services provided by this library are used by the OpenSSL implementations
       of TLS and CMS, and they have also been used to implement many other third party products and protocols.

       The functionality includes symmetric encryption, public key cryptography, key agreement, certificate
       handling, cryptographic hash functions, cryptographic pseudo-random number generators, message
       authentication codes (MACs), key derivation functions (KDFs), and various utilities.

   <b>Algorithms</b>
       Cryptographic primitives such as the SHA256 digest, or AES encryption are referred to in OpenSSL as
       "algorithms". Each algorithm may have multiple implementations available for use. For example the RSA
       algorithm is available as a "default" implementation suitable for general use, and a "fips"
       implementation which has been validated to FIPS standards for situations where that is important. It is
       also possible that a third party could add additional implementations such as in a hardware security
       module (HSM).

   <b>Operations</b>
       Different algorithms can be grouped together by their purpose. For example there are algorithms for
       encryption, and different algorithms for digesting data.  These different groups are known as
       "operations" in OpenSSL. Each operation has a different set of functions associated with it. For example
       to perform an encryption operation using AES (or any other encryption algorithm) you would use the
       encryption functions detailed on the <b><a href="../man3/EVP_EncryptInit.3.html">EVP_EncryptInit</a></b>(3) page. Or to perform a digest operation using
       SHA256 then you would use the digesting functions on the <b><a href="../man3/EVP_DigestInit.3.html">EVP_DigestInit</a></b>(3) page.

   <b>Providers</b>
       A provider in OpenSSL is a component that collects together algorithm implementations. In order to use an
       algorithm you must have at least one provider loaded that contains an implementation of it. OpenSSL comes
       with a number of providers and they may also be obtained from third parties. If you don't load a provider
       explicitly (either in program code or via config) then one of the following OpenSSL providers will be
       loaded automatically:

       •   The built-in "default" provider when running on a system that is not operating in FIPS-approved mode.

       •   The "fips" provider when running on a system that is operating in FIPS-approved mode.

   <b>Library</b> <b>contexts</b>
       A  library  context can be thought of as a "scope" within which configuration options take effect. When a
       provider is loaded, it is only loaded within the scope of a given library context.  In  this  way  it  is
       possible  for  different  components of a complex application to each use a different library context and
       have different providers loaded with different configuration settings.

       If an application does not explicitly create a library context then the "default" library context will be
       used.

       Library contexts are represented by the <b>OSSL_LIB_CTX</b> type. Many OpenSSL  API  functions  take  a  library
       context  as  a  parameter.  Applications  can always pass <b>NULL</b> for this parameter to just use the default
       library context.

       The default library context is automatically created the first time it is needed. This will automatically
       load any available configuration file and will initialise OpenSSL for use. Unlike in earlier versions  of
       OpenSSL (prior to 1.1.0) no explicit initialisation steps need to be taken.

       Similarly  when the application exits the default library context is automatically destroyed. No explicit
       de-initialisation steps need to be taken.

       See <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3) for more information about library contexts.  See also "ALGORITHM FETCHING".

   <b>Multi-threaded</b> <b>applications</b>
       As long as OpenSSL has been built with support for threads (the default case on most platforms) then most
       OpenSSL <u>functions</u> are thread-safe in the sense that it is safe to call the same  function  from  multiple
       threads  at  the  same  time.  However  most OpenSSL <u>data</u> <u>structures</u> are not thread-safe. For example the
       <b><a href="../man3/BIO_write.3.html">BIO_write</a></b>(3) and <b><a href="../man3/BIO_read.3.html">BIO_read</a></b>(3) functions are thread safe. However it would  not  be  thread  safe  to  call
       <b>BIO_write()</b>  from one thread while calling <b>BIO_read()</b> in another where both functions are passed the same
       <b>BIO</b> object since both of them may attempt to make changes to the same <b>BIO</b> object.

       There are exceptions to these rules. A small number of functions are not thread safe at all.  Where  this
       is  the  case this restriction should be noted in the documentation for the function. Similarly some data
       structures may be partially or fully thread safe. For example it  is  safe  to  use  an  <b>OSSL_LIB_CTX</b>  in
       multiple threads.

       See <b><a href="../man7/openssl-threads.7.html">openssl-threads</a></b>(7) for a more detailed discussion on OpenSSL threading support.

</pre><h4><b>ALGORITHM</b> <b>FETCHING</b></h4><pre>
       In  order  to use an algorithm an implementation for it must first be "fetched".  Fetching is the process
       of looking through the available implementations, applying  selection  criteria  (via  a  property  query
       string), and finally choosing the implementation that will be used.

       Two types of fetching are supported by OpenSSL - explicit fetching and implicit fetching.

   <b>Property</b> <b>query</b> <b>strings</b>
       When  fetching  an  algorithm  it  is  possible to specify a property query string to guide the selection
       process. For example a property query string of "provider=default" could be used to force  the  selection
       to only consider algorithm implementations in the default provider.

       Property  query strings can be specified explicitly as an argument to a function.  It is also possible to
       specify   a   default   property   query   string   for   the   whole   library   context    using    the
       <b><a href="../man3/EVP_set_default_properties.3.html">EVP_set_default_properties</a></b>(3)  or  <b><a href="../man3/EVP_default_properties_enable_fips.3.html">EVP_default_properties_enable_fips</a></b>(3)  functions.  Where  both default
       properties and function specific properties are specified  then  they  are  combined.  Function  specific
       properties will override default properties where there is a conflict.

       See <b><a href="../man7/property.7.html">property</a></b>(7) for more information about properties.

   <b>Explicit</b> <b>fetching</b>
       Users  of the OpenSSL libraries never query a provider directly for an algorithm implementation. Instead,
       the diverse OpenSSL APIs often have explicit fetching functions that do the  work,  and  they  return  an
       appropriate  algorithm  object  back  to the user. These functions usually have the name "APINAME_fetch",
       where "APINAME" is the name of the operation. For example <b><a href="../man3/EVP_MD_fetch.3.html">EVP_MD_fetch</a></b>(3) can be used to explicitly fetch
       a digest algorithm implementation. The user is responsible for  freeing  the  object  returned  from  the
       "APINAME_fetch" function using "APINAME_free" when it is no longer needed.

       These fetching functions follow a fairly common pattern, where three arguments are passed:

       The library context
           See  <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3)  for  a  more  detailed  description.   This  may be NULL to signify the default
           (global) library context, or a context created by the user. Only providers  loaded  in  this  library
           context  (see <b><a href="../man3/OSSL_PROVIDER_load.3.html">OSSL_PROVIDER_load</a></b>(3)) will be considered by the fetching function. In case no provider
           has been loaded in this library context then the default provider will be loaded as a  fallback  (see
           <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7)).

       An identifier
           For all currently implemented fetching functions this is the algorithm name.

       A property query string
           The property query string used to guide selection of the algorithm implementation.

       The algorithm implementation that is fetched can then be used with other diverse functions that use them.
       For  example  the <b><a href="../man3/EVP_DigestInit_ex.3.html">EVP_DigestInit_ex</a></b>(3) function takes as a parameter an <b>EVP_MD</b> object which may have been
       returned from an earlier call to <b><a href="../man3/EVP_MD_fetch.3.html">EVP_MD_fetch</a></b>(3).

   <b>Implicit</b> <b>fetching</b>
       OpenSSL has a number of functions that return an algorithm object with no associated implementation, such
       as <b><a href="../man3/EVP_sha256.3.html">EVP_sha256</a></b>(3),  <b><a href="../man3/EVP_aes_128_cbc.3.html">EVP_aes_128_cbc</a></b>(3),  <b><a href="../man3/EVP_get_cipherbyname.3.html">EVP_get_cipherbyname</a></b>(3)  or  <b><a href="../man3/EVP_get_digestbyname.3.html">EVP_get_digestbyname</a></b>(3).  These  are
       present for compatibility with OpenSSL before version 3.0 where explicit fetching was not available.

       When  they  are  used  with  functions  like  <b><a href="../man3/EVP_DigestInit_ex.3.html">EVP_DigestInit_ex</a></b>(3)  or  <b><a href="../man3/EVP_CipherInit_ex.3.html">EVP_CipherInit_ex</a></b>(3),  the actual
       implementation to be used is fetched implicitly using default search criteria.

       In some cases implicit fetching can also occur when a NULL algorithm parameter is supplied. In this  case
       an  algorithm  implementation  is  implicitly fetched using default search criteria and an algorithm name
       that is consistent with the context in which it is being used.

       Functions that revolve around <b>EVP_PKEY_CTX</b> and <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3), such as  <b><a href="../man3/EVP_DigestSignInit.3.html">EVP_DigestSignInit</a></b>(3)  and  friends,
       all  fetch  the implementations implicitly.  Because these functions involve both an operation type (such
       as <b><a href="../man3/EVP_SIGNATURE.3.html">EVP_SIGNATURE</a></b>(3)) and an <b><a href="../man3/EVP_KEYMGMT.3.html">EVP_KEYMGMT</a></b>(3) for the <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3), they try the following:

       1.  Fetch the operation type implementation from any provider given a library context and property string
           stored in the <b>EVP_PKEY_CTX</b>.

           If the provider of  the  operation  type  implementation  is  different  from  the  provider  of  the
           <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3)'s <b><a href="../man3/EVP_KEYMGMT.3.html">EVP_KEYMGMT</a></b>(3) implementation, try to fetch a <b><a href="../man3/EVP_KEYMGMT.3.html">EVP_KEYMGMT</a></b>(3) implementation in the same
           provider  as the operation type implementation and export the <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3) to it (effectively making a
           temporary copy of the original key).

           If anything in this step fails, the next step is used as a fallback.

       2.  As a fallback, try to fetch the operation type implementation from the same provider as the  original
           <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3)'s <b><a href="../man3/EVP_KEYMGMT.3.html">EVP_KEYMGMT</a></b>(3), still using the property string from the <b>EVP_PKEY_CTX</b>.

   <b>Performance</b>
       If  you  perform  the  same  operation  many  times  then it is recommended to use "Explicit fetching" to
       prefetch an algorithm once initially, and then pass this  created  object  to  any  operations  that  are
       currently  using  "Implicit  fetching".   See  an  example  of  Explicit fetching in "USING ALGORITHMS IN
       APPLICATIONS".

       Prior to OpenSSL 3.0, constant method tables (such as <b>EVP_sha256()</b>) were used directly to access methods.
       If you pass one of these convenience functions to an operation the fixed methods are  ignored,  and  only
       the name is used to internally fetch methods from a provider.

       If  the  prefetched  object  is not passed to operations, then any implicit fetch will use the internally
       cached prefetched object, but it will still be slower than passing the prefetched object directly.

       Fetching via a provider offers more flexibility, but it is slower than the  old  method,  since  it  must
       search  for  the  algorithm  in  all  loaded providers, and then populate the method table using provider
       supplied methods.  Internally OpenSSL caches similar algorithms on the first fetch (so loading  a  digest
       caches all digests).

       The following methods can be used for prefetching:

       <b><a href="../man3/EVP_MD_fetch.3.html">EVP_MD_fetch</a></b>(3)
       <b><a href="../man3/EVP_CIPHER_fetch.3.html">EVP_CIPHER_fetch</a></b>(3)
       <b><a href="../man3/EVP_KDF_fetch.3.html">EVP_KDF_fetch</a></b>(3)
       <b><a href="../man3/EVP_MAC_fetch.3.html">EVP_MAC_fetch</a></b>(3)
       <b><a href="../man3/EVP_KEM_fetch.3.html">EVP_KEM_fetch</a></b>(3)
       <b><a href="../man3/OSSL_ENCODER_fetch.3.html">OSSL_ENCODER_fetch</a></b>(3)
       <b><a href="../man3/OSSL_DECODER_fetch.3.html">OSSL_DECODER_fetch</a></b>(3)
       <b><a href="../man3/EVP_RAND_fetch.3.html">EVP_RAND_fetch</a></b>(3)

       The following methods are used internally when performing operations:

       <b><a href="../man3/EVP_KEYMGMT_fetch.3.html">EVP_KEYMGMT_fetch</a></b>(3)
       <b><a href="../man3/EVP_KEYEXCH_fetch.3.html">EVP_KEYEXCH_fetch</a></b>(3)
       <b><a href="../man3/EVP_SIGNATURE_fetch.3.html">EVP_SIGNATURE_fetch</a></b>(3)
       <b><a href="../man3/OSSL_STORE_LOADER_fetch.3.html">OSSL_STORE_LOADER_fetch</a></b>(3)

       See   <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7),   &lt;<b><a href="../man7/OSSL_PROVIDER-fips.7.html">OSSL_PROVIDER-fips</a></b>(7)&gt;  and  &lt;<b><a href="../man7/OSSL_PROVIDER-legacy.7.html">OSSL_PROVIDER-legacy</a></b>(7)&gt;for  a  list  of
       algorithm names that can be fetched.

</pre><h4><b>FETCHING</b> <b>EXAMPLES</b></h4><pre>
       The following section provides a series of examples of fetching algorithm implementations.

       Fetch any available implementation of SHA2-256 in the default context. Note  that  some  algorithms  have
       aliases. So "SHA256" and "SHA2-256" are synonymous:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", NULL);
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch any available implementation of AES-128-CBC in the default context:

        EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, "AES-128-CBC", NULL);
        ...
        EVP_CIPHER_free(cipher);

       Fetch an implementation of SHA2-256 from the default provider in the default context:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider=default");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch an implementation of SHA2-256 that is not from the default provider in the default context:

        EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider!=default");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Fetch an implementation of SHA2-256 from the default provider in the specified context:

        EVP_MD *md = EVP_MD_fetch(ctx, "SHA2-256", "provider=default");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Load the legacy provider into the default context and then fetch an implementation of WHIRLPOOL from it:

        /* This only needs to be done once - usually at application start up */
        OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, "legacy");

        EVP_MD *md = EVP_MD_fetch(NULL, "WHIRLPOOL", "provider=legacy");
        ...
        <a href="../manmd/EVP_MD_free.md.html">EVP_MD_free</a>(md);

       Note that in the above example the property string "provider=legacy" is optional since, assuming no other
       providers  have  been  loaded,  the  only  implementation of the "whirlpool" algorithm is in the "legacy"
       provider. Also note that the default provider should be explicitly loaded if it is required  in  addition
       to other providers:

        /* This only needs to be done once - usually at application start up */
        OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, "legacy");
        OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, "default");

        EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, "whirlpool", NULL);
        EVP_MD *md_sha256 = EVP_MD_fetch(NULL, "SHA2-256", NULL);
        ...
        <a href="../manmd_whirlpool/EVP_MD_free.md_whirlpool.html">EVP_MD_free</a>(md_whirlpool);
        <a href="../manmd_sha256/EVP_MD_free.md_sha256.html">EVP_MD_free</a>(md_sha256);

</pre><h4><b>OPENSSL</b> <b>PROVIDERS</b></h4><pre>
       OpenSSL comes with a set of providers.

       The algorithms available in each of these providers may vary due to build time configuration options. The
       <b><a href="../man1/openssl-list.1.html">openssl-list</a></b>(1) command can be used to list the currently available algorithms.

       The  names  of  the  algorithms  shown from <b><a href="../man1/openssl-list.1.html">openssl-list</a></b>(1) can be used as an algorithm identifier to the
       appropriate fetching function. Also see the provider specific  manual  pages  linked  below  for  further
       details about using the algorithms available in each of the providers.

       As  well as the OpenSSL providers third parties can also implement providers.  For information on writing
       a provider see <b><a href="../man7/provider.7.html">provider</a></b>(7).

   <b>Default</b> <b>provider</b>
       The default provider is built in as part of the <u>libcrypto</u> library and contains all of the  most  commonly
       used  algorithm  implementations.  Should  it  be  needed  (if  other  providers  are  loaded  and  offer
       implementations of the same algorithms), the property query string "provider=default" can be  used  as  a
       search  criterion  for  these implementations.  The default provider includes all of the functionality in
       the base provider below.

       If you don't load any providers at all and the system is not running  in  FIPS-approved  mode,  then  the
       "default"  provider will be automatically loaded.  If you explicitly load any provider then the "default"
       provider would also need to be explicitly loaded if it is required.

       See <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7).

   <b>Base</b> <b>provider</b>
       The base provider is built in as part of the <u>libcrypto</u> library and contains algorithm implementations for
       encoding and decoding for OpenSSL keys.  Should it be needed (if other providers  are  loaded  and  offer
       implementations  of  the  same  algorithms),  the  property query string "provider=base" can be used as a
       search criterion for these implementations.  Some encoding and decoding algorithm implementations are not
       FIPS algorithm implementations in themselves but support  algorithms  from  the  FIPS  provider  and  are
       allowed  for  use  in  "FIPS  mode".  The  property  query  string  "fips=yes" can be used to select such
       algorithms.

       See <b><a href="../man7/OSSL_PROVIDER-base.7.html">OSSL_PROVIDER-base</a></b>(7).

   <b>FIPS</b> <b>provider</b>
       The FIPS provider is a dynamically loadable module, and must therefore be loaded  explicitly,  either  in
       code  or  through  OpenSSL configuration (see <b><a href="../man5/config.5.html">config</a></b>(5)). It contains algorithm implementations that have
       been validated according to the FIPS 140-2 standard. Should it be needed (if other providers  are  loaded
       and  offer implementations of the same algorithms), the property query string "provider=fips" can be used
       as a search criterion for these implementations. All  approved  algorithm  implementations  in  the  FIPS
       provider  can  also  be  selected  with  the property "fips=yes". The FIPS provider may also contain non-
       approved algorithm implementations and these can be selected with the property "fips=no".

       If you don't load any providers at all and the system is running in FIPS-approved  mode,  then  the  FIPS
       provider  will be automatically loaded.  If you explicitly load any provider then the FIPS provider would
       also need to be explicitly loaded if it is required.

       See <b><a href="../man7/OSSL_PROVIDER-FIPS.7.html">OSSL_PROVIDER-FIPS</a></b>(7) and <b><a href="../man7/fips_module.7.html">fips_module</a></b>(7).

   <b>Legacy</b> <b>provider</b>
       The legacy provider is a dynamically loadable module, and must therefore be loaded explicitly, either  in
       code  or  through  OpenSSL  configuration (see <b><a href="../man5/config.5.html">config</a></b>(5)). It contains algorithm implementations that are
       considered insecure, or are no longer in common use such as MD2 or RC4. Should it  be  needed  (if  other
       providers  are  loaded  and offer implementations of the same algorithms), the property "provider=legacy"
       can be used as a search criterion for these implementations.

       See <b><a href="../man7/OSSL_PROVIDER-legacy.7.html">OSSL_PROVIDER-legacy</a></b>(7).

   <b>Null</b> <b>provider</b>
       The null provider is built in as part of the <u>libcrypto</u> library. It contains no algorithms in it  at  all.
       When  fetching algorithms the default provider will be automatically loaded if no other provider has been
       explicitly loaded. To prevent that from happening you can explicitly load the null provider.

       See <b><a href="../man7/OSSL_PROVIDER-null.7.html">OSSL_PROVIDER-null</a></b>(7).

</pre><h4><b>USING</b> <b>ALGORITHMS</b> <b>IN</b> <b>APPLICATIONS</b></h4><pre>
       Cryptographic algorithms are made available to applications through use of the "EVP" APIs.  Each  of  the
       various  operations  such as encryption, digesting, message authentication codes, etc., have a set of EVP
       function calls that can be invoked to use them. See the <b><a href="../man7/evp.7.html">evp</a></b>(7) page for further details.

       Most of these follow a common pattern. A "context" object is first created.  For  example  for  a  digest
       operation  you  would  use  an  <b>EVP_MD_CTX</b>,  and  for an encryption/decryption operation you would use an
       <b>EVP_CIPHER_CTX</b>. The operation is then initialised ready for use  via  an  "init"  function  -  optionally
       passing  in  a  set  of  parameters  (using the <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) type) to configure how the operation should
       behave. Next data is fed into the operation in a series of "update" calls.  The  operation  is  finalised
       using  a "final" call which will typically provide some kind of output. Finally the context is cleaned up
       and freed.

       The following shows a complete example for doing this  process  for  digesting  data  using  SHA256.  The
       process is similar for other operations such as encryption/decryption, signatures, message authentication
       codes, etc.

        #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/bio.h&gt;
        #include &lt;openssl/err.h&gt;

        int main(void)
        {
            EVP_MD_CTX *ctx = NULL;
            EVP_MD *sha256 = NULL;
            const unsigned char msg[] = {
                0x00, 0x01, 0x02, 0x03
            };
            unsigned int len = 0;
            unsigned char *outdigest = NULL;
            int ret = 1;

            /* Create a context for the digest operation */
            ctx = EVP_MD_CTX_new();
            if (ctx == NULL)
                goto err;

            /*
             * Fetch the SHA256 algorithm implementation for doing the digest. We're
             * using the "default" library context here (first NULL parameter), and
             * we're not supplying any particular search criteria for our SHA256
             * implementation (second NULL parameter). Any SHA256 implementation will
             * do.
             * In a larger application this fetch would just be done once, and could
             * be used for multiple calls to other operations such as EVP_DigestInit_ex().
             */
            sha256 = EVP_MD_fetch(NULL, "SHA256", NULL);
            if (sha256 == NULL)
                goto err;

           /* Initialise the digest operation */
           if (!EVP_DigestInit_ex(ctx, sha256, NULL))
               goto err;

            /*
             * Pass the message to be digested. This can be passed in over multiple
             * EVP_DigestUpdate calls if necessary
             */
            if (!EVP_DigestUpdate(ctx, msg, <a href="../manmsg/sizeof.msg.html">sizeof</a>(msg)))
                goto err;

            /* Allocate the output buffer */
            outdigest = OPENSSL_malloc(EVP_MD_get_size(sha256));
            if (outdigest == NULL)
                goto err;

            /* Now calculate the digest itself */
            if (!EVP_DigestFinal_ex(ctx, outdigest, &amp;len))
                goto err;

            /* Print out the digest result */
            BIO_dump_fp(stdout, outdigest, len);

            ret = 0;

         err:
            /* Clean up all the resources we allocated */
            OPENSSL_free(outdigest);
            EVP_MD_free(sha256);
            EVP_MD_CTX_free(ctx);
            if (ret != 0)
               ERR_print_errors_fp(stderr);
            return ret;
        }

</pre><h4><b>CONFIGURATION</b></h4><pre>
       By  default  OpenSSL  will  load  a  configuration  file  when it is first used. This will set up various
       configuration settings within the default library context.  Applications that create  their  own  library
       contexts may optionally configure them with a config file using the <b><a href="../man3/OSSL_LIB_CTX_load_config.3.html">OSSL_LIB_CTX_load_config</a></b>(3) function.

       The  configuration  file  can  be  used to automatically load providers and set up default property query
       strings.

       For information on the OpenSSL configuration file format see <b><a href="../man5/config.5.html">config</a></b>(5).

</pre><h4><b>ENCODING</b> <b>AND</b> <b>DECODING</b> <b>KEYS</b></h4><pre>
       Many algorithms require the use of a key. Keys can be generated  dynamically  using  the  EVP  APIs  (for
       example  see  <b><a href="../man3/EVP_PKEY_Q_keygen.3.html">EVP_PKEY_Q_keygen</a></b>(3)).  However  it  is  often  necessary  to  save  or load keys (or their
       associated parameters) to or from some external format such as  PEM  or  DER  (see  <b><a href="../man7/openssl-glossary.7.html">openssl-glossary</a></b>(7)).
       OpenSSL uses encoders and decoders to perform this task.

       Encoders  and  decoders  are  just  algorithm  implementations  in  the  same  way as any other algorithm
       implementation in OpenSSL. They are implemented by providers.  The  OpenSSL  encoders  and  decoders  are
       available in the default provider. They are also duplicated in the base provider.

       For  information  about encoders see <b><a href="../man3/OSSL_ENCODER_CTX_new_for_pkey.3.html">OSSL_ENCODER_CTX_new_for_pkey</a></b>(3). For information about decoders see
       <b><a href="../man3/OSSL_DECODER_CTX_new_for_pkey.3.html">OSSL_DECODER_CTX_new_for_pkey</a></b>(3).

</pre><h4><b>LIBRARY</b> <b>CONVENTIONS</b></h4><pre>
       Many OpenSSL functions that "get" or "set" a value follow a naming convention using the numbers <b>0</b> and  <b>1</b>,
       i.e.  "get0",  "get1",  "set0" and "set1". This can also apply to some functions that "add" a value to an
       existing set, i.e.  "add0" and "add1".

       For example the functions:

        int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
        int X509_add1_trust_object(X509 *x, const ASN1_OBJECT *obj);

       In the <b>0</b> version the ownership of the object is passed to (for an add or set) or retained by (for a  get)
       the parent object. For example after calling the <b>X509_CRL_add0_revoked()</b> function above, ownership of the
       <u>rev</u>  object  is  passed to the <u>crl</u> object. Therefore, after calling this function <u>rev</u> should not be freed
       directly. It will be freed implicitly when <u>crl</u> is freed.

       In the <b>1</b> version the ownership of the object is not passed to or retained by the parent object. Instead a
       copy or "up ref" of the object is performed. So after calling the <b>X509_add1_trust_object()</b> function above
       the application will still be responsible for freeing the <u>obj</u> value where appropriate.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/openssl.1.html">openssl</a></b>(1), <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man7/evp.7.html">evp</a></b>(7), <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3), <b><a href="../man7/openssl-threads.7.html">openssl-threads</a></b>(7),  <b><a href="../man7/property.7.html">property</a></b>(7),  <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7),
       <b><a href="../man7/OSSL_PROVIDER-base.7.html">OSSL_PROVIDER-base</a></b>(7),     <b><a href="../man7/OSSL_PROVIDER-FIPS.7.html">OSSL_PROVIDER-FIPS</a></b>(7),     <b><a href="../man7/OSSL_PROVIDER-legacy.7.html">OSSL_PROVIDER-legacy</a></b>(7),     <b><a href="../man7/OSSL_PROVIDER-null.7.html">OSSL_PROVIDER-null</a></b>(7),
       <b><a href="../man7/openssl-glossary.7.html">openssl-glossary</a></b>(7), <b><a href="../man7/provider.7.html">provider</a></b>(7)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.0.13                                             2025-02-05                                       <u><a href="../man7SSL/CRYPTO.7SSL.html">CRYPTO</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>