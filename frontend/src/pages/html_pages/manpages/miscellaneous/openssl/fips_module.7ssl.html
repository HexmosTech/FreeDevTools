<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fips_module - OpenSSL fips module guide</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openssl">openssl_3.5.0-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fips_module - OpenSSL fips module guide

</pre><h4><b>SYNOPSIS</b></h4><pre>
       See the individual manual pages for details.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This guide details different ways that OpenSSL can be used in conjunction with the FIPS module. Which is
       the correct approach to use will depend on your own specific circumstances and what you are attempting to
       achieve.

       For information related to installing the FIPS module see
       &lt;https://github.com/openssl/openssl/blob/master/README-FIPS.md&gt;.

       Note that the old functions <b>FIPS_mode()</b> and <b>FIPS_mode_set()</b> are no longer present so you must remove them
       from your application if you use them.

       Applications written to use the OpenSSL 3.0 FIPS module should not use any legacy APIs or features that
       avoid the FIPS module. Specifically this includes:

       •   Low level cryptographic APIs (use the high level APIs, such as EVP, instead)

       •   Engines

       •   Any   functions   that   create   or   modify   custom   "METHODS"  (for  example  <b>EVP_MD_meth_new()</b>,
           <b>EVP_CIPHER_meth_new()</b>, <b>EVP_PKEY_meth_new()</b>, <b>RSA_meth_new()</b>, <b>EC_KEY_METHOD_new()</b>, etc.)

       All of the above APIs are deprecated in OpenSSL 3.0 - so a simple rule is to avoid using  all  deprecated
       functions. See <b><a href="../man7/ossl-guide-migration.7.html">ossl-guide-migration</a></b>(7) for a list of deprecated functions.

   <b>Applications</b> <b>running</b> <b>on</b> <b>systems</b> <b>operating</b> <b>in</b> <b>FIPS-approved</b> <b>mode</b>
       When  running  on systems that are operating in FIPS-approved mode and no providers are loaded explicitly
       via the application or config, the FIPS module is loaded implicitly as a fallback  provider  whenever  an
       algorithm  is  fetched  for the first time. The "default" provider is not loaded implicitly in this case,
       and must be loaded explicitly if it is required by an application.

       Every <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3) is created with "fips=yes" as a default property in this  mode  so  that  algorithm
       fetches  will  only  fetch  algorithms that define this property and are FIPS-approved. To use algorithms
       that are not FIPS approved, either specify "-fips" or "fips=no" as a property query string with  fetching
       functions, or use the <b><a href="../man3/EVP_default_properties_enable_fips.3.html">EVP_default_properties_enable_fips</a></b>(3) function to remove the default property for a
       specific <b>OSSL_LIB_CTX</b>.

   <b>Making</b> <b>all</b> <b>applications</b> <b>use</b> <b>the</b> <b>FIPS</b> <b>module</b> <b>by</b> <b>default</b>
       One  simple  approach is to cause all applications that are using OpenSSL to only use the FIPS module for
       cryptographic algorithms by default.

       This approach can be done purely via configuration. As long as applications are built and linked  against
       OpenSSL  3.0  and  do  not  override the loading of the default config file or its settings then they can
       automatically start using the FIPS module without the need for any further code changes.

       To do this the default OpenSSL config file will have to be modified. The location  of  this  config  file
       will  depend on the platform, and any options that were given during the build process. You can check the
       location of the config file by running this command:

           $ openssl version -d
           OPENSSLDIR: "/usr/local/ssl"

       Caution: Many Operating Systems install OpenSSL by default. It is a common error to not have the  correct
       version of OpenSSL in your $PATH. Check that you are running an OpenSSL 3.0 version like this:

           $ openssl version -v
           OpenSSL 3.0.0-dev xx XXX xxxx (Library: OpenSSL 3.0.0-dev xx XXX xxxx)

       The  <b>OPENSSLDIR</b>  value  above gives the directory name for where the default config file is stored. So in
       this case the default config file will be called <u>/usr/local/ssl/openssl.cnf</u>.

       Edit the config file to add the following lines near the beginning:

           config_diagnostics = 1
           openssl_conf = openssl_init

           .include /usr/local/ssl/fipsmodule.cnf

           [openssl_init]
           providers = provider_sect
           alg_section = algorithm_sect

           [provider_sect]
           fips = fips_sect
           base = base_sect

           [base_sect]
           activate = 1

           [algorithm_sect]
           default_properties = fips=yes

       Obviously the include file location above should match the path and name of the FIPS module  config  file
       that you installed earlier.  See &lt;https://github.com/openssl/openssl/blob/master/README-FIPS.md&gt;.

       For FIPS usage, it is recommended that the <b>config_diagnostics</b> option is enabled to prevent accidental use
       of non-FIPS validated algorithms via broken or mistaken configuration.  See <b><a href="../man5/config.5.html">config</a></b>(5).

       Any  applications that use OpenSSL 3.0 and are started after these changes are made will start using only
       the FIPS module unless those applications take explicit steps to avoid this default behaviour. Note  that
       this  configuration  also  activates  the  "base"  provider.  The  base  provider  does  not  include any
       cryptographic algorithms (and therefore does not  impact  the  validation  status  of  any  cryptographic
       operations), but does include other supporting algorithms that may be required. It is designed to be used
       in conjunction with the FIPS module.

       This  approach  has  the  primary  advantage  that  it  is  simple,  and  no code changes are required in
       applications in order to benefit from the FIPS module. There are some disadvantages to this approach:

       •   You may not want all applications to use the FIPS module.

           It may be the case that some applications should and some should not use the FIPS module.

       •   If applications take explicit steps to not load the default config file or set different settings.

           This method will not work for these cases.

       •   The algorithms available in the FIPS module are a subset of the algorithms that are available in  the
           default OpenSSL Provider.

           If any applications attempt to use any algorithms that are not present, then they will fail.

       •   Usage of certain deprecated APIs avoids the use of the FIPS module.

           If any applications use those APIs then the FIPS module will not be used.

   <b>Selectively</b> <b>making</b> <b>applications</b> <b>use</b> <b>the</b> <b>FIPS</b> <b>module</b> <b>by</b> <b>default</b>
       A variation on the above approach is to do the same thing on an individual application basis. The default
       OpenSSL  config  file  depends on the compiled in value for <b>OPENSSLDIR</b> as described in the section above.
       However it is also possible to override the config file to  be  used  via  the  <b>OPENSSL_CONF</b>  environment
       variable.  For  example  the  following,  on  Unix, will cause the application to be executed with a non-
       standard config file location:

           $ OPENSSL_CONF=/my/nondefault/openssl.cnf myapplication

       Using this mechanism you can control which config file is loaded (and hence whether the  FIPS  module  is
       loaded) on an application by application basis.

       This removes the disadvantage listed above that you may not want all applications to use the FIPS module.
       All the other advantages and disadvantages still apply.

   <b>Programmatically</b> <b>loading</b> <b>the</b> <b>FIPS</b> <b>module</b> <b>(default</b> <b>library</b> <b>context)</b>
       Applications  may  choose  to load the FIPS provider explicitly rather than relying on config to do this.
       The config file is still necessary in order to hold the FIPS module config data (such as  its  self  test
       status  and integrity data). But in this case we do not automatically activate the FIPS provider via that
       config file.

       To do things this way configure as per "Making all applications use the FIPS module  by  default"  above,
       but  edit  the <u>fipsmodule.cnf</u> file to remove or comment out the line which says "activate = 1" (note that
       setting this value to 0 is <u>not</u> sufficient).  This means all  the  required  config  information  will  be
       available  to  load  the FIPS module, but it is not automatically loaded when the application starts. The
       FIPS provider can then be loaded programmatically like this:

           #include &lt;openssl/provider.h&gt;

           int main(void)
           {
               OSSL_PROVIDER *fips;
               OSSL_PROVIDER *base;

               fips = OSSL_PROVIDER_load(NULL, "fips");
               if (fips == NULL) {
                   printf("Failed to load FIPS provider\n");
                   exit(EXIT_FAILURE);
               }
               base = OSSL_PROVIDER_load(NULL, "base");
               if (base == NULL) {
                   OSSL_PROVIDER_unload(fips);
                   printf("Failed to load base provider\n");
                   exit(EXIT_FAILURE);
               }

               /* Rest of application */

               OSSL_PROVIDER_unload(base);
               OSSL_PROVIDER_unload(fips);
               exit(EXIT_SUCCESS);
           }

       Note that this should be one of the first things  that  you  do  in  your  application.  If  any  OpenSSL
       functions  get  called  that  require  the  use of cryptographic functions before this occurs then, if no
       provider has yet been loaded, then the default provider will be automatically loaded. If you  then  later
       explicitly load the FIPS provider then you will have both the FIPS and the default provider loaded at the
       same   time.  It  is  unspecified  which  implementation  of  an  algorithm  will  be  used  if  multiple
       implementations are available and you have not explicitly specified via  a  property  query  (see  below)
       which one should be used.

       Also  note that in this example we have additionally loaded the "base" provider.  This loads a sub-set of
       algorithms that are also available in the default provider - specifically non  cryptographic  ones  which
       may  be used in conjunction with the FIPS provider. For example this contains algorithms for encoding and
       decoding keys. If you decide not to load the default provider then you will usually want to load the base
       provider instead.

       In this example we are using the "default" library context. OpenSSL functions operate within the scope of
       a library context. If no library context is explicitly specified then  the  default  library  context  is
       used. For further details about library contexts see the <b><a href="../man3/OSSL_LIB_CTX.3.html">OSSL_LIB_CTX</a></b>(3) man page.

   <b>Loading</b> <b>the</b> <b>FIPS</b> <b>module</b> <b>at</b> <b>the</b> <b>same</b> <b>time</b> <b>as</b> <b>other</b> <b>providers</b>
       It is possible to have the FIPS provider and other providers (such as the default provider) all loaded at
       the same time into the same library context. You can use a property query string during algorithm fetches
       to specify which implementation you would like to use.

       For  example  to  fetch  an implementation of SHA256 which conforms to FIPS standards you can specify the
       property query "fips=yes" like this:

           EVP_MD *sha256;

           sha256 = EVP_MD_fetch(NULL, "SHA2-256", "fips=yes");

       If no property query is specified, or more than one implementation matches the property query then it  is
       unspecified which implementation of a particular algorithm will be returned.

       This example shows an explicit request for an implementation of SHA256 from the default provider:

           EVP_MD *sha256;

           sha256 = EVP_MD_fetch(NULL, "SHA2-256", "provider=default");

       It  is  also  possible  to  set  a  default property query string. The following example sets the default
       property query of "fips=yes" for all fetches within the default library context:

           EVP_set_default_properties(NULL, "fips=yes");

       If a fetch function has both an explicit property query  specified,  and  a  default  property  query  is
       defined  then  the two queries are merged together and both apply. The local property query overrides the
       default properties if the same property name is specified in both.

       There are two important built-in properties that you should be aware of:

       The "provider" property enables you to specify which provider you want an implementation  to  be  fetched
       from,  e.g.  "provider=default"  or  "provider=fips".  All algorithms implemented in a provider have this
       property set on them.

       There is also the "fips" property. All FIPS algorithms match against the property query "fips=yes". There
       are also some non-cryptographic algorithms available in the default and base providers that also have the
       "fips=yes" property defined for them. These are the encoder and decoder algorithms that can (for example)
       be used to write out a key generated in the FIPS provider to a file. The encoder and  decoder  algorithms
       are not in the FIPS module itself but are allowed to be used in conjunction with the FIPS algorithms.

       It  is possible to specify default properties within a config file. For example the following config file
       automatically loads the default and FIPS providers and sets the default property value to be  "fips=yes".
       Note  that  this  config  file  does  not load the "base" provider. All supporting algorithms that are in
       "base" are also in "default", so it is unnecessary in this case:

           config_diagnostics = 1
           openssl_conf = openssl_init

           .include /usr/local/ssl/fipsmodule.cnf

           [openssl_init]
           providers = provider_sect
           alg_section = algorithm_sect

           [provider_sect]
           fips = fips_sect
           default = default_sect

           [default_sect]
           activate = 1

           [algorithm_sect]
           default_properties = fips=yes

   <b>Programmatically</b> <b>loading</b> <b>the</b> <b>FIPS</b> <b>module</b> <b>(nondefault</b> <b>library</b> <b>context)</b>
       In addition to using properties to separate usage of the FIPS module from other usages this can  also  be
       achieved  using  library  contexts.  In this example we create two library contexts. In one we assume the
       existence of a config file called <u>openssl-fips.cnf</u> that automatically loads and configures the  FIPS  and
       base providers. The other library context will just use the default provider.

           OSSL_LIB_CTX *fips_libctx, *nonfips_libctx;
           OSSL_PROVIDER *defctxnull = NULL;
           EVP_MD *fipssha256 = NULL, *nonfipssha256 = NULL;
           int ret = 1;

           /*
            * Create two nondefault library contexts. One for fips usage and
            * one for non-fips usage
            */
           fips_libctx = OSSL_LIB_CTX_new();
           nonfips_libctx = OSSL_LIB_CTX_new();
           if (fips_libctx == NULL || nonfips_libctx == NULL)
               goto err;

           /* Prevent anything from using the default library context */
           defctxnull = OSSL_PROVIDER_load(NULL, "null");

           /*
            * Load config file for the FIPS library context. We assume that
            * this config file will automatically activate the FIPS and base
            * providers so we don't need to explicitly load them here.
            */
           if (!OSSL_LIB_CTX_load_config(fips_libctx, "openssl-fips.cnf"))
               goto err;

           /*
            * Set the default property query on the FIPS library context to
            * ensure that only FIPS algorithms can be used.  There are a few non-FIPS
            * approved algorithms in the FIPS provider for backward compatibility reasons.
            */
           if (!EVP_set_default_properties(fips_libctx, "fips=yes"))
               goto err;

           /*
            * We don't need to do anything special to load the default
            * provider into nonfips_libctx. This happens automatically if no
            * other providers are loaded.
            * Because we don't call OSSL_LIB_CTX_load_config() explicitly for
            * nonfips_libctx it will just use the default config file.
            */

           /* As an example get some digests */

           /* Get a FIPS validated digest */
           fipssha256 = EVP_MD_fetch(fips_libctx, "SHA2-256", NULL);
           if (fipssha256 == NULL)
               goto err;

           /* Get a non-FIPS validated digest */
           nonfipssha256 = EVP_MD_fetch(nonfips_libctx, "SHA2-256", NULL);
           if (nonfipssha256 == NULL)
               goto err;

           /* Use the digests */

           printf("Success\n");
           ret = 0;

           err:
           EVP_MD_free(fipssha256);
           EVP_MD_free(nonfipssha256);
           OSSL_LIB_CTX_free(fips_libctx);
           OSSL_LIB_CTX_free(nonfips_libctx);
           OSSL_PROVIDER_unload(defctxnull);

           return ret;

       Note  that  we  have  made use of the special "null" provider here which we load into the default library
       context. We could have chosen to use the default library context for FIPS  usage,  and  just  create  one
       additional  library  context  for other usages - or vice versa. However if code has not been converted to
       use library contexts then the default library context will be automatically used.  This could be the case
       for your own existing applications as well as certain parts of OpenSSL itself. Not all parts  of  OpenSSL
       are  library  context  aware. If this happens then you could "accidentally" use the wrong library context
       for a particular operation. To be sure this doesn't happen you can load  the  "null"  provider  into  the
       default  library  context.  Because  a provider has been explicitly loaded, the default provider will not
       automatically load. This means code using the default context by accident will fail because no algorithms
       will be available.

       See "Library Context" in <b><a href="../man7/ossl-guide-migration.7.html">ossl-guide-migration</a></b>(7) for additional information about the Library Context.

   <b>Using</b> <b>Encoders</b> <b>and</b> <b>Decoders</b> <b>with</b> <b>the</b> <b>FIPS</b> <b>module</b>
       Encoders and decoders are used to read and write keys or parameters from or to some external format  (for
       example  a  PEM file). If your application generates keys or parameters that then need to be written into
       PEM or DER format then it is likely that you will need to use an encoder to do this. Similarly you need a
       decoder to read previously saved keys and parameters. In most cases this will be invisible to you if  you
       are  using  APIs  that  existed  in  OpenSSL  1.1.1  or  earlier  such  as <b><a href="../man3/i2d_PrivateKey.3.html">i2d_PrivateKey</a></b>(3). However the
       appropriate encoder/decoder will need to be available in the library context associated with the  key  or
       parameter object. The built-in OpenSSL encoders and decoders are implemented in both the default and base
       providers  and  are  not in the FIPS module boundary. However since they are not cryptographic algorithms
       themselves it is still possible to use them in conjunction with the  FIPS  module,  and  therefore  these
       encoders/decoders  have  the "fips=yes" property against them.  You should ensure that either the default
       or base provider is loaded into the library context in this case.

   <b>Using</b> <b>the</b> <b>FIPS</b> <b>module</b> <b>in</b> <b>SSL/TLS</b>
       Writing an application that uses libssl in conjunction with the FIPS module is much the same as writing a
       normal libssl application. If you are using global properties and the default library context to  specify
       usage  of  FIPS validated algorithms then this will happen automatically for all cryptographic algorithms
       in libssl. If you are using a nondefault library context to load the FIPS provider then  you  can  supply
       this to libssl using the function <b><a href="../man3/SSL_CTX_new_ex.3.html">SSL_CTX_new_ex</a></b>(3). This works as a drop in replacement for the function
       <b><a href="../man3/SSL_CTX_new.3.html">SSL_CTX_new</a></b>(3)  except it provides you with the capability to specify the library context to be used. You
       can also use the same function to specify libssl specific properties to use.

       In this first example we create two SSL_CTX objects using two different library contexts.

           /*
            * We assume that a nondefault library context with the FIPS
            * provider loaded has been created called fips_libctx.
            */
           SSL_CTX *fips_ssl_ctx = SSL_CTX_new_ex(fips_libctx, "fips=yes", TLS_method());
           /*
            * We assume that a nondefault library context with the default
            * provider loaded has been created called non_fips_libctx.
            */
           SSL_CTX *non_fips_ssl_ctx = SSL_CTX_new_ex(non_fips_libctx, NULL,
                                                      TLS_method());

       In this second example we create two SSL_CTX objects using different properties to specify FIPS usage:

           /*
            * The "fips=yes" property includes all FIPS approved algorithms
            * as well as encoders from the default provider that are allowed
            * to be used. The NULL below indicates that we are using the
            * default library context.
            */
           SSL_CTX *fips_ssl_ctx = SSL_CTX_new_ex(NULL, "fips=yes", TLS_method());
           /*
            * The "provider!=fips" property allows algorithms from any
            * provider except the FIPS provider
            */
           SSL_CTX *non_fips_ssl_ctx = SSL_CTX_new_ex(NULL, "provider!=fips",
                                                      TLS_method());

   <b>Confirming</b> <b>that</b> <b>an</b> <b>algorithm</b> <b>is</b> <b>being</b> <b>provided</b> <b>by</b> <b>the</b> <b>FIPS</b> <b>module</b>
       A chain of links needs to be followed to go from an algorithm instance to the  provider  that  implements
       it. The process is similar for all algorithms. Here the example of a digest is used.

       To  go  from  an  <b>EVP_MD_CTX</b>  to  an  <b>EVP_MD</b>,  use  <b><a href="../man3/EVP_MD_CTX_md.3.html">EVP_MD_CTX_md</a></b>(3)  .   To  go  from  the <b>EVP_MD</b> to its
       <b>OSSL_PROVIDER</b>,  use  <b><a href="../man3/EVP_MD_get0_provider.3.html">EVP_MD_get0_provider</a></b>(3).   To  extract  the  name  from   the   <b>OSSL_PROVIDER</b>,   use
       <b><a href="../man3/OSSL_PROVIDER_get0_name.3.html">OSSL_PROVIDER_get0_name</a></b>(3).

   <b>FIPS</b> <b>indicators</b>
       FIPS  indicators  have been added to the FIPS provider in OpenSSL 3.4.  FIPS 140-3 requires indicators to
       be used if the FIPS provider allows non approved algorithms. An algorithm is approved if  it  passes  all
       required  checks  such  as  minimum  key  size.  By  default an error will occur if any check fails.  For
       backwards compatibility individual algorithms may override the checks by using either an  option  in  the
       FIPS configuration (See "FIPS indicator options" in <b><a href="../man5/fips_config.5.html">fips_config</a></b>(5)) OR in code using an algorithm context
       setter.    Overriding    the    check    means    that    the    algorithm   is   not   FIPS   compliant.
       <b><a href="../man3/OSSL_INDICATOR_set_callback.3.html">OSSL_INDICATOR_set_callback</a></b>(3) can be called to register a callback to log unapproved algorithms. At  the
       end  of  any  algorithm operation the approved status can be queried using an algorithm context getter to
       retrieve the indicator (e.g. "fips-indicator").  An example of an algorithm context setter is "key-check"
       in "Supported parameters" in <b><a href="../man7/EVP_KDF-HKDF.7.html">EVP_KDF-HKDF</a></b>(7).

       The following algorithms use "fips-indicator" to query if the algorithm is approved:

       DSA Key generation
           DSA Key generation is no longer approved.  See "DSA parameters" in <b><a href="../man7/EVP_PKEY-DSA.7.html">EVP_PKEY-DSA</a></b>(7)

       DSA Signatures
           DSA Signature generation is no longer approved.  See "Signature Parameters" in <b><a href="../man7/EVP_SIGNATURE-DSA.7.html">EVP_SIGNATURE-DSA</a></b>(7)

       ECDSA Signatures
           See "ECDSA Signature Parameters" in <b><a href="../man7/EVP_SIGNATURE-ECDSA.7.html">EVP_SIGNATURE-ECDSA</a></b>(7)

       EC Key Generation
           See "Common EC parameters" in <b><a href="../man7/EVP_PKEY-EC.7.html">EVP_PKEY-EC</a></b>(7)

       RSA Encryption
           "pkcs1" padding is no longer approved.

           See "RSA Asymmetric  Cipher  parameters"  in  <b><a href="../man7/EVP_ASYM_CIPHER-RSA.7.html">EVP_ASYM_CIPHER-RSA</a></b>(7)  and  "RSA  KEM  parameters"  in
           <b><a href="../man7/EVP_KEM-RSA.7.html">EVP_KEM-RSA</a></b>(7)

       RSA Signatures
           See "Signature Parameters" in <b><a href="../man7/EVP_SIGNATURE-RSA.7.html">EVP_SIGNATURE-RSA</a></b>(7)

       DRBGS
           See "Supported parameters" in <b><a href="../man7/EVP_RAND-HASH-DRBG.7.html">EVP_RAND-HASH-DRBG</a></b>(7) and <b><a href="../man7/EVP_RAND-HMAC-DRBG.7.html">EVP_RAND-HMAC-DRBG</a></b>(7)/Supported parameters&gt;

       DES Triple-DES is not longer approved for encryption.  See "Parameters" in <b><a href="../man7/EVP_CIPHER-DES.7.html">EVP_CIPHER-DES</a></b>(7)

       DH  See "DH and DHX key exchange parameters" in <b><a href="../man7/EVP_KEYEXCH-DH.7.html">EVP_KEYEXCH-DH</a></b>(7)

       ECDH
           See "ECDH Key Exchange parameters" in <b><a href="../man7/EVP_KEYEXCH-ECDH.7.html">EVP_KEYEXCH-ECDH</a></b>(7)

       KDFS
           See relevant KDF documentation e.g. "Supported parameters" in <b><a href="../man7/EVP_KDF-HKDF.7.html">EVP_KDF-HKDF</a></b>(7)

       CMAC and KMAC
           See "Supported parameters" in <b><a href="../man7/EVP_MAC-CMAC.7.html">EVP_MAC-CMAC</a></b>(7) and "Supported parameters" in <b><a href="../man7/EVP_MAC-KMAC.7.html">EVP_MAC-KMAC</a></b>(7)

       The following FIPS algorithms are unapproved and use the "fips-indicator".

       RAND-TEST-RAND
           See  "Supported parameters" in <b><a href="../man7/EVP_RAND-TEST-RAND.7.html">EVP_RAND-TEST-RAND</a></b>(7) The indicator callback is NOT triggered for this
           algorithm since it is used internally for non security purposes.

       X25519 and X448 Key Generation and Key Exchange

       The unapproved (non FIPS validated) algorithms have a property query value of "fips=no".

       The following algorithms use a unique indicator and do not trigger the indicator callback.

       AES-GCM ciphers support the indicator "iv-generated"
           See "PARAMETERS" in <b><a href="../man3/EVP_EncryptInit.3.html">EVP_EncryptInit</a></b>(3) for further information.

       ECDSA and RSA Signatures support the indicator "verify-message".
           See  "ECDSA  Signature  Parameters"  in  <b><a href="../man7/EVP_SIGNATURE-ECDSA.7.html">EVP_SIGNATURE-ECDSA</a></b>(7)   and   "Signature   Parameters"   in
           <b><a href="../man7/EVP_SIGNATURE-RSA.7.html">EVP_SIGNATURE-RSA</a></b>(7) /for further information.

</pre><h4><b>NOTES</b></h4><pre>
       Some  released versions of OpenSSL do not include a validated FIPS provider.  To determine which versions
       have   undergone   the   validation   process,   please   refer   to   the   OpenSSL    Downloads    page
       &lt;https://www.openssl.org/source/&gt;.   If you require FIPS-approved functionality, it is essential to build
       your FIPS provider using one of the validated versions listed there.  Normally, it is possible to utilize
       a FIPS provider constructed from one of the validated versions alongside <u>libcrypto</u>  and  <u>libssl</u>  compiled
       from any release within the same major release series.  This flexibility enables you to address bug fixes
       and CVEs that fall outside the FIPS boundary.

       As  the  FIPS  provider  still  supports  non-FIPS validated algorithms, The property query "fips=yes" is
       mandatory for applications that want to operate in a FIPS approved manner.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ossl-guide-migration.7.html">ossl-guide-migration</a></b>(7), <b><a href="../man7/crypto.7.html">crypto</a></b>(7), <b><a href="../man5/fips_config.5.html">fips_config</a></b>(5), &lt;https://www.openssl.org/source/&gt;

</pre><h4><b>HISTORY</b></h4><pre>
       The FIPS module guide was created for use with the new FIPS provider in  OpenSSL  3.0.   FIPS  indicators
       were added in OpenSSL 3.4.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2021-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                  <u><a href="../man7SSL/FIPS_MODULE.7SSL.html">FIPS_MODULE</a></u>(7SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>