<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>icecream - A distributed compile system</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/icecc">icecc_1.4-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       icecream - A distributed compile system

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Icecream is a distributed compile system for C and C++.

       Icecream  is  created by SUSE and is based on ideas and code by distcc. Like distcc it takes compile jobs
       from your build and distributes it to remote machines allowing a parallel build on several  machines  you
       have got. But unlike distcc Icecream uses a central server that schedules the compile jobs to the fastest
       free  server  and is as this dynamic. This advantage pays off mostly for shared computers, if you are the
       only user on X machines, you have full control over them anyway.

</pre><h4><b>HOW</b> <b>TO</b> <b>USE</b> <b>ICECREAM</b></h4><pre>
       You need:

       • One machine that runs the scheduler (<b>icecc-scheduler</b> <b>-d</b>)

       • Many machines that run the daemon (<b>iceccd</b> <b>-d</b>)

       If you want to compile using icecream, make sure <u>$prefix/lib/icecc/bin</u> is the first entry in  your  path,
       e.g.  type  <b>export</b> <b>PATH=/usr/lib/icecc/bin:$PATH</b> (Hint: put this in <u><a href="file:~/.bashrc">~/.bashrc</a></u> or <u><a href="file:/etc/profile">/etc/profile</a></u> to not have
       to type it in everytime)

       Then you just compile with <b>make</b> <b>-j</b> <u>num</u>, where num is the amount of jobs you want to compile in  parallel.
       Do  not exaggerate. Too large numbers can overload your machine or the compile cluster and make the build
       in fact slower.

              <b>Warning</b>

              Never use icecream in untrusted environments. Run the daemons and the  scheduler  as  unpriviliged
              user  in such networks if you have to! But you will have to rely on homogeneous networks then (see
              below).

       If you want an overview of your icecream compile cluster, or if you just want funny stats, you might want
       to run icemon.

</pre><h4><b>USING</b> <b>ICECREAM</b> <b>IN</b> <b>HETEROGENEOUS</b> <b>ENVIRONMENTS</b></h4><pre>
       If you are running icecream daemons in the same  icecream  network  but  on  machines  with  incompatible
       compiler  versions, icecream needs to send your build environment to remote machines (note: they <u>all</u> must
       be running as root if compiled without libcap-ng support. In the future icecream might gain  the  ability
       to know when machines cannot accept a different environment, but for now it is all or nothing).

       Under  normal  circumstances  this  is handled transparently by the icecream daemon, which will prepare a
       tarball with the environment when needed.   This  is  the  recommended  way,  as  the  daemon  will  also
       automatically update the tarball whenever your compiler changes.

       If  you want to handle this manually for some reason, you have to tell icecream which environment you are
       using. Use <b>icecc</b> <b>--build-native</b> to create an archive file containing all the files necessary to setup the
       compiler    environment.     The     file     will     have     a     random     unique     name     like
       <u>ddaea39ca1a7c88522b185eca04da2d8.tar.bz2</u>  per  default.  Rename  it to something more expressive for your
       convenience, e.g. <u>i386-3.3.1.tar.bz2</u>.  Set  <b>ICECC_VERSION=</b><u>filename_of_archive_containing_your_environment</u>
       in the shell environment where you start the compile jobs and the file will be transferred to the daemons
       where  your  compile jobs run and installed to a chroot environment for executing the compile jobs in the
       environment fitting to the environment of the client. This requires that  the  icecream  daemon  runs  as
       root.

</pre><h4><b>CROSS-COMPILING</b> <b>USING</b> <b>ICECREAM</b></h4><pre>
       SUSE got quite some good machines not having a processor from Intel or AMD, so icecream is pretty good in
       using   cross-compiler  environments  similar  to  the  above  way  of  spreading  compilers.  There  the
       ICECC_VERSION variable looks like &lt;native_filename&gt;(,&lt;platform&gt;:&lt;cross_compiler_filename&gt;)*, for  example
       like this: /work/9.1-i386.tar.bz2,ia64:/work/9.1-cross-ia64.tar.bz2

       How  to  package  such a cross compiler is pretty straightforward if you look what is inside the tarballs
       generated by <b>icecc</b> <b>--build-native</b>.

</pre><h4><b>CROSS-COMPILING</b> <b>FOR</b> <b>EMBEDDED</b> <b>TARGETS</b> <b>USING</b> <b>ICECREAM</b></h4><pre>
       When building for embedded targets like ARM often you will have a toolchain that runs on  your  host  and
       produces code for the target. In these situations you can exploit the power of icecream as well.

       Create  symlinks  from  where  icecc  is  to  the  name  of  your cross compilers (e.g. <u>arm-linux-g++</u> and
       <u>arm-linux-gcc</u>), make sure that these symlinks are in the path and before the path of your toolchain, with
       $ICECC_CC and $ICECC_CXX you need to tell icecream which compilers to use  for  preprocessing  and  local
       compiling. e.g. set it to <b>ICECC_CC=arm-linux-gcc</b> and <b>ICECC_CXX=arm-linux-g++</b>.

       As  the  next step you need to create a .tar.bz2 of your cross compiler, check the result of build-native
       to see what needs to be present.

       Finally one needs to set ICECC_VERSION and point it to the .tar.bz2 you have  created.   When  you  start
       compiling your toolchain will be used.

              <b>Note</b>

              With  ICECC_VERSION  you point out on which platforms your toolchain runs, you do not indicate for
              which target code will be generated.

</pre><h4><b>CROSS-COMPILING</b> <b>FOR</b> <b>MULTIPLE</b> <b>TARGETS</b> <b>IN</b> <b>THE</b> <b>SAME</b> <b>ENVIRONMENT</b> <b>USING</b> <b>ICECREAM</b></h4><pre>
       When working with toolchains for multiple  targets,  icecream  can  be  configured  to  support  multiple
       toolchains in the same environment.

       Multiple toolchains can be configured by appending =&lt;target&gt; to the tarball filename in the ICECC_VERSION
       variable.  Where  the  &lt;target&gt;  is the cross compiler prefix. There the ICECC_VERSION variable will look
       like &lt;native_filename&gt;(,&lt;platform&gt;:&lt;cross_compiler_filename&gt;=&lt;target&gt;)*.

       Below an  example  of  how  to  configure  icecream  to  use  two  toolchains,  /work/toolchain1/bin/arm-
       eabi-[gcc,g++] and /work/toolchain2/bin/arm-linux-androideabi-[gcc,g++], for the same host architecture:

       • Create  symbolic  links  with  the  cross  compilers  names  (e.g.  arm-eabi-[gcc,g++]  and  arm-linux-
         androideabi-[gcc,g++]) pointing to where the icecc binary is. Make sure these symbolic links are in the
         $PATH and before the path of the toolchains.

       • Create a tarball file for each toolchain that you want  to  use  with  icecream.  The  <u>icecc-create-env</u>
         script  can  be  used  to  create  the  tarball  file for each toolchain, for example: <b>icecc-create-env</b>
         <b>/work/toolchain1/bin/arm-eabi-gcc</b> <b>icecc-create-env</b> <b>/work/toolchain2/bin/arm-linux-androideabi-gcc</b>.

       • Set ICECC_VERSION to point to the native tarball  file  and  for  each  tarball  file  created  to  the
         toolchains       (e.g      ICECC_VERSION=/work/i386-native.tar.gz,/work/arm-eabi-toolchain1.tar.gz=arm-
         eabi,/work/arm-linux-androideabi-toolchain2.tar.gz=arm-linux-androideabi).

       With these steps the icecrem will use <u>/work/arm-eabi-toolchain1.tar.gz</u> file to cross compilers  with  the
       prefix  arm-eabi  (e.g. <b>arm-eabi-gcc</b> and <b>arm-eabi-g++</b>), use <u>/work/arm-linux-androideabi-toolchain2.tar.gz</u>
       file to cross compilers with the prefix arm-linux-androideabi (e.g.  <b>arm-linux-androideabi-gcc</b>  and  <b>arm-</b>
       <b>linux-androideabi-g++</b>)  and  use  <u>/work/i386-native.tar.gz</u>  file  to compilers without prefix, the native
       compilers.

</pre><h4><b>HOW</b> <b>TO</b> <b>COMBINE</b> <b>ICECREAM</b> <b>WITH</b> <b>ccache</b></h4><pre>
       The easiest way to use ccache with icecream is to set CCACHE_PREFIX to icecc (the actual icecream  client
       wrapper)

       <b>export</b> <b>CCACHE_PREFIX=icecc</b>

       This  will  make  ccache prefix any compilation command it needs to do with icecc, making it use icecream
       for the compilation (but not for preprocessing alone).

       To actually use ccache, the mechanism is the same like with using icecream alone.  Since ccache does  not
       provide any symlinks in <u>/opt/ccache/bin</u>, you can create them manually:

       mkdir /opt/ccache/bin
       ln -s /usr/bin/ccache /opt/ccache/bin/gcc
       ln -s /usr/bin/ccache /opt/ccache/bin/g++

       And then compile with

       export PATH=/opt/ccache/bin:$PATH

       Note  however  that  ccache is not really worth the trouble if you are not recompiling your project three
       times a day from scratch (it adds quite some overhead in comparing the preprocessor output and uses quite
       some disc space and I found a cache hit of 18% a bit too few, so I disabled it again).

</pre><h4><b>DEBUG</b> <b>OUTPUT</b></h4><pre>
       You can use the environment variable ICECC_DEBUG to control if icecream gives debug output or not. Set it
       to debug to get debug output. The other possible values are error, warning and info (the  <b>-v</b>  option  for
       daemon and scheduler raise the level per <b>-v</b> on the command line - so use <b>-vvv</b> for full debug).

</pre><h4><b>AVOIDING</b> <b>OLD</b> <b>HOSTS</b></h4><pre>
       It is possible that compilation on some hosts fails because they are too old (typically the kernel on the
       remote host is too old for the glibc from the local host).  Recent icecream versions should automatically
       detect  this  and  avoid  such  hosts when compilation would fail. If some hosts are running old icecream
       versions and it is not possible to upgrade them for some reason, use

       export ICECC_IGNORE_UNVERIFIED=1

</pre><h4><b>SOME</b> <b>NUMBERS</b></h4><pre>
       Numbers of my test case (some STL C++ genetic algorithm)

       • <b>g++</b> on my machine: 1.6s

       • <b>g++</b> on fast machine: 1.1s

       • icecream using my machine as remote machine: 1.9s

       • icecream using fast machine: 1.8s

       The icecream overhead is quite huge as you might notice, but the compiler cannot interleave preprocessing
       with compilation and the file needs to be read/written once more and in between the file is transferred.

       But even if the other computer is faster, using <b>g++</b> on my local  machine  is  faster.  If  you  are  (for
       whatever  reason)  alone  in your network at some point, you lose all advantages of distributed compiling
       and only add the overhead. So icecream got a special  case  for  local  compilations  (the  same  special
       meaning  that localhost got within $DISTCC_HOSTS). This makes compiling on my machine using icecream down
       to 1.7s (the overhead is actually less than 0.1s in average).

       As the scheduler is aware of that meaning, it will prefer your own computer if it is  free  and  got  not
       less than 70% of the fastest available computer.

       Keep in mind, that this affects only the first compile job, the second one is distributed anyway. So if I
       had to compile two of my files, I would get

       • <b>g++</b> <b>-j1</b> on my machine: 3.2s

       • <b>g++</b> <b>-j1</b> on the fast machine: 2.2s

       • using icecream <b>-j2</b> on my machine: max(1.7,1.8)=1.8s

       • (using icecream <b>-j2</b> on the other machine: max(1.1,1.8)=1.8s)

       The math is a bit tricky and depends a lot on the current state of the compilation network, but make sure
       you are not blindly assuming <b>make</b> <b>-j2</b> halves your compilation time.

</pre><h4><b>WHAT</b> <b>IS</b> <b>THE</b> <b>BEST</b> <b>ENVIRONMENT</b> <b>FOR</b> <b>ICECREAM</b></h4><pre>
       In most requirements icecream is not special, e.g. it does not matter what distributed compile system you
       use,  you  will  not have fun if your nodes are connected through than less or equal to 10MBit. Note that
       icecream compresses input and output files (using lzo), so you can calc with ~1MBit  per  compile  job  -
       i.e. more than <b>make</b> <b>-j10</b> will not be possible without delays.

       Remember  that  more machines are only good if you can use massive parallelization, but you will for sure
       get the best result if your submitting machine (the one you called <b>g++</b> on) will be fast  enough  to  feed
       the  others.   Especially  if  your project consists of many easy to compile files, the preprocessing and
       file I/O will be job enough to need a quick machine.

       The scheduler will try to give you the fastest machines available, so even if you add old machines,  they
       will  be  used  only  in exceptional situations, but still you can have bad luck - the scheduler does not
       know how long a job will take before it started. So if you have 3 machines and two quick to  compile  and
       one  long  to  compile source file, you are not safe from a choice where everyone has to wait on the slow
       machine. Keep that in mind.

</pre><h4><b>NETWORK</b> <b>SETUP</b> <b>FOR</b> <b>ICECREAM</b> <b>(FIREWALLS)</b></h4><pre>
       A short overview of the ports icecream requires:

       • TCP/10245 on the daemon computers (required)

       • TCP/8765 for the the scheduler computer (required)

       • TCP/8766 for the telnet interface to the scheduler (optional)

       • UDP/8765 for broadcast to find the scheduler (optional)

       If the monitor cannot find the scheduler, use <b>ICECC_SCHEDULER=</b><u>host</u> <b>icemon</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/icecc-scheduler.1.html">icecc-scheduler</a>(1), <a href="../man1/iceccd.1.html">iceccd</a>(1), <a href="../man1/icemon.1.html">icemon</a>(1)

</pre><h4><b>ICECREAM</b> <b>AUTHORS</b></h4><pre>
       Stephan Kulow &lt;<a href="mailto:coolo@suse.de">coolo@suse.de</a>&gt;

       Michael Matz &lt;<a href="mailto:matz@suse.de">matz@suse.de</a>&gt;

       Cornelius Schumacher &lt;<a href="mailto:cschum@suse.de">cschum@suse.de</a>&gt;

       ...and various other contributors.

                                                April 21th, 2005                                     <u><a href="../man7/icecream.7.html">icecream</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>