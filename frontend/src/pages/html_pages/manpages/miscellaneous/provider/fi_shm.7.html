<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fi_shm - The SHM Fabric Provider</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfabric-dev">libfabric-dev_2.1.0-1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fi_shm - The SHM Fabric Provider

</pre><h4><b>OVERVIEW</b></h4><pre>
       The  SHM  provider  is a complete provider that can be used on Linux systems supporting shared memory and
       process_vm_readv/process_vm_writev calls.  The provider is intended to provide high-performance  communi‐
       cation between processes on the same system.

</pre><h4><b>SUPPORTED</b> <b>FEATURES</b></h4><pre>
       This release contains an initial implementation of the SHM provider that offers the following support:

       <u>Endpoint</u> <u>types</u>
              The provider supports only endpoint type <u>FI_EP_RDM</u>.

       <u>Endpoint</u> <u>capabilities</u>
              Endpoints  cna  support  any  combinations  of  the  following data transfer capabilities: <u>FI_MSG</u>,
              <u>FI_TAGGED</u>, <u>FI_RMA</u>, amd <u>FI_ATOMICS</u>.  These capabilities can be further defined by <u>FI_SEND</u>, <u>FI_RECV</u>,
              <u>FI_READ</u>, <u>FI_WRITE</u>, <u>FI_REMOTE_READ</u>, and <u>FI_REMOTE_WRITE</u> to limit the direction of operations.

       <u>Modes</u>  The provider does not require the use of any mode bits.

       <u>Progress</u>
              The SHM provider supports <u>FI_PROGRESS_MANUAL</u>.  Receive side data buffers are not modified  outside
              of completion processing routines.  The provider processes messages using three different methods,
              based on the size of the message.  For messages smaller than 4096 bytes, tx completions are gener‐
              ated  immediately after the send.  For larger messages, tx completions are not generated until the
              receiving side has processed the message.

       <u>Address</u> <u>Format</u>
              The SHM provider uses the address format FI_ADDR_STR, which follows  the  general  format  pattern
              “[prefix]://[addr]”.   The  application can provide addresses through the node or hints parameter.
              As long as the address is in a valid FI_ADDR_STR format (contains “://”), the address will be used
              as is.  If the application input is incorrectly formatted  or  no  input  was  provided,  the  SHM
              provider will resolve it according to the following SHM provider standards:

       (flags  &amp; FI_SOURCE) ?  src_addr : dest_addr = - if (node &amp;&amp; service) : “fi_ns://node:service” - if (ser‐
       vice) : “fi_ns://service” - if  (node  &amp;&amp;  !service)  :  “fi_shm://node”  -  if  (!node  &amp;&amp;  !service)  :
       “fi_shm://PID”

       !(flags &amp; FI_SOURCE) - src_addr = “fi_shm://PID”

       In  other  words, if the application provides a source and/or destination address in an acceptable FI_AD‐
       DR_STR format (contains “://”), the call to util_getinfo will successfully fill in src_addr and dest_addr
       with the provided input.  If the input is not in an ADDR_STR format, the shared memory provider will then
       create a proper FI_ADDR_STR address with either the “fi_ns://” (node/service format) or “fi_shm://”  (shm
       format) prefixes signaling whether the addr is a “unique” address and does or does not need an extra end‐
       point  name  identifier  appended  in order to make it unique.  For the shared memory provider, we assume
       that the service (with or without a node) is enough to make it unique, but a node  alone  is  not  suffi‐
       cient.  If only a node is provided, the “fi_shm://” prefix is used to signify that it is not a unique ad‐
       dress.   If no node or service are provided (and in the case of setting the src address without FI_SOURCE
       and no hints), the process ID will be used as a default address.  On endpoint creation, if  the  src_addr
       has  the “fi_shm://” prefix, the provider will append “:[uid]:[ep_idx]” as a unique endpoint name (essen‐
       tially, in place of a service).  In the case of the “fi_ns://” prefix (or any other  prefix  if  one  was
       provided  by  the application), no supplemental information is required to make it unique and it will re‐
       main with only the application-defined address.  Note that the actual endpoint name will not include  the
       FI_ADDR_STR  “*://”  prefix  since it cannot be included in any shared memory region names.  The provider
       will strip off the prefix before setting  the  endpoint  name.   As  a  result,  the  addresses  “fi_pre‐
       fix1://my_node:my_service” and “fi_prefix2://my_node:my_service” would result in endpoints and regions of
       the same name.  The application can also override the endpoint name after creating an endpoint using set‐
       name() without any address format restrictions.

       <u>Msg</u> <u>flags</u> The provider currently only supports the FI_REMOTE_CQ_DATA msg flag.

       <u>MR</u> <u>registration</u> <u>mode</u> The provider implements FI_MR_VIRT_ADDR memory mode.

       <u>Atomic</u>  <u>operations</u>  The provider supports all combinations of datatype and operations as long as the mes‐
       sage is less than 4096 bytes (or 2048 for compare operations).

</pre><h4><b>DSA</b></h4><pre>
       Intel Data Streaming Accelerator (DSA) is an integrated accelerator in  Intel  Xeon  processors  starting
       with  Sapphire  Rapids  generation.   One of the capabilities of DSA is to offload memory copy operations
       from the CPU.  A system may have one or more DSA devices.  Each DSA device may  have  one  or  more  work
       queues.  The DSA specification can be found here.

       The  SAR  protocol  of SHM provider is enabled to take advantage of DSA to offload memory copy operations
       into and out of SAR buffers in shared memory regions.  To fully take advantage of the DSA  offload  capa‐
       bility,  memory  copy  operations are performed asynchronously.  Copy initiator thread constructs the DSA
       commands and submits to work queues.  A copy operation may consists of more than one  DSA  commands.   In
       such  case,  commands  are  spread across all available work queues in round robin fashion.  The progress
       thread checks for DSA command completions.  If the copy command successfully completes, it then  notifies
       the  peer  to consume the data.  If DSA encountered a page fault during command execution, the page fault
       is reported via completion records.  In such case, the progress thread accesses the page to  resolve  the
       page  fault  and  resubmits  the command after adjusting for partial completions.  One of the benefits of
       making memory copy operations asynchronous is that now data transfers between different target  endpoints
       can be initiated in parallel.  Use of Intel DSA in SAR protocol is disabled by default and can be enabled
       using  an  environment variable.  Note that CMA must be disabled, e.g. FI_SHM_DISABLE_CMA=0, in order for
       DSA to be used.  See the RUNTIME PARAMETERS section.

       Compiling with DSA capabilities depends on the accel-config library which can  be  found  here.   Running
       with DSA requires using Linux Kernel 5.19.0-rc3 or later.

       DSA  devices  need to be setup just once before runtime.  This configuration file (https://github.com/in‐
       tel/idxd-config/blob/stable/contrib/configs/os_profile.conf) can be used as a template with  accel-config
       utility to configure the DSA devices.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The  SHM provider has hard-coded maximums for supported queue sizes and data transfers.  These values are
       reflected in the related fabric attribute structures

       EPs must be bound to both RX and TX CQs.

       No support for counters.

</pre><h4><b>RUNTIME</b> <b>PARAMETERS</b></h4><pre>
       The <u>shm</u> provider checks for the following environment variables:

       <u>FI_SHM_SAR_THRESHOLD</u>
              Maximum message size to use segmentation protocol before switching to mmap (only valid when CMA is
              not available).  Default: SIZE_MAX (18446744073709551615)

       <u>FI_SHM_TX_SIZE</u>
              Maximum number of outstanding tx operations.  Default 1024

       <u>FI_SHM_RX_SIZE</u>
              Maximum number of outstanding rx operations.  Default 1024

       <u>FI_SHM_DISABLE_CMA</u>
              Manually disables CMA.  Default false

       <u>FI_SHM_USE_DSA_SAR</u>
              Enables memory copy offload to Intel DSA in SAR protocol.  Default false

       <u>FI_SHM_USE_XPMEM</u>
              SHM can use SAR, CMA or XPMEM for host memory transfer.  If FI_SHM_USE_XPMEM  is  set  to  1,  the
              provider  will  select  XPMEM over CMA if XPMEM is available.  Otherwise, if neither CMA nor XPMEM
              are available SHM shall default to the SAR protocol.  Default 0

       <u>FI_XPMEM_MEMCPY_CHUNKSIZE</u>
              The maximum size which will be used with a single memcpy call.  XPMEM  copy  performance  improves
              when  buffers are divided into smaller chunks.  This environment variable is provided to fine tune
              performance on different systems.  Default 262144

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/fabric.7.html">fabric</a></b>(7), <b><a href="../man7/fi_provider.7.html">fi_provider</a></b>(7), <b><a href="../man3/fi_getinfo.3.html">fi_getinfo</a></b>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       OpenFabrics.

Libfabric Programmer’s Manual                      2024-12-10                                          <u><a href="../man7/fi_shm.7.html">fi_shm</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>