<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fi_psm2 - The PSM2 Fabric Provider</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfabric-dev">libfabric-dev_2.1.0-1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fi_psm2 - The PSM2 Fabric Provider

</pre><h4><b>OVERVIEW</b></h4><pre>
       The  <u>psm2</u>  provider runs over the PSM 2.x interface that is supported by the Intel Omni-Path Fabric.  PSM
       2.x has all the PSM 1.x features plus a set of new functions with enhanced capabilities.  Since  PSM  1.x
       and  PSM  2.x  are not ABI compatible the <u>psm2</u> provider only works with PSM 2.x and doesn’t support Intel
       TrueScale Fabric.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The <u>psm2</u> provider doesn’t support all the features defined in the libfabric API.  Here are  some  of  the
       limitations:

       Endpoint types
              Only support non-connection based types <u>FI_DGRAM</u> and <u>FI_RDM</u>

       Endpoint capabilities
              Endpoints can support any combination of data transfer capabilities <u>FI_TAGGED</u>, <u>FI_MSG</u>, <u>FI_ATOMICS</u>,
              and  <u>FI_RMA</u>.   These  capabilities  can be further refined by <u>FI_SEND</u>, <u>FI_RECV</u>, <u>FI_READ</u>, <u>FI_WRITE</u>,
              <u>FI_REMOTE_READ</u>, and <u>FI_REMOTE_WRITE</u> to limit the direction of operations.

       <u>FI_MULTI_RECV</u> is supported for non-tagged message queue only.

       Scalable endpoints are supported if the underlying PSM2 library supports multiple endpoints.  This condi‐
       tion must be satisfied both when the provider is built and when the provider is used.  See  the  <u>Scalable</u>
       <u>endpoints</u> section for more information.

       Other   supported  capabilities  include  <u>FI_TRIGGER</u>,  <u>FI_REMOTE_CQ_DATA</u>,  <u>FI_RMA_EVENT</u>,  <u>FI_SOURCE</u>,  and
       <u>FI_SOURCE_ERR</u>.  Furthermore, <u>FI_NAMED_RX_CTX</u> is supported when scalable endpoints are enabled.

       Modes  <u>FI_CONTEXT</u> is required for the <u>FI_TAGGED</u> and <u>FI_MSG</u> capabilities.  That means, any request belong‐
              ing to these two categories that generates a completion must pass as the operation context a valid
              pointer to type <u>struct</u> <u>fi_context</u>, and the space referenced by the pointer must  remain  untouched
              until  the  request  has  completed.  If none of <u>FI_TAGGED</u> and <u>FI_MSG</u> is asked for, the <u>FI_CONTEXT</u>
              mode is not required.

       Progress
              The <u>psm2</u> provider requires manual progress.  The application is expected  to  call  <u>fi_cq_read</u>  or
              <u>fi_cntr_read</u>  function  from  time  to  time  when no other libfabric function is called to ensure
              progress is made in a timely manner.  The provider does support auto progress mode.  However,  the
              performance  can  be  significantly  impacted if the application purely depends on the provider to
              make auto progress.

       Scalable endpoints
              Scalable endpoints support depends on the multi-EP feature of the <u>PSM2</u> library.  If the  <u>PSM2</u>  li‐
              brary  supports  this  feature,  the availability is further controlled by an environment variable
              <u>PSM2_MULTI_EP</u>.  The <u>psm2</u> provider automatically sets this variable to 1 if it  is  not  set.   The
              feature can be disabled explicitly by setting <u>PSM2_MULTI_EP</u> to 0.

       When  creating a scalable endpoint, the exact number of contexts requested should be set in the “fi_info”
       structure passed to  the  <u>fi_scalable_ep</u>  function.   This  number  should  be  set  in  “fi_info-&gt;ep_at‐
       tr-&gt;tx_ctx_cnt”  or “fi_info-&gt;ep_attr-&gt;rx_ctx_cnt” or both, whichever greater is used.  The <u>psm2</u> provider
       allocates all requested contexts upfront when the scalable endpoint is created.  The same context is used
       for both Tx and Rx.

       For optimal performance, it is advised to avoid having multiple threads accessing the same  context,  ei‐
       ther  directly  by  posting  send/recv/read/write request, or indirectly by polling associated completion
       queues or counters.

       Using the scalable endpoint as a whole in communication functions is not supported.  Instead,  individual
       tx  context  or  rx context of the scalable endpoint should be used.  Similarly, using the address of the
       scalable endpoint as the source address or destination address doesn’t collectively address all the tx/rx
       contexts.  It addresses only the first tx/rx context, instead.

       Shared Tx contexts
              In order to achieve the purpose of saving PSM context by using shared Tx  context,  the  endpoints
              bound  to  the shared Tx contexts need to be Tx only.  The reason is that Rx capability always re‐
              quires a PSM context, which can also be automatically used for Tx.  As the  result,  allocating  a
              shared  Tx  context for Rx capable endpoints actually consumes one extra context instead of saving
              some.

       Unsupported features
              These features are unsupported: connection management, passive endpoint, and shared  receive  con‐
              text.

</pre><h4><b>RUNTIME</b> <b>PARAMETERS</b></h4><pre>
       The <u>psm2</u> provider checks for the following environment variables:

       <u>FI_PSM2_UUID</u>
              PSM  requires that each job has a unique ID (UUID).  All the processes in the same job need to use
              the same UUID in order to be able to talk to each other.  The PSM reference manual advises to keep
              UUID unique to each job.  In practice, it generally works fine to reuse UUID as long as (1) no two
              jobs with the same UUID are running at the same time; and (2) previous jobs  with  the  same  UUID
              have exited normally.  If running into “resource busy” or “connection failure” issues with unknown
              reason, it is advisable to manually set the UUID to a value different from the default.

       The default UUID is 00FF00FF-0000-0000-0000-00FF0F0F00FF.

       It  is possible to create endpoints with UUID different from the one set here.  To achieve that, set `in‐
       fo-&gt;ep_attr-&gt;auth_key' to the uuid value and `info-&gt;ep_attr-&gt;auth_key_size' to its size (16  bytes)  when
       calling  fi_endpoint()  or fi_scalable_ep().  It is still true that an endpoint can only communicate with
       endpoints with the same UUID.

       <u>FI_PSM2_NAME_SERVER</u>
              The <u>psm2</u> provider has a simple built-in name server that can be used to resolve an IP  address  or
              host name into a transport address needed by the <u>fi_av_insert</u> call.  The main purpose of this name
              server  is to allow simple client-server type applications (such as those in <u>fabtests</u>) to be writ‐
              ten purely with libfabric, without using any out-of-band communication mechanism.  For such appli‐
              cations, the server would run first to allow endpoints be created and  registered  with  the  name
              server, and then the client would call <u>fi_getinfo</u> with the <u>node</u> parameter set to the IP address or
              host  name of the server.  The resulting <u>fi_info</u> structure would have the transport address of the
              endpoint created by the server in the <u>dest_addr</u> field.  Optionally the <u>service</u>  parameter  can  be
              used  in  addition  to <u>node</u>.  Notice that the <u>service</u> number is interpreted by the provider and is
              not a TCP/IP port number.

       The name server is on by default.  It can be turned off by setting the variable to 0.  This  may  save  a
       small amount of resource since a separate thread is created when the name server is on.

       The provider detects OpenMPI and MPICH runs and changes the default setting to off.

       <u>FI_PSM2_TAGGED_RMA</u>
              The  RMA functions are implemented on top of the PSM Active Message functions.  The Active Message
              functions have limit on the size of data can be transferred in a single message.  Large  transfers
              can  be divided into small chunks and be pipe-lined.  However, the bandwidth is sub-optimal by do‐
              ing this way.

       The <u>psm2</u> provider use PSM tag-matching message queue functions to achieve higher bandwidth for large size
       RMA.  It takes advantage of the extra tag bits available in PSM2 to separate the  RMA  traffic  from  the
       regular tagged message queue.

       The option is on by default.  To turn it off set the variable to 0.

       <u>FI_PSM2_DELAY</u>
              Time (seconds) to sleep before closing PSM endpoints.  This is a workaround for a bug in some ver‐
              sions of PSM library.

       The default setting is 0.

       <u>FI_PSM2_TIMEOUT</u>
              Timeout  (seconds) for gracefully closing PSM endpoints.  A forced closing will be issued if time‐
              out expires.

       The default setting is 5.

       <u>FI_PSM2_CONN_TIMEOUT</u>
              Timeout (seconds) for establishing connection between two PSM endpoints.

       The default setting is 5.

       <u>FI_PSM2_PROG_INTERVAL</u>
              When auto progress is enabled (asked via the hints to <u>fi_getinfo</u>), a progress thread is created to
              make progress calls from time to time.   This  option  set  the  interval  (microseconds)  between
              progress calls.

       The default setting is 1 if affinity is set, or 1000 if not.  See <u>FI_PSM2_PROG_AFFINITY</u>.

       <u>FI_PSM2_PROG_AFFINITY</u>
              When  set,  specify  the  set  of CPU cores to set the progress thread affinity to.  The format is
              <b>&lt;start&gt;[:&lt;end&gt;[:&lt;stride&gt;]][,&lt;start&gt;[:&lt;end&gt;[:&lt;stride&gt;]]]*</b>,        where        each         triplet
              <b>&lt;start&gt;:&lt;end&gt;:&lt;stride&gt;</b>  defines  a  block  of  core_ids.  Both <b>&lt;start&gt;</b> and <b>&lt;end&gt;</b> can be either the
              <b>core_id</b> (when &gt;=0) or <b>core_id</b> <b>-</b> <b>num_cores</b> (when &lt;0).

       By default affinity is not set.

       <u>FI_PSM2_INJECT_SIZE</u>
              Maximum message size allowed for fi_inject and fi_tinject calls.  This is an experimental  feature
              to  allow  some  applications to override default inject size limitation.  When the inject size is
              larger than the default value, some inject calls might block.

       The default setting is 64.

       <u>FI_PSM2_LOCK_LEVEL</u>
              When set, dictate the level of locking being used by the provider.  Level 2 means  all  locks  are
              enabled.   Level 1 disables some locks and is suitable for runs that limit the access to each PSM2
              context to a single thread.  Level 0 disables all locks and  thus  is  only  suitable  for  single
              threaded runs.

       To  use  level 0 or level 1, wait object and auto progress mode cannot be used because they introduce in‐
       ternal threads that may break the conditions needed for these levels.

       The default setting is 2.

       <u>FI_PSM2_LAZY_CONN</u>
              There are two strategies on when to establish connections between the PSM2 endpoints that OFI end‐
              points are built on top of.  In eager connection mode, connections are established when  addresses
              are  inserted  into the address vector.  In lazy connection mode, connections are established when
              addresses are used the first time in communication.  Eager  connection  mode  has  slightly  lower
              critical path overhead but lazy connection mode scales better.

       This  option  controls how the two connection modes are used.  When set to 1, lazy connection mode is al‐
       ways used.  When set to 0, eager connection mode is used when required conditions are all  met  and  lazy
       connection  mode  is used otherwise.  The conditions for eager connection mode are: (1) multiple endpoint
       (and scalable endpoint) support is disabled by explicitly setting PSM2_MULTI_EP=0; and  (2)  the  address
       vector type is FI_AV_MAP.

       The default setting is 0.

       <u>FI_PSM2_DISCONNECT</u>
              The  provider  has  a mechanism to automatically send disconnection notifications to all connected
              peers before the local endpoint is closed.  As the response, the peers call <u>psm2_ep_disconnect</u>  to
              clean  up the connection state at their side.  This allows the same PSM2 epid be used by different
              dynamically started processes (clients) to communicate with the same peer (server).   This  mecha‐
              nism,  however,  introduce  extra overhead to the finalization phase.  For applications that never
              reuse epids within the same session such overhead is unnecessary.

       This option controls whether the automatic disconnection notification mechanism should be  enabled.   For
       client-server  application  mentioned  above, the client side should set this option to 1, but the server
       should set it to 0.

       The default setting is 0.

       <u>FI_PSM2_TAG_LAYOUT</u>
              Select how the 96-bit PSM2 tag bits are organized.  Currently three choices are  available:  <u>tag60</u>
              means 32-4-60 partitioning for CQ data, internal protocol flags, and application tag.  <u>tag64</u> means
              4-28-64  partitioning  for  internal  protocol flags, CQ data, and application tag.  <u>auto</u> means to
              choose either <u>tag60</u> or <u>tag64</u> based on the hints passed to fi_getinfo – <u>tag60</u> is used if remote  CQ
              data  support  is  requested  explicitly,  either  by passing non-zero value via <u>hints-&gt;domain_at‐</u>
              <u>tr-&gt;cq_data_size</u> or by including <u>FI_REMOTE_CQ_DATA</u> in <u>hints-&gt;caps</u>, otherwise <u>tag64</u>  is  used.   If
              <u>tag64</u>  is  the  result  of  automatic  selection, <u>fi_getinfo</u> also returns a second instance of the
              provider with <u>tag60</u> layout.

       The default setting is <u>auto</u>.

       Notice that if the provider is compiled with macro <u>PSMX2_TAG_LAYOUT</u> defined  to  1  (means  <u>tag60</u>)  or  2
       (means <u>tag64</u>), the choice is fixed at compile time and this runtime option will be disabled.

</pre><h4><b>PSM2</b> <b>EXTENSIONS</b></h4><pre>
       The  <u>psm2</u> provider supports limited low level parameter setting through the fi_set_val() and fi_get_val()
       functions.  Currently the following parameters can be set via the domain fid: • .RS 2

       FI_PSM2_DISCONNECT *
              Overwite the global runtime parameter <u>FI_PSM2_DISCONNECT</u> for this domain.  See the <u>RUNTIME</u> <u>PARAME‐</u>
              <u>TERS</u> section for details.

       Valid parameter names are defined in the header file <u>rdma/fi_ext_psm2.h</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/fabric.7.html">fabric</a></b>(7), <b><a href="../man7/fi_provider.7.html">fi_provider</a></b>(7), <b><a href="../man7/fi_psm3.7.html">fi_psm3</a></b>(7),

</pre><h4><b>AUTHORS</b></h4><pre>
       OpenFabrics.

Libfabric Programmer’s Manual                      2024-12-10                                         <u><a href="../man7/fi_psm2.7.html">fi_psm2</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>