<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>spufs - SPU filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       spufs - SPU filesystem

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  SPU  filesystem is used on PowerPC machines that implement the Cell Broadband Engine Architecture in
       order to access Synergistic Processor Units (SPUs).

       The filesystem provides a name space similar to POSIX shared memory or message queues.  Users  that  have
       write  permissions on the filesystem can use <b><a href="../man2/spu_create.2.html">spu_create</a></b>(2) to establish SPU contexts under the <b>spufs</b> root
       directory.

       Every SPU context is represented by a directory containing a predefined set of files.  These files can be
       used for manipulating the state of the logical SPU.  Users can change permissions on the files, but can't
       add or remove files.

   <b>Mount</b> <b>options</b>
       <b>uid=&lt;uid&gt;</b>
              Set the user owning the mount point; the default is 0 (root).

       <b>gid=&lt;gid&gt;</b>
              Set the group owning the mount point; the default is 0 (root).

       <b>mode=&lt;mode&gt;</b>
              Set the mode of the top-level directory in <b>spufs</b>, as an octal mode string.  The default is 0775.

   <b>Files</b>
       The files in <b>spufs</b> mostly follow the standard behavior for regular system calls like <b><a href="../man2/read.2.html">read</a></b>(2) or <b><a href="../man2/write.2.html">write</a></b>(2),
       but often support only a subset of the operations supported on regular filesystems.   This  list  details
       the  supported  operations  and the deviations from the standard behavior described in the respective man
       pages.

       All files that support the <b><a href="../man2/read.2.html">read</a></b>(2) operation also  support  <b><a href="../man2/readv.2.html">readv</a></b>(2)  and  all  files  that  support  the
       <b><a href="../man2/write.2.html">write</a></b>(2)  operation  also  support  <b><a href="../man2/writev.2.html">writev</a></b>(2).   All  files  support  the <b><a href="../man2/access.2.html">access</a></b>(2) and <b><a href="../man2/stat.2.html">stat</a></b>(2) family of
       operations, but for the latter call, the only fields of the returned <u>stat</u> structure that contain reliable
       information are <u>st_mode</u>, <u>st_nlink</u>, <u>st_uid</u>, and <u>st_gid</u>.

       All files support the <b><a href="../man2/chmod.2.html">chmod</a></b>(2)/<b><a href="../man2/fchmod.2.html">fchmod</a></b>(2) and <b><a href="../man2/chown.2.html">chown</a></b>(2)/<b><a href="../man2/fchown.2.html">fchown</a></b>(2) operations, but will not be able to grant
       permissions that contradict the possible operations (e.g., read access on the <u>wbox</u> file).

       The current set of files is:

       <u>/capabilities</u>
              Contains a comma-delimited string representing the capabilities of  this  SPU  context.   Possible
              capabilities are:

              <b>sched</b>  This context may be scheduled.

              <b>step</b>   This context can be run in single-step mode, for debugging.

              New capabilities flags may be added in the future.

       <u>/mem</u>   the  contents  of the local storage memory of the SPU.  This can be accessed like a regular shared
              memory file and contains both code and data in  the  address  space  of  the  SPU.   The  possible
              operations on an open <u>mem</u> file are:

              <b><a href="../man2/read.2.html">read</a></b>(2)
              <b><a href="../man2/pread.2.html">pread</a></b>(2)
              <b><a href="../man2/write.2.html">write</a></b>(2)
              <b><a href="../man2/pwrite.2.html">pwrite</a></b>(2)
              <b><a href="../man2/lseek.2.html">lseek</a></b>(2)
                     These  operate  as usual, with the exception that <b><a href="../man2/lseek.2.html">lseek</a></b>(2), <b><a href="../man2/write.2.html">write</a></b>(2), and <b><a href="../man2/pwrite.2.html">pwrite</a></b>(2) are not
                     supported beyond the end of the file.  The file size is the size of the  local  storage  of
                     the SPU, which is normally 256 kilobytes.

              <b><a href="../man2/mmap.2.html">mmap</a></b>(2)
                     Mapping  <u>mem</u> into the process address space provides access to the SPU local storage within
                     the process address space.  Only <b>MAP_SHARED</b> mappings are allowed.

       <u>/regs</u>  Contains the saved general-purpose registers of the SPU context.  This file contains  the  128-bit
              values  of  each  register,  from  register 0 to register 127, in order.  This allows the general-
              purpose registers to be inspected for debugging.

              Reading to or writing from this file requires that the context is scheduled out, so  use  of  this
              file is not recommended in normal program operation.

              The <u>regs</u> file is not present on contexts that have been created with the <b>SPU_CREATE_NOSCHED</b> flag.

       <u>/mbox</u>  The  first SPU-to-CPU communication mailbox.  This file is read-only and can be read in units of 4
              bytes.  The file can be used only in nonblocking mode - even <b><a href="../man2/poll.2.html">poll</a></b>(2) cannot be used  to  block  on
              this file.  The only possible operation on an open <u>mbox</u> file is:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     If <u>count</u> is smaller than four, <b><a href="../man2/read.2.html">read</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  If there is no
                     data  available  in  the mailbox (i.e., the SPU has not sent a mailbox message), the return
                     value is set to -1 and <u>errno</u> is set to <b>EAGAIN</b>.  When data has been read successfully,  four
                     bytes are placed in the data buffer and the value four is returned.

       <u>/ibox</u>  The  second SPU-to-CPU communication mailbox.  This file is similar to the first mailbox file, but
              can be read in blocking I/O mode, thus calling <b><a href="../man2/read.2.html">read</a></b>(2) on an open <u>ibox</u> file will block  until  the
              SPU  has  written  data  to  its  interrupt  mailbox channel (unless the file has been opened with
              <b>O_NONBLOCK</b>, see below).  Also, <b><a href="../man2/poll.2.html">poll</a></b>(2) and similar system calls can be used  to  monitor  for  the
              presence of mailbox data.

              The possible operations on an open <u>ibox</u> file are:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     If <u>count</u> is smaller than four, <b><a href="../man2/read.2.html">read</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  If there is no
                     data  available in the mailbox and the file descriptor has been opened with <b>O_NONBLOCK</b>, the
                     return value is set to -1 and <u>errno</u> is set to <b>EAGAIN</b>.

                     If there is no data available in the mailbox  and  the  file  descriptor  has  been  opened
                     without  <b>O_NONBLOCK</b>,  the  call  will  block  until the SPU writes to its interrupt mailbox
                     channel.  When data has been read successfully, four bytes are placed in  the  data  buffer
                     and the value four is returned.

              <b><a href="../man2/poll.2.html">poll</a></b>(2)
                     Poll on the <u>ibox</u> file returns <u>(POLLIN</u> <u>|</u> <u>POLLRDNORM)</u> whenever data is available for reading.

       <u>/wbox</u>  The CPU-to-SPU communication mailbox.  It is write-only and can be written in units of four bytes.
              If the mailbox is full, <b><a href="../man2/write.2.html">write</a></b>(2) will block, and <b><a href="../man2/poll.2.html">poll</a></b>(2) can be used to block until the mailbox is
              available for writing again.  The possible operations on an open <u>wbox</u> file are:

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     If  <u>count</u>  is smaller than four, <b><a href="../man2/write.2.html">write</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  If there is
                     no space available in the mailbox and the file descriptor has been opened with  <b>O_NONBLOCK</b>,
                     the return value is set to -1 and <u>errno</u> is set to <b>EAGAIN</b>.

                     If  there  is  no  space  available  in the mailbox and the file descriptor has been opened
                     without <b>O_NONBLOCK</b>, the call  will  block  until  the  SPU  reads  from  its  PPE  (PowerPC
                     Processing  Element)  mailbox channel.  When data has been written successfully, the system
                     call returns four as its function result.

              <b><a href="../man2/poll.2.html">poll</a></b>(2)
                     A poll on the <u>wbox</u> file returns <u>(POLLOUT</u> <u>|</u> <u>POLLWRNORM)</u>  whenever  space  is  available  for
                     writing.

       <u>/mbox_stat</u>
       <u>/ibox_stat</u>
       <u>/wbox_stat</u>
              These  are  read-only  files that contain the length of the current queue of each mailboxâ€”that is,
              how many words can be read from <u>mbox</u> or <u>ibox</u> or how many words can  be  written  to  <u>wbox</u>  without
              blocking.   The  files  can be read only in four-byte units and return a big-endian binary integer
              number.  The only possible operation on an open <u>*box_stat</u> file is:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     If <u>count</u> is smaller than four, <b><a href="../man2/read.2.html">read</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.   Otherwise,  a
                     four-byte  value  is  placed in the data buffer.  This value is the number of elements that
                     can be read from (for <u>mbox_stat</u> and <u>ibox_stat</u>) or written to (for <u>wbox_stat</u>) the respective
                     mailbox without blocking or returning an <b>EAGAIN</b> error.

       <u>/npc</u>
       <u>/decr</u>
       <u>/decr_status</u>
       <u>/spu_tag_mask</u>
       <u>/event_mask</u>
       <u>/event_status</u>
       <u>/srr0</u>
       <u>/lslr</u>  Internal registers of the SPU.  These files contain an ASCII string representing the hex value  of
              the  specified register.  Reads and writes on these files (except for <u>npc</u>, see below) require that
              the SPU context be scheduled out, so frequent access to these files is not recommended for  normal
              program operation.

              The contents of these files are:

              <u>npc</u>             Next Program Counter - valid only when the SPU is in a stopped state.

              <u>decr</u>            SPU Decrementer

              <u>decr_status</u>     Decrementer Status

              <u>spu_tag_mask</u>    MFC tag mask for SPU DMA

              <u>event_mask</u>      Event mask for SPU interrupts

              <u>event_status</u>    Number of SPU events pending (read-only)

              <u>srr0</u>            Interrupt Return address register

              <u>lslr</u>            Local Store Limit Register

              The possible operations on these files are:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     Reads  the  current register value.  If the register value is larger than the buffer passed
                     to the <b><a href="../man2/read.2.html">read</a></b>(2) system call, subsequent reads will continue reading from  the  same  buffer,
                     until the end of the buffer is reached.

                     When a complete string has been read, all subsequent read operations will return zero bytes
                     and a new file descriptor needs to be opened to read a new value.

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     A  <b><a href="../man2/write.2.html">write</a></b>(2)  operation on the file sets the register to the value given in the string.  The
                     string is parsed from the beginning until the first nonnumeric character or the end of  the
                     buffer.  Subsequent writes to the same file descriptor overwrite the previous setting.

                     Except  for  the  <u>npc</u>  file, these files are not present on contexts that have been created
                     with the <b>SPU_CREATE_NOSCHED</b> flag.

       <u>/fpcr</u>  This file provides access to the Floating Point Status and Control Register (fcpr)  as  a  binary,
              four-byte file.  The operations on the <u>fpcr</u> file are:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     If  <u>count</u>  is smaller than four, <b><a href="../man2/read.2.html">read</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  Otherwise, a
                     four-byte value is placed in the data buffer;  this  is  the  current  value  of  the  <u>fpcr</u>
                     register.

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     If  <u>count</u> is smaller than four, <b><a href="../man2/write.2.html">write</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  Otherwise, a
                     four-byte value is copied from the data buffer, updating the value of the <u>fpcr</u> register.

       <u>/signal1</u>
       <u>/signal2</u>
              The files provide access to the two signal notification channels of an SPU.  These are  read-write
              files that operate on four-byte words.  Writing to one of these files triggers an interrupt on the
              SPU.   The  value  written  to the signal files can be read from the SPU through a channel read or
              from host user space through the file.  After the value has been read by the SPU, it is  reset  to
              zero.  The possible operations on an open <u>signal1</u> or <u>signal2</u> file are:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     If  <u>count</u>  is smaller than four, <b><a href="../man2/read.2.html">read</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  Otherwise, a
                     four-byte value is placed in the data buffer; this is the current value  of  the  specified
                     signal notification register.

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     If  <u>count</u> is smaller than four, <b><a href="../man2/write.2.html">write</a></b>(2) returns -1 and sets <u>errno</u> to <b>EINVAL</b>.  Otherwise, a
                     four-byte value is copied from the data buffer, updating the value of the specified  signal
                     notification  register.   The signal notification register will either be replaced with the
                     input data or will be updated to the bitwise OR operation of the old value  and  the  input
                     data, depending on the contents of the <u>signal1_type</u> or <u>signal2_type</u> files respectively.

       <u>/signal1_type</u>
       <u>/signal2_type</u>
              These two files change the behavior of the <u>signal1</u> and <u>signal2</u> notification files.  They contain a
              numeric  ASCII  string  which  is  read as either "1" or "0".  In mode 0 (overwrite), the hardware
              replaces the contents of the signal channel with the data that  is  written  to  it.   In  mode  1
              (logical OR), the hardware accumulates the bits that are subsequently written to it.  The possible
              operations on an open <u>signal1_type</u> or <u>signal2_type</u> file are:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     When  the  count  supplied  to the <b><a href="../man2/read.2.html">read</a></b>(2) call is shorter than the required length for the
                     digit (plus a newline character), subsequent reads  from  the  same  file  descriptor  will
                     complete  the string.  When a complete string has been read, all subsequent read operations
                     will return zero bytes and a new file descriptor needs to  be  opened  to  read  the  value
                     again.

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     A  <b><a href="../man2/write.2.html">write</a></b>(2)  operation on the file sets the register to the value given in the string.  The
                     string is parsed from the beginning until the first nonnumeric character or the end of  the
                     buffer.  Subsequent writes to the same file descriptor overwrite the previous setting.

       <u>/mbox_info</u>
       <u>/ibox_info</u>
       <u>/wbox_info</u>
       <u>/dma_into</u>
       <u>/proxydma_info</u>
              Read-only files that contain the saved state of the SPU mailboxes and DMA queues.  This allows the
              SPU  status to be inspected, mainly for debugging.  The <u>mbox_info</u> and <u>ibox_info</u> files each contain
              the four-byte mailbox message that has been written by the SPU.  If no message has been written to
              these mailboxes, then contents of  these  files  is  undefined.   The  <u>mbox_stat</u>,  <u>ibox_stat</u>,  and
              <u>wbox_stat</u> files contain the available message count.

              The  <u>wbox_info</u>  file  contains an array of four-byte mailbox messages, which have been sent to the
              SPU.  With current CBEA machines, the array is four items in length, so up to 4 * 4 = 16 bytes can
              be read from this file.  If any mailbox  queue  entry  is  empty,  then  the  bytes  read  at  the
              corresponding location are undefined.

              The  <u>dma_info</u>  file  contains  the contents of the SPU MFC DMA queue, represented as the following
              structure:

                  struct spu_dma_info {
                      uint64_t         dma_info_type;
                      uint64_t         dma_info_mask;
                      uint64_t         dma_info_status;
                      uint64_t         dma_info_stall_and_notify;
                      uint64_t         dma_info_atomic_command_status;
                      struct mfc_cq_sr dma_info_command_data[16];
                  };

              The last member of this data structure is the  actual  DMA  queue,  containing  16  entries.   The
              <u>mfc_cq_sr</u> structure is defined as:

                  struct mfc_cq_sr {
                      uint64_t mfc_cq_data0_RW;
                      uint64_t mfc_cq_data1_RW;
                      uint64_t mfc_cq_data2_RW;
                      uint64_t mfc_cq_data3_RW;
                  };

              The <u>proxydma_info</u> file contains similar information, but describes the proxy DMA queue (i.e., DMAs
              initiated by entities outside the SPU) instead.  The file is in the following format:

                  struct spu_proxydma_info {
                      uint64_t         proxydma_info_type;
                      uint64_t         proxydma_info_mask;
                      uint64_t         proxydma_info_status;
                      struct mfc_cq_sr proxydma_info_command_data[8];
                  };

              Accessing  these  files  requires  that  the  SPU  context  is scheduled out - frequent use can be
              inefficient.  These files should not be used for normal program operation.

              These files are not present on contexts that have been created with the <b>SPU_CREATE_NOSCHED</b> flag.

       <u>/cntl</u>  This file provides access to the SPU Run Control and SPU status registers,  as  an  ASCII  string.
              The following operations are supported:

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     Reads  from  the <u>cntl</u> file will return an ASCII string with the hex value of the SPU Status
                     register.

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     Writes to the <u>cntl</u> file will set the context's SPU Run Control register.

       <u>/mfc</u>   Provides access to the Memory Flow Controller of the SPU.   Reading  from  the  file  returns  the
              contents  of  the  SPU's MFC Tag Status register, and writing to the file initiates a DMA from the
              MFC.  The following operations are supported:

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     Writes to this file need to be in the format of a MFC DMA command, defined as follows:

                         struct mfc_dma_command {
                             int32_t  pad;    /* reserved */
                             uint32_t lsa;    /* local storage address */
                             uint64_t ea;     /* effective address */
                             uint16_t size;   /* transfer size */
                             uint16_t tag;    /* command tag */
                             uint16_t class;  /* class ID */
                             uint16_t cmd;    /* command opcode */
                         };

                     Writes are required to be  exactly  <u>sizeof(struct</u>  <u>mfc_dma_command)</u>  bytes  in  size.   The
                     command  will  be  sent to the SPU's MFC proxy queue, and the tag stored in the kernel (see
                     below).

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     Reads the contents of the tag status register.  If the file  is  opened  in  blocking  mode
                     (i.e.,  without  <b>O_NONBLOCK</b>),  then  the read will block until a DMA tag (as performed by a
                     previous write) is complete.  In nonblocking mode, the MFC  tag  status  register  will  be
                     returned without waiting.

              <b><a href="../man2/poll.2.html">poll</a></b>(2)
                     Calling  <b><a href="../man2/poll.2.html">poll</a></b>(2) on the <u>mfc</u> file will block until a new DMA can be started (by checking for
                     <b>POLLOUT</b>) or until a previously started DMA (by checking for <b>POLLIN</b>) has been completed.

                     <u>/mss</u> Provides access to the MFC MultiSource Synchronization (MSS) facility.  By <b><a href="../man2/mmap.2.html">mmap</a></b>(2)-ing
                     this file, processes can access the MSS area of the SPU.

                     The following operations are supported:

              <b><a href="../man2/mmap.2.html">mmap</a></b>(2)
                     Mapping <b>mss</b> into the process address space gives access to the  SPU  MSS  area  within  the
                     process address space.  Only <b>MAP_SHARED</b> mappings are allowed.

       <u>/psmap</u> Provides  access to the whole problem-state mapping of the SPU.  Applications can use this area to
              interface to the SPU, rather than writing to individual register files in <b>spufs</b>.

              The following operations are supported:

              <b><a href="../man2/mmap.2.html">mmap</a></b>(2)
                     Mapping <b>psmap</b> gives a process a direct map of the SPU problem state area.  Only  <b>MAP_SHARED</b>
                     mappings are supported.

       <u>/phys-id</u>
              Read-only  file  containing  the physical SPU number that the SPU context is running on.  When the
              context is not running, this file contains the string "-1".

              The physical SPU number is given by an ASCII hex string.

       <u>/object-id</u>
              Allows applications to store (or retrieve) a single 64-bit ID into the context.  This ID is  later
              used by profiling tools to uniquely identify the context.

              <b><a href="../man2/write.2.html">write</a></b>(2)
                     By writing an ASCII hex value into this file, applications can set the object ID of the SPU
                     context.  Any previous value of the object ID is overwritten.

              <b><a href="../man2/read.2.html">read</a></b>(2)
                     Reading  this  file  gives  an  ASCII  hex  string  representing the object ID for this SPU
                     context.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To automatically <b><a href="../man8/mount.8.html">mount</a></b>(8) the SPU filesystem when booting, at the location <u>/spu</u> chosen by the  user,  put
       this line into the <b><a href="../man5/fstab.5.html">fstab</a></b>(5) configuration file:
       none /spu spufs gid=spu 0 0

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/close.2.html">close</a></b>(2), <b><a href="../man2/spu_create.2.html">spu_create</a></b>(2), <b><a href="../man2/spu_run.2.html">spu_run</a></b>(2), <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7)

       <u>The</u> <u>Cell</u> <u>Broadband</u> <u>Engine</u> <u>Architecture</u> <u>(CBEA)</u> <u>specification</u>

Linux man-pages 6.9.1                              2024-05-02                                           <u><a href="../man7/spufs.7.html">spufs</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>