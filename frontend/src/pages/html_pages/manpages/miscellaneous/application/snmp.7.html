<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNMP - The SNMP Application</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/erlang-manpages">erlang-manpages_25.3.2.8+dfsg-1ubuntu4.4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SNMP - The SNMP Application

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This chapter describes the <u>snmp</u> application in OTP. The SNMP application provides the following services:

         * a multilingual extensible SNMP agent

         * a SNMP manager

         * a MIB compiler

</pre><h4><b>CONFIGURATION</b></h4><pre>
       The  following  configuration parameters are defined for the SNMP application. Refer to <a href="../man3erl/application.3erl.html">application</a>(3erl)
       for more information about configuration parameters.

       The snmp part of the config file specifying the  configuration  parameters  is  basically  the  following
       tuple:

             {snmp, snmp_components_config()}

       A minimal config file for starting a node with both a manager and an agent:

             [{snmp,
               [{agent, [{db_dir, "/tmp/snmp/agent/db"},
                         {config, [{dir, "/tmp/snmp/agent/conf"}]}]},
                {manager, [{config, [{dir, "/tmp/snmp/manager/conf"},
                                     {db_dir, "/tmp/snmp/manager/db"}]}]}]}
               ]
              }
             ].

       Each snmp component has its own set of configuration parameters, even though some of the types are common
       to both components.

             snmp_components_config() -&gt; [snmp_component_config()]
             snmp_component_config() -&gt; {agent, agent_options()} | {manager, manager_options()}
             agent_options() = [agent_option()]
             agent_option() = {restart_type,     restart_type()}     |
                              {agent_type,       agent_type()}       |
                              {agent_verbosity,  verbosity()}        |
                              {discovery,        agent_discovery()}  |
                              {versions,         versions()}         |
                              {gb_max_vbs,       gb_max_vbs()}       |
                              {priority,         priority()}         |
                              {multi_threaded,   multi_threaded()}   |
                              {db_dir,           db_dir()}           |
                              {db_init_error,    db_init_error()}    |
                              {local_db,         local_db()}         |
                              {net_if,           agent_net_if()}     |
                              {mibs,             mibs()}             |
                              {mib_storage,      mib_storage()}      |
                              {mib_server,       mib_server()}       |
                              {audit_trail_log,  audit_trail_log()}  |
                              {error_report_mod, error_report_mod()} |
                              {note_store,       note_store()}       |
                              {symbolic_store,   symbolic_store()}   |
                              {target_cache,     target_cache()}     |
                              {config,           agent_config()}
             manager_options() = [manager_option()]
             manager_option() = {restart_type,             restart_type()}    |
                                {net_if,                   manager_net_if()}  |
                                {server,                   server()}          |
                                {note_store,               note_store()}      |
                                {config,                   manager_config()}  |
                                {inform_request_behaviour, manager_irb()}     |
                                {mibs,                     manager_mibs()}    |
                                {priority,                 priority()}        |
                                {audit_trail_log,          audit_trail_log()} |
                                {versions,                 versions()}        |
                                {def_user_mod,             def_user_module()  |
                                {def_user_data,            def_user_data()}

       Agent specific config options and types:

         <u>agent_type()</u> <u>=</u> <u>master</u> <u>|</u> <u>sub</u> <u>&lt;optional&gt;</u>:
           If <u>master</u>, one master agent is started. Otherwise, no agents are started.

           Default is <u>master</u>.

         <u>agent_discovery()</u> <u>=</u> <u>[agent_discovery_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_discovery_opt()</u>    <u>=</u>    <u>{terminating,</u>   <u>agent_terminating_discovery_opts()}</u>   <u>|</u>   <u>{originating,</u>
           <u>agent_originating_discovery_opts()}</u>

           The <u>terminating</u> options effects discovery initiated by a manager.

           The <u>originating</u> options effects discovery initiated by this agent.

           For defaults see the options in <u>agent_discovery_opt()</u>.

         <u>agent_terminating_discovery_opts()</u> <u>=</u> <u>[agent_terminating_discovery_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_terminating_discovery_opt()</u>  <u>=</u>  <u>{enable,</u>  <u>boolean()}</u>  <u>|</u>   <u>{stage2,</u>   <u>discovery</u>   <u>|</u>   <u>plain}</u>   <u>|</u>
           <u>{trigger_username,</u> <u>string()}</u>

           These are options effecting discovery <u>terminating</u> in this agent (i.e. initiated by a manager).

           The default values for the <u>terminating</u> discovery options are:

           * enable: <u>true</u>

           * stage2: <u>discovery</u>

           * trigger_username: <u>""</u>

         <u>agent_originating_discovery_opts()</u> <u>=</u> <u>[agent_originating_discovery_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_originating_discovery_opt()</u> <u>=</u> <u>{enable,</u> <u>boolean()}</u>

           These are options effecting discovery <u>originating</u> in this agent.

           The default values for the <u>originating</u> discovery options are:

           * enable: <u>true</u>

         <u>multi_threaded()</u> <u>=</u> <u>bool()</u> <u>|</u> <u>extended</u> <u>&lt;optional&gt;</u>:
           If <u>true</u> (or <u>extended</u>), the agent is multi-threaded, with one thread for each get request.

           The  value  <u>extended</u>  means  that  a  special  'process'  is  also  created  intended  to  handle <u>all</u>
           notifications.

           * <u>true</u> - One worker dedicated to 'set-requests' and one (main) worker for all other  requests  ('get-
             request' and notifications).

             If  the  'main' worker is busy, a temporary process is spawned to handle that job ('get-request' or
             notification).

           * <u>extended</u> - One worker dedicated to 'set-requests', one worker dedicated to  notifications  and  one
             (main) worker for all 'get-requests'.

             If the 'main' worker is busy, a temporary process is spawned to handle that 'get-request'.

     <b>Note:</b>
         Even  with  multi-threaded  set  to  <u>extended</u>  there is still a risk for 'reorder' when sending inform-
         requsts, which require a response (and may therefore require resending).

         Also, there is of course no way to guarantee order once the package is on the network.

           Default is <u>false</u>.

         <u>db_dir()</u> <u>=</u> <u>string()</u> <u>&lt;mandatory&gt;</u>:
           Defines where the SNMP agent internal db files are stored.

         <u>gb_max_vbs()</u> <u>=</u> <u>pos_integer()</u> <u>|</u> <u>infinity</u> <u>&lt;optional&gt;</u>:
           Defines the maximum number of varbinds allowed in a Get-BULK response.

           Default is <u>1000</u>.

         <u>local_db()</u> <u>=</u> <u>[local_db_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>local_db_opt()</u> <u>=</u> <u>{repair,</u> <u>agent_repair()}</u> <u>|</u> <u>{auto_save,</u> <u>agent_auto_save()}</u> <u>|</u> <u>{verbosity,</u> <u>verbosity()}</u>

           Defines options specific for the SNMP agent local database.

           For defaults see the options in <u>local_db_opt()</u>.

         <u>agent_repair()</u> <u>=</u> <u>false</u> <u>|</u> <u>true</u> <u>|</u> <u>force</u> <u>&lt;optional&gt;</u>:
           When starting snmpa_local_db it always tries to open an existing database. If <u>false</u>, and some  errors
           occur,  a  new database is created instead. If <u>true</u>, an existing file will be repaired. If <u>force</u>, the
           table will be repaired even if it was properly closed.

           Default is <u>true</u>.

         <u>agent_auto_save()</u> <u>=</u> <u>integer()</u> <u>|</u> <u>infinity</u> <u>&lt;optional&gt;</u>:
           The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.

           Default is <u>5000</u>.

         <u>agent_net_if()</u> <u>=</u> <u>[agent_net_if_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_net_if_opt()</u>  <u>=</u>  <u>{module,</u>  <u>agent_net_if_module()}</u>  <u>|</u>  <u>{verbosity,</u>  <u>verbosity()}</u>   <u>|</u>   <u>{options,</u>
           <u>agent_net_if_options()}</u>

           Defines options specific for the SNMP agent network interface entity.

           For defaults see the options in <u>agent_net_if_opt()</u>.

         <u>agent_net_if_module()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           Module   which   handles  the  network  interface  part  for  the  SNMP  agent.  Must  implement  the
           snmpa_network_interface behaviour.

           Default is <u>snmpa_net_if</u>.

         <u>agent_net_if_options()</u> <u>=</u> <u>[agent_net_if_option()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_net_if_option()</u> <u>=</u> <u>{bind_to,</u> <u>bind_to()}</u> <u>|</u> <u>{sndbuf,</u> <u>sndbuf()}</u> <u>|</u> <u>{recbuf,</u> <u>recbuf()}</u>  <u>|</u>  <u>{no_reuse,</u>
           <u>no_reuse()}</u> <u>|</u> <u>{req_limit,</u> <u>req_limit()}</u> <u>|</u> <u>{filter,</u> <u>agent_net_if_filter_options()}</u> <u>|</u> <u>{open_err_filters,</u>
           <u>agent_net_if_open_err_filters()}</u>  <u>|</u> <u>{extra_sock_opts,</u> <u>extra_socket_options()}</u> <u>|</u> <u>{inet_backend,</u> <u>inet</u> <u>|</u>
           <u>socket}</u>

           These options are actually specific to the used module. The ones shown here  are  applicable  to  the
           default <u>agent_net_if_module()</u>.

     <b>Note:</b>
         If  the user has configured transports <u>with</u> options then those will take precedence over these options.
         See agent information for more info.

           For defaults see the options in <u>agent_net_if_option()</u>.

         <u>req_limit()</u> <u>=</u> <u>integer()</u> <u>|</u> <u>infinity</u> <u>&lt;optional&gt;</u>:
           Max number of simultaneous requests handled by the agent.

           Default is <u>infinity</u>.

         <u>agent_net_if_filter_options()</u> <u>=</u> <u>[agent_net_if_filter_option()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_net_if_filter_option()</u> <u>=</u> <u>{module,</u> <u>agent_net_if_filter_module()}</u>

           These options are actually specific to the used module. The ones shown here  are  applicable  to  the
           default <u>agent_net_if_filter_module()</u>.

           For defaults see the options in <u>agent_net_if_filter_option()</u>.

         <u>agent_net_if_filter_module()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           Module  which  handles  the  network  interface  filter  part  for the SNMP agent. Must implement the
           snmpa_network_interface_filter behaviour.

           Default is <u>snmpa_net_if_filter</u>.

         <u>agent_net_if_open_err_filters()</u> <u>=</u> <u>[agent_net_if_open_err_filter()]</u> <u>&lt;optional&gt;</u>:
           <u>agent_net_if_open_err_filter()</u> <u>=</u> <u>atom()</u>

           During agent initiation, the transports UDP sockets are opened. If this operation fails,  the  net-if
           (and  the  agent)  fails to start (crash). This (filter) list contains error (reasons) that will make
           net-if fail "nicely". This (filter) list, is supposed to contain  errors  that  can  be  returned  by
           gen_udp:open/1,2.  The  effect  is  that any error returned by gen_udp:open which *are* in this list,
           will be considered "non-fatal" and will only result in an info message, rather than an error message.
           Net If, and the agent, will still crash, but will produce a less obnoxious message.

         <u>agent_mibs()</u> <u>=</u> <u>[string()]</u> <u>&lt;optional&gt;</u>:
           Specifies a list of MIBs (including path) that defines which MIBs are initially loaded into the  SNMP
           master agent.

           Note that the following mibs will always be loaded:

           * version v1: <u>STANDARD-MIB</u>

           * version v2: <u>SNMPv2</u>

           * version v3: <u>SNMPv2</u>, <u>SNMP-FRAMEWORK-MIB</u> and <u>SNMP-MPD-MIB</u>

           Default is <u>[]</u>.

         <u>mib_storage()</u> <u>=</u> <u>[mib_storage_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>mib_storage_opt()</u> <u>=</u> <u>{module,</u> <u>mib_storage_module()}</u> <u>|</u> <u>{options,</u> <u>mib_storage_options()}</u>

           This  option  specifies  how  basic  mib data is stored. This option is used by two parts of the snmp
           agent: The mib-server and the symbolic-store.

           Default is <u>[{module,</u> <u>snmpa_mib_storage_ets}]</u>.

         <u>mib_storage_module()</u> <u>=</u> <u>snmpa_mib_data_ets</u> <u>|</u> <u>snmpa_mib_data_dets</u> <u>|</u> <u>snmpa_mib_data_mnesia</u> <u>|</u> <u>module()</u>:
           Defines the mib storage module of the SNMP agent as defined by the snmpa_mib_storage behaviour.

           Several entities (<u>mib-server</u> via the its data module and the <u>symbolic-store</u>) of the snmp  agent  uses
           this for storage of miscellaneous mib related data retrieved while loading a mib.

           There    are    several    implementations    provided   with   the   agent:   <u>snmpa_mib_storage_ets</u>,
           <u>snmpa_mib_storage_dets</u> and <u>snmpa_mib_storage_mnesia</u>.

           Default module is <u>snmpa_mib_storage_ets</u>.

         <u>mib_storage_options()</u> <u>=</u> <u>list()</u> <u>&lt;optional&gt;</u>:
           This is implementation depended. That is, it depends on the module. For each module a specific set of
           options are valid. For the module provided with the app, these options are supported:

           * <u>snmpa_mib_storage_ets</u>: <u>{dir,</u> <u>filename()}</u> <u>|</u> <u>{action,</u> <u>keep</u> <u>|</u> <u>clear},</u> <u>{checksum,</u> <u>boolean()}</u>

             * <u>dir</u> - If present, points to a directory where a file to which  all  data  in  the  ets  table  is
               "synced".

               Also, when a table is opened this file is read, if it exists.

               By default, this will <u>not</u> be used.

             * <u>action</u>  -  Specifies  the  behaviour when a non-empty file is found: Keep its content or clear it
               out.

               Default is <u>keep</u>.

             * <u>checksum</u> - Defines if the file is checksummed or not.

               Default is <u>false</u>.

           * <u>snmpa_mib_storage_dets</u>:  <u>{dir,</u>  <u>filename()}</u>  <u>|</u>  <u>{action,</u>  <u>keep</u>  <u>|</u>  <u>clear},</u>  <u>{auto_save,</u>  <u>default</u>  <u>|</u>
             <u>pos_integer()}</u> <u>|</u> <u>{repair,</u> <u>force</u> <u>|</u> <u>boolean()}</u>

             * <u>dir</u> - This <u>mandatory</u> option points to a directory where to place the file of a dets table.

             * <u>action</u>  -  Specifies  the  behaviour when a non-empty file is found: Keep its content or clear it
               out.

               Default is <u>keep</u>.

             * <u>auto_save</u> - Defines the dets auto-save frequency.

               Default is <u>default</u>.

             * <u>repair</u> - Defines the dets repair behaviour.

               Default is <u>false</u>.

           * <u>snmpa_mib_storage_mnesia</u>: <u>{action,</u> <u>keep</u> <u>|</u> <u>clear},</u> <u>{nodes,</u> <u>[node()]}</u>

             * <u>action</u> - Specifies the behaviour when a non-empty, already existing, table: Keep its  content  or
               clear it out.

               Default is <u>keep</u>.

             * <u>nodes</u>  -  A list of node names (or an atom describing a list of nodes) defining where to open the
               table. Its up to the user to ensure that mnesia is actually running on the specified nodes.

               The following distinct values are recognised:

               * <u>[]</u> - Translated into a list of the own node: <u>[node()]</u>

               * <u>all</u> - <u>erlang:nodes()</u>

               * <u>visible</u> - <u>erlang:nodes(visible)</u>

               * <u>connected</u> - <u>erlang:nodes(connected)</u>

               * <u>db_nodes</u> - <u>mnesia:system_info(db_nodes)</u>

               Default is the result of the call: <u>erlang:nodes()</u>.

         <u>mib_server()</u> <u>=</u> <u>[mib_server_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>mib_server_opt()</u>    <u>=</u>     <u>{mibentry_override,</u>     <u>mibentry_override()}</u>     <u>|</u>     <u>{trapentry_override,</u>
           <u>trapentry_override()}</u>   <u>|</u>   <u>{verbosity,</u>   <u>verbosity()}</u>   <u>|</u>   <u>{cache,</u>  <u>mibs_cache()}</u>  <u>|</u>  <u>{data_module,</u>
           <u>mib_server_data_module()}</u>

           Defines options specific for the SNMP agent mib server.

           For defaults see the options in <u>mib_server_opt()</u>.

         <u>mibentry_override()</u> <u>=</u> <u>bool()</u> <u>&lt;optional&gt;</u>:
           If this value is false, then when loading a mib each mib- entry is checked prior to  installation  of
           the  mib.  The  purpose  of  the check is to prevent that the same symbolic mibentry name is used for
           different oid's.

           Default is <u>false</u>.

         <u>trapentry_override()</u> <u>=</u> <u>bool()</u> <u>&lt;optional&gt;</u>:
           If this value is false, then when loading a mib each trap is checked prior  to  installation  of  the
           mib.  The  purpose  of the check is to prevent that the same symbolic trap name is used for different
           trap's.

           Default is <u>false</u>.

         <u>mib_server_data_module()</u> <u>=</u> <u>snmpa_mib_data_tttn</u> <u>|</u> <u>module()</u> <u>&lt;optional&gt;</u>:
           Defines the backend data module of the  SNMP  agent  mib-server  as  defined  by  the  snmpa_mib_data
           behaviour.

           At present only the default module is provided with the agent, <u>snmpa_mib_data_tttn</u>.

           Default module is <u>snmpa_mib_data_tttn</u>.

         <u>mibs_cache()</u> <u>=</u> <u>bool()</u> <u>|</u> <u>mibs_cache_opts()</u> <u>&lt;optional&gt;</u>:
           Shall the agent utilize the mib server lookup cache or not.

           Default is <u>true</u> (in which case the <u>mibs_cache_opts()</u> default values apply).

         <u>mibs_cache_opts()</u> <u>=</u> <u>[mibs_cache_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>mibs_cache_opt()</u>   <u>=</u>   <u>{autogc,</u>   <u>mibs_cache_autogc()}</u>  <u>|</u>  <u>{gclimit,</u>  <u>mibs_cache_gclimit()}</u>  <u>|</u>  <u>{age,</u>
           <u>mibs_cache_age()}</u>

           Defines options specific for the SNMP agent mib server cache.

           For defaults see the options in <u>mibs_cache_opt()</u>.

         <u>mibs_cache_autogc()</u> <u>=</u> <u>bool()</u> <u>&lt;optional&gt;</u>:
           Defines if the mib server shall perform  cache  gc  automatically  or  leave  it  to  the  user  (see
           gc_mibs_cache/0,1,2,3).

           Default is <u>true</u>.

         <u>mibs_cache_age()</u> <u>=</u> <u>integer()</u> <u>&gt;</u> <u>0</u> <u>&lt;optional&gt;</u>:
           Defines how old the entries in the cache will be allowed to become before they are GC'ed (assuming GC
           is performed). Each entry in the cache is "touched" whenever it is accessed.

           The age is defined in milliseconds.

           Default is <u>10</u> <u>timutes</u>.

         <u>mibs_cache_gclimit()</u> <u>=</u> <u>infinity</u> <u>|</u> <u>integer()</u> <u>&gt;</u> <u>0</u> <u>&lt;optional&gt;</u>:
           When performing a GC, this is the max number of cache entries that will be deleted from the cache.

           The  reason  why  its  possible to set a limit, is that if the cache is large, the GC can potentially
           take a long time, during which the agent is "busy". <u>But</u> on a heavily loaded system, we also risk  not
           removing  enough  elements in the cache, instead causing it to grow over time. This is the reason the
           default value is <u>infinity</u>, which will ensure that <u>all</u> candidates are removed as soon as possible.

           Default is <u>infinity</u>.

         <u>error_report_mod()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           Defines an error report module,  implementing  the  snmpa_error_report  behaviour.  Two  modules  are
           provided with the toolkit: <u>snmpa_error_logger</u> and <u>snmpa_error_io</u>.

           Default is <u>snmpa_error_logger</u>.

         <u>symbolic_store()</u> <u>=</u> <u>[symbolic_store_opt()]</u>:
           <u>symbolic_store_opt()</u> <u>=</u> <u>{verbosity,</u> <u>verbosity()}</u>

           Defines options specific for the SNMP agent symbolic store.

           For defaults see the options in <u>symbolic_store_opt()</u>.

         <u>target_cache()</u> <u>=</u> <u>[target_cache_opt()]</u>:
           <u>target_cache_opt()</u> <u>=</u> <u>{verbosity,</u> <u>verbosity()}</u>

           Defines options specific for the SNMP agent target cache.

           For defaults see the options in <u>target_cache_opt()</u>.

         <u>agent_config()</u> <u>=</u> <u>[agent_config_opt()]</u> <u>&lt;mandatory&gt;</u>:
           <u>agent_config_opt()</u>   <u>=</u>   <u>{dir,</u>   <u>agent_config_dir()}</u>   <u>|</u>  <u>{force_load,</u>  <u>force_load()}</u>  <u>|</u>  <u>{verbosity,</u>
           <u>verbosity()}</u>

           Defines specific config related options for the SNMP agent.

           For defaults see the options in <u>agent_config_opt()</u>.

         <u>agent_config_dir</u> <u>=</u> <u>dir()</u> <u>&lt;mandatory&gt;</u>:
           Defines where the SNMP agent configuration files are stored.

         <u>force_load()</u> <u>=</u> <u>bool()</u> <u>&lt;optional&gt;</u>:
           If <u>true</u> the configuration files are re-read during start-up, and the contents  of  the  configuration
           database  ignored.  Thus,  if <u>true</u>, changes to the configuration database are lost upon reboot of the
           agent.

           Default is <u>false</u>.

       Manager specific config options and types:

         <u>server()</u> <u>=</u> <u>[server_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>server_opt()</u> <u>=</u> <u>{timeout,</u> <u>server_timeout()}</u> <u>|</u> <u>{verbosity,</u> <u>verbosity()}</u> <u>|</u> <u>{cbproxy,</u> <u>server_cbproxy()}</u> <u>|</u>
           <u>{netif_sup,</u> <u>server_nis()}</u>

           Specifies the options for the manager server process.

           Default is <u>silence</u>.

         <u>server_timeout()</u> <u>=</u> <u>integer()</u> <u>&lt;optional&gt;</u>:
           Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be
           able to deliver the reply (when it arrives) to the proper destination. If  the  reply  arrives,  this
           info  will  be deleted. But if there is no reply (in time), the info has to be deleted after the <u>best</u>
           <u>before</u> time has been passed. This cleanup will be performed at  regular  intervals,  defined  by  the
           <u>server_timeout()</u>  time.  The  information  will  have an <u>best</u> <u>before</u> time, defined by the <u>Expire</u> time
           given when calling the request function (see async_get, async_get_next and async_set).

           Time in milli-seconds.

           Default is <u>30000</u>.

         <u>server_cbproxy()</u> <u>=</u> <u>temporary</u> <u>(default)</u> <u>|</u> <u>permanent</u> <u>&lt;optional&gt;</u>:
           This option specifies how the server will handle callback calls.

           <u>temporary</u> <u>(default)</u>:
             A temporary process will be created for each callback call.

           <u>permanent</u>:
             With this the server will create a permanent (named) process that in effect serializes all callback
             calls.

           Default is <u>temporary</u>.

         <u>server_nis()</u> <u>=</u> <u>none</u> <u>(default)</u> <u>|</u> <u>{PingTO,</u> <u>PongTO}</u> <u>&lt;optional&gt;</u>:
           This option specifies if the server should actively supervise the net-if process. Note that this will
           only work if the used net-if process actually  supports  the  protocol.  See  snmpm_network_interface
           behaviour for more info.

           <u>none</u> <u>(default)</u>:
             No active supervision of the net-if process.

           <u>{PingTO</u> <u>::</u> <u>pos_integer(),</u> <u>PongTO</u> <u>::</u> <u>pos_integer()}</u>:
             The <u>PingTO</u> time specifies the between a successful ping (or start) and the time when a ping message
             is to be sent to the net-if process (basically the time between ping).

             The <u>PongTO</u> time specifies how long time the net-if process has to respond to a ping message, with a
             <u>pong</u> message. Its starts counting when the ping message has been sent.

             Both times are in milli seconds.

           Default is <u>none</u>.

         <u>manager_config()</u> <u>=</u> <u>[manager_config_opt()]</u> <u>&lt;mandatory&gt;</u>:
           <u>manager_config_opt()</u>  <u>=</u>  <u>{dir,</u>  <u>manager_config_dir()}</u>  <u>|</u> <u>{db_dir,</u> <u>manager_db_dir()}</u> <u>|</u> <u>{db_init_error,</u>
           <u>db_init_error()}</u> <u>|</u>  <u>{repair,</u>  <u>manager_repair()}</u>  <u>|</u>  <u>{auto_save,</u>  <u>manager_auto_save()}</u>  <u>|</u>  <u>{verbosity,</u>
           <u>verbosity()}</u>

           Defines specific config related options for the SNMP manager.

           For defaults see the options in <u>manager_config_opt()</u>.

         <u>manager_config_dir</u> <u>=</u> <u>dir()</u> <u>&lt;mandatory&gt;</u>:
           Defines where the SNMP manager configuration files are stored.

         <u>manager_db_dir</u> <u>=</u> <u>dir()</u> <u>&lt;mandatory&gt;</u>:
           Defines where the SNMP manager store persistent data.

         <u>manager_repair()</u> <u>=</u> <u>false</u> <u>|</u> <u>true</u> <u>|</u> <u>force</u> <u>&lt;optional&gt;</u>:
           Defines the repair option for the persistent database (if and how the table is repaired when opened).

           Default is <u>true</u>.

         <u>manager_auto_save()</u> <u>=</u> <u>integer()</u> <u>|</u> <u>infinity</u> <u>&lt;optional&gt;</u>:
           The auto save interval. The table is flushed to disk whenever not accessed for this amount of time.

           Default is <u>5000</u>.

         <u>manager_irb()</u> <u>=</u> <u>auto</u> <u>|</u> <u>user</u> <u>|</u> <u>{user,</u> <u>integer()}</u> <u>&lt;optional&gt;</u>:
           This  option defines how the manager will handle the sending of response (acknowledgment) to received
           inform-requests.

           * <u>auto</u> - The manager will autonomously send response (acknowledgment&gt; to inform-request messages.

           * <u>{user,</u> <u>integer()}</u> - The manager will send response (acknowledgment) to inform-request messages when
             the handle_inform function completes. The integer is the time, in milli-seconds, that  the  manager
             will consider the stored inform-request info valid.

           * <u>user</u> - Same as <u>{user,</u> <u>integer()}</u>, except that the default time, 15 seconds (15000), is used.

           See snmpm_network_interface, handle_inform and definition of the manager net if for more info.

           Default is <u>auto</u>.

         <u>manager_mibs()</u> <u>=</u> <u>[string()]</u> <u>&lt;optional&gt;</u>:
           Specifies  a  list of MIBs (including path) and defines which MIBs are initially loaded into the SNMP
           manager.

           Default is <u>[]</u>.

         <u>manager_net_if()</u> <u>=</u> <u>[manager_net_if_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>manager_net_if_opt()</u> <u>=</u> <u>{module,</u>  <u>manager_net_if_module()}</u>  <u>|</u>  <u>{verbosity,</u>  <u>verbosity()}</u>  <u>|</u>  <u>{options,</u>
           <u>manager_net_if_options()}</u>

           Defines options specific for the SNMP manager network interface entity.

           For defaults see the options in <u>manager_net_if_opt()</u>.

         <u>manager_net_if_options()</u> <u>=</u> <u>[manager_net_if_option()]</u> <u>&lt;optional&gt;</u>:
           <u>manager_net_if_option()</u> <u>=</u> <u>{bind_to,</u> <u>bind_to()}</u> <u>|</u> <u>{sndbuf,</u> <u>sndbuf()}</u> <u>|</u> <u>{recbuf,</u> <u>recbuf()}</u> <u>|</u> <u>{no_reuse,</u>
           <u>no_reuse()}</u> <u>|</u> <u>{filter,</u> <u>manager_net_if_filter_options()}</u> <u>|</u> <u>{extra_sock_opts,</u> <u>extra_socket_options()}</u> <u>|</u>
           <u>{inet_backend,</u> <u>inet</u> <u>|</u> <u>socket}</u>

           These  options  are  actually  specific to the used module. The ones shown here are applicable to the
           default <u>manager_net_if_module()</u>.

           For defaults see the options in <u>manager_net_if_option()</u>.

         <u>manager_net_if_module()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           The module which handles the network interface part for the  SNMP  manager.  It  must  implement  the
           snmpm_network_interface behaviour.

           Default is <u>snmpm_net_if</u>.

         <u>manager_net_if_filter_options()</u> <u>=</u> <u>[manager_net_if_filter_option()]</u> <u>&lt;optional&gt;</u>:
           <u>manager_net_if_filter_option()</u> <u>=</u> <u>{module,</u> <u>manager_net_if_filter_module()}</u>

           These  options  are  actually  specific to the used module. The ones shown here are applicable to the
           default <u>manager_net_if_filter_module()</u>.

           For defaults see the options in <u>manager_net_if_filter_option()</u>.

         <u>manager_net_if_filter_module()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           Module which handles the network interface filter part for  the  SNMP  manager.  Must  implement  the
           snmpm_network_interface_filter behaviour.

           Default is <u>snmpm_net_if_filter</u>.

         <u>def_user_module()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           The module implementing the default user. See the snmpm_user behaviour.

           Default is <u>snmpm_user_default</u>.

         <u>def_user_data()</u> <u>=</u> <u>term()</u> <u>&lt;optional&gt;</u>:
           Data for the default user. Passed to the user module when calling the callback functions.

           Default is <u>undefined</u>.

       Common config types:

         <u>restart_type()</u> <u>=</u> <u>permanent</u> <u>|</u> <u>transient</u> <u>|</u> <u>temporary</u>:
           See supervisor documentation for more info.

           Default is <u>permanent</u> for the agent and <u>transient</u> for the manager.

         <u>db_init_error()</u> <u>=</u> <u>terminate</u> <u>|</u> <u>create</u> <u>|</u> <u>create_db_and_dir</u>:
           Defines  what  to  do  if the agent or manager is unable to open an existing database file. <u>terminate</u>
           means that the agent/manager will terminate and <u>create</u> means that the agent/manager will  remove  the
           faulty  file(s)  and  create new ones, and <u>create_db_and_dir</u> means that the agent/manager will create
           the database file along with any missing parent directories for the database file.

           Default is <u>terminate</u>.

         <u>priority()</u> <u>=</u> <u>atom()</u> <u>&lt;optional&gt;</u>:
           Defines the Erlang priority for all SNMP processes.

           Default is <u>normal</u>.

         <u>versions()</u> <u>=</u> <u>[version()]</u> <u>&lt;optional&gt;</u>:
           <u>version()</u> <u>=</u> <u>v1</u> <u>|</u> <u>v2</u> <u>|</u> <u>v3</u>

           Which SNMP versions shall be accepted/used.

           Default is <u>[v1,v2,v3]</u>.

         <u>verbosity()</u> <u>=</u> <u>silence</u> <u>|</u> <u>info</u> <u>|</u> <u>log</u> <u>|</u> <u>debug</u> <u>|</u> <u>trace</u> <u>&lt;optional&gt;</u>:
           Verbosity for a SNMP process. This specifies now much debug info is printed.

           Default is <u>silence</u>.

         <u>bind_to()</u> <u>=</u> <u>bool()</u> <u>&lt;optional&gt;</u>:
           If <u>true</u>, net_if binds to the IP address. If <u>false</u>, net_if listens on any IP address on the host where
           it is running.

           Default is <u>false</u>.

         <u>no_reuse()</u> <u>=</u> <u>bool()</u> <u>&lt;optional&gt;</u>:
           If <u>true</u>, net_if does not specify that the IP and port address  should  be  reusable.  If  <u>false</u>,  the
           address is set to reusable.

           Default is <u>false</u>.

         <u>recbuf()</u> <u>=</u> <u>integer()</u> <u>&lt;optional&gt;</u>:
           Receive buffer size.

           Default value is defined by <u>gen_udp</u>.

         <u>sndbuf()</u> <u>=</u> <u>integer()</u> <u>&lt;optional&gt;</u>:
           Send buffer size.

           Default value is defined by <u>gen_udp</u>.

         <u>extra_socket_options()</u> <u>=</u> <u>list()</u> <u>&lt;optional&gt;</u>:
           A list of arbitrary socket options.

           This  list  is  not  inspected  by  snmp  (other  then  checking  that  its  a  list).  Its the users
           responsibility to ensure that these are valid  options  and  does  not  conflict  with  the  "normal"
           options.

           Default is <u>[]</u>.

         <u>note_store()</u> <u>=</u> <u>[note_store_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>note_store_opt()</u> <u>=</u> <u>{timeout,</u> <u>note_store_timeout()}</u> <u>|</u> <u>{verbosity,</u> <u>verbosity()}</u>

           Specifies the start-up verbosity for the SNMP note store.

           For defaults see the options in <u>note_store_opt()</u>.

         <u>note_store_timeout()</u> <u>=</u> <u>integer()</u> <u>&lt;optional&gt;</u>:
           Note  cleanup time. When storing a note in the note store, each note is given lifetime. Every <u>timeout</u>
           the note_store process performs a GC to remove the expired note's. Time in milli-seconds.

           Default is <u>30000</u>.

         <u>audit_trail_log()</u> <u>=</u> <u>[audit_trail_log_opt()]</u> <u>&lt;optional&gt;</u>:
           <u>audit_trail_log_opt()</u> <u>=</u> <u>{type,</u> <u>atl_type()}</u>  <u>|</u>  <u>{dir,</u>  <u>atl_dir()}</u>  <u>|</u>  <u>{size,</u>  <u>atl_size()}</u>  <u>|</u>  <u>{repair,</u>
           <u>atl_repair()}</u> <u>|</u> <u>{seqno,</u> <u>atl_seqno()}</u>

           If  present,  this  option  specifies the options for the audit trail logging. The <u>disk_log</u> module is
           used to maintain a wrap log. If present, the <u>dir</u> and <u>size</u> options are mandatory.

           If not present, audit trail logging is not used.

         <u>atl_type()</u> <u>=</u> <u>read</u> <u>|</u> <u>write</u> <u>|</u> <u>read_write</u> <u>&lt;optional&gt;</u>:
           Specifies what type of an audit trail log should  be  used.  The  effect  of  the  type  is  actually
           different for the the agent and the manager.

           For the agent:

           * If <u>write</u> is specified, only set requests are logged.

           * If <u>read</u> is specified, only get requests are logged.

           * If <u>read_write</u>, all requests are logged.

           For the manager:

           * If <u>write</u> is specified, only sent messages are logged.

           * If <u>read</u> is specified, only received messages are logged.

           * If <u>read_write</u>, both outgoing and incoming messages are logged.

           Default is <u>read_write</u>.

         <u>atl_dir</u> <u>=</u> <u>dir()</u> <u>&lt;mandatory&gt;</u>:
           Specifies where the audit trail log should be stored.

           If <u>audit_trail_log</u> specifies that logging should take place, this parameter <u>must</u> be defined.

         <u>atl_size()</u> <u>=</u> <u>{integer(),</u> <u>integer()}</u> <u>&lt;mandatory&gt;</u>:
           Specifies the size of the audit trail log. This parameter is sent to <u>disk_log</u>.

           If <u>audit_trail_log</u> specifies that logging should take place, this parameter <u>must</u> be defined.

         <u>atl_repair()</u> <u>=</u> <u>true</u> <u>|</u> <u>false</u> <u>|</u> <u>truncate</u> <u>|</u> <u>snmp_repair</u> <u>&lt;optional&gt;</u>:
           Specifies if and how the audit trail log shall be repaired when opened. Unless this parameter has the
           value  <u>snmp_repair</u>  it  is  sent  to  <u>disk_log</u>. If, on the other hand, the value is <u>snmp_repair</u>, snmp
           attempts to handle certain faults on its own. And even if it cannot repair  the  file,  it  does  not
           truncate it directly, but instead <u>moves</u> <u>it</u> <u>aside</u> for later off-line analysis.

           Default is <u>true</u>.

         <u>atl_seqno()</u> <u>=</u> <u>true</u> <u>|</u> <u>false</u> <u>&lt;optional&gt;</u>:
           Specifies  if  the  audit  trail  log  entries  will  be (sequence) numbered or not. The range of the
           sequence numbers are according to RFC 5424, i.e. 1 through 2147483647.

           Default is <u>false</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/application.3erl.html">application</a>(3erl), <a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)

Ericsson AB                                        snmp 5.13.5                                           <u><a href="../man7/SNMP.7.html">SNMP</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>