<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>librpmem - remote persistent memory support library (EXPERIMENTAL)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/librpmem-dev">librpmem-dev_1.11.1-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>librpmem</b> - remote persistent memory support library (EXPERIMENTAL)

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;librpmem.h&gt;
              cc ... -lrpmem

   <b>Library</b> <b>API</b> <b>versioning:</b>
              const char *rpmem_check_version(
                  unsigned major_required,
                  unsigned minor_required);

   <b>Error</b> <b>handling:</b>
              const char *rpmem_errormsg(void);

   <b>Other</b> <b>library</b> <b>functions:</b>
       A description of other <b>librpmem</b> functions can be found on the following manual pages:

       • <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3), <b><a href="../man3/rpmem_persist.3.html">rpmem_persist</a></b>(3)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>librpmem</b>  provides low-level support for remote access to <u>persistent</u> <u>memory</u> (pmem) utilizing RDMA-capable
       RNICs.  The library can be used to remotely replicate a memory region over the RDMA  protocol.   It  uti‐
       lizes  an  appropriate  persistency mechanism based on the remote node's platform capabilities.  <b>librpmem</b>
       utilizes the <b><a href="../man1/ssh.1.html">ssh</a></b>(1) client to authenticate a user on the remote node, and for encryption of  the  connec‐
       tion's out-of-band configuration data.  See <b>SSH</b>, below, for details.

       The  maximum  replicated  memory  region size can not be bigger than the maximum locked-in-memory address
       space limit.  See <b>memlock</b> in <b><a href="../man5/limits.conf.5.html">limits.conf</a></b>(5) for more details.

       This library is for applications that use remote persistent memory directly, without the help of any  li‐
       brary-supplied  transactions  or  memory allocation.  Higher-level libraries that build on <b><a href="../man7/libpmem.7.html">libpmem</a></b>(7) are
       available and are recommended for most applications, see:

       • <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7), a general use persistent memory API, providing memory allocation and transactional oper‐
         ations on variable-sized objects.

</pre><h4><b>TARGET</b> <b>NODE</b> <b>ADDRESS</b> <b>FORMAT</b></h4><pre>
              [&lt;user&gt;@]&lt;hostname&gt;[:&lt;port&gt;]

       The target node address is described by the <u>hostname</u> which the client connects to, with an optional  <u>user</u>
       name.   The  user  must  be  authorized  to authenticate to the remote machine without querying for pass‐
       word/passphrase.  The optional <u>port</u> number is used to establish the SSH  connection.   The  default  port
       number is 22.

</pre><h4><b>REMOTE</b> <b>POOL</b> <b>ATTRIBUTES</b></h4><pre>
       The  <u>rpmem_pool_attr</u>  structure  describes  a  remote pool and is stored in remote pool's metadata.  This
       structure must be passed to the <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3) function by caller when creating a pool on  remote  node.
       When  opening  the pool using <b><a href="../man3/rpmem_open.3.html">rpmem_open</a></b>(3) function the appropriate fields are read from pool's metadata
       and returned back to the caller.

              #define RPMEM_POOL_HDR_SIG_LEN    8
              #define RPMEM_POOL_HDR_UUID_LEN   16
              #define RPMEM_POOL_USER_FLAGS_LEN 16

              struct rpmem_pool_attr {
                  char signature[RPMEM_POOL_HDR_SIG_LEN];
                  uint32_t major;
                  uint32_t compat_features;
                  uint32_t incompat_features;
                  uint32_t ro_compat_features;
                  unsigned char poolset_uuid[RPMEM_POOL_HDR_UUID_LEN];
                  unsigned char uuid[RPMEM_POOL_HDR_UUID_LEN];
                  unsigned char next_uuid[RPMEM_POOL_HDR_UUID_LEN];
                  unsigned char prev_uuid[RPMEM_POOL_HDR_UUID_LEN];
                  unsigned char user_flags[RPMEM_POOL_USER_FLAGS_LEN];
              };

       The <u>signature</u> field is an 8-byte field which describes the pool's on-media format.

       The <u>major</u> field is a major version number of the pool's on-media format.

       The <u>compat_features</u> field is a mask describing compatibility of pool's on-media format optional features.

       The <u>incompat_features</u> field is a mask describing compatibility of pool's on-media  format  required  fea‐
       tures.

       The  <u>ro_compat_features</u>  field is a mask describing compatibility of pool's on-media format features.  If
       these features are not available, the pool shall be opened in read-only mode.

       The <u>poolset_uuid</u> field is an UUID of the pool which the remote pool is associated with.

       The <u>uuid</u> field is an UUID of a first part of the remote pool.  This field can be used to connect the  re‐
       mote pool with other pools in a list.

       The  <u>next_uuid</u>  and  <u>prev_uuid</u> fields are UUIDs of next and previous replicas respectively.  These fields
       can be used to connect the remote pool with other pools in a list.

       The <u>user_flags</u> field is a 16-byte user-defined flags.

</pre><h4><b>SSH</b></h4><pre>
       <b>librpmem</b> utilizes the <b><a href="../man1/ssh.1.html">ssh</a></b>(1) client to login and execute the <b><a href="../man1/rpmemd.1.html">rpmemd</a></b>(1) process on the  remote  node.   By
       default, <b><a href="../man1/ssh.1.html">ssh</a></b>(1) is executed with the <b>-4</b> option, which forces using <b>IPv4</b> addressing.

       For  debugging purposes, both the ssh client and the commands executed on the remote node may be overrid‐
       den by setting the <b>RPMEM_SSH</b> and <b>RPMEM_CMD</b> environment variables, respectively.  See <b>ENVIRONMENT</b> for  de‐
       tails.

</pre><h4><b>FORK</b></h4><pre>
       The  <b><a href="../man1/ssh.1.html">ssh</a></b>(1)  client  is executed by <b><a href="../man3/rpmem_open.3.html">rpmem_open</a></b>(3) and <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3) after forking a child process using
       <b><a href="../man2/fork.2.html">fork</a></b>(2).  The application must take this into account when using <b><a href="../man2/wait.2.html">wait</a></b>(2) and <b><a href="../man2/waitpid.2.html">waitpid</a></b>(2), which may return
       the <u>PID</u> of the <b><a href="../man1/ssh.1.html">ssh</a></b>(1) process executed by <b>librpmem</b>.

       If <b><a href="../man2/fork.2.html">fork</a></b>(2) support is not enabled in <b>libibverbs</b>, <b><a href="../man3/rpmem_open.3.html">rpmem_open</a></b>(3) and <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3)  will  fail.   By  de‐
       fault,  <b><a href="../man7/fabric.7.html">fabric</a></b>(7)  initializes  <b>libibverbs</b> with <b><a href="../man2/fork.2.html">fork</a></b>(2) support by calling the <b><a href="../man3/ibv_fork_init.3.html">ibv_fork_init</a></b>(3) function.
       See <b><a href="../man7/fi_verbs.7.html">fi_verbs</a></b>(7) for more details.

</pre><h4><b>CAVEATS</b></h4><pre>
       <b>librpmem</b> relies on the library destructor being called from the main thread.  For this reason, all  func‐
       tions  that  might trigger destruction (e.g.  <b><a href="../man3/dlclose.3.html">dlclose</a></b>(3)) should be called in the main thread.  Otherwise
       some of the resources associated with that thread might not be cleaned up properly.

       <b>librpmem</b> registers a pool as a single memory region.  A Chelsio T4 and T5 hardware can not handle a memo‐
       ry region greater than or equal to 8GB due to a hardware bug.  So <u>pool_size</u> value for <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3) and
       <b><a href="../man3/rpmem_open.3.html">rpmem_open</a></b>(3) using this hardware can not be greater than or equal to 8GB.

</pre><h4><b>LIBRARY</b> <b>API</b> <b>VERSIONING</b></h4><pre>
       This section describes how the library API is versioned, allowing applications to work with  an  evolving
       API.

       The  <b>rpmem_check_version</b>()  function is used to see if the installed <b>librpmem</b> supports the version of the
       library API required by an application.  The easiest way to do this is for the application to supply  the
       compile-time version information, supplied by defines in <b>&lt;librpmem.h&gt;</b>, like this:

              reason = rpmem_check_version(RPMEM_MAJOR_VERSION,
                                           RPMEM_MINOR_VERSION);
              if (reason != NULL) {
                  /* version check failed, reason string tells you why */
              }

       Any  mismatch  in the major version number is considered a failure, but a library with a newer minor ver‐
       sion number will pass this check since increasing minor versions imply backwards compatibility.

       An application can also check specifically for the existence of an interface by checking for the  version
       where  that  interface was introduced.  These versions are documented in this man page as follows: unless
       otherwise specified, all interfaces described here are available in version 1.0 of the  library.   Inter‐
       faces added after version 1.0 will contain the text <u>introduced</u> <u>in</u> <u>version</u> <u>x.y</u> in the section of this man‐
       ual describing the feature.

       When  the version check performed by <b>rpmem_check_version</b>() is successful, the return value is NULL.  Oth‐
       erwise the return value is a static string describing the reason for  failing  the  version  check.   The
       string returned by <b>rpmem_check_version</b>() must not be modified or freed.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>librpmem</b> can change its default behavior based on the following environment variables.  These are largely
       intended for testing and are not normally required.

       • <b>RPMEM_SSH</b>=<u>ssh_client</u>

       Setting this environment variable overrides the default <b><a href="../man1/ssh.1.html">ssh</a></b>(1) client command name.

       • <b>RPMEM_CMD</b>=<u>cmd</u>

       Setting  this environment variable overrides the default command executed on the remote node using either
       <b><a href="../man1/ssh.1.html">ssh</a></b>(1) or the alternative remote shell command specified by <b>RPMEM_SSH</b>.

       <b>RPMEM_CMD</b> can contain multiple commands separated by a vertical bar (|).  Each consecutive command is ex‐
       ecuted on the remote node in order read from a pool set file.  This environment variable is read when the
       library is initialized, so <b>RPMEM_CMD</b> must be set prior to application launch (or prior  to  <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3)  if
       <b>librpmem</b> is being dynamically loaded).

       • <b>RPMEM_ENABLE_SOCKETS</b>=0|1

       Setting this variable to 1 enables using <b><a href="../man7/fi_sockets.7.html">fi_sockets</a></b>(7) provider for in-band RDMA connection.  The <u>sockets</u>
       provider  does not support IPv6.  It is required to disable IPv6 system wide if <b>RPMEM_ENABLE_SOCKETS</b> == 1
       and <u>target</u> == localhost (or any other loopback interface address) and <b>SSH_CONNECTION</b> variable (see <b><a href="../man1/ssh.1.html">ssh</a></b>(1)
       for more details) contains IPv6 address after ssh to loopback interface.  By default the <u>sockets</u> provider
       is disabled.

       • <b>RPMEM_ENABLE_VERBS</b>=0|1

       Setting this variable to 0 disables using <b><a href="../man7/fi_verbs.7.html">fi_verbs</a></b>(7) provider for in-band RDMA  connection.   The  <u>verbs</u>
       provider is enabled by default.

       • <b>RPMEM_MAX_NLANES</b>=<u>num</u>

       Limit the maximum number of lanes to <u>num</u>.  See <b>LANES</b>, in <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3), for details.

       • <b>RPMEM_WORK_QUEUE_SIZE</b>=<u>size</u>

       Suggest the work queue size.  The effective work queue size can be greater than suggested if <b>librpmem</b> re‐
       quires  it  or  it  can  be smaller if underlying hardware does not support the suggested size.  The work
       queue size affects the performance of communication to the remote node.  <b><a href="../man3/rpmem_flush.3.html">rpmem_flush</a></b>(3) operations can be
       added to the work queue up to the size of this queue.  When work queue is full any subsequent call has to
       wait till the work queue will be drained.  <b><a href="../man3/rpmem_drain.3.html">rpmem_drain</a></b>(3) and <b><a href="../man3/rpmem_persist.3.html">rpmem_persist</a></b>(3) among  other  things  also
       drain the work queue.

</pre><h4><b>DEBUGGING</b> <b>AND</b> <b>ERROR</b> <b>HANDLING</b></h4><pre>
       If  an  error  is  detected during the call to a <b>librpmem</b> function, the application may retrieve an error
       message describing the reason for the failure from <b>rpmem_errormsg</b>().  This function returns a pointer  to
       a  static  buffer containing the last error message logged for the current thread.  If <u>errno</u> was set, the
       error message may include a description of the corresponding error code as returned by <b><a href="../man3/strerror.3.html">strerror</a></b>(3).   The
       error  message  buffer is thread-local; errors encountered in one thread do not affect its value in other
       threads.  The buffer is never cleared by any library function; its content is significant only  when  the
       return value of the immediately preceding call to a <b>librpmem</b> function indicated an error, or if <u>errno</u> was
       set.   The application must not modify or free the error message string, but it may be modified by subse‐
       quent calls to other library functions.

       Two versions of <b>librpmem</b> are typically available on a development system.  The normal  version,  accessed
       when  a  program  is  linked  using the <b>-lrpmem</b> option, is optimized for performance.  That version skips
       checks that impact performance and never logs any trace information or performs any run-time assertions.

       A second version of <b>librpmem</b>, accessed when a program uses the libraries under <b>/usr/lib/pmdk_debug</b>,  con‐
       tains  run-time  assertions  and trace points.  The typical way to access the debug version is to set the
       environment variable <b>LD_LIBRARY_PATH</b> to <b>/usr/lib/pmdk_debug</b>  or  <b>/usr/lib64/pmdk_debug</b>,  as  appropriate.
       Debugging output is controlled using the following environment variables.  These variables have no effect
       on the non-debug version of the library.

              NOTE:  On Debian/Ubuntu systems, this extra debug version of the library is shipped in the respec‐
              tive <b>-debug</b> Debian package and placed in the <b><a href="file:/usr/lib/">/usr/lib/</a>$ARCH/pmdk_dbg/</b> directory.

       • <b>RPMEM_LOG_LEVEL</b>

       The value of <b>RPMEM_LOG_LEVEL</b> enables trace points in the debug version of the library, as follows:

       • <b>0</b> - This is the default level when <b>RPMEM_LOG_LEVEL</b> is not set.  No log messages  are  emitted  at  this
         level.

       • <b>1</b>  - Additional details on any errors detected are logged (in addition to returning the <u>errno</u>-based er‐
         rors as usual).  The same information may be retrieved using <b>rpmem_errormsg</b>().

       • <b>2</b> - A trace of basic operations is logged.

       • <b>3</b> - Enables a very verbose amount of function call tracing in the library.

       • <b>4</b> - Enables voluminous and fairly obscure tracing information that is likely only useful to the  <b>librp‐</b>
         <b>mem</b> developers.

       Unless <b>RPMEM_LOG_FILE</b> is set, debugging output is written to <u>stderr</u>.

       • <b>RPMEM_LOG_FILE</b>

       Specifies  the  name of a file where all logging information should be written.  If the last character in
       the name is “-”, the <u>PID</u> of the current process will be appended to the file name when the  log  file  is
       created.  If <b>RPMEM_LOG_FILE</b> is not set, logging output is written to <u>stderr</u>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example uses <b>librpmem</b> to create a remote pool on given target node identified by given pool
       set  name.   The  associated  local memory pool is zeroed and the data is made persistent on remote node.
       Upon success the remote pool is closed.

              #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
              #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
              #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
              #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;

              #include &lt;librpmem.h&gt;

              #define POOL_SIGNATURE  "MANPAGE"
              #define POOL_SIZE   (32 * 1024 * 1024)
              #define NLANES      4

              #define DATA_OFF    4096
              #define DATA_SIZE   (POOL_SIZE - DATA_OFF)

              static void
              parse_args(int argc, char *argv[], const char **target, const char **poolset)
              {
                  if (argc &lt; 3) {
                      fprintf(stderr, "usage:\t%s &lt;target&gt; &lt;poolset&gt;\n", argv[0]);
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  *target = argv[1];
                  *poolset = argv[2];
              }

              static void *
              alloc_memory()
              {
                  long pagesize = sysconf(_SC_PAGESIZE);
                  if (pagesize &lt; 0) {
                      perror("sysconf");
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  /* allocate a page size aligned local memory pool */
                  void *mem;
                  int ret = posix_memalign(&amp;mem, pagesize, POOL_SIZE);
                  if (ret) {
                      fprintf(stderr, "posix_memalign: %s\n", strerror(ret));
                      <a href="../man1/exit.1.html">exit</a>(1);
                  }

                  assert(mem != NULL);

                  return mem;
              }

              int
              main(int argc, char *argv[])
              {
                  const char *target, *poolset;
                  parse_args(argc, argv, &amp;target, &amp;poolset);

                  unsigned nlanes = NLANES;
                  void *pool = alloc_memory();
                  int ret;

                  /* fill pool_attributes */
                  struct rpmem_pool_attr pool_attr;
                  memset(&amp;pool_attr, 0, sizeof(pool_attr));
                  strncpy(pool_attr.signature, POOL_SIGNATURE, RPMEM_POOL_HDR_SIG_LEN);

                  /* create a remote pool */
                  RPMEMpool *rpp = rpmem_create(target, poolset, pool, POOL_SIZE,
                          &amp;nlanes, &amp;pool_attr);
                  if (!rpp) {
                      fprintf(stderr, "rpmem_create: %s\n", rpmem_errormsg());
                      return 1;
                  }

                  /* store data on local pool */
                  memset(pool, 0, POOL_SIZE);

                  /* make local data persistent on remote node */
                  ret = rpmem_persist(rpp, DATA_OFF, DATA_SIZE, 0, 0);
                  if (ret) {
                      fprintf(stderr, "rpmem_persist: %s\n", rpmem_errormsg());
                      return 1;
                  }

                  /* close the remote pool */
                  ret = rpmem_close(rpp);
                  if (ret) {
                      fprintf(stderr, "rpmem_close: %s\n", rpmem_errormsg());
                      return 1;
                  }

                  free(pool);

                  return 0;
              }

</pre><h4><b>NOTE</b></h4><pre>
       The <b>librpmem</b> API is experimental and may be subject to change in the future.  However, using  the  remote
       replication in <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) is safe and backward compatibility will be preserved.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       <b>librpmem</b>  builds on the persistent memory programming model recommended by the SNIA NVM Programming Tech‐
       nical Work Group: &lt;https://snia.org/nvmp&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/rpmemd.1.html">rpmemd</a></b>(1), <b><a href="../man1/ssh.1.html">ssh</a></b>(1), <b><a href="../man2/fork.2.html">fork</a></b>(2), <b><a href="../man3/dlclose.3.html">dlclose</a></b>(3), <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3), <b><a href="../man3/ibv_fork_init.3.html">ibv_fork_init</a></b>(3), <b><a href="../man3/rpmem_create.3.html">rpmem_create</a></b>(3), <b><a href="../man3/rpmem_drain.3.html">rpmem_drain</a></b>(3), <b>rp‐</b>
       <b><a href="../man3/mem_flush.3.html">mem_flush</a></b>(3), <b><a href="../man3/rpmem_open.3.html">rpmem_open</a></b>(3), <b><a href="../man3/rpmem_persist.3.html">rpmem_persist</a></b>(3),  <b><a href="../man3/strerror.3.html">strerror</a></b>(3),  <b><a href="../man5/limits.conf.5.html">limits.conf</a></b>(5),  <b><a href="../man7/fabric.7.html">fabric</a></b>(7),  <b><a href="../man7/fi_sockets.7.html">fi_sockets</a></b>(7),
       <b><a href="../man7/fi_verbs.7.html">fi_verbs</a></b>(7), <b><a href="../man7/libpmem.7.html">libpmem</a></b>(7), <b><a href="../man7/libpmemblk.7.html">libpmemblk</a></b>(7), <b><a href="../man7/libpmemlog.7.html">libpmemlog</a></b>(7), <b><a href="../man7/libpmemobj.7.html">libpmemobj</a></b>(7) and <b>&lt;https://pmem.io&gt;</b>

PMDK - rpmem API version 1.3                       2021-09-24                                        <u><a href="../man7/LIBRPMEM.7.html">LIBRPMEM</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>