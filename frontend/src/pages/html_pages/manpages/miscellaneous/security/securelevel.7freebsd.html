<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>security — introduction to security under FreeBSD</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       security — introduction to security under FreeBSD

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Security  is  a  function  that  begins and ends with the system administrator.  While all BSD multi-user
       systems have some inherent security, the job of building and maintaining additional  security  mechanisms
       to  keep users “honest” is probably one of the single largest undertakings of the sysadmin.  Machines are
       only as secure as you make them, and security concerns are ever competing with the  human  necessity  for
       convenience.   Unix  systems,  in general, are capable of running a huge number of simultaneous processes
       and many of these processes operate as servers — meaning that external entities can connect and  talk  to
       them.   As  yesterday's  mini-computers  and  mainframes become today's desktops, and as computers become
       networked and internetworked, security becomes an ever bigger issue.

       Security is best implemented through a layered onion approach.  In a nutshell, what you want to do is  to
       create as many layers of security as are convenient and then carefully monitor the system for intrusions.

       System security also pertains to dealing with various forms of attacks, including attacks that attempt to
       crash  or  otherwise  make  a system unusable but do not attempt to break root.  Security concerns can be
       split up into several categories:

             1.   Denial of Service attacks (DoS)

             2.   User account compromises

             3.   Root compromise through accessible servers

             4.   Root compromise via user accounts

             5.   Backdoor creation

       A denial of service attack is an action that deprives the machine of needed  resources.   Typically,  DoS
       attacks  are  brute-force  mechanisms  that  attempt  to  crash  or  otherwise make a machine unusable by
       overwhelming its servers or network stack.  Some DoS attacks try  to  take  advantages  of  bugs  in  the
       networking stack to crash a machine with a single packet.  The latter can only be fixed by applying a bug
       fix  to  the  kernel.   Attacks on servers can often be fixed by properly specifying options to limit the
       load the servers incur on the system under adverse conditions.  Brute-force network attacks are harder to
       deal with.  A spoofed-packet attack, for example, is nearly impossible to  stop  short  of  cutting  your
       system  off  from  the  Internet.   It may not be able to take your machine down, but it can fill up your
       Internet pipe.

       A user account compromise is even more common than a DoS  attack.   Many  sysadmins  still  run  standard
       <u><a href="../man8/telnetd.8.html">telnetd</a></u>(8)  and  <u><a href="../man8/ftpd.8.html">ftpd</a></u>(8)  servers  on  their  machines.   These  servers, by default, do not operate over
       encrypted connections.  The result is that if you have any moderate-sized user base, one or more of  your
       users logging into your system from a remote location (which is the most common and convenient way to log
       in  to  a system) will have his or her password sniffed.  The attentive system administrator will analyze
       his remote access logs looking for suspicious source addresses even for successful logins.

       One must always assume that once an attacker has access to a user account, the attacker can  break  root.
       However,  the  reality is that in a well secured and maintained system, access to a user account does not
       necessarily give the attacker access to root.  The distinction is important  because  without  access  to
       root the attacker cannot generally hide his tracks and may, at best, be able to do nothing more than mess
       with  the user's files or crash the machine.  User account compromises are very common because users tend
       not to take the precautions that sysadmins take.

       System administrators must keep in mind that there are potentially many ways to break root on a  machine.
       The  attacker may know the root password, the attacker may find a bug in a root-run server and be able to
       break root over a network connection to that server, or the attacker may know of a bug  in  an  SUID-root
       program  that allows the attacker to break root once he has broken into a user's account.  If an attacker
       has found a way to break root on a machine, the attacker may not have a need to install a backdoor.  Many
       of the root holes found and closed to date involve a considerable amount of work by the attacker to clean
       up after himself, so most attackers do install backdoors.  This gives you a convenient way to detect  the
       attacker.  Making it impossible for an attacker to install a backdoor may actually be detrimental to your
       security because it will not close off the hole the attacker used to break in originally.

       Security  remedies  should  always  be  implemented with a multi-layered “onion peel” approach and can be
       categorized as follows:

             1.   Securing root and staff accounts

             2.   Securing root — root-run servers and SUID/SGID binaries

             3.   Securing user accounts

             4.   Securing the password file

             5.   Securing the kernel core, raw devices, and file systems

             6.   Quick detection of inappropriate changes made to the system

             7.   Paranoia

</pre><h4><b>SECURING</b> <b>THE</b> <b>ROOT</b> <b>ACCOUNT</b> <b>AND</b> <b>SECURING</b> <b>STAFF</b> <b>ACCOUNTS</b></h4><pre>
       Do not bother securing staff accounts if you have not secured the root  account.   Most  systems  have  a
       password  assigned  to  the  root  account.  The first thing you do is assume that the password is <u>always</u>
       compromised.  This does not mean that you should remove the password.   The  password  is  almost  always
       necessary  for  console access to the machine.  What it does mean is that you should not make it possible
       to use the password outside of the console or possibly even with a <u><a href="../man1/su.1.html">su</a></u>(1) utility.  For example, make sure
       that your PTYs are specified as being “<b>insecure</b>” in the <u>/etc/ttys</u> file so that  direct  root  logins  via
       <u><a href="../man1/telnet.1.html">telnet</a></u>(1)  are  disallowed.   If  using  other login services such as <u><a href="../man8/sshd.8.html">sshd</a></u>(8), make sure that direct root
       logins are disabled there as well.  Consider every access method — services such  as  <u><a href="../man1/ftp.1.html">ftp</a></u>(1)  often  fall
       through the cracks.  Direct root logins should only be allowed via the system console.

       Of course, as a sysadmin you have to be able to get to root, so we open up a few holes.  But we make sure
       these  holes  require additional password verification to operate.  One way to make root accessible is to
       add appropriate staff accounts to the “<b>wheel</b>” group (in <u><a href="file:/etc/group">/etc/group</a></u>).  The staff  members  placed  in  the
       <b>wheel</b>  group  are  allowed  to <u><a href="../man1/su.1.html">su</a></u>(1) to root.  You should never give staff members native <b>wheel</b> access by
       putting them in the <b>wheel</b> group in their password entry.  Staff accounts should be placed  in  a  “<b>staff</b>”
       group,  and then added to the <b>wheel</b> group via the <u><a href="file:/etc/group">/etc/group</a></u> file.  Only those staff members who actually
       need to have root access should be placed in the <b>wheel</b>  group.   It  is  also  possible,  when  using  an
       authentication  method  such  as Kerberos, to use Kerberos's <u>.k5login</u> file in the root account to allow a
       <u><a href="../man1/ksu.1.html">ksu</a></u>(1) to root without having to place anyone at all in the <b>wheel</b> group.  This may be the better solution
       since the <b>wheel</b> mechanism still allows an intruder to break root if the intruder has gotten hold of  your
       password file and can break into a staff account.  While having the <b>wheel</b> mechanism is better than having
       nothing at all, it is not necessarily the safest option.

       An indirect way to secure the root account is to secure your staff accounts by using an alternative login
       access  method  and  *'ing  out the crypted password for the staff accounts.  This way an intruder may be
       able to steal the password file but will not be able to break into any staff accounts or  root,  even  if
       root has a crypted password associated with it (assuming, of course, that you have limited root access to
       the  console).   Staff  members  get  into  their staff accounts through a secure login mechanism such as
       <u><a href="../man8/kerberos.8.html">kerberos</a></u>(8) or <u><a href="../man1/ssh.1.html">ssh</a></u>(1) using a private/public  key  pair.   When  you  use  something  like  Kerberos  you
       generally must secure the machines which run the Kerberos servers and your desktop workstation.  When you
       use  a  public/private  key  pair with SSH, you must generally secure the machine you are logging in <u>from</u>
       (typically your workstation), but you can also add an additional layer of protection to the key  pair  by
       password protecting the keypair when you create it with <u><a href="../man1/ssh-keygen.1.html">ssh-keygen</a></u>(1).  Being able to *-out the passwords
       for  staff accounts also guarantees that staff members can only log in through secure access methods that
       you have set up.  You can thus force all staff members to use secure, encrypted connections for all their
       sessions which closes an important hole used by many intruders: that of  sniffing  the  network  from  an
       unrelated, less secure machine.

       The  more indirect security mechanisms also assume that you are logging in from a more restrictive server
       to a less restrictive server.  For example, if your main box  is  running  all  sorts  of  servers,  your
       workstation  should not be running any.  In order for your workstation to be reasonably secure you should
       run as few servers as possible, up to and including no servers at all, and you  should  run  a  password-
       protected  screen  blanker.  Of course, given physical access to a workstation, an attacker can break any
       sort of security you put on it.  This is definitely a problem that you should  consider  but  you  should
       also  consider  the  fact that the vast majority of break-ins occur remotely, over a network, from people
       who do not have physical access to your workstation or servers.

       Using something like Kerberos also gives you the ability to disable or change the password  for  a  staff
       account in one place and have it immediately affect all the machines the staff member may have an account
       on.   If  a  staff member's account gets compromised, the ability to instantly change his password on all
       machines should not be underrated.  With discrete passwords, changing a password on N machines can  be  a
       mess.   You  can also impose re-passwording restrictions with Kerberos: not only can a Kerberos ticket be
       made to timeout after a while, but the Kerberos system can require that the user choose  a  new  password
       after a certain period of time (say, once a month).

</pre><h4><b>SECURING</b> <b>ROOT</b> <b>—</b> <b>ROOT-RUN</b> <b>SERVERS</b> <b>AND</b> <b>SUID/SGID</b> <b>BINARIES</b></h4><pre>
       The  prudent  sysadmin  only  runs  the servers he needs to, no more, no less.  Be aware that third party
       servers are often the most bug-prone.  For example, running an  old  version  of  <u><a href="../man8/imapd.8.html">imapd</a></u>(8)  or  <u><a href="../man8/popper.8.html">popper</a></u>(8)
       (<u>ports/mail/popper</u>)  is  like giving a universal root ticket out to the entire world.  Never run a server
       that you have not checked out carefully.  Many servers do not need to be run as root.  For  example,  the
       <u><a href="../man8/talkd.8.html">talkd</a></u>(8),  <u><a href="../man8/comsat.8.html">comsat</a></u>(8),  and  <u><a href="../man8/fingerd.8.html">fingerd</a></u>(8)  daemons can be run in special user “sandboxes”.  A sandbox is not
       perfect unless you go to a large amount of trouble, but the onion approach to security still  stands:  if
       someone  is  able  to break in through a server running in a sandbox, they still have to break out of the
       sandbox.  The more layers the attacker must break through, the lower the likelihood of his success.  Root
       holes have historically been found in virtually every server ever run as  root,  including  basic  system
       servers.   If you are running a machine through which people only log in via <u><a href="../man8/sshd.8.html">sshd</a></u>(8) and never log in via
       <u><a href="../man8/telnetd.8.html">telnetd</a></u>(8) then turn off those services!

       FreeBSD now defaults to running <u><a href="../man8/talkd.8.html">talkd</a></u>(8), <u><a href="../man8/comsat.8.html">comsat</a></u>(8), and <u><a href="../man8/fingerd.8.html">fingerd</a></u>(8) in a sandbox.  Depending  on  whether
       you  are installing a new system or upgrading an existing system, the special user accounts used by these
       sandboxes may not be installed.  The prudent sysadmin would research and implement sandboxes for  servers
       whenever possible.

       There  are  a  number  of  other  servers that typically do not run in sandboxes: <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8), <u><a href="../man8/popper.8.html">popper</a></u>(8),
       <u><a href="../man8/imapd.8.html">imapd</a></u>(8), <u><a href="../man8/ftpd.8.html">ftpd</a></u>(8), and others.  There are alternatives to some of these, but installing them may  require
       more  work than you are willing to put (the convenience factor strikes again).  You may have to run these
       servers as root and rely on other mechanisms to detect break-ins that might occur through them.

       The other big potential root hole in a system are the  SUID-root  and  SGID  binaries  installed  on  the
       system.   Most  of  these  binaries, such as <u><a href="../man1/su.1.html">su</a></u>(1), reside in <u><a href="file:/bin">/bin</a></u>, <u><a href="file:/sbin">/sbin</a></u>, <u><a href="file:/usr/bin">/usr/bin</a></u>, or <u><a href="file:/usr/sbin">/usr/sbin</a></u>.  While
       nothing is 100% safe, the system-default SUID and  SGID  binaries  can  be  considered  reasonably  safe.
       Still,  root  holes are occasionally found in these binaries.  A root hole was found in Xlib in 1998 that
       made <u><a href="../man1/xterm.1.html">xterm</a></u>(1) (<u>ports/x11/xterm</u>) (which is typically SUID) vulnerable.  It is better to be safe than sorry
       and the prudent sysadmin will restrict SUID binaries that only staff should run to a special  group  that
       only staff can access, and get rid of (“<b>chmod</b> <b>000</b>”) any SUID binaries that nobody uses.  A server with no
       display  generally  does  not  need an <u><a href="../man1/xterm.1.html">xterm</a></u>(1) binary.  SGID binaries can be almost as dangerous.  If an
       intruder can break an SGID-kmem binary the intruder might be able to read <u>/dev/kmem</u>  and  thus  read  the
       crypted  password  file,  potentially compromising any passworded account.  Alternatively an intruder who
       breaks group “<b>kmem</b>” can monitor keystrokes sent through PTYs, including PTYs used by  users  who  log  in
       through  secure methods.  An intruder that breaks the “<b>tty</b>” group can write to almost any user's TTY.  If
       a user is running a terminal program or emulator with a keyboard-simulation  feature,  the  intruder  can
       potentially  generate  a data stream that causes the user's terminal to echo a command, which is then run
       as that user.

</pre><h4><b>SECURING</b> <b>USER</b> <b>ACCOUNTS</b></h4><pre>
       User accounts are usually  the  most  difficult  to  secure.   While  you  can  impose  draconian  access
       restrictions  on your staff and *-out their passwords, you may not be able to do so with any general user
       accounts you might have.  If you do have sufficient control then you may win out and be  able  to  secure
       the  user  accounts  properly.   If  not, you simply have to be more vigilant in your monitoring of those
       accounts.  Use of SSH and Kerberos for user accounts is more problematic due to the extra  administration
       and technical support required, but still a very good solution compared to a crypted password file.

</pre><h4><b>SECURING</b> <b>THE</b> <b>PASSWORD</b> <b>FILE</b></h4><pre>
       The  only  sure  fire  way is to *-out as many passwords as you can and use SSH or Kerberos for access to
       those accounts.  Even though the crypted password file (<u>/etc/spwd.db</u>) can only be read by root, it may be
       possible for an intruder to obtain read access to that file even if the attacker cannot obtain root-write
       access.

       Your security scripts should always check for and report changes to the password file (see “CHECKING FILE
       INTEGRITY” below).

</pre><h4><b>SECURING</b> <b>THE</b> <b>KERNEL</b> <b>CORE,</b> <b>RAW</b> <b>DEVICES,</b> <b>AND</b> <b>FILE</b> <b>SYSTEMS</b></h4><pre>
       If an attacker breaks root he can do just about  anything,  but  there  are  certain  conveniences.   For
       example,  most  modern kernels have a packet sniffing device driver built in.  Under FreeBSD it is called
       the <u><a href="../man4/bpf.4.html">bpf</a></u>(4) device.  An intruder will commonly attempt to run a packet sniffer on a  compromised  machine.
       You  do  not  need to give the intruder the capability and most systems should not have the <u><a href="../man4/bpf.4.html">bpf</a></u>(4) device
       compiled in.

       But even if you turn off the <u><a href="../man4/bpf.4.html">bpf</a></u>(4) device, you still have <u>/dev/mem</u> and <u>/dev/kmem</u> to  worry  about.   For
       that  matter,  the  intruder  can still write to raw disk devices.  Also, there is another kernel feature
       called the module loader, <u><a href="../man8/kldload.8.html">kldload</a></u>(8).  An enterprising intruder can use a KLD module to install  his  own
       <u><a href="../man4/bpf.4.html">bpf</a></u>(4)  device or other sniffing device on a running kernel.  To avoid these problems you have to run the
       kernel at a higher security level, at least level 1.  The security level can be set with a  <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)  on
       the  <u>kern.securelevel</u>  variable.   Once you have set the security level to 1, write access to raw devices
       will be denied and special <u><a href="../man1/chflags.1.html">chflags</a></u>(1) flags, such as <b>schg</b>, will be enforced.  You must also  ensure  that
       the  <b>schg</b>  flag is set on critical startup binaries, directories, and script files — everything that gets
       run up to the point where the security level is set.  This might  be  overdoing  it,  and  upgrading  the
       system  is  much  more difficult when you operate at a higher security level.  You may compromise and run
       the system at a higher security level but not set the <b>schg</b> flag for every system file and directory under
       the sun.  Another possibility is to simply mount <u>/</u> and <u><a href="file:/usr">/usr</a></u> read-only.  It should be noted that being too
       draconian in what you attempt to protect may prevent the all-important detection of an intrusion.

       The kernel runs with five different security levels.  Any super-user process can raise the level, but  no
       process can lower it.  The security levels are:

       <b>-1</b>    Permanently  insecure  mode  - always run the system in insecure mode.  This is the default initial
             value.

       <b>0</b>     Insecure mode - immutable and append-only flags may be turned off.  All  devices  may  be  read  or
             written subject to their permissions.

       <b>1</b>     Secure  mode  -  the system immutable and system append-only flags may not be turned off; disks for
             mounted file systems, <u>/dev/mem</u> and <u>/dev/kmem</u> may not  be  opened  for  writing;  <u>/dev/io</u>  (if  your
             platform  has  it)  may  not  be  opened  at  all; kernel modules (see <u><a href="../man4/kld.4.html">kld</a></u>(4)) may not be loaded or
             unloaded.  The kernel debugger may not be entered using the <u>debug.kdb.enter</u>  sysctl.   A  panic  or
             trap cannot be forced using the <u>debug.kdb.panic</u> and other sysctl's.

       <b>2</b>     Highly  secure  mode  -  same  as  secure mode, plus disks may not be opened for writing (except by
             <u><a href="../man2/mount.2.html">mount</a></u>(2)) whether mounted or not.  This level precludes tampering with file systems  by  unmounting
             them, but also inhibits running <u><a href="../man8/newfs.8.html">newfs</a></u>(8) while the system is multi-user.

             In  addition,  kernel time changes are restricted to less than or equal to one second.  Attempts to
             change the time by more than this will log the message “Time adjustment clamped to +1 second”.

       <b>3</b>     Network secure mode - same as highly secure  mode,  plus  IP  packet  filter  rules  (see  <u><a href="../man8/ipfw.8.html">ipfw</a></u>(8),
             <u><a href="../man4/ipfirewall.4.html">ipfirewall</a></u>(4)  and  <u><a href="../man8/pfctl.8.html">pfctl</a></u>(8))  cannot  be  changed and <u><a href="../man4/dummynet.4.html">dummynet</a></u>(4) or <u><a href="../man4/pf.4.html">pf</a></u>(4) configuration cannot be
             adjusted.

       The security level can be configured with variables documented in <u><a href="../man5/rc.conf.5.html">rc.conf</a></u>(5).

</pre><h4><b>CHECKING</b> <b>FILE</b> <b>INTEGRITY:</b> <b>BINARIES,</b> <b>CONFIG</b> <b>FILES,</b> <b>ETC</b></h4><pre>
       When it comes right down to it, you can only protect your core system configuration and control files  so
       much  before  the  convenience factor rears its ugly head.  For example, using <u><a href="../man1/chflags.1.html">chflags</a></u>(1) to set the <b>schg</b>
       bit on most of the files in <u>/</u> and <u><a href="file:/usr">/usr</a></u> is probably counterproductive because while  it  may  protect  the
       files,  it  also  closes  a  detection window.  The last layer of your security onion is perhaps the most
       important — detection.  The rest of your security is pretty much useless (or, worse, presents you with  a
       false  sense  of safety) if you cannot detect potential incursions.  Half the job of the onion is to slow
       down the attacker rather than stop him in order to give the detection layer a chance to catch him in  the
       act.

       The  best way to detect an incursion is to look for modified, missing, or unexpected files.  The best way
       to look for modified files is from another  (often  centralized)  limited-access  system.   Writing  your
       security  scripts  on  the  extra-secure  limited-access  system makes them mostly invisible to potential
       attackers, and this is important.  In order to take maximum advantage you  generally  have  to  give  the
       limited-access  box  significant  access to the other machines in the business, usually either by doing a
       read-only NFS export of the other machines to the limited-access box, or by setting up  SSH  keypairs  to
       allow  the  limit-access  box  to  SSH to the other machines.  Except for its network traffic, NFS is the
       least visible method — allowing you to monitor the file systems on each client box virtually  undetected.
       If  your limited-access server is connected to the client boxes through a switch, the NFS method is often
       the better choice.  If your limited-access server is connected to the  client  boxes  through  a  hub  or
       through several layers of routing, the NFS method may be too insecure (network-wise) and using SSH may be
       the better choice even with the audit-trail tracks that SSH lays.

       Once  you  give  a limit-access box at least read access to the client systems it is supposed to monitor,
       you must write scripts to do the actual monitoring.  Given an NFS mount, you can  write  scripts  out  of
       simple system utilities such as <u><a href="../man1/find.1.html">find</a></u>(1) and <u><a href="../man1/md5.1.html">md5</a></u>(1).  It is best to physically <u><a href="../man1/md5.1.html">md5</a></u>(1) the client-box files
       boxes  at least once a day, and to test control files such as those found in <u><a href="file:/etc">/etc</a></u> and <u><a href="file:/usr/local/etc">/usr/local/etc</a></u> even
       more often.  When mismatches are found relative to the base MD5 information  the  limited-access  machine
       knows  is  valid,  it  should  scream at a sysadmin to go check it out.  A good security script will also
       check for inappropriate SUID binaries and for new or deleted files on system partitions  such  as  <u>/</u>  and
       <u><a href="file:/usr">/usr</a></u>.

       When using SSH rather than NFS, writing the security script is much more difficult.  You essentially have
       to  <u><a href="../man1/scp.1.html">scp</a></u>(1)  the  scripts  to the client box in order to run them, making them visible, and for safety you
       also need to <u><a href="../man1/scp.1.html">scp</a></u>(1) the binaries (such as <u><a href="../man1/find.1.html">find</a></u>(1)) that those scripts use.  The  <u><a href="../man8/sshd.8.html">sshd</a></u>(8)  daemon  on  the
       client box may already be compromised.  All in all, using SSH may be necessary when running over unsecure
       links, but it is also a lot harder to deal with.

       A  good security script will also check for changes to user and staff members access configuration files:
       <u>.rhosts</u>, <u>.shosts</u>, <u>.ssh/authorized_keys</u> and so forth, files that might fall outside the purview of the MD5
       check.

       If you have a huge amount of user disk space it may take too long to run  through  every  file  on  those
       partitions.   In  this  case, setting mount flags to disallow SUID binaries on those partitions is a good
       idea.  The <b>nosuid</b> option (see <u><a href="../man8/mount.8.html">mount</a></u>(8)) is what you want to look into.  I would scan them anyway at least
       once a week, since the object of this layer is to detect a  break-in  whether  or  not  the  break-in  is
       effective.

       Process  accounting  (see <u><a href="../man8/accton.8.html">accton</a></u>(8)) is a relatively low-overhead feature of the operating system which I
       recommend using as a post-break-in evaluation mechanism.  It is especially useful in tracking down how an
       intruder has actually broken into a system, assuming the file is still intact after the break-in occurs.

       Finally, security scripts should process the log files and the logs themselves should be generated in  as
       secure  a  manner as possible — remote syslog can be very useful.  An intruder tries to cover his tracks,
       and log files are critical to the sysadmin trying to track down the time and method of the initial break-
       in.  One way to keep a permanent record of the log files is to run the system console to  a  serial  port
       and collect the information on a continuing basis through a secure machine monitoring the consoles.

</pre><h4><b>PARANOIA</b></h4><pre>
       A  little paranoia never hurts.  As a rule, a sysadmin can add any number of security features as long as
       they do not affect convenience, and can add security features that do affect convenience with some  added
       thought.   Even  more  importantly,  a  security  administrator  should  mix  it  up  a  bit — if you use
       recommendations such as those given by this manual page verbatim, you give away your methodologies to the
       prospective attacker who also has access to this manual page.

</pre><h4><b>SPECIAL</b> <b>SECTION</b> <b>ON</b> <b>DoS</b> <b>ATTACKS</b></h4><pre>
       This section covers Denial of Service attacks.  A DoS attack is typically a packet attack.   While  there
       is  not much you can do about modern spoofed packet attacks that saturate your network, you can generally
       limit the damage by ensuring that the attacks cannot take down your servers.

             1.   Limiting server forks

             2.   Limiting springboard attacks (ICMP response attacks, ping broadcast, etc.)

             3.   Kernel Route Cache

       A common DoS attack is against a forking server that attempts to cause the server to eat processes,  file
       descriptors,  and  memory  until the machine dies.  The <u><a href="../man8/inetd.8.html">inetd</a></u>(8) server has several options to limit this
       sort of attack.  It should be noted that while it is possible to prevent a machine from going down it  is
       not generally possible to prevent a service from being disrupted by the attack.  Read the <u><a href="../man8/inetd.8.html">inetd</a></u>(8) manual
       page  carefully  and  pay specific attention to the <b>-c</b>, <b>-C</b>, and <b>-R</b> options.  Note that spoofed-IP attacks
       will circumvent the <b>-C</b> option to <u><a href="../man8/inetd.8.html">inetd</a></u>(8), so typically a combination of  options  must  be  used.   Some
       standalone servers have self-fork-limitation parameters.

       The  <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8) daemon has its <b>-OMaxDaemonChildren</b> option which tends to work much better than trying to
       use <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8)'s load limiting options due to the load lag.   You  should  specify  a  <u>MaxDaemonChildren</u>
       parameter  when  you  start <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8) high enough to handle your expected load but not so high that the
       computer cannot handle that number of <b>sendmail</b>'s without falling on its face.  It is also prudent to  run
       <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8) in “queued” mode (<b>-ODeliveryMode=queued</b>) and to run the daemon (“<b>sendmail</b> <b>-bd</b>”) separate from
       the  queue-runs (“<b>sendmail</b> <b>-q15m</b>”).  If you still want real-time delivery you can run the queue at a much
       lower interval, such as <b>-q1m</b>, but be sure to specify  a  reasonable  <u>MaxDaemonChildren</u>  option  for  that
       <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8) to prevent cascade failures.

       The  <u><a href="../man8/syslogd.8.html">syslogd</a></u>(8) daemon can be attacked directly and it is strongly recommended that you use the <b>-s</b> option
       whenever possible, and the <b>-a</b> option otherwise.

       You should also be fairly careful with connect-back services such as tcpwrapper's  reverse-identd,  which
       can  be attacked directly.  You generally do not want to use the reverse-ident feature of tcpwrappers for
       this reason.

       It is a very good idea to protect internal services from external access by firewalling them off at  your
       border  routers.   The  idea  here is to prevent saturation attacks from outside your LAN, not so much to
       protect internal services from network-based root compromise.  Always configure  an  exclusive  firewall,
       i.e.,  ‘firewall everything <u>except</u> ports A, B, C, D, and M-Z’.  This way you can firewall off all of your
       low ports except for certain specific  services  such  as  <u><a href="../man8/talkd.8.html">talkd</a></u>(8),  <u><a href="../man8/sendmail.8.html">sendmail</a></u>(8),  and  other  internet-
       accessible  services.  If you try to configure the firewall the other way — as an inclusive or permissive
       firewall, there is a good chance that you will forget to “close” a couple of services or  that  you  will
       add  a  new  internal service and forget to update the firewall.  You can still open up the high-numbered
       port range on the firewall to allow permissive-like operation without compromising your low ports.   Also
       take  note  that FreeBSD allows you to control the range of port numbers used for dynamic binding via the
       various  <u>net.inet.ip.portrange</u>  sysctl's  (“<b>sysctl</b>  <b>net.inet.ip.portrange</b>”),  which  can  also  ease  the
       complexity  of  your  firewall's configuration.  I usually use a normal first/last range of 4000 to 5000,
       and a hiport range of 49152 to 65535, then block everything under 4000 off in  my  firewall  (except  for
       certain specific internet-accessible ports, of course).

       Another common DoS attack is called a springboard attack — to attack a server in a manner that causes the
       server  to  generate  responses which then overload the server, the local network, or some other machine.
       The most common attack of this nature is the ICMP  PING  BROADCAST  attack.   The  attacker  spoofs  ping
       packets  sent  to  your LAN's broadcast address with the source IP address set to the actual machine they
       wish to attack.  If your border routers are not configured to stomp on  ping's  to  broadcast  addresses,
       your  LAN  winds up generating sufficient responses to the spoofed source address to saturate the victim,
       especially when the attacker uses the same trick on several dozen broadcast addresses over several  dozen
       different  networks at once.  Broadcast attacks of over a hundred and twenty megabits have been measured.
       A second common springboard attack is against the ICMP error reporting system.  By  constructing  packets
       that  generate  ICMP  error responses, an attacker can saturate a server's incoming network and cause the
       server to saturate its outgoing network with ICMP responses.  This type of  attack  can  also  crash  the
       server by running it out of <u>mbuf</u>'s, especially if the server cannot drain the ICMP responses it generates
       fast  enough.   The  FreeBSD  kernel has a new kernel compile option called ICMP_BANDLIM which limits the
       effectiveness of these sorts of attacks.  The last major class  of  springboard  attacks  is  related  to
       certain  internal <u><a href="../man8/inetd.8.html">inetd</a></u>(8) services such as the UDP echo service.  An attacker simply spoofs a UDP packet
       with the source address being server A's echo port, and the destination address  being  server  B's  echo
       port,  where  server  A and B are both on your LAN.  The two servers then bounce this one packet back and
       forth between each other.  The attacker can overload both servers and their LANs simply  by  injecting  a
       few packets in this manner.  Similar problems exist with the internal chargen port.  A competent sysadmin
       will turn off all of these <u><a href="../man8/inetd.8.html">inetd</a></u>(8)-internal test services.

</pre><h4><b>ACCESS</b> <b>ISSUES</b> <b>WITH</b> <b>KERBEROS</b> <b>AND</b> <b>SSH</b></h4><pre>
       There  are  a  few issues with both Kerberos and SSH that need to be addressed if you intend to use them.
       Kerberos5 is an excellent authentication protocol but the kerberized <u><a href="../man1/telnet.1.html">telnet</a></u>(1)  suck  rocks.   There  are
       bugs  that  make  them  unsuitable  for  dealing with binary streams.  Also, by default Kerberos does not
       encrypt a session unless you use the <b>-x</b> option.  SSH encrypts everything by default.

       SSH works quite well in every respect except when it is set up to forward  encryption  keys.   What  this
       means  is  that  if  you  have  a secure workstation holding keys that give you access to the rest of the
       system, and you <u><a href="../man1/ssh.1.html">ssh</a></u>(1) to an unsecure machine, your keys become exposed.  The actual keys themselves  are
       not  exposed, but <u><a href="../man1/ssh.1.html">ssh</a></u>(1) installs a forwarding port for the duration of your login and if an attacker has
       broken root on the unsecure machine he can utilize that port to use your keys to gain access to any other
       machine that your keys unlock.

       We recommend that you use SSH in combination with Kerberos whenever possible for staff logins.   SSH  can
       be compiled with Kerberos support.  This reduces your reliance on potentially exposable SSH keys while at
       the  same  time protecting passwords via Kerberos.  SSH keys should only be used for automated tasks from
       secure machines (something that Kerberos is unsuited to).  We also recommend that  you  either  turn  off
       key-forwarding  in  the  SSH  configuration,  or  that you make use of the <u>from</u>=<u>IP/DOMAIN</u> option that SSH
       allows in its <u>authorized_keys</u> file to make the key only usable  to  entities  logging  in  from  specific
       machines.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/chflags.1.html">chflags</a></u>(1),  <u><a href="../man1/find.1.html">find</a></u>(1),  <u><a href="../man1/md5.1.html">md5</a></u>(1), <u><a href="../man1/netstat.1.html">netstat</a></u>(1), <u><a href="../man1/openssl.1.html">openssl</a></u>(1), <u><a href="../man1/ssh.1.html">ssh</a></u>(1), <u><a href="../man1/xdm.1.html">xdm</a></u>(1) (<u>ports/x11/xorg-clients</u>), <u><a href="../man5/group.5.html">group</a></u>(5),
       <u><a href="../man5/ttys.5.html">ttys</a></u>(5), <u><a href="../man8/accton.8.html">accton</a></u>(8), <u><a href="../man8/init.8.html">init</a></u>(8), <u><a href="../man8/sshd.8.html">sshd</a></u>(8), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8), <u><a href="../man8/syslogd.8.html">syslogd</a></u>(8), <u><a href="../man8/vipw.8.html">vipw</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>security</b> manual page was originally written by Matthew Dillon and  first  appeared  in  FreeBSD  3.1,
       December 1998.

Debian                                           August 13, 2019                                     <u><a href="../man7/SECURITY.7.html">SECURITY</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>