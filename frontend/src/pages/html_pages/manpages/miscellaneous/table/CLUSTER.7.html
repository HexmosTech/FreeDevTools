<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLUSTER - cluster a table according to an index</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/postgresql-client-17">postgresql-client-17_17.5-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CLUSTER - cluster a table according to an index

</pre><h4><b>SYNOPSIS</b></h4><pre>
       CLUSTER [ ( <u>option</u> [, ...] ) ] [ <u>table_name</u> [ USING <u>index_name</u> ] ]

       where <u>option</u> can be one of:

           VERBOSE [ <u>boolean</u> ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>CLUSTER</b> instructs PostgreSQL to cluster the table specified by <u>table_name</u> based on the index specified by
       <u>index_name</u>. The index must already have been defined on <u>table_name</u>.

       When a table is clustered, it is physically reordered based on the index information. Clustering is a
       one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no
       attempt is made to store new or updated rows according to their index order. (If one wishes, one can
       periodically recluster by issuing the command again. Also, setting the table's fillfactor storage
       parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are
       kept on the same page if enough space is available there.)

       When a table is clustered, PostgreSQL remembers which index it was clustered by. The form <b>CLUSTER</b>
       <u>table_name</u> reclusters the table using the same index as before. You can also use the CLUSTER or SET
       WITHOUT CLUSTER forms of <b>ALTER</b> <b>TABLE</b> to set the index to be used for future cluster operations, or to
       clear any previous setting.

       <b>CLUSTER</b> without a <u>table_name</u> reclusters all the previously-clustered tables in the current database that
       the calling user has privileges for. This form of <b>CLUSTER</b> cannot be executed inside a transaction block.

       When a table is being clustered, an ACCESS EXCLUSIVE lock is acquired on it. This prevents any other
       database operations (both reads and writes) from operating on the table until the <b>CLUSTER</b> is finished.

</pre><h4><b>PARAMETERS</b></h4><pre>
       <u>table_name</u>
           The name (possibly schema-qualified) of a table.

       <u>index_name</u>
           The name of an index.

       VERBOSE
           Prints a progress report as each table is clustered.

       <u>boolean</u>
           Specifies whether the selected option should be turned on or off. You can write TRUE, ON, or 1 to
           enable the option, and FALSE, OFF, or 0 to disable it. The <u>boolean</u> value can also be omitted, in
           which case TRUE is assumed.

</pre><h4><b>NOTES</b></h4><pre>
       To cluster a table, one must have the MAINTAIN privilege on the table.

       In cases where you are accessing single rows randomly within a table, the actual order of the data in the
       table is unimportant. However, if you tend to access some data more than others, and there is an index
       that groups them together, you will benefit from using <b>CLUSTER</b>. If you are requesting a range of indexed
       values from a table, or a single indexed value that has multiple rows that match, <b>CLUSTER</b> will help
       because once the index identifies the table page for the first row that matches, all other rows that
       match are probably already on the same table page, and so you save disk accesses and speed up the query.

       <b>CLUSTER</b> can re-sort the table using either an index scan on the specified index, or (if the index is a
       b-tree) a sequential scan followed by sorting. It will attempt to choose the method that will be faster,
       based on planner cost parameters and available statistical information.

       While <b>CLUSTER</b> is running, the search_path is temporarily changed to pg_catalog, pg_temp.

       When an index scan is used, a temporary copy of the table is created that contains the table data in the
       index order. Temporary copies of each index on the table are created as well. Therefore, you need free
       space on disk at least equal to the sum of the table size and the index sizes.

       When a sequential scan and sort is used, a temporary sort file is also created, so that the peak
       temporary space requirement is as much as double the table size, plus the index sizes. This method is
       often faster than the index scan method, but if the disk space requirement is intolerable, you can
       disable this choice by temporarily setting enable_sort to off.

       It is advisable to set maintenance_work_mem to a reasonably large value (but not more than the amount of
       RAM you can dedicate to the <b>CLUSTER</b> operation) before clustering.

       Because the planner records statistics about the ordering of tables, it is advisable to run <b>ANALYZE</b> on
       the newly clustered table. Otherwise, the planner might make poor choices of query plans.

       Because <b>CLUSTER</b> remembers which indexes are clustered, one can cluster the tables one wants clustered
       manually the first time, then set up a periodic maintenance script that executes <b>CLUSTER</b> without any
       parameters, so that the desired tables are periodically reclustered.

       Each backend running <b>CLUSTER</b> will report its progress in the pg_stat_progress_cluster view. See
       Section 27.4.2 for details.

       Clustering a partitioned table clusters each of its partitions using the partition of the specified
       partitioned index. When clustering a partitioned table, the index may not be omitted.  <b>CLUSTER</b> on a
       partitioned table cannot be executed inside a transaction block.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Cluster the table employees on the basis of its index employees_ind:

           CLUSTER employees USING employees_ind;

       Cluster the employees table using the same index that was used before:

           CLUSTER employees;

       Cluster all tables in the database that have previously been clustered:

           CLUSTER;

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       There is no <b>CLUSTER</b> statement in the SQL standard.

       The following syntax was used before PostgreSQL 17 and is still supported:

           CLUSTER [ VERBOSE ] [ <u>table_name</u> [ USING <u>index_name</u> ] ]

       The following syntax was used before PostgreSQL 8.3 and is still supported:

           CLUSTER <u>index_name</u> ON <u>table_name</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/clusterdb.1.html">clusterdb</a></b>(1), Section 27.4.2

PostgreSQL 17.5                                       2025                                            <u><a href="../man7/CLUSTER.7.html">CLUSTER</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>