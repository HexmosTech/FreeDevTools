<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rheostream - i/o utilities (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rheostream - i/o utilities (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Here, utilities for stream input and output are suitable are reviewed. Two classes are provided, together
       with a set of useful functions.

</pre><h4><b>OUTPUT</b> <b>STREAM</b></h4><pre>
       The irheostream is suitable for a sequential memory envinement: for a distributed memory and parallel
       computation case, see the <b><a href="../man2/diststream.2.html">diststream</a>(2)</b> class. Indeed, the irheostream is used as a base class for the
       idiststream one.

       File decompresion is assumed using gzip and a recursive search in a directory list is provided for input.

           orheostream foo('NAME', 'suffix');

        is like

           ofstream foo('NAME.suffix').

        However, if NAME does not end with .suffix, then .suffix is automatically added. By default, compression
       is performed on the fly with gzip, adding an additional .gz suffix. The flush action is nicely handled in
       compression mode:

           foo.flush();

        This feature allows intermediate results to be available during long computations. The compression can
       be deactivated while opening a file by an optional argument:

           orheostream foo('NAME', 'suffix', io::nogz);

        An existing compressed file can be reopen in append mode: new results will be appended at the end of an
       existing file:

           orheostream foo('NAME', 'suffix', io::app);

</pre><h4><b>INPUT</b> <b>STREAM</b></h4><pre>
       Conversely,

           irheostream foo('NAME','suffix');

        is like

           ifstream foo('NAME.suffix').

        However, we look at a search path environment variable RHEOPATH in order to find NAME while suffix is
       assumed. Moreover, gzip compressed files, ending with the .gz suffix is assumed, and decompression is
       done.

</pre><h4><b>OPTIONS</b></h4><pre>
       The following code:

       irheostream is('results', 'data');

        will recursively look for a results[.data[.gz]] file in the rectory mentioned by the RHEOPATH
       environment variable.

       For instance, if you insert in our '.cshrc' something like:

           setenv RHEOPATH '.:/home/dupont:/usr/local/math/demo'

        the process will study the current directory ., then, if neither square.data.gz nor square.data exits,
       it scan all subdirectory of the current directory. Then, if file is not founded, it start recusively in
       /home/dupond and then in /usr/local/math/demo.

       File decompression is performed by using the gzip command, and data are pipe-lined directly in memory.

       If the file start with . as ./square or with a / as /home/oscar/square, no search occurs and RHEOPATH
       environment variable is not used.

       Also, if the environment variable RHEOPATH is not set, the default value is the current directory ..

       For output stream:

           orheostream os('newresults', 'data');

        file compression is assumed, and 'newresults.data.gz' will be created.

       File loading and storing are mentioned by a message, either:

           ! load './results.data.gz'

        or:

           ! file './newresults.data.gz' created.

        on the clog stream. By adding the following:

           clog &lt;&lt; noverbose;

        you turn off these messages.

</pre><h4><b>USEFULL</b> <b>FUNCTIONS</b></h4><pre>
       // float-to-string conversion
       std::string ftos (const Float&amp; x);

       // catch first occurrence of string in file
       bool scatch (std::istream&amp; in, const std::string&amp; ch, bool full_match = true);

       // has_suffix("toto.suffix", "suffix") -&gt; true
       bool has_suffix (const std::string&amp; name, const std::string&amp; suffix);

       // "toto.suffix" --&gt; "toto"
       std::string delete_suffix (const std::string&amp; name, const std::string&amp; suffix);

       // has_any_suffix("toto.any_suffix") -&gt; true
       bool has_any_suffix (const std::string&amp; name);

       // delete_any_suffix("toto.any_suffix") --&gt; "toto"
       std::string delete_any_suffix (const std::string&amp; name);

       // "/usr/local/dir/toto.suffix" --&gt; "toto.suffix"
       std::string get_basename (const std::string&amp; name);

       // "/usr/local/dir/toto.suffix" --&gt; "/usr/local/dir"
       std::string get_dirname (const std::string&amp; name);

       // "toto" --&gt; "/usr/local/math/data/toto.suffix"
       std::string get_full_name_from_rheo_path (const std::string&amp; rootname, const std::string&amp; suffix);

       // "." + "../geodir" --&gt; ".:../geodir"
       void append_dir_to_rheo_path (const std::string&amp; dir);

       // "../geodir" + "." --&gt; "../geodir:."
       void prepend_dir_to_rheo_path (const std::string&amp; dir);

       // predicate when a file exists
       bool file_exists (const std::string&amp; filename);

       // is_float("3.14") -&gt; true
       bool is_float (const std::string&amp;);

       // string-to-float conversion
       Float to_float (const std::string&amp;);

       // in TMPDIR environment variable or "<a href="file:/tmp">/tmp</a>" by default
       std::string get_tmpdir();

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file util/lib/rheostream.h

       class irheostream : public boost::iostreams::filtering_stream&lt;boost::iostreams::input&gt; {
       public:
           irheostream() : boost::iostreams::filtering_stream&lt;boost::iostreams::input&gt;(), _ifs() {}
           irheostream(const std::string&amp; name, const std::string&amp; suffix = std::string());
           virtual ~irheostream();
           void open  (const std::string&amp; name, const std::string&amp; suffix = std::string());
           void close();

       };

       class orheostream : public boost::iostreams::filtering_stream&lt;boost::iostreams::output&gt; {
       public:
           orheostream() : boost::iostreams::filtering_stream&lt;boost::iostreams::output&gt;(), _mode(), _full_name() {}
           orheostream(const std::string&amp; name, const std::string&amp; suffix = std::string(),
               io::mode_type mode = io::out);
           virtual ~orheostream();
           void open  (const std::string&amp; name, const std::string&amp; suffix = std::string(),
               io::mode_type mode = io::out);
           void flush();
           void close();
           const std::string&amp; filename() const { return _full_name; }

       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                              <u><a href="../man7rheolef/rheostream.7rheolef.html">rheostream</a></u>(7rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>