<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sched - overview of CPU scheduling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sched - overview of CPU scheduling

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Since  Linux  2.6.23,  the  default scheduler is CFS, the "Completely Fair Scheduler".  The CFS scheduler
       replaced the earlier "<a href="../man1/O.1.html">O</a>(1)" scheduler.

   <b>API</b> <b>summary</b>
       Linux provides the following system calls for  controlling  the  CPU  scheduling  behavior,  policy,  and
       priority of processes (or, more precisely, threads).

       <b><a href="../man2/nice.2.html">nice</a></b>(2)
              Set a new nice value for the calling thread, and return the new nice value.

       <b><a href="../man2/getpriority.2.html">getpriority</a></b>(2)
              Return  the  nice  value  of a thread, a process group, or the set of threads owned by a specified
              user.

       <b><a href="../man2/setpriority.2.html">setpriority</a></b>(2)
              Set the nice value of a thread, a process group, or the set of threads owned by a specified user.

       <b><a href="../man2/sched_setscheduler.2.html">sched_setscheduler</a></b>(2)
              Set the scheduling policy and parameters of a specified thread.

       <b><a href="../man2/sched_getscheduler.2.html">sched_getscheduler</a></b>(2)
              Return the scheduling policy of a specified thread.

       <b><a href="../man2/sched_setparam.2.html">sched_setparam</a></b>(2)
              Set the scheduling parameters of a specified thread.

       <b><a href="../man2/sched_getparam.2.html">sched_getparam</a></b>(2)
              Fetch the scheduling parameters of a specified thread.

       <b><a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max</a></b>(2)
              Return the maximum priority available in a specified scheduling policy.

       <b><a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min</a></b>(2)
              Return the minimum priority available in a specified scheduling policy.

       <b><a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval</a></b>(2)
              Fetch the quantum used for threads that are scheduled under the "round-robin" scheduling policy.

       <b><a href="../man2/sched_yield.2.html">sched_yield</a></b>(2)
              Cause the caller to relinquish the CPU, so that some other thread be executed.

       <b><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></b>(2)
              (Linux-specific) Set the CPU affinity of a specified thread.

       <b><a href="../man2/sched_getaffinity.2.html">sched_getaffinity</a></b>(2)
              (Linux-specific) Get the CPU affinity of a specified thread.

       <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2)
              Set the scheduling policy and parameters of a specified thread.  This (Linux-specific) system call
              provides a superset of the functionality of <b><a href="../man2/sched_setscheduler.2.html">sched_setscheduler</a></b>(2) and <b><a href="../man2/sched_setparam.2.html">sched_setparam</a></b>(2).

       <b><a href="../man2/sched_getattr.2.html">sched_getattr</a></b>(2)
              Fetch the scheduling policy and parameters of a specified thread.   This  (Linux-specific)  system
              call provides a superset of the functionality of <b><a href="../man2/sched_getscheduler.2.html">sched_getscheduler</a></b>(2) and <b><a href="../man2/sched_getparam.2.html">sched_getparam</a></b>(2).

   <b>Scheduling</b> <b>policies</b>
       The  scheduler  is  the  kernel  component that decides which runnable thread will be executed by the CPU
       next.  Each thread has an associated scheduling policy and a <u>static</u> scheduling priority,  <u>sched_priority</u>.
       The  scheduler makes its decisions based on knowledge of the scheduling policy and static priority of all
       threads on the system.

       For threads scheduled under one of the normal scheduling policies (<b>SCHED_OTHER</b>, <b>SCHED_IDLE</b>, <b>SCHED_BATCH</b>),
       <u>sched_priority</u> is not used in scheduling decisions (it must be specified as 0).

       Processes scheduled under one of the real-time policies  (<b>SCHED_FIFO</b>,  <b>SCHED_RR</b>)  have  a  <u>sched_priority</u>
       value  in  the  range  1 (low) to 99 (high).  (As the numbers imply, real-time threads always have higher
       priority than normal threads.)  Note well: POSIX.1 requires an implementation to support only  a  minimum
       32  distinct  priority  levels  for  the  real-time  policies, and some systems supply just this minimum.
       Portable programs should use <b><a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min</a></b>(2) and <b><a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max</a></b>(2) to find the range of
       priorities supported for a particular policy.

       Conceptually, the scheduler maintains a list of runnable threads for each possible <u>sched_priority</u>  value.
       In  order to determine which thread runs next, the scheduler looks for the nonempty list with the highest
       static priority and selects the thread at the head of this list.

       A thread's scheduling policy determines where it will be inserted into the list  of  threads  with  equal
       static priority and how it will move inside this list.

       All  scheduling  is  preemptive:  if  a  thread  with  a higher static priority becomes ready to run, the
       currently running thread will be preempted and returned to the wait list for its static  priority  level.
       The  scheduling policy determines the ordering only within the list of runnable threads with equal static
       priority.

   <b>SCHED_FIFO:</b> <b>First</b> <b>in-first</b> <b>out</b> <b>scheduling</b>
       <b>SCHED_FIFO</b> can be used only with static priorities higher than 0, which  means  that  when  a  <b>SCHED_FIFO</b>
       thread  becomes  runnable,  it  will  always  immediately  preempt  any  currently  running  <b>SCHED_OTHER</b>,
       <b>SCHED_BATCH</b>, or <b>SCHED_IDLE</b> thread.  <b>SCHED_FIFO</b> is a simple scheduling  algorithm  without  time  slicing.
       For threads scheduled under the <b>SCHED_FIFO</b> policy, the following rules apply:

       •  A  running <b>SCHED_FIFO</b> thread that has been preempted by another thread of higher priority will stay at
          the head of the list for its priority and will resume execution as  soon  as  all  threads  of  higher
          priority are blocked again.

       •  When  a blocked <b>SCHED_FIFO</b> thread becomes runnable, it will be inserted at the end of the list for its
          priority.

       •  If a call to <b><a href="../man2/sched_setscheduler.2.html">sched_setscheduler</a></b>(2), <b><a href="../man2/sched_setparam.2.html">sched_setparam</a></b>(2), <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2), <b><a href="../man3/pthread_setschedparam.3.html">pthread_setschedparam</a></b>(3),  or
          <b><a href="../man3/pthread_setschedprio.3.html">pthread_setschedprio</a></b>(3)  changes  the priority of the running or runnable <b>SCHED_FIFO</b> thread identified
          by <u>pid</u> the effect on the thread's position in the list depends on the direction of the change  to  the
          thread's priority:

          (a)  If the thread's priority is raised, it is placed at the end of the list for its new priority.  As
               a consequence, it may preempt a currently running thread with the same priority.

          (b)  If the thread's priority is unchanged, its position in the run list is unchanged.

          (c)  If the thread's priority is lowered, it is placed at the front of the list for its new priority.

          According  to  POSIX.1-2008, changes to a thread's priority (or policy) using any mechanism other than
          <b><a href="../man3/pthread_setschedprio.3.html">pthread_setschedprio</a></b>(3) should result in the thread being placed at  the  end  of  the  list  for  its
          priority.

       •  A thread calling <b><a href="../man2/sched_yield.2.html">sched_yield</a></b>(2) will be put at the end of the list.

       No  other  events  will  move a thread scheduled under the <b>SCHED_FIFO</b> policy in the wait list of runnable
       threads with equal static priority.

       A <b>SCHED_FIFO</b> thread runs until either it is blocked by an I/O  request,  it  is  preempted  by  a  higher
       priority thread, or it calls <b><a href="../man2/sched_yield.2.html">sched_yield</a></b>(2).

   <b>SCHED_RR:</b> <b>Round-robin</b> <b>scheduling</b>
       <b>SCHED_RR</b>  is  a simple enhancement of <b>SCHED_FIFO</b>.  Everything described above for <b>SCHED_FIFO</b> also applies
       to <b>SCHED_RR</b>, except that each thread is allowed to run only for a maximum time quantum.   If  a  <b>SCHED_RR</b>
       thread has been running for a time period equal to or longer than the time quantum, it will be put at the
       end  of the list for its priority.  A <b>SCHED_RR</b> thread that has been preempted by a higher priority thread
       and subsequently resumes execution as a running thread will complete the unexpired portion of its  round-
       robin time quantum.  The length of the time quantum can be retrieved using <b><a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval</a></b>(2).

   <b>SCHED_DEADLINE:</b> <b>Sporadic</b> <b>task</b> <b>model</b> <b>deadline</b> <b>scheduling</b>
       Since Linux 3.14, Linux provides a deadline scheduling policy (<b>SCHED_DEADLINE</b>).  This policy is currently
       implemented  using  GEDF  (Global  Earliest  Deadline  First) in conjunction with CBS (Constant Bandwidth
       Server).  To set and fetch this policy  and  associated  attributes,  one  must  use  the  Linux-specific
       <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2) and <b><a href="../man2/sched_getattr.2.html">sched_getattr</a></b>(2) system calls.

       A  sporadic task is one that has a sequence of jobs, where each job is activated at most once per period.
       Each job also has a <u>relative</u> <u>deadline</u>, before which it should finish execution, and a  <u>computation</u>  <u>time</u>,
       which is the CPU time necessary for executing the job.  The moment when a task wakes up because a new job
       has  to  be  executed  is called the <u>arrival</u> <u>time</u> (also referred to as the request time or release time).
       The <u>start</u> <u>time</u> is the time at which a task starts its execution.  The <u>absolute</u> <u>deadline</u> is thus  obtained
       by adding the relative deadline to the arrival time.

       The following diagram clarifies these terms:

           arrival/wakeup                    absolute deadline
                |    start time                    |
                |        |                         |
                v        v                         v
           -----x--------xooooooooooooooooo--------x--------x---
                         |&lt;- comp. time -&gt;|
                |&lt;------- relative deadline ------&gt;|
                |&lt;-------------- period -------------------&gt;|

       When  setting  a  <b>SCHED_DEADLINE</b>  policy  for  a  thread  using  <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2),  one can specify three
       parameters: <u>Runtime</u>, <u>Deadline</u>, and <u>Period</u>.   These  parameters  do  not  necessarily  correspond  to  the
       aforementioned  terms:  usual practice is to set Runtime to something bigger than the average computation
       time (or worst-case execution time for hard real-time tasks), Deadline  to  the  relative  deadline,  and
       Period to the period of the task.  Thus, for <b>SCHED_DEADLINE</b> scheduling, we have:

           arrival/wakeup                    absolute deadline
                |    start time                    |
                |        |                         |
                v        v                         v
           -----x--------xooooooooooooooooo--------x--------x---
                         |&lt;-- Runtime -------&gt;|
                |&lt;----------- Deadline -----------&gt;|
                |&lt;-------------- Period -------------------&gt;|

       The   three   deadline-scheduling   parameters  correspond  to  the  <u>sched_runtime</u>,  <u>sched_deadline</u>,  and
       <u>sched_period</u> fields of the <u>sched_attr</u> structure; see <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2).  These fields  express  values  in
       nanoseconds.  If <u>sched_period</u> is specified as 0, then it is made the same as <u>sched_deadline</u>.

       The kernel requires that:

           sched_runtime &lt;= sched_deadline &lt;= sched_period

       In  addition,  under the current implementation, all of the parameter values must be at least 1024 (i.e.,
       just over one microsecond, which is the resolution of the implementation), and less than 2^63.  If any of
       these checks fails, <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2) fails with the error <b>EINVAL</b>.

       The CBS guarantees non-interference between tasks, by throttling threads that attempt to  over-run  their
       specified Runtime.

       To  ensure  deadline  scheduling  guarantees,  the  kernel  must  prevent  situations  where  the  set of
       <b>SCHED_DEADLINE</b> threads is not feasible (schedulable) within  the  given  constraints.   The  kernel  thus
       performs  an  admittance  test  when  setting  or  changing  <b>SCHED_DEADLINE</b>  policy and attributes.  This
       admission test calculates whether the change is feasible; if it is not, <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2) fails  with  the
       error <b>EBUSY</b>.

       For example, it is required (but not necessarily sufficient) for the total utilization to be less than or
       equal  to  the total number of CPUs available, where, since each thread can maximally run for Runtime per
       Period, that thread's utilization is its Runtime divided by its Period.

       In order to fulfill the guarantees that are made when a thread is admitted to the <b>SCHED_DEADLINE</b>  policy,
       <b>SCHED_DEADLINE</b>  threads  are  the  highest  priority  (user  controllable)  threads in the system; if any
       <b>SCHED_DEADLINE</b> thread is runnable, it will preempt any thread scheduled under one of the other policies.

       A call to <b><a href="../man2/fork.2.html">fork</a></b>(2) by a thread scheduled under the <b>SCHED_DEADLINE</b> policy  fails  with  the  error  <b>EAGAIN</b>,
       unless the thread has its reset-on-fork flag set (see below).

       A <b>SCHED_DEADLINE</b> thread that calls <b><a href="../man2/sched_yield.2.html">sched_yield</a></b>(2) will yield the current job and wait for a new period to
       begin.

   <b>SCHED_OTHER:</b> <b>Default</b> <b>Linux</b> <b>time-sharing</b> <b>scheduling</b>
       <b>SCHED_OTHER</b>  can  be  used  at only static priority 0 (i.e., threads under real-time policies always have
       priority over <b>SCHED_OTHER</b> processes).  <b>SCHED_OTHER</b> is the standard Linux time-sharing scheduler  that  is
       intended for all threads that do not require the special real-time mechanisms.

       The  thread  to  run  is  chosen  from  the  static  priority  0 list based on a <u>dynamic</u> priority that is
       determined only inside this list.  The dynamic priority is based on the nice value  (see  below)  and  is
       increased  for  each  time  quantum the thread is ready to run, but denied to run by the scheduler.  This
       ensures fair progress among all <b>SCHED_OTHER</b> threads.

       In the Linux kernel source code, the <b>SCHED_OTHER</b> policy is actually named <b>SCHED_NORMAL</b>.

   <b>The</b> <b>nice</b> <b>value</b>
       The nice value is an attribute that can be used to influence the CPU scheduler to  favor  or  disfavor  a
       process  in  scheduling  decisions.  It affects the scheduling of <b>SCHED_OTHER</b> and <b>SCHED_BATCH</b> (see below)
       processes.  The nice value can be modified using <b><a href="../man2/nice.2.html">nice</a></b>(2), <b><a href="../man2/setpriority.2.html">setpriority</a></b>(2), or <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2).

       According to POSIX.1, the nice value is a per-process attribute; that is, the threads in a process should
       share a nice value.  However, on Linux, the nice value is a per-thread attribute:  different  threads  in
       the same process may have different nice values.

       The  range  of  the  nice  value  varies  across  UNIX  systems.  On modern Linux, the range is -20 (high
       priority) to +19 (low priority).  On some other systems, the range is -20..20.  Very early Linux  kernels
       (before Linux 2.0) had the range -infinity..15.

       The  degree  to  which  the  nice value affects the relative scheduling of <b>SCHED_OTHER</b> processes likewise
       varies across UNIX systems and across Linux kernel versions.

       With the advent of the CFS scheduler in Linux 2.6.23, Linux adopted an  algorithm  that  causes  relative
       differences  in  nice values to have a much stronger effect.  In the current implementation, each unit of
       difference in the nice values of two processes results in a factor of 1.25 in the  degree  to  which  the
       scheduler  favors  the  higher priority process.  This causes very low nice values (+19) to truly provide
       little CPU to a process whenever there is any other higher priority load on the system,  and  makes  high
       nice  values  (-20)  deliver  most  of  the  CPU  to  applications  that  require  it  (e.g.,  some audio
       applications).

       On Linux, the <b>RLIMIT_NICE</b> resource limit can be used to define a limit to which an unprivileged process's
       nice value can be raised; see <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2) for details.

       For further details on the nice value, see the subsections on the autogroup feature and group scheduling,
       below.

   <b>SCHED_BATCH:</b> <b>Scheduling</b> <b>batch</b> <b>processes</b>
       (Since Linux 2.6.16.)  <b>SCHED_BATCH</b> can be used only at static priority 0.   This  policy  is  similar  to
       <b>SCHED_OTHER</b>  in that it schedules the thread according to its dynamic priority (based on the nice value).
       The difference is that this policy will cause the scheduler to always assume  that  the  thread  is  CPU-
       intensive.   Consequently,  the  scheduler  will  apply a small scheduling penalty with respect to wakeup
       behavior, so that this thread is mildly disfavored in scheduling decisions.

       This policy is useful for workloads that are noninteractive, but do not want to lower their  nice  value,
       and  for  workloads  that  want  a  deterministic  scheduling  policy without interactivity causing extra
       preemptions (between the workload's tasks).

   <b>SCHED_IDLE:</b> <b>Scheduling</b> <b>very</b> <b>low</b> <b>priority</b> <b>jobs</b>
       (Since Linux 2.6.23.)  <b>SCHED_IDLE</b> can be used only at static priority 0; the process nice  value  has  no
       influence for this policy.

       This policy is intended for running jobs at extremely low priority (lower even than a +19 nice value with
       the <b>SCHED_OTHER</b> or <b>SCHED_BATCH</b> policies).

   <b>Resetting</b> <b>scheduling</b> <b>policy</b> <b>for</b> <b>child</b> <b>processes</b>
       Each  thread  has a reset-on-fork scheduling flag.  When this flag is set, children created by <b><a href="../man2/fork.2.html">fork</a></b>(2) do
       not inherit privileged scheduling policies.  The reset-on-fork flag can be set by either:

       •  ORing the <b>SCHED_RESET_ON_FORK</b> flag into the <u>policy</u> argument when calling <b><a href="../man2/sched_setscheduler.2.html">sched_setscheduler</a></b>(2)  (since
          Linux 2.6.32); or

       •  specifying the <b>SCHED_FLAG_RESET_ON_FORK</b> flag in <u>attr.sched_flags</u> when calling <b><a href="../man2/sched_setattr.2.html">sched_setattr</a></b>(2).

       Note  that  the  constants used with these two APIs have different names.  The state of the reset-on-fork
       flag can analogously be retrieved using <b><a href="../man2/sched_getscheduler.2.html">sched_getscheduler</a></b>(2) and <b><a href="../man2/sched_getattr.2.html">sched_getattr</a></b>(2).

       The reset-on-fork feature is intended for  media-playback  applications,  and  can  be  used  to  prevent
       applications  evading  the  <b>RLIMIT_RTTIME</b>  resource  limit  (see <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2)) by creating multiple child
       processes.

       More precisely, if the reset-on-fork flag is set, the following  rules  apply  for  subsequently  created
       children:

       •  If  the  calling  thread  has  a  scheduling  policy of <b>SCHED_FIFO</b> or <b>SCHED_RR</b>, the policy is reset to
          <b>SCHED_OTHER</b> in child processes.

       •  If the calling process has a negative nice value, the nice value is reset to zero in child processes.

       After the reset-on-fork flag has been enabled, it can be reset only if the thread  has  the  <b>CAP_SYS_NICE</b>
       capability.  This flag is disabled in child processes created by <b><a href="../man2/fork.2.html">fork</a></b>(2).

   <b>Privileges</b> <b>and</b> <b>resource</b> <b>limits</b>
       Before  Linux 2.6.12, only privileged (<b>CAP_SYS_NICE</b>) threads can set a nonzero static priority (i.e., set
       a real-time scheduling policy).  The only change that an unprivileged thread  can  make  is  to  set  the
       <b>SCHED_OTHER</b>  policy, and this can be done only if the effective user ID of the caller matches the real or
       effective user ID of the target thread (i.e., the thread specified by <u>pid</u>) whose policy is being changed.

       A thread must be privileged (<b>CAP_SYS_NICE</b>) in order to set or modify a <b>SCHED_DEADLINE</b> policy.

       Since Linux 2.6.12, the <b>RLIMIT_RTPRIO</b> resource limit defines a ceiling on an unprivileged thread's static
       priority for the <b>SCHED_RR</b> and <b>SCHED_FIFO</b> policies.  The rules for changing scheduling policy and priority
       are as follows:

       •  If an unprivileged thread has a nonzero <b>RLIMIT_RTPRIO</b> soft limit, then it can  change  its  scheduling
          policy and priority, subject to the restriction that the priority cannot be set to a value higher than
          the maximum of its current priority and its <b>RLIMIT_RTPRIO</b> soft limit.

       •  If the <b>RLIMIT_RTPRIO</b> soft limit is 0, then the only permitted changes are to lower the priority, or to
          switch to a non-real-time policy.

       •  Subject  to  the  same  rules, another unprivileged thread can also make these changes, as long as the
          effective user ID of the thread making the change matches the real or effective user ID of the  target
          thread.

       •  Special  rules apply for the <b>SCHED_IDLE</b> policy.  Before Linux 2.6.39, an unprivileged thread operating
          under this policy cannot change its policy, regardless of the  value  of  its  <b>RLIMIT_RTPRIO</b>  resource
          limit.   Since  Linux  2.6.39,  an  unprivileged  thread  can  switch to either the <b>SCHED_BATCH</b> or the
          <b>SCHED_OTHER</b> policy so long as its nice value falls within  the  range  permitted  by  its  <b>RLIMIT_NICE</b>
          resource limit (see <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2)).

       Privileged  (<b>CAP_SYS_NICE</b>)  threads  ignore the <b>RLIMIT_RTPRIO</b> limit; as with older kernels, they can make
       arbitrary changes to scheduling policy  and  priority.   See  <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2)  for  further  information  on
       <b>RLIMIT_RTPRIO</b>.

   <b>Limiting</b> <b>the</b> <b>CPU</b> <b>usage</b> <b>of</b> <b>real-time</b> <b>and</b> <b>deadline</b> <b>processes</b>
       A  nonblocking  infinite  loop  in  a  thread scheduled under the <b>SCHED_FIFO</b>, <b>SCHED_RR</b>, or <b>SCHED_DEADLINE</b>
       policy can potentially block all other threads from accessing the CPU forever.  Before Linux 2.6.25,  the
       only way of preventing a runaway real-time process from freezing the system was to run (at the console) a
       shell  scheduled  under  a  higher static priority than the tested application.  This allows an emergency
       kill of tested real-time applications that do not block or terminate as expected.

       Since Linux 2.6.25, there are other techniques for dealing with runaway real-time and deadline processes.
       One of these is to use the <b>RLIMIT_RTTIME</b> resource limit to set a ceiling on the CPU time that a real-time
       process may consume.  See <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2) for details.

       Since Linux 2.6.25, Linux also provides two <u><a href="file:/proc">/proc</a></u> files that can be used to reserve a certain  amount  of
       CPU  time to be used by non-real-time processes.  Reserving CPU time in this fashion allows some CPU time
       to be allocated to (say) a root shell that can be used to kill a runaway process.  Both  of  these  files
       specify time values in microseconds:

       <u><a href="file:/proc/sys/kernel/sched_rt_period_us">/proc/sys/kernel/sched_rt_period_us</a></u>
              This  file  specifies  a scheduling period that is equivalent to 100% CPU bandwidth.  The value in
              this file can range from 1 to <b>INT_MAX</b>, giving an operating range of 1  microsecond  to  around  35
              minutes.  The default value in this file is 1,000,000 (1 second).

       <u><a href="file:/proc/sys/kernel/sched_rt_runtime_us">/proc/sys/kernel/sched_rt_runtime_us</a></u>
              The  value  in  this file specifies how much of the "period" time can be used by all real-time and
              deadline scheduled processes on the system.   The  value  in  this  file  can  range  from  -1  to
              <b>INT_MAX</b>-1.   Specifying  -1 makes the run time the same as the period; that is, no CPU time is set
              aside for non-real-time processes (which was the behavior before Linux 2.6.25).  The default value
              in this file is 950,000 (0.95 seconds), meaning that 5% of the CPU time is reserved for  processes
              that don't run under a real-time or deadline scheduling policy.

   <b>Response</b> <b>time</b>
       A  blocked high priority thread waiting for I/O has a certain response time before it is scheduled again.
       The device driver writer can greatly reduce this response time by  using  a  "slow  interrupt"  interrupt
       handler.

   <b>Miscellaneous</b>
       Child processes inherit the scheduling policy and parameters across a <b><a href="../man2/fork.2.html">fork</a></b>(2).  The scheduling policy and
       parameters are preserved across <b><a href="../man2/execve.2.html">execve</a></b>(2).

       Memory  locking  is  usually needed for real-time processes to avoid paging delays; this can be done with
       <b><a href="../man2/mlock.2.html">mlock</a></b>(2) or <b><a href="../man2/mlockall.2.html">mlockall</a></b>(2).

   <b>The</b> <b>autogroup</b> <b>feature</b>
       Since Linux 2.6.38, the kernel provides a feature known as autogrouping to  improve  interactive  desktop
       performance  in  the face of multiprocess, CPU-intensive workloads such as building the Linux kernel with
       large numbers of parallel build processes (i.e., the <b><a href="../man1/make.1.html">make</a></b>(1) <b>-j</b> flag).

       This feature operates in conjunction with the CFS scheduler and requires a kernel that is configured with
       <b>CONFIG_SCHED_AUTOGROUP</b>.  On a  running  system,  this  feature  is  enabled  or  disabled  via  the  file
       <u><a href="file:/proc/sys/kernel/sched_autogroup_enabled">/proc/sys/kernel/sched_autogroup_enabled</a></u>;  a  value of 0 disables the feature, while a value of 1 enables
       it.  The default value in this file is 1, unless the kernel was booted with the <u>noautogroup</u> parameter.

       A new autogroup is created when a new session is created via <b><a href="../man2/setsid.2.html">setsid</a></b>(2); this happens, for example, when a
       new terminal window is started.  A new  process  created  by  <b><a href="../man2/fork.2.html">fork</a></b>(2)  inherits  its  parent's  autogroup
       membership.   Thus, all of the processes in a session are members of the same autogroup.  An autogroup is
       automatically destroyed when the last process in the group terminates.

       When autogrouping is enabled, all of the members of an autogroup are placed in the same kernel  scheduler
       "task  group".   The  CFS  scheduler  employs  an algorithm that equalizes the distribution of CPU cycles
       across task groups.  The benefits of this for interactive desktop performance can be  described  via  the
       following example.

       Suppose  that  there  are  two  autogroups  competing for the same CPU (i.e., presume either a single CPU
       system or the use of <b><a href="../man1/taskset.1.html">taskset</a></b>(1) to confine all the processes to the same CPU  on  an  SMP  system).   The
       first  group  contains  ten  CPU-bound  processes  from a kernel build started with <u>make</u> <u>-j10</u>.  The other
       contains a single CPU-bound process: a video player.  The effect of autogrouping is that the  two  groups
       will  each receive half of the CPU cycles.  That is, the video player will receive 50% of the CPU cycles,
       rather than just 9% of the cycles, which would likely lead to degraded video playback.  The situation  on
       an  SMP  system is more complex, but the general effect is the same: the scheduler distributes CPU cycles
       across task groups such that an autogroup that contains a large number of CPU-bound  processes  does  not
       end up hogging CPU cycles at the expense of the other jobs on the system.

       A process's autogroup (task group) membership can be viewed via the file <u><a href="file:/proc/">/proc/</a></u>pid<u>/autogroup</u>:

           $ <b>cat</b> <b><a href="file:/proc/1/autogroup">/proc/1/autogroup</a></b>
           /autogroup-1 nice 0

       This  file  can  also  be  used  to  modify the CPU bandwidth allocated to an autogroup.  This is done by
       writing a number in the "nice" range to the file to set the autogroup's nice value.  The allowed range is
       from +19 (low priority) to -20 (high priority).  (Writing values outside of this range causes <b><a href="../man2/write.2.html">write</a></b>(2) to
       fail with the error <b>EINVAL</b>.)

       The autogroup nice setting has the same meaning as the process nice value, but applies to distribution of
       CPU cycles to the autogroup as a whole, based on the relative nice values of  other  autogroups.   For  a
       process  inside  an  autogroup, the CPU cycles that it receives will be a product of the autogroup's nice
       value (compared to other autogroups) and the process's nice value (compared to  other  processes  in  the
       same autogroup.

       The  use  of  the  <b><a href="../man7/cgroups.7.html">cgroups</a></b>(7) CPU controller to place processes in cgroups other than the root CPU cgroup
       overrides the effect of autogrouping.

       The autogroup  feature  groups  only  processes  scheduled  under  non-real-time  policies  (<b>SCHED_OTHER</b>,
       <b>SCHED_BATCH</b>,  and  <b>SCHED_IDLE</b>).   It  does  not  group  processes  scheduled under real-time and deadline
       policies.  Those processes are scheduled according to the rules described earlier.

   <b>The</b> <b>nice</b> <b>value</b> <b>and</b> <b>group</b> <b>scheduling</b>
       When scheduling non-real-time processes (i.e., those scheduled under the  <b>SCHED_OTHER</b>,  <b>SCHED_BATCH</b>,  and
       <b>SCHED_IDLE</b>  policies),  the  CFS scheduler employs a technique known as "group scheduling", if the kernel
       was configured with the <b>CONFIG_FAIR_GROUP_SCHED</b> option (which is typical).

       Under group scheduling, threads are  scheduled  in  "task  groups".   Task  groups  have  a  hierarchical
       relationship,  rooted  under  the initial task group on the system, known as the "root task group".  Task
       groups are formed in the following circumstances:

       •  All of the threads in a CPU cgroup form a task group.  The parent of this task group is the task group
          of the corresponding parent cgroup.

       •  If autogrouping is enabled, then all of the threads that  are  (implicitly)  placed  in  an  autogroup
          (i.e.,  the  same  session,  as created by <b><a href="../man2/setsid.2.html">setsid</a></b>(2)) form a task group.  Each new autogroup is thus a
          separate task group.  The root task group is the parent of all such autogroups.

       •  If autogrouping is enabled, then the root task group consists of all processes in the root CPU  cgroup
          that were not otherwise implicitly placed into a new autogroup.

       •  If  autogrouping  is  disabled,  then  the  root  task group consists of all processes in the root CPU
          cgroup.

       •  If group scheduling was disabled (i.e., the kernel was  configured  without  <b>CONFIG_FAIR_GROUP_SCHED</b>),
          then all of the processes on the system are notionally placed in a single task group.

       Under  group  scheduling,  a  thread's nice value has an effect for scheduling decisions <u>only</u> <u>relative</u> <u>to</u>
       <u>other</u> <u>threads</u> <u>in</u> <u>the</u> <u>same</u> <u>task</u> <u>group</u>.  This has some surprising consequences in terms of the  traditional
       semantics  of  the  nice  value on UNIX systems.  In particular, if autogrouping is enabled (which is the
       default in various distributions), then employing <b><a href="../man2/setpriority.2.html">setpriority</a></b>(2) or <b><a href="../man1/nice.1.html">nice</a></b>(1) on a process  has  an  effect
       only  for  scheduling  relative  to  other  processes  executed  in the same session (typically: the same
       terminal window).

       Conversely, for two processes that are (for example) the sole CPU-bound processes in  different  sessions
       (e.g.,  different  terminal  windows, each of whose jobs are tied to different autogroups), <u>modifying</u> <u>the</u>
       <u>nice</u> <u>value</u> <u>of</u> <u>the</u> <u>process</u> <u>in</u> <u>one</u> <u>of</u> <u>the</u> <u>sessions</u> <u>has</u> <u>no</u> <u>effect</u> in  terms  of  the  scheduler's  decisions
       relative to the process in the other session.  A possibly useful workaround here is to use a command such
       as the following to modify the autogroup nice value for <u>all</u> of the processes in a terminal session:

           $ <b>echo</b> <b>10</b> <b>&gt;</b> <b><a href="file:/proc/self/autogroup">/proc/self/autogroup</a></b>

   <b>Real-time</b> <b>features</b> <b>in</b> <b>the</b> <b>mainline</b> <b>Linux</b> <b>kernel</b>
       Since  Linux  2.6.18, Linux is gradually becoming equipped with real-time capabilities, most of which are
       derived from the former <u>realtime-preempt</u> patch set.  Until the patches have been completely  merged  into
       the mainline kernel, they must be installed to achieve the best real-time performance.  These patches are
       named:

           patch-<u>kernelversion</u>-rt<u>patchversion</u>

       and can be downloaded from <a href="http://www.kernel.org/pub/linux/kernel/projects/rt/">http://www.kernel.org/pub/linux/kernel/projects/rt/</a>.

       Without  the patches and prior to their full inclusion into the mainline kernel, the kernel configuration
       offers  only  the   three   preemption   classes   <b>CONFIG_PREEMPT_NONE</b>,   <b>CONFIG_PREEMPT_VOLUNTARY</b>,   and
       <b>CONFIG_PREEMPT_DESKTOP</b>  which respectively provide no, some, and considerable reduction of the worst-case
       scheduling latency.

       With the patches applied or  after  their  full  inclusion  into  the  mainline  kernel,  the  additional
       configuration item <b>CONFIG_PREEMPT_RT</b> becomes available.  If this is selected, Linux is transformed into a
       regular  real-time  operating  system.  The FIFO and RR scheduling policies are then used to run a thread
       with true real-time priority and a minimum worst-case scheduling latency.

</pre><h4><b>NOTES</b></h4><pre>
       The <b><a href="../man7/cgroups.7.html">cgroups</a></b>(7) CPU controller can be used to limit the CPU consumption of groups of processes.

       Originally, Standard Linux was intended as a  general-purpose  operating  system  being  able  to  handle
       background  processes,  interactive applications, and less demanding real-time applications (applications
       that need to usually meet timing deadlines).  Although the Linux 2.6 allowed for  kernel  preemption  and
       the  newly  introduced <a href="../man1/O.1.html">O</a>(1) scheduler ensures that the time needed to schedule is fixed and deterministic
       irrespective of the number of active tasks, true real-time computing was not possible up to Linux 2.6.17.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/chcpu.1.html">chcpu</a></b>(1), <b><a href="../man1/chrt.1.html">chrt</a></b>(1), <b><a href="../man1/lscpu.1.html">lscpu</a></b>(1), <b><a href="../man1/ps.1.html">ps</a></b>(1), <b><a href="../man1/taskset.1.html">taskset</a></b>(1), <b><a href="../man1/top.1.html">top</a></b>(1), <b><a href="../man2/getpriority.2.html">getpriority</a></b>(2), <b><a href="../man2/mlock.2.html">mlock</a></b>(2), <b><a href="../man2/mlockall.2.html">mlockall</a></b>(2),
       <b><a href="../man2/munlock.2.html">munlock</a></b>(2), <b><a href="../man2/munlockall.2.html">munlockall</a></b>(2), <b><a href="../man2/nice.2.html">nice</a></b>(2), <b><a href="../man2/sched_get_priority_max.2.html">sched_get_priority_max</a></b>(2), <b><a href="../man2/sched_get_priority_min.2.html">sched_get_priority_min</a></b>(2),
       <b><a href="../man2/sched_getaffinity.2.html">sched_getaffinity</a></b>(2), <b><a href="../man2/sched_getparam.2.html">sched_getparam</a></b>(2), <b><a href="../man2/sched_getscheduler.2.html">sched_getscheduler</a></b>(2), <b><a href="../man2/sched_rr_get_interval.2.html">sched_rr_get_interval</a></b>(2),
       <b><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></b>(2), <b><a href="../man2/sched_setparam.2.html">sched_setparam</a></b>(2), <b><a href="../man2/sched_setscheduler.2.html">sched_setscheduler</a></b>(2), <b><a href="../man2/sched_yield.2.html">sched_yield</a></b>(2), <b><a href="../man2/setpriority.2.html">setpriority</a></b>(2),
       <b><a href="../man3/pthread_getaffinity_np.3.html">pthread_getaffinity_np</a></b>(3), <b><a href="../man3/pthread_getschedparam.3.html">pthread_getschedparam</a></b>(3), <b><a href="../man3/pthread_setaffinity_np.3.html">pthread_setaffinity_np</a></b>(3), <b><a href="../man3/sched_getcpu.3.html">sched_getcpu</a></b>(3),
       <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7), <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7)

       <u>Programming</u> <u>for</u> <u>the</u> <u>real</u> <u>world</u> <u>-</u> <u>POSIX.4</u> by Bill  O.  Gallmeister,  O'Reilly  &amp;  Associates,  Inc.,  ISBN
       1-56592-074-0.

       The   Linux  kernel  source  files  <u>Documentation/scheduler/sched-deadline.txt</u>,  <u>Documentation/scheduler/</u>
       <u>sched-rt-group.txt</u>,    <u>Documentation/scheduler/sched-design-CFS.txt</u>,     and     <u>Documentation/scheduler/</u>
       <u>sched-nice-design.txt</u>

Linux man-pages 6.9.1                              2024-05-02                                           <u><a href="../man7/sched.7.html">sched</a></u>(7)
</pre>
 </div>
</div></section>
</div>
</body>
</html>