<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>request-key.conf - Instantiation handler configuration file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/keyutils">keyutils_1.6.3-6ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       request-key.conf - Instantiation handler configuration file

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  files  are  used  by  the  /sbin/request-key  program  to determine which program it should run to
       instantiate a key.

       request-key looks for the best match, reading all the following files:

                   /etc/request-key.d/*.conf
                   /etc/request-key.conf

       If it doesn't find a match, it will return an error and the kernel will automatically negate the key.

       The best match is defined as the line with the shortest wildcard skips, ranking the columns in order left
       to right.  If two lines have the same length skips, then the first read is the one taken.

       In the files, any blank line or line beginning with a hash mark '#' is considered to  be  a  comment  and
       ignored.

       All other lines are assumed to be command lines with a number of white space separated fields:

       &lt;op&gt; &lt;type&gt; &lt;description&gt; &lt;callout-info&gt; &lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...

       The  first  four  fields  are used to match the parameters passed to request-key by the kernel. <u>op</u> is the
       operation type; currently the only supported operation is "create".

       <u>type</u>, <u>description</u> and  <u>callout-info</u>  match  the  three  parameters  passed  to  <b>keyctl</b>  <b>request2</b>  or  the
       <b>request_key()</b>  system  call.  Each of these may contain one asterisk '*' character as a wildcard anywhere
       within the string.

       Should a match be made, the program specified by &lt;prog&gt; will be exec'd. This must have a fully  qualified
       path  name.  argv[0]  will  be  set  from  the  part  of the program name that follows the last slash '/'
       character.

       If the program name is prefixed with a pipe bar character '|', then the program will be forked and exec'd
       attached to three pipes. The callout information will be piped to it  on  it's  stdin  and  the  intended
       payload  data will be retrieved from its stdout. Anything sent to stderr will be posted in syslog. If the
       program exits 0, then /sbin/request-key will attempt to instantiate the  key  with  the  data  read  from
       stdout.  If  it fails in any other way, then request-key will attempt to execute the appropriate 'negate'
       operation command.

       The program arguments can be substituted with various macros.  Only  complete  argument  substitution  is
       supported  -  macro  substitutions  can't  be embedded. All macros begin with a percent character '%'. An
       argument beginning with two percent characters will have one of them discarded.

       The following macros are supported:

              %o    Operation type
              %k    Key ID
              %t    Key type
              %d    Key description
              %c    Callout information
              %u    Key UID
              %g    Key GID
              %T    Requestor's thread keyring
              %P    Requestor's process keyring
              %S    Requestor's session keyring

       There's another macro substitution too that permits the interpolation of the contents of a key:

              %{&lt;type&gt;:&lt;description&gt;}

       This performs a lookup for a key of the given type and description on the requestor's  keyrings,  and  if
       found,  substitutes  the  contents  for the macro. If not found an error will be logged and the key under
       construction will be negated.

</pre><h4><b>EXAMPLE</b></h4><pre>
       A basic file will be installed in the /etc. This will contain two debugging lines that  can  be  used  to
       test the installation:

              create user debug:* negate /bin/keyctl negate %k 30 %S
              create user debug:loop:* * |<a href="file:/bin/cat">/bin/cat</a>
              create user debug:* * /usr/share/keyutils/request-key-debug.sh %k %d %c %S
              negate * * * /bin/keyctl negate %k 30 %S

       This is set up so that something like:

              keyctl request2 user debug:xxxx negate

       will create a negative user-defined key, something like:

              keyctl request2 user debug:yyyy spoon

       will create an instantiated user-defined key with "Debug spoon" as the payload, and something like:

              keyctl request2 user debug:loop:zzzz abcdefghijkl

       will create an instantiated user-defined key with the callout information as the payload.

</pre><h4><b>FILES</b></h4><pre>
       <u>/etc/request-key.conf</u>
       <u>/etc/request-key.d/*.conf</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/keyctl.1.html">keyctl</a></b>(1), <b><a href="../man5/request-key.conf.5.html">request-key.conf</a></b>(5)

Linux                                           15 November 2011                             <u><a href="../man5/REQUEST-KEY.CONF.5.html">REQUEST-KEY.CONF</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>