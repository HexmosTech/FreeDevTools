<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mh-format - formatting language for nmh message system</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/nmh">nmh_1.8-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mh-format - formatting language for nmh message system

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Several  <b>nmh</b>  commands  utilize  either  a  <u>format</u>  string  or a <u>format</u> file during their execution.  For
       example, <b>scan</b> uses a format string to generate its listing of  messages;  <b>repl</b>  uses  a  format  file  to
       generate message replies, and so on.

       There are a number of scan listing formats available, including <u>nmh/etc/scan.time</u>, <u>nmh/etc/scan.size</u>, and
       <u>nmh/etc/scan.timely</u>.   Look  in <u>/etc/nmh</u> for other <b>scan</b> and <b>repl</b> format files which may have been written
       at your site.

       You can have your local <b>nmh</b> expert write new format commands or modify existing ones, or you can try your
       hand at it yourself.  This manual section explains how to do that.  Note: some  familiarity  with  the  C
       <b>printf</b> routine is assumed.

       A  format string consists of ordinary text combined with special, multi-character, escape sequences which
       begin with `%'.  When specifying a format string, the usual C backslash  characters  are  honored:  `\b',
       `\f',  `\n',  `\r',  and  `\t'.   Continuation lines in format files end with `\' followed by the newline
       character.  A literal `%' can be inserted into a format file by using the sequence `%%'.

   <b>SYNTAX</b>
       Format strings are built around <u>escape</u> <u>sequences</u>.  There are  three  types  of  escape  sequence:  header
       <u>components</u>,  built-in  <u>functions</u>,  and  flow  <u>control</u>.   Comments  may be inserted in most places where a
       function argument is not expected.  A comment begins with `%;' and ends with a (non-escaped) newline.

   <b>Component</b> <b>escapes</b>
       A <u>component</u> escape is specified as `%{<u>component</u>}', and exists  for  each  header  in  the  message  being
       processed.   For  example,  `%{<u>date</u>}'  refers to the “Date:” field of the message.  All component escapes
       have a string value.  Such values are usually compressed by converting any control  characters  (tab  and
       newline  included)  to  spaces, then eliding any leading or multiple spaces.  Some commands, however, may
       interpret some component escapes differently; be sure  to  refer  to  each  command's  manual  entry  for
       details.  Some commands (such as <u><a href="../man8/ap.8.html">ap</a></u>(8) and <u><a href="../man1/mhl.1.html">mhl</a></u>(1)<u>)</u> use a special component `%{<u>text</u>}' to refer to the text
       being processed; see their respective man pages for details and examples.

   <b>Function</b> <b>escapes</b>
       A  <u>function</u>  escape is specified as `%(<u>function</u>)'.  All functions are built-in, and most have a string or
       integer value.  A function escape may take an <u>argument</u>.  The argument follows the  function  escape  (and
       any separating whitespace is discarded) as in the following example:

            %(<u>function</u> <u>argument</u>)

       In  addition to literal numbers or strings, the argument to a function escape can be another function, or
       a component, or a control escape.  When the argument is a  function  or  a  component,  the  argument  is
       specified  without  a leading `%'.  When the argument is a control escape, it is specified with a leading
       `%'.

   <b>Control</b> <b>escapes</b>
       A <u>control</u> escape is one of: `%&lt;', `%?', `%|', or `%&gt;'.  These are combined into the conditional execution
       construct:

            %&lt; <u>condition</u> <u>format-text</u>
            %? <u>condition</u> <u>format-text</u>
                ...
            %| <u>format-text</u>
            %&gt;

       (Extra white space is shown here only for clarity.)   These  constructs,  which  may  be  nested  without
       ambiguity,  form  a general <b>if-elseif-else-endif</b> block where only one of the format-texts is interpreted.
       In other words, `%&lt;' is like the "if", `%?' is like the "elseif", `%|' is like "else", and `%&gt;'  is  like
       "endif".

       A  `%&lt;'  or  `%?'  control escape causes its condition to be evaluated.  This condition is a <u>component</u> or
       <u>function</u>.  For components and functions whose value is an integer, the condition is true if  it  is  non-
       zero,  and false if zero.  For components and functions whose value is a string, the condition is true it
       is a non-empty string, and false if an empty string.

       The `%?' control escape is optional, and can be used multiple times in a  conditional  block.   The  `%|'
       control escape is also optional, but may only be used once.

   <b>Function</b> <b>escapes</b>
       Functions  expecting  an argument generally require an argument of a particular type.  In addition to the
       integer and string types, these include:

            <u>Argument</u> <u>Description</u>            <u>Example</u> <u>Syntax</u>
            literal  A literal number       %(<u>func</u> 1234)
                     or string              %(<u>func</u> text string)
            comp     Any component          %(<u>func</u>{<u>in-reply-to</u>})
            date     A date component       %(<u>func</u>{<u>date</u>})
            addr     An address component   %(<u>func</u>{<u>from</u>})
            expr     Nothing                %(<u>func</u>)
                     or a subexpression     %(<u>func</u>(<u>func2</u>))
                     or control escape      %(<u>func</u> %&lt;{<u>reply-to</u>}%|%{<u>from</u>}%&gt;)

       The <u>date</u> and <u>addr</u> types have the same syntax as the component type, <u>comp</u>, but require a header  component
       which is a date, or address, string, respectively.

       Most  arguments  not of type <u>expr</u> are required.  When escapes are nested (via expr arguments), evaluation
       is done from innermost to outermost.   As  noted  above,  for  the  <u>expr</u>  argument  type,  functions  and
       components  are written without a leading `%'.  Control escape arguments must use a leading `%', preceded
       by a space.

       For example,

            %&lt;(mymbox{from}) To: %{to}%&gt;

       writes  the  value of the header component “From:” to the internal  register  named  str;  then  (<u>mymbox</u>)
       reads  str  and  writes  its  result  to  the internal register named <u>num</u>; then the control escape, `%&lt;',
       evaluates <u>num</u>.  If <u>num</u> is non-zero, the string “To:” is printed followed  by  the  value  of  the  header
       component “To:”.

   <b>Evaluation</b>
       The  evaluation  of  format  strings  is performed by a small virtual machine.  The machine is capable of
       evaluating nested expressions (as described above) and, in addition, has an integer register <u>num</u>,  and  a
       text string register <u>str</u>.  When a function escape that accepts an optional argument is processed, and the
       argument  is  not  present,  the  current  value of either <u>num</u> or <u>str</u> is substituted as the argument: the
       register used depends on the function, as listed below.

       Component escapes write the value of their message header in <u>str</u>.  Function escapes  write  their  return
       value in <u>num</u> for functions returning integer or boolean values, and in <u>str</u> for functions returning string
       values.   (The  boolean  type  is  a  subset of integers, with usual values 0=false and 1=true.)  Control
       escapes return a boolean value, setting <u>num</u> to 1 if the last explicit condition evaluated by  a  `%&lt;'  or
       `%?' control escape succeeded, and 0 otherwise.

       All  component  escapes,  and those function escapes which return an integer or string value, evaluate to
       their value as well as setting <u>str</u> or <u>num</u>.  Outermost escape expressions in these forms will print  their
       value, but outermost escapes which return a boolean value do not result in printed output.

   <b>Functions</b>
       The function escapes may be roughly grouped into a few categories.

            <u>Function</u>    <u>Argument</u> <u>Return</u>   <u>Description</u>
            msg                  integer  message number
            cur                  integer  message is current (0 or 1)
            unseen               integer  message is unseen (0 or 1)
            size                 integer  size of message
            strlen               integer  length of <u>str</u>
            width                integer  column width of terminal
            charleft             integer  bytes left in output buffer
            timenow              integer  seconds since the Unix epoch
            me                   string   the user's mailbox (username)
            myhost               string   the user's local hostname
            myname               string   the user's name
            localmbox            string   the complete local mailbox
            eq          literal  boolean  <u>num</u> == <u>arg</u>
            ne          literal  boolean  <u>num</u> != <u>arg</u>
            gt          literal  boolean  <u>num</u> &gt; <u>arg</u>
            match       literal  boolean  <u>str</u> contains <u>arg</u>
            amatch      literal  boolean  <u>str</u> starts with <u>arg</u>
            plus        literal  integer  <u>arg</u> plus <u>num</u>
            minus       literal  integer  <u>arg</u> minus <u>num</u>
            multiply    literal  integer  <u>num</u> multiplied by <u>arg</u>
            divide      literal  integer  <u>num</u> divided by <u>arg</u>
            modulo      literal  integer  <u>num</u> modulo <u>arg</u>
            num         literal  integer  Set <u>num</u> to <u>arg</u>.
            num                  integer  Set <u>num</u> to zero.
            lit         literal  string   Set <u>str</u> to <u>arg</u>.
            lit                  string   Clear <u>str</u>.
            getenv      literal  string   Set <u>str</u> to environment value of <u>arg</u>
            profile     literal  string   Set <u>str</u> to profile or context
                                          component <u>arg</u> value
            nonzero     expr     boolean  <u>num</u> is non-zero
            zero        expr     boolean  <u>num</u> is zero
            null        expr     boolean  <u>str</u> is empty
            nonnull     expr     boolean  <u>str</u> is non-empty
            void        expr              Set <u>str</u> or <u>num</u>
            comp        comp     string   Set <u>str</u> to component text
            compval     comp     integer  Set <u>num</u> to “<b>atoi</b>(<u>comp</u>)”
            decode      expr     string   decode <u>str</u> as RFC 2047 (MIME-encoded)
                                          component
            unquote     expr     string   remove RFC 2822 quotes from <u>str</u>
            trim        expr              trim trailing whitespace from <u>str</u>
            trimr       expr     string   Like %(trim), also returns string
            kilo        expr     string   express in SI units: 15.9K, 2.3M, etc.
                                          %(kilo) scales by factors of 1000,
            kibi        expr     string   express in IEC units: 15.5Ki, 2.2Mi.
                                          %(kibi) scales by factors of 1024.
            ordinal     expr     string   Output ordinal suffix based on value
                                          of <u>num</u> (st, nd, rd, th)
            putstr      expr              print <u>str</u>
            putstrf     expr              print <u>str</u> in a fixed width
            putnum      expr              print <u>num</u>
            putnumf     expr              print <u>num</u> in a fixed width
            putlit      expr              print <u>str</u> without space compression
            zputlit     expr              print <u>str</u> without space compression;
                                          <u>str</u> must occupy no width on display
            bold                 string   set terminal bold mode
            underline            string   set terminal underlined mode
            standout             string   set terminal standout mode
            resetterm            string   reset all terminal attributes
            hascolor             boolean  terminal supports color
            fgcolor     literal  string   set terminal foreground color
            bgcolor     literal  string   set terminal background color
            formataddr  expr              append <u>arg</u> to <u>str</u> as a
                                          (comma separated) address list
            concataddr  expr              append <u>arg</u> to <u>str</u> as a
                                          (comma separated) address list,
                                          including duplicates,
                                          see Special Handling
            putaddr     literal           print <u>str</u> address list with
                                          <u>arg</u> as optional label;
                                          get line width from <u>num</u>

       The  (<u>me</u>) function returns the username of the current user.  The (<u>myhost</u>) function returns the <b>localname</b>
       entry in <u>mts.conf</u>, or the local hostname if <b>localname</b> is not  configured.   The  (<u>myname</u>)  function  will
       return  the value of the <b>SIGNATURE</b> environment variable if set, otherwise it will return the passwd GECOS
       field (truncated at the first comma if it contains one) for the current user.  The  (<u>localmbox</u>)  function
       will  return the complete form of the local mailbox, suitable for use in a “From” header.  It will return
       the “<u>Local-Mailbox</u>” profile entry if there is one; if not, it will be equivalent to:

            %(myname) &lt;%(me)@%(myhost)&gt;

       The following functions require a date component as an argument:

            <u>Function</u>    <u>Argument</u> <u>Return</u>   <u>Description</u>
            sec         date     integer  seconds of the minute
            min         date     integer  minutes of the hour
            hour        date     integer  hours of the day (0-23)
            wday        date     integer  day of the week (Sun=0)
            day         date     string   day of the week (abbrev.)
            weekday     date     string   day of the week
            sday        date     integer  day of the week known?
                                          (1=explicit,0=implicit,-1=unknown)
            mday        date     integer  day of the month
            yday        date     integer  day of the year
            mon         date     integer  month of the year
            month       date     string   month of the year (abbrev.)
            lmonth      date     string   month of the year
            year        date     integer  year (may be &gt; 100)
            zone        date     integer  timezone in minutes
            tzone       date     string   timezone string
            szone       date     integer  timezone explicit?
                                          (1=explicit,0=implicit,-1=unknown)
            date2local  date              coerce date to local timezone
            date2gmt    date              coerce date to GMT
            dst         date     integer  daylight savings in effect? (0 or 1)
            clock       date     integer  seconds since the Unix epoch
            rclock      date     integer  seconds prior to current time
            tws         date     string   official RFC 822 rendering
            pretty      date     string   user-friendly rendering
            nodate      date     integer  returns 1 if date is invalid

       The following functions require an address component as an argument.  The return value of functions noted
       with `*' is computed from the first address present in the header component.

            <u>Function</u>    <u>Argument</u> <u>Return</u>   <u>Description</u>
            proper      addr     string   official RFC 822 rendering
            friendly    addr     string   user-friendly rendering
            addr        addr     string   mbox@host or host!mbox rendering*
            pers        addr     string   the personal name*
            note        addr     string   commentary text*
            mbox        addr     string   the local mailbox*
            mymbox      addr     integer  list has the user's address? (0 or 1)
            getmymbox   addr     string   the user's (first) address,
                                          with personal name
            getmyaddr   addr     string   the user's (first) address,
                                          without personal name
            host        addr     string   the host domain*
            nohost      addr     integer  no host was present (0 or 1)*
            type        addr     integer  host type* (0=local,1=network,
                                          -1=uucp,2=unknown)
            path        addr     string   any leading host route*
            ingrp       addr     integer  address was inside a group (0 or 1)*
            gname       addr     string   name of group*

       (A clarification on (<u>mymbox</u>{<u>comp</u>}) is in order.  This function checks each of the addresses in the header
       component “<u>comp</u>” against the user's mailbox name and any “<u>Alternate-Mailboxes</u>”.  It returns true  if  any
       address  matches.  However,  it also returns true if the “<u>comp</u>” header is not present in the message.  If
       needed, the (<u>null</u>) function can be used to explicitly test for this case.)

       The <u>friendly</u>{<u>comp</u>}) call will return any double-quoted “personal name” (that  is,  anything  before  &lt;&gt;),
       then  it  will  return that.  If there's no personal name but there is a “note” (comments string after an
       email address), it will return that.  If there is neither of those it will just  return  the  bare  email
       address.

   <b>Formatting</b>
       When  a  function  or  component  escape  is  interpreted  and the result will be printed immediately, an
       optional field width can be specified to print the field in exactly a given number  of  characters.   For
       example, a numeric escape like %4(<u>size</u>) will print at most 4 digits of the message size; overflow will be
       indicated by a `?' in the first position (like `?234').  A string escape like %4(<u>me</u>) will print the first
       4  characters  and  truncate  at  the  end.  Short fields are padded at the right with the fill character
       (normally, a blank).  If the field width argument begins with a leading zero, then the fill character  is
       set to a zero.

       The functions (<u>putnumf</u>) and (<u>putstrf</u>) print their result in exactly the number of characters specified by
       their  leading  field  width  argument.  For example, %06(<u>putnumf</u>(<u>size</u>)) will print the message size in a
       field six characters wide filled with leading zeros; %14(<u>putstrf</u>{<u>from</u>}) will  print  the  “From:”  header
       component  in  fourteen  characters with trailing spaces added as needed.  Using a negative value for the
       field width causes right-justification within the field, with padding on the left up to the field  width.
       Padding  is  with spaces except for a left-padded <u>putnumf</u> when the width starts with zero.  The functions
       (<u>putnum</u>) and (<u>putstr</u>) are somewhat special: they print their result in the minimum number  of  characters
       required,  and ignore any leading field width argument.  The (<u>putlit</u>) function outputs the exact contents
       of the str register without any changes such as duplicate space removal or control character  conversion.
       Similarly, the (<u>zputlit</u>) function outputs the exact contents of the str register, but requires that those
       contents not occupy any output width.  It can therefore be used for outputting terminal escape sequences.

       There  are a limited number of function escapes to output terminal escape sequences.  These sequences are
       retrieved from the  <u><a href="../man5/terminfo.5.html">terminfo</a></u>(5)  database  according  to  the  current  terminal  setting.   The  (<u>bold</u>),
       (<u>underline</u>),  and  (<u>standout</u>)  escapes  set  bold  mode,  underline mode, and standout mode respectively.
       (<u>hascolor</u>) can be used to determine if the current terminal supports color.  (<u>fgcolor</u>) and (<u>bgcolor</u>)  set
       the  foreground and background colors respectively.  Both of these escapes take one literal argument, the
       color name, which can be one of: black, red, green, yellow,  blue,  magenta,  cyan,  white.   (<u>resetterm</u>)
       resets  all  terminal  attributes  to  their  default  setting.  These terminal escapes should be used in
       conjunction with (<u>zputlit</u>) (preferred) or (<u>putlit</u>), as  the  normal  (<u>putstr</u>)  function  will  strip  out
       control characters.

       The  available  output  width  is  kept  in an internal register; any output exceeding this width will be
       truncated.  The one exception to this is that (<u>zputlit</u>) functions will still be executed  if  a  terminal
       reset code is being placed at the end of a line.

   <b>Special</b> <b>Handling</b>
       Some functions have different behavior depending on the command they are invoked from.

       In  <b>repl</b> the (<u>formataddr</u>) function stores all email addresses encountered into an internal cache and will
       use this cache to suppress duplicate addresses.  If you need to create  an  address  list  that  includes
       previously-seen  addresses  you  may use the (<u>concataddr</u>) function, which is identical to (<u>formataddr</u>) in
       all other respects.  Note that (<u>concataddr</u>) does <u>not</u> add addresses to the duplicate-suppression cache.

   <b>Other</b> <b>Hints</b> <b>and</b> <b>Tips</b>
       Sometimes, the writer of a format function is confused because output is duplicated.  The general rule to
       remember is simple: If a function or component escape begins with a `%', it will  generate  text  in  the
       output file.  Otherwise, it will not.

       A good example is a simple attempt to generate a To: header based on the From: and Reply-To: headers:

            %(formataddr %&lt;{reply-to}%|%{from})%(putaddr To: )

       Unfortunately, if the Reply-to: header is <u>not</u> present, the output line will be something like:

            My From User &lt;<a href="mailto:from@example.com">from@example.com</a>&gt;To: My From User &lt;<a href="mailto:from@example.com">from@example.com</a>&gt;

       What went wrong?  When performing the test for the <b>if</b> clause (%&lt;), the component is not output because it
       is  considered  an argument to the <b>if</b> statement (so the rule about not starting with % applies).  But the
       component escape in our <b>else</b> statement (everything after the `%|') is <u>not</u> an  argument  to  anything;  it
       begins  with  a  %,  and  thus  the  value of that component is output.  This also has the side effect of
       setting the <u>str</u> register, which is later picked up by  the  (<u>formataddr</u>)  function  and  then  output  by
       (<u>putaddr</u>).   The  example format string above has another bug: there should always be a valid width value
       in the <u>num</u> register when (<u>putaddr</u>) is called, otherwise bad formatting can take place.

       The solution is to use the (<u>void</u>) function; this will prevent the function or component  from  outputting
       any  text.   With  this  in  place  (and  using  (<u>width</u>)  to set the <u>num</u> register for the width) a better
       implementation would look like:

          %(formataddr %&lt;{reply-to}%|%(void{from})%(void(width))%(putaddr To: )

       It should be noted here that the side effects of function and component escapes are still in  force  and,
       as a result, each component test in the <b>if-elseif-else-endif</b> clause sets the <u>str</u> register.

       As an additional note, the (<u>formataddr</u>) and (<u>concataddr</u>) functions have special behavior when it comes to
       the  <u>str</u>  register.   The  starting point of the register is saved and is used to build up entries in the
       address list.

       You will find the <u><a href="../man1/fmttest.1.html">fmttest</a></u>(1) utility invaluable when debugging problems with format strings.

   <b>Examples</b>
       With all the above in mind, here is a breakdown of the default format string for <b>scan</b>.   The  first  part
       is:

              %<a href="../manmsg/4.msg.html">4</a>(msg)%&lt;(cur)+%| %&gt;%&lt;{replied}-%?{encrypted}E%| %&gt;

       which  says  that  the  message  number  should be printed in four digits.  If the message is the current
       message then a `+', else a space, should be printed; if a “Replied:” field is present then a `-', else if
       an “Encrypted:” field is present then an `E', otherwise a space, should be printed.  Next:

              %02(mon{date})/%02(mday{date})

       the month and date are printed in two digits (zero filled) separated by a slash.  Next,

            %&lt;{date} %|*%&gt;

       If a “Date:” field is present it is printed, followed by a space; otherwise a `*' is printed.  Next,

            %&lt;(mymbox{from})%&lt;{to}To:%14(decode(friendly{to}))%&gt;%&gt;

       if the message is from me, and there is a  “To:”  header,  print  “To:”  followed  by  a  “user-friendly”
       rendering  of  the  first  address  in  the “To:” field; any MIME-encoded characters are decoded into the
       actual characters.  Continuing,

            %&lt;(zero)%17(decode(friendly{from}))%&gt;

       if either of the above two tests failed, then the “From:” address is printed in  a  mime-decoded,  “user-
       friendly” format.  And finally,

            %(decode{subject})%&lt;{body}&lt;&lt;%{body}&gt;&gt;%&gt;

       the mime-decoded subject and initial body (if any) are printed.

       For a more complicated example, consider a possible <u>replcomps</u> format file.

            %(lit)%(formataddr %&lt;{reply-to}

       This  clears  <u>str</u>  and  formats the “Reply-To:” header if present.  If not present, the else-if clause is
       executed.

            %?{from}%?{sender}%?{return-path}%&gt;)\

       This formats the “From:”, “Sender:” and “Return-Path:” headers, stopping  as  soon  as  one  of  them  is
       present.  Next:

            %&lt;(nonnull)%(void(width))%(putaddr To: )\n%&gt;\

       If  the  <u>formataddr</u>  result  is  non-null, it is printed as an address (with line folding if needed) in a
       field <u>width</u> wide, with a leading label of “To:”.

            %(lit)%(formataddr{to})%(formataddr{cc})%(<a href="../manme/formataddr.me.html">formataddr</a>(me))\

       <u>str</u> is cleared, and the “To:” and “Cc:” headers, along with the user's address  (depending  on  what  was
       specified with the “-cc” switch to <u>repl</u>) are formatted.

            %&lt;(nonnull)%(void(width))%(putaddr cc: )\n%&gt;\

       If the result is non-null, it is printed as above with a leading label of “cc:”.

            %&lt;{fcc}Fcc: %{fcc}\n%&gt;\

       If  a  <b>-fcc</b> <u>folder</u> switch was given to <b>repl</b> (see <u><a href="../man1/repl.1.html">repl</a></u>(1) for more details about %{<u>fcc</u>}), an “Fcc:” header
       is output.

            %&lt;{subject}Subject: Re: %{subject}\n%&gt;\

       If a subject component was present, a suitable reply subject is output.

            %&lt;{message-id}In-Reply-To: %{message-id}\n%&gt;\
            %&lt;{message-id}References: %&lt;{references} %{references}%&gt;\
            %{message-id}\n%&gt;
            --------

       If a message-id component was present, an “In-Reply-To:”  header  is  output  including  the  message-id,
       followed  by  a “References:” header with references, if present, and the message-id.  As with all plain-
       text, the row of dashes are output as-is.

       This last part is a good example for a little more elaboration.  Here's that part again in pseudo-code:

            if (comp_exists(message-id))  then
                 print (“In-reply-to: ”)
                 print (message-id.value)
                 print (“\n”)
            endif
            if (comp_exists(message-id)) then
                 print (“References: ”)
                 if (comp_exists(references)) then
                       print(references.value);
                 endif
                 print (message-id.value)
                 print (“\n”)
            endif

       One more example: Currently, <b>nmh</b> supports very large message numbers, and it is not uncommon for a folder
       to have far more than 10000 messages.  Nonetheless (as noted above)  the  various  scan  format  strings,
       inherited  from  older  MH  versions,  are  generally  hard-coded  to  4  digits  for the message number.
       Thereafter, formatting problems occur.  The nmh format strings can be modified to  behave  more  sensibly
       with larger message numbers:

              %(<a href="../manmsg/void.msg.html">void</a>(msg))%&lt;(gt 9999)%(msg)%|%<a href="../manmsg/4.msg.html">4</a>(msg)%&gt;

       The  current  message  number  is  placed in <u>num</u>.  (Note that (<u>msg</u>) is a function escape which returns an
       integer, it is not a component.)  The (<u>gt</u>) conditional is used to test whether the message number  has  5
       or more digits.  If so, it is printed at full width, otherwise at 4 digits.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/scan.1.html">scan</a></u>(1), <u><a href="../man1/repl.1.html">repl</a></u>(1), <u><a href="../man1/fmttest.1.html">fmttest</a></u>(1)

</pre><h4><b>CONTEXT</b></h4><pre>
       None

nmh-1.8                                            2015-01-10                                     <u><a href="../man5mh/MH-FORMAT.5mh.html">MH-FORMAT</a></u>(5mh)
</pre>
 </div>
</div></section>
</div>
</body>
</html>