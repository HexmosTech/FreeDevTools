<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gitformat-chunk - Chunk-based file formats</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/git-man">git-man_2.50.0-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gitformat-chunk - Chunk-based file formats

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Used by <b><a href="../man5/gitformat-commit-graph.5.html">gitformat-commit-graph</a></b>(5) and the "MIDX" format (see the pack format documentation in <b><a href="../man5/gitformatpack.5.html">gitformat-</a></b>
       <b><a href="../man5/gitformatpack.5.html">pack</a></b>(5)).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Some file formats in Git use a common concept of "chunks" to describe sections of the file. This allows
       structured access to a large file by scanning a small "table of contents" for the remaining data. This
       common format is used by the <b>commit-graph</b> and <b>multi-pack-index</b> files. See the <b>multi-pack-index</b> format in
       <b><a href="../man5/gitformat-pack.5.html">gitformat-pack</a></b>(5) and the <b>commit-graph</b> format in <b><a href="../man5/gitformat-commit-graph.5.html">gitformat-commit-graph</a></b>(5) for how they use the chunks to
       describe structured data.

       A chunk-based file format begins with some header information custom to that format. That header should
       include enough information to identify the file type, format version, and number of chunks in the file.
       From this information, that file can determine the start of the chunk-based region.

       The chunk-based region starts with a table of contents describing where each chunk starts and ends. This
       consists of (C+1) rows of 12 bytes each, where C is the number of chunks. Consider the following table:

           | Chunk ID (4 bytes) | Chunk Offset (8 bytes) |
           |--------------------|------------------------|
           | ID[0]              | OFFSET[0]              |
           | ...                | ...                    |
           | ID[C]              | OFFSET[C]              |
           | 0x0000             | OFFSET[C+1]            |

       Each row consists of a 4-byte chunk identifier (ID) and an 8-byte offset. Each integer is stored in
       network-byte order.

       The chunk identifier <b>ID</b>[<b>i</b>] is a label for the data stored within this file from <b>OFFSET</b>[<b>i</b>] (inclusive) to
       <b>OFFSET</b>[<b>i+1</b>] (exclusive). Thus, the size of the <b>i</b>`th <b>chunk</b> <b>is</b> <b>equal</b> <b>to</b> <b>the</b> <b>difference</b> <b>between</b> `OFFSET[<b>i+1</b>]
       and <b>OFFSET</b>[<b>i</b>]. This requires that the chunk data appears contiguously in the same order as the table of
       contents.

       The final entry in the table of contents must be four zero bytes. This confirms that the table of
       contents is ending and provides the offset for the end of the chunk-based data.

       Note: The chunk-based format expects that the file contains <u>at</u> <u>least</u> a trailing hash after <b>OFFSET</b>[<b>C+1</b>].

       Functions for working with chunk-based file formats are declared in <b>chunk-format.h</b>. Using these methods
       provide extra checks that assist developers when creating new file formats.

</pre><h4><b>WRITING</b> <b>CHUNK-BASED</b> <b>FILE</b> <b>FORMATS</b></h4><pre>
       To write a chunk-based file format, create a <b>struct</b> <b>chunkfile</b> by calling <b>init_chunkfile</b>() and pass a
       <b>struct</b> <b>hashfile</b> pointer. The caller is responsible for opening the <b>hashfile</b> and writing header
       information so the file format is identifiable before the chunk-based format begins.

       Then, call <b>add_chunk</b>() for each chunk that is intended for writing. This populates the <b>chunkfile</b> with
       information about the order and size of each chunk to write. Provide a <b>chunk_write_fn</b> function pointer to
       perform the write of the chunk data upon request.

       Call <b>write_chunkfile</b>() to write the table of contents to the <b>hashfile</b> followed by each of the chunks.
       This will verify that each chunk wrote the expected amount of data so the table of contents is correct.

       Finally, call <b>free_chunkfile</b>() to clear the <b>struct</b> <b>chunkfile</b> data. The caller is responsible for
       finalizing the <b>hashfile</b> by writing the trailing hash and closing the file.

</pre><h4><b>READING</b> <b>CHUNK-BASED</b> <b>FILE</b> <b>FORMATS</b></h4><pre>
       To read a chunk-based file format, the file must be opened as a memory-mapped region. The chunk-format
       API expects that the entire file is mapped as a contiguous memory region.

       Initialize a <b>struct</b> <b>chunkfile</b> pointer with <b>init_chunkfile</b>(<b>NULL</b>).

       After reading the header information from the beginning of the file, including the chunk count, call
       <b>read_table_of_contents</b>() to populate the <b>struct</b> <b>chunkfile</b> with the list of chunks, their offsets, and
       their sizes.

       Extract the data information for each chunk using <b>pair_chunk</b>() or <b>read_chunk</b>():

       •   <b>pair_chunk</b>() assigns a given pointer with the location inside the memory-mapped file corresponding to
           that chunk’s offset. If the chunk does not exist, then the pointer is not modified.

       •   <b>read_chunk</b>() takes a <b>chunk_read_fn</b> function pointer and calls it with the appropriate initial pointer
           and size information. The function is not called if the chunk does not exist. Use this method to read
           chunks if you need to perform immediate parsing or if you need to execute logic based on the size of
           the chunk.

       After calling these methods, call <b>free_chunkfile</b>() to clear the <b>struct</b> <b>chunkfile</b> data. This will not
       close the memory-mapped region. Callers are expected to own that data for the timeframe the pointers into
       the region are needed.

</pre><h4><b>EXAMPLES</b></h4><pre>
       These file formats use the chunk-format API, and can be used as examples for future formats:

       •   <b>commit-graph:</b> see <b>write_commit_graph_file</b>() and <b>parse_commit_graph</b>() in <b>commit-graph.c</b> for how the
           chunk-format API is used to write and parse the commit-graph file format documented in the
           commit-graph file format in <b><a href="../man5/gitformat-commit-graph.5.html">gitformat-commit-graph</a></b>(5).

       •   <b>multi-pack-index:</b> see <b>write_midx_internal</b>() and <b>load_multi_pack_index</b>() in <b>midx.c</b> for how the
           chunk-format API is used to write and parse the multi-pack-index file format documented in the
           multi-pack-index file format section of <b><a href="../man5/gitformat-pack.5.html">gitformat-pack</a></b>(5).

</pre><h4><b>GIT</b></h4><pre>
       Part of the <b><a href="../man1/git.1.html">git</a></b>(1) suite

Git 2.50.0                                         07/03/2025                                 <u><a href="../man5/GITFORMAT-CHUNK.5.html">GITFORMAT-CHUNK</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>