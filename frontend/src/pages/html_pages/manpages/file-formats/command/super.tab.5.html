<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>super.tab - database of restricted commands for super(1)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/super">super_3.30.3-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       super.tab - database of restricted commands for <a href="../man1/super.1.html">super</a>(1)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>super.tab</u>  file  contains  the  restrictions on who can execute commands with <b><a href="../man1/super.1.html">super</a></b>(1).  It may also
       contain options that modify the uid and/or gid under which a command is  run;  the  list  of  environment
       variables  that  are  discarded  before  executing  a  command,  and so on.  The reader is expected to be
       familiar with the <b><a href="../man1/super.1.html">super</a></b>(1) man page.

       If you are trying to avoid reading this lengthy man page, you need to know a few  simple  rules.   First,
       for  a  user  to  successfully  execute  a  command by typing <u>super</u> <u>commandName</u>, the minimum entry in the
       <u>super.tab</u> is something like
            <b>commandName</b>   <b>FullPathToCommand</b>  <b>userName</b>
       For example, the entry
            <b>cdmount</b>   <b>/usr/local/bin/cdmount</b>  <b>wally,dolly</b>
       says that users <u>wally</u> and <u>dolly</u> may execute the /usr/local/bin/cdmount program by typing <u>super</u> <u>cdmount</u>.

       Second, when you define options in the <u>super.tab</u> file, remember that all options are orthogonal  to  each
       other, and it doesn't matter in what order they appear on a control line.  Third, <u>global</u> options (defined
       on  a  <b>:global</b>  or <b>:global_options</b> line) take effect immediately after the defining line, are valid until
       the end of the input or until there is a countermanding global option or pattern, and are  overridden  by
       <u>local</u> (per-command) options, which are defined on a regular control line.

       Although  <u>super</u>  has  a  great  many options that you can set inside the <u>super.tab</u> file, none of them are
       required for security, so you don't have to be intimately familiar with this entire document in order  to
       use  <u>super</u>  securely.   The  most  important options that you will probably want to use are (a) a logging
       option like <u>logfile=</u>xxx or <u>syslog=y</u>; and (b)  <u>patterns=shell</u>,  so  that  the  default  regular-expression
       interpretation of wildcards is changed to the more convenient shell-style glob patterns.

       Unless  modified  with  options  in the <u>super.tab</u> file, super executes commands using effective uid root;
       unchanged real uid and gid; no supplementary groups; no open file  descriptors  save  0,  1,  and  2;  no
       environment  variables  except  a  few  with safe values (see <b><a href="../man1/super.1.html">super</a></b>(1)); and signal handling reset to the
       default.

       When <u>super</u> uses a command from a user-supplied super file (<u>.supertab</u> in the user's home directory)  these
       rules  are  modified:  the real and effective uid and gid are set to the owner of the <u>.supertab</u> file, and
       the supplementary groups are set to the user's login groups.

       If the special supplementary file named <u>super.init</u> exists, it  is  implictly  include  at  the  start  of
       <u>super.tab</u>  and  every  <u>.supertab</u>  file.   The file resides in the same directory as <u>super.tab</u> and must be
       owned by root, and should be world-readable.  This provides a uniform configuration file applied to every
       super-executed command.  Note that the configuration file should contain entries that are appropriate for
       use in both the <u>super.tab</u> file and any per-user <u>supertab</u> file.  It is not a good idea to include commands
       in the <u>super.init</u> file.  The variable <b>IS_USERTAB</b> is defined to be ``<u>yes</u>'' if <u>super</u> is processing  a  per-
       user  .supertab  file, and ``<u>no</u>'' otherwise.  The following pair of entries could be used in a super.init
       file to allow different initialization for regular use and per-user use:

              <b>:if</b> <b>$IS_USERTAB</b> <b>==</b> <b>yes</b>    <b>:include</b> <b>/etc/super.init.per-user</b>
              <b>:if</b> <b>$IS_USERTAB</b> <b>!=</b> <b>yes</b>    <b>:include</b> <b>/etc/super.init.as-root</b>

       (The use of variables and conditional expressions is explained  below,  in  the  sections  <u>Variables</u>  and
       <u>Conditionally-included</u> <u>Control</u> <u>Lines</u>, respectively.)

       The <u>super.tab</u> file is formatted as a series of control lines of the form

            <b>CmdPat</b>  <b>FullPath</b> <b>\</b>
                         <b>Options</b> <b>PermittedUsers</b> <b>PermittedTimes</b>
       or
            <b>CmdPat1::FullPath1</b> <b>CmdPat2::FullPath2</b> <b>...</b> <b>\</b>
                         <b>Options</b> <b>PermittedUsers</b> <b>PermittedTimes</b>
       or
            <u>:</u><b>BuiltinCmd</b> <b>arguments</b>

       The  <u>Options</u>,  <u>PermittedUsers</u>,  and  <u>PermittedTimes</u>  may  be  mixed  together in any order.  At least one
       <u>PermittedUsers</u> field is required, but neither <u>Options</u> nor <u>PermittedTimes</u> are required.  For each  control
       line, <u>Super</u> matches the following:

              • the user-entered command to a <u>CmdPat</u>;

              • the {user,group,host} triplet to a <u>PermittedUsers</u> entry; and

              • the current time to a <u>PermittedTimes</u> entry (the default permits any time).

       If these conditions are not satisfied, <u>super</u> ``falls through'' and tries the next control line.

       For example, the entry

              <b>renice</b> <b>/etc/renice</b> <b>jack@hill</b> <b>jill@bucket</b> <b>time~8-17</b>

       specifies that between hours 8:00 and 17:00, user Jack can renice any process on host hill, and user Jill
       can do so on host bucket, by simply typing <b>super</b> <b>renice</b> <b>&lt;args&gt;</b>  <b>.</b>

       Control lines begin in column 1, and the fields are whitespace-separated.  Note that you can either use a
       single  <u>CmdPat</u> and <u>FullPath</u>, separated by whitespace, or you can use a series of them in one control line
       by putting `<b>::</b>' between each <u>CmdPat</u> and <u>FullPath</u> pair.

       Whitespace may be included in a field by enclosing text in single-  or  double-quotes.   The  quoting  is
       shell-like,  in  the  sense  that  quotemarks don't have to surround the entire field, and you can switch
       between quotemark types in a single entry.  For  instance,  <b>X"a</b> <b>b"Y'd</b> <b>e'</b>  is  equivalent  to  <b>"Xa</b> <b>bYd</b> <b>e"</b>.
       Comments begin with a `#' and continue to the end of a line.

       There can also be blank or comment lines without any control data.

       A control line may be continued by preceding the newline with a backslash, and indenting the continuation
       line  with  whitespace.  When the multiple-line entry is read, the text just before the backslash-newline
       is not modified (any whitespace before the backslash will be kept), and the  backslash-newline-whitespace
       sequence is either eliminated entirely or treated as whitespace.  The rule is simple: following a letter,
       digit, or underscore, it is treated as whitespace.  Otherwise, it is eliminated.  This means that

              <b>Cmd</b>  <b>File</b>  <b>user1\</b>
                         <b>user2\</b>
                         <b>user3</b>

       is equivalent to

              <b>Cmd</b>  <b>File</b>  <b>user1</b> <b>user2</b> <b>user3</b>

       On the other hand,

              <b>Cmd</b>  <b>File</b>  <b>{user1,\</b>
                         <b>user2,\</b>
                         <b>user3}</b>

       is equivalent to

              <b>Cmd</b>  <b>File</b>  <b>{user1,user2,user3}</b>

       That is, the sensible interpretation is done in both cases.

       The  indentation  requirement  for  continuation  lines  helps <b>super</b> catch typos.  Comments may be placed
       before each backslash-newline pair, not just at the end of a continued control line.

</pre><h4><b>The</b> <b>CmdPat</b> <b>Field</b></h4><pre>
       In response to the user typing

              <b>super</b> <u>cmd</u> [ <u>args</u> ],

       the <u>cmd</u> is searched for in the <u>super.tab</u> file.  The <u>cmd</u> is matched against each pattern <u>CmdPat</u>.

       <b>Basic</b> <b>Use:</b> <b>Simple</b> <b>Command</b> <b>Patterns</b> <b>without</b> <b>Wildcards.</b>

       Typically, a <u>CmdPat</u> just uses plain characters without any special pattern-matching characters, so a  <u>cmd</u>
       must be the same as the <u>CmdPat</u> string.  For example:

              <b>skill</b> <b>/usr/local/bin/skill</b>   <b>user1</b> <b>user2</b> <b>user3</b>

       Here, any user in the list {user1, user2, user3} may type <b>super</b> <b>skill</b> to execute /usr/local/bin/skill.

       <b>Advanced</b> <b>Use:</b> <b>Command</b> <b>Patterns</b> <b>with</b> <b>Wildcards.</b>

       More  generally,  a  <u>CmdPat</u> can be either an <u>ed</u>-style pattern (``regex'' — the BSD 4.x syntax used in the
       re_comp()/re_exec() routines), POSIX regular expressions, or a Bourne-shell-style pattern.  You  can  set
       the  pattern style using the global option <b>patterns</b> (see below).  The default is ``regex'' for historical
       reasons; however, shell-style patterns are easier to use without errors, and most sites should use shell-
       style patterns.  In all cases the patterns are  extended  to  support  csh-style  brace  expansion.   For
       instance,  <b>a{x,y,z}b</b>  stands  for  the  set of patterns <b>axb</b> <b>ayb</b> <b>azb</b>.  Don't put any whitespace inside the
       braces!

       For convenience, there is always an implied set of braces around an entire pattern.  This means that  any
       comma-separated list <b>a,b,c</b> is interpreted as <b>{a,b,c}</b>, and is very helpful so that you don't have to worry
       about  getting  braces just right when you build complex lists of out of (say) variables containing other
       lists of users.

       All pattern matching is ``anchored'': patterns are forced to match the entire <u>cmd</u> string.

       If the <u>CmdPat</u> is matched and the other conditions are met (such as the user being  in  the  PermittedUser
       list  to  execute this command), <u>FullPath</u> gives the name of the actual command that will be executed with
       <u>execve()</u>.  If <u>FullPath</u> contains an asterisk, the asterisk is first replaced by the user's <u>cmd</u>.

       If you put special pattern-matching characters into the <u>CmdPat</u>, but don't put an asterisk into  <u>FullPath</u>,
       you  have  simply  given  more ways a user can execute the same <u>FullPath.</u>  This isn't useful, and in fact
       isn't a good idea at all.  The power of using patterns in the <u>CmdPat</u>  comes  when  <u>FullPath</u>  includes  an
       asterisk.  For instance, a SysV-based host might have an entry in the <u>super.tab</u> file that looks like:

              <b><a href="file:/usr/bin/">/usr/bin/</a>{lp,lpstat,disable,enable,cancel}</b> <b>*</b> <b>\</b>
                             <b>:operators</b> <b>uid=0</b>

       This  would  allow anybody in the "operators" group to have root access to the line printer commands (the
       <u>uid=0</u> tells <b>super</b> to set the real uid to 0, not just the effective  uid).   For  instance,  if  the  user
       typed:

              <b>super</b> <b>/usr/bin/disable</b> <u>some_printer</u>

       then the <u>FullPath</u> (``<b>*</b>'') would be replaced by <b>/usr/bin/disable</b>, which would be the command to exec.

       More conveniently, the <u>super.tab</u> file could have a line like:

              <b>{lp,lpstat,disable,enable,cancel}</b> <b><a href="file:/usr/bin/">/usr/bin/</a>*</b> <b>\</b>
                             <b>:operators</b> <b>uid=0</b>

       In this case, the user can type

              <b>super</b> <b>disable</b> <u>some_printer</u>

       The asterisk-replacement ability also lets a user execute any of an entire directory of commands, using a
       <u>super.tab</u> entry like the following:

              <b>op/*</b> <b>/usr/local/super/scripts/*</b> <b>:operators</b> <b>uid=0</b>

       <b>In</b> <b>this</b> <b>case,</b> <b>the</b> <b>user</b> <b>can</b> <b>type</b>

              <b>super</b> <b>op/</b><u>xyz</u>

       and <u>super</u> will execute <u>/usr/local/super/scripts/op/xyz.</u>

       The  asterisk-replacement  capability is useful but potentially dangerous, because it may unintentionally
       open the door to programs you hadn't intended to give away.  It is  a  sensible  precaution  to  restrict
       asterisk-replacement to entries where the valid-user list includes trusted users only.

       If you <u>completely</u> trust some users, but want logging of all actions executed as root, you could use:

              <b>/*</b>   <b>*</b>   <u>ReallyReallyTrustedUsers</u>
       or
              <b><a href="file:/.">/.</a>*</b>   <b>*</b>   <u>ReallyReallyTrustedUsers</u>

       (depending on whether <b>patterns=shell</b>, <b>patterns=regex</b>, or <b>patterns=posix</b>).

       The trusted users can now execute any command.  Note that the pattern begins with a slash, to ensure that
       the <u>cmd</u> must be an absolute path — this helps avoid accidental execs of the wrong program.

       If  you  were  really  going  to  give everything away as shown above, you'd probably want to exclude any
       public-area workstations, require the trusted users to periodically give their  passwords,  and  set  the
       real uid=root (instead of just the effective uid), so the entry might be modified to read something like:

              <b>/*</b>   <b>*</b>   <u>TrustedUsers</u> <b>\</b>
                       <b>!{</b><u>PatternsOfPublicWorkstations</u><b>}</b> <b>\</b>
                       <b>password=y</b> <b>timeout=5</b> <b>uid=0</b>

</pre><h4><b>The</b> <b>FullPath</b> <b>Field</b></h4><pre>
       The  <u>FullPath</u>  field  gives  the  name of the actual command that will be executed, and if it contains an
       asterisk, the asterisk is first replaced by the user's <u>cmd</u> string.  The <u>FullPath</u> can optionally contain a
       list of initial arguments that precede any arguments passed by the user.  For example,

              <b>xyz</b>  <b>"/usr/local/bin/blah</b> <b>-o1</b> <b>-o2</b> <b>-xrm</b> <b>'a</b> <b>b</b> <b>c'"</b> <b>...</b>

       specifies that when a valid user types <b>super</b> <b>xyz</b>, the command to execute is <b>/usr/local/bin/blah</b>  and  its
       arguments will be
              argv[1]: <b>-o1</b>
              argv[2]: <b>-o2</b>
              argv[3]: <b>-xrm</b>
              argv[4]: <b>a</b> <b>b</b> <b>c</b>
       followed  by  any  arguments  that the user put on the super command line.  Note: asterisk replacement is
       only done on the filename part of the <u>FullPath</u>, not on the arguments.  You can safely  include  asterisks
       in the argument list.  For security, the user's <u>cmd</u> may not contain any whitespace or backslashes.

       The  <u>FullPath</u>  string  is  parsed using rules similar to the Bourne shell rules for backslashes in quoted
       strings, namely:
              (a) backslash-newline is discarded;
              (b) Otherwise, if outside a quoted substring, <b>\</b><u>x</u> → plain  <u>x</u>,  which  will  not  be  treated  as  a
              delimiter, quotemark, or comment character;
              (c) Otherwise, inside a quoted substring of <u>FullPath</u>:
                     <b>\\</b> → <b>\</b>;
                     <b>\</b><u>q</u> → <u>q</u>, where <u>q</u> is the quote character that encloses the <u>FullPath</u> string;
                     other backslashes are preserved: <b>\x</b> → <b>\x</b>.

       After  writing  a command with such backslash escapes, you should certainly use ``<b>super</b> <b>-d</b> <b>cmd</b>'' to check
       that your args are being parsed as expected before you offer this command to your users.

       The same <u>cmd</u> can be listed several times in the <u>super.tab</u> file, in which case the first entry that allows
       the user to execute the command is chosen.  The EXAMPLES section shows how this can be useful.

</pre><h4><b>Permitted</b> <b>Users</b></h4><pre>
       Permitted users are those who may execute the specified <u>Cmd</u>'s.  Entries for any number of permitted users
       are given after the <u>CmdPat</u> and <u>FullPath</u> fields.  Local options — options that apply to this command  only
       —  may  also  appear anywhere after the <u>FullPath</u>.  Options are distinguished from permitted users because
       options all have the form <u>key</u>=<u>value</u>, whereas permitted-user  entries  may  not  contain  unescaped  equal
       signs.  Each whitespace-separated word is a pattern in one of the formats

            •    [<b>user~</b>]<u>user</u>[<b>:</b>][<b>@</b><u>host</u>]

            •    [<b>user~</b>]<b>:</b><u>group</u>[<b>@</b><u>host</u>]

            •    [<b>user~</b>]<u>user</u>[<b>:</b><u>group</u>][<b>@</b><u>host</u>]

       Note  that  the <b>user~</b> part is optional.  The user's login name must match the <u>user</u> pattern; the user must
       belong to a group whose name matches the <u>group</u> pattern; and the hostname must match the <u>host</u> pattern.  If
       the <u>user,</u> <u>group,</u> or <u>host</u> part is not given, there are no corresponding restrictions.

       If the user is root, <u>super</u> acts as if all permitted-user patterns are preceded by the pattern <b>user~root</b> —
       that is, root's rule is default-allow, instead of the default-deny rule  that  applies  to  all  ordinary
       users.

       By default, the ``group'' field is first matched against named groups to which the user belongs, and then
       against  the  user's decimal gid — this allows the user to be put in a group in the <a href="file:/etc/passwd">/etc/passwd</a> file that
       isn't given a name in the <a href="file:/etc/group">/etc/group</a> file.  (If you want to change the rules for using decimal  gid,  see
       the use of MATCH_DECIMAL_UID and MATCH_DECIMAL_GID in <u>super.c</u> for details.)

       Since  you  can  restrict  users  to  particular  hosts, a single <u>super.tab</u> file can be shared among many
       different machines.  If the <u>host</u> part is of the form <b>+</b><u>xyz</u><b>,</b> then <u>xyz</u> is interpreted as a netgroup name and
       any host in netgroup <u>xyz</u> is matched.  In that case, <u>xyz</u> is taken literally,  and  <u>not</u>  interpreted  as  a
       pattern to be matched.  Note: netgroup lookup is only implemented if the function <u>innetgr()</u> is available.

       If the <u>host</u> part doesn't match the hostname, it might be because the pattern and actual hostnames contain
       two  different  (but  both  valid)  incomplete  versions  of  the fully-qualified domain name (FQDN).  By
       default, if the <u>host</u> part fails to match the hostname, the FQDN is looked up  and  all  of  the  ways  of
       naming  the  host  are  matched  against the pattern.  For example, if the FQDN is <u>spacely.sprockets.com</u>,
       <b>super</b> will first try <u>spacely.sprockets.com</u>, then <u>spacely.sprockets</u>, and finally  <u>spacely</u>.   This  can  be
       turned off; see option <b>gethostbyname</b>.  (You might want to turn it off because using nameserver lookup can
       reduce security a bit — your host may query a nameserver on another host to obtain the FQDN, and (a) that
       nameserver  or  an  intermediate  host along the way could have been subverted, or (b) another host could
       impersonate the nameserver.  In either case your computer could receive incorrect hostnames.)

       The patterns for valid users, groups, and hosts follow the same rules for the <u>CmdPat</u>s,  described  above:
       they  can be entered with either <u>ed</u>-style or Bourne-shell-style patterns (depending on the setting of the
       <b>patterns</b> global option); csh-style brace expansion is allowed; and all pattern matching is  ``anchored'':
       patterns are forced to match the entire username, groupname, or hostname.

       To make it easy to exclude some users/groups/hosts, any of these patterns can be negated by prefixing the
       pattern  with  `<b>!</b>'.  If a negated pattern is matched, the user may <u>not</u> execute the command, even if there
       was a previous non-negated pattern that the user matched.  All patterns are read left-to-right,  and  the
       last matched pattern ``wins''.  Thus if the user/group/host list is

              <b>j.*</b> <b>!jo</b>
              or
              <b>user~j.*</b> <b>!user~jo</b>

       then  the first entry allows any username beginning with `<b>j</b>' to execute the command, but the second entry
       disallows user `<b>jo</b>'.  If entered in the reverse order,

              <b>!jo</b> <b>j.*</b>

       then the second entry, `<b>j.*</b>', allows all users beginning `<b>j</b>',  and  therefore  the  first  entry  has  no
       effect.

</pre><h4><b>Permitted</b> <b>Times</b></h4><pre>
       The  <b>time</b>  condition  restricts  the  days  and  times  during which this command may be matched.  If the
       execution time isn't acceptable, then super ignores the control line, and ``falls  through''  to  inspect
       the next entry, just as it does if the user/group/host aren't acceptable.  A time condition looks like:
            <b>time~</b><u>pattern</u>

       with <u>pattern</u>s that look like:

              <u>Pattern</u>                       <u>Example</u>
              <b>hh</b>[<b>:mm</b>]<b>-hh</b>[<b>:mm</b>][<b>/dayname</b>]     13:30-17/monday
              {<b>&lt;</b>,<b>&gt;</b>,<b>&lt;=</b>,<b>&gt;=</b>}<b>hh</b>[<b>:mm</b>][<b>/dayname</b>]  &lt;17/tues
              <b>dayname</b>                       Friday

       The  first  form explicitly specifies an interval during which the command may be used.  Times may not go
       past midnight; to specify the night between Monday and Tuesday, you must do something like:
              <b>time~{17:30-24:00/mon,0-8/tues}</b>

       The second form for time patterns allows you to use logical operators.  The  Monday-night  example  could
       equally have been rendered as:
              <b>time~{&gt;17:30/mon,&lt;8/tues}</b>
       (There  is  a  tiny  difference  in the two examples above: in the first example, the time range includes
       17:30 and 8:00; in the second example, the time range is 17:31-07:59.  Use <b>time~{&gt;=17:30/mon,&lt;=8/tues}</b> to
       make the interpretation identical to the first example.)

       If there are a series of time patterns, they are evaluated  left-to-right,  and  the  rightmost  matching
       pattern  is  used.   To  permit execution between 17:30 Monday and 8:00 Tuesday, but exclude 0:00 to 1:00
       Tuesday, use:
              <b>time~{&gt;=17:30/mon,&lt;=8/tues}</b>  <b>!time~{0-1/tues}</b>

       By default, valid <u>dayname</u>s are English, but if your system supports the <u>setlocale(</u>3<u>)</u> function, the global
       option <b>lang=</b><u>zzz</u> will set the valid names to those of locale <u>zzz</u>.  Valid <u>dayname</u>s are either (a) the  full
       names  of  the  chosen  language; (b) an official abbreviated day name for that language; (c) a 3-or-more
       character abbreviation of the full weekday; or (d) <b>*</b>, meaning any day.  (You can check on  super's  valid
       daynames  by  executing <u>super</u> <u>-d</u>, which will show the default names of the weekdays at or near the top of
       its debugging output, and show the new weekday names  that  take  effect  when  the  <b>lang=</b><u>zzz</u>  option  is
       encountered.)

       Time  patterns  have  a special defaulting rule when the execution time is not in one of the intervals in
       the time list:
              • if <u>all</u> time patterns are negated, <u>super</u> permits execution at any time not in one of  the  listed
              intervals;
              •  otherwise,  there  is at least one non-negated pattern, and <u>super</u> defaults to deny execution at
              times outside the specified acceptable intervals.
       The reason is that the natural interpretation of a series of negated conditions, such as
              <b>!time~{0-8,17-24}</b> <b>!time~{sat,sun}</b>
       is to infer that all other times are acceptable for execution.  On the  other  hand,  if  there  are  any
       ordinary, non-negated times, such as
              <b>time~8-17/{mon,tues,wed,thu,fri}</b>
       the natural interpretation is that any times not explicitly mentioned are not acceptable.

       Note  that  explicit  braces  are  important in the above list.  If they were missing, the implied braces
       around the entire pattern would render this equivalent to
              <b>time~8-17/mon</b> <b>time~tues</b> <b>time~wed</b> <b>time~thu</b> <b>time~fri</b>
       That is, the permitted times are 8-17h on Monday, and any time on Tuesday through Friday.

</pre><h4><b>Global</b> <b>Conditions</b></h4><pre>
       Global options and conditions affect the overall <b>super</b> processing.  To set them, you must use a line like

              <b>:global</b>             <u>Global</u> <u>Options</u> <u>And</u> <u>Patterns</u>
       or
              <b>:global_options</b>     <u>Global</u> <u>Options</u> <u>And</u> <u>Patterns</u>

       For backwards compatibility, you can alternatively use

              <b>/</b>         <b>/</b>         <u>GlobalOptionsAndPatterns</u>

       but this use is discouraged.

       These so-called ``global'' options and conditions actually take effect  immediately  after  the  line  on
       which  they  appear,  and  are valid until the end of the input or until there is a countermanding global
       option or pattern.  To have a global option or pattern affect the entire file, you must place it  as  the
       <u>first</u> <u>non-comment</u> <u>line</u> of the <u>super.tab</u> file.

       If  there are any PermittedUser or PermittedTime conditions on the global settings line, they are applied
       to each following command in the <u>super.tab</u> file.  The conditions look like

              <b>:global</b>   <u>cond</u> <u>cond</u> <u>...</u>  <b>&lt;&gt;</b> <u>cond</u> <u>cond</u> <u>...</u>

       PermittedUser and PermittedTime conditions to the left of ``<b>&lt;&gt;</b>'' are processed  <u>before</u>  the  local  (per-
       command)  conditions;  conditions  to the right of ``<b>&lt;&gt;</b>'' are processed <u>after</u> the per-command conditions.
       If ``<b>&lt;&gt;</b>'' is missing, all conditions are processed after the local conditions.  Example 1:

              <b>:global</b>   <b>jan</b> <b>&lt;&gt;</b> <b>!@+badhosts</b>

       says that user <u>jan</u> can usually execute any command, but under no circumstances will a user on any host in
       netgroup <u>badhosts</u> be allowed to execute any command.  (User <u>jan</u> will not be allowed to execute a  command
       if the per-command conditions disallow it, or if <u>jan</u> is on one of the <u>badhosts</u> computers).

       Example 2:
              <b>:global</b>   <b>!root</b> <b>&lt;&gt;</b>

       changes  <u>root</u>'s  default setting from default-allow to default-deny, just like ordinary users.  Root will
       only be given execute permission for entries that explicitly allow root on the per-entry line.

       Global PermittedUser (PermittedTime) conditions take effect on the line on which they  are  defined,  and
       are  good  until  another  set  of  global PermittedUser (PermittedTime) conditions is entered on another
       <b>:global_option</b> line.  That is, a new global condition line replaces any previous global conditions.

       One sensible approach to using global conditions is  to  put  conditions  that  allow  users  to  execute
       commands   <u>before</u>   the  per-command  conditions  are  processed,  and  to  put  negating  patterns  (for
       users/groups/hosts that are never to be allowed to execute anything) <u>after</u> the per-command conditions.

       (Global options are discussed below, together with local options).

</pre><h4><b>Conditionally-included</b> <b>Control</b> <b>Lines</b></h4><pre>
       Control lines can be conditionally included by using the <b>:if</b> control line.   This  can  be  helpful  when
       using  a single <u>super.tab</u> file for hosts with different architectures, or hosts in different NIS domains,
       etc.  The syntax is:

              <b>:if</b>  <u>left</u>   <u>op</u>   <u>right</u>     <u>moreText</u>

       <u>The</u> <u>expression</u> <u>left</u> <u>op</u> <u>right</u> is evaluated, and if true, <u>moreText</u> is  evaluated  as  an  ordinary  control
       line.  The valid comparison operators are:

            •    ==   string equality
            •    !=   string inequality
            •    ~    glob match string <u>left</u> against pattern <u>right</u>
            •    !~   negated glob-match.
       For example, you could include a file of commands only valid on Sun4-type machines as follows:

              <b>:if</b> <b>$UNAME_MACHINE</b> <b>~</b> <b>sun*</b> <b>\</b>
                       <b>:include</b>  <b>/Path/To/Sun4/File</b>
       (UNAME_MACHINE is a variable automatically defined by <u>super</u>; see the following section on variables.)

       If you wanted to exclude Sun4c-type machines from using the file, you could modify this to be:

              <b>:if</b> <b>$UNAME_MACHINE</b> <b>~</b> <b>sun*</b> <b>\</b>
                  <b>:if</b> <b>$UNAME_MACHINE</b> <b>!=</b> <b>sun4c</b> <b>\</b>
                       <b>:include</b>  <b>/Path/To/Sun4/File</b>

       There  are  no  boolean  operators  provided, but note that there is an implicit boolean <b>and</b> available by
       concatenating <b>:if</b> commands, as shown in the second example above.

</pre><h4><b>Variables</b></h4><pre>
       <b>Super</b> offers variables to make it easier to handle entries that are duplicated or are constructed out  of
       other entries.  Variables are defined by typing

              <b>:define</b> <b>VariableName</b> <b>VariableDefinition</b>

       or they may be imported from the environment by using

              <b>:getenv</b> <u>[</u><b>EnvVarName</b><u>...]</u>

       If  you  use  the <b>:getenv</b> command, then the values of any imported environment variables may only contain
       the following ``safe'' characters: <b>-/:+._a-zA-Z0-9.</b>  If ``bad'' characters are  found  in  a  value,  the
       entire  value  is  replaced  with  an  empty string.  Note that these imported variables do <u>not</u> enter the
       environment of any executed command; they simply become part of the super.tab variable set.

       The <u>VariableName</u> should be made up only of letters, digits, and/or underscore.  (You can actually use any
       characters you wish, but super doesn't promise to work  correctly  if  you  use  characters  outside  the
       standard set.)

       The  <u>VariableDefinition</u> begins at the first non-whitespace character after the <u>VariableName</u> and continues
       up to but not including the final newline.  Comments embedded on  the  variable  definition  line(s)  are
       deleted before the variable definition is stored.  A variable definition may be continued across multiple
       lines  by  preceding  each newline with a backslash, and indenting the continuation line with whitespace.
       Just as for regular control lines, the backslash-newline-whitespace sequence is treated as whitespace  if
       it follows a letter, digit, or underscore; otherwise, it is eliminated.  For example,

              <b>:define</b>  <b>Users</b>   <b>user1,\</b>
                               <b>user2,\</b>
                               <b>user3</b>
       <b>and</b>
              <b>:define</b> <b>Users</b>   <b>user1,user2,user3</b>

       are equivalent definitions.

       Unlike  Makefiles, the variable definitions are not scanned first and then the file re-scanned.  Instead,
       variables take effect at the point they are defined, and remain in effect until they  are  re-defined  or
       end of file — thus variables definitions must precede their first use in the file.

       Variables  may  contain other variables (which must have already been defined).  Variable substitution is
       done when a line is first read.  A line is never re-scanned after variable substitution.

       Variables are used in a file by typing

              <b>$VariableName</b>

       or

              <b>$(VariableName)</b>

       The special variable <b>$$</b> is replaced by a single ``<b>$</b>''.  Any other name <b>$</b><u>X</u>  (where  <u>X</u>  is  not  a  letter,
       digit, or underscore) is an error.

       Because a line is never re-scanned after variable substitution, the following sequence:

              <b>:define</b> <b>A</b> <b>$$</b>
              <b>:define</b> <b>B</b> <b>A</b>
              <b>:define</b> <b>C</b> <b>$B</b> <b>$$B</b>
              <b>$C</b>

       defines <b>C</b> to be simply ``<b>A</b> <b>$B</b>''.

       Variables  can be helpful in grouping users or hosts together.  For example, you might restrict access to
       a command so that it can't be run from a public-access workstation:
              <b>:define</b> <b>Room103_WS</b> <b>hosta,hostb,hostc,hostd</b>
              <b>:define</b> <b>Room105_WS</b> <b>hoste,hostf,hostg,hosth</b>
              <b>:define</b> <b>Room106_WS</b> <b>+nonprivate</b>
              <b>:define</b> <b>PublicWorkstations</b> <b>$Room103_WS,$Room105_WS,$Room106_WS</b>
              <b>SomeCmd</b> <b>FullPathHere</b> <b>!@$(PublicWorkstations)</b>

       In the above example, we have taken advantage of the implied braces that are  always  placed  around  any
       pattern,   so   that   the   comma-separated   list   of  workstations  is  brace-expanded  into  <b>!@hosta</b>
       <b>!@hostb</b> <b>...</b> <b>!@hoste</b> <b>!@hostf</b> <b>...</b> <b>!@+nonprivate</b>.

       Some variables are automatically defined by <u>super.</u>

       After super determines whether  it  is  processing  a  per-user  .supertab  (see  <a href="../man1/super.1.html">super</a>(1)),  it  defines
       <b>IS_USERTAB</b>  to  be  ``<u>yes</u>''  if <u>super</u> is processing a per-user .supertab file, and ``<u>no</u>'' otherwise.  The
       allows the super.init to act differently depending on how it is being invoked.

       When the top-level <u>super.tab</u> file is opened, <b>SUPER_OWNER</b> is set to the  login  name  of  the  owner,  and
       <b>SUPER_HOME</b>  is  set  to the home directory of the owner.  This can be useful in per-user <u>.supertab</u> files,
       especially when they include files shared among several accounts.  For example, each  person's  <u>.supertab</u>
       file could be simply

              <b>:include</b> <b>/opt/proj/common.supertab</b> <b>owner=cristy</b>

       Then, the <u>/opt/proj/common.supertab</u> file can use entries like the following:

              <b>:global</b> <b>logfile=$SUPER_HOME/.superlog</b>
              <b>*</b> <b>/project/tools/$SUPER_OWNER/*</b> <b>:toolgroup</b>

       Because the <b>SUPER_HOME</b> and <b>SUPER_OWNER</b> variables apply to the top-level per-user files, they always refer
       to per-user locations.

       Super defines the built-in variable <b>CALLER</b> to be the the login name of the of account invoking super, and
       <b>CALLER_HOME</b> <b>is</b> <b>the</b> <b>home</b> <b>directory</b> <b>of</b> <b>$CALLER</b>.  Sample use:
              <b>sam</b>  <b>/usr/sbin/sam</b>  <b>group~operator</b>  <b>uid=0</b> <b>\</b>
                                  <b>env=DISPLAY</b> <b>\</b>
                                  <b>setenv=XAUTHORITY=$CALLER_HOME/.Xauthority</b>
       Here,  the  <u>operator</u> group can execute <u>sam</u> as root, and the GUI will display at the caller's display (due
       to the use of <b>env=DISPLAY</b>).  Since the XAUTHORITY environment variable is set to the caller's <u>.Xauthority</u>
       file, this will give the caller access to the same display(s) to which s/he already has access.

       The following variables are defined when super starts up.  They can be useful  in  conditionally-included
       lines  (<b>:if</b>  lines).   If your host doesn't supply these functions, or doesn't support some of the values
       that <u>super</u> tries to fetch, the corresponding variable will be  initialized  to  an  empty  string.   (Use
       <b>super</b> <b>-b</b>  to  print  the  names  and  values  of all builtin variables.  This makes it simple to see what
       variable values to check in <b>:if</b> lines.)

       From the <u>gethostname()</u> or <u>sysinfo()</u> function:
            • HOSTNAME            Hostname, possibly canonicalized.
            • HOST                Hostname, short (unqualified).

       From the <u>getdomainname()</u> function:
            • NIS_DOMAIN          domain set for NIS purposes.

       From the <u>sysinfo()</u> function:
            • SI_SYSNAME          Name of operating system.
            • SI_HOSTNAME         Name of node.
            • SI_RELEASE          Release of operating system.
            • SI_VERSION          Version field of utsname.
            • SI_MACHINE          Kind of machine.
            • SI_ARCHITECTURE     Instruction set arch.
            • SI_HW_SERIAL        Hardware serial number.
            • SI_HW_PROVIDER      Hardware manufacturer.
            • SI_SRPC_DOMAIN      Secure RPC domain.
            •

       From the <u>uname()</u> function:
            • UNAME_SYSNAME       Operating system name.
            • UNAME_NODENAME      The nodename.
            • UNAME_RELEASE       Operating system release.
            • UNAME_VERSION       Operating system version.
            • UNAME_MACHINE       Machine hardware name (class).

</pre><h4><b>Options</b></h4><pre>
       The configuration file can specify a wide variety of options,  such  as  requiring  the  user's  password
       before executing some commands, or restricting the command-line arguments to match certain patterns.

       <u>Options</u>  are  handled  very differently from <u>conditions</u> (conditions include user, group, host, and time).
       If a control line's conditions aren't met, super falls through and tries the next  control  line  in  the
       file.   After  finding  an  acceptable  control  line,  super will execute the command if the options are
       satisfied; otherwise, it stops and doesn't search the <u>super.tab</u> file any further.

       Options can be divided into (a) <u>local</u> options, which are defined on a regular  control  line,  and  apply
       only  to  that  control  line;  and (b) <u>global</u> options, which are defined on a <b>:global</b> or <b>:global_options</b>
       line, take effect immediately after the line, and are valid until the end of the input or until there  is
       a countermanding global option or pattern.

       All options are orthogonal to each other.  It doesn't matter in what order they appear on a control line.

       Some  options  can  be  given  as  either  local  or global options.  If both are used, the local setting
       overrides the global one.

       Two special names can be used with any of  the  options  that  take  user  or  group  ids  as  arguments:
       <b>owner=</b><u>xxx,</u>  <b>uid=</b><u>xxx,</u>  <b>euid=</b><u>xxx,</u>  <b>gid=</b><u>xxx,</u>  <b>egid=</b><u>xxx,</u> <b>u+g=</b><u>xxx,</u> <b>groups=</b><u>xxx,</u> <b>addgroups=</b><u>xxx.</u>  These names are
       <b>&lt;owner&gt;</b>, meaning the owner of the file to be executed (or the owner's group, whichever is appropriate  in
       the context); and <b>&lt;caller&gt;</b>, meaning the owner or group of the user calling super.  The angle brackets are
       literally  part  of the name.  These have the same values as the built-in variables <b>CALLER</b> and <b>OWNER</b> (see
       the <u>Variables</u> section, above).  For example, the options
              gid=Foo uid=&lt;caller&gt;
       would change the group to <u>Foo</u>, but leave the uid unchanged.

       The recognized options are:

       <u>Group</u> <u>1.</u>  <u>Options</u> <u>Affecting</u> <u>How</u> <u>Superfiles</u> <u>Are</u> <u>Read</u> <u>and</u> <u>Processed.</u>

       <b>patterns=</b><u>xxx</u>
              <b>(Global)</b> Specifies the pattern-matching type for conditions and options.  The string <u>xxx</u>  must  be
              one of:

              <b>posix</b>  —  patterns  are  POSIX  regular  expressions.  You can use ``<b>posix/extended</b>'' for extended
                     regular  expressions;  ``<b>posix/icase</b>''  for  case-insensitive   regular   expressions;   or
                     ``<b>posix/extended/icase</b>'' for both.  See your regular-expression man pages for details.

              <b>regex</b>  —  patterns  are  ed-style  regular  expressions,  using  the rules embodied in the BSD 4.x
                     routines <u>re_comp()/re_exec()</u>, with the addition of csh-style brace expansion.  This is  the
                     default  for  historical  reasons, but most people prefer to use shell-style patterns here,
                     and it is recommended that you put <b>patterns=shell</b> (see below) in your global options  list.

              <b>shell</b>  —  patterns  are  approximately  Bourne-shell  style,  with the addition of csh-style brace
                     expansion and the special <b>[[</b><u>chars</u><b>]]</b> pattern.  The patterns are formed from:

                     \x   force x to be a plain character;

                     ?    matches any single character;

                     *    matches any sequence of 0 or more chars;

                     [<u>chars</u>]   matches any single character in the set;

                     [^<u>chars</u>]  matches any single char NOT in the set;

                     [[<u>chars</u>]] When the pattern begins with <b>[[</b>, and ends with <b>]]</b>, then each and every  character
                            in  the string must match the ordinary square-bracket pattern <b>[</b><u>chars</u><b>]</b> (or <b>[</b>^<u>chars</u><b>]</b>).

                     ^<u>pat</u> inverts the sense of the match — the string must NOT match the pattern.

       <b>lang=</b><u>zzz</u>
              <b>(Global)</b> This option sets the language used for weekdays (in time conditions).  Here, <u>zzz</u>  may  be
              any locale available on your host.  For example, <b>lang=de</b> would typically cause <u>super</u> to use German
              names.  The default is the <b>C</b> locale, hence English names.

       <b>relative_path=</b><u>y</u>|<u>n</u>
              <b>(Global)</b>  If <u>y</u>, FullPathNames can be relative instead of absolute.  By default this is disallowed,
              because it is almost always a very foolish (unsafe) thing to do.

       <b>group_slash=</b><u>y</u>|<u>n</u>
              <b>(Global)</b> If <u>y</u>, group names can contain a slash.  By default this is disallowed, so that <b>super</b>  can
              catch  certain  typos in the <u>super.tab</u> file.  (Namely, <b>super</b> can catch errors in which an entry is
              of the form <u>Cmd</u><b>:</b><u>File</u> instead of the required  <u>Cmd</u><b>::</b><u>File.</u>   The  trouble  is  that  <u>Cmd</u><b>:</b><u>File</u>  looks
              syntactically  like  <u>user</u><b>:</b><u>group,</u> and can therefore be mistaken for a valid part of a control line.
              But the filename will contain a slash — unless you have unwisely enabled the <b>relative_path</b>  option
              — so disallowing slashes allows <b>super</b> to flag the line as syntactically invalid.)

       <b>gethostbyname=</b><u>y</u>|<u>n</u>
              <b>(Global)</b>  Enables  or  disables the use of <u>gethostbyname()</u> to find the fully-qualified domain name
              (see the discussion in the <b>Permitted</b> <b>Users</b> section, which describes the security issues associated
              with enabling this option.)  Default: enabled (if your host supports gethostbyname()).

       <u>Group</u> <u>2.</u>  <u>Logging</u> <u>Options.</u>

       <b>logfile=</b><u>fname</u>
              <b>(Global)</b> Enables logging to a local file.  Each invocation of <b>super</b> (aside  from  ones  for  help)
              generates an entry in file <u>fname</u>.

       <b>loguid=</b><u>xxx</u>
              <b>(Global)</b>  If  logging  is enabled with logfile=<u>fname</u>, the logfile will be opened for writing using
              uid=<u>xxx</u> (can be either a username or numeric uid).  This  option  allows  you  to  have  the  file
              created/opened  under  another  uid  that does have cross-host access, such as the uid of a system
              manager.  (See <u>timestampuid=xxx</u> for additional comments).  Default: loguid=0.

       <b>mail="</b><u>mail-command</u><b>"</b>
              <b>(Local|Global)</b> Notices of super failures are piped to the shell  command  <u>mail-command</u>.   This  is
              independent  of  the setting of the <b>logfile</b> and <b>syslog</b> options.  For instance, <u>mail="mail</u> <u>-s</u> <u>Super</u>
              <u>joeblow"</u> will cause error messages to be mailed to user <u>joeblow</u> (on some systems you may  need  to
              substitute  <u>mailx</u>  for  <u>mail</u>).  Note: the <u>mail-command</u> is executed by passing it as an argument to
              <u><a href="../man3/popen.3.html">popen</a>(3)</u>.  This is safe to execute because of the clean environment assured by <b>super.</b>

       <b>mailany="</b><u>mail-command</u><b>"</b>
              <b>(Local|Global)</b> This is identical to the <u>mail</u> option, except that  <u>mailany</u>  sends  notification  of
              successful invocations as well as errors.

       <b>rlog_host=</b><u>hostname</u>
              <b>(Global)</b> Tells super which host's syslog daemon is to receive log messages when option <b>syslog=y</b> is
              enabled.   The option has no effect if used after the first message is logged: once the logger has
              been opened, it is not re-opened if the <b>rlog_host</b> is changed.  Default: the local host.  Note: One
              could instead configure the <u>syslog.conf</u> file to forward the messages to a central machine.

       <b>syslog=</b><u>y</u>|<u>n</u>
              <b>(Global)</b> Logging information is passed to the logs maintained by  the  <u>syslogd</u>  daemon.   This  is
              independent of the setting of the <b>logfile</b> option (above).  Error messages are by default logged at
              priority  LOG_ERR  and  successful attempts to run programs are logged at priority LOG_INFO.  (See
              options <u>syslog_error</u> and <u>syslog_success</u> to change these levels.)

       <b>syslog_error=</b><u>xxx</u>
              <b>(Global)</b> If syslog is enabled (see the <u>syslog</u> option), then by default super logs  error  messages
              using  <u><a href="../man3/syslog.3.html">syslog</a>(3)</u> code <b>LOG_ERR.</b>  This option changes the code to <u>xxx</u>, where <u>xxx</u> is any of the usual
              <u><a href="../man3/syslog.3.html">syslog</a>(3)</u> priority and/or facility codes, such as <b>LOG_WARNING</b> or <b>LOG_LOCAL7|LOG_ERR</b>.  The  <b>LOG_</b><u>xxx</u>
              words  can  be  separated  by  whitespace, dot, and/or ``|'', but of course you must use quotes if
              whitespace is included.  The leading "LOG_" is optional, and the value is  case-insensitive.   For
              example,  <b>LOG_LOCAL7|LOG_ERR</b>  can alternatively be written as <b>local7.err</b>.  Super doesn't know what
              are sensible codes — it's up to the <u>super.tab</u> writer to choose meaningful values.   For  instance,
              if you put
                   <b>syslog_error="LOG_INFO</b> <b>|</b> <b>LOG_ERR"</b> <u>(bad!)</u>
              then you will get both those values or'd together and passed to <u>syslog().</u>

       <b>syslog_success=</b><u>xxx</u>
              <b>(Global)</b>  This  option  is  just like <b>syslog_error</b>, except that it applies to successful-execution
              messages instead of error messages.  Default: <b>LOG_INFO</b> <b>.</b>

       <u>Group</u> <u>3.</u>  <u>Extra</u> <u>Help</u> <u>Information</u> <u>for</u> <u>Users.</u>

       <b>info=</b><u>xxx</u>
              <b>(Local)</b> The string <u>xxx</u> is printed when giving help to users.  It should be set to a  helpful  one-
              line description of the command.

       <u>Group</u> <u>4.</u>  <u>Password</u> <u>and</u> <u>Other</u> <u>Restrictions</u> <u>Before</u> <u>Approval.</u>

       <b>maxlen=</b>[<u>mmm</u><b>,</b>]<u>nnn</u>
              <b>(Local|Global)</b>  Each  argument must be no more than <u>mmm</u> characters long (including the terminating
              null), and the sum length of all arguments must not exceed <u>nnn</u> characters.  A negative value means
              that no limit is applied.  The defaults for <u>mmm</u> and <u>nnn</u>  are  set  by  the  compile-time  manifest
              constants MAXLEN1ARG and MAXLENARGS, which are usually 1000 and 10,000 characters, respectively.

       <b>nargs=</b>[<u>mmm</u><b>-</b>]<u>nnn</u>
              <b>(Local|Global)</b>  The  user is required to enter <u>mmm</u> <u>-</u> <u>nnn</u> arguments to the command.  If just <u>nnn</u> is
              given, the user must enter exactly  <u>nnn</u>  arguments.   These  arguments  are  in  addition  to  any
              arguments  entered in the command part of the <u>super.tab</u> file.  The default is to allow the user to
              enter any number of arguments.

       <b>arg</b>[<u>mmm</u><b>-</b>]<u>nnn</u><b>=</b><u>sss</u>
              <b>(Local|Global)</b> This means that  the  <u>nnn</u>'th  or  <u>mmm-nnn</u>'th  arguments  must  match  pattern  <u>sss</u>.
              (Arguments  are  numbered  from 1.)   The  pattern  must  be  enclosed  in  quotes  if it contains
              whitespace.  Note that this option does not <u>require</u> that there be <u>mmm</u>-<u>nnn</u> arguments; it only  says
              what  those  arguments  must  look like, if entered.  You can use this option several times on one
              line, with different <u>mmm</u>-<u>nnn</u> values each time, to apply different patterns to different arguments.
              If more than one pattern applies to a given argument, all of those patterns must be  matched.   An
              empty pattern ("") is special: it has the effect of <u>unsetting</u> (removing) any previous patterns for
              the  matching  [<u>mmm</u>-]<u>nnn</u>.   This  can be useful if you want to change <b>:global</b> settings, instead of
              adding to them.  If there are local <b>arg</b>[<u>mmm</u><b>-</b>]<u>nnn</u> option(s), they  completely  replace  all  global
              <b>arg</b>[<u>mmm</u><b>-</b>]<u>nnn</u> values, even if the local <u>mmm</u>-<u>nnn</u> values do not overlap with the global values.

       <b>owner=</b><u>xxx</u>
              <b>(Local|Global)</b> This option specifies that the <u>FullPath</u> (after asterisk-substitution) must be owned
              by user (or uid) <u>xxx</u>, or else it won't be executed.

       <b>auth=</b><u>y</u>|<u>n</u>
              <b>(Local|Global)</b>  If <u>y</u>, user authentication is required before the command is executed.  The default
              authentication method is Unix password authentication.  See also the options <u>authprompt</u>, <u>authtype</u>,
              <u>authuser</u>, <u>timeout</u>, and <u>renewtime</u>, and be sure to read the warning under <u>timestampbyhost.</u>

       <b>authprompt=</b><u>message</u>
              <b>(Local|Global)</b> Specifies the prompt used when authenticating the user (usually the default  prompt
              is fine).  Variable substitution is done on the prompt before printing.

       <b>authtype=</b><u>type</u>
              <b>(Local|Global)</b> Specifies the type of authentication used when <u>auth=y</u>.  The <u>type</u> can be <b>password</b> or
              <b>pam</b>  (if  PAM  is  supported  on your system).  The default is <b>password</b>.  If PAM authentication is
              used, <u>super</u> uses the service name ``<b>super</b>'' when looking for authentication  in  your  system  PAM
              configuration files.

       <b>authuser=</b><u>username</u>
              <b>(Local|Global)</b>  Specifies  the  user whose authentication is required when <u>auth=y</u>.  The default is
              the password (or other authentication) for the user who invoked super.

       <b>password=</b><u>y</u>|<u>n</u>
              <b>(Local|Global)</b> This is a deprecated option; it has been replaced by the <u>auth</u> and <u>authtype</u> options.
              <b>Password=y</b> is equivalent to <b>auth=y</b> <b>authtype=password</b> ; and <b>Password=n</b> is equivalent to <b>auth=n.</b>

       <b>renewtime=</b><u>y</u>|<u>n</u>
              <b>(Global)</b>  If  <u>y</u>,  the  user's  timestamp  file  is  updated  to  the  current  time  whenever   an
              authentication-requiring  command  is executed.  The result is that a user who frequently executes
              authentication-requiring commands won't need to re-authenticate until more  than  <u>timeout</u>  minutes
              elapse  since  the  last  such  command.  Otherwise, the user will need to re-authenticate <u>timeout</u>
              minutes after last entering the password.  The default is <u>n</u>.

       <b>timeout=</b><u>m</u>
              <b>(Local|Global)</b> User authentication is good for <u>m</u> minutes; that is, the  command  may  be  executed
              without  re-authenticating  for  <u>m</u>  minutes  after  the previous authentication (for any command).
              After <u>m</u> minutes, user authentication will be required again before the command  can  be  executed.
              If  <u>timeout</u>  is  zero or negative, authentication is required every time the command is used.  The
              timestamp for user <u>usr</u> is recorded in the file <b>TIMESTAMP_DIR</b> directory  (see  <b>timestampbyhost</b>  and
              the FILES section, below).

       <b>timestampbyhost=</b><u>y</u>|<u>n</u>
              <b>(Global)</b>  If  <u>y</u>  (default), the timestamp files are given names that are unique on each host.  For
              instance, <u>jouser@somehost</u> will be given  a  timestamp  file  named  <u>TIMESTAMP_DIR/somehost/jouser</u>,
              where  <u>TIMESTAMP_DIR</u>  is  defined in the FILES section.  If <u>timestmapbyhost=n</u>, the timestamp files
              are given names that are unique to each user, but not unique per host.  For  instance,  <u>jouser</u>  on
              any host will be given a timestamp file named <u>TIMESTAMP_DIR/jouser</u>.
              <u>WARNING:</u>  The  hostname used is that from <u>gethostname().</u>  Note that this is not necessarily unique
              across internet domains, since it is frequently not a fully-qualified domain name.  Therefore  you
              should  not  share  timestamp  directories  with  hosts outside the local domain.  (Generally such
              connections don't exist, but one <u>could</u> crossmount the timestamp directory disk...)

       <b>timestampuid=</b><u>xxx</u>
              If a password is required, the time at which it  was  entered  is  recorded  as  the  mtime  of  a
              timestamp  file.   The  timestamp  file  is normally created with owner=root; however, this option
              causes it to be created/modified using uid=<u>xxx</u> (<u>xxx</u> can be either  a  username  or  numeric  uid).
              This  option  is  useful  when a network of hosts are sharing a cross-mounted timestamp directory.
              Note that networks are typically configured to not allow root on one host to have root  access  to
              files  on  another  host,  which  will forbid root on other hosts from creating the timestamp file
              unless it's world-writable.  This option allows you to have the file created/opened under  another
              uid  that  does  have  cross-host  access,  such  as  the  uid  of  a  system  manager.   Default:
              timestampuid=0.

       <b>checkvar=</b><u>name</u>[,...]
              <b>(Local)</b> Each <u>name</u> in the comma-separated list is a <u>super.tab</u> variable which the user must enter at
              a prompt from <u>super.</u>  For example, you might  have  a  <b>super</b>  <b>shutdown</b>  command  which  halts  the
              computer.   If  you  execute this on the wrong host there may be some very annoyed users!  So, you
              can include <b>checkvar=HOST</b>, and the user will have to type the correct hostname in  response  to  a
              prompt from <u>super.</u>

       <u>Group</u> <u>5.</u>  <u>Modifications</u> <u>to</u> <u>Environment</u> <u>Before</u> <u>Executing</u> <u>Command.</u>

       <b>uid=</b><u>xxx</u>
              <b>(Local)</b>  Sets  the  real uid to <u>xxx</u> just before executing the command.  If option <b>euid</b> isn't used,
              also sets the effective uid to <u>xxx</u>.  The uid <u>xxx</u> is first tried as a login  name  and  then  as  a
              number.   If  the  options  <b>uid</b><u>=xxx</u> and <b>u+g</b><u>=yyy</u> (see below) are used together, then the <b>u+g</b> option
              only sets the group id, and not the user id.

       <b>euid=</b><u>xxx</u>
              <b>(Local)</b> Sets the effective uid to <u>xxx</u> just before executing the command.  The  uid  <u>xxx</u>  is  first
              tried as a login name and then as a number.

       <b>gid=</b><u>yyy</u>
              <b>(Local)</b>  Sets  the  real gid to <u>yyy</u> just before executing the command.  If option <b>egid</b> isn't used,
              also sets the effective gid to <u>yyy</u>.  The gid <u>yyy</u> is first tried as a group  name  and  then  as  a
              number.

       <b>egid=</b><u>yyy</u>
              <b>(Local)</b>  Sets  the  effective  gid to <u>yyy</u> just before executing the command.  The gid <u>yyy</u> is first
              tried as a group name and then as a number.

       <b>u+g=</b><u>zzz</u>
              <b>(Local)</b> Sets the real uid to <u>zzz</u>, the real gid to <u>zzz</u>'s login gid, and  the  supplementary  groups
              list  to  <u>zzz</u>'s  supplementary  groups just before executing the command.  If the <b>euid</b> and/or <b>egid</b>
              option aren't given, the effective uid and/or gid are also  set.   The  options  <u>u+g</u>  and  <b>gid=yyy</b>
              conflict with each other, and may not be used together.

       <b>groups=</b><u>name</u>[,...]
              <b>(Local|Global)</b>  By  default,  the  user's  supplementary groups list is deleted before executing a
              command (unless the option <b>u+g</b> is used).  This option instead sets the group list to <u>name</u>[,...]

       <b>addgroups=</b><u>name</u>[,...]
              <b>(Local|Global)</b> This option adds the listed groups to the supplementary  groups  list.   Since  the
              default  is to provide an empty supplementary groups list, this option usually has the same effect
              as the plain <b>groups</b> option.  However, if the options <b>u+g=</b><u>foo</u> <b>addgroups=</b><u>a,b,c</u> are  used,  then  the
              supplementary groups list is composed of user <u>foo</u>'s supplementary groups plus <u>a,</u> <u>b</u>, and <u>c</u>.

       <b>argv0=</b><u>name</u>
              <b>(Local)</b>  Execute  the  command  will  execute  with  its  first  argument  (that  is, the argument
              conventionally denoted as <u>argv[0]</u>), set to <u>name</u>.  As a convenient shorthand, the value <b>&lt;path&gt;</b> (the
              angle brackets are literally part of the  name)  means  to  use  the  <u>FullPath</u>  specified  in  the
              <u>super.tab</u>  file.   By default, <u>argv[0]</u> is set to <u>Cmd</u>, the name of the <u>super</u> command invoked by the
              user, regardless of the actual path being invoked.  However, some programs will not  run  properly
              unless  <u>argv[0]</u>  has  a particular value.  For example, suppose you want to permit users to safely
              mount zip disks, and you use something like:
                   <b>zipmount</b> "/etc/mount -o nosuid /dev/xz10  /zip"
              This command will fail if <u>/etc/mount</u> requires that it be invoked with <u>argv[0]</u> set to  [<u>.../</u>]<u>mount,</u>
              because  <u>super</u>  will use the name <u>zipmount.</u>  However, you can put <b>argv0=&lt;path&gt;</b> into your super.tab
              file, and then the mount command will work properly.

       <b>env=</b><u>name</u>[,...]
              <b>(Global|Local)</b> Each <u>name</u> in the comma-separated list is an environment variable which  should  <u>not</u>
              be  deleted  before  executing  the  <u>Cmd</u>;  these variables are in addition to the normal variables
              created or passed by <b>super</b>  (TERM,  IFS,  PATH,  USER,  LOGNAME,  HOME,  ORIG_USER,  ORIG_LOGNAME,
              ORIG_HOME,  LINES,  COLUMNS,  SUPERCMD).   Be careful here; environment variables can sometimes be
              abused to create security holes.  If you use  the  option  more  than  once,  the  later  instance
              overrides  the  earlier  one,  instead  of  adding  to  it.  Similarly, using it as a local option
              completely overrides any global setting.

       <b>maxenvlen=nnn</b>
              <b>(Global|Local)</b> Specifies the maximum length of an environment variable definition (including name,
              equal sign, value, and trailing null  character).   The  default  is  given  by  the  compile-time
              manifest constant MAXENVLEN, usually 1000 characters.  A negative value means no limit.

       <b>cd=</b><u>dir</u>
              <b>(Local|Global)</b> Just before executing the command, <u>super</u> changes the working directory to <u>dir</u>.

       <b>setenv=</b><u>var</u><b>=</b><u>xxx</u>
              <b>(Local|Global)</b>  The  environment  variable  <u>var</u> is defined to have the value <u>xxx</u>, and is passed on
              when executing the <u>Cmd</u>.  You can add several environment variable definitions by using the  option
              more than once.

       <b>fd=</b><u>n</u>[,...]
              <b>(Local)</b>  Each  file descriptor <u>n</u> in the comma-separated list should <u>not</u> be closed before executing
              the <u>Cmd.</u>  These descriptors are added to the usual set of descriptors kept open, namely 0, 1, 2.

       <b>nice=</b><u>n</u>
              <b>(Local|Global)</b> changes the ``nice'' value of the executed command by an amount <u>n</u> from the  default
              level.  (Positive increments reduce the command's priority; negative increments increase it.)

       <b>umask=</b><u>nnn</u>
              <b>(Local|Global)</b>  sets  the  umask  of any executed command to <u>n</u>.  A leading <b>0x</b> or <b>0X</b> in <u>nnn</u> means a
              hexadecimal value; otherwise, a leading <b>0</b> means octal; otherwise it's decimal.

       <u>Group</u> <u>6.</u>  <u>Other</u> <u>Options</u>

       <b>print=</b><u>message</u>
              <b>(Local)</b> If the rest of the line is matched, then <b>super</b> prints the specified  <u>message</u>  just  before
              executing the command.

       <b>die=</b><u>message</u>
              <b>(Local)</b> If the rest of the line is matched, then <b>super</b> does variable-substitution on the specified
              message  <u>message</u>,  prints  it,  and  exits.   This  lets  you  conveniently  set  up some ``stop''
              conditions, and use the die option to prevent super  from  looking  at  any  line  past  the  stop
              conditions.   Otherwise,  you'd  have  to individually attach the stop conditions to every control
              line.

</pre><h4><b>Include</b> <b>Files</b></h4><pre>
       A <u>super.tab</u> file can include other files by means of an entry like
              <b>:include</b> <u>filename</u> <u>[</u> <b>owner=</b><u>xxx</u> <u>]</u> <u>[</u> <b>group=</b><u>yyy</u>  <u>]</u>
       or
              <b>:optinclude</b> <u>file</u> <u>[</u> <b>owner=</b><u>xxx</u> <u>]</u> <u>[</u> <b>group=</b><u>yyy</u>  <u>]</u>
       If the <u>file</u> isn't an absolute path, it is taken to be relative to the directory containing the  <u>super.tab</u>
       file.   Include  files  may  be  nested  up to the system limit on the number of simultaneously-open file
       descriptors.

       The <b>owner=</b><u>xxx</u> option specifies that the <u>file</u> must be owned by user <u>xxx;</u> the <b>group=</b><u>yyy</u>  options  specifies
       that  the <u>file</u> must belong to group <u>yyy.</u>  If <b>group=</b><u>yyy</u> is specified, then the file can be group-writable;
       by default, the file must be writable only by owner.  This can be useful for  a  collection  of  accounts
       that  are  operated  together  as  part of a single project — the several of accounts can share <u>.supertab</u>
       files by <b>:include</b><u>-ing</u> files belonging to the trusted user <u>xxx</u> and/or group <u>yyy.</u>  Notes:

              1.  The regular root-owned <u>super.tab</u> file can also use the <u>owner=</u> or <u>group=</u> constructs,  but  it's
              not a good idea.  Don't do it.

              2.   Beware  of  the  transitive nature of this trust: the file owned by <u>xxx</u> can in turn include a
              file owned by yet another user.  You might wind up trusting a user you didn't intend to trust!

       The difference between <b>:include</b> and <b>:optinclude</b> is that the former generates an error if the  named  file
       doesn't exist, whereas the latter (optional-include) silently ignores files that don't exist.

       <u>WARNING:</u>  You  should  use  <b>:optinclude</b>  with great caution, and be sure not to depend on that file being
       present.  It is easy to imagine a scenario in which an administrator carelessly changes an entry so  that
       the wrong permission is granted if an :optinclude'd file was missing.

</pre><h4><b>FILES</b></h4><pre>
       <u>/etc/super.tab</u>
              The location of the <u>super.tab</u> file on your system.

       <u>/etc/super.init</u>
              The location of the <u>super.init</u> file on your system.

       <u>/run/superstamps/</u>username
              Default  location  of  the  file  whose  <u>mtime</u> is used as the timestamp for the last time the user
              entered his or her password for password-requiring commands.   Check  your  installation  for  the
              directory used on your system.

</pre><h4><b>EXAMPLES</b></h4><pre>

       Example 1.  The control line

                   doit /usr/local/bin/doit                \
                             me                            \
                             you@{h1,h32}                  \
                             ja.*:ok_j                     \
                             :goodguys

              allows /usr/local/bin/doit to be run setuid-root by
                   • user <b>me</b> on any host,
                   • user <b>you</b> on hosts <b>h1</b> and <b>h32</b>;
                   • any users named <b>ja.*</b>  in group <b>ok_j</b>;
                   • and anybody in group <b>goodguys</b>.

       Example 2.  The pair of control lines

                   doit /usr/local/bin/doit                \
                             u+g=smith env=TZ,TAPE         \
                             password=y timeout=0          \
                             jo@PublicWorkstation

                   doit /usr/local/bin/doit                \
                             u+g=smith env=TZ,TAPE         \
                             jo

              allows  user  <b>jo</b> to run /usr/local/bin/doit with uid = <b>smith</b>, gid = <b>smith</b>'s login gid, and keeping
              the environment variables TZ and TAPE in  addition  to  the  standard  set.   If  user  <b>jo</b>  is  at
              <b>PublicWorkstation</b>,  the  first entry will match, requiring jo's password every time the command is
              used; otherwise, <u>super</u> will match at the second entry, and  no  password  is  needed  to  run  the
              command.

       Example 3.  Here is an entry restricting CD-ROM mounting on different hosts: <b>tas</b> is the only user who may
              mount  CD's on <b>elgar</b>; anybody in group <b>xyz</b> may mount CD's on <b>alpha</b> or <b>delta</b>; and anybody on a host
              in the netgroup <b>india</b> may mount a CD on the <b>india</b> hosts.  However, user <b>jo</b> may never run  <u>cdmount</u>,
              regardless  of  his or her group or host (assuming that there is no overriding global pattern that
              permits <b>jo</b> to use the  command).   Note  that  shell-style  patterns  are  used,  not  regex-style
              patterns.

                   cdmount /usr/local/bin/cdmount          \
                             tas@elgar                     \
                             :xyz@{alpha,delta}            \
                             *@+india                      \
                             !jo

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/super.1.html">super</a></b>(1).

                                                      local                                         <u><a href="../man5/SUPER.TAB.5.html">SUPER.TAB</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>