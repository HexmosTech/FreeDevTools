<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>/proc/sys/vm/ - virtual memory subsystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <a href="file:/proc/sys/vm/">/proc/sys/vm/</a> - virtual memory subsystem

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u><a href="file:/proc/sys/vm/">/proc/sys/vm/</a></u>
              This directory contains files for memory management tuning, buffer, and cache management.

       <u><a href="file:/proc/sys/vm/admin_reserve_kbytes">/proc/sys/vm/admin_reserve_kbytes</a></u> (since Linux 3.10)
              This  file  defines  the  amount of free memory (in KiB) on the system that should be reserved for
              users with the capability <b>CAP_SYS_ADMIN</b>.

              The default value in this file is the minimum of [3% of free pages, 8MiB] expressed as  KiB.   The
              default  is  intended  to  provide  enough  for  the  superuser  to  log in and kill a process, if
              necessary, under the default overcommit 'guess' mode (i.e., 0 in <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u>).

              Systems running in "overcommit never" mode  (i.e.,  2  in  <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u>)  should
              increase  the  value in this file to account for the full virtual memory size of the programs used
              to recover (e.g., <b><a href="../man1/login.1.html">login</a></b>(1) <b><a href="../man1/ssh.1.html">ssh</a></b>(1), and <b><a href="../man1/top.1.html">top</a></b>(1)) Otherwise, the superuser may not be able to log  in
              to recover the system.  For example, on x86-64 a suitable value is 131072 (128MiB reserved).

              Changing the value in this file takes effect whenever an application requests memory.

       <u><a href="file:/proc/sys/vm/compact_memory">/proc/sys/vm/compact_memory</a></u> (since Linux 2.6.35)
              When  1  is  written  to  this file, all zones are compacted such that free memory is available in
              contiguous  blocks  where  possible.   The  effect  of  this  action  can  be  seen  by  examining
              <u><a href="file:/proc/buddyinfo">/proc/buddyinfo</a></u>.

              Present only if the kernel was configured with <b>CONFIG_COMPACTION</b>.

       <u><a href="file:/proc/sys/vm/drop_caches">/proc/sys/vm/drop_caches</a></u> (since Linux 2.6.16)
              Writing  to  this  file  causes the kernel to drop clean caches, dentries, and inodes from memory,
              causing that memory to become free.   This  can  be  useful  for  memory  management  testing  and
              performing  reproducible  filesystem benchmarks.  Because writing to this file causes the benefits
              of caching to be lost, it can degrade overall system performance.

              To free pagecache, use:

                  echo 1 &gt; <a href="file:/proc/sys/vm/drop_caches">/proc/sys/vm/drop_caches</a>

              To free dentries and inodes, use:

                  echo 2 &gt; <a href="file:/proc/sys/vm/drop_caches">/proc/sys/vm/drop_caches</a>

              To free pagecache, dentries, and inodes, use:

                  echo 3 &gt; <a href="file:/proc/sys/vm/drop_caches">/proc/sys/vm/drop_caches</a>

              Because writing to this file is a nondestructive operation and dirty objects are not freeable, the
              user should run <b><a href="../man1/sync.1.html">sync</a></b>(1) first.

       <u>/proc/sys/vm/sysctl_hugetlb_shm_group</u> (since Linux 2.6.7)
              This writable file contains a group ID that is allowed to allocate memory using huge pages.  If  a
              process  has  a filesystem group ID or any supplementary group ID that matches this group ID, then
              it  can  make  huge-page  allocations   without   holding   the   <b>CAP_IPC_LOCK</b>   capability;   see
              <b><a href="../man2/memfd_create.2.html">memfd_create</a></b>(2), <b><a href="../man2/mmap.2.html">mmap</a></b>(2), and <b><a href="../man2/shmget.2.html">shmget</a></b>(2).

       <u><a href="file:/proc/sys/vm/legacy_va_layout">/proc/sys/vm/legacy_va_layout</a></u> (since Linux 2.6.9)
              If  nonzero,  this  disables  the new 32-bit memory-mapping layout; the kernel will use the legacy
              (2.4) layout for all processes.

       <u><a href="file:/proc/sys/vm/memory_failure_early_kill">/proc/sys/vm/memory_failure_early_kill</a></u> (since Linux 2.6.32)
              Control how to kill processes when an uncorrected memory error  (typically  a  2-bit  error  in  a
              memory module) that cannot be handled by the kernel is detected in the background by hardware.  In
              some  cases  (like the page still having a valid copy on disk), the kernel will handle the failure
              transparently without affecting any applications.  But if there is no other up-to-date copy of the
              data, it will kill processes to prevent any data corruptions from propagating.

              The file has one of the following values:

              <b>1</b>      Kill all processes that have the corrupted-and-not-reloadable page mapped as  soon  as  the
                     corruption  is detected.  Note that this is not supported for a few types of pages, such as
                     kernel internally allocated data or the swap cache, but works  for  the  majority  of  user
                     pages.

              <b>0</b>      Unmap  the  corrupted page from all processes and kill a process only if it tries to access
                     the page.

              The kill is performed using a <b>SIGBUS</b> signal with <u>si_code</u>  set  to  <b>BUS_MCEERR_AO</b>.   Processes  can
              handle this if they want to; see <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2) for more details.

              This  feature  is  active only on architectures/platforms with advanced machine check handling and
              depends on the hardware capabilities.

              Applications can override the <u>memory_failure_early_kill</u> setting  individually  with  the  <b><a href="../man2/prctl.2.html">prctl</a></b>(2)
              <b>PR_MCE_KILL</b> operation.

              Present only if the kernel was configured with <b>CONFIG_MEMORY_FAILURE</b>.

       <u><a href="file:/proc/sys/vm/memory_failure_recovery">/proc/sys/vm/memory_failure_recovery</a></u> (since Linux 2.6.32)
              Enable memory failure recovery (when supported by the platform).

              <b>1</b>      Attempt recovery.

              <b>0</b>      Always panic on a memory failure.

              Present only if the kernel was configured with <b>CONFIG_MEMORY_FAILURE</b>.

       <u><a href="file:/proc/sys/vm/oom_dump_tasks">/proc/sys/vm/oom_dump_tasks</a></u> (since Linux 2.6.25)
              Enables a system-wide task dump (excluding kernel threads) to be produced when the kernel performs
              an  OOM-killing.   The  dump  includes  the following information for each task (thread, process):
              thread ID, real user ID, thread group ID (process ID), virtual memory size, resident set size, the
              CPU that the task is scheduled on, oom_adj score (see the description of  <u><a href="file:/proc/">/proc/</a></u>pid<u>/oom_adj</u>),  and
              command  name.   This  is  helpful to determine why the OOM-killer was invoked and to identify the
              rogue task that caused it.

              If this contains the value zero, this information is  suppressed.   On  very  large  systems  with
              thousands  of  tasks,  it  may  not be feasible to dump the memory state information for each one.
              Such systems should not be forced to incur a  performance  penalty  in  OOM  situations  when  the
              information may not be desired.

              If  this  is  set  to  nonzero, this information is shown whenever the OOM-killer actually kills a
              memory-hogging task.

              The default value is 0.

       <u><a href="file:/proc/sys/vm/oom_kill_allocating_task">/proc/sys/vm/oom_kill_allocating_task</a></u> (since Linux 2.6.24)
              This enables or disables killing the OOM-triggering task in out-of-memory situations.

              If this is set to zero, the OOM-killer will scan through the entire tasklist  and  select  a  task
              based  on  heuristics  to kill.  This normally selects a rogue memory-hogging task that frees up a
              large amount of memory when killed.

              If this is set to nonzero, the OOM-killer simply kills the task that triggered  the  out-of-memory
              condition.  This avoids a possibly expensive tasklist scan.

              If  <u><a href="file:/proc/sys/vm/panic_on_oom">/proc/sys/vm/panic_on_oom</a></u>  is  nonzero,  it  takes  precedence  over whatever value is used in
              <u><a href="file:/proc/sys/vm/oom_kill_allocating_task">/proc/sys/vm/oom_kill_allocating_task</a></u>.

              The default value is 0.

       <u><a href="file:/proc/sys/vm/overcommit_kbytes">/proc/sys/vm/overcommit_kbytes</a></u> (since Linux 3.14)
              This writable file provides an alternative to <u><a href="file:/proc/sys/vm/overcommit_ratio">/proc/sys/vm/overcommit_ratio</a></u>  for  controlling  the
              <u>CommitLimit</u>  when  <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u> has the value 2.  It allows the amount of memory
              overcommitting to be specified as an absolute value (in kB), rather than as a  percentage,  as  is
              done  with <u>overcommit_ratio</u>.  This allows for finer-grained control of <u>CommitLimit</u> on systems with
              extremely large memory sizes.

              Only one of <u>overcommit_kbytes</u> or <u>overcommit_ratio</u> can have an effect: if <u>overcommit_kbytes</u>  has  a
              nonzero  value,  then  it  is  used  to calculate <u>CommitLimit</u>, otherwise <u>overcommit_ratio</u> is used.
              Writing a value to either of these files causes the value in the other file to be set to zero.

       <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u>
              This file contains the kernel virtual memory accounting mode.  Values are:

                     0: heuristic overcommit (this is the default)
                     1: always overcommit, never check
                     2: always check, never overcommit

              In mode 0, calls of <b><a href="../man2/mmap.2.html">mmap</a></b>(2) with <b>MAP_NORESERVE</b> are not checked, and  the  default  check  is  very
              weak, leading to the risk of getting a process "OOM-killed".

              In mode 1, the kernel pretends there is always enough memory, until memory actually runs out.  One
              use  case  for  this  mode  is  scientific computing applications that employ large sparse arrays.
              Before Linux 2.6.0, any nonzero value implies mode 1.

              In mode 2 (available since Linux 2.6), the total virtual  address  space  that  can  be  allocated
              (<u>CommitLimit</u> in <u><a href="file:/proc/meminfo">/proc/meminfo</a></u>) is calculated as

                  CommitLimit = (total_RAM - total_huge_TLB) *
                             overcommit_ratio / 100 + total_swap

              where:

              •  <u>total_RAM</u> is the total amount of RAM on the system;

              •  <u>total_huge_TLB</u> is the amount of memory set aside for huge pages;

              •  <u>overcommit_ratio</u> is the value in <u><a href="file:/proc/sys/vm/overcommit_ratio">/proc/sys/vm/overcommit_ratio</a></u>; and

              •  <u>total_swap</u> is the amount of swap space.

              For  example,  on  a  system with 16 GB of physical RAM, 16 GB of swap, no space dedicated to huge
              pages, and an <u>overcommit_ratio</u> of 50, this formula yields a <u>CommitLimit</u> of 24 GB.

              Since Linux 3.14, if the value in <u><a href="file:/proc/sys/vm/overcommit_kbytes">/proc/sys/vm/overcommit_kbytes</a></u> is nonzero, then  <u>CommitLimit</u>  is
              instead calculated as:

                  CommitLimit = overcommit_kbytes + total_swap

              See       also       the       description      of      <u><a href="file:/proc/sys/vm/admin_reserve_kbytes">/proc/sys/vm/admin_reserve_kbytes</a></u>      and
              <u><a href="file:/proc/sys/vm/user_reserve_kbytes">/proc/sys/vm/user_reserve_kbytes</a></u>.

       <u><a href="file:/proc/sys/vm/overcommit_ratio">/proc/sys/vm/overcommit_ratio</a></u> (since Linux 2.6.0)
              This writable file defines a percentage by which memory can be overcommitted.  The  default  value
              in the file is 50.  See the description of <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u>.

       <u><a href="file:/proc/sys/vm/panic_on_oom">/proc/sys/vm/panic_on_oom</a></u> (since Linux 2.6.18)
              This enables or disables a kernel panic in an out-of-memory situation.

              If  this  file  is  set  to  the  value  0,  the kernel's OOM-killer will kill some rogue process.
              Usually, the OOM-killer is able to kill a rogue process and the system will survive.

              If this file is set to the value 1, then the kernel normally panics  when  out-of-memory  happens.
              However,  if  a  process  limits  allocations  to  certain  nodes  using memory policies (<b><a href="../man2/mbind.2.html">mbind</a></b>(2)
              <b>MPOL_BIND</b>) or cpusets (<b><a href="../man7/cpuset.7.html">cpuset</a></b>(7)) and those nodes reach memory exhaustion status, one process  may
              be  killed  by  the  OOM-killer.  No panic occurs in this case: because other nodes' memory may be
              free, this means the system as a whole may not have reached an out-of-memory situation yet.

              If this file is set to the value 2, the kernel  always  panics  when  an  out-of-memory  condition
              occurs.

              The  default value is 0.  1 and 2 are for failover of clustering.  Select either according to your
              policy of failover.

       <u><a href="file:/proc/sys/vm/swappiness">/proc/sys/vm/swappiness</a></u>
              The value in this file controls how aggressively the kernel will swap memory pages.  Higher values
              increase aggressiveness, lower values decrease aggressiveness.  The default value is 60.

       <u><a href="file:/proc/sys/vm/user_reserve_kbytes">/proc/sys/vm/user_reserve_kbytes</a></u> (since Linux 3.10)
              Specifies an amount of memory (in KiB) to reserve for user processes.  This is intended to prevent
              a user from starting a single memory hogging process, such that  they  cannot  recover  (kill  the
              hog).   The  value in this file has an effect only when <u><a href="file:/proc/sys/vm/overcommit_memory">/proc/sys/vm/overcommit_memory</a></u> is set to 2
              ("overcommit never" mode).  In this case, the system reserves an amount  of  memory  that  is  the
              minimum of [3% of current process size, <u>user_reserve_kbytes</u>].

              The default value in this file is the minimum of [3% of free pages, 128MiB] expressed as KiB.

              If  the value in this file is set to zero, then a user will be allowed to allocate all free memory
              with a single process (minus  the  amount  reserved  by  <u><a href="file:/proc/sys/vm/admin_reserve_kbytes">/proc/sys/vm/admin_reserve_kbytes</a></u>).   Any
              subsequent attempts to execute a command will result in "fork: Cannot allocate memory".

              Changing the value in this file takes effect whenever an application requests memory.

       <u><a href="file:/proc/sys/vm/unprivileged_userfaultfd">/proc/sys/vm/unprivileged_userfaultfd</a></u> (since Linux 5.2)
              This  (writable)  file  exposes a flag that controls whether unprivileged processes are allowed to
              employ <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2).  If this file  has  the  value  1,  then  unprivileged  processes  may  use
              <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2).   If  this  file has the value 0, then only processes that have the <b>CAP_SYS_PTRACE</b>
              capability may employ <b><a href="../man2/userfaultfd.2.html">userfaultfd</a></b>(2).  The default value in this file is 1.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/proc.5.html">proc</a></b>(5), <b><a href="../man5/proc_sys.5.html">proc_sys</a></b>(5)

Linux man-pages 6.9.1                              2024-05-02                                     <u><a href="../man5/proc_sys_vm.5.html">proc_sys_vm</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>