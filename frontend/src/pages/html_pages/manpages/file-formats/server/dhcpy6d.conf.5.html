<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dhcpy6d.conf - Configuration file for DHCPv6 server dhcpy6d</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dhcpy6d">dhcpy6d_1.2.3-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dhcpy6d.conf - Configuration file for DHCPv6 server dhcpy6d

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  file  contains  the  general  settings  for DHCPv6 server daemon dhcpy6d.  It follows RFC 822 style
       parsed by Python ConfigParser module.  It contains several sections which will  be  discussed  in  detail
       here.

       An online documentation is also available at <u>https://dhcpy6d.de/documentation/config</u>.

       Boolean settings can be set with <u>1|0</u>, <u>on|off</u> or <u>yes|no</u> values.

       Some options allow multiple values. These have to be separated by spaces.

       There are 5 types of sections:

       <b>[dhcpy6d]</b>
              This  section  contains  general  options like interfaces, storage and logging. Only one [dhcpy6d]
              section is allowed.

       <b>[address_&lt;address_name&gt;]</b>
              There can be various  <u>[address_&lt;address_name&gt;]</u>  sections.  In  several  address  sections  several
              address  ranges  and  types  can be defined.  Addresses are organized in classes. For details read
              further down.

       <b>[prefix_&lt;prefix_name&gt;]</b>
              There can be various <u>[prefix_&lt;prefix_name&gt;]</u> sections. In several prefix  sections  several  prefix
              ranges  and  types  can  be  defined.  Prefixes are organized in classes. For details read further
              down.

       <b>[class_&lt;class_name&gt;]</b>
              Class definitions allow one to apply different addresses, time limits et al. to different types of
              clients.

       <b>[bootfile_&lt;bootfile_name&gt;]</b>
              There can be various <u>[bootfile_&lt;bootfile_name&gt;]</u> sections. In  several  bootfile  sections  several
              tftp bootfile urls with restrictions to CPU architecture and user class supplied by the PXE client
              can be defined.

</pre><h4><b>GENERAL</b> <b>CONFIGURATION</b> <b>IN</b> <b>SECTION</b> <b>[DHCPY6D]</b></h4><pre>
       This  section  contains important general options. Values are sometimes examples and not meant to be used
       in production environments.

       <b>really_do_it</b> <b>=</b> <b>yes|no</b>
              Let dhcpy6d <b>really</b> <b>do</b> <b>it</b> and respond to client requests - disabling might be of use for  debugging
              and testing.  <u>Default:</u> <u>no</u>

       <b>interface</b> <b>=</b> <b>&lt;interface&gt;</b> <b>[&lt;interface&gt;</b> <b>...]</b>
              The  interfaces  the server listens on is defined with keyword interface. Multiple interfaces have
              to be separated by spaces.

       <b>serverduid</b> <b>=</b> <b>&lt;longlongserverduid&gt;</b>
              The server DUID should be configured with serverduid. If there is none dhcpy6d creates a  new  one
              at  every  startup.  Windows clients might run a little bit wild when server DUID changed. You are
              free to compose your own as long as it follows RFC 3315.   Please  note  that  it  has  to  be  in
              hexadecimal  format  -  no  octals, no "-", just like in the example below.  The example here is a
              DUID-LLT (Link-layer Address Plus Time) even if it should be a DUID-TLL as timestamp comes  first.
              It  is  composed  of  <u>DUID-type(LLT=1)</u>  +  <u>Hardware-type(Ethernet=1)</u>  +  <u>Unixtime-in-hexadecimal</u> +
              <u>MAC-address</u> what makes a <u>0001</u> + <u>0001</u> + <u>11fb5dc9</u> + <u>01023472a6c5</u> = <b>0001000111fb5dc901023472a6c5</b>.

       <b>server_preference</b> <b>=</b> <b>&lt;0-255&gt;</b>
              The server preference determines the priority of the server. The maximum value is 255 which  means
              highest priority.  <u>Default:</u> <u>255</u>

       <b>user</b> <b>=</b> <b>&lt;user&gt;</b>
              For security reasons dhcpy6d can and should be run as non-root user.  <u>Default:</u> <u>root</u>

       <b>group</b> <b>=</b> <b>&lt;group&gt;</b>
              For security reasons dhcpy6d can and should be run as non-root group.  <u>Default:</u> <u>root</u>

       <b>nameserver</b> <b>=</b> <b>&lt;nameserver-address&gt;</b> <b>[&lt;nameserver-address&gt;</b> <b>...]</b>
              If  an  address type is of category <u>dns</u> at least one nameserver has to be given here. If more than
              one is needed they have to be separated by spaces.

       <b>domain</b> <b>=</b> <b>&lt;domain-name&gt;</b>
              The domain to be used with FQDN hostnames for option 39.

       <b>domain_search_list</b> <b>=</b> <b>&lt;domain-name&gt;</b> <b>[&lt;domain-name&gt;</b> <b>...]</b>
              Domain search lists to be used with option 24. If none is given the value of domain above is used.
              Multiple domains have to be separated by space or comma.

       <b>ntp_server</b> <b>=</b> <b>&lt;ntp_server&gt;</b> <b>[&lt;ntp_server&gt;</b> <b>...]</b>
              NTP servers to be used. &lt;ntp_server&gt; can  be  unicast  addresses,  multicast  addresses  or  FQDNs
              following RFC 5908 for DHCPv6 option 56.

       <b>log</b> <b>=</b> <b>yes|no</b>
              Enable logging.  <u>Default:</u> <u>no</u>

       <b>log_console</b> <b>=</b> <b>yes|no</b>
              Log to the console where <b>dhcpy6d</b> has been started.  <u>Default:</u> <u>no</u>

       <b>log_file</b> <b>=</b> <b>&lt;/path/to/dhcpy6d/log/file&gt;</b>
              Defines the file used for logging. Will be created if it does not yet exist.

       <b>log_syslog</b> <b>=</b> <b>yes|no</b>
              If logs should go to syslog it is set here.  <u>Default:</u> <u>no</u>

       <b>log_syslog_destination</b> <b>=</b> <b>syslogserver</b>
              An  UDP  syslog server may be used if <b>log_syslog_destination</b> points to it. Optionally a port other
              than default 514 can be set when adding ":&lt;port&gt;" to the destination.

       <b>log_syslog_facility</b> <b>=</b> <b>&lt;log-facility&gt;</b>
              The default syslog facility is <u>daemon</u> but can be changed here.  <u>Default:</u> <u>daemon</u>

       <b>log_mac_llip</b> <b>=</b> <b>yes|no</b>
              Log discovered MAC/LLIP pairs of clients. Might be  pretty  verbose  in  larger  setups  and  with
              disabled MAC/LLIP pair caching.  <u>Default:</u> <u>no</u>

       <b>store_config</b> <b>=</b> <b>file|sqlite|mysql|postgresql|none</b>
              Configuration of clients can be stored in a file or in a database. Databases MySQL, PostgreSQL and
              SQLite  are  supported at the moment, thus possible values are <u>file</u>, <u>mysql</u>, <u>postgresql</u>  or <u>sqlite</u>.
              To disable any client configuration source it has to be <u>none</u>.  <u>Default:</u> <u>none</u>

       <b>store_file_config</b> <b>=</b> <b>&lt;/path/to/client/conf/file&gt;</b>
              File which contains the clients configuration. For details see <b><a href="../man5/dhcpy6d-clients.conf.5.html">dhcpy6d-clients.conf</a>(5)</b>.   <u>Default:</u>
              <u>/etc/dhcpy6d-clients.conf</u>

       <b>store_sqlite_config</b> <b>=</b> <b>/path/to/sqlite/config/file</b>
              SQLite database file which contains the clients configuration.  <u>Default:</u> <u>config.sqlite</u>

       <b>store_volatile</b> <b>=</b> <b>sqlite|mysql|postgresql</b>
              Volatile  data  like  leases and the mapping between Link Local addresses and MAC addresses can be
              stored in MySQL, PostgreSQL or SQLite database, so the possible values are <u>mysql</u>,  <u>postgresql</u>  and
              <u>sqlite</u>.

       <b>store_sqlite_volatile</b> <b>=</b> <b>/path/to/sqlite/volatile/file</b>
              If    set    to    <u>sqlite</u>    a    SQLite    database    file    must    be    defined.    <u>Default:</u>
              <u>/var/lib/dhcpy6d/volatile.sqlite</u>

       <b>store_db_host</b> <b>=</b> <b>&lt;database-host&gt;</b>

       <b>store_db_db</b> <b>=</b> <b>&lt;database-name&gt;</b>

       <b>store_db_user</b> <b>=</b> <b>&lt;database-user&gt;</b>

       <b>store_db_password</b> <b>=</b> <b>&lt;database-password&gt;</b>
              If <b>store_config</b> and/or <b>store_volatile</b> use a database to store information it has to  be  set  with
              these self-explanatory options. The same database is used for config and volatile data.

       <b>cache_mac_llip</b> <b>=</b> <b>yes|no</b>
              Cache discovered MAC/LLIP pairs in database. If enabled reduces response time and opens dhcpy6d to
              <u>possible</u> MAC/LLIP poisoning. If disabled might increase system load.  <u>Default:</u> <u>no</u>

       <b>identification</b> <b>=</b> <b>&lt;mac&gt;</b> <b>&lt;duid&gt;</b> <b>&lt;hostname&gt;</b>
              Clients  can  be  set  to  be identified by several attributes - MAC address, DUID or hostname. At
              least one of mac, duid or hostname is necessary. Hostname is the one sent in client  request  with
              DHCPv6  option  39.  Identification is used to get the correct settings for the client from config
              file or database.  Same MAC and different DUIDs might be interesting for clients with multiple OS.
              <u>Default:</u> <u>mac</u>

       <b>identification_mode</b> <b>=</b> <b>match_all|match_some</b>
              If more than one identification attribute has been set, the identification  mode  can  be  one  of
              <u>match_all</u>  or  <u>match_some</u>.  The first means that all attributes have to match to identify a client
              and the latter is more tolerant.  <u>Default:</u> <u>match_all</u>

       <b>ignore_mac</b> <b>=</b> <b>yes|no</b>
              If serving only for delivering addresses regardless of classes (e.g. on PPP interface) MACs do not
              need to be investigated.

       <b>dns_update</b> <b>=</b> <b>yes|no</b>
              Dynamically update DNS. This works at the moment only with Bind DNS,  but  might  be  extended  to
              others, maybe via call of an external command.  <u>Default:</u> <u>no</u>

       <b>dns_update_nameserver</b> <b>=</b> <b>&lt;nameserver-address&gt;</b> <b>[&lt;nameserver-address&gt;</b> <b>...]</b>

       <b>dns_use_rndc</b> <b>=</b> <b>yes|no</b>
              DNS updates might be able without RNDC key but this is not advised.  <u>Default:</u> <u>yes</u>

       <b>dns_rndc_key</b> <b>=</b> <b>&lt;rndc-key_like_in_rndc.conf&gt;</b>

       <b>dns_rndc_secret</b> <b>=</b> <b>&lt;secret_key_like_in_rndc.conf</b>
              When  connecting  to  a Bind DNS server for dynamic DNS updates its address and the necessary RNDC
              data must be set.

       <b>dns_ignore_client</b> <b>=</b> <b>yes|no</b>
              Clients may request that they update the DNS record theirself. If their wishes  shall  be  ignored
              this option has to be true.  <u>Default:</u> <u>yes</u>

       <b>dns_use_client_hostname</b> <b>=</b> <b>yes|no</b>
              The client hostname either comes from configuration of dhcpy6d or in the client request.  <u>Default:</u>
              <u>no</u>

       <b>preferred_lifetime</b> <b>=</b> <b>&lt;seconds&gt;</b>
              <u>Default:</u> <u>5400</u>

       <b>valid_lifetime</b> <b>=</b> <b>&lt;seconds&gt;</b>
              <u>Default:</u> <u>7200</u>

       <b>t1</b> <b>=</b> <b>&lt;seconds&gt;</b>
              <u>Default:</u> <u>2700</u>

       <b>t2</b> <b>=</b> <b>&lt;seconds&gt;</b>
              Preferred  lifetime,  valid  lifetime,  T1 and T2 in seconds are configured with the corresponding
              options.  <u>Default:</u> <u>4050</u>

       <b>information_refresh_time</b> <b>=</b> <b>&lt;seconds&gt;</b>
              The lifetime of information given to  clients  as  response  to  an  <u>information-request</u>  message.
              <u>Default:</u> <u>6000</u>

       <b>ignore_iaid</b> <b>=</b> <b>yes|no</b>
              Ignore IAID when looking for leases in database. Might be of use in case some clients are changing
              their IAD for some unknown reason.  <u>Default:</u> <u>no</u>

       <b>ignore_unknown_clients</b> <b>=</b> <b>yes|no</b>
              Ignore clients if no trace of them can be found in the neighbor cache.  <u>Default:</u> <u>yes</u>

       <b>request_limit</b> <b>=</b> <b>yes|no</b>
              Enables   request   limits   for  clients  which  can  be  controlled  by  <u>request_limit_time</u>  and
              <u>request_limit_count</u>.  <u>Default:</u> <u>no</u>

       <b>request_limit_identification</b> <b>=</b> <b>mac|llip</b>
              Identifies clients either by MAC address or Link Local IP.  <u>Default:</u> <u>llip</u>

       <b>request_limit_time</b> <b>=</b> <b>&lt;seconds&gt;</b>
              <u>Default:</u> <u>60</u>

       <b>request_limit_count</b> <b>=</b> <b>&lt;max_number_of_requests&gt;</b>
              Requests can be limited to avoid server to be flooded by buggy  clients.  Set  number  of  request
              during a certain time in seconds.  <u>Default:</u> <u>20</u>

       <b>request_limit_release_time</b> <b>=</b> <b>&lt;seconds&gt;</b>
              Duration in seconds for brute force clients to stay on the blacklist.  <u>Default:</u> <u>7200</u>

       <b>manage_routes_at_start</b> <b>=</b> <b>yes|no</b>
              Check prefixes at startup and call commands for adding and deleting routes respectively.  <u>Default:</u>
              <u>no</u>

</pre><h4><b>ADDRESS</b> <b>DEFINITIONS</b> <b>IN</b> <b>MULTIPLE</b> <b>[ADDRESS_&lt;ADDRESS_NAME&gt;]</b> <b>SECTIONS</b></h4><pre>
       The  <u>&lt;address_name&gt;</u>  part of an <b>[address_&lt;address_name&gt;]</b> section is an arbitrarily chosen identifier like
       <u>clients_global</u> or <u>invalid_clients_local</u>.  There can be many address definitions which  will  be  used  by
       classes. Every address definition may include several properties:

       <b>category</b> <b>=</b> <b>mac|eui64|id|range|random|fixed|dns</b>
              Categories  play  an  important role when defining patterns for addresses. An address belongs to a
              certain category:

              <b>mac</b>    Uses MAC address from client request as part of address

              <b>eui64</b>  Also uses MAC address from client as part of address, but converts it to a 64-bit  extended
                     unique identifier (EUI-64)

              <b>id</b>     Uses  ID  given to client in configuration file or database as one octet of address, should
                     be in range 0-ffff

              <b>range</b>  Generate addresses of given range like 0-ffff

              <b>random</b> Randomly created 64 bit values used as host part in address

              <b>fixed</b>  Use addresses from client configuration only.

              <b>dns</b>    Ask DNS server for IPv6 address of client host

       <b>range</b> <b>=</b> <b>&lt;from&gt;-&lt;to&gt;</b>
              Sets range for addresses of category <u>range</u>.

              <b>from</b>   Starting hex number of range, minimum is 0

              <b>to</b>     Maximum hex limit of range, highest is ffff.

       <b>pattern</b> <b>=</b> <b>2001:db8::$mac$|$id$|$range$|$random$</b>

       <b>pattern=</b> <b>$prefix$|$mac$|$eui64$|$id$|$range$|$random$</b>
              Patterns allow one to design the addresses according to their category. See examples section below
              to make it more clear.

              <b>$mac$</b>  The MAC address from the DHCPv6 request's Link Local Address found in  the  neighbor  cache
                     will  be  inserted instead of the placeholder. It will be stretched over 3 thus octets like
                     00:11:22:33:44:55 become 0011:2233:4455.

              <b>$eui64$</b>
                     The MAC address converted to a modified 64-bit extended unique identifier (EUI-64) from the
                     DHCPv6 request's Link Local Address found in the neighbor cache will be inserted instead of
                     the placeholder. It will be converted according to RFC 4291 like  52:54:00:e5:b4:64  become
                     5054:ff:fee5:b464

              <b>$id$</b>   If  clients get an ID in client configuration file or in client configuration database this
                     ID will fill one octet. Thus the ID has to be in the range of 0000-ffff.

              <b>$range$</b>
                     If address is of category range the range defined with extra keyword  <u>range</u>  will  be  used
                     here  in place of one octet.This is why the range can span from 0000-ffff. Clients will get
                     an address out of the given range.

              <b>$random64$</b>
                     A 64 bit random address will be generated in place of this variable. Clients get  a  random
                     address  just  like  they  would if privacy extensions were used. The random part will span
                     over 4 octets.

              <b>$prefix</b>
                     This placeholder can be used instead of a literal prefix  and  uses  the  prefix  given  at
                     calling dhcpy6d via the <u>--prefix</u> argument like <u>$prefix$::$id$</u>.

       <b>ia_type</b> <b>=</b> <b>na|ta</b>
              IA  (Identity  Association)  types can be one of non-temporary address <u>na</u> or temporary address <u>ta</u>.
              Default and probably most used is <u>na</u>.  <u>Default:</u> <u>na</u>

       <b>preferred_lifetime</b> <b>=</b> <b>&lt;seconds&gt;</b>

       <b>valid_lifetime</b> <b>=</b> <b>&lt;seconds&gt;</b>
              As default preferred and valid lifetime are set  in  general  settings,  but  it  is  configurable
              individually for every address setting.

       <b>dns_update</b> <b>=</b> <b>yes|no</b>
              <u>Default:</u> <u>no</u>

       <b>dns_zone</b> <b>=</b> <b>&lt;dnszone&gt;</b>

       <b>dns_rev_zone</b> <b>=</b> <b>&lt;reverse_dnszone&gt;</b>
              If  these  addresses  should  be  synchronized  with Bind DNS, these three settings have to be set
              accordingly. The nameserver for updates is set in general settings.

   <b>Default</b> <b>Address</b>
       The address scheme used for the default class <u>class_default</u> is  by  default  named  <u>address_default</u>.   It
       should be enough if <u>address_default</u> is defined, only if unknown clients should get extra nameservers etc.
       a <u>class_default</u> has to be set.

       <b>[address_default]</b>
              Address scheme used as default for clients which do not match any other class than <u>class_default</u>.

</pre><h4><b>PREFIX</b> <b>DEFINITIONS</b> <b>IN</b> <b>MULTIPLE</b> <b>[PREFIX_&lt;PREFIX_NAME&gt;]</b> <b>SECTIONS</b></h4><pre>
       The  <u>&lt;prefix_name&gt;</u>  part  of  an  <b>[prefix_&lt;prefix_name&gt;]</b> section is an arbitrarily chosen identifier like
       <u>customers</u>.  A prefix definition may contain several properties:

       <b>category</b> <b>=</b> <b>range</b>
              Like addresses prefix have a category. Right now only <u>range</u> seems to make sense, similar to ranges
              in addresses being like 0-ffff.

       <b>range</b> <b>=</b> <b>&lt;from&gt;-&lt;to&gt;</b>
              Sets range for prefix of category <u>range</u>.

              <b>from</b>   Starting hex number of range, minimum is 0

              <b>to</b>     Maximum hex limit of range, highest is ffff.

       <b>pattern</b> <b>=</b> <b>2001:db8:$range$::</b>

       <b>pattern=</b> <b>$prefix$:$range$::</b>
              Patterns allow one to design the addresses according to their category. See examples section below
              to make it more clear.

              <b>$range$</b>
                     If address is of category range the range defined with extra keyword  <u>range</u>  will  be  used
                     here  in  place  of one octet.  This is why the range can span from 0000-ffff. Clients will
                     get an address out of the given range.

       <b>length</b> <b>=</b> <b>&lt;prefix_length&gt;</b>
              Length of prefix given out to clients.

       <b>preferred_lifetime</b> <b>=</b> <b>&lt;seconds&gt;</b>

       <b>valid_lifetime</b> <b>=</b> <b>&lt;seconds&gt;</b>
              As default preferred and valid lifetime are set  in  general  settings,  but  it  is  configurable
              individually for every prefixk setting.

       <b>route_link_lokal</b> <b>=</b> <b>yes|no</b>
              As  default  Link  Local  Address  of requesting client is not used as router address for external
              call.  Instead the client should be able to retrieve exactly 1 address from server to be  used  as
              router  for  the  delegated  prefix.  Alternatively the client Link Local Address might be used by
              enabling this option.  <u>Default:</u> <u>no</u>

</pre><h4><b>CLASS</b> <b>DEFINITIONS</b> <b>IN</b> <b>MULTIPLE</b> <b>[CLASS_&lt;CLASS_NAME&gt;]</b> <b>SECTIONS</b></h4><pre>
       The <u>&lt;class_name&gt;</u> part of an <b>[class_&lt;class_name&gt;]</b> section is an arbitrarily chosen identifier like <u>clients</u>
       or <u>invalid_clients</u>.  Clients can be grouped in classes. Different classes can have different  properties,
       different  address  sets  and  different  numbers  of  addresses.  Classes also might have different name
       servers, time intervals, filters and interfaces.

       A client gets the addresses, nameserver and T1/T2 values of the class  which  it  is  configured  for  in
       client configuration database or file.

       <b>addresses</b> <b>=</b> <b>&lt;address_name&gt;</b> <b>[&lt;address_name&gt;</b> <b>...]</b>
              A  class can contain as many addresses as needed. Their names have to be separated by spaces. <u>Name</u>
              means the <u>name</u>-part of an address section like <u>[address_name]</u>.  If a class does  not  contain  any
              addresses clients won't get any address except they have one fixed defined in client configuration
              file or database.

       <b>prefixes</b> <b>=</b> <b>&lt;prefix_name&gt;</b> <b>[&lt;address_name&gt;</b> <b>...]</b>
              A  class  can contain prefixes - even most probably only one prefix will be useful. <u>Name</u> means the
              <u>name</u>-part of a prefiy section.

       <b>answer</b> <b>=</b> <b>normal|noaddress|none</b>
              Normally a client will get an answer, but if  for  whatever  reason  is  a  need  to  give  it  an
              <u>NoAddrAvail</u> message back or completely ignore the client it can be set here.  <u>Default:</u> <u>normal</u>

       <b>nameserver</b> <b>=</b> <b>&lt;nameserver-address&gt;</b> <b>[&lt;nameserver-address&gt;</b> <b>...]</b>
              Each  class  can have its own nameservers. If this option is used it replaces the nameservers from
              general settings.

       <b>t1</b> <b>=</b> <b>&lt;seconds&gt;</b>

       <b>t2</b> <b>=</b> <b>&lt;seconds&gt;</b>
              Each class can have its own <b>t1</b> and <b>t2</b> values. The ones from general settings will  be  overridden.
              Might be of use for some invalid-but-about-to-become-valid-somehow-soon class.

       <b>filter_hostname</b> <b>=</b> <b>&lt;regular_expression&gt;</b>

       <b>filter_mac</b> <b>=</b> <b>&lt;regular_expression&gt;</b>

       <b>filter_duid</b> <b>=</b> <b>&lt;regular_expression&gt;</b>
              Filters  allow  one  to  apply  a class to a client not by configuration but by a matching regular
              expression filter. Most useful might be the filtering by hostname, but maybe there is some use for
              DUID and MAC address based filtering too.  The regular expressions are meant to by Python  Regular
              Expressions.   See  <u>https://docs.python.org/2/howto/regex.html</u>  and  examples  section  below  for
              details.

       <b>interface</b> <b>=</b> <b>&lt;interface&gt;</b> <b>[&lt;interface&gt;</b> <b>...]</b>
              It is possible to let a class only apply on specific interfaces. These have  to  be  separated  by
              spaces.

       <b>advertise</b> <b>=</b> <b>addresses|prefixes</b>
              A  class  per  default  allows  one  to advertise addresses as well as prefixes if requested. This
              option allows one to narrow the answers down to either <u>addresses</u> or <u>prefixes</u>.  <u>Default:</u> <u>addresses</u>

       <b>call_up</b> <b>=</b> <b>&lt;executable&gt;</b> <b>[$prefix$]</b> <b>[$length$]</b> <b>[$router$]</b>
              When a route is requested and accepted the custom <u>executable</u> will  called  and  the  optional  but
              senseful variables will be filled with their appropriate values.

              <b>$prefix$</b>
                     Contains the prefix advertised to the client.

              <b>$length$</b>
                     The prefix length.

              <b>$router$</b>
                     The host which routes into the advertised prefix - of course the requesting client IPv6.

       <b>call_down</b> <b>=</b> <b>&lt;executable&gt;</b> <b>[$prefix$]</b> <b>[$length$]</b> <b>[$router$]</b>
              When a route is released the custom <u>executable</u> will called and the optional but senseful variables
              will be filled with their appropriate values.

              <b>$prefix$</b>
                     Contains the prefix advertised to the client.

              <b>$length$</b>
                     The prefix length.

              <b>$router$</b>
                     The host which routes into the advertised prefix - of course the requesting client IPv6.

       <b>bootfiles</b> <b>=</b> <b>&lt;bootfile&gt;</b> <b>[&lt;bootfile&gt;</b> <b>...]</b>
              List  of  PXE  bootfiles  to evaluate for clients in this client. Each value must refer a bootfile
              section (see below). Each bootfile is evaluated by the filter defined in the bootfile section, the
              first machting bootfile is chosen.

              Example:
                 <u>bootfiles</u> <u>=</u> <u>eth1_ipxe</u> <u>eth1_efi64</u> <u>eth1_efi32</u> <u>eth1_efibc</u>

   <b>Default</b> <b>Class</b>
       At the moment every client which does not match  any  other  class  by  client  configuration  or  filter
       automatically  matches  the  class  "default".   This class could get an address scheme too. It should be
       enough if 'address_default' is defined, only if unknown clients  should  get  extra  nameservers  etc.  a
       'class_default' has to be set.

       <b>[class_default]</b>
              Default  class  for  all  clients that do not match any other class. Like any other class it might
              contain all options that appyl to a class.

       <b>[class_default_&lt;interface&gt;]</b>
              If dhcpy6d listens at multiple interfaces, one can define a default class for every 'interface'.

</pre><h4><b>BOOTFILE</b> <b>DEFINITIONS</b> <b>IN</b> <b>MULTIPLE</b> <b>[BOOTFILE_&lt;BOOTFILE_NAME&gt;]</b> <b>SECTIONS</b></h4><pre>
       The <u>&lt;bootfile_name&gt;</u> part of an <b>[bootfile_&lt;bootfile_name&gt;]</b> section is  an  arbitrarily  chosen  identifier
       like <u>efi32</u>, <u>bios</u> or <u>efi64</u>.  Each bootfile can be restricted to an architecture and/or an user class which
       is sent by the PXE client.

       <b>bootfile_url</b> <b>=</b> <b>&lt;url&gt;</b>
              The  bootfile  URL  in  a  format like <u>tftp://[2001:db8:85a3::8a2e:370:7334]/pxe.efi</u>. The possible
              protocols are dependent on the PXE client, TFTP should be supported by almost every client.

       <b>client_architecture</b> <b>=</b> <b>&lt;architecture&gt;</b>
              Optionally restrict the bootfile to a specific CPU architecture. If the client doesn't  match  the
              requirement,  the  next  bootfile  assigned  to  the  class definition is chosen or no bootfile is
              provided, if there are no further alternatives.

              Either the integer identifier for an architecture is possible (e.g.  0009  for  EFI  x86-64).  The
              integer  must  consists  of  four  numeric digits, empty digits must be written as zero (e.g. 9 =&gt;
              0009).     For     a     full     list      of      possible      integer      identifier      see
              <u>https://tools.ietf.org/html/rfc4578#section-2.1</u>.  Alternatively the well-known names of registered
              CPU architectures defined in RF4578 can be used:

              • Intel x86PC

              • NEC/PC98

              • EFI Itanium

              • DEC Alpha

              • Arc x86

              • Intel Lean Client

              • EFI IA32

              • EFI BC

              • EFI Xscale

              • EFI x86-64

       <b>user_class</b> <b>=</b> <b>&lt;user_class&gt;</b>
              Optionally restrict this bootfile to PXE clients  sending  this  user  class.  The  <u>user_class</u>  is
              matched against the value of the client with simple comparison (no regular expression).

              Example:
                 <u>user_class</u> <u>=</u> <u>iPXE</u>

              This restricts the bootfile to the iPXE boot firmware.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following paragraphs contain some hopefully helpful examples:

   <b>Minimal</b> <b>configuration</b>
          Here  in  this  minimalistic  example the server daemon listens on interface eth0. It does not use any
          client configuration source but answers requests with  default  addresses.   These  are  made  of  the
          pattern        fd01:db8:dead:bad:beef:$mac$       and       result       in       addresses       like
          fd01:db8:deaf:bad:beef:1020:3040:5060  if   the   MAC   address   of   the   requesting   client   was
          10:20:30:40:50:60.

            [dhcpy6d]
            # Set to yes to really answer to clients.
            really_do_it = yes

            # Interface to listen to multicast ff02::1:2.
            interface = eth0

            # Some server DUID.
            serverduid = 0001000134824528134567366121

            # Do not identify and configure clients.
            store_config = none

            # SQLite DB for leases and LLIP-MAC-mapping.
            store_volatile = sqlite
            store_sqlite_volatile = /var/lib/dhcpy6d/volatile.sqlite

            # Special address type which applies to all not specially.
            # configured clients.
            [address_default]
            # Choosing MAC-based addresses.
            category = mac
            # ULA-type address pattern.
            pattern = fd01:db8:dead:bad:beef:$mac$

   <b>Configuration</b> <b>with</b> <b>valid</b> <b>and</b> <b>unknown</b> <b>clients</b>
          This  example  shows some more complexity. Here only valid hosts will get a random global address from
          2001:db8::/64.  Unknown clients get a default ULA range address from fc00::/7.

            [dhcpy6d]
            # Set to yes to really answer to clients.
            really_do_it = yes

            # Interface to listen to multicast ff02::1:2.
            interface = eth0

            # Server DUID - if not set there will be one generated every time dhcpy6d starts.
            # This might cause trouble for Windows clients because they go crazy about the
            # changed server DUID.
            serverduid = 0001000134824528134567366121

            # Non-privileged user/group.
            user = dhcpy6d
            group = dhcpy6d

            # Nameservers for option 23 - there can be several specified separated by spaces.
            nameserver = fd00:db8::53

            # Domain to be used for option 39 - host FQDN.
            domain = example.com

            # Domain search list for option 24 - domain search list.
            # If omitted the value of option "domain" above is taken as default.
            domain_search_list = example.com

            # Do logging.
            log = yes
            # Log to console.
            log_console = no
            # Path to logfile.
            log_file = /var/log/dhcpy6d.log

            # Use SQLite for client configuration.
            store_config = sqlite

            # Use SQLite for volatile data.
            store_volatile = sqlite

            # Paths to SQLite database files.
            store_sqlite_config = /var/lib/dhcpy6d/config.sqlite
            store_sqlite_volatile = /var/lib/dhcpy6d/volatile.sqlite

            # Declare which attributes of a requesting client should be checked
            # to prove its identity. It is  possible to mix them, separated by spaces.
            identification = mac

            # Declare if all checked attributes have to match or is it enough if
            # some do. Kind of senseless with just one attribute.
            identification_mode = match_all

            # These lifetimes are also used as default for addresses which
            # have no extra defined lifetimes.
            preferred_lifetime = 43200
            valid_lifetime = 64800
            t1 = 21600
            t2 = 32400

            # ADDRESS DEFINITION
            # Addresses for proper valid clients.
            [address_valid_clients]
            # Better privacy for global addresses with category random.
            category = random
            # The following pattern will result in addresses like 2001:0db8::d3f6:834a:03d5:139c.
            pattern = 2001:db8::$random64$

            # Default addresses for unknown invalid clients.
            [address_default]
            # Unknown clients will get an internal ULA range-based address.
            category = range
            # The keyword "range" sets the range used in pattern.
            range = 1000-1fff
            # This pattern results in addresses like fd00::1234.
            pattern = fd00::$range$

            # CLASS DEFINITION

            # Class for proper valid client.
            [class_valid_clients]
            # At least one of the above address schemes has to be set.
            addresses = valid_clients
            # Valid clients get a different nameserver.
            nameserver = 2001:db8::53

            # Default class for unknown hosts - only necessary here because of time interval settings.
            [class_default]
            addresses = default
            # Short interval of address refresh attempts so that a client's status
            # change will be reflected in IPv6 address soon.
            t1 = 600
            t2 = 900

   <b>Configuration</b> <b>with</b> <b>2</b> <b>network</b> <b>segments,</b> <b>servers,</b> <b>valid</b> <b>and</b> <b>unknown</b> <b>clients</b>
          This example uses 2 network segments, one for servers and one for clients. Servers here only get local
          ULA addresses.  Valid clients get 2 addresses, one local ULA and one global GUA address. This  feature
          of  DHCPv6  is  at the moment only well supported by Windows clients. Unknown clients will get a local
          ULA address. Only valid clients and servers will get information about nameservers.

            [dhcpy6d]
            # Set to yes to really answer to clients.
            really_do_it = yes

            # Interfaces to listen to multicast ff02::1:2.
            # eth1 - client network
            # eth2 - server network
            interface = eth1 eth2

            # Server DUID - if not set there will be one generated every time dhcpy6d starts.
            # This might cause trouble for Windows clients because they go crazy about the
            # changed server DUID.
            serverduid = 0001000134824528134567366121

            # Non-privileged user/group.
            user = dhcpy6d
            group = dhcpy6d

            # Domain to be used for option 39 - host FQDN.
            domain = example.com

            # Domain search list for option 24 - domain search list.
            # If omited the value of option "domain" above is taken as default.
            domain_search_list = example.com

            # Do logging.
            log = yes
            # Log to console.
            log_console = no
            # Path to logfile.
            log_file = /var/log/dhcpy6d.log

            # Use MySQL for client configuration.
            store_config = mysql

            # Use MySQL for volatile data.
            store_volatile = mysql

            # Data used for MySQL storage.
            store_db_host = localhost
            store_db_db = dhcpy6d
            store_db_user = dhcpy6d
            store_db_password = dhcpy6d

            # Declare which attributes of a requesting client should be checked
            # to prove its identity. It is  possible to mix them, separated by spaces.
            identification = mac

            # Declare if all checked attributes have to match or is it enough if
            # some do. Kind of senseless with just one attribute.
            identification_mode = match_all

            # These lifetimes are also used as default for addresses which
            # have no extra defined lifetimes.
            preferred_lifetime = 43200
            valid_lifetime = 64800
            t1 = 21600
            t2 = 32400

            # ADDRESS DEFINITION

            # Global addresses for proper valid clients (GUA).
            [address_valid_clients_global]
            # Better privacy for global addresses with category random.
            category = random
            # The following pattern will result in addresses like 2001:0db8::d3f6:834a:03d5:139c.
            pattern = 2001:db8::$random64$

            # Local addresses for proper valid clients (ULA).
            [address_valid_clients_local]
            # Local addresses need no privacy, so they will be based of range.
            category = range
            range = 2000-2FFF
            # Valid clients will get local ULA addresses from fd01::/64.
            pattern = fd01::$range$

            # Servers in servers network will get local addresses based on IDs from client configuration.
            [address_servers]
            # IDs are set in client configuration database in range of 0-FFFF.
            category = id
            # Servers will get local ULA addresses from fd02::/64.
            pattern = fd02::$id$

            # Default addresses for unknown invalid clients
            [address_default]
            # Unknown clients will get an internal ULA range-based address.
            category = range
            # The keyword "range" sets the range used in pattern.
            range = 1000-1FFF
            # This pattern results in addresses like fd00::1234.
            pattern = fd00::$range$

            # CLASS DEFINITION

            # Class for proper valid client.
            [class_valid_clients]
            # Clients only exist in network linked with eth1.
            interface = eth1
            # Valid clients get 2 addresses, one local ULA and one global GUA
            # (only works reliably with Windows clients).
            addresses = valid_clients_global valid_clients_local
            # Only valid clients get a nameserver from server network.
            nameserver = fd02::53

            # Class for servers in network on eth2
            [class_servers]
            # Servers only exist in network linked with eth2.
            interface = eth2
            # Only local addresses for servers.
            addresses = servers
            # Nameserver from server network.
            nameserver = fd02::53

            # Default class for unknown hosts - only necessary here because of time interval settings
            [class_default]
            addresses = default
            # Short interval of address refresh attempts so that a client's status
            # change will be reflected in IPv6 address soon.
            t1 = 600
            t2 = 900

   <b>Configuration</b> <b>with</b> <b>dynamic</b> <b>DNS</b> <b>Updates</b>
          In this example the hostnames of valid clients will be registered in the Bind DNS server. The zones to
          be updated are configured for every address definition. Here only the global GUA addresses  for  valid
          clients will be updated in DNS.  The hostnames will be taken from client configuration data - the ones
          supplied by the clients are ignored.

            [dhcpy6d]
            # Set to yes to really answer to clients.
            really_do_it = yes

            # Interface to listen to multicast ff02::1:2.
            interface = eth0

            # Server DUID - if not set there will be one generated every time dhcpy6d starts.
            # This might cause trouble for Windows clients because they go crazy about the
            # changed server DUID.
            serverduid = 0001000134824528134567366121

            # Non-privileged user/group.
            user = dhcpy6d
            group = dhcpy6d

            # Nameservers for option 23 - there can be several specified separated by spaces.
            nameserver = fd00:db8::53

            # Domain to be used for option 39 - host FQDN.
            domain = example.com

            # Domain search list for option 24 - domain search list.
            # If omited the value of option "domain" above is taken as default.
            domain_search_list = example.com

            # This works at the moment only for ISC Bind nameservers.
            dns_update = yes

            # RNDC key name for DNS Update.
            dns_rndc_key = rndc-key

            # RNDC secret - mostly some MD5-hash. Take it from
            # nameservers' /etc/rndc.key.
            dns_rndc_secret = 0123456789012345679

            # Nameserver to talk to.
            dns_update_nameserver = ::1

            # Regarding RFC 4704 5. there are 3 kinds of client behaviour
            # for N O S bits:
            # - client wants to update DNS itself -&gt; sends 0 0 0
            # - client wants server to update DNS -&gt; sends 0 0 1
            # - client wants no server DNS update -&gt; sends 1 0 0
            # Ignore client ideas about DNS (if at all, what name to use, self-updating...)
            # Here client hostname is taken from client configuration
            dns_ignore_client = yes

            # Do logging.
            log = yes
            # Log to console.
            log_console = no
            # Path to logfile.
            log_file = /var/log/dhcpy6d.log

            # Use SQLite for client configuration.
            store_config = sqlite

            # Use SQLite for volatile data.
            store_volatile = sqlite

            # Paths to SQLite database files.
            store_sqlite_config = config.sqlite
            store_sqlite_volatile = volatile.sqlite

            # Declare which attributes of a requesting client should be checked
            # to prove its identity. It is  possible to mix them, separated by spaces.
            identification = mac

            # ADDRESS DEFINITION

            # Addresses for proper valid clients.
            [address_valid_clients]
            # Better privacy for global addresses with category random.
            category = random
            # The following pattern will result in addresses like 2001:0db8::d3f6:834a:03d5:139c.
            pattern = 2001:db8::$random64$
            # Update these addresses in Bind DNS
            dns_update = yes
            # Zone to update.
            dns_zone = example.com
            # Reverse zone to update
            dns_rev_zone = 8.b.d.0.1.0.0.2.ip6.arpa

            # Default addresses for unknown invalid clients.
            [address_default]
            # Unknown clients will get an internal ULA range-based address.
            category = range
            # The keyword "range" sets the range used in pattern.
            range = 1000-1FFF
            # This pattern results in addresses like fd00::1234.
            pattern = fd00::$range$

            # CLASS DEFINITION

            # Class for proper valid client.
            [class_valid_clients]
            # At least one of the above address schemes has to be set.
            addresses = valid_clients
            # Valid clients get a different nameserver.
            nameserver = 2001:db8::53

   <b>Configuration</b> <b>with</b> <b>filter</b>
          In  this  example  the  membership  of  a  client to a class is defined by a filter for hostnames. All
          Windows machines have win*-names here and when requesting an address this hostname gets filtered.

            [dhcpy6d]
            # Set to yes to really answer to clients.
            really_do_it = yes

            # Interface to listen to multicast ff02::1:2.
            interface = eth0

            # Server DUID - if not set there will be one generated every time dhcpy6d starts.
            # This might cause trouble for Windows clients because they go crazy about the
            # changed server DUID.
            serverduid = 0001000134824528134567366121

            # Use no client configuration.
            store_config = none

            # Use SQLite for volatile data.
            store_volatile = sqlite

            # Paths to SQLite database file.
            store_sqlite_volatile = volatile.sqlite

            # ADDRESS DEFINITION

            [address_local]
            category = range
            range = 1000-1FFF
            pattern = fd00::$range$

            [address_global]
            category = random
            pattern = 2001:638::$random64$

            # CLASS DEFINITION

            [class_windows]
            addresses = local
            # Python regular expressions to be used here
            filter_hostname = win.*
            [class_default]
            addresses = global

   <b>Configuration</b> <b>with</b> <b>prefixes</b>
       Here dhcpy6d also provides prefixes in the default class. To avoid heavy  load  by  bad  clients  request
       limits are activated.

            [dhcpy6d]
            interface = eth0
            server_preference = 255

            store_config = none
            store_volatile = sqlite
            store_sqlite_volatile = /var/lib/dhcpy6d/volatile.sqlite

            log = on
            log_console = yes
            log_syslog = yes
            log_file = /var/log/dhcpy6d.log

            identification_mode = match_all
            identification = mac

            nameserver = 2001:db8::53
            ntp_server = 2001:db8::123

            # Mitigate ugly and aggressive clients
            request_limit = yes
            request_limit_time = 30
            request_limit_count = 10
            request_limit_identification = llip
            ignore_iaid = yes
            ignore_unknown_clients = yes

            advertise = addresses prefixes
            manage_routes_at_start = yes

            [address_default]
            category = mac
            pattern = 2001:db8::$mac$

            [prefix_default]
            category = range
            range = 0000-ffff
            pattern = 2001:db8:0:$range$::
            route_link_local = yes
            length = 64

            [class_default]
            addresses = default
            prefixes = default
            call_up = sudo ip -6 route add $prefix$/$length$ via $router$ dev eth0
            call_down = sudo ip -6 route delete $prefix$/$length$ via $router$ dev eth0

   <b>Only</b> <b>use</b> <b>fixed</b> <b>addresses</b>
       If  no  addresses should be generated, the clients need to have an address defined in their configuration
       file or database. It looks like this:
          [example-client]
          hostname = example-client
          mac = 01:02:03:04:05:06
          class = fixed_address
          address = 2001:db8::1234

       The according class of the client simply must not have any address  definition  an  might  as  well  stay
       empty:

            [dhcpy6d]
            # Set to yes to really answer to clients.
            really_do_it = yes

            # Interface to listen to multicast ff02::1:2.
            interface = eth0

            # Some server DUID.
            serverduid = 0001000134824528134567366121

            # Do not identify and configure clients.
            store_config = none

            # SQLite DB for leases and LLIP-MAC-mapping.
            store_volatile = sqlite
            store_sqlite_volatile = /var/lib/dhcpy6d/volatile.sqlite

            # Special address type which applies to all not specially.
            # configured clients.
            [address_default]
            # Choosing MAC-based addresses.
            category = mac
            # ULA-type address pattern.
            pattern = fd01:db8:dead:bad:beef:$mac$
            # To use the EUI-64 instead of the plain MAC address:
            #category = eui64
            #pattern = fd01:db8:dead:bad:$eui64$

            [class_fixed_address]
            # just no address definiton here

   <b>Supply</b> <b>a</b> <b>PXE</b> <b>bootfile</b> <b>for</b> <b>different</b> <b>CPU</b> <b>architectures</b> <b>and</b> <b>user</b> <b>classes</b>
       This example how to assign PXE bootfiles depending on CPU architecture and user class:
          [class_default_eth1]
          bootfiles = eth1_ipxe eth1_efi64 eth1_efi32 eth1_efibc
          addresses = eth1
          interface = eth1
          nameserver = fdff:cc21:56df:8bc8:5054:00ff:fec2:c5dd 2001:0470:76aa:00f5:5054:00ff:fec2:c5dd
          filter_mac = .*

          [address_eth1]
          # Choosing EUI-64-based addresses.
          category = eui64
          # ULA-type address pattern.
          pattern = fdff:cc21:56df:8bc8::$eui64$

          [bootfile_eth1_ipxe]
          user_class = iPXE
          bootfile_url = <u>tftp://[fdff:cc21:56df:8bc8:5054:00ff:fec2:c5dd]/default.ipxe</u>

          [bootfile_eth1_efi32]
          client_architecture = 0006
          bootfile_url = <u>tftp://[fdff:cc21:56df:8bc8:5054:00ff:fec2:c5dd]/efi32/ipxe.efi</u>

          [bootfile_eth1_efibc]
          client_architecture = 0007
          bootfile_url = <u>tftp://[fdff:cc21:56df:8bc8:5054:00ff:fec2:c5dd]/efi64/ipxe.efi</u>

          [bootfile_eth1_efi64]
          client_architecture = 0009
          bootfile_url = <u>tftp://[fdff:cc21:56df:8bc8:5054:00ff:fec2:c5dd]/efi32/ipxe.efi</u>

          [bootfile_eth2_ipxe]
          user_class = iPXE
          bootfile_url = <u>tftp://[fdff:cc21:56df:fe1d:5054:00ff:fe3f:5da0]/default.ipxe</u>

          [bootfile_eth2_efi32]
          client_architecture = 0006
          bootfile_url = <u>tftp://[fdff:cc21:56df:fe1d:5054:00ff:fe3f:5da0]/efi32/ipxe.efi</u>

          [bootfile_eth2_efibc]
          client_architecture = 0007
          bootfile_url = <u>tftp://[fdff:cc21:56df:fe1d:5054:00ff:fe3f:5da0]/efi64/ipxe.efi</u>

          [bootfile_eth2_efi64]
          client_architecture = 0009
          bootfile_url = <u>tftp://[fdff:cc21:56df:fe1d:5054:00ff:fe3f:5da0]/efi32/ipxe.efi</u>

       At first there is a check for the iPXE boot firmware, which delivers an iPXE script on success. Otherwise
       the iPXE binary matching to the architecture is served.

</pre><h4><b>LICENSE</b></h4><pre>
       This  program  is  free  software;  you  can  redistribute it and/or modify it under the terms of the GNU
       General Public License as published by the Free Software Foundation; either version 2 of the License,  or
       (at your option) any later version.

       This  program  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General  Public
       License for more details.

       You  should have received a copy of the GNU General Public License along with this package; if not, write
       to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

       On Debian systems, the full text of the GNU General Public License version 2 can be  found  in  the  file
       <u><a href="file:/usr/share/common-licenses/GPL-2">/usr/share/common-licenses/GPL-2</a></u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       • <a href="../man8/dhcpy6d.8.html">dhcpy6d</a>(8)

       • <a href="../man5/dhcpy6d-clients.conf.5.html">dhcpy6d-clients.conf</a>(5)

       • <u>https://dhcpy6d.de</u>

       • <u>https://github.com/HenriWahl/dhcpy6d</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2012-2022 Henri Wahl &lt;<a href="mailto:henri@dhcpy6d.de">henri@dhcpy6d.de</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This manual page is licensed under the GPL-2 license.

1.0.3                                              2020-12-21                                    <u><a href="../man5/DHCPY6D.CONF.5.html">DHCPY6D.CONF</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>