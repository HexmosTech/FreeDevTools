<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>compiled.rules  -  compiled  fapolicyd  rules  to  determine  access  rights fapolicyd.rules - deprecated</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/fapolicyd">fapolicyd_1.3.4-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       compiled.rules  -  compiled  fapolicyd  rules  to  determine  access  rights fapolicyd.rules - deprecated
       fapolicyd rules to determine access rights

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>compiled.rules</b> is a file that is compiled by <b>fagenrules</b> which contains the rules that <b>fapolicyd</b>  uses  to
       make decisions about access rights. The rules follow a simple format of:

       <b>decision</b> <b>perm</b> <b>subject</b> <b>:</b> <b>object</b>

       They  are  evaluated  from  top  to bottom with the first rule to match being used for the access control
       decision. The colon is mandatory to separate subject and object since they share keywords.

   <b>Decision</b>
       The decision is either <u>allow</u>, <u>deny</u>, <u>allow_audit</u>, <u>deny_audit</u>,  <u>allow_syslog</u>,  <u>deny_syslog</u>,  <u>allow_log</u>,  or
       <u>deny_log</u>.   If the rule triggers, this is the access decision that fapolicyd will tell the kernel. If the
       decision is one of the audit variety, then the decision will trigger a  FANOTIFY  audit  event  with  all
       relevant  information.   <b>You</b> <b>must</b> <b>have</b> <b>at</b> <b>least</b> <b>one</b> <b>audit</b> <b>rule</b> <b>loaded</b> <b>to</b> <b>generate</b> <b>an</b> <b>audit</b> <b>event.</b>  If the
       decision is one of the syslog variety, then the decision will trigger writing an event  into  syslog.  If
       the decision is of one the log variety, then it will create an audit event and a syslog event. Regardless
       of  the  notification,  any rule with a deny in the keyword will deny access and any with an allow in the
       keyword will allow access.

   <b>Perm</b>
       Perm describes what kind permission is being asked for. The permission is either <u>open</u>, <u>execute</u>,  or  <u>any</u>.
       If none are given, then open is assumed.

   <b>Subject</b>
       The  subject  is  the process that is performing actions on system resources. The fields in the rule that
       describe the subject are written in a name=value format. There can be one or more  subject  fields.  Each
       field is and'ed with others to decide if a rule triggers. The name values can be any of the following:

              <b>all</b>         This  matches  against  any  subject.  When used, this must be the only subject in the
                          rule.

              <b>auid</b>        This is the login uid that the audit system assigns users when  they  log  in  to  the
                          system.  Daemons  have  a  value  of -1. The given value may be numeric or the account
                          name.

              <b>uid</b>         This is the user id that the program is running under. The given value may be  numeric
                          or the account name.

              <b>gid</b>         This is the group id that the program is running under. The given value may be numeric
                          or the group name.

              <b>sessionid</b>   This  is  the  numeric session id that the audit system assigns to users when they log
                          in. Daemons have a value of -1.

              <b>pid</b>         This is the numeric process id that a program has.

              <b>ppid</b>        This is the numeric process id of the program's parent. Note that  programs  that  are
                          orphaned  or started directly from systemd have a ppid value of 1. Kernel threads have
                          a ppid value of 2.

              <b>trust</b>       This is a boolean describing whether it is required for the subject to be in the trust
                          database or not. A value of 1 means its required while 0 means its not. Trust checking
                          is extended by the integrity setting in fapolicyd.conf. When  trust  is  used  on  the
                          subject,  it  could be a daemon. If that daemon gets updated on disk, the trustdb will
                          be updated to the new SHA256 hash. If the integrity setting is not none,  the  running
                          daemon is not likely to be trusted unless it gets restarted. The default rules are not
                          written  in  a  way that this would happen. But this needs to be highlighted as it may
                          not be obvious when writing a new rule.

              <b>comm</b>        This is the shortened command name. When an interpreter starts a program,  it  usually
                          renames the program to the script rather than the interpreter.

              <b>exe</b>         This  is  the full path to the executable. Globbing is not supported. You may also use
                          the special keyword <b>untrusted</b> to match on the subject not  being  listed  in  the  rpm
                          database.

              <b>dir</b>         If  you  wish  to  match  a  directory,  then  use this by giving the full path to the
                          directory. Its recommended to end with the / to ensure it matches a  directory.  There
                          are 3 keywords that <u>dir</u> supports: <b>execdirs</b>, <b>systemdirs</b>, <b>untrusted</b>.

                          <b>execdirs</b>    The <u>execdirs</u> option will match against the following list of directories:

                                      <a href="file:/usr/">/usr/</a>       <a href="file:/bin/">/bin/</a> <a href="file:/sbin/">/sbin/</a> <a href="file:/lib/">/lib/</a> <a href="file:/lib64/">/lib64/</a> <a href="file:/usr/libexec/">/usr/libexec/</a>

                          <b>systemdirs</b>  The  <u>systemdirs</u>  option  will  match against the same list as <u>execdirs</u> but
                                      also includes <a href="file:/etc/.">/etc/.</a>

                          <b>untrusted</b>   The <u>untrusted</u> option will look up the current executable's  full  path  in
                                      the rpm database to see if the executable is known to the system. The rule
                                      will  trigger  if  the file in question is not in the trust database. This
                                      option is <b>deprecated</b> in favor of using obj_trust with  execute  permission
                                      when writing rules.

              <b>ftype</b>       This  option  takes  the  mime type of a file as an argument. If you wish to check the
                          mime type of a file while writing rules, run the following command:

                          <b>fapolicyd-cli</b> <b>--ftype</b> <b>/path-to-file</b>

              <b>device</b>      This option will match against the device that the executable resides on. To  use  it,
                          start with <a href="file:/dev/">/dev/</a> and add the target device name.

              <b>pattern</b>     There are various ways that an attacker may try to execute code that may reveal itself
                          in the pattern of file accesses made during program startup. This rule can take one of
                          several  options depending on which access patterns is wished to be blocked. Fapolicyd
                          is able to detect these different access patterns and provide the access  decision  as
                          soon as it identifies the pattern. The pattern type can be any of:

                          <b>normal</b>      This matches against any ELF program that is dynamically linked.

                          <b>ld_so</b>       This  matches  against  access  patterns that indicate that the program is
                                      being started directly by the runtime linker.

                          <b>ld_preload</b>  This matches against access patterns that indicate  that  the  program  is
                                      being   started   with  either  LD_PRELOAD  or  LD_AUDIT  present  in  the
                                      environment. Note that even without this rule, you have protection against
                                      LD_PRELOAD of unknown binaries when the rules are written such that  trust
                                      is  used  to  determine  if  a library should be opened. In that case, the
                                      preloaded library would be denied but the application will still  execute.
                                      This  rule  makes  it so that even trusted libraries can be denied and the
                                      application will not execute.

                          <b>static</b>      This matches against ELF files that are statically linked.

   <b>Object</b>
       The object is the file that the subject is interacting with. The fields in the  rule  that  describe  the
       object  are  written in a name=value format. There can be one or more object fields. Each field is and'ed
       with others to decide if a rule triggers. The name values can be any of the following:

              <b>all</b>         This matches against any obbject. When used, this must be the only object in the rule.

              <b>path</b>        This is the full path to the file that will be accessed. Globbing  is  not  supported.
                          You may also use the special keyword <b>untrusted</b> to match on the object not being listed
                          in the rpm database.

              <b>dir</b>         If you wish to match on access to any file in a directory, then use this by giving the
                          full  path  to the directory. Its recommended to end with the / to ensure it matches a
                          directory. There are 3 keywords that <u>dir</u> supports:  <b>execdirs</b>,  <b>systemdirs</b>,  <b>untrusted</b>.
                          See the <b>dir</b> option under Subject for an explanation of these keywords.

              <b>device</b>      This  option will match against the device that the file being accessed resides on. To
                          use it, start with <a href="file:/dev/">/dev/</a> and add the target device name.

              <b>ftype</b>       This option matches against the mime type of the file being accessed. See <b>ftype</b>  under
                          Subject for more information on determining the mime type.

              <b>trust</b>       This  is a boolean describing whether it is required for the object to be in the trust
                          database or not. A value of 1 means its required while 0 means its not. Trust checking
                          is extended by the integrity setting in fapolicyd.conf.

              <b>sha256hash</b>  This option matches against the sha256 hash of the file being accessed.  The  hash  in
                          the  rules  should be all lowercase letters and do NOT start with 0x. Lowercase is the
                          default output of sha256sum.

</pre><h4><b>SETS</b></h4><pre>
       Set is a named group of values of the same type.  Fapolicyd  internally  distinguishes  between  INT  and
       STRING  set  types.  You can define your own set and use it as a value for a specific rule attribute. The
       definition is in key=value syntax and starts with a set name. The set name has to start with '%' and  the
       rest  is  alphanumeric  or  '_'.  The value is a comma separated list. The set type is inherited from the
       first item in the list. If that can be turned into number then whole list is expected to  carry  numbers.
       One  can  use these sets as a value for subject and object attributes. It is also possible to use a plain
       list as an attribute value without previous definition. The assigned set has to match the attribute type.
       It is not possible set groups for TRUST and PATTERN attributes.

   <b>SETS</b> <b>EXAMPLES</b>
       <b>#</b> <b>definition</b>
       <b>%python=/usr/bin/python2.7,/usr/bin/python3.6</b>
       <b>allow</b> <b>exe=%python</b> <b>:</b> <b>all</b> <b>trust=1</b>
       <b>#</b>
       <b>#</b> <b>definition</b>
       <b>#</b> <b>number</b> <b>set</b>
       <b>%uuids=0,1000</b>
       <b>allow</b> <b>uid=%uuids</b> <b>:</b> <b>all</b>

</pre><h4><b>NOTES</b></h4><pre>
       When writing rules, you should keep them focused to one goal and store them in one file. These rule files
       are kept in the /etc/fapolicyd/rules.d directory. During daemon startup, <b>fagenrules</b> will run and  compile
       all  these  component  files  into  one master file, compiled.rules. See the <b>fagenrules</b> man page for more
       information.

       When you are writing a rule for the execute permission, remember that the  file  to  be  executed  is  an
       <b>object.</b>   For  example,  you  type  ssh  into  the shell. The shell calls execve on /usr/bin/ssh. At that
       instant in time, ssh is the object that bash is working on. However, if you are blocking execution <u>from</u> a
       specific program, then you would normally state the program on the subject  side  and  use  <u>all</u>  for  the
       object side.

       If  you  are  writing  rules  that  use patterns, just select <u>any</u> as the permission to be clear that this
       applies to anything. In reality, pattern matching ignores  the  permission  but  the  suggestion  is  for
       documentation purposes.

       Some  interpreters  do not immediately read all lines of input. Rather, they read content as needed until
       they get to end of file. This means that if they do stuff like networking or sleeping  or  anything  that
       takes  time,  someone with the privileges to modify the file can add to it after the file's integrity has
       been checked. This is not unique to fapolicyd, it's simply how things work. Make sure that  trusted  file
       permissions are not excessive so that no unexpected file content modifications can occur.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following rules illustrate the rule syntax.

       <b>deny_audit</b> <b>perm=open</b> <b>exe=<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wget">/usr/bin/wget</a></b> <b>:</b> <b>dir=<a href="file:/tmp">/tmp</a></b>
       <b>allow</b> <b>perm=open</b> <b>exe=/usr/bin/python3.7</b> <b>:</b> <b>ftype=text/x-python</b> <b>trust=1</b>
       <b>deny_audit</b> <b>perm=any</b> <b>pattern</b> <b>ld_so</b> <b>:</b> <b>all</b>
       <b>deny</b> <b>perm=any</b> <b>all</b> <b>:</b> <b>all</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/fapolicyd.8.html">fapolicyd</a></b>(8), <b>fagenrules</b> <b>(8),</b> <b><a href="../man8/fapolicyd-cli.8.html">fapolicyd-cli</a></b>(8), and <b><a href="../man5/fapolicyd.conf.5.html">fapolicyd.conf</a></b>(5)

</pre><h4><b>AUTHOR</b></h4><pre>
       Steve Grubb

Red Hat                                             June 2022                                <u>FAPOLICYD.RULES:</u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>