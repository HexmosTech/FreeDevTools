<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gfshare_ctx_init_enc, etc. - Shamir Secret Sharing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgfshare-dev">libgfshare-dev_2.0.0-7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gfshare_ctx_init_enc, etc. - Shamir Secret Sharing

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;libgfshare.h&gt;</b>

       <b>gfshare_rand_func_t</b> <b>gfshare_fill_rand;</b>

       <b>gfshare_rand_func_t</b> <b>gfshare_bad_idea_but_fill_rand_using_random;</b>

       <b>gfshare_ctx</b> <b>*gfshare_ctx_init_enc(</b> <b>unsigned</b> <b>char</b> <b>*</b><u>sharenrs</u><b>,</b>
                                          <b>unsigned</b> <b>int</b>   <u>sharecount</u><b>,</b>
                                          <b>unsigned</b> <b>char</b>  <u>threshold</u><b>,</b>
                                          <b>unsigned</b> <b>int</b>   <u>size</u> <b>);</b>

       <b>gfshare_ctx</b> <b>*gfshare_ctx_init_dec(</b> <b>unsigned</b> <b>char</b> <b>*</b><u>sharenrs</u><b>,</b>
                                          <b>unsigned</b> <b>int</b>   <u>sharecount</u><b>,</b>
                                          <b>unsigned</b> <b>int</b>   <u>size</u> <b>);</b>

       <b>void</b> <b>gfshare_ctx_free(</b> <b>gfshare_ctx</b> <b>*</b><u>ctx</u> <b>);</b>

       <b>void</b> <b>gfshare_ctx_enc_setsecret(</b> <b>gfshare_ctx</b>   <b>*</b><u>ctx</u><b>,</b>
                                       <b>unsigned</b> <b>char</b> <b>*</b><u>secret</u> <b>);</b>

       <b>void</b> <b>gfshare_ctx_enc_getshare(</b> <b>gfshare_ctx</b>   <b>*</b><u>ctx</u><b>,</b>
                                      <b>unsigned</b> <b>char</b>  <u>sharenr</u><b>,</b>
                                      <b>unsigned</b> <b>char</b> <b>*</b><u>share</u> <b>);</b>

       <b>void</b> <b>gfshare_ctx_dec_newshares(</b> <b>gfshare_ctx</b>   <b>*</b><u>ctx</u><b>,</b>
                                       <b>unsigned</b> <b>char</b> <b>*</b><u>sharenrs</u> <b>);</b>

       <b>void</b> <b>gfshare_ctx_dec_giveshare(</b> <b>gfshare_ctx</b>   <b>*</b><u>ctx</u><b>,</b>
                                       <b>unsigned</b> <b>char</b>  <u>sharenr</u><b>,</b>
                                       <b>unsigned</b> <b>char</b> <b>*</b><u>share</u> <b>);</b>

       <b>void</b> <b>gfshare_ctx_dec_extract(</b> <b>gfshare_ctx</b>   <b>*</b><u>ctx</u><b>,</b>
                                     <b>unsigned</b> <b>char</b> <b>*</b><u>secretbuf</u> <b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>gfshare_fill_rand</b> variable must contain a pointer to a function which takes an <b>unsigned</b> <b>char</b> <b>*</b> and an
       <b>unsigned</b>  <b>int</b>  and fills the given buffer with the given number of random bytes before calling any of the
       functions which create or populate contexts.
       If you cannot  do  this  with  a  cryptographically  secure  mechanism  then  the  library  provides  the
       <b>gfshare_bad_idea_but_fill_rand_using_random</b> value which you can put into <b>gfshare_fill_rand</b> and which will
       use  the  C  library function <b>random</b>() to fill the buffer.  You should ensure you call <b>srandom</b>() at least
       once before using any of the other functions though.

       The <b>gfshare_ctx_init_enc</b>() function returns a context object which can be used for encoding shares  of  a
       secret.  The  context  encodes  against  <u>sharecount</u> shares which are numbered in the array <u>sharenrs</u>.  The
       secret is always <u>size</u> bytes long and the resultant shares will need at  least  <u>threshold</u>  of  the  shares
       present for recombination. It is critical that <u>threshold</u> be at least one lower than <u>sharecount</u>.

       The  <b>gfshare_ctx_init_dec</b>()  function  returns  a context object which can be used to recombine shares to
       recover a secret. Each share and the resulting secret will be <u>size</u> bytes long. The context can be used to
       recombine <u>sharecount</u> shares which are numbered in the <u>sharenrs</u> array.

       The <b>gfshare_ctx_free</b>() function frees all the memory associated with  a  gfshare  context  including  the
       memory belonging to the context itself.

       The  <b>gfshare_ctx_enc_setsecret</b>()  function  provides  the  secret  you wish to encode to the context. The
       <u>secret</u> will be copied into the internal buffer of the library.

       The <b>gfshare_ctx_enc_getshare</b>() function extracts a particular share from the context.  The  <u>share</u>  buffer
       must  be  preallocated  to the size of the shares and the <u>sharenr</u> parameter is an index into the <u>sharenrs</u>
       array used to initialise the context

       The <b>gfshare_ctx_dec_newshares</b>() function informs the decode context of a  change  in  the  share  numbers
       available to the context. The number of shares cannot be changed but the <u>sharenrs</u> can be zero to indicate
       that a particular share is missing currently.

       The <b>gfshare_ctx_dec_giveshare</b>() function provides the decode context with a given share. The share number
       itself was previously provided in a <u>sharenrs</u> array and the <u>sharenr</u> parameter is the index into that array
       of the number of the share being provided in the <u>share</u> memory block.

       The  <b>gfshare_ctx_dec_extract</b>()  function  combines  the  provided shares to recalculate the secret. It is
       recommended that you <b>mlock()</b> the <u>secretbuf</u> before calling this function, so that  the  recombined  secret
       will never be written to swap. This may help to prevent a malicious party discovering the content of your
       secret.  You  should  also randomise the content of the buffer once you are finished using the recombined
       secret.

</pre><h4><b>ERRORS</b></h4><pre>
       Any function which can fail for any reason will return NULL on error.

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Daniel Silverstone.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs against the libgfshare product on www.launchpad.net.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright Â© 2006,2015 Daniel Silverstone.
       This is free software. You may redistribute copies of  it  under  the  terms  of  the  MIT  licence  (the
       COPYRIGHT file in the source distribution).  There is NO WARRANTY, to the extent permitted by law.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/gfsplit.1.html">gfsplit</a>(1), <a href="../man1/gfcombine.1.html">gfcombine</a>(1), <a href="../man7/gfshare.7.html">gfshare</a>(7)

2.0.0                                               June 2015                                      <u><a href="../man5/LIBGFSHARE.5.html">LIBGFSHARE</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>