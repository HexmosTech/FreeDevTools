<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>imapfilter_config — imapfilter configuration file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/imapfilter">imapfilter_2.8.2+1-0.2build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       imapfilter_config — imapfilter configuration file

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <u>$HOME/.imapfilter/config.lua</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u><a href="../man1/imapfilter.1.html">imapfilter</a></u>(1) uses the Lua programming language as a configuration and extension language, therefore, the
       configuration file is a Lua script.

       Although knowledge of Lua is not required to use <u><a href="../man1/imapfilter.1.html">imapfilter</a></u>(1), it is nonetheless recommended, especially
       if one wants to extend it. For more information on Lua see <u><a href="http://www.lua.org/docs.html">http://www.lua.org/docs.html</a></u>.

</pre><h4><b>CONVENTIONS</b></h4><pre>
       A brief description of the Lua values and types mentioned hereafter in the manual page follows:

           The  <u>nil</u> is the type of the value “nil”, whose main property is to be different from any other value;
           usually it represents the absence of a useful value.

           The <u>boolean</u> is the type of the values “true” and “false”.  Both “nil” and “false”  make  a  condition
           false; any other value makes it true.

           The type <u>number</u> represents real numbers.

           The  type  <u>string</u>  represents a sequence of characters and can be defined using single quotes, double
           quotes or double square brackets.

           The type <u>table</u> implements associative arrays, that is, arrays that  can  be  indexed  not  only  with
           numbers, but with any value.

           A  <u>function</u>  is  a  first-class  value;  it  can  be stored in variables, passed as argument to other
           functions, and returned as a result.

</pre><h4><b>OPTIONS</b></h4><pre>
       Program's options are set using an already initialised <u>table</u> named “options”, in the following manner:

           options.timeout = 120
           options.namespace = false
           options.charset = 'ISO-8859-1'

       Available options are:

       <u>cache</u>   When this option is enabled, parts of messages are  cached  locally  in  memory  to  avoid  being
               downloaded  more  than  once.  The cache is preserved for the current session only. This variable
               takes a <u>boolean</u> as a value. Default is “true”.

       <u>certificates</u>
               When this option is enabled, the server certificate can be accepted and stored, to  validate  the
               authenticity  of  the  server  in  future  connections. This variable takes a <u>boolean</u> as a value.
               Default is “true”.

       <u>charset</u>
               Indicates to the server the character set  of  the  strings  for  the  searching  methods.   This
               variable  takes  a  <u>string</u> as a value.  By default, no character set is set, and thus plain ASCII
               should be assumed by the server.

       <u>create</u>  According to the IMAP specification, when trying to write a message to  a  non-existent  mailbox,
               the  server must send a hint to the client, whether it should create the mailbox and try again or
               not. However, some IMAP servers don't  follow  the  specification  and  don't  send  the  correct
               response  code  to  the  client.  By enabling this option the client tries to create the mailbox,
               despite of the server's response. This variable takes a <u>boolean</u> as a value.  Default is “false”.

       <u>close</u>   This option controls whether the currently selected mailbox is implicitly closed at  the  end  of
               each performed operation, thus removing all messages that are marked deleted. This variable takes
               a <u>boolean</u> as a value.  Default is “false”.

       <u>expunge</u>
               Normally,  messages  are marked for deletion and are actually deleted when the mailbox is closed.
               When this option is enabled, messages are expunged immediately after being marked deleted.   This
               variable takes a <u>boolean</u> as a value.  Default is “true”.

       <u>hostnames</u>
               When  this  option is enabled, the server hostname is validated, in order to verify the client is
               talking to the correct server. This variable takes a <u>boolean</u> as a value. Default is “true”.

       <u>info</u>    When this option is enabled, a summary of the program's  actions  is  printed,  while  processing
               mailboxes.  This variable takes a <u>boolean</u> as a value.  Default is “true”.

       <u>keepalive</u>
               The  time  in  minutes before terminating and re-issuing the IDLE command, in order to keep alive
               the connection, by resetting the inactivity timeout of the server.  A standards compliant  server
               must  have an inactivity timeout of at least 30 minutes.  But some IMAP servers might not respect
               that, or some intermediary network device has a shorter timeout.   By  setting  this  option  the
               above  problem  can  be  worked  around. This variable takes a <u>number</u> as a value. Default is “29”
               minutes.

       <u>limit</u>   Some servers have problems handling very long requests, but some of the requests that need to  be
               sent  can  become  quite  long because they apply an action for many messages at once.  When this
               option is set, the client will try to break up these requests into smaller  requests,  that  each
               operates  on fewer messages at a time.  A good value for this would be “50”.  This variable takes
               a <u>number</u> as a value.  Default is “0”.  See also the <u>range</u> option which is related.

       <u>namespace</u>
               When enabled, the program gets the namespace  of  the  user's  personal  mailboxes,  and  applies
               automatically  the  prefix  and hierarchy delimiter to any mailboxes residing on the mail server;
               the user must use the ‘/’ character as the delimiter  and  “”  (i.e.   nothing)  as  the  prefix,
               regardless  of the folder format of the mail server.  This must be disabled, if the user wants to
               manually specify mailbox names (e.g. because they are not part of the user's  personal  namespace
               mailboxes).  This variable takes a <u>boolean</u> as a value.  Default is “true”.

       <u>range</u>   Some  servers have problems handling long sequence number ranges, and by setting this option, the
               number of messages included in each range can be limited.  A good value for this would  be  “50”.
               This  variable  takes  a  <u>number</u> as a value.  By default, no such limit is imposed.  See also the
               <u>limit</u> option which is related.

       <u>starttls</u>
               When this option is enabled and the server supports the IMAP STARTTLS extension, a TLS connection
               will be negotiated with the mail server in the beginning of the session.  This variable  takes  a
               <u>boolean</u> as value.  Default is “true”.

       <u>subscribe</u>
               By  enabling this option new mailboxes that were automatically created, get also subscribed; they
               are set active in order for IMAP clients to recognize them.  This variable takes a <u>boolean</u>  as  a
               value.  Default is “false”.

       <u>timeout</u>
               The  time  in  seconds  for  the  program to wait for a mail server's response.  If set to 0, the
               client will block indefinitely.  This variable takes a  <u>number</u>  as  a  value.   Default  is  “60”
               seconds.

       <u>wakeonany</u>
               By  enabling  this  option,  the  IDLE command will return on any event that is received from the
               server, and not just on the “RECENT” and “EXISTS” events, that normally indicate the arrival of a
               new message.  Examples of other events are “FETCH”, which indicates that the details of a message
               (e.g. its flags) have been modified, or “EXPUNGE”,  which  indicates  that  a  message  has  been
               deleted.  This variable takes a <u>boolean</u> as a value.  Default is “false”.

</pre><h4><b>ACCOUNTS</b></h4><pre>
       Accounts  are  initialized using the <b>IMAP</b>() function, and the details of the connection are defined using
       an account <u>table</u>:

           myaccount = IMAP {
               server = 'imap.mail.server',
               username = 'me',
               password = 'secret',
               ssl = 'auto'
           }

       An account <u>table</u> must have the following elements:

       <u>server</u>  The hostname of the IMAP server to connect to.  It takes a <u>string</u> as a value.

       <u>username</u>
               User's name.  It takes a <u>string</u> as a value.

       An account <u>table</u> can also have the following optional elements:

       <u>password</u>
               User's secret keyword.  If a password wasn't supplied, the  user  will  be  asked  to  enter  one
               interactively  the  first time it will be needed (unless <u>oauth2</u> has been set).  It takes a <u>string</u>
               as a value.

               Passwords can also be extracted during execution time from  an  encrypted  password  vault.   The
               <u>samples/extend.lua</u> file contains such an example.

               Note  that  due to Lua using backslash ‘\’ as an escape character for its strings, one has to use
               double backslashes in order to insert a single backslash, and thus a backslash character inside a
               password might require four backslashes.

       <u>oauth2</u>  The OAuth2 string to use to authenticate  if  the  server  supports  the  XOAUTH2  authentication
               mechanism.   If  the  server does not support it and a <u>password</u> has also been set, authentication
               will be attempted using the <u>password</u>.  It takes a <u>string</u> as a value.

               Note that this requires that an OAuth client ID and client secret have been obtained,  an  OAuth2
               token  has been generated and authorized, a new access token has been generated using the refresh
               token if the last access token has expired, and an OAuth2 string  has  been  generated  from  the
               access  token.   The  aforementioned  OAuth2 string is a Base64 encoded string that should be set
               here.  For more information, see <u>https://developers.google.com/gmail/xoauth2_protocol</u>.

               The <u>samples/extend.lua</u> file contains an example of authentication using OAuth2.

       <u>port</u>    The port to connect to.  It takes a <u>number</u> as a value.  Default is “143” for imap and  “993”  for
               imaps.

       <u>ssl</u>     Forces  an  imaps  connection  and specifies the SSL/TLS protocol/version to be used.  It takes a
               <u>string</u> as a value, specifically one of: “auto”, “tls1.2”, “tls1.1”, “tls1”, “ssl3”.

               Note that the latest versions of the OpenSSL library have deprecated  version  specific  methods,
               and  the  actual  protocol  version  used,  will be negotiated to be the highest version mutually
               supported by the client and the server.  This is also what the “auto” value does.

   <b>LISTING</b>
       The following methods can be used on an account to list mailboxes in a folder of an account:

       <b>list_all</b>(<u>folder</u>)
               Lists all the available mailboxes in the <u>folder</u> (<u>string</u>),  and  returns  a  <u>table</u>  that  contains
               <u>strings</u>, the available mailboxes, and a <u>table</u> that contains <u>strings</u>, the available folders.

       <b>list_subscribed</b>(<u>folder</u>)
               Lists  all  the  subscribed  mailboxes  in the <u>folder</u> (<u>string</u>), and returns a <u>table</u> that contains
               <u>strings</u>, the subscribed mailboxes, and a <u>table</u> that contains <u>strings</u>, the subscribed folders.

       The following methods can be used on an account to list mailboxes, using wildcards, in  a  folder  of  an
       account.   The  ‘*’  wildcard,  matches any character and the ‘%’ matches any character except the folder
       delimiter, i.e.  non-recursively:

       <b>list_all</b>(<u>folder</u>, <u>mailbox</u>)
               Lists all the available mailboxes in the <u>folder</u> (<u>string</u>) with  the  name  <u>mailbox</u>  (<u>string</u>),  and
               returns  a  <u>table</u>  that  contains  <u>strings</u>,  the  available  mailboxes, and a <u>table</u> that contains
               <u>strings</u>, the available folders.  Wildcards may only be used in the <u>mailbox</u> argument.

       <b>list_subscribed</b>(<u>folder</u>, <u>mailbox</u>)
               Lists all the subscribed mailboxes in the <u>folder</u> (<u>string</u>) with the  name  <u>mailbox</u>  (<u>string</u>),  and
               returns  a  <u>table</u>  that  contains  <u>strings</u>,  the  subscribed mailboxes, and a <u>table</u> that contains
               <u>strings</u>, the subscribed folders.  Wildcards may only be used in the <u>mailbox</u> argument.

       Examples:

           mailboxes, folders = myaccount:list_subscribed('myfolder')
           mailboxes, folders = myaccount:list_all('myfolder/mysubfolder', '*')

   <b>MANIPULATING</b>
       The following methods can be used to manipulate mailboxes in an account:

       <b>create_mailbox</b>(<u>name</u>)
               Creates the <u>name</u> (<u>string</u>) mailbox.

       <b>delete_mailbox</b>(<u>name</u>)
               Deletes the <u>name</u> (<u>string</u>) mailbox.

       <b>rename_mailbox</b>(<u>oldname</u>, <u>newname</u>)
               Renames the <u>oldname</u> (<u>string</u>) mailbox to <u>newname</u> (<u>string</u>).

       <b>subscribe_mailbox</b>(<u>name</u>)
               Subscribes the <u>name</u> (<u>string</u>) mailbox.

       <b>unsubscribe_mailbox</b>(<u>name</u>)
               Unsubscribes the <u>name</u> (<u>string</u>) mailbox.

       Examples:

           myaccount:create_mailbox('mymailbox')
           myaccount:subscribe_mailbox('mymailbox')
           myaccount:unsubscribe_mailbox('myfolder/mymailbox')
           myaccount:delete_mailbox('myfolder/mymailbox')

</pre><h4><b>MAILBOXES</b></h4><pre>
       After an IMAP account has been initialized, mailboxes residing in that account can be accessed simply  as
       elements of the account <u>table</u>:

           myaccount.mymailbox

       If  mailbox  names  don't  only  include  letters,  digits  and  underscores,  or  begin with a digit, an
       alternative form must be used:

           myaccount['mymailbox']

       A mailbox inside a folder can be only accessed by using the alternative form:

           myaccount['myfolder/mymailbox']

       The methods that are available for an account (e.g.  <b>list_all</b>(), <b>create_mailbox</b>(), etc.) , are considered
       keywords and must not be used as mailbox names, and the same also applies for any string starting with an
       underscore, as they are considered reserved.

   <b>CHECKING</b>
       The following methods can be used to check the status of a mailbox:

       <b>check_status</b>()

               The <b>check_status</b>() method gets the current status of a mailbox, and returns four values of <u>number</u>
               type: the total number of messages, the number of recent messages, the number of unseen  messages
               in the mailbox, and the next UID to be assigned to a new message in the mailbox.

       <b>enter_idle</b>()
               The  <b>enter_idle</b>()  method implements the IMAP IDLE (RFC 2177) extension.  By using this extension
               it's not necessary to poll the server for changes  to  the  selected  mailbox  (i.e.   using  the
               <b>check_status</b>()  method),  but  instead  the  server sends an update when there is a change in the
               mailbox (e.g. in case of new mail).  When  the  <b>enter_idle</b>()  method  has  been  called  no  more
               commands  in  the configuration file are executed until an update is received, at which point the
               <b>enter_idle</b>() method returns.  For the  <b>enter_idle</b>()  to  work,  the  IDLE  extension  has  to  be
               supported by the IMAP server.

               The  <b>enter_idle</b>()  method  returns  a  value  of  type  <u>boolean</u>:  “true” if the IDLE extension is
               supported and there was an update in the mailbox, and  “false”  if  the  IDLE  extension  is  not
               supported,  in  which  case the method returns immediately.  When the aforementioned return value
               was “true”, an additional second value of type <u>string</u> is  also  returned,  indicating  the  event
               received from the server, which is useful when the <u>wakeonany</u> option has been enabled.

               Apart from an event received by the server, the SIGUSR1 or SIGUSR2 signals can also interrupt the
               IDLE  mode  at  any time, and the execution of the configuration file will then continue from the
               next line after the <b>enter_idle</b>().  In this case, only the value “true” is returned.

       Examples:

           exist, unread, unseen, uidnext = myaccount.mymailbox:check_status()
           update = myaccount.mymailbox:enter_idle()
           update, event = myaccount.mymailbox:enter_idle()

   <b>SEARCHING</b>
       The searching methods in this subsection can be applied to any mailbox.  They return a  special  form  of
       <u>table</u>, that contains the messages that match the searching method.  This <u>table</u> can be combined with other
       <u>tables</u>  using  logic  theory.  There are three available operations, that implement logical “or”, logical
       “and” and logical “not”.

       The logical “or” is implemented using the ‘+’ operator:

           results = myaccount.mymailbox:is_unseen() +
                     myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000)

       The logical “and” is implemented using the ‘*’ operator:

           results = myaccount.mymailbox:is_unseen() *
                     myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000)

       The logical “not” is implemented using the ‘-’ operator:

           results = myaccount.mymailbox:is_unseen() -
                     myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000)

       The three logical operators can be combined  in  the  same  expression.  The  logical  “and”  has  higher
       precedence  than  the logical “or” and the logical “not”, with the latter two having the same precedence,
       and parentheses may be used to change this behaviour:

           results = myaccount.mymailbox:is_unseen() +
                     myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000) *
                     myaccount.mymailbox:contain_subject('test')

           results = ( myaccount.mymailbox:is_unseen() +
                       myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000) ) *
                       myaccount.mymailbox:contain_subject('test')

       The returned <u>tables</u> of the searching methods can also be stored in variables and then further processed:

           unseen = myaccount.mymailbox:is_unseen()
           larger = myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000)
           subject = myaccount.mymailbox:contain_subject('test')
           results = unseen + larger * subject

       A composite filter that includes one or more simple rules can be defined:

           myfilter = function ()
                          return myaccount.mymailbox:is_unseen() +
                                 myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000) *
                                 myaccount.mymailbox:contain_subject('test')
                      end

           results = myfilter()

       Composite filters can may be more dynamic by adding arguments:

           myfilter = function (mailbox, size, subject)
                          return mailbox:is_unseen() +
                                 mailbox:is_larger(size) *
                                 mailbox:contain_subject(subject)
                      end

           results = myfilter(myaccount.mailbox, 100000, 'test')

       It is also possible to combine the searching methods in  different  mailboxes,  either  at  the  same  or
       different  accounts, for example when the same actions will be executed on messages residing in different
       mailboxes or accounts.

           results = myaccount.mymailbox:is_unseen() +
                     myaccount.myothermailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000) +
                     myotheraccount.myothermailbox:contain_subject('test')

       And for those that want to know more about the return values of the following  methods,  it  is  a  <u>table</u>
       which  contains  <u>tables</u>  with two values: the mailbox (<u>table</u>) the message belongs to, and the message UID
       (<u>number</u>) which points to the matching message.  For examples  on  iterating  these  returned  tables,  or
       creating  new  tables  of  this  format  (they  are  actually  metatables  implementing  sets),  see  the
       <u>samples/extend.lua</u> file.

           {
               { &lt;myaccount.mymailbox&gt;, 1 },
               { &lt;myaccount.mymailbox&gt;, 3 },
               { &lt;myaccount.myothermailbox&gt;, 5 },
               { &lt;myothermailbox.myothermailbox&gt;, 7},
               { ... },
               ...
           }

       The following method can be used to get all messages in a mailbox:

       <b>select_all</b>()
               All messages.

       The following methods can be used to search for messages that are in a specific state:

       <b>is_answered</b>()
               Messages that have been answered.

       <b>is_deleted</b>()
               Messages that are marked for later removal.

       <b>is_draft</b>()
               Messages that have not completed composition.

       <b>is_flagged</b>()
               Messages that are flagged for urgent/special attention.

       <b>is_new</b>()
               Messages that are recently arrived (this session is the first to have been notified  about  these
               messages) and have not been read.

       <b>is_old</b>()
               Messages that are not recently arrived (this session is not the first to have been notified about
               these messages) and have not been read.

       <b>is_recent</b>()
               Messages  that  are recently arrived (this session is the first to have been notified about these
               messages).

       <b>is_seen</b>()
               Messages that have been read.

       <b>is_unanswered</b>()
               Messages that have not been answered.

       <b>is_undeleted</b>()
               Messages that are not marked for later removal.

       <b>is_undraft</b>()
               Messages that have completed composition.

       <b>is_unflagged</b>()
               Messages that are not flagged for urgent/special attention.

       <b>is_unseen</b>()
               Messages that have not been read.

       The following method can be used to search for messages that have a specific keyword flag set:

       <b>has_keyword</b>(<u>flag</u>)
               Messages with the specified keyword flag (<u>string</u>) set.
       <b>has_unkeyword</b>(<u>flag</u>)
               Messages without the specified keyword flag (<u>string</u>) set.

       The following methods can be used to search for messages based on their size:

       <b>is_larger</b>(<u>size</u>)
               Messages that are larger than the size (<u>number</u>) in octets (bytes).

       <b>is_smaller</b>(<u>size</u>)
               Messages that are smaller than the size (<u>number</u>) in octets (bytes).

       The following methods can be used to search for messages based on their age:

       <b>is_newer</b>(<u>age</u>)
               Messages that are newer than the <u>age</u> (<u>number</u>) in days.

       <b>is_older</b>(<u>age</u>)
               Messages that are older than the <u>age</u> (<u>number</u>) in days.

       The following methods can be used to search for messages based on their arrival  or  sent  date,  in  the
       “day-month-year”  form,  where  day  is  the  day  of the month as a decimal number (01-31), month is the
       abbreviated month ( “Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”,  “Nov”,  “Dec”)
       and year is the year as decimal number including the century (e.g. 2007):

       <b>arrived_before</b>(<u>date</u>)
               messages  that have arrived earlier than the <u>date</u> (<u>string</u>), where <u>date</u> is in the “day-month-year”
               form.

       <b>arrived_on</b>(<u>date</u>)
               Messages that have arrived within the <u>date</u> (<u>string</u>), where <u>date</u> is in the “day-month-year” form.

       <b>arrived_since</b>(<u>date</u>)
               Messages that have arrived within or  later  than  the  <u>date</u>  (<u>string</u>),  where  <u>date</u>  is  in  the
               “day-month-year” form.

       <b>sent_before</b>(<u>date</u>)
               Messages   that   have  been  sent  earlier  than  the  <u>date</u>  (<u>string</u>),  where  <u>date</u>  is  in  the
               “day-month-year” form.

       <b>sent_on</b>(<u>date</u>)
               Messages that have been sent within the <u>date</u> (<u>string</u>), where  <u>date</u>  is  in  the  “day-month-year”
               form.

       <b>sent_since</b>(<u>date</u>)
               Messages  that  have  been  sent  within  or  later  than the <u>date</u> (<u>string</u>), where <u>date</u> is in the
               “day-month-year” form.

       The following methods can be used to do case-insensitive searching, for messages that contain a  specific
       word or phrase:

       <b>contain_bcc</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the “Bcc” header field.

       <b>contain_cc</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the “Cc” header field.

       <b>contain_from</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the “From” header field.

       <b>contain_subject</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the “Subject” header field.

       <b>contain_to</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the “To” header field.

       <b>contain_field</b>(<u>field</u>, <u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the <u>field</u> (<u>string</u>) header field.

       <b>contain_body</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the message body.

       <b>contain_message</b>(<u>string</u>)
               Messages that contain the <u>string</u> (<u>string</u>) in the message.

       The  following  methods  can  be  used to do case-sensitive searching, for messages that match a specific
       regular expression pattern. The matching mechanism that is used to support this is  based  on  the  Perl-
       compatible  regular expressions (PCRE), and more information about the patterns and modifiers that can be
       used, is available in the relevant documentation at <u><a href="http://pcre.org/original/doc/html/">http://pcre.org/original/doc/html/</a></u>.

       This way of searching is not supported by the IMAP protocol, and this means that  what  actually  happens
       under the hood, is that the relevant parts of all the messages are downloaded and matched locally.  It is
       therefore  recommended  to  use  these  methods  with meta-searching (see following section), in order to
       narrow down the set of messages that should be searched, and thus minimize what will be downloaded.

       Note that due to Lua using backslash ‘\’ as an escape character for its strings, one has  to  use  double
       backslashes in order to insert a single backslash inside a regular expression pattern:

       <b>match_bcc</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the “Bcc” header field.

       <b>match_cc</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the “Cc” header field.

       <b>match_from</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the “From” header field.

       <b>match_subject</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the “Subject” header field.

       <b>match_to</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the “To” header field.

       <b>match_field</b>(<u>field</u>, <u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the <u>field</u> (<u>string</u>) header field.

       <b>match_header</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the message header.

       <b>match_body</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the message body.

       <b>match_message</b>(<u>pattern</u>)
               Messages that match the regular expression <u>pattern</u> (<u>string</u>) in the message.

       The  following  method  can  be  used  to  search  for  messages  using  user  queries  based on the IMAP
       specification (RFC 3501 Section 6.4.4):

       <b>send_query</b>(<u>criteria</u>)
               Searches messages by sending an IMAP search query as described in the search <u>criteria</u> (<u>string</u>).

       Examples:

           results = myaccount.mymailbox:select_all()
           results = myaccount.mymailbox:is_new()
           results = myaccount.mymailbox:is_recent()
           results = myaccount.mymailbox:<a href="../man100000/is_larger.100000.html">is_larger</a>(100000)
           results = myaccount.mymailbox:<a href="../man10/is_older.10.html">is_older</a>(10)
           results = myaccount.mymailbox:has_keyword('MyFlag')
           results = myaccount.mymailbox:arrived_before('01-Jan-2007')
           results = myaccount.mymailbox:sent_since('01-Jan-2007')
           results = myaccount.mymailbox:contain_subject('test')
           results = myaccount.mymailbox:contain_field('Sender', 'user@host')
           results = myaccount.mymailbox:contain_body('hello world')
           results = myaccount.mymailbox:match_from('.*(user1|user2)@host')
           results = myaccount.mymailbox:send_query('ALL')

           results = myaccount['mymailbox']:is_new()
           results = myaccount['myfolder/mymailbox']:is_recent()

</pre><h4><b>RESULTS</b></h4><pre>
       After one of more searching methods have been applied to one or more mailboxes, the result  contains  all
       the  necessary  information,  such as which messages matched in which mailboxes.  Using this result these
       messages can be either searched further or processed in various way.

   <b>META-SEARCHING</b>
       The results of the searching methods can be searched further on in the same way as searching is  done  in
       mailboxes.   The  difference  is  that  instead  of doing the search in the whole mailbox, ie. in all the
       messages, it is instead done only to those messages that were returned in a previous search.

       Examples:

           results:match_message('^[Hh]ello world!?$')
           myaccount.mymailbox:is_new():match_body('^[Ww]orld, hello!?$')

   <b>PROCESSING</b>
       The processing methods are applied to the results that searching returned.

       The following method can be used to delete messages in a mailbox:

       <b>delete_messages</b>()
               Deletes the messages that matched.

       The following methods can be used to copy and move messages  in  a  mailbox  at  the  same  or  different
       accounts.   If  the  destination  mailbox  is  in  a  different account than the source mailbox, then the
       messages are downloaded and then uploaded to the destination:

       <b>copy_messages</b>(<u>destination</u>)
               Copies the messages to the <u>destination</u>, which is a mailbox at an account.

       <b>move_messages</b>(<u>destination</u>)
               Moves the messages to the <u>destination</u>, which is a mailbox at an account.

       The following methods can be used to mark messages in a mailbox:

       <b>mark_answered</b>()
               Marks the messages as answered.

       <b>mark_deleted</b>()
               Marks the messages for later removal.

       <b>mark_draft</b>()
               Marks the messages as draft.

       <b>mark_flagged</b>()
               Marks the messages for urgent/special attention.

       <b>mark_seen</b>()
               Marks the messages as read.

       <b>unmark_answered</b>()
               Unmarks the messages that have been marked as answered.

       <b>unmark_deleted</b>()
               Unmarks the messages that have been marked for later removal.

       <b>unmark_draft</b>()
               Unmarks the messages that have been marked as draft.

       <b>unmark_flagged</b>()
               Unmarks the messages that have been marked for urgent/special attention.

       <b>unmark_seen</b>()
               Unmarks the messages that have been marked as read.

       The following methods can be used  to  flag  messages  in  a  mailbox.  The  standard  system  flags  are
       “\Answered”,  “\Deleted”,  “\Draft”,  “\Flagged”,  “\Seen”,  while,  if  the server supports it, new user
       keywords may be defined:

       <b>add_flags</b>(<u>flags</u>)
               Adds the <u>flags</u> (<u>table</u> that contains <u>strings</u>) to the messages.

       <b>remove_flags</b>(<u>flags</u>)
               Removes the <u>flags</u> (<u>table</u> that contains <u>strings</u>) from the messages.

       <b>replace_flags</b>(<u>flags</u>)
               Replaces the <u>flags</u> (<u>table</u> that contains <u>strings</u>) of the messages.

       Examples:

           results:delete_messages()
           results:copy_messages(myaccount.myothermailbox)
           results:move_messages(myotheraccount.mymailbox)
           results:mark_seen()
           results:unmark_flagged()
           results:add_flags({ 'MyFlag', '\\Seen' })
           results:remove_flags({ '\\Seen' })

           results:move_messages(myotheraccount['myfolder/mymailbox'])

</pre><h4><b>MESSAGES</b></h4><pre>
       The messages that are residing in any mailbox can also be accessed, as a whole or in parts.  Messages can
       be accessed using their unique identifier (UID):

           myaccount.mymailbox[22]

       The UIDs of messages the user is interested in, are gained from the results of searching:

           results = account.INBOX:is_unseen()
           for _, message in ipairs(results) do
               mailbox, uid = <a href="../manmessage/table.unpack.message.html">table.unpack</a>(message)
               header = mailbox[uid]:fetch_header()
           end

   <b>FETCHING</b>
       The following methods can be used to fetch  parts  of  messages.   The  methods  return  a  <u>string</u>.   The
       downloaded message parts are cached locally, so they can be reused inside the same program session:

       <b>fetch_message</b>()
               Fetches the header and body of the message.

       <b>fetch_header</b>()
               Fetches the header of the message.

       <b>fetch_body</b>()
               Fetches the body of the messages.

       <b>fetch_field</b>(<u>field</u>)
               Fetches the specified header <u>field</u> (<u>string</u>) of the message.

       <b>fetch_part</b>(<u>part</u>)
               Fetches the specified <u>part</u> (<u>string</u>) of the message.

       The following methods can be used to fetch details about the state of a message:

       <b>fetch_flags</b>()
               Fetches the flags of the message.  Returns a <u>table</u> of <u>strings</u>.

       <b>fetch_date</b>()
               Fetches the internal date of the message.  Returns a <u>string</u>.

       <b>fetch_size</b>()
               Fetches the size of the message.  Returns a <u>number</u>.

       <b>fetch_structure</b>()
               Fetches  the  body  structure  of  the message. Returns a <u>table</u> that has as keys the parts of the
               message, and as values a <u>table</u> that has one mandatory element, the type (<u>string</u>) of the part, and
               two optional elements, the size (<u>number</u>) and name (<u>string</u>) of the part.

   <b>APPENDING</b>
       The following methods can be used to append a message to a mailbox:

       <b>append_message</b>(<u>message</u>)
               Appends the <u>message</u> (<u>string</u>) to the mailbox.

       <b>append_message</b>(<u>message</u>, <u>flags</u>, <u>date</u>)
               Appends the <u>message</u> (<u>string</u>) to the mailbox, setting the specified <u>flags</u> (<u>table</u> of  <u>strings</u>),  as
               returned by <b>fetch_flags</b>(), and <u>date</u> (<u>string</u>), as returned by <b>fetch_date</b>().

       Examples:

           myaccount.mymailbox[2]:fetch_message()
           myaccount.mymailbox[3]:fetch_field('subject')
           myaccount.mymailbox[5]:fetch_part('1.1')

           myaccount['mymailbox'][7]:fetch_message()
           myaccount['myfolder/mymailbox'][11]:fetch_message()

           myaccount.mymailbox:<a href="../manmessage/append_message.message.html">append_message</a>(message)

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The following auxiliary functions are also available for convenience:

       <b>form_date</b>(<u>days</u>)
               Forms  a  date in “day-month-year” format that the system had before the number of <u>days</u> (<u>number</u>),
               and returns it as a <u>string</u>.

       <b>get_password</b>(<u>prompt</u>)
               Displays the specified <u>prompt</u> (<u>string</u>), and reads a password, while character echoing  is  turned
               off.  Returns that password as a <u>string</u>.

       <b>become_daemon</b>(<u>interval</u>, <u>commands</u>)
       <b>become_daemon</b>(<u>interval</u>, <u>commands</u>, <u>nochdir</u>)
       <b>become_daemon</b>(<u>interval</u>, <u>commands</u>, <u>nochdir</u>, <u>noclose</u>)
               Detaches  the  program  from  the  controlling  terminal  and runs it in the background as system
               daemon. The program will then repeatedly poll at the specified <u>interval</u> (<u>number</u>) in seconds. Each
               time the program wakes up, the <u>commands</u> (<u>function</u>) are executed.

               If <u>nochdir</u> (<u>boolean</u>) is “true”, the  current  working  directory  is  not  changed  to  the  root
               directory (<u>/</u>).

               If  <u>noclose</u>  (<u>boolean</u>)  is “true”, the standard input, standard output and standard error are not
               redirected to <u>/dev/null</u>.

       <b>pipe_to</b>(<u>command</u>, <u>data</u>)
               Executes the system's <u>command</u> (<u>string</u>) and sends the <u>data</u> (<u>string</u>) to the standard input  channel
               of the subprocess. Returns a <u>number</u>, the exit status of the child process.

       <b>pipe_from</b>(<u>command</u>)
               Executes the system's <u>command</u> (<u>string</u>) and retrieves the data from the standard output channel of
               the subprocess.  Returns a <u>number</u>, the exit status of the child process, and a <u>string</u>, the output
               of the child process.

       <b>regex_search</b>(<u>pattern</u>, <u>string</u>)
               Implements  Perl-compatible  regular  expressions (PCRE). The <u>pattern</u> (<u>string</u>) is a PCRE pattern.
               The <u>string</u> (<u>string</u>) is the subject string in which the pattern is  matched  against.  Returns  at
               least  a  <u>boolean</u>, that denotes if the match was successful, and any captures which are of <u>string</u>
               type.  Note that due to Lua using backslash ‘\’ as an escape character for its strings,  one  has
               to  use  double  backslashes  in  order  to insert a single backslash inside a regular expression
               pattern.  For more information on PCRE see <u><a href="http://pcre.org/original/doc/html/">http://pcre.org/original/doc/html/</a></u>.

       <b>sleep</b>(<u>interval</u>)
               Delay for the specified <u>interval</u> (<u>number</u>) in seconds.

       <b>recover</b>(<u>commands</u>)
       <b>recover</b>(<u>commands</u>, <u>retries</u>)
               Protects the <u>commands</u> (<u>function</u>) executed from raising an error. Whenever an error is raised,  it
               sleeps for a few seconds (using exponential backoff up to some upper limit), and then re-executes
               the <u>commands</u> (<u>function</u>) from start.

               If  the  maximum count of <u>retries</u> (<u>number</u>) is specified, it will retry up to the specified number
               of times, otherwise it will never give up.

               Returns the status code of the execution as the first result, “true” if it succeeded  or  “false”
               if  it  failed.  If  it  succeeded,  it  returns  all  values the <u>commands</u> (<u>function</u>) returned as
               additional results.  If it failed, it returns the error as an additional result.

       Examples:

           date = <a href="../man14/form_date.14.html">form_date</a>(14)
           password = get_password('Enter password: ')
           become_daemon(600, myfunction)
           status = pipe_to('mycommandline', 'mydata')
           status, data = pipe_from('mycommandline')
           success, capture = regex_search('^(?i)pcre: (\\w)$', 'mystring')
           <a href="../man300/sleep.300.html">sleep</a>(300)
           recover(myfunction, 5)

       For more examples, see the <u>samples/extend.lua</u> file.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See <u>samples/config.lua</u> and <u>samples/extend.lua</u> in the source code distribution.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       HOME    User's home directory.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/imapfilter.1.html">imapfilter</a></u>(1)

Debian                                             Jan 6, 2023                              <u><a href="../man5/IMAPFILTER_CONFIG.5.html">IMAPFILTER_CONFIG</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>