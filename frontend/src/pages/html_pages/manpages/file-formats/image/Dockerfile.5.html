<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dockerfile - automate the steps of creating a Docker image</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/docker.io">docker.io_28.2.2-0ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dockerfile - automate the steps of creating a Docker image

</pre><h4><b>INTRODUCTION</b></h4><pre>
       The <b>Dockerfile</b> is a configuration file that automates the steps of creating a Docker image. It is similar
       to  a  Makefile.  Docker reads instructions from the <b>Dockerfile</b> to automate the steps otherwise performed
       manually to create an image. To build an image, create a file called <b>Dockerfile</b>.

       The <b>Dockerfile</b> describes the steps taken to assemble the image. When the  <b>Dockerfile</b>  has  been  created,
       call the <b>docker</b> <b>build</b> command, using the path of directory that contains <b>Dockerfile</b> as the argument.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       INSTRUCTION arguments

       For example:

       FROM image

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Dockerfile is a file that automates the steps of creating a Docker image.  A Dockerfile is similar to a
       Makefile.

</pre><h4><b>USAGE</b></h4><pre>
       docker build .

       -- Runs the steps and commits them, building a final image.
         The path to the source repository defines where to find the context of the
         build. The build is run by the Docker daemon, not the CLI. The whole
         context must be transferred to the daemon. The Docker CLI reports
         <b>"Sending</b> <b>build</b> <b>context</b> <b>to</b> <b>Docker</b> <b>daemon"</b> when the context is sent to the
         daemon.

         docker build -t repository/tag .

       -- specifies a repository and tag at which to save the new image if the build
         succeeds. The Docker daemon runs the steps one-by-one, committing the result
         to a new image if necessary, before finally outputting the ID of the new
         image. The Docker daemon automatically cleans up the context it is given.

       Docker reuses intermediate images whenever possible. This significantly
         accelerates the <u>docker</u> <u>build</u> process.

</pre><h4><b>FORMAT</b></h4><pre>
       <b>FROM</b> <b>image</b>

       <b>FROM</b> <b>image:tag</b>

       <b>FROM</b> <b>image@digest</b>

       -- The <b>FROM</b> instruction sets the base image for subsequent instructions. A
         valid Dockerfile must have <b>FROM</b> as its first instruction. The image can be any
         valid image. It is easy to start by pulling an image from the public
         repositories.

       -- <b>FROM</b> must be the first non-comment instruction in Dockerfile.

       -- <b>FROM</b> may appear multiple times within a single Dockerfile in order to create
         multiple images. Make a note of the last image ID output by the commit before
         each new <b>FROM</b> command.

       -- If no tag is given to the <b>FROM</b> instruction, Docker applies the
         <b>latest</b> tag. If the used tag does not exist, an error is returned.

       -- If no digest is given to the <b>FROM</b> instruction, Docker applies the
         <b>latest</b> tag. If the used tag does not exist, an error is returned.

       <b>MAINTAINER</b>
         -- <b>MAINTAINER</b> sets the Author field for the generated images.
         Useful for providing users with an email or url for support.

       <b>RUN</b>
         -- <b>RUN</b> has two forms:

         # the command is run in a shell - <a href="file:/bin/sh">/bin/sh</a> -c
         RUN &lt;command&gt;

         # Executable form
         RUN ["executable", "param1", "param2"]

       -- The <b>RUN</b> instruction executes any commands in a new layer on top of the current
         image and commits the results. The committed image is used for the next step in
         Dockerfile.

       -- Layering <b>RUN</b> instructions and generating commits conforms to the core
         concepts of Docker where commits are cheap and containers can be created from
         any point in the history of an image. This is similar to source control.  The
         exec form makes it possible to avoid shell string munging. The exec form makes
         it possible to <b>RUN</b> commands using a base image that does not contain <b><a href="file:/bin/sh">/bin/sh</a></b>.

       Note that the exec form is parsed as a JSON array, which means that you must
         use double-quotes (") around words not single-quotes (').

       <b>CMD</b>
         -- <b>CMD</b> has three forms:

         # Executable form
         CMD ["executable", "param1", "param2"]`

         # Provide default arguments to ENTRYPOINT
         CMD ["param1", "param2"]`

         # the command is run in a shell - <a href="file:/bin/sh">/bin/sh</a> -c
         CMD command param1 param2

       -- There should be only one <b>CMD</b> in a Dockerfile. If more than one <b>CMD</b> is listed, only
         the last <b>CMD</b> takes effect.
         The main purpose of a <b>CMD</b> is to provide defaults for an executing container.
         These defaults may include an executable, or they can omit the executable. If
         they omit the executable, an <b>ENTRYPOINT</b> must be specified.
         When used in the shell or exec formats, the <b>CMD</b> instruction sets the command to
         be executed when running the image.
         If you use the shell form of the <b>CMD</b>, the <b>&lt;command&gt;</b> executes in <b><a href="file:/bin/sh">/bin/sh</a></b> <b>-c</b>:

       Note that the exec form is parsed as a JSON array, which means that you must
         use double-quotes (") around words not single-quotes (').

         FROM ubuntu
         CMD echo "This is a test." | wc -

       -- If you run <b>command</b> without a shell, then you must express the command as a
         JSON array and give the full path to the executable. This array form is the
         preferred form of <b>CMD</b>. All additional parameters must be individually expressed
         as strings in the array:

         FROM ubuntu
         CMD ["<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a>","--help"]

       -- To make the container run the same executable every time, use <b>ENTRYPOINT</b> in
         combination with <b>CMD</b>.
         If the user specifies arguments to <b>docker</b> <b>run</b>, the specified commands
         override the default in <b>CMD</b>.
         Do not confuse <b>RUN</b> with <b>CMD</b>. <b>RUN</b> runs a command and commits the result.
         <b>CMD</b> executes nothing at build time, but specifies the intended command for
         the image.

       <b>LABEL</b>
         -- <b>LABEL</b> <b>&lt;key&gt;=&lt;value&gt;</b> <b>[&lt;key&gt;=&lt;value&gt;</b> <b>...]</b>or

         LABEL &lt;key&gt;[ &lt;value&gt;]
         LABEL &lt;key&gt;[ &lt;value&gt;]
         ...

       The <b>LABEL</b> instruction adds metadata to an image. A <b>LABEL</b> is a
         key-value pair. To specify a <b>LABEL</b> without a value, simply use an empty
         string. To include spaces within a <b>LABEL</b> value, use quotes and
         backslashes as you would in command-line parsing.

         LABEL com.example.vendor="ACME Incorporated"
         LABEL com.example.vendor "ACME Incorporated"
         LABEL com.example.vendor.is-beta ""
         LABEL com.example.vendor.is-beta=
         LABEL com.example.vendor.is-beta=""

       An image can have more than one label. To specify multiple labels, separate
         each key-value pair by a space.

       Labels are additive including <b>LABEL</b>s in <b>FROM</b> images. As the system
         encounters and then applies a new label, new <b>key</b>s override any previous
         labels with identical keys.

       To display an image's labels, use the <b>docker</b> <b>inspect</b> command.

       <b>STOPSIGNAL</b>

       -- <b>STOPSIGNAL</b> <b>&lt;signal&gt;</b>
         The <b>STOPSIGNAL</b> instruction sets the system call signal that will be sent
         to the container to exit. This signal can be a signal name in the format
         <b>SIG</b>, for instance <b>SIGKILL</b>, or an unsigned number that matches a
         position in the kernel's syscall table, for instance <b>9</b>. The default is
         <b>SIGTERM</b> if not defined.

       The image's default stopsignal can be overridden per container, using the
         <b>--stop-signal</b> flag on <b><a href="../man1/docker-run.1.html">docker-run</a>(1)</b> and <b><a href="../man1/docker-create.1.html">docker-create</a>(1)</b>.

       <b>EXPOSE</b>
         -- <b>EXPOSE</b> <b>&lt;port&gt;</b> <b>[&lt;port&gt;...]</b>
         The <b>EXPOSE</b> instruction informs Docker that the container listens on the
         specified network ports at runtime. Docker uses this information to
         interconnect containers using links and to set up port redirection on the host
         system.

       <b>ENV</b>
         -- <b>ENV</b> <b>&lt;key&gt;</b> <b>&lt;value&gt;</b>
         The <b>ENV</b> instruction sets the environment variable  to
         the value <b>&lt;value&gt;</b>. This value is passed to all future
         <b>RUN</b>, <b>ENTRYPOINT</b>, and <b>CMD</b> instructions. This is
         functionally equivalent to prefixing the command with <b>&lt;key&gt;=&lt;value&gt;</b>.  The
         environment variables that are set with <b>ENV</b> persist when a container is run
         from the resulting image. Use <b>docker</b> <b>inspect</b> to inspect these values, and
         change them using <b>docker</b> <b>run</b> <b>--env</b> <b>&lt;key&gt;=&lt;value&gt;</b>.

       Note that setting "<b>ENV</b> <b>DEBIAN_FRONTEND=noninteractive</b>" may cause
         unintended consequences, because it will persist when the container is run
         interactively, as with the following command: <b>docker</b> <b>run</b> <b>-t</b> <b>-i</b> <b>image</b> <b>bash</b>

       <b>ADD</b>
         -- <b>ADD</b> has two forms:

         ADD &lt;src&gt; &lt;dest&gt;

         # Required for paths with whitespace
         ADD ["&lt;src&gt;",... "&lt;dest&gt;"]

       The <b>ADD</b> instruction copies new files, directories
         or remote file URLs to the filesystem of the container at path <b>&lt;dest&gt;</b>.
         Multiple <b>&lt;src&gt;</b> resources may be specified but if they are files or directories
         then they must be relative to the source directory that is being built
         (the context of the build). The <b>&lt;dest&gt;</b> is the absolute path, or path relative
         to <b>WORKDIR</b>, into which the source is copied inside the target container.
         If the <b>&lt;src&gt;</b> argument is a local file in a recognized compression format
         (tar, gzip, bzip2, etc) then it is unpacked at the specified <b>&lt;dest&gt;</b> in the
         container's filesystem.  Note that only local compressed files will be unpacked,
         i.e., the URL download and archive unpacking features cannot be used together.
         All new directories are created with mode 0755 and with the uid and gid of <b>0</b>.

       <b>COPY</b>
         -- <b>COPY</b> has two forms:

         COPY &lt;src&gt; &lt;dest&gt;

         # Required for paths with whitespace
         COPY ["&lt;src&gt;",... "&lt;dest&gt;"]

       The <b>COPY</b> instruction copies new files from <b>&lt;src&gt;</b> and
         adds them to the filesystem of the container at path . The <b>&lt;src&gt;</b> must be
         the path to a file or directory relative to the source directory that is
         being built (the context of the build) or a remote file URL. The <b>&lt;dest&gt;</b> is an
         absolute path, or a path relative to <b>WORKDIR</b>, into which the source will
         be copied inside the target container. If you <b>COPY</b> an archive file it will
         land in the container exactly as it appears in the build context without any
         attempt to unpack it.  All new files and directories are created with mode <b>0755</b>
         and with the uid and gid of <b>0</b>.

       <b>ENTRYPOINT</b>
         -- <b>ENTRYPOINT</b> has two forms:

         # executable form
         ENTRYPOINT ["executable", "param1", "param2"]`

         # run command in a shell - <a href="file:/bin/sh">/bin/sh</a> -c
         ENTRYPOINT command param1 param2

       -- An <b>ENTRYPOINT</b> helps you configure a
         container that can be run as an executable. When you specify an <b>ENTRYPOINT</b>,
         the whole container runs as if it was only that executable.  The <b>ENTRYPOINT</b>
         instruction adds an entry command that is not overwritten when arguments are
         passed to docker run. This is different from the behavior of <b>CMD</b>. This allows
         arguments to be passed to the entrypoint, for instance <b>docker</b> <b>run</b> <b>&lt;image&gt;</b> <b>-d</b>
         passes the -d argument to the <b>ENTRYPOINT</b>.  Specify parameters either in the
         <b>ENTRYPOINT</b> JSON array (as in the preferred exec form above), or by using a <b>CMD</b>
         statement.  Parameters in the <b>ENTRYPOINT</b> are not overwritten by the docker run
         arguments.  Parameters specified via <b>CMD</b> are overwritten by docker run
         arguments.  Specify a plain string for the <b>ENTRYPOINT</b>, and it will execute in
         <b><a href="file:/bin/sh">/bin/sh</a></b> <b>-c</b>, like a <b>CMD</b> instruction:

         FROM ubuntu
         ENTRYPOINT wc -l -

       This means that the Dockerfile's image always takes stdin as input (that's
         what "-" means), and prints the number of lines (that's what "-l" means). To
         make this optional but default, use a <b>CMD</b>:

         FROM ubuntu
         CMD ["-l", "-"]
         ENTRYPOINT ["<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a>"]

       <b>VOLUME</b>
         -- <b>VOLUME</b> <b>["/data"]</b>
         The <b>VOLUME</b> instruction creates a mount point with the specified name and marks
         it as holding externally-mounted volumes from the native host or from other
         containers.

       <b>USER</b>
         -- <b>USER</b> <b>daemon</b>
         Sets the username or UID used for running subsequent commands.

       The <b>USER</b> instruction can optionally be used to set the group or GID. The
         followings examples are all valid:
         USER [user | user:group | uid | uid:gid | user:gid | uid:group ]

       Until the <b>USER</b> instruction is set, instructions will be run as root. The USER
         instruction can be used any number of times in a Dockerfile, and will only affect
         subsequent commands.

       <b>WORKDIR</b>
         -- <b>WORKDIR</b> <b>/path/to/workdir</b>
         The <b>WORKDIR</b> instruction sets the working directory for the <b>RUN</b>, <b>CMD</b>,
         <b>ENTRYPOINT</b>, <b>COPY</b> and <b>ADD</b> Dockerfile commands that follow it. It can
         be used multiple times in a single Dockerfile. Relative paths are defined
         relative to the path of the previous <b>WORKDIR</b> instruction. For example:

         WORKDIR /a
         WORKDIR b
         WORKDIR c
         RUN pwd

       In the above example, the output of the <b>pwd</b> command is <b>a/b/c</b>.

       <b>ARG</b>
          -- ARG [=]

       The <b>ARG</b> instruction defines a variable that users can pass at build-time to
         the builder with the <b>docker</b> <b>build</b> command using the <b>--build-arg</b>
         <b>&lt;varname&gt;=&lt;value&gt;</b> flag. If a user specifies a build argument that was not
         defined in the Dockerfile, the build outputs a warning.

         [Warning] One or more build-args [foo] were not consumed

       The Dockerfile author can define a single variable by specifying <b>ARG</b> once or many
         variables by specifying <b>ARG</b> more than once. For example, a valid Dockerfile:

         FROM busybox
         ARG user1
         ARG buildno
         ...

       A Dockerfile author may optionally specify a default value for an <b>ARG</b> instruction:

         FROM busybox
         ARG user1=someuser
         ARG buildno=1
         ...

       If an <b>ARG</b> value has a default and if there is no value passed at build-time, the
         builder uses the default.

       An <b>ARG</b> variable definition comes into effect from the line on which it is
         defined in the <b>Dockerfile</b> not from the argument's use on the command-line or
         elsewhere.  For example, consider this Dockerfile:

         1 FROM busybox
         2 USER ${user:-some_user}
         3 ARG user
         4 USER $user
         ...

       A user builds this file by calling:

         $ docker build --build-arg user=what_user Dockerfile

       The <b>USER</b> at line 2 evaluates to <b>some_user</b> as the <b>user</b> variable is defined on the
         subsequent line 3. The <b>USER</b> at line 4 evaluates to <b>what_user</b> as <b>user</b> is
         defined and the <b>what_user</b> value was passed on the command line. Prior to its definition by an
         <b>ARG</b> instruction, any use of a variable results in an empty string.

              <b>Warning:</b> It is not recommended to use build-time variables for
               passing secrets like github keys, user credentials etc. Build-time variable
               values are visible to any user of the image with the <b>docker</b> <b>history</b> command.

       You can use an <b>ARG</b> or an <b>ENV</b> instruction to specify variables that are
         available to the <b>RUN</b> instruction. Environment variables defined using the
         <b>ENV</b> instruction always override an <b>ARG</b> instruction of the same name. Consider
         this Dockerfile with an <b>ENV</b> and <b>ARG</b> instruction.

         1 FROM ubuntu
         2 ARG CONT_IMG_VER
         3 ENV CONT_IMG_VER=v1.0.0
         4 RUN echo $CONT_IMG_VER

       Then, assume this image is built with this command:

         $ docker build --build-arg CONT_IMG_VER=v2.0.1 Dockerfile

       In this case, the <b>RUN</b> instruction uses <b>v1.0.0</b> instead of the <b>ARG</b> setting
         passed by the user:<b>v2.0.1</b> This behavior is similar to a shell
         script where a locally scoped variable overrides the variables passed as
         arguments or inherited from environment, from its point of definition.

       Using the example above but a different <b>ENV</b> specification you can create more
         useful interactions between <b>ARG</b> and <b>ENV</b> instructions:

         1 FROM ubuntu
         2 ARG CONT_IMG_VER
         3 ENV CONT_IMG_VER=${CONT_IMG_VER:-v1.0.0}
         4 RUN echo $CONT_IMG_VER

       Unlike an <b>ARG</b> instruction, <b>ENV</b> values are always persisted in the built
         image. Consider a docker build without the --build-arg flag:

         $ docker build Dockerfile

       Using this Dockerfile example, <b>CONT_IMG_VER</b> is still persisted in the image but
         its value would be <b>v1.0.0</b> as it is the default set in line 3 by the <b>ENV</b> instruction.

       The variable expansion technique in this example allows you to pass arguments
         from the command line and persist them in the final image by leveraging the
         <b>ENV</b> instruction. Variable expansion is only supported for a limited set of
         Dockerfile instructions.  ⟨#environment-replacement⟩

       Docker has a set of predefined <b>ARG</b> variables that you can use without a
         corresponding <b>ARG</b> instruction in the Dockerfile.

       • <b>HTTP_PROXY</b>

       • <b>http_proxy</b>

       • <b>HTTPS_PROXY</b>

       • <b>https_proxy</b>

       • <b>FTP_PROXY</b>

       • <b>ftp_proxy</b>

       • <b>NO_PROXY</b>

       • <b>no_proxy</b>

       • <b>ALL_PROXY</b>

       • <b>all_proxy</b>

       To use these, pass them on the command line using <b>--build-arg</b> flag, for
         example:

         $ docker build --build-arg HTTPS_PROXY=https://my-proxy.example.com .

       <b>ONBUILD</b>
         -- <b>ONBUILD</b> <b>[INSTRUCTION]</b>
         The <b>ONBUILD</b> instruction adds a trigger instruction to an image. The
         trigger is executed at a later time, when the image is used as the base for
         another build. Docker executes the trigger in the context of the downstream
         build, as if the trigger existed immediately after the <b>FROM</b> instruction in
         the downstream Dockerfile.

       You can register any build instruction as a trigger. A trigger is useful if
         you are defining an image to use as a base for building other images. For
         example, if you are defining an application build environment or a daemon that
         is customized with a user-specific configuration.

       Consider an image intended as a reusable python application builder. It must
         add application source code to a particular directory, and might need a build
         script called after that. You can't just call <b>ADD</b> and <b>RUN</b> now, because
         you don't yet have access to the application source code, and it is different
         for each application build.

       -- Providing application developers with a boilerplate Dockerfile to copy-paste
         into their application is inefficient, error-prone, and
         difficult to update because it mixes with application-specific code.
         The solution is to use <b>ONBUILD</b> to register instructions in advance, to
         run later, during the next build stage.

</pre><h4><b>HISTORY</b></h4><pre>
       *May 2014, Compiled by Zac Dover (zdover at redhat dot com) based on docker.com Dockerfile documentation.
       *Feb  2015,  updated  by  Brian  Goff  (<a href="mailto:cpuguy83@gmail.com">cpuguy83@gmail.com</a>)  for readability *Sept 2015, updated by Sally
       O'Malley (<a href="mailto:somalley@redhat.com">somalley@redhat.com</a>) *Oct 2016, updated by Addam Hardy (<a href="mailto:addam.hardy@gmail.com">addam.hardy@gmail.com</a>)

Docker Community                                    MAY 2014                                       <u><a href="../man5/DOCKERFILE.5.html">DOCKERFILE</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>