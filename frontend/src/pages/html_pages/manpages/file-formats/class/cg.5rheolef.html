<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cg - conjugate gradient algorithm (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cg - conjugate gradient algorithm (rheolef-7.2)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       template &lt;class Matrix, class Vector, class Vector2, class Preconditioner&gt;
       int cg (const Matrix &amp;A, Vector &amp;x, const Vector2 &amp;Mb, const Preconditioner &amp;M,
               const solver_option&amp; sopt = solver_option())

</pre><h4><b>EXAMPLE</b></h4><pre>
           solver_option sopt;
           sopt.max_iter = 100;
           sopt.tol = 1e-7;
           int status = cg (A, x, b, eye(), sopt);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This function solves the <u>symmetric</u> <u>positive</u> <u>definite</u> linear system A*x=b with the conjugate gradient
       method. The cg function follows the algorithm described on p. 15 in

           R. Barrett, M. Berry, T. F. Chan, J. Demmel, J. Donato,
           J. Dongarra, V. Eijkhout, R. Pozo, C. Romine and H. Van der Vorst,
           Templates for the solution of linear systems: building blocks for iterative methods,
           SIAM, 1994.

        The fourth argument of cg is a preconditionner: here, the <b><a href="../man5/eye.5.html">eye</a>(5)</b> one is a do-nothing preconditionner,
       for simplicity. Finally, the <b><a href="../man4/solver_option.4.html">solver_option</a>(4)</b> variable sopt transmits the stopping criterion with
       sopt.tol and sopt.max_iter.

       On return, the sopt.residue and sopt.n_iter indicate the reached residue and the number of iterations
       effectively performed. The return status is zero when the prescribed tolerance tol has been obtained, and
       non-zero otherwise. Also, the x variable contains the approximate solution. See also the <b><a href="../man4/solver_option.4.html">solver_option</a>(4)</b>
       for more controls upon the stopping criterion.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file linalg/lib/cg.h

       The present template implementation is inspired from the IML++ 1.2 iterative method library,
       <a href="http://math.nist.gov/iml">http://math.nist.gov/iml</a>++

       template &lt;class Matrix, class Vector, class Vector2, class Preconditioner&gt;
       int cg (const Matrix &amp;A, Vector &amp;x, const Vector2 &amp;Mb, const Preconditioner &amp;M,
               const solver_option&amp; sopt = solver_option())

       {
         typedef typename Vector::size_type  Size;
         typedef typename Vector::float_type Real;
         std::string label = (sopt.label != "" ? sopt.label : "cg");
         Vector b = M.solve(Mb);
         Real norm2_b = dot(Mb,b);
         if (sopt.absolute_stopping || norm2_b == <a href="../man0/Real.0.html">Real</a>(0)) norm2_b = 1;
         Vector Mr = Mb - A*x;
         Real  norm2_r = 0;
         if (sopt.p_err) (*sopt.p_err) &lt;&lt; "[" &lt;&lt; label &lt;&lt; "] #iteration residue" &lt;&lt; std::endl;
         Vector p;
         for (sopt.n_iter = 0; sopt.n_iter &lt;= sopt.max_iter; sopt.n_iter++) {
           Vector r = M.solve(Mr);
           Real prev_norm2_r = norm2_r;
           norm2_r = dot(Mr, r);
           sopt.residue = sqrt(norm2_r/norm2_b);
           if (sopt.p_err) (*sopt.p_err) &lt;&lt; "[" &lt;&lt; label &lt;&lt; "] " &lt;&lt; sopt.n_iter &lt;&lt; " " &lt;&lt; sopt.residue &lt;&lt; std::endl;
           if (sopt.residue &lt;= sopt.tol) return 0;
           if (sopt.n_iter == 0) {
             p = r;
           } else {
             Real beta = norm2_r/prev_norm2_r;
             p = r + beta*p;
           }
           Vector Mq = A*p;
           Real alpha = norm2_r/dot(Mq, p);
           x  += alpha*p;
           Mr -= alpha*Mq;
         }
         return 1;
       }

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                      <u><a href="../man5rheolef/cg.5rheolef.html">cg</a></u>(5rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>