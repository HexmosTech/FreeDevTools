<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>auditd-plugins - realtime event receivers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/auditd">auditd_4.0.5-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       auditd-plugins - realtime event receivers

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>auditd</b>  can  multiplex  audit  events  in  realtime.  It takes audit events and distributes them to child
       programs that want to analyze events in realtime. When the audit daemon receives a SIGTERM or SIGHUP,  it
       passes that signal to its child processes so that can reload the configuration or terminate.

       The   child   programs   install   a  configuration  file  in  a  plugins  directory  which  defaults  to
       <u>/etc/audit/plugins.d</u>. This can be controlled by a auditd.conf  config  option  <b>plugin_dir</b>  if  the  admin
       wished to locate plugins somewhere else. But auditd will install its plugins in the default location.

       The plugin directory will be scanned and every plugin that is active will be started. If the plugin has a
       problem and exits, it will be started a maximum of <b>max_restarts</b> times as found in auditd.conf.

       Configuration files must be regular files that do not begin with a '.' character, contain at most one '.'
       character,  and have a '.conf' suffix. Files that do not meet these criteria will be skipped. Config file
       options are given one per line with an equal sign between  the  keyword  and  its  value.  The  available
       options are as follows:

       <u>active</u> The options for this are <u>yes</u> or <u>no.</u>

       <u>direction</u>
              The  option  is  dictated by the plugin.  <u>In</u> or <u>out</u> are the only choices. You cannot make a plugin
              operate in a way it wasn't designed just by changing this option. This option is to give a clue to
              the event dispatcher about which direction events flow. NOTE: inbound  events  are  not  supported
              yet.

       <u>path</u>   This  is  the absolute path to the plugin executable. In the case of internal plugins, it would be
              the name of the plugin.

       <u>type</u>   This tells the dispatcher how the plugin wants to be run. There is only one valid option, <u>always</u> ,
              which means the plugin is external and should always be run. The default is always since there are
              no more builtin plugins.

       <u>args</u>   This allows you to pass arguments to the child program. Generally plugins do  not  take  arguments
              and  have  their own config file that instructs them how they should be configured. At the moment,
              there is a limit of 2 args.

       <u>format</u> The valid options for this are <u>binary</u> and <u>string.</u>  <u>Binary</u> passes the data  exactly  as  the  audit
              event  dispatcher  gets  it  from  the  audit  daemon.  The  <u>string</u> option tells the dispatcher to
              completely change the event into a string suitable for parsing with the audit parsing library. The
              default value is <u>string.</u>

</pre><h4><b>NOTE</b></h4><pre>
       auditd has an internal queue to hold events for  plugins.  (See  the  <u>q_depth</u>  setting  in  <u>auditd.conf</u>.)
       Plugins  have to watch for and dequeue events as fast as possible and queue them internally if they can't
       be immediately processed. If the plugin is not able to dequeue records, the auditd  internal  queue  will
       get filled. At any time, as root, you can run the following to check auditd's metrics:

       auditctl --signal cont ; sleep 1 ; cat /var/run/auditd.state

       If  auditd's  internal queue fills, it cannot dequeue any events from the kernel backlog. If the kernel's
       backlog fills, it looks at the value of backlog_wait_time to delay all processes that generate  an  event
       to  see if there is eventually room to add the event. This will likely be noticed as slowing down various
       processes on the machine. The kernel's audit subsystem can be checked by running:

       auditctl -s

       When tuning the audit system's performance, you'd want to check both kernel and auditd metrics and adjust
       accordingly.

</pre><h4><b>NOTES</b> <b>FOR</b> <b>DEVELOPERS</b></h4><pre>
       When the audit daemon starts your plugin, you  will  be  running  as  root.  If  you  do  not  need  root
       privileges,  you  should  change  uid/gid  to lower chances of being a target for exploit. If you need to
       retain capabilities, using <b>libcap-ng</b> is the simplest way.

       Your environment is not going to be clean. You are inheriting many attributes  from  auditd  itself.  You
       will  need  to adjust your <b>signal</b> <b>mask</b>, <b>sigaction</b>, <b>umask</b>, and <b>environmental</b> <b>variables</b>. Look at the auditd
       man page to see which signals auditd used. Plugins are expected to handle <b>SIGTERM</b> and  <b>SIGHUP</b>.  You  will
       also  inherit  the  resource  limits  of auditd. Note that some of these resource limits, such as maximum
       number of open descriptors, are controlled by systemd. You also inherit auditd's nice  value.  You  might
       want to adjust that to be sure to keep up with incoming audit events.

       Auditd will send events to the plugin on it's <b>stdin</b>. The plugin has to keep this descriptor empty so that
       events don't back up. If you do significant processing of each event, you should add an internal queue to
       your  design  in  order to keep events flowing. The <b>auparse_feed</b> function is the preferred way to examine
       whole events if you need to analyze the contents of the events.

</pre><h4><b>FILES</b></h4><pre>
       /etc/auditd/auditd.conf /etc/audit/plugins.d

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/auditd.conf.5.html">auditd.conf</a></b>(5), <b><a href="../man8/auditd.8.html">auditd</a></b>(8), <b><a href="../man2/execve.2.html">execve</a>(2),</b> <b><a href="../man3/auparse_feed.3.html">auparse_feed</a>(3).</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Steve Grubb

Red Hat                                             Jan 2024                                   <u><a href="../man5/AUDITD-PLUGINS.5.html">AUDITD-PLUGINS</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>