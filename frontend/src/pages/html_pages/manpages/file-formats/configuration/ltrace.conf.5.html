<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ltrace.conf - Configuration file for ltrace(1).</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ltrace">ltrace_0.7.3-6.4ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>ltrace.conf</b> - Configuration file for <b><a href="../man1/ltrace.1.html">ltrace</a>(1)</b>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  manual  page  describes  <b>ltrace.conf</b>, a file that describes prototypes of functions in binaries for
       <b><a href="../man1/ltrace.1.html">ltrace</a>(1)</b> to use.  Ltrace needs this information to display function call arguments.

       Each line of a configuration file describes at most a single item.   Lines  composed  entirely  of  white
       space  are  ignored, as are lines starting with semicolon character (comment lines).  Described items can
       be either function prototypes, or definitions of type aliases.

</pre><h4><b>PROTOTYPES</b></h4><pre>
       A prototype describes return type and parameter types of a single function.  The syntax is as follows:

              <u>LENS</u> <u>NAME</u> <b>(</b>[<u>LENS</u>{,<u>LENS</u>}]<b>);</b>

       <u>NAME</u> is the (mangled) name of a symbol.  In the elementary case, <u>LENS</u> is simply a type.  Both lenses  and
       types are described below.  For example, a simple function prototype might look like this:

              <b>int</b> kill<b>(int,int);</b>

       Despite  the  apparent  similarity  with  C,  <b>ltrace.conf</b> is really its own language that's only somewhat
       inspired by C.

</pre><h4><b>TYPES</b></h4><pre>
       Ltrace understands a range of primitive types.  Those are interpreted according to C convention native on
       a given architecture.  E.g. <b>ulong</b> is interpreted as 4-byte unsigned integer on 32-bit GNU/Linux  machine,
       but 8-byte unsigned integer on 64-bit GNU/Linux machine.

       <b>void</b>   Denotes  that  a  function  does  not  return  anything.   Can be also used to construct a generic
              pointer, i.e. pointer-sized number formatted in hexadecimal format.

       <b>char</b>   8-bit quantity rendered as a character

       <b>ushort,short</b>
              Denotes unsigned or signed short integer.

       <b>uint,int</b>
              Denotes unsigned or signed integer.

       <b>ulong,long</b>
              Denotes unsigned or signed long integer.

       <b>float</b>  Denotes floating point number with single precision.

       <b>double</b> Denotes floating point number with double precision.

       Besides primitive types, the following composed types are possible:

       <b>struct(</b>[<u>LENS</u>{,<u>LENS</u>}]<b>)</b>
              Describes a structure with given types as fields, e.g. <b>struct(int,int,float)</b>.

              Alignment is computed as customary on the architecture.  Custom alignment  (e.g.  packed  structs)
              and  bit-fields  are  not  supported.  It's also not possible to differentiate between structs and
              non-POD C++ classes, for arches where it makes a difference.

       <b>array(</b><u>LENS</u><b>,</b><u>EXPR</u><b>)</b>
              Describes array of length <u>EXPR</u>, which is composed of types described by <u>LENS</u>, e.g. <b>array(int,</b> 6<b>)</b>.

              Note that in C, arrays in role of function argument decay into pointers.  Ltrace currently handles
              this automatically, but for full formal correctness, any such arguments  should  be  described  as
              pointers to arrays.

       <u>LENS</u><b>*</b>  Describes  a pointer to a given type, e.g. <b>char*</b> or <b>int***</b>.  Note that the former example actually
              describes a pointer to a character, not a string.  See below for <b>string</b> lens, which is  applicable
              to these cases.

</pre><h4><b>LENSES</b></h4><pre>
       Lenses  change  the  way  that  types  are  described.   In the simplest case, a lens is directly a type.
       Otherwise a type is decorated by the lens.  Ltrace understands the following lenses:

       <b>oct(</b><u>TYPE</u><b>)</b>
              The argument, which should be an integer type, is formatted in base-8.

       <b>hex(</b><u>TYPE</u><b>)</b>
              The argument, which should be an  integer  or  floating  point  type,  is  formatted  in  base-16.
              Floating point arguments are converted to double and then displayed using the <b>%a</b> fprintf modifier.

       <b>hide(</b><u>TYPE</u><b>)</b>
              The argument is not shown in argument list.

       <b>bool(</b><u>TYPE</u><b>)</b>
              Arguments with zero value are shown as "false", others are shown as "true".

       <b>bitvec(</b><u>TYPE</u><b>)</b>
              Underlying  argument  is  interpreted  as  a bit vector and a summary of bits set in the vector is
              displayed.  For example if bits 3,4,5 and 7 of the bit  vector  are  set,  ltrace  shows  &lt;3-5,7&gt;.
              Empty  bit  vector  is  displayed  as &lt;&gt;.  If there are more bits set than unset, inverse is shown
              instead: e.g. ~&lt;0&gt; when a number 0xfffffffe is displayed.  Full set is thus displayed ~&lt;&gt;.

              If the underlying type is integral, then bits are shown in their natural  big-endian  order,  with
              LSB  being bit 0.  E.g. <b>bitvec(ushort)</b> with value 0x0102 would be displayed as &lt;1,8&gt;, irrespective
              of underlying byte order.

              For other data types (notably structures and arrays), the  underlying  data  is  interpreted  byte
              after  byte.   Bit  0  of first byte has number 0, bit 0 of second byte number 8, and so on.  Thus
              <b>bitvec(struct(int))</b> is endian sensitive, and will show  bytes  comprising  the  integer  in  their
              memory  order.   Pointers  are  first  dereferenced,  thus  <b>bitvec(array(char,</b> 32<b>)*)</b> is actually a
              pointer to 256-bit bit vector.

       <b>string(</b><u>TYPE</u><b>)</b>
       <b>string[</b><u>EXPR</u><b>]</b>
       <b>string</b>
              The first form of the argument is canonical, the latter two are syntactic sugar.  In the canonical
              form, the function argument is formatted as  string.   The  <u>TYPE</u>  shall  be  either  a  <b>char*</b>,  or
              <b>array(char,</b><u>EXPR</u><b>)</b>, or <b>array(char,</b><u>EXPR</u><b>)*</b>.  If an array is given, the length will typically be a <b>zero</b>
              expression  (but  doesn't  have to be).  Using argument that is plain array (i.e. not a pointer to
              array) makes sense e.g.  in  C  structs,  in  cases  like  <b>struct(string(array(char,</b>  6<b>)))</b>,  which
              describes the C type <b>struct</b> <b>{char</b> s<b>[</b>6<b>];}</b>.

              Because  simple  C-like  strings  are  pretty  common,  there  are two shorthand forms.  The first
              shorthand form (with brackets) means the same as <b>string(array(char,</b> <u>EXPR</u><b>)*)</b>.  Plain <b>string</b> without
              an argument is then taken to mean the same as <b>string[zero]</b>.

              Note that <b>char*</b> by itself describes a pointer to a char.  Ltrace will dereference the pointer, and
              read and display the single character that it points to.

       <b>enum(</b><u>NAME</u>[<b>=</b><u>VALUE</u>]{,<u>NAME</u>[<b>=</b><u>VALUE</u>]}<b>)</b>
       <b>enum[</b><u>TYPE</u><b>](</b><u>NAME</u>[<b>=</b><u>VALUE</u>]{,<u>NAME</u>[<b>=</b><u>VALUE</u>]}<b>)</b>
              This describes an enumeration lens.  If an argument has any of the given  values,  it  is  instead
              shown  as  the  corresponding  <u>NAME</u>.   If a <u>VALUE</u> is omitted, the next consecutive value following
              after the previous <u>VALUE</u> is taken instead.  If the first <u>VALUE</u> is omitted, it's <b>0</b> by default.

              <u>TYPE</u>, if given, is the underlying type.  It is thus possible to create enums over shorts or longsâ€”
              arguments that are themselves plain, non-enum types in C, but whose  values  can  be  meaningfully
              described as enumerations.  If omitted, <u>TYPE</u> is taken to be <b>int</b>.

</pre><h4><b>TYPE</b> <b>ALIASES</b></h4><pre>
       A  line  in  config file can, instead of describing a prototype, create a type alias.  Instead of writing
       the same enum or struct on many places (and possibly updating when it changes), one can introduce a  name
       for such type, and later just use that name:

              <b>typedef</b> <u>NAME</u> <b>=</b> <u>LENS</u><b>;</b>

</pre><h4><b>RECURSIVE</b> <b>STRUCTURES</b></h4><pre>
       Ltrace  allows  you to express recursive structures.  Such structures are expanded to the depth described
       by the parameter -A.  To declare a recursive type, you first have to introduce  the  type  to  ltrace  by
       using forward declaration.  Then you can use the type in other type definitions in the usual way:

              <b>typedef</b> <u>NAME</u> <b>=</b> <b>struct;</b>
              <b>typedef</b> <u>NAME</u> <b>=</b> <b>struct(</b><u>NAME</u> can be used here<b>)</b>

       For  example,  consider  the  following  singy-linked structure and a function that takes such list as an
       argument:

              <b>typedef</b> int_list <b>=</b> <b>struct;</b>
              <b>typedef</b> int_list <b>=</b> <b>struct(int,</b> int_list<b>*);</b>
              <b>void</b> ll<b>(</b>int_list<b>*);</b>

       Such declarations might lead to an output like the following:

              ll({ 9, { 8, { 7, { 6, ... } } } }) = &lt;void&gt;

       Ltrace detects recursion and will not expand already-expanded  structures.   Thus  a  doubly-linked  list
       would look like the following:

              <b>typedef</b> int_list <b>=</b> <b>struct;</b>
              <b>typedef</b> int_list <b>=</b> <b>struct(int,</b> int_list<b>*,</b> int_list<b>*);</b>

       With output e.g. like:

              ll({ 9, { 8, { 7, { 6, ..., ... }, recurse^ }, recurse^ }, nil })

       The  "recurse^"  tokens  mean  that given pointer points to a structure that was expanded in the previous
       layer.  Simple "recurse" would mean that it points back to  this  object.   E.g.  "recurse^^^"  means  it
       points to a structure three layers up.  For doubly-linked list, the pointer to the previous element is of
       course  the  one  that has been just expanded in the previous round, and therefore all of them are either
       recurse^, or nil.  If the next and previous pointers are swapped, the output adjusts correspondingly:

              ll({ 9, nil, { 8, recurse^, { 7, recurse^, { 6, ..., ... } } } })

</pre><h4><b>EXPRESSIONS</b></h4><pre>
       Ltrace has support for some elementary expressions.  Each expression can be either of the following:

       <u>NUM</u>    An integer number.

       <b>arg</b><u>NUM</u> Value of <u>NUM</u>-th argument.  The expression has the same value as the corresponding argument.   <b>arg1</b>
              refers to the first argument, <b>arg0</b> to the return value of the given function.

       <b>retval</b> Return value of function, same as <b>arg0</b>.

       <b>elt</b><u>NUM</u> Value  of  <u>NUM</u>-th  element of the surrounding structure type.  E.g.  <b>struct(ulong,array(int,elt1))</b>
              describes a structure whose first element is a length, and second element an array of ints of that
              length.

       <b>zero</b>
       <b>zero(</b><u>EXPR</u><b>)</b>
              Describes array which extends until the first element, whose each byte is 0.  If an expression  is
              given,  that  is  the maximum length of the array.  If NUL terminator is not found earlier, that's
              where the array ends.

</pre><h4><b>PARAMETER</b> <b>PACKS</b></h4><pre>
       Sometimes the actual function prototype varies slightly depending on the  exact  parameters  given.   For
       example,  the number and types of printf parameters are not known in advance, but ltrace might be able to
       determine them in runtime.  This feature has wider applicability, but currently the only  parameter  pack
       that ltrace supports is printf-style format string itself:

       <b>format</b> When <b>format</b> is seen in the parameter list, the underlying string argument is parsed, and GNU-style
              format  specifiers  are  used  to  determine what the following actual arguments are.  E.g. if the
              format string is "%s %d\n", it's as if the <b>format</b> was replaced by <b>string,</b> <b>string,</b> <b>int</b>.

</pre><h4><b>RETURN</b> <b>ARGUMENTS</b></h4><pre>
       C functions often use one or more arguments for returning values back to the caller.  The caller provides
       a pointer to storage, which the called function initializes.  Ltrace has some support for this idiom.

       When a traced binary hits a function call, ltrace first fetches all arguments.   It  then  displays  <u>left</u>
       portion  of the argument list.  Only when the function returns does ltrace display <u>right</u> portion as well.
       Typically, left portion takes up all the arguments, and right portion only contains  return  value.   But
       ltrace  allows you to configure where exactly to put the dividing line by means of a <b>+</b> operator placed in
       front of an argument:

              <b>int</b> asprintf<b>(+string*,</b> <b>format);</b>

       Here, the first argument to asprintf is denoted as return argument, which means that displaying the whole
       argument list is delayed until the function returns:

              a.out-&gt;asprintf( &lt;unfinished ...&gt;
              libc.so.6-&gt;<a href="../man100/malloc.100.html">malloc</a>(100)                   = 0x245b010
              [... more calls here ...]
              &lt;... asprintf resumed&gt; "X=1", "X=%d", 1) = 5

       It is currently not possible to have an "inout" argument that passes information in both directions.

</pre><h4><b>EXAMPLES</b></h4><pre>
       In the following, the first is the C prototype, and following that is ltrace configuration line.

       <b>void</b> func_charp_string<b>(char</b> str<b>[]);</b>
              <b>void</b> func_charp_string<b>(string);</b>

       <b>enum</b> e_foo <b>{</b>RED<b>,</b> GREEN<b>,</b> BLUE<b>};</b>
       <b>void</b> func_enum<b>(enum</b> e_foo bar<b>);</b>
              <b>void</b> func_enum<b>(enum(</b>RED<b>,</b>GREEN<b>,</b>BLUE<b>));</b>
                     - or -
              <b>typedef</b> e_foo <b>=</b> <b>enum(</b>RED<b>,</b>GREEN<b>,</b>BLUE<b>);</b>
              <b>void</b> func_enum<b>(</b>e_foo<b>);</b>

       <b>void</b> func_arrayi<b>(int</b> arr<b>[],</b> int len<b>);</b>
              <b>void</b> func_arrayi<b>(array(int,arg2)*,int);</b>

       <b>struct</b> S1 <b>{float</b> f<b>;</b> <b>char</b> a<b>;</b> <b>char</b> b<b>;};</b>
       <b>struct</b> S2 <b>{char</b> str<b>[</b>6<b>];</b> <b>float</b> f<b>;};</b>
       <b>struct</b> S1 func_struct<b>(int</b> a<b>,</b> <b>struct</b> S2<b>,</b> <b>double</b> d<b>);</b>
              <b>struct(float,char,char)</b> func_struct_2<b>(int,</b> <b>struct(string(array(char,</b> 6<b>)),float),</b> <b>double);</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Petr Machata &lt;<a href="mailto:pmachata@redhat.com">pmachata@redhat.com</a>&gt;

                                                  October 2012                                    <u><a href="../man5/ltrace.conf.5.html">ltrace.conf</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>