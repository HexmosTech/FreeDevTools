<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>please.ini - configuration file for access</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pleaser">pleaser_0.5.6-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       please.ini - configuration file for access

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>please.ini</b> file contains one or more <b>[sections]</b> that hold ACL for users of the <b>please</b> and <b>pleaseedit</b>
       programs.

       <b>please.ini</b> is an ini file, sections can be named with a short description of what the  section  provides.
       You may then find this helpful when listing rights with <b>please</b> <b>-l</b>.

       Rules  are  read  and applied in the order they are presented in the configuration file.  For example, if
       the user matches a permit rule to run a command in an early section, but in a later section matches  cri‐
       teria  for  a  deny and no further matches, then the user will not be permitted to run that command.  The
       last match wins.

       The properties permitted are described below and should appear at most once per section.  If  a  property
       is used more than once in a section, the last one will be used.

</pre><h4><b>SECTION</b> <b>OPTIONS</b></h4><pre>
       <b>[section-name]</b>
              section name, shown in list mode

       <b>include=[file]</b>
              read ini file, and continue to next section

       <b>includedir=[directory]</b>
              read .ini files in directory, and continue to next section, if the directory does not exist config
              parse will fail

       Sections with a name starting <b>default</b> will retain match actions including implicit <b>permit</b>, therefore set‐
       ting <b>permit=false</b> in the default block and <b>permit=true</b> elsewhere is advised.

</pre><h4><b>MATCHES</b></h4><pre>
       <b>name=[regex]</b>
              mandatory, the user or <b>group</b> (see below) to match against

       <b>target=[regex]</b>
              user to execute or list as, defaults to <b>root</b>

       <b>target_group=[regex]</b>
              requires that the user runs with <b>--group</b> to run or edit with the match

       <b>rule=[regex]</b>
              the regular expression that the command or edit path matches against, defaults to ^$

       <b>notbefore=[YYYYmmdd|YYYYmmddHHMMSS]</b>
              will add HHMMSS as 00:00:00 to the date if not given, defaults to never

       <b>notafter=[YYYYmmdd|YYYYmmddHHMMSS]</b>
              will add 23:59:59 to the date if not given, defaults to never

       <b>datematch=[Day</b> <b>dd</b> <b>Mon</b> <b>HH:MM:SS</b> <b>UTC</b> <b>YYYY]</b>
              regex to match a date string with

       <b>type=[edit/run/list]</b>
              this section’s mode behaviour, defaults to <b>run</b>, edit = <b>pleaseedit</b> entry, list = user access rights
              listing

       <b>group=[true|false]</b>
              defaults to false, when true, the <b>name</b> (above) refers to a group rather than a user

       <b>hostname=[regex]</b>
              permitted  hostnames  where  this  may  apply.  A hostname defined as <b>any</b> or <b>localhost</b> will always
              match.  Defaults to localhost

       <b>dir=[regex]</b>
              permitted directories to run within

       <b>permit_env=[regex]</b>
              allow environments that match <b>regex</b> to optionally pass through

       <b>search_path=[string]</b>
              configure a <b>:</b> separated directory list to locate the binary to execute, does not configure a  <b>PATH</b>
              environment and is searched as the user running <b>please</b>, not as the <b>target</b> user (no plans to change
              that at present)

       <b>regex</b>  is  a regular expression, <b>%{USER}</b> will expand to the user who is currently running <b>please</b>, <b>%{HOST‐</b>
       <b>NAME}</b> expands to the hostname.  See below for examples.  Other <b>%{}</b> expansions may be  added  at  a  later
       date.

       Spaces  within arguments will be substituted as <b>`\</b> <b>'</b> (backslash space).  Use <b>^<a href="file:/bin/echo">/bin/echo</a></b> <b>hello\\</b> <b>world$</b> to
       match <b><a href="file:/bin/echo">/bin/echo</a></b> <b>“hello</b> <b>world”</b>, note that <b>\</b> is a regex escape character so it must be  escaped,  therefore
       matching a space becomes <b>`\\</b> <b>'</b> (backslash backslash space).

       To match a <b>\</b> (backslash), the hex code <b>\x5c</b> can be used.

       To match the string <b>%{USER}</b>, the sequence <b>\x25\{USER\}</b> can be used.

       Rules starting <b>exact</b> are string matches and not <b>regex</b> processed and take precedence over <b>regex</b> matches.

       <b>exact_name=[string]</b>
              only permit a user/group name that matches exactly

       <b>exact_hostname=[string]</b>
              only permit a hostname that matches exactly

       <b>exact_target=[string]</b>
              only permit a target that matches exactly

       <b>exact_target_group=[groupname]</b>
              requires that the user runs with <b>--group</b> to run or edit as <b>groupname</b>

       <b>exact_rule=[string]</b>
              only permit a command rule that matches exactly

       <b>exact_dir=[string]</b>
              only permit a dir that matches exactly

</pre><h4><b>ACTIONS</b></h4><pre>
       <b>permit=[true|false]</b>
              permit or disallow the entry, defaults to true

       <b>require_pass=[true|false]</b>
              if entry matches, require a password, defaults to true

       <b>timeout=[number]</b>
              length of timeout in whole seconds to wait for password input

       <b>last=[true|false]</b>
              if true, stop processing when entry is matched, defaults to false

       <b>reason=[true|false|regex]</b>
              require  a reason for execution/edit.  If reason is <b>true</b> then any reason will satisfy.  Any string
              other than <b>true</b> or <b>false</b> will be treated as a regex match.  Defaults to false

       <b>token_timeout=[number]</b>
              length of timeout for token authentication in whole seconds (default 600)

       <b>syslog=[true|false]</b>
              log this activity to syslog, defaults to true

       <b>env_assign.[key]=[value]</b>
              assign <b>value</b> to environment <b>key</b>

       <b>editmode=[octal</b> <b>mode|keep]</b>
              (<b>type=edit</b>) set the file mode bits on replacement file to octal mode.  When set to  <b>keep</b>  use  the
              existing  file mode.  If the file is not present, or mode is not declared, then mode falls back to
              0600.  If there is a file present, then the mode is read and used just prior to file rename

       <b>exitcmd=[program]</b>
              (<b>type=edit</b>) run program after editor exits as the target user, if exit is zero, continue with file
              replacement.  <b>%{NEW}</b> and <b>%{OLD}</b> placeholders expand to new and old edit files

</pre><h4><b>EXAMPLES</b></h4><pre>
       To allow all commands, you can use a greedy match (<b>^.*$</b>).  You should reduce this to the set  of  accept‐
       able commands though.

              [user_jim_root]
              name = jim
              target = root
              rule = ^.*$

       If  you wish to permit a user to view another’s command set, then you may do this using <b>type=list</b> (<b>run</b> by
       default).  To list another user, they must match the <b>target</b> regex.

              [user_jim_list_root]
              name = jim
              type = list
              target = root

       <b>type</b> may also be <b>edit</b> if you wish to permit a file edit with <b>pleaseedit</b>.

              [user_jim_edit_hosts]
              name = jim
              type = edit
              target = root
              rule = ^<a href="file:/etc/hosts">/etc/hosts</a>$
              editmode = 644

       Naming sections should help later when listing permissions.

       Below, user <b>mandy</b> may run <b>du</b> without needing a password, but must enter her password for a  <b>bash</b>  running
       as root:

              [mandy_du]
              name = mandy
              rule = ^(<a href="file:/usr">/usr</a>)?<a href="file:/bin/du">/bin/du</a> .*$
              require_pass = false
              [mandy_some]
              name = mandy
              rule = ^(<a href="file:/usr">/usr</a>)?<a href="file:/bin/bash">/bin/bash</a>$
              require_pass = true

       The  rule  <b>regex</b>  can  include repetitions.  To permit running <b>wc</b> to count the lines in the log files (we
       don’t know how many there are) in <b><a href="file:/var/log">/var/log</a></b>.  This sort of regex will allow multiple  instances  of  a  <b>()</b>
       group with <b>+</b>, which is used to define the character class <b>[a-zA-Z0-9-]+</b>, the numeric class  and the group
       near the end of the line.  In other words, multiple instances of files in <b><a href="file:/var/log">/var/log</a></b> that may end in common
       log rotate forms <b>-YYYYMMDD</b> or <b>.N</b>.

       This will permit commands such as the following, note how for efficiency find will combine arguments with
       <b>+</b> into fewer invocations.  <b>xargs</b> could have been used in place of <b>find</b>.

              $ find <a href="file:/var/log">/var/log</a> -type f -exec please <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a> {} \+

       Here is a sample for the above scenario:

              [user_jim_root_wc]
              name = jim
              target = root
              permit = true
              rule = ^<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?wc">/usr/bin/wc</a> (<a href="file:/var/log/">/var/log/</a>[a-zA-Z0-9-]+(\.\d+)?(\s)?)+$

       User jim may only start or stop a docker container:

              [user_jim_root_docker]
              name = jim
              target = root
              permit = true
              rule = ^/usr/bin/docker (start|stop) \S+

       User ben may only edit <b><a href="file:/etc/fstab">/etc/fstab</a></b>, and afterwards check the fstab file:

              [ben_fstab]
              name = ben
              target = root
              permit = true
              type = edit
              editmode = 644
              rule = ^<a href="file:/etc/fstab">/etc/fstab</a>$
              exitcmd = <a href="file:/bin/findmnt">/bin/findmnt</a> --verify --tab-file %{NEW}

       User ben may list only users <b>eng</b>, <b>net</b> and <b>dba</b>:

              [ben_ops]
              name = ben
              permit = true
              type = list
              target = ^(eng|net|dba)ops$

       All  users may list their own permissions.  You may or may not wish to do this if you consider permitting
       a view of the rules to be a security risk.

              [list_own]
              name = ^%{USER}$
              permit = true
              type = list
              target = ^%{USER}$

</pre><h4><b>DEFAULT</b> <b>SECTION</b></h4><pre>
       Sections that are named starting with <b>default</b> retain their actions, which can be useful for  turning  off
       <b>syslog</b>  or setting a <b>token_timeout</b> globally, for example, but they will retain <b>permit</b> which implicitly is
       <b>true</b>, it is therefore sensible to negate this (setting <b>permit=false</b>) and set  <b>permit=true</b>  in  subsequent
       sections as needed.

              [default:nosyslog]
              name = .*
              rule = .*
              require_pass = false
              syslog = false
              permit = false
              token_timeout = 1800
              [mailusers]
              name = mailadm
              group = true
              rule = ^/usr/sbin/postcat$
              require_pass = true
              permit = true

</pre><h4><b>EXITCMD</b></h4><pre>
       When  the  user completes their edit, and the editor exits cleanly, if <b>exitcmd</b> is included then this pro‐
       gram will run as the target user.  If the program also exits cleanly then  the  temporary  edit  will  be
       copied to the destination.

       <b>%{OLD}</b>  and  <b>%{NEW}</b>  will  expand to the old (existing source) file and edit candidate, respectively.  To
       verify a file edit, <b>ben</b>’s entry to check <b><a href="file:/etc/hosts">/etc/hosts</a></b> after clean exit could look like this:

              [ben_ops]
              name = ben
              permit = true
              type = edit
              editmode = 644
              rule = ^<a href="file:/etc/hosts">/etc/hosts</a>$
              exitcmd = /usr/local/bin/check_hosts %{OLD} %{NEW}

       <b>/usr/local/bin/check_hosts</b> takes two arguments, the original file as the first argument  and  the  modify
       candidate  as the second argument.  If <b>check_hosts</b> terminates zero, then the edit is considered clean and
       the original file is replaced with the candidate.  Otherwise the edit file is not  copied  and  is  left,
       <b>pleaseedit</b> will exit with the return value from <b>check_hosts</b>.

       A  common <b>exitcmd</b> is to check the validity of <b>please.ini</b>, shown below.  This permits members of the <b>admin</b>
       group to edit <b>/etc/please.ini</b> if they provide a reason (<b>-r</b>).  Upon clean exit from  the  editor  the  tmp
       file will be syntax checked.

              [please_ini]
              name = admins
              group = true
              reason = true
              rule = /etc/please.ini
              type = edit
              editmode = 600
              exitcmd = /usr/bin/please -c %{NEW}

</pre><h4><b>DATED</b> <b>RANGES</b></h4><pre>
       For  large  environments  it is not unusual for a third party to require access during a short time frame
       for debugging.  To accommodate this there are the <b>notbefore</b> and <b>notafter</b> time brackets.  These can be ei‐
       ther <b>YYYYmmdd</b> or <b>YYYYmmddHHMMSS</b>.

       The whole day is considered when using the shorter date form of <b>YYYYmmdd</b>.

       Many enterprises may wish to permit periods of access to a user for a limited time only, even if that in‐
       dividual is considered to have a permanent role.

       User joker can do what they want as root on 1st April 2021:

              [joker_april_first]
              name = joker
              target = root
              permit = true
              notbefore = 20210401
              notafter = 20210401
              rule = ^<a href="file:/bin/bash">/bin/bash</a>

</pre><h4><b>DATEMATCHES</b></h4><pre>
       <b>datematch</b> matches against the date string <b>Day</b> <b>dd</b> <b>mon</b> <b>HH:MM:SS</b> <b>UTC</b> <b>Year</b>.  This enables calendar style date
       matches.

       Note that the day of the month (<b>dd</b>) will be padded with spaces if less than two characters wide.

       You can permit a group of users to run <b>/usr/local/housekeeping/</b> scripts every Monday:

              [l2_housekeeping]
              name = l2users
              group = true
              target = root
              permit = true
              rule = /usr/local/housekeeping/tidy_(logs|images|mail)
              datematch = ^Mon\s+.*

</pre><h4><b>REASONS</b></h4><pre>
       When <b>reason=true</b>, a user must pass a reason with the <b>-r</b> option to <b>please</b> and <b>pleaseedit</b>.  Some  organisa‐
       tions  may  prefer a reason to be logged when a command is executed.  This can be helpful for some situa‐
       tions where something such as <b>mkfs</b> or <b>useradd</b> might be preferable to be logged against a ticket.

              [l2_user_admin]
              name = l2users
              group = true
              target = root
              permit = true
              reason = true
              rule = ^<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?useradd">/usr/sbin/useradd</a> -m \w+$

       Or, if tickets have a known prefix:

              reason = .*(bug|incident|ticket|change)\d+.*

       Perhaps you want to add a mini molly-guard where the hostname must appear in the reason:

              [user_poweroff]
              name = l2users
              group = true
              rule = (<a href="file:/usr">/usr</a>)?/s?bin/(shutdown( -h now)?|poweroff|reboot)
              require_pass = true
              reason = .*%{HOSTNAME}.*

</pre><h4><b>DIR</b></h4><pre>
       In some situations you may only want a command to run within a set  of  directories.   The  directory  is
       specified  with  the <b>-d</b> argument to <b>please</b>.  For example, a program may output to the current working di‐
       rectory, which may only be desirable in certain locations.

              [eng_build_aliases]
              name = l2users
              group = true
              dir = ^/etc/mail$
              rule = ^/usr/local/bin/build_aliases$

</pre><h4><b>LAST</b></h4><pre>
       <b>last</b> <b>=</b> <b>true</b> stops processing at a match:

              [mkfs]
              name = l2users
              group = true
              target = root
              permit = true
              reason = true
              rule = ^/sbin/mkfs.(ext[234]|xfs) /dev/sd[bcdefg]\d?$
              last = true

       For simplicity, there is no need to process other configured rules if certain that the <b>l2users</b> group  are
       safe  to  execute  this.  <b>last</b> should only be used in situations where there will never be something that
       could contradict the match in an undesired way later.

</pre><h4><b>SYSLOG</b></h4><pre>
       By default entries are logged to syslog.  If you do not wish an entry to  be  logged  then  specify  <b>sys‐</b>
       <b>log=false</b>.  In this case <b>jim</b> can run anything in <b><a href="file:/usr/bin/">/usr/bin/</a></b> as root and it will not be logged.

              [maverick]
              syslog = false
              name = jim
              rule = <a href="file:/usr/bin/.">/usr/bin/.</a>*
              reason = false

</pre><h4><b>FILES</b></h4><pre>
       /etc/please.ini

</pre><h4><b>NOTES</b></h4><pre>
       At a later date repeated properties within the same section may be treated as a match list.

</pre><h4><b>CONTRIBUTIONS</b></h4><pre>
       I welcome pull requests with open arms.  New features always considered.

</pre><h4><b>BUGS</b></h4><pre>
       Found a bug?  Please either open a ticket or send a pull request/patch.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/please.1.html">please</a></b>(1)

</pre><h4><b>AUTHORS</b></h4><pre>
       Ed Neville (<a href="mailto:ed-please@s5h.net">ed-please@s5h.net</a>).

please 0.5.6                                    06 September 2024                                  <u><a href="../man5/please.ini.5.html">please.ini</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>