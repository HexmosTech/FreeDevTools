<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>danted.conf - Dante server configuration file syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dante-server">dante-server_1.4.3+dfsg-3.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       danted.conf - <b>Dante</b> server configuration file syntax

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  configuration  file  for  the <b>Dante</b> server controls both access controls and logging.  It is divided
       into three parts; server settings, rules, and routes.

       Note that server settings <b>must</b> come before rules and routes.

       A line can be commented out using the standard comment character <b>#</b>.

</pre><h4><b>SERVER</b> <b>SETTINGS</b></h4><pre>
       The server settings control the generic behaviour of the server.  Each  keyword  is  separated  from  its
       value by a <b>':'</b> character.

       The following keywords are available:

       <b>clientmethod</b>
              A  list  of  acceptable  authentication  methods  for client-rules, listed in order of preference.
              These are authentication methods that are to be checked immediately after  the  SOCKS  client  has
              connected to <b>Dante,</b> <b>and</b> <b>before</b> <b>any</b> <b>socks-negotiation</b> <b>has</b> <b>started.</b>

              <b>Supported</b> <b>values</b> <b>are</b> <b>pam.address,</b> <b>pam.any,</b> <b>none,</b> <b>and</b> <b>rfc931</b> <b>.</b>

              <b>For</b>  <b>all</b>  <b>methods</b>  <b>the</b>  <b>authentication</b>  <b>will</b>  <b>be</b>  <b>based</b> <b>on</b> <b>solely</b> <b>on</b> <b>the</b> <b>IP-address</b> <b>of</b> <b>the</b> <b>client,</b>
              <b>possibly</b> <b>in</b> <b>combination</b> <b>with</b> <b>a</b> <b>rfc931</b> <b>("ident")</b> <b>lookup</b> <b>towards</b> <b>the</b> <b>host</b> <b>the</b> <b>client</b> <b>is</b> <b>running</b> <b>on.</b>

              <b>Any</b> <b>credentials</b> <b>provided</b> <b>during</b> <b>this</b> <b>pass</b> <b>will</b> <b>also</b> <b>be</b> <b>available</b> <b>for</b>  <b>use</b>  <b>in</b>  <b>later</b>  <b>socks-rules,</b>
              <b>when</b> <b>the</b> <b>socks-request</b> <b>from</b> <b>the</b> <b>client</b> <b>is</b> <b>evaluated.</b>

              <b>The</b>  <b>default</b> <b>value</b> <b>for</b> <b>this</b> <b>keyword</b> <b>is</b> <b>all</b> <b>methods</b> <b>that</b> <b>may</b> <b>be</b> <b>necessary</b> <b>for</b> <b>the</b> <b>later</b> <b>socks-based</b>
              <b>authentication</b> <b>methods,</b> <b>as</b> <b>specified</b> <b>as</b> <b>values</b> <b>to</b> <b>the</b> <b>global</b> <b>socksmethod</b>  <b>keyword.</b>   <b>Normally</b>  <b>you</b>
              <b>should</b> <b>not</b> <b>need</b> <b>to</b> <b>set</b> <b>this</b> <b>keyword,</b> <b>as</b> <b>Dante</b> <b>will</b> <b>set</b> <b>it</b> <b>to</b> <b>the</b> <b>correct</b> <b>value</b> <b>by</b> <b>it</b> <b>self.</b>

       <b>compatibility</b>
              With  the <b>sameport</b> keyword, the server attempts to use the same port on the server's external side
              as the client used on the server's internal side.  This is normally the  default,  but  when  this
              option  is given it will be done with privileged ports also, meaning if a client connects to <b>Dante</b>
              from a privileged port, <b>Dante</b> will attempt to connect to the target destination from a  privileged
              port  too.  There can be security issues involved with this, so normally this option should not be
              set.

              The <b>draft-5.05</b> keyword will enable usage of parts of the socks v5-05 draft.  The only feature from
              this draft that  <b>Dante</b>  supports  is  the  "USECLIENTSPORT"  extension.   Note  that  there  is  a
              conflicting  interpretation  of  this  extension,  so  enabling it might prevent clients using the
              conflicting interpretation from working correctly.  Only affects UDP.

       <b>cpu</b>    The CPU settings for the  various  type  of  <b>Dante</b>  processes.   Note  that  the  possibility  for
              configuring  these  settings  depend  on  the platform <b>Dante</b> is running on.  Not all platforms may
              provide support for these type of CPU settings.

              There are four process types: <b>mother,</b> <b>negotiate,</b> <b>request</b>, and <b>io</b>.

              The currently supported options are:

              <b>schedule</b>.&lt;process type&gt;: &lt;scheduling policy&gt;/&lt;priority&gt;.

              Example: <b>cpu.schedule.mother:</b> <b>SCHED_FIFO/20</b> The above  requests  that  the  kernel  schedules  the
              mother process(es) using a first-in, first-out policy, at priority 20.

              The default is to not request any specific scheduling.

              <b>mask</b>.&lt;process type&gt;: &lt;cpu id 1&gt; [cpu id 1 ...]/any.

              Example: <b>cpu.mask.mother:</b> <b>any</b> Example: <b>cpu.mask.io:</b> <b>0</b> <b>1</b>

              The  mask  gives  control  over  the  CPU/cores  on  which  the  different process types will run.
              Specifying the default (<b>all</b>) allows the process type to run on any CPU id. Specifying one or  more
              numeric CPU id limits the process to that set of CPUs.

              The  cpu  keywords  (<b>schedule</b>  and  <b>mask</b>) should in most cases not be necessary. If they are to be
              used, the <b>io</b> processes are where most of the work is done and adjusting the priority or CPU  usage
              is  what is likely to have the most significant performance effect client performance and overhead
              from the server. The other processes are primarily used  during  connection/session  establishment
              and changes to settings for the non-io process types will primarily affect these operations.

              The default is to not limit processes to any specific cpu.

       <b>debug</b>  Print debug info to the logs.  The value sets the debug level.

       <b>errorlog</b>
              This  value  can  be set to receive only error-related logoutput.  Note that this does not include
              client-specific errors, but only more serious "global" errors.

              The possible values are the same as for the <b>logoutput</b> keyword mentioned below.

              The intent is to have a special place that only  serious  errors  are  logged  so  that  they  can
              discovered quickly.  The default is to not have any special place to log errors.

       <b>external</b>
              The address to be used for outgoing connections.  The address given may be either an IP address or
              an interface name.  Can be given multiple times for different addresses.

       <b>external.log.&lt;loglevel&gt;.error</b>
              See <b>internal.log.&lt;loglevel&gt;.error</b>.  This option has an identical syntax and semantics, but applies
              to error related to the external interface side.

       <b>external.protocol</b>
              By  default  <b>Dante</b>  will use the address families specified and available, and there is no need to
              set this keyword.

              In some cases the operator may however wish to specify an address in a form that may include  more
              than one address family, yet not wish for Dante to use all the address families available for that
              address form.

              This  will  typically happen if the operator wishes to specify that Dante should use the addresses
              on a network interface card which has both IPv4 and IPv6 addresses configured,  yet  the  operator
              wishes  Dante  to  only  use one of these two address families.  The operator can then specify the
              address family he wants Dante too look for when expanding the interface name for  IP-addresses  to
              use.

              Valid  values  for this keyword are: <b>ipv4</b> and <b>ipv6</b>, indicating that Dante should only use the IPv4
              address family or only the IPv6  address  family,  respectively.   The  default  is  to  use  both
              families, if available.

              A corresponding keyword exists for the internal side (see <b>internal.protocol</b>).

       <b>external.rotation</b>
              If  more than one external address is given, this governs which of the given addresses is selected
              as the source address for outgoing connections/packets.  Note that regardless  of  which  external
              rotation value is used, all external addresses that are to be used must be listed via the <b>external</b>
              keyword first.

              Valid values are <b>none</b> (the default), <b>route</b>, and <b>same-same</b>.

              <b>none</b> indicates the first address on the list of external addresses should be used.

              <b>route</b>  indicates the kernels routing table should be consulted to find out what the source address
              for a given destination will be, and might require you to set <b>user.privileged</b> to <b>root</b>.  Note  that
              <b>route</b>  might  create  problems  for  ftp-clients  using  active ftp if the <b>Dante</b> bind extension is
              enabled for the ftp-client.

              <b>same-same</b> indicates the source address for a given destination should be the same address  as  the
              <b>Dante</b> server accepted the clients connection on.

       <b>internal</b>
              The  internal addresses.  Connections will only be accepted on these addresses.  The address given
              may be either an IP address or an interface name.

       <b>internal.log.&lt;loglevel&gt;.error</b>
              Specifies that certain system call failures, listed as  symbolic  errno  values,  or  certain  dns
              failures, listed as symbolic libresolv failure-codes, should be logged, possibly an extra time, at
              the log-level <b>log-level</b>.

              Note that this only applies to errors on the internal interface side only.

              A corresponding keyword exists for the external side (see <b>external.log</b>).

              In  addition to the standard errno and <a href="../man3/getaddrinfo.3.html">getaddrinfo</a>(3) error symbols, the following special symbols
              are accepted:

              <b>no-route</b>
                     Any error related to no route.

              <b>dns-any</b>
                     Any error related to DNS/hostname-resolving.

              <b>system-any</b>
                     Any system error.  I.e., any errno value.

       <b>internal.protocol</b>
              See <b>external.protocol</b>.  This option has an identical syntax and  semantics,  but  applies  to  the
              internal interface, for addresses to listen to connections from clients on.

       <b>libwrap.hosts_access</b>
              If  the  server  is  compiled with libwrap support, determines whether the <b>hosts_access()</b> function
              should be used for access control. When enabled by setting this value to <b>yes</b>, the libwrap  library
              determines  if  TCP  connections or UDP packets should be immediately dropped or not, typically by
              consulting <b><a href="file:/etc/hosts.allow">/etc/hosts.allow</a></b> and <b><a href="file:/etc/hosts.deny">/etc/hosts.deny</a></b>. These checks are applied to all  traffic,  before
              the rule processing starts. The default value is <b>no</b> (disabled).

       <b>logoutput</b>
              This value controls where the server sends logoutput.  It can be set to <b>syslog</b>[/<b>facility</b>], <b>stdout</b>,
              <b>stderr</b>, a filename, or a combination.  The default is nowhere.  Note that if <b>errorlog</b> is also set,
              there  will  be a overlap between what is logged there (errors only), and what will be logged here
              (errors, and everything else).

       <b>socksmethod</b>
              A list of acceptable authentication methods for socks-rules, listed in order of preference.  It is
              thus important that you specify these in the desired order, normally with the more secure  methods
              first.

              Supported  values  are  <b>bsdauth</b>,  <b>gssapi</b>,  <b>none</b>,  <b>pam.any</b>,  <b>pam.address</b>, <b>pam.username</b>, <b>rfc931</b>, and
              <b>username</b>,

              If a method is not set in this list it will never be selected.  The default is no  methods,  which
              means all socks-requests will be blocked.

              See  the  section  on <b>AUTHENTICATION</b> <b>METHODS</b> for an explanation of the different methods and their
              meaning.

       <b>srchost</b>
              This keyword allows you to configure a few options that relate to the srchost, i.e., the host  the
              <b>Dante</b> server accepts the connections from.

              With  the  <b>nodnsmismatch</b>  keyword,  the server will not accept connections from addresses having a
              mismatch between DNS IP address and hostname.  Default is to accept them.

              With the <b>nodnsunknown</b> keyword, the server will not accept connections from addresses without a DNS
              record.  Default is to accept them.

              With the <b>checkreplyauth</b> keyword, the server will check that the authentication on bind-replies and
              udp-replies  matches  that  which  is  set  in  the  rule  and  global   socksmethod.    Normally,
              authentication  is not desired on replies, as they are replies sent to the socks-clients from non-
              socks clients, and thus only a limited set of authentication methods are possible.

              The methods possible for TCP are the methods not involving the socks protocol in any way, and  are
              listed in the <b>clientmethod</b> section previously mentioned.  For UDP-replies, no methods can be used.

              Default is not to check the authentication on replies.

       <b>timeout.connect</b>
              The  number  of seconds the server will wait for a connect initiated on behalf of the socks-client
              to complete.  The default is 30.  Setting it to 0 will use the systems default.

       <b>timeout.io</b>
              The number of seconds an established connection can be idle.  The default is 0,  meaning  forever.
              See also the "-n" option in the <a href="../man8/danted.8.html">danted</a>(8) manpage.

              Individual  timeouts  can  be  set  for  TCP  and UDP by suffixing io with ".&lt;protocolname&gt;", i.e.
              <b>timeout.io.tcp</b> or <b>timeout.io.udp</b>.

              Individual timeouts can also be set within rules, using the same syntax.  The timeout set  in  the
              rule will then override the default timeouts for clients matching the rule.

       <b>timeout.negotiate</b>
              The  number  of  seconds  a client can spend negotiating with the <b>Dante</b> server for a socks session
              before <b>Dante</b> will close the connection to the client.  The  default  is  30.   Set  it  to  0  for
              forever, though that is strongly discouraged.

       <b>timeout.tcp_fin_wait</b>
              The timeout for the equivalent of TCP's FIN-WAIT-2.  The default is 0, which means use the systems
              default (normally, no timeout).

       <b>udp.connectdst</b>
              Enables  or  disables whether the server should attempt connecting UDP sockets to the destination.
              Valid values are <b>yes</b> and <b>no</b>.

              The default is <b>yes</b>, which improves UDP performance, but may not be compatible with some  UDP-based
              application  protocols  as  it  means  the  server  can  only receive packets from the destination
              address.

              The socket will only remain connected as long  as  the  client  only  sends  UDP  packets  to  one
              destination address. If packets are sent to multiple destinations the socket will no longer remain
              connected and replies can be received from any destination.

       <b>Userids</b>
              On platforms providing a privilege-model supported by <b>Dante</b>, the <b>Dante</b> server does not use userid-
              switching  via the <a href="../man2/seteuid.2.html">seteuid</a>(2) system call.  On other platforms, it is prudent to set the userid to
              be used by the <b>Dante</b> server to appropriate  values.   The  <b>Dante</b>  server  can  use  two  different
              userids, or three if compiled with libwrap support.  They are as follows:

       <b>user.privileged</b>
              Username  which  will  be used for doing privileged operations.  If you need special privileges to
              read the danted.conf file or to write the danted.pid file  (you  can  create  it  manually  before
              starting  danted),  have  anything  in your configuration that requires binding privileged TCP/UDP
              ports (ports below 1024), or use some sort of password-based authentication, this  probably  needs
              to be set to root.

              If not, you can probably set it to the same value as <b>user.unprivileged</b>.

       <b>user.unprivileged</b>
              User which the server runs as most of the time.  This should be an id with as little privileges as
              possible.  It is recommended that a separate userid is created for this purpose.

       <b>user.libwrap</b>
              User used to execute libwrap commands.  Normally this should be the same as <b>user.unprivileged</b>

</pre><h4><b>MODULES</b></h4><pre>
       The following modules are supported by <b>Dante</b>.  Modules are purchased separately from Inferno Nettverk A/S
       and  may  add  extra  functionality  that  is  not needed by most users.  See the <b>Dante</b> homepage for more
       information.

       <b>bandwidth</b>
              The <b>bandwidth</b> module gives control over how much bandwidth the <b>Dante</b>  server  uses  on  behalf  of
              different clients or to different targets.

       <b>redirect</b>
              The  <b>redirect</b>  module  gives  you control over what addresses the server will use on behalf of the
              clients, as well as allowing you to redirect client requests to a different addresses.

</pre><h4><b>SOCKET</b> <b>OPTIONS</b></h4><pre>
       The server has support for setting a large number of  low-level  socket  options  on  both  incoming  and
       outgoing traffic.  <u>Most</u> <u>users</u> <u>will</u> <u>not</u> <u>need</u> <u>to</u> <u>set</u> <u>any</u> <u>of</u> <u>these</u> <u>options,</u> <u>but</u> <u>some</u> <u>might</u> <u>want</u> <u>to</u> <u>do</u> <u>it,</u> <u>to</u>
       <u>enable</u> <u>special</u> <u>network</u> <u>features,</u> <u>or</u> <u>to</u> <u>perform</u> <u>various</u> <u>experiments.</u>

       Options  can  be  set globally as defaults for all traffic, or be set in the access control rules to only
       affect clients and targets matching the given rule.

       The socket options that are available vary between platforms, so during configuration and building of the
       server the options that are available will be determined. Currently,  the  following  options  should  be
       detected, when available, for the specified protocol levels:

              <b>SOCKET</b> so_bindany,  so_broadcast,  so_debug,  so_dontroute,  so_jumbo, so_keepalive, so_oobinline,
                     so_priority,   so_rcvbuf,   so_rcvbufforce,   so_rcvlowat,    so_sndbuf,    so_sndbufforce,
                     so_sndlowat, so_useloopback

              <b>TCP</b>    tcp_cork,  tcp_cwnd,  tcp_init_cwnd, tcp_keepcnt, tcp_keepidle, tcp_keepintvl, tcp_linger2,
                     tcp_maxrt, tcp_maxseg, tcp_md5sig,  tcp_nodelay,  tcp_noopt,  tcp_nopush,  tcp_sack_enable,
                     tcp_stdurg, tcp_syncnt, tcp_window_clamp

              <b>UDP</b>    udp_cork

              <b>IP</b>     ip_auth_level,    ip_dontfrag,   ip_esp_network_level,   ip_esp_trans_level,   ip_freebind,
                     ip_ipcomp_level, ip_minttl, ip_mtu_discover, ip_portrange, ip_recvtos, ip_tos, ip_ttl

       The syntax for setting socket options is as follows:

       &lt;direction&gt;.&lt;level&gt;.&lt;option&gt;: &lt;value&gt;

       The <b>value</b> field corresponds to the value that the socket option should be set to. For many socket options
       this is an integer value.  The <b>level</b> and <b>option</b> values correspond to the socket names and protocol levels
       listed above. Both should be in lower-case.

       The <b>direction</b> keywords is used to specify whether the socket option should be  set  for  traffic  on  the
       internal  or  the  external interface and can have the values <b>internal</b> and <b>external</b>.  For example, to set
       the IP_TOS socket option on outgoing traffic, the following syntax can be used:

       external.ip.ip_tos: 0x10

       In this example, the argument value (0x10) is specified as a hex value. For some of  the  socket  options
       the  value  can  also be set symbolically. Currently this is possible for the following options, with the
       listed values:

              <b>ip_portrange</b>
                     ip_portrange_default, ip_portrange_low, ip_portrange_high

       The IP_TOS socket option also supports this, but handling this option is somewhat complicated by the same
       bits having different meanings in different RFCs. Handling this is done with a  subfield  that  indicates
       the  type of argument that should be used. The following subfields are defined and should be added to the
       name of the socket option as specified below:

              <b>ip_tos.dscp</b>
                     af11 af12 af13 af21 af22 af23 af31 af32 af33 af41 af42 af43 cs0 cs1 cs2 cs3 cs4 cs5 cs6 cs7
                     ef

              <b>ip_tos.prec</b>
                     netcontrol internetcontrol critic_ecp flashoverride flash immediate priority routine

              <b>ip_tos.tos</b>
                     lowdelay throughput reliability

       When numerical arguments are given to subfields, the values are shifted to apply only to the subfield bit
       range. The following example shows the different ways of setting IP_TOS to <b>lowdelay</b> on external traffic:

       external.ip.ip_tos:     0x10       #base value, numerically
       external.ip.ip_tos.tos: 0x08       #subfield, numerically
       external.ip.ip_tos.tos: lowdelay   #subfield, symbolically

       The first value sets the value directly, the second sets only the TOS bits, which are shifted relative to
       the base value. The final line sets the TOS value symbolically.

       This functionality gives a large amount of control over socket options, but it should not be used without
       some understanding of how the kernel allows the socket option to be set, and the limitations  that  apply
       when the socket options are set as either defaults or in rules.

       Setting  a socket option in a client pass or socks-rules will cause any defaults to be overridden. Global
       options are set before bind() is called on internal sockets, or before connect() is  called  on  external
       sockets. Options set in client rules are also applied before bind() is called on the internal socket, but
       cannot  be  set  for the external socket. For socks-rules, both external and internal options can be set,
       but because the socks-request must be interpreted before the rules can be evaluated, socket  options  can
       only be set on internal sockets after the connection has been received.

       Some  socket  options  must be set before a connection has been established, while others can only be set
       after a connection has been established. Others can be set at any time.

       Socket options that are not  listed  above  can  also  be  set  by  specifying  the  socket  option  name
       numerically, for example:

       external.ip.10:     0x12

       In  this  example the socket option corresponding to the value 10 will be set. These numbers are platform
       dependent but can typically be determined by looking at the appropriate system header files.   Specifying
       options  numerically might result in some warnings, but allows any socket option to be specified, as long
       as it takes a numerical argument. This is not the recommended approach for setting  socket  options,  but
       represents  a simple way of setting socket options that are not directly supported by the server, such as
       local kernel extensions.

</pre><h4><b>AUTHENTICATION</b> <b>METHODS</b></h4><pre>
       The <b>Dante</b> server supports the following authentication methods.  Some installations of <b>Dante</b> may  support
       only a subset of these, depending on platform support.

       <b>none</b>   This method requires no form of authentication.

       <b>username</b>
              This  method  requires the client to provide a username and password.  This information must match
              the username and password given in the system password file.

       <b>gssapi</b> This method requires the setup of a Kerberos environment and can  provide  strong  encryption  and
              authentication, depending on the gssapi settings you choose.

       <b>rfc931</b> This  method requires the host the socks client runs on to provide a rfc931 ("ident") username for
              the client.  This username match a username given in the system password file.

       <b>pam.address</b>
              IP-based (rhosts) PAM authentication.

       <b>pam.any</b>
              Will try to match against any type of PAM authentication, depending on  the  information  that  is
              currently  available.  Normally of limited use, and you should instead set the pam-based method(s)
              you actually want.

       <b>pam.username</b>
              Username/password-based PAM authentication.  Similar to the method <b>username</b>, but  the  information
              is  passed  to  the  PAM subsystem for authentication, rather than <b>Dante</b> using the system password
              file directly.  When using PAM, be wary of memory leakages and other  bugs  in  the  external  PAM
              library <b>Dante</b> will have to use on your platform.

       <b>bsdauth</b>
              This  method  requires  the available client data to be verified by the BSD Authentication system.
              Similar to the method <b>username</b>, but passed to the BSD authentication system instead.

</pre><h4><b>ADDRESSES</b></h4><pre>
       Each address field can consist of an IP address (and where required, a netmask,  separated  from  the  IP
       address  by  a  '<b>/</b>'  sign),  a hostname, a domainname (designated so by the leading '<b>.</b>'), or an interface
       name.

       An IP address can be given on on IPv4 form, IPv6 form, or as the special value <b>0/0</b>, which matches all  IP
       addresses, be they IPv4 or IPv6.  The latter is intended for use in <b>rules</b> that should match both IPv4 and
       IPv6 clients or targets.

       Each address, except the <b>external</b> address, can include an optional <b>port</b> specifier.

</pre><h4><b>RULES</b></h4><pre>
       There  are  two  sets of rules and they work at different levels.  Rules prefixed with <b>client</b> are checked
       first and are used to see if the client is allowed to connect to the <b>Dante</b> server.  We call them "client-
       rules".  These rules will start with <b>client</b> <b>pass</b> for a rule that allows the client, or <b>client</b> <b>block</b> for a
       rule that blocks the client.

       It is recommended that the client-rules do not use hostnames but only IP-addresses, both for security and
       performance reasons.  These rules operate at the TCP level.

       The other rules, which we call "socks-rules", are prefixed with <b>socks</b> and operate at the  socks  protocol
       level.

       These  rules will start with <b>socks</b> <b>pass</b> for a rule that allows the client, or <b>socks</b> <b>block</b> for a rule that
       blocks the client.

       These rules are only checked if the client connection has been allowed by the client-rules.   The  socks-
       rules are used to evaluate the socks request that the client sends.

       While  it  is  less important that these rules use only IP-addresses, provided the client-rules have been
       configured to only allow access from a pre-defined range of client IP-addresses, it is still recommended.

       Both set of rules include a <b>pass</b> or <b>deny</b> keyword.  The <b>pass</b>/<b>deny</b> keyword determines  whether  connections
       matching the rule are to be passed through or be blocked.

       Both  the  client-rules and the socks-rules also specify a <b>from</b>/<b>to</b> address pair which gives the addresses
       the rule will match.

       In both contexts, <b>from</b> refers to the clients address, i.e., the address the client is connecting  to  the
       <b>Dante</b>  server from.  The <b>to</b> address however refers to different things depending on whether it is used in
       a client-rule or in a socks-rule.

       In the client-rule context, <b>to</b> means the address the request is accepted on, i.e., a  address  the  <b>Dante</b>
       server listens on.

       In  the socks-rule context, <b>to</b> means the client's destination address, as expressed in the client's socks
       request.  I.e., the address the <b>Dante</b> server should connect to (for TCP sessions) or send packets to (for
       UDP session) on behalf of the client.

       Both set of rules are evaluated on a "first match is best match"  basis.   That  means,  the  first  rule
       matched for a particular client or socks request is the rule that will be used.

       In addition to the addresses there is a set of optional keywords which can be given.  There are two forms
       of  keywords;  conditions  and  actions.  For each rule, all conditions are checked and if they match the
       request, all actions are executed.

       The list of condition keywords is: <b>clientcompatibility</b>, <b>clientmethod</b>, <b>command</b>, <b>from</b>, <b>group</b>,  <b>socksmethod</b>,
       <b>protocol</b>, <b>proxyprotocol</b>, <b>to</b>, <b>user</b>.

       The   list   of  action  keywords  is:  <b>bandwidth</b>,  <b>libwrap</b>,  <b>log</b>,  <b>session</b>,  <b>redirect</b>,  <b>timeout.connect</b>,
       <b>timeout.negotiate</b>, <b>timeout.io</b>, <b>timeout.tcp_fin_wait</b>, and <b>udp.portrange</b>.

       The format and content of the keyword as used in client-rules or socks-rules is  identical,  but  client-
       rules can contain only a subset of the keyword that socks-rules may contain.

              The contents of a <b>client-rule</b> can be:

       <b>bandwidth</b>
              The clients matching this rule will all share the given amount of bandwidth, measured in bytes per
              second.  Requires the bandwidth module.

       <b>clientcompatibility</b>
              Enables  certain  options for compatibility with broken clients.  Valid values are: <b>necgssapi</b>, for
              compatibility with clients implementing GSSAPI the NEC socks way.

       <b>from</b>   The rule applies to requests coming from the specified address.

       <b>group</b>  The user must belong to one of the groups given as value.

              Note that if gssapi-based authentication is used, the username as provided  to  the  <b>Dante</b>  server
              normally  includes  the Kerberos domain.  The name must be listed on the same form here and in the
              system groupfile (usually <a href="file:/etc/passwd">/etc/passwd</a>) if it is to be used.

       <b>gssapi.enctype</b>
              Which encryption to enforce for GSSAPI-authenticated communication.  Possible  values  are  <b>clear</b>,
              <b>integrity</b>,  or <b>confidentiality</b>.  The default is to accept whatever the client offers except <b>clear</b>,
              as <b>clear</b> is not part of the SOCKS GSSAPI standard.

       <b>gssapi.keytab</b>
              Value for keytab to use.  The default is "FILE:/etc/danted.keytab".

       <b>gssapi.servicename</b>
              Which servicename to use when involving GSSAPI.  Default is "rcmd".

       <b>libwrap</b>
              The server will pass the specified parameter line to libwrap for execution.

       <b>log</b>    Used to control logging.  Accepted keywords  are  <b>connect</b>,  <b>disconnect</b>,  <b>data</b>,  <b>error</b>,  <b>ioop</b>,  and
              <b>tcpinfo</b>.  The default is no logging.

       <b>session</b>
              Control the max number of sessions or session establishment rate. See below for details.

       <b>clientmethod</b>
              Require that the connection be "authenticated" using one of the given clientmethods.

       <b>pam.servicename</b>
              Which servicename to use when involving pam.  Default is "danted".

       <b>port</b>   Parameter  to  <b>from</b>,  <b>to</b>  and  <b>via</b>.   Accepts  the keywords <b>eq/=,</b> <b>neq/!=,</b> <b>ge/&gt;=,</b> <b>le/&lt;=,</b> <b>gt/&gt;,</b> <b>lt/&lt;</b>
              followed by a number.  A port range can also be given as "port &lt;start #&gt; - &lt;end  #&gt;",  which  will
              match all port numbers within the range &lt;start #&gt; and &lt;end #&gt;.

              The default is to match all ports.

       <b>redirect</b>
              The  source  and/or  destination  can  be  redirected  using the <b>redirect</b> statement.  Requires the
              redirect module.

              The syntax of the redirect statement is as follows:

              <b>redirect</b> from: <b>ADDRESS</b>

              See the redirect manual for detailed information.

       <b>socksmethod</b>
              If the client offers more than one authentication method, <b>Dante</b> will  select  the  method  to  use
              based  on  the  order  the  methods  are  listed here.  Valid values are the same as in the global
              <b>socksmethod</b> line.  Normally there will be no need to set this keyword in a client-rule, but if  it
              is set and the client offers none of the methods listed, the client will be blocked at this stage.

       <b>timeout.negotiate</b>
              See the global <b>timeout.negotiate</b> option.

       <b>to</b>     The rule applies to requests going to the address given as value.

       <b>user</b>   The  user  must  match  one  of  the  names  given as value.  If no <b>user</b> value is given for a rule
              requiring usernames, the effect will be the same as listing every user in the password file.

              Note that if gssapi-based authentication is used, the username as provided  to  the  <b>Dante</b>  server
              normally  includes the Kerberos domain.  The name must be listed on the same form here if it is to
              be used.

              The contents of a <b>socks-rule</b> can be:

       <b>bandwidth</b>
              The clients matching this rule will all share the given amount of bandwidth, measured in bytes per
              second.  Requires the bandwidth module.

       <b>bsdauth.stylename</b>
              The name of the BSD authentication style to use. The default is to not specify  a  value,  causing
              the default system style to be used.

       <b>command</b>
              The rule applies to the given commands.  Valid commands are <b>bind</b>, <b>bindreply</b>, <b>connect</b>, <b>udpassociate</b>
              and  <b>udpreply</b>.   Can  be used instead of, or to complement, <b>protocol</b>.  The default is all commands
              valid for the protocols allowed by the rule.

       <b>from</b>   The rule applies to requests coming from the address given as value.

       <b>group</b>  The user must belong to one of the groups given as value.

       <b>libwrap</b>
              The server will pass the line to libwrap for execution.

       <b>log</b>    Used to control logging.  Accepted keywords are <b>connect</b>, <b>disconnect</b>, <b>data</b>, <b>ioop</b>, and <b>tcpinfo</b>.

       <b>session</b>
              Control the max number of sessions or session establishment rate. See

       <b>socksmethod</b>
              Require that the connection be established using one  of  the  given  authentication  methods.   A
              <b>method</b>  normally  refers  to the socks client part of the rule, and thus authenticates the client,
              and not the target destination (see <b>checkreplyauth</b> for information about authentication the target
              destination).  Valid values are the same as in the global <b>socksmethod</b> line.

       <b>pam.servicename</b>
              What servicename to use when involving pam.  Default is "danted".

       <b>port</b>   Parameter to <b>from</b>, <b>to</b> and <b>via</b>.  Accepts the  keywords  <b>eq/=,</b>  <b>neq/!=,</b>  <b>ge/&gt;=,</b>  <b>le/&lt;=,</b>  <b>gt/&gt;,</b>  <b>lt/&lt;</b>
              followed  by  a  number.   A portrange can also be given as "port &lt;start #&gt; - &lt;end #&gt;", which will
              match all port numbers within the range &lt;start #&gt; and &lt;end #&gt;.

              The default is all ports.

       <b>protocol</b>
              The rule applies to the given protocols.  Valid values are  <b>tcp</b>  and  <b>udp</b>.   The  default  is  all
              supported protocols that can apply to the given <b>commands</b>.

       <b>proxyprotocol</b>
              The  rule  applies to requests using the given proxy protocol.  Valid proxy protocols are <b>socks_v4</b>
              and <b>socks_v5</b>.  The default is all supported proxy protocols.

       <b>redirect</b>
              The source and/or destination can be  redirected  using  the  <b>redirect</b>  statement.   Requires  the
              redirect module.

              The syntax of the redirect statement is as follows:

              <b>redirect</b> from: <b>ADDRESS</b>

              <b>redirect</b> to: <b>ADDRESS</b>

              The  semantics  of  <b>from</b>  and  <b>to</b> vary according to <b>command</b>.  See the redirect manual for detailed
              information.

       <b>timeout.connect</b>
              See the global <b>timeout.connect</b> option.

       <b>timeout.io</b>
              See the global <b>timeout.io</b> option.

       <b>timeout.tcp_fin_wait</b>
              See the global <b>timeout.tcp_fin_wait</b> option.

       <b>to</b>     The rule applies to requests going to or using the address given as value.  Note that the  meaning
              of this address is affected by <b>command</b>.

       <b>udp.portrange</b>
              The argument to this keyword is two port numbers, separated by a dash ('-').  They specify the UDP
              port-range  that will be used between the <b>socks-client</b> and the <b>Dante-server</b> <b>for</b> <b>UDP</b> <b>packets.</b>  <b>Note</b>
              <b>that</b> <b>this</b> <b>has</b> <b>no</b> <b>relation</b> <b>to</b> <b>the</b> <b>UDP</b> <b>port-range</b> <b>used</b> <b>between</b> <b>the</b> <b>Dante-server</b> <b>and</b>  <b>external,</b>  <b>non-</b>
              <b>socks,</b> <b>clients/servers.</b>

       <b>user</b>   The  user  must  match  one  of  the  names  given as value.  If no <b>user</b> value is given for a rule
              requiring usernames, the effect will be the same as listing every user in the password file.

</pre><h4><b>SESSION</b></h4><pre>
       The <b>session</b> keyword can be used any any rule to limit the number of active sessions and the rate at which
       they are established. There are two main commands for this; <b>session.max</b>, that controls the max number  of
       sessions that can be matched, and <b>session.throttle</b>, that controls the connection rate. These commands can
       be  applied both for the total limit for all matching clients and can be set as global defaults or in any
       of the rule types.  The <b>session.max</b> keyword takes a number corresponding to the highest number of allowed
       simultaneous connections as an argument. The <b>session.throttle</b> keyword takes two  number  separated  by  a
       slash  character, with the first representing the number of connections and the latter a time duration in
       seconds. If more than the specified number of  connections  are  received  in  the  specified  number  of
       seconds, additional connections will be dropped.

       Stateful session tracking on a per IP-address basis is also supported.  For stateful tracking, the limits
       apply  to  each  connection  with  a  matching  IP-address, with the <b>session.state.key</b> keyword is used to
       control how the IP-address is determined. Currently two values are supported, <b>from</b> and <b>hostid</b>. The former
       causes the limit to be applied to all hosts with the same source IP-address and the  latter  to  all  TCP
       connections  with  the  same  hostid  value.  If  a hostid value is used, the <b>session.state.key.hostindex</b>
       keyword can be used to choose which of the to hostid values are used, with  the  first  value  being  the
       default.

       Limits  are  evaluated  first  for  client  rules, then for hostid rules, and finally for socks rules. By
       default, a limit set in a matching client rule will be used also any subsequent matching hostid or  socks
       rules,  unless  either  of these rules also have session limit keywords.  This session inheritance can be
       disabled in client and hostid rules, causing them to only apply in the rule in which they appear. This is
       done by setting the <b>session.inheritable</b> to <b>no</b>.

       The session keywords must be set in a rule (either client, hostid, or socks), setting  them  globally  is
       not supported.

</pre><h4><b>TRAFFIC</b> <b>MONITORING</b></h4><pre>
       The Dante server can be configured to monitor the traffic passing through it, and trigger alarms based on
       the observed network traffic.

       The  alarms  are specified in so-called monitors. These objects have the same general format as the rules
       Dante uses for access control and enable perform passive monitoring of network traffic, or  the  lack  of
       network traffic.

       The  following  example  shows  the  general  monitor syntax, specifying a monitor without any monitoring
       operations:

         monitor {
          from: 0.0.0.0/0 to: www.example.org port = 80
          protocol: tcp
         }

       A monitor can include many of the same keywords that are available in the Dante ACL rules. The  following
       subset is currently supported:

              <b>from</b>   Normally specifies what SOCKS client addresses/networks to monitor.

              <b>to</b>     Normally specifies what target addresses/networks to monitor.

              <b>protocol</b>
                     Can be used to restrict monitoring to a certain protocol (TCP, UDP or both). Note: only TCP
                     should be used for now.

              <b>hostid</b> Can be used to restrict monitoring to only clients with a specific hostid value set.

              <b>hostindex</b>
                     Used  along with the hostid keyword to control which of the two possible hostid values will
                     be used when matching.

       NOTE: It is currently recommended that the protocol keyword is always specified and set  to  tcp  because
       there  is  currently  only  limited  support  for  monitoring  of UDP traffic, and testing of UDP traffic
       monitoring has not been done.

       The main function of monitors is to provide a container for one or more alarms, which are specified using
       a new set of keywords not available for other rules. Alarms specify a condition that will cause Dante  to
       log a warning if the condition is triggered.

       Active  TCP  sessions  will  at  most match one monitor, but multiple alarms can be specified in a single
       monitor. This makes it possible to specify multiple  sets  of  conditions  for  the  same  TCP  sessions,
       depending  on  what  network  interface  the  traffic  is transferred on and whether the traffic is being
       received or transmitted.

       Alarms can trigger as a result of periods of no or little data being transmitted, or a large  numbers  of
       TCP  connections  disconnecting  during  a  short  period of time, or for other reasons.  See below for a
       complete list of what conditions alarms can be enabled for.

   <b>Data</b> <b>alarms</b>
       Adding an alarm.data keyword to a monitor will result in warnings being logged if there are periods  with
       too little network traffic.

       Dante has four network paths and data alarms can be configured independently for each of them:

              <b>internal.alarm.data.recv</b>
                     Data received on Dante's internal interface (data sent from the SOCKS clients to Dante).

              <b>internal.alarm.data.send</b>
                     Data sent out on Dante's internal interface (data sent from Dante to the SOCKS clients).

              <b>external.alarm.data.recv</b>
                     Data received on Dante's external interface (data sent from the target servers to Dante).

              <b>external.alarm.data.send</b>
                     Data sent out on Dante's external interface (data sent from Dante to the target servers).

       The  data.alarm  keyword  takes  two  parameters:  a byte count and a duration in seconds. The alarm will
       trigger if the specified number of seconds pass with only the specified number of bytes (or  less)  being
       transmitted.

       The syntax is as follows:

       <b>internal.alarm.data.recv:</b> <b>DATALIMIT</b> <b>in</b> <b>INTERVAL</b>

       The  DATALIMIT  is  a  number  that specifies the byte limit. The INTERVAL is a number that specifies the
       duration. If only DATALIMIT bytes (or less) have been transferred during a period of INTERVAL seconds, an
       alarm will trigger in Dante.

       Data alarms trigger when a period of data idleness has been detected. Once a data alarm has triggered  it
       will  remain  active until it is cleared. A warning will be logged when the alarm triggers and than again
       when the alarm condition is cleared. In between these two points no warnings related to this  alarm  will
       be  logged. This avoids repeating the same alarm/warning multiple times during network problems that last
       for an extended amount of time. When the alarm is cleared, Dante will also include information about  how
       long the alarm condition lasted.

       A  data alarm can be cleared in two ways; automatically, once enough data has been transferred in a short
       enough amount of time, or manually, by sending the Dante server a SIGHUP signal. A SIGHUP will cause  all
       active  alarms to be cleared. No log messages indicating that the alarms have cleared will be logged when
       alarms are cleared in this way.

       Once an alarm has been cleared, it can trigger again if enough data is not being transferred.

       Note that data alarms will trigger regardless of whether there are active sessions matching  the  monitor
       or  not;  if  enough  data  is  not being transmitted or received, a data alarm will trigger. Alarms will
       trigger also shortly after server startup, if the Dante server does not  receive  sufficient  traffic  to
       prevent the alarms from triggering.

       Note  that the message indicating that an alarm has cleared is not logged if the alarm was cleared due to
       a SIGHUP signal being received.

   <b>Disconnect</b> <b>alarms</b>
       The disconnect alarms are related to connection disconnects and by using the alarm.disconnect keyword the
       Dante server can log warnings based on the number and rate of terminated connections.

       There are two variants of the alarm keyword, one for the internal network interface,  between  the  SOCKS
       clients and Dante, and one for the external interface, between the Dante server and the target servers:

              <b>internal.alarm.disconnect</b>
                     Connections between SOCKS clients and the Dante server.

              <b>external.alarm.disconnect</b>
                     Connections between the Dante server and target servers.

       Each  alarm  keyword  takes  three  parameters,  a minimum count, a ratio value, and a time interval. The
       following format is used:

       internal.alarm.disconnect: MINCOUNT/RATIO in INTERVAL

       The MINCOUNT is the minimum number of connections that must be disconnected for the alarm to trigger. The
       RATIO is used together with the MINCOUNT to express the number of  connections,  relative  to  the  total
       number  of  connections  that have existed in the time period, that must be disconnected for the alarm to
       trigger. The INTERVAL is the time in seconds within which the disconnects must occur  for  the  alarm  to
       trigger.

       To  set values that are useful, some knowledge about the expected amount of network traffic and number of
       sessions is required. If the rate of disconnects, as a percentage, is lower than the ratio specified,  an
       alarm  will  not trigger. Conversely, if the MINCOUNT is set too low, alarms might trigger too frequently
       because only a small number of disconnects  might  be  sufficient  to  achieve  the  required  number  of
       disconnects and disconnect ratio at times when there are only a few active sessions.

       Only   connections   that   are   terminated   on   the   specified   interface  are  counted,  i.e.,  an
       external.alarm.disconnect alarm will only trigger for connections that  are  terminated  on  the  network
       interface  between  the  Dante  server  and  the  target  server, either by the target server closing the
       connection to Dante or by Dante receiving a fatal network error from that side of the connection (e.g., a
       TCP RST packet).

       Connections that are closed on the internal interface (by the SOCKS clients) will  not  count  towards  a
       disconnect  alarm  on  the  external  side. Likewise, connections closed by target servers will not count
       towards a disconnect alarm on the internal side.

       A practical consequence of this is that if a large number of connections  are  simultaneously  closed  by
       both the client and the target server, each connection will only be counted as a disconnect on one of the
       sides;  either  the  external  side  or  the internal side, depending on which side closes the connection
       first.

       Alarms trigger each time a  sufficient  number  disconnects  occur.  Each  sufficiently  large  burst  of
       disconnects  will  result  in  an alarm, but normally at most one warning per alarm will be logged during
       each time interval, though this might change in a later version of Dante.

       Separate alarms are produced for each distinct alarm keyword when multiple  alarms  are  specified  in  a
       monitor rule.

</pre><h4><b>ROUTES</b></h4><pre>
       The  routes  are  specified  with  a <b>route</b> keyword.  Inside a pair of curly braces ({}) a set of keywords
       control the behavior of the route.  See <a href="../man5/dante.conf.5.html">dante.conf</a>(5) for a description.  This is  used  to  perform  so-
       called "server-chaining", where one socks-server connects to another socks-server further upstream.

       The  syntax  for these routes is the same as the routes used by the client.  Please see <a href="../man5/dante.conf.5.html">dante.conf</a>(5) for
       information about the route syntax.

       There are however some special things one need  to  be  aware  of  regarding  serverchaining  and  routes
       specified for the server:

              At present serverchaining is only supported for the <b>tcp</b> <b>connect</b> command.

              If  the  route  specifies that a username/password-method should be offered to the upstream proxy,
              <b>Dante</b> will forward the username/password received from its own  client  to  the  foreign  upstream
              proxy,  meaning the upstream proxy will receive the user's username and password in cleartext from
              <b>Dante.</b>

              At present serverchaining does not scale well in <b>Dante</b> and should not be  used  for  anything  but
              minimal client loads.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See the example/ directory in the distribution.

</pre><h4><b>FILES</b></h4><pre>
       /etc/danted.conf   <b>Dante</b> server configuration file.
       <a href="file:/etc/passwd">/etc/passwd</a>       systemfile used when doing standard username/password
                         authentication.

</pre><h4><b>AUTHORS</b></h4><pre>
       For inferno Nettverk A/S:
          Michael Shuldman
          Karl-Andre' Skevik

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/danted.8.html">danted</a>(8), <a href="../man5/dante.conf.5.html">dante.conf</a>(5), <a href="../man5/hosts_access.5.html">hosts_access</a>(5)

       Information  about  new  releases  and  other  related  issues  can  be found on the <b>Dante</b> WWW home page:
       <a href="http://www.inet.no/dante/">http://www.inet.no/dante/</a>

       Information   about   commercial   support   can   be   found   on   the   <b>Dante</b>   WWW   support    page:
       <a href="http://www.inet.no/dante/support.html">http://www.inet.no/dante/support.html</a>

                                                  July 29 2013                                    <u><a href="../man5/DANTED.CONF.5.html">DANTED.CONF</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>