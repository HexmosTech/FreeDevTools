<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cgconfig.conf - libcgroup configuration file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cgroup-tools">cgroup-tools_3.1.0-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cgconfig.conf - libcgroup configuration file

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>cgconfig.conf</b>  is  a  configuration file used by <b>libcgroup</b> to define control groups, their parameters and
       their mount points.  The file consists of <u>mount</u> , <u>group</u> and <u>default</u> sections. These sections  can  be  in
       arbitrary order and all of them are optional. Any line starting with '#' is considered a comment line and
       is ignored.

       <u>mount</u> section has this form:

              <b>mount</b> <b>{</b>
                     <b>&lt;controller&gt;</b> <b>=</b> <b>&lt;path&gt;;</b>
                     <u>...</u>
              <b>}</b>

       <b>controller</b>
              Name  of  the  kernel  subsystem.  The  list of subsystems supported by the kernel can be found in
              <u><a href="file:/proc/cgroups">/proc/cgroups</a></u> file. Named hierarchy can be  specified  as  controller  <b>"name=&lt;somename&gt;"</b>.  Do  not
              forget  to  use  double  quotes around this controller name (see examples below). Apart from named
              hierarchy, additional mount options may be specified by putting the controller and the options  in
              quotes. Options supported are  <b>nosuid,</b> <b>noexec</b> and <b>nodev</b>.

              <b>Libcgroup</b> merges all subsystems mounted to the same directory (see Example 1) and the directory is
              mounted only once.

       <b>path</b>   The  directory  path  where the group hierarchy associated to a given controller shall be mounted.
              The directory is created automatically on cgconfig service startup if it does  not  exist  and  is
              deleted on service shutdown.

       If no <u>mount</u> section is specified, no controllers are mounted.

       <u>group</u> section has this form:

              <b>group</b> <b>&lt;name&gt;</b> <b>{</b>
                     <b>[permissions]</b>
                     <b>&lt;controller&gt;</b> <b>{</b>
                            <b>&lt;param</b> <b>name&gt;</b> <b>=</b> <b>&lt;param</b> <b>value&gt;;</b>
                            <u>...</u>
                     <b>}</b>
                     <u>...</u>
              <b>}</b>

       <b>name</b>   Name  of the control group. It can contain only characters, which are allowed for directory names.
              The groups form a tree, i.e. a control group can contain zero or more subgroups. Subgroups can  be
              specified using '/' delimiter.

              The  root  control  group is always created automatically in all hierarchies and it is the base of
              the group hierarchy. It can be explicitly specified in <b>cgconfig.conf</b> by using '.' as  group  name.
              This can be used e.g. to set its permissions, as shown in Example 6.

              When the parent control group of a subgroup is not specified it is created automatically.

       <b>permissions</b>
              Permissions  of  the  given control group on mounted filesystem.  <u>root</u> has always permission to do
              anything with the control group.  Permissions have the following syntax:
                        <b>perm</b> <b>{</b>
                               <b>task</b> <b>{</b>
                                      <b>uid</b> <b>=</b> <b>&lt;task</b> <b>user&gt;;</b>
                                      <b>gid</b> <b>=</b> <b>&lt;task</b> <b>group&gt;;</b>
                                      <b>fperm</b> <b>=</b> <b>&lt;file</b> <b>permissions&gt;</b>
                               <b>}</b>
                               <b>admin</b> <b>{</b>
                                      <b>uid</b> <b>=</b> <b>&lt;admin</b> <b>name&gt;;</b>
                                      <b>gid</b> <b>=</b> <b>&lt;admin</b> <b>group&gt;;</b>
                                      <b>dperm</b> <b>=</b> <b>&lt;directory</b> <b>permissions&gt;</b>
                                      <b>fperm</b> <b>=</b> <b>&lt;file</b> <b>permissions&gt;</b>
                               <b>}</b>
                        <b>}</b>

              <b>task</b> <b>user/group</b>  Name of the user and the group, which own the <u>tasks</u> file of  the  control  group.
                               Given  fperm then specify the file permissions.  Please note that the given value
                               is not used as was specified. Instead, current file owner permissions are used as
                               a "umask" for group and others permissions. For example if fperm = 777 then  both
                               group and others will get the same permissions as the file owner.

              <b>admin</b> <b>user/group</b> Name of the user and the group which own the rest of control group's files. Given
                               fperm  and  dperm control file and directory permissions.  Again, the given value
                               is masked by the file/directory owner permissions.

              Permissions are only apply to the enclosing control group and are not inherited by  subgroups.  If
              there  is no <b>perm</b> section in the control group definition, <u>root:root</u> is the owner of all files and
              default file permissions are preserved if fperm resp. dperm are not specified.

       <b>controller</b>
              Name of the kernel subsystem.  The section can be empty, default kernel parameters will be used in
              this case. By specifying <b>controller</b> the control group and all its parents are  controlled  by  the
              specific  subsystem.  One  control  group  can  be  controlled by multiple subsystems, even if the
              subsystems are mounted on different directories. Each control group must be controlled by at least
              one subsystem, so that <b>libcgroup</b> knows in which hierarchies the control group should be created.

              The parameters of the given controller can be  modified  in  the  following  section  enclosed  in
              brackets.

              <b>param</b> <b>name</b>
                     Name of the file to set. Each controller can have zero or more parameters.

              <b>param</b> <b>value</b>
                     Value  which  should  be  written  to  the file when the control group is created. If it is
                     enclosed in double quotes `"', it can contain spaces and other special characters.

       If no <u>group</u> section is specified, no groups are created.

       <u>default</u> section has this form:

              <b>default</b> <b>{</b>
                     <b>perm</b> <b>{</b>
                            <b>task</b> <b>{</b>
                                   <b>uid</b> <b>=</b> <b>&lt;task</b> <b>user&gt;;</b>
                                   <b>gid</b> <b>=</b> <b>&lt;task</b> <b>group&gt;;</b>
                                   <b>fperm</b> <b>=</b> <b>&lt;file</b> <b>permissions&gt;</b>
                            <b>}</b>
                            <b>admin</b> <b>{</b>
                                   <b>uid</b> <b>=</b> <b>&lt;admin</b> <b>name&gt;;</b>
                                   <b>gid</b> <b>=</b> <b>&lt;admin</b> <b>group&gt;;</b>
                                   <b>dperm</b> <b>=</b> <b>&lt;directory</b> <b>permissions&gt;</b>
                                   <b>fperm</b> <b>=</b> <b>&lt;file</b> <b>permissions&gt;</b>
                            <b>}</b>
                     <b>}</b>
              <b>}</b>

       Content of the <b>perm</b> section has the same form as in <u>group</u> section. The permissions defined  here  specify
       owner  and  permissions  of  groups and files of all groups, which do not have explicitly specified their
       permissions in their <u>group</u> section.

       <u>template</u> section has the same structure as <b>group</b> section. Template name uses the same templates string as
       <b>cgrules.conf</b> destination tag (see (<b>cgrules.conf</b> (5)).  Template definition is used  as  a  control  group
       definition  for rules in <b>cgrules.conf</b> (5) with the same destination name.  Templates does not use <b>default</b>
       section settings.

       <u>/etc/cgconfig.d/</u> directory can be used for additional  configuration  files.  cgrulesengd  searches  this
       directory for additional templates.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Example</b> <b>1</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     cpuacct = /sys/fs/cgroup/cpu;
              }

       creates the hierarchy controlled by two subsystems with no groups inside. It corresponds to the following
       operations:

              mkdir /sys/fs/cgroup/cpu
              mount -t cgroup -o cpu,cpuacct cpu /sys/fs/cgroup/cpu

   <b>Example</b> <b>2</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     "name=scheduler" = /sys/fs/cgroup/cpu;
                     "name=noctrl" = /sys/fs/cgroup/noctrl;
              }

              group daemons {
                     cpu {
                            cpu.shares = "1000";
                     }
              }
              group test {
                     "name=noctrl" {
                     }
              }
       creates  two  hierarchies.  One hierarchy named <b>scheduler</b> controlled by cpu subsystem, with group <b>daemons</b>
       inside. Second hierarchy is named <b>noctrl</b> without any controller,  with  group  <b>test</b>.  It  corresponds  to
       following operations:

              mkdir /sys/fs/cgroup/cpu
              mount -t cgroup -o cpu,name=scheduler cpu /sys/fs/cgroup/cpu
              mount -t cgroup -o none,name=noctrl none /sys/fs/cgroup/noctrl

              mkdir /sys/fs/cgroup/cpu/daemons
              echo 1000 &gt; /sys/fs/cgroup/cpu/daemons/www/cpu.shares

              mkdir /sys/fs/cgroup/noctrl/tests

       The  <u>daemons</u>  group  is created automatically when its first subgroup is created. All its parameters have
       the default value and only root can access group's files.

       Since both <u>cpuacct</u> and <u>cpu</u> subsystems are mounted to  the  same  directory,  all  groups  are  implicitly
       controlled also by <u>cpuacct</u> subsystem, even if there is no <u>cpuacct</u> section in any of the groups.

   <b>Example</b> <b>3</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     cpuacct = /sys/fs/cgroup/cpu;
              }

              group daemons/www {
                     perm {
                            task {
                                   uid = root;
                                   gid = webmaster;
                                   fperm = 770;
                            }
                            admin {
                                   uid = root;
                                   gid = root;
                                   dperm = 775;
                                   fperm = 744;
                            }
                     }
                     cpu {
                            cpu.shares = "1000";
                     }
              }

              group daemons/ftp {
                     perm {
                            task {
                                   uid = root;
                                   gid = ftpmaster;
                                   fperm = 774;
                            }
                            admin {
                                   uid = root;
                                   gid = root;
                                   dperm = 755;
                                   fperm = 700;
                            }
                     }
                     cpu {
                            cpu.shares = "500";
                     }
              }
       creates  the  hierarchy controlled by two subsystems with one group and two subgroups inside, setting one
       parameter.  It corresponds to the following operations (except for file permissions which are little  bit
       trickier to emulate via chmod):

              mkdir /sys/fs/cgroup/cpu
              mount -t cgroup -o cpu,cpuacct cpu /sys/fs/cgroup/cpu

              mkdir /sys/fs/cgroup/cpu/daemons

              mkdir /sys/fs/cgroup/cpu/daemons/www
              chown root:root /sys/fs/cgroup/cpu/daemons/www/*
              chown root:webmaster /sys/fs/cgroup/cpu/daemons/www/tasks
              echo 1000 &gt; /sys/fs/cgroup/cpu/daemons/www/cpu.shares

               # + chmod the files so the result looks like:
               # ls -la /sys/fs/cgroup/cpu/daemons/www/
               # admin.dperm = 755:
               # drwxr-xr-x. 2 root webmaster 0 Jun 16 11:51 .
               #
               # admin.fperm = 744:
               # --w-------. 1 root webmaster 0 Jun 16 11:51 cgroup.event_control
               # -r--r--r--. 1 root webmaster 0 Jun 16 11:51 cgroup.procs
               # -r--r--r--. 1 root webmaster 0 Jun 16 11:51 cpuacct.stat
               # -rw-r--r--. 1 root webmaster 0 Jun 16 11:51 cpuacct.usage
               # -r--r--r--. 1 root webmaster 0 Jun 16 11:51 cpuacct.usage_percpu
               # -rw-r--r--. 1 root webmaster 0 Jun 16 11:51 cpu.rt_period_us
               # -rw-r--r--. 1 root webmaster 0 Jun 16 11:51 cpu.rt_runtime_us
               # -rw-r--r--. 1 root webmaster 0 Jun 16 11:51 cpu.shares
               # -rw-r--r--. 1 root webmaster 0 Jun 16 11:51 notify_on_release
               #
               # tasks.fperm = 770
               # -rw-rw----. 1 root webmaster 0 Jun 16 11:51 tasks

              mkdir /sys/fs/cgroup/cpu/daemons/ftp
              chown root:root /sys/fs/cgroup/cpu/daemons/ftp/*
              chown root:ftpmaster /sys/fs/cgroup/cpu/daemons/ftp/tasks
              echo 500 &gt; /sys/fs/cgroup/cpu/daemons/ftp/cpu.shares

               # + chmod the files so the result looks like:
               # ls -la /sys/fs/cgroup/cpu/daemons/ftp/
               # admin.dperm = 755:
               # drwxr-xr-x. 2 root ftpmaster 0 Jun 16 11:51 .
               #
               # admin.fperm = 700:
               # --w-------. 1 root ftpmaster 0 Jun 16 11:51 cgroup.event_control
               # -r--------. 1 root ftpmaster 0 Jun 16 11:51 cgroup.procs
               # -r--------. 1 root ftpmaster 0 Jun 16 11:51 cpuacct.stat
               # -rw-------. 1 root ftpmaster 0 Jun 16 11:51 cpuacct.usage
               # -r--------. 1 root ftpmaster 0 Jun 16 11:51 cpuacct.usage_percpu
               # -rw-------. 1 root ftpmaster 0 Jun 16 11:51 cpu.rt_period_us
               # -rw-------. 1 root ftpmaster 0 Jun 16 11:51 cpu.rt_runtime_us
               # -rw-------. 1 root ftpmaster 0 Jun 16 11:51 cpu.shares
               # -rw-------. 1 root ftpmaster 0 Jun 16 11:51 notify_on_release
               #
               # tasks.fperm = 774:
               # -rw-rw-r--. 1 root ftpmaster 0 Jun 16 11:51 tasks

       The  <u>daemons</u>  group  is created automatically when its first subgroup is created. All its parameters have
       the default value and only root can access the group's files.

       Since both <u>cpuacct</u> and <u>cpu</u> subsystems are mounted to the same directory, all groups are  implicitly  also
       controlled by the <u>cpuacct</u> subsystem, even if there is no <u>cpuacct</u> section in any of the groups.

   <b>Example</b> <b>4</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     cpuacct = /sys/fs/cgroup/cpuacct;
              }

              group daemons {
                     cpuacct{
                     }
                     cpu {
                     }
              }
       creates  two  hierarchies  and  one  common  group  in  both  of  them.   It corresponds to the following
       operations:

              mkdir /sys/fs/cgroup/cpu
              mkdir /sys/fs/cgroup/cpuacct
              mount -t cgroup -o cpu cpu /sys/fs/cgroup/cpu
              mount -t cgroup -o cpuacct cpuacct /sys/fs/cgroup/cpuacct

              mkdir /sys/fs/cgroup/cpu/daemons
              mkdir /sys/fs/cgroup/cpuacct/daemons

       In fact there are two groups created. One in the <u>cpuacct</u> hierarchy, the  second  in  the  <u>cpu</u>  hierarchy.
       These two groups have nothing in common and can contain different subgroups and different tasks.

   <b>Example</b> <b>5</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     cpuacct = /sys/fs/cgroup/cpuacct;
              }

              group daemons {
                     cpuacct{
                     }
              }

              group daemons/www {
                     cpu {
                            cpu.shares = "1000";
                     }
              }

              group daemons/ftp {
                     cpu {
                            cpu.shares = "500";
                     }
              }
       creates two hierarchies with few groups inside. One of the groups is created in both hierarchies.

       It corresponds to the following operations:

              mkdir /sys/fs/cgroup/cpu
              mkdir /sys/fs/cgroup/cpuacct
              mount -t cgroup -o cpu cpu /sys/fs/cgroup/cpu
              mount -t cgroup -o cpuacct cpuacct /sys/fs/cgroup/cpuacct

              mkdir /sys/fs/cgroup/cpuacct/daemons
              mkdir /sys/fs/cgroup/cpu/daemons
              mkdir /sys/fs/cgroup/cpu/daemons/www
              echo 1000 &gt; /sys/fs/cgroup/cpu/daemons/www/cpu.shares
              mkdir /sys/fs/cgroup/cpu/daemons/ftp
              echo 500 &gt; /sys/fs/cgroup/cpu/daemons/ftp/cpu.shares
       Group  <u>daemons</u> is created in both hierarchies. In the <u>cpuacct</u> hierarchy the group is explicitly mentioned
       in the configuration file. In the <u>cpu</u> hierarchy the group is  created  implicitly  when  <u>www</u>  is  created
       there.  These  two  groups have nothing in common, for example they do not share processes and subgroups.
       Groups <u>www</u> and <u>ftp</u> are created only in the <u>cpu</u> hierarchy and are not controlled by the <u>cpuacct</u> subsystem.

   <b>Example</b> <b>6</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     cpuacct = /sys/fs/cgroup/cpu;
              }

              group . {
                     perm {
                            task {
                                   uid = root;
                                   gid = operator;
                            }
                            admin {
                                   uid = root;
                                   gid = operator;
                            }
                     }
                     cpu {
                     }
              }

              group daemons {
                     perm {
                            task {
                                   uid = root;
                                   gid = daemonmaster;
                            }
                            admin {
                                   uid = root;
                                   gid = operator;
                            }
                     }
                     cpu {
                     }
              }
       creates the hierarchy controlled by two subsystems with one group having some  special  permissions.   It
       corresponds to the following operations:

              mkdir /sys/fs/cgroup/cpu
              mount -t cgroup -o cpu,cpuacct cpu /sys/fs/cgroup/cpu

              chown root:operator /sys/fs/cgroup/cpu/*
              chown root:operator /sys/fs/cgroup/cpu/tasks

              mkdir /sys/fs/cgroup/cpu/daemons
              chown root:operator /sys/fs/cgroup/cpu/daemons/*
              chown root:daemonmaster /sys/fs/cgroup/cpu/daemons/tasks

       Users  which  are members of the <u>operator</u> group are allowed to administer the control groups, i.e. create
       new control groups and move processes between these groups without having root privileges.

       Members of the <u>daemonmaster</u> group can move processes to the <u>daemons</u> control group, but they can not  move
       the process out of the group. Only the <u>operator</u> or root can do that.

   <b>Example</b> <b>7</b>
       The configuration file:

              mount {
                     cpu = /sys/fs/cgroup/cpu;
                     cpuacct = /sys/fs/cgroup/cpuacct;
              }

              group students {
                     cpuacct{
                     }
                     cpu {
                     }
              }

              template students/%u {
                     cpuacct{
                     }
                     cpu {
                     }
              }

              mkdir /sys/fs/cgroup/cpu/daemons
              mkdir /sys/fs/cgroup/cpuacct/daemons

       The situation is the similar as in Example 4. The only difference is template, which is used if some rule
       uses "/students/%u" as a destination.

   <b>Example</b> <b>8</b>
       The configuration file:

              mount {
                     "cpu,nodev,nosuid,noexec" = /mnt/cgroups/cpu;
              }

       This  is the same as mount -t cgroup cgroup -o nodev,nosuid,noexec,cpu /mnt/cgroups/cpu It mounts the cpu
       controller with MS_NODEV, MS_NOSUID and MS_NOEXEC options passed.

</pre><h4><b>RECOMMENDATIONS</b></h4><pre>
   <b>Keep</b> <b>hierarchies</b> <b>separated</b>
       Having multiple hierarchies is perfectly valid and can be useful in various scenarios.  To  keeps  things
       clean,  do  not  create  one  group  in  multiple  hierarchies.  Examples 4 and 5 show how unreadable and
       confusing it can be, especially when reading somebody elses configuration file.

   <b>Explicit</b> <b>is</b> <b>better</b> <b>than</b> <b>implicit</b>
       <b>libcgroup</b> can implicitly create groups which are needed for the creation of  configured  subgroups.  This
       may  be  useful  and  save  some  typing in simple scenarios. When it comes to multiple hierarchies, it's
       better to explicitly specify all groups and all controllers related to them.

</pre><h4><b>FILES</b></h4><pre>
       <b>/etc/cgconfig.conf</b>
              default libcgroup configuration file

       <b>/etc/cgconfig.d/</b>
              default libcgroup configuration files directory

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       cgconfigparser (8)

</pre><h4><b>BUGS</b></h4><pre>
       Parameter values must be single strings without spaces.  Parsing of quoted strings is not implemented.

                                                                                                <u><a href="../man5/CGCONFIG.CONF.5.html">CGCONFIG.CONF</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>