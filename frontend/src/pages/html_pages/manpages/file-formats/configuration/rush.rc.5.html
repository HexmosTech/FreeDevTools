<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rush.rc - configuration rules for remote user shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/rush">rush_2.4-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rush.rc - configuration rules for remote user shell

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  file  <b>/etc/rush.rc</b> contains a set of rules that the <b><a href="../man8/rush.8.html">rush</a></b>(8) shell uses in order to determine whether
       the user is allowed to execute the requested command and to set up the environment for its execution.

       Empty lines are ignored.  Lines beginning with a pound sign are comments and are ignored as well.

       Except for comments and empty lines, each line of the configuration file  consists  of  the  keyword  and
       optional  value,  and  constitutes  a  <u>statement</u>.   Exceedingly  long  lines may be split across multiple
       physical lines, by ending each line with a backslash immediately followed by a newline.  Statements  fall
       into  two  major  classes: <u>section</u> and <u>regular</u> statements.  A <u>section</u> statement serves as a container for
       one or more regular statements that pursue the same goal, thus playing the role of a chapter in  a  book.
       A <u>regular</u> statement modifies a certain aspect of the program's behavior.

       The overall file structure is as follows:

         <b>rush</b> <b>2.0</b>

         <b>global</b>
           <u>keyword</u> <u>value</u>
           ...

         <b>rule</b> <u>A</u>
           <u>keyword</u> <u>value</u>
           ...

         <b>rule</b> <u>B</u>
           <u>keyword</u> <u>value</u>
           ...

       A  configuration  file  must  begin  with a <b>rush</b> statement indicating the version of the syntax this file
       uses.  Current versions of <b>rush</b> implement syntax version  2.0.   In  the  absence  of  the  initial  <b>rush</b>
       statement,  the  program will treat the configuration file as written in legacy configuration syntax (see
       <b><a href="http://www.gnu.org.ua/software/rush/manual/1.x">http://www.gnu.org.ua/software/rush/manual/1.x</a></b> for details).

       There are two section statements: <b>global</b> and <b>rule</b>.  The <b>global</b> section  contains  statements  configuring
       the  behavior  of the program in general.  There can be as many <b>global</b> statements in the configuration as
       you consider necessary, each of them affecting the material up to the next <b>global</b> statement,  or  end  of
       the file, whichever occurs first.

       Examples  of  statements  that can be used in a <b>global</b> section are: <b>debug</b>, which sets the debug verbosity
       level, <b>message</b>, which configures error messages, etc.  See the <b>global</b> section for the full list.

       One or more <b>rule</b> statements constitute the core of the configuration.  Each  <b>rule</b>  statement  provides  a
       recipe  for serving a specific class of input commands.  When <b>rush</b> is invoked with a specific command, it
       will scan the configuration file looking for a rule that matches the requested command line.  If  such  a
       rule is found, it will be applied.  Commands that don't match any rule will be rejected.

       A  <b>rule</b> statement may be followed by a <u>tag</u>, an arbitrary sequence of non-whitespace characters serving as
       a label for this rule.  This sequence will be used in diagnostic messages to identify this rule.  In  the
       absence  of  user-supplied tag, the default one will be generated, consisting of the <b>#</b> symbol followed by
       the ordinal number of the rule in the configuration file (started with 1).

       To match a particular command, each  rule  should  contain  the  <b>match</b>  statement.   Its  argument  is  a
       conditional  expression that can contain comparison and boolean operators.  The operands can refer to the
       command line using shell-like variables: <b>$command</b> to refer to the entire command line, <b>$#</b>,  referring  to
       the  number  of arguments in the command line (the command itself being counted as one of the arguments),
       <b>$0</b> meaning the command name, and <b>$1</b>, <b>$2</b>,  etc.,  referring  to  the  particular  command  line  arguments
       (arguments past the ninth one can be accessed as, e.g.  <b>${10}</b>).  For example, the following rule:

         rule
           match $command == "ls"

       will match only the <b>ls</b> command without arguments.

       The  <b>~</b>  (tilde) operator denotes regular expression matching.  For example, the following rule matches <b>ls</b>
       command, optionally preceded with any path prefix:

         rule
           match $0 ~ "^(.*/)?ls$"

       <b>Match</b> expressions can contain terms of arbitrary complexity.  Consider the following example:

         rule
           match $0 ~ "^(.*/)?ls$" &amp;&amp; $# == 2 \
                 &amp;&amp; $1 !~ "^(/|<a href="file:/etc">/etc</a>)$"

       This rule will match any <b>ls</b> command having exactly one argument, unless  that  argument  is  <b>/</b>  or  <b><a href="file:/etc">/etc</a></b>.
       Notice  the  use  of  the  <b>!~</b>  operator to denote the negated regular expression matching, and the use of
       backslash to split a single expression across two physical lines.

       Variables are referenced using the same syntax as in shell.  For example, <b>${1:-<a href="file:/bin">/bin</a>}</b> expands to the value
       of the first parameter, if it is supplied, or to the string  "<a href="file:/bin">/bin</a>"  otherwise.   For  details.  see  the
       section <b>REFERENCE:</b> <b>VARIABLE</b> <b>EXPANSION</b>.

       Although  important, the <b>match</b> statement is not mandatory in a <b>rule</b> statement.  If it is absent, the rule
       will match any command line.  This is normally used in <u>fall-through</u> rules.  A fall-through  rule  applies
       modifications  to  the  command  environment.  After applying such rule, the scanning resumes at the rule
       that follows it. Fall-through rules are marked with the <b>fall-through</b> statement.

   <b>set</b>
       A rule can modify the command line and environment in which it will be executed.  The  <b>set</b>  statement  is
       provided  for  altering  the  command  line or its parts.  It takes three arguments: the variable name or
       index, the operator and the value.  For example, the statement:

         set command = "/bin/sftp-server -u 002"

       replaces the entire command line.  To replace particular arguments, use the <b>[</b><u>N</u>] syntax, where  <u>N</u>  is  the
       index of the argument in the command line.  For example, to set the first argument:

         set [1] = "<a href="file:/tmp">/tmp</a>"

       The  part  to  the right of the equals sign can contain a transformation, i.e. a string followed by the <b>~</b>
       operand and a <u>s-expression</u> of the form <b>s/</b><u>regexp</u><b>/</b><u>replacement</u><b>/</b>[<u>flags</u>].  Parenthesized groups in <u>regexp</u>  can
       be referred to in <u>replacement</u> using the backreference construct <b>\</b><u>N</u>, where <u>N</u> is the 1-based ordinal number
       of the group.  For example, the following statement sets the second argument to the directory part of the
       first one:

         set [2] = "$1" ~ "s/(.*)\\//\\1/"

       Two points are worth noticing.  First, the left operand of <b>~</b> undergoes variable expansion.  Secondly, the
       right-hand side operand is quoted and therefore each backslash in it has to be escaped.

       The special operator <b>=~</b> is used if the resulted value is assigned to the same variable that served as its
       argument.  For example, the two statements below are equivalent:

         set [1] =~ "s/(.*)\\//\\1/"
         set [1] = "$1" ~ "s/(.*)\\//\\1/"

       Parenthesized  groups matched by the most recent <b>set</b> statement remain available for use in the statements
       that follow it in the rule.  To refer to the group from the recent matching, use the following construct:
       <b>%</b><u>N</u>.  For example, the following two statements set the first argument to the directory part,  and  second
       argument to the base name of the original <b>$1</b> value:

         set [1] =~ "s/(.*)\\/(.*)/\\1/"
         set [2] = %2

       The <b>set</b> statement operates not only on positional arguments and built-in variables, but also on arbitrary
       user-defined  variables.  A user-defined variable springs into existence when it first appears as a left-
       hand side argument to the <b>set</b> statement.  The name of the  variable  must  follow  the  usual  rules  for
       variable  names:  it  must  begin  with an alphabetical character or underscore and contain only letters,
       digits and underscores.  References to user-defined variables follow the  same  syntax  as  for  built-in
       ones.

       The following example uses temporary variable <b>temp</b> to swap two arguments:

         set temp = $1
         set [1] = $2
         set [2] = $temp

   <b>unset</b>
       Variable  definitions  can  be  removed  using the <b>unset</b> statement.  It takes variable name or positional
       argument index as its argument:

         unset temp

       When index is given, the corresponding positional argument is removed and all arguments to the  right  of
       it are shifted one position left to occupy the released slot.  For example, given the command line

         scp -d -v -t /incoming

       the statement

         unset 1

       will reduce it to

         scp -v -t /incoming

   <b>delete</b>
       The  <b>delete</b>  statement  provides a generalization of <b>unset</b> for positional arguments.  It takes one or two
       argument indexes as arguments.  When used with one index, it provides the same  functionality  as  <b>unset</b>.
       When two indices are given, it deletes all arguments between those indices (inclusive).  For example, the
       statement

         delete 1 2

       will change the command line from the above example to

         scp -t /incoming

       Using negative indices, one can indicate arguments counting from right to left.  Thus, the following will
       delete all arguments starting from the third:

         delete 3 -1

   <b>remopt</b>
       Whereas  <b>delete</b>  and <b>unset</b> remove arguments at given positions, the <b>remopt</b> statement allows you to remove
       specific <u>command</u> <u>line</u> <u>options</u> from the command line.  This is useful to  ensure  no  potentially  harmful
       options  can  be  passed by the user.  The statement takes one or two arguments.  First argument supplies
       the short option letter.  For example, the following removes all occurrences of the <b>-A</b> option:

         remopt A

       If there is a long-option equivalent, it can be supplied as the second argument.  For example,  if  <b>--all</b>
       is an alias for <b>-A</b>, the above statement would be rewritten as:

         remopt A all

       Notice, that the initial dash or double-dash is omitted from both the short and long option designation.

       When  looking  for long option in the command line, <b>remopt</b> will recognize its possible abbreviations.  In
       the example above, eventual occurrences of <b>--al</b> will be removed as well.

       If the option takes an argument,  follow  the  first  argument  by  a  colon.   For  example,  to  remove
       occurrences of the options <b>-r</b> along with its arguments write

         remopt r:

       The long option equivalent can be specified as well, e.g.:

         remopt r: root

       This  will  recognize  all  possible  ways  of  option usage in the command line, such as: <b>-r</b> <b>ARG</b>, <b>-rARG</b>,
       <b>--root=ARG</b>, or <b>--root</b> <b>ARG</b>.  <b>-afr</b> <b>ARG</b> In each case, both the option and its argument will be  removed,  so
       that  the  modified  command  line  will  remain  valid.   Short  option  appearing  in a cluster will be
       recognized, .e.g <b>-afr</b> <b>ARG</b> will be replaced by <b>-af</b>.  Finally, if the option takes  an  optional  argument,
       follow its short letter by two colons, as in:

         remopt r:: root

   <b>insert</b>
       Arguments  can  also  be  inserted  at  arbitrary  positions.   The <b>insert</b> statement is provided for this
       purpose.  Its syntax is similar to <b>set</b>:

         <b>insert</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <u>value</u>

       and

         <b>insert</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <u>value</u> <b>~</b> <b>s/</b><u>regex</u><b>/</b><u>replace</u><b>/</b>

       where <u>N</u> is the position where to insert the new argument. All arguments starting from <u>N</u>th will be shifted
       one position to the right, and the <u>value</u> will be stored in the <u>N</u>th slot.  In the second form,  the  value
       to be inserted is computed by applying the replacement expression to <u>value</u>.

</pre><h4><b>REFERENCE:</b> <b>LEXICAL</b> <b>STRUCTURE</b></h4><pre>
       A <u>statement</u> consists of a keyword and arguments, separated by any amount of whitespace.  Arguments can be
       one of the following:

       <u>Identifiers</u>
              Identifiers  begin  with  a  letter  and consist of letters, digits, underscores and dashes.  They
              serve as keywords and variable names.

       <u>Decimal</u> <u>numbers</u>
              A sequence of decimal digits, optionally preceded by a minus or plus sign.

       <u>Unquoted</u> <u>strings</u>
              An unquoted string is any contiguous sequence of any characters, except newlines,  whitespace  and
              the following special characters: <b>\</b>, <b>"</b>, <b>!</b>, <b>=</b>, <b>&lt;</b>, <b>&gt;</b>, <b>(</b>, <b>)</b>, <b>{</b>, <b>}</b>, <b>[</b>, <b>]</b>, <b>$</b>, <b>%</b>, <b>&amp;</b>, <b>|</b>, <b>~</b>, <b>#</b>.

       <u>Quoted</u> <u>strings</u>
              A quoted string is a sequence of characters enclosed in double-quotes.  Quoted strings are subject
              to backslash interpretation, backreference interpretation and variable expansion.

              During  <u>backslash</u>  <u>interpretation</u>,  the  <u>escape</u> <u>sequences</u> are recognized and replaced as per table
              below:

                      <u>Sequence</u>    <u>Replaced</u> <u>with</u>
                      \a          Audible bell character (ASCII 7)
                      \b          Backspace character (ASCII 8)
                      \f          Form-feed character (ASCII 12)
                      \n          Newline character (ASCII 10)
                      \r          Carriage return character (ASCII 13)
                      \t          Horizontal tabulation character (ASCII 9)
                      \v          Vertical tabulation character (ASCII 11)
                      \\          A single backslash
                      \"          A double-quote.
                      \%          Percent sign

              In addition, the sequence <b>\</b><u>newline</u> is removed from the string.  This allows splitting long strings
              over several physical lines.

              During the <u>backreference</u> <u>interpretation</u>, references to parenthesized groups in regular  expression
              are  replaced  with  the  actual  content  of the corresponding group in the most recently matched
              string.  A reference is <b>%{</b><u>N</u><b>}</b> where <u>N</u> is a decimal number.  If <u>N</u> is one digit, curly braces can  be
              omitted:  <b>%</b><u>N</u>  If the <b>%</b> character resulted from previous backslash interpretation, no backreference
              interpretation occurs.

              Strings used in the left-hand side of a comparison expression are subject to  variable  expansion.
              This is discussed later.

       <u>Backreferences</u>
              The construct <b>%{</b><u>N</u><b>}</b> is replaced with the substring that matched the <u>N</u>th parenthesized subgroup in a
              most recently performed regular expression match.  If <u>N</u> is one digit, curly braces can be omitted.

       <u>Variable</u> <u>references</u>
              Variable  references  consist  of a <b>$</b> sign, followed by the positional argument number or variable
              name, optionally enclosed in curly braces.  Positional arguments greater than 9 must  be  enclosed
              in  curly  braces.   The  variable name must follow the rules for valid identifiers: it must begin
              with a letter and consist of letters, digits and underscores.  Variable name in curly  braces  can
              be followed by <b>-</b>, <b>=</b>, <b>?</b>, or <b>+</b>, optionally preceded by <b>:</b> as summarized in the table below:

                      <u>Reference</u>             <u>Meaning</u>
                      ${<u>VAR</u>:-<u>WORD</u>}          Use Default Values
                      ${<u>VAR</u>:=<u>WORD</u>}          Assign Default Values
                      ${<u>VAR</u>:?<u>WORD</u>}          Display Error if Null or Unset
                      ${<u>VAR</u>:+<u>WORD</u>}          Use Alternate Value

              where  <u>WORD</u>  stands  for any valid token as described in this section.  See the section <b>REFERENCE:</b>
              <b>VARIABLE</b> <b>EXPANSION</b>, for a detailed discussion of these forms and their meaning.

       <u>Comparison</u> <u>and</u> <u>boolean</u> <u>operators</u>

                      &amp;&amp;                    Boolean AND
                      ||                    Boolean OR
                      !                     Boolean negation
                      ==                    Equality (string or numeric)
                      !=                    Inequality (string or numeric)
                      &lt;                     Less than
                      &lt;=                    Less than or equal to
                      &gt;                     Greater than
                      &gt;=                    Greater than or equal to
                      ~                     Regexp matching
                      !~                    Negated regexp matching
                      in                    Membership in set of strings
                      group                 Membership in UNIX group
                      =                     Assignment
                      =~                    Regular expression substitution

</pre><h4><b>REFERENCE:</b> <b>VARIABLE</b> <b>EXPANSION</b></h4><pre>
       Most statements in the configuration file undergo variable expansion prior to their use.  During variable
       expansion, references to variables in the string are replaced  with  their  actual  values.   A  variable
       reference has two basic forms:

         $V
         ${V}

       where  <u>V</u>  is either the name of the variable (request, environment, or user-defined), or the index of the
       positional variable.  The notation in curly braces serves several purposes.  First, it is obligatory if <u>V</u>
       is an index of the positional variable that is negative or greater than 9.  Secondly, it should  be  used
       if  the  variable  reference  is  immediately followed by an alphanumeric symbol, which will otherwise be
       considered part of it (as in <b>${home}dir</b>).  Finally, this form allows for specifying the action to take if
       the variable is undefined or expands to an empty value.

       The following special forms are recognized:

       <b>${</b><u>VARIABLE</u><b>:-</b><u>WORD</u><b>}</b>
              <u>Use</u> <u>Default</u> <u>Values</u>.  If <u>VARIABLE</u>  is  unset  or  null,  the  expansion  of  <u>WORD</u>  is  substituted.
              Otherwise, the value of <u>VARIABLE</u> is substituted.

       <b>${</b><u>VARIABLE</u><b>:=</b><u>WORD</u><b>}</b>
              <u>Assign</u>  <u>Default</u>  <u>Values</u>.   If  <u>VARIABLE</u> is unset or null, the expansion of <u>WORD</u> is assigned to the
              variable.  The value of <u>VARIABLE</u> is then substituted.

       <b>${</b><u>VARIABLE</u><b>:?</b><u>WORD</u><b>}</b>
              <u>Display</u> <u>Error</u> <u>if</u> <u>Null</u> <u>or</u> <u>Unset</u>.  If <u>VARIABLE</u> is null or unset, the expansion of <u>WORD</u> (or a message
              to that effect if <u>WORD</u> is not present) is output to the current logging channel.   Otherwise,  the
              value of <u>VARIABLE</u> is substituted.

       <b>${</b><u>VARIABLE</u><b>:+</b><u>WORD</u><b>}</b>
              <u>Use</u>  <u>Alternate</u>  <u>Value</u>.   If  <u>VARIABLE</u>  is  null  or  unset,  nothing is substituted, otherwise the
              expansion of <u>WORD</u> is substituted.

</pre><h4><b>REFERENCE:</b> <b>STATEMENTS</b></h4><pre>
       There are three global statements, two of which can contain multiple substatements:

       <b>rush</b> <b>2.0</b>
              Declares the version of the syntax this configuration file is written in.  This must be the  first
              statement in the configuration file.  If this statement is missing, the configuration file will be
              treated  as  <u>legacy</u>  <u>configuration</u> <u>file</u> from previous versions of <b>GNU</b> <b>rush</b>.  For the discussion of
              the legacy configuration file, please refer to <b><a href="http://www.gnu.org.ua/software/rush/manual/1.x">http://www.gnu.org.ua/software/rush/manual/1.x</a></b>.

       <b>global</b> Defines global settings.

       <b>rule</b> [<u>TAG</u>]
              Contains a set of rules for a certain class of input command lines.

   <b>global</b>
       Introduces global settings.  This statement is followed by one or more  substatements.   Global  settings
       end at the nearest <b>rule</b> statement that follows.  They remain in effect until the next <b>global</b> statement is
       encountered which alters them.

       The following statements may appear in this section.

       <b>expand-undefined</b> <u>BOOL</u>
              Controls how undefined variables are expanded.  If <u>BOOL</u> is <b>true</b>, references to undefined variables
              are  replaced  with  empty  values.   If it is <b>false</b> (the default), an error message is issued and
              program terminates.

              Any of the following values can be used as a synonym for <b>true</b>: <b>yes</b>, <b>on</b>, <b>t</b>, <b>1</b>.

              The following values can be used as synonyms for <b>false</b>: <b>no</b>, <b>off</b>, <b>nil</b>, <b>0</b>.

       <b>debug</b> <u>NUM</u>
              Set debugging level.  The bigger  <u>NUM</u>  is,  the  more  verbose  is  the  logging.   The  debugging
              information is reported via <b>syslog</b> at facility <b>authpriv</b>, priority <b>debug</b>.

       <b>sleep-time</b> <u>NUM</u>
              Set the time in seconds to sleep before exiting on error.  This statement is intended as a measure
              against brute-force attacks.  Default sleep time is 5 seconds.

       <b>message</b> <u>CLASS</u> <u>TEXT</u>
              Define  a  textual  message  which  is returned to the remote party if an error of the given <u>CLASS</u>
              occurs.  Valid classes are:

           <b>usage-error</b>
                  This error is reported when <b>rush</b> has been invoked improperly.  The default text is:

                  <b>"You</b> <b>are</b> <b>not</b> <b>permitted</b> <b>to</b> <b>execute</b> <b>this</b> <b>command."</b>

           <b>nologin-error</b>
                  A message which is returned if there is no such user name in the password database.   Defaults
                  to:

                  <b>"You</b> <b>are</b> <b>not</b> <b>permitted</b> <b>to</b> <b>execute</b> <b>this</b> <b>command."</b>

           <b>config-error</b>
                  Define  a  textual  message  which  is  returned  if  the configuration file contained errors.
                  Default is:

                  <b>"Local</b> <b>configuration</b> <b>error</b> <b>occurred."</b>

           <b>system-error</b>
                  Define a textual message which is returned if a system error occurs.  Default is:

                  <b>"A</b> <b>system</b> <b>error</b> <b>occurred</b> <b>while</b> <b>attempting</b> <b>to</b> <b>execute</b> <b>command."</b>

       <b>regexp</b> <u>FLAG</u> [<u>FLAG</u>...]
              Configure the type of regular expressions  to  be  used  by  subsequent  <b>match</b>,  <b>set</b>,  and  <b>insert</b>
              statements.  Each <u>FLAG</u> is a word specifying a regular expression feature.  It can be preceded by a
              plus sing to enable this feature (this is the default), or by the minus sign to disable it.  Valid
              flags are:

           <b>extended</b>
                  Use POSIX Extended Regular Expression syntax when interpreting regex.  This is the default.

           <b>basic</b>  Use basic regular expressions.  Equivalent to <b>-extended</b>.

           <b>icase</b> or <b>ignore-case</b>
                  Do not differentiate case.  Subsequent regex matches will be case insensitive.

       <b>include-security</b> <u>FLAG</u> [<u>FLAG</u>...]
              Configure the security checks for include files.  Valid flags are:

           <b>all</b>    Enable all checks.

           <b>owner</b>  The file must be owned by root.

           <b>iwgrp</b> or <b>groupwritablefile</b>
                  Forbid group writable files.

           <b>iwoth</b> or <b>worldwritablefile</b>
                  Forbid world writable files.

           <b>dir_iwgrp</b> or <b>groupwritabledir</b>
                  Forbid files that reside in group writable directories.

           <b>dir_iwoth</b> or <b>worldwritabledir</b>
                  Forbid files that reside in world writable directories.

           <b>link</b>   Forbid symbolic links to files residing in group or world writable directories.

       Each  of  the above keywords can be prefixed by <b>no</b>, which reverses its meaning.  The special keyword <b>none</b>
       disables all checks.

       <b>acct-umask</b> <u>MASK</u>
              Set umask used when accessing accounting database files.  Default value is 022.

       <b>acct-dir-mode</b> <u>MODE</u>
              Set mode bits for the accounting directory.  The argument is the mode in octal.

       <b>acct-file-mode</b> <u>MODE</u>
              Set mode bits for the <b>wtmp</b> and <b>utmp</b> files.

   <b>rule</b>
       Defines a rule.  This is a block statement, which means that all statements located between  it  and  the
       next <b>rule</b> statement (or end of file, whichever occurs first) modify the definition of that rule.

       The syntax is:

         rule <b>TAG</b>

       Optional  <b>TAG</b> argument supplies the identifier for that rule.  It is used in diagnostic messages.  If tag
       is missing, <b>rush</b> will supply a default one, which is constructed by concatenating the <b>#</b> character and the
       ordinal number of rule in the configuration file, in decimal notation.  Rule numbering starts from 1.

       A rule can contain the following statements:

       <b>match</b> <u>EXPR</u>
              Defines conditions that decide whether the rule matches the particular request.  The <u>EXPR</u> argument
              is a comparison expression.  It can be a simple comparison  expression  or  a  boolean  expression
              involving several other expressions.

              A  simple  expression  is  either a comparison or a membership test.  A comparison has the general
              syntax

                <u>lhs</u> <u>op</u> <u>rhs</u>

              where <u>lhs</u> and <u>rhs</u> are operands and <u>op</u> is the operation.  The <u>lhs</u> is either  a  string  (quoted  or
              unquoted),  or  a  variable reference.  The <u>rhs</u> is a string or number.  Prior to evaluating simple
              expression, its <u>LHS</u> undergoes variable expansion.  In contrast, the <u>RHS</u> operand is always  treated
              verbatim.

              The comparison operator <u>OP</u> is one of the following:

                      ==                    Equality (string or numeric)
                      !=                    Inequality (string or numeric)
                      &lt;                     Less than
                      &lt;=                    Less than or equal to
                      &gt;                     Greater than
                      &gt;=                    Greater than or equal to
                      ~                     Regexp matching
                      !~                    Negated regexp matching

              Two membership tests are available.  The <b>in</b> test has the form

                <u>LHS</u> <b>in</b> ( <u>STRING</u> ... )

              and  evaluates  to  true if <u>LHS</u> matches one of the strings in parentheses.  <u>LHS</u> undergoes variable
              expansion and backreference interpretation prior to comparison.

              The <b>group</b> test has the following syntax:

                <b>group</b> <u>GRP</u>

              It returns true if the requesting user is a member of the group <u>GRP</u>.  Several groups can be  given
              in parentheses:

                <b>group</b> <b>(</b><u>GRP</u> ...<b>)</b>

              in  which  case  the  test  return  true  if the user is a member of at least one of the mentioned
              groups.

              Compound boolean expression combine one or more expressions using logical operators

                      &amp;&amp;                    Boolean AND
                      ||                    Boolean OR
                      !                     Boolean negation

       <b>set</b> <u>NAME</u> <b>=</b> <u>VALUE</u>
              Sets the variable <u>NAME</u>  to  <u>VALUE</u>,  which  undergoes  backreference  interpretation  and  variable
              expansion.

       <b>set</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <u>VALUE</u>
              Sets the command line argument <u>N</u> to <u>VALUE</u>

       <b>set</b> <u>NAME</u> <b>=</b> <u>VALUE</u> <b>~</b> <u>S-EXPR</u>
              Applies  the  <b><a href="../man1/sed.1.html">sed</a></b>(1)-like  search-and-replace expression <b>S-EXPR</b> to <u>VALUE</u> and assigns the result to
              the variable <b>NAME</b>.  Both <b>VALUE</b> and <b>S-EXPR</b> are subject  to  variable  expansion  and  backreference
              interpretation.

       <b>set</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <u>VALUE</u> <b>~</b> <u>S-EXPR</u>
              Similar to the above, but assigns the result to the <u>N</u>th command line argument.

       <b>set</b> <u>NAME</u> <b>=~</b> <u>S-EXPR</u>
              This is a shortcut for

                <b>set</b> <u>NAME</u> <b>=</b> <b>$</b><u>NAME</u> <b>~</b> <u>S-EXPR</u>

              i.e. it applies the search-and-replace expression <u>S-EXPR</u> to the current value of the variable <u>NAME</u>
              and stores the resulting string as its new value.

       <b>set</b> <b>[</b><u>N</u><b>]</b> <b>=~</b> <u>S-EXPR</u>
              A shortcut for

                <b>set</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <b>$</b><u>N</u> <b>~</b> <u>S-EXPR</u>

       The <u>S-EXPR</u>, is a sed replace expression of the form:

         <b>s/</b><u>REGEXP</u><b>/</b><u>REPLACE</u><b>/</b>[<u>FLAGS</u>]

       where  <b>REGEXP</b>  is  a regular expression, <u>REPLACE</u> is a replacement for each part of the input that matches
       <u>REGEXP</u> and optional <u>FLAGS</u> are flag letters that control the substitution.  Both <u>REGEXP</u>  and  <u>REPLACE</u>  are
       described in <b><a href="../man1/sed.1.html">sed</a></b>(1)<b>.</b>

       As in <b>sed</b>, you can give several replace expressions, separated by semicolons.

       The supported <u>FLAGS</u> are:

       <b>g</b>      Apply the replacement to all matches to the <u>REGEXP</u>, not just the first.

       <b>i</b>      Use case-insensitive matching.

       <b>x</b>      <u>REGEXP</u> is an extended regular expression.

       <u>NUMBER</u> Only replace the <u>NUMBER</u>th match of the <u>REGEXP</u>.

       Notice,  that  the  POSIX  standard  does  not  specify  what should happen when you mix the <b>g</b> and <u>NUMBER</u>
       modifiers.  <b>Rush</b> follows the GNU <b>sed</b> implementation in this regard, so the interaction is defined to  be:
       ignore matches before the <u>NUMBER</u>th, and then match and replace all matches from the <u>NUMBER</u>th on.

       Also  notice,  that  usually  <u>S-EXPR</u>  is  a  quoted  string,  and  as  such  it  is  subject to backslash
       interpretation.  It is therefore important to properly escape  backslashes,  especially  in  the  <u>REPLACE</u>
       part.  E.g.

         set bindir = $program ~ "s/(.*)\\//\\1/"

       <b>insert</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <u>VALUE</u>
              Shift  command  line  arguments starting from the <u>N</u>th one position to the right and store <u>VALUE</u> in
              the <u>N</u>th slot. <u>VALUE</u> is subject to variable expansion and backreference interpretation.

       <b>insert</b> <b>[</b><u>N</u><b>]</b> <b>=</b> <u>VALUE</u> <b>~</b> <u>S-EXPR</u>
              Shift command line arguments starting from the <u>N</u>th one position to  the  right,  apply  <u>S-EXPR</u>  to
              <u>VALUE</u>  and  store  the  result  in  the  <u>N</u>th  slot.  Both <u>S-EXPR</u> and <u>VALUE</u> are subject to variable
              expansion and backreference interpretation.

       <b>unset</b> <u>NAME</u>
              Unset the variable <u>NAME</u>.

       <b>unset</b> <u>N</u>
              Unset the positional argument <u>N</u> (an  integer  number  greater  than  0),  shifting  the  remaining
              arguments one position left.  This is the same as <b>delete</b> <u>N</u>.

       <b>remopt</b> <u>SOPT</u>
              Remove  from  the  command  line  all occurrences of the short option described by <u>SOPT</u>.  The <u>SOPT</u>
              argument is the short option letter, optionally followed  by  a  colon  if  that  option  takes  a
              mandatory argument, or by two colons if it takes an optional argument.

       <b>remopt</b> <u>SOPT</u> <u>LOPT</u>
              Same  as  the  above.   <u>LOPT</u> supplies the long option equivalent for the short option described by
              <u>SOPT</u>.

       <b>delete</b> <u>N</u>
              Delete <b>N</b>th argument.

       <b>delete</b> <u>I</u> <u>J</u>
              Delete arguments between <u>I</u> and <u>J</u>, inclusive.

       <b>map</b> <u>NAME</u> <u>FILE</u> <u>DELIM</u> <u>KEY</u> <u>KN</u> <u>VN</u>
              This statement uses file lookup to find a new value for the  variable  <u>NAME</u>.   The  <u>FILE</u>  argument
              supplies  the name of the <u>map</u> <u>file</u>.  It must begin with <b>/</b> or <b>~/</b>.  Before use, the file permissions
              and ownership are checked using the criteria supplied in the <b>include-security</b> statement  (see  the
              <b>global</b> section).

              The map file consists of <u>records</u>, separated by newline characters.  Each record, in turn, consists
              of  fields,  separated  by  characters  listed  in  the  <u>DELIM</u>  argument.   If it contains a space
              character, then fields may be delimited by any amount  of  whitespace  characters  (spaces  and/or
              tabulations).   Otherwise,  exactly  one  character  delimits  fields.  Fields within a record are
              numbered starting from 1.

              The <b>map</b> action operates as follows.  First, variable expansion and backreference interpretation is
              performed on the <u>KEY</u> argument.  The result will be used as  actual  lookup  key.   Then,  <u>FILE</u>  is
              scanned  for  a  record  whose  <u>KN</u>th field matches the lookup key.  If such a record is found, the
              value of its <u>VN</u>th field is assigned to the variable.  Otherwise, if <u>DEFAULT</u>  is  supplied,  it  is
              assigned to the variable.  Otherwise, the variable remains unchanged.

       <b>map</b> <b>[</b><u>N</u><b>]</b> <u>FILE</u> <u>DELIM</u> <u>KEY</u> <u>KN</u> <u>VN</u> <u>DEFAULT</u>
              Same as above, but the result of the lookup is assigned to <u>N</u>th argument.

       The following statements modify command execution environment:

       <b>clrenv</b> Clear the environment.

       <b>keepenv</b> <u>NAME</u> ...
              Retain the listed variables.  This statement should be used in conjunction with <b>clrenv</b>.

              Argument  is  a whitespace delimited list of variables to retain.  Each element in the list can be
              either a variable name, or a shell-style globbing pattern, in which case  all  variables  matching
              that pattern will be retained, or a variable name followed by an equals sign and a value, in which
              case it will be retained only if its actual value equals the supplied one.  For example, to retain
              only variables with names beginning with 'LC_':

                keepenv "LC_*"

       <b>setenv</b> <u>NAME</u> <b>=</b> <u>VALUE</u>
              Set  the  environment  variable  <u>NAME</u>.   The  <u>VALUE</u>  argument is subject to variable expansion and
              backreference interpretation.

              For example, to modify the 'PATH' value:

                setenv PATH = "$PATH:/opt/bin"

       <b>unsetenv</b> <u>NAME</u> ...
              Unset environment variables.  See <b>keepenv</b> for a discussion of arguments.

       <b>evalenv</b> <u>STRING</u>
              Performs backslash interpretation, backreference interpretation and variable expansion  on  <u>STRING</u>
              and discards the result.  This statement is similar to the shell's "colon" statement.

       The following statements are <u>system</u> <u>actions</u>.  They provide interface to the operating system.

       <b>umask</b> <u>MASK</u>
              Set the umask.  The <u>MASK</u> must be an octal value not greater than 0777.  The default umask is 022.

       <b>newgrp</b> <u>GROUP-ID</u>
              Change  the current group ID to <u>GROUP-ID</u>, which is either a numeric value or a name of an existing
              group.

       <b>newgroup</b> <u>GROUP-ID</u>
              Alias to the above.

       <b>chroot</b> <u>DIR</u>
              Change the root directory to <u>DIR</u>.  The argument is subject to tilde and  variable  expansions  and
              backreference  interpretation.  During tilde expansion, a tilde at the start of string is replaced
              with the absolute pathname of the user's home directory.

       <b>chdir</b> <u>DIR</u>
              Change to the directory <u>DIR</u>.  The argument  is  subject  to  tilde  and  variable  expansions  and
              backreference interpretation.  If both <b>chdir</b> and <b>chroot</b> are specified, <b>chroot</b> is applied first.

       <b>limits</b> <u>RES</u>
              Impose  limits  on  system  resources,  as  defined  by  <u>RES</u>.   The argument consists of <u>commands</u>,
              optionally separated by any amount of whitespace.  A command is a single command  letter  followed
              by a number, that specifies the limit.  The command letters are case-insensitive and coincide with
              those used by the shell <b>ulimit</b> utility:

           <b>A</b>      max address space (KB)

           <b>C</b>      max core file size (KB)

           <b>D</b>      max data size (KB)

           <b>F</b>      maximum file size (KB)

           <b>M</b>      max locked-in-memory address space (KB)

           <b>N</b>      max number of open files

           <b>R</b>      max resident set size (KB)

           <b>S</b>      max stack size (KB)

           <b>T</b>      max CPU time (MIN)

           <b>U</b>      max number of processes

           <b>L</b>      max number of logins for this user (see below)

           <b>P</b>      process priority -20..20 (negative = high priority)

       If some limit cannot be set, execution of the rule aborts.  In particular, the <b>L</b> limit can be regarded as
       a  condition, rather than an action.  Setting <b>limit</b> <b>L5</b> succeeds only if no more than 5 <b>rush</b> instances are
       simultaneously running for the same user.  This can be used to limit the number  of  simultaneously  open
       sessions.

       The  use  of <b>L</b> resource automatically enables <u>forked</u> <u>mode</u>.  See the subsection <b>Accounting</b> <b>and</b> <b>forked</b> <b>mode</b>
       for details.

       <b>fall-through</b> or <b>fallthrough</b>
              Declare a fall-through rule.  After evaluating such a rule, <b>rush</b> continues rule  matching  process
              from  the  next  rule  in  the configuration.  Any modifications to the request found in the fall-
              through rule take effect immediately, which means that subsequent rules will see modified  command
              line  and  environment.   Execution of any other actions found in the fall-through rule is delayed
              until a matching rule is found.

              Fall-through rules are often used to set default values for subsequent rules.

   <b>Accounting</b> <b>and</b> <b>forked</b> <b>mode</b>
       GNU <b>rush</b> is able to operate in two modes, which we call  default  and  forked.   When  operating  in  the
       default  mode, the process image of <b>rush</b> itself is overwritten by the command being executed.  Thus, when
       it comes to launching the requested command, the running instance of <b>rush</b> ceases to exist.

       There is also another operation mode, which we call  <u>forked</u>  <u>mode</u>.   When  running  in  this  mode,  <b>rush</b>
       executes  the  requested  command in a subprocess, and remains in memory supervising its execution.  Once
       the command terminates, <b>rush</b> exits.

       One advantage of the forked mode is that it allows you to keep <u>accounting</u>, i.e.  to  note  who  is  doing
       what  and  to  keep a history of invocations.  The accounting, in turn, can be used to limit simultaneous
       executions of commands, as requested by the <b>L</b> command to <b>limit</b> statement (see above).

       <b>acct</b> <u>BOOL</u>
              Turn accounting mode on or off, depending on <u>BOOL</u>.  The argument can be one of the following: <b>yes</b>,
              <b>on</b>, <b>t</b>, <b>true</b>, or <b>1</b>, to enable accounting, and <b>no</b>, <b>off</b>, <b>nil</b>, <b>false</b>, <b>0</b>, to disable it.

       <b>fork</b> <u>BOOL</u>
              Enable or disable forked mode.  See <b>acct</b> for a description of <u>BOOL</u>.  Enabling accounting turns the
              fork mode as well.  This statement is mainly designed as a way of disabling the forked mode for  a
              given rule.

   <b>Post-process</b> <b>notification</b>
       <b>Rush</b>  can  be configured to send a <u>notification</u> over INET or UNIX sockets, after completing user request.
       It is done using the following statement:

       <b>post-socket</b> <u>URL</u>
              Notify <u>URL</u> about completing the user request.  This statement implies forked mode.

       Allowed formats for <u>URL</u> are:

       <b>inet://</b><u>HOSTNAME</u>[<b>:</b><u>PORT</u>]
              Connect to remote host <u>HOSTNAME</u> using TCP/IP.  <u>HOSTNAME</u> is the host name  or  IP  address  of  the
              remote  machine.   Optional  <u>PORT</u>  specifies  the  port  number to connect to.  It can be either a
              decimal port number or a service name from <b><a href="file:/etc/services">/etc/services</a></b>.  If <u>PORT</u> is absent, <b>tcpmux</b> (port  1)  is
              assumed.

       <b>unix://</b><u>FILENAME</u> or <b>local://</b><u>FILENAME</u>
              Connect to a UNIX socket <u>FILENAME</u>.

       The  notification  protocol is based on TCPMUX (RFC 1078).  After establishing connection, <b>rush</b> sends the
       rule tag followed by a CRLF pair.  The rule tag acts as a service name.  The remote party replies with  a
       single character indicating positive (<b>+</b>) or negative (<b>-</b>) acknowledgment, optionally followed by a message
       of explanation, and terminated with a CRLF.

       If  positive  acknowledgment  is  received, <b>rush</b> sends a single line, consisting of the user name and the
       executed command line, separated by a single space character.  The line is terminated with a CRLF.

       After sending this line, <b>rush</b> closes the connection.

       The post-process notification feature can be used to schedule execution of  some  actions  after  certain
       rules.

   <b>Exit</b> <b>rule</b>
       <b>exit</b> <u>FD</u> <u>TEXT</u>
              Write textual message <u>TEXT</u> to file descriptor <u>FD</u>.

       <b>exit</b> <u>TEXT</u>
              Write textual message <u>TEXT</u> to standard error.  Similar to

                <b>exit</b> <b>2</b> <u>TEXT</u>

              In both cases the <u>TEXT</u> argument can be either a quoted string, or an identifier.

       If it is a quoted string, it is subject to backreference interpretation and variable expansion.

       If  <u>TEXT</u>  is  an  identifier,  it  must  be  the  name of a predefined error message (see the list in the
       discussion of the <b>message</b> statement in <b>global</b> section, above).

   <b>Interactive</b> <b>access</b>
       Sometimes it may be necessary to allow some group of users limited access  to  interactive  shells.   GNU
       <b>rush</b>  contains  provisions for such usage.  When it is invoked without '-c' it assumes interactive usage.
       In this case only rules explicitly marked as interactive are considered, the rest of rules is ignored.

       <b>interactive</b> <u>BOOL</u>
              If BOOL is true (see the <b>acct</b> statement above for allowed values), this statement marks  the  rule
              it  appears  in as interactive.  This rule will match only if <b>rush</b> is invoked without command line
              arguments.

       Unless command line transformations are applied, interactive rule finishes  by  executing  <b><a href="file:/bin/sh">/bin/sh</a></b>.   The
       first  word  in the command line (<b>argv[0]</b>) is normally set to the base name of the command being executed
       prefixed by a minus character.

       An example

         rule login
           interactive true
           group rshell
           map program /etc/rush.shell : ${user} 1 2
           set [0] = ${program} ~ "s|^.*/||;s,^,-r,"

         rule nologin
           interactive true
           exit You don't have interactive access to this machine.

       The <b>login</b> rule will match interactive user requests if the user is a member  of  the  group  <b>rshell</b>.   It
       looks  up  the  shell to use for this in the file <b>/etc/rush.shell</b>.  This map file consists of two fields,
       separated by a colon.  If the shell is found, its base name, prefixed with <b>-r</b>, will be  used  as  <b>argv[0]</b>
       (this  indicates a restricted login shell).  Otherwise, the trap rule <b>nologin</b> will be matched, which will
       output the given diagnostics message and terminate <b>rush</b>.

   <b>Localization</b>
       The following statement allow you to provide translations (localizations) for the messages in  your  <b>rush</b>
       configuration:

       <b>locale</b> <u>NAME</u>
              Set the locale name.  To specify empty locale, use "" as <u>NAME</u> (recall that empty locale name means
              to use the value of the environment variable 'LC_ALL' as locale name).

       <b>locale-dir</b> <u>NAME</u>
              Set the name of the locale directory.

       <b>text-domain</b> <u>NAME</u>
              Set the textual domain name.

       An example:

         rule l10n
           locale "pl_PL"
           text-domain "rush-config"
           fall-through

   <b>include</b>
       The <b>include</b> statement forces inclusion of the named file in that file location:

       <b>include</b> <u>FILE</u>

       The  statement  is  evaluated  when  parsing the configuration file, which means that <u>FILE</u> undergoes only
       tilde expansion: the two characters <b>~/</b> appearing at the beginning of file name are replaced with the full
       path name of the current user's home directory.

       If <u>FILE</u> is a directory, that directory is searched for a file whose name coincides with the current  user
       name.  If such a file is found, it is included.

       In  any  case,  if  the named file does not exist, no error is reported, and parsing of the configuration
       file continues.

       Before including the file <b>rush</b> checks if it is secure, using the criteria  set  in  the  <b>include-security</b>
       statement.  See its description in the <b>global</b> section, above.

       The  <b>include</b> statement can be used only within a rule.  The included file may not contain <b>rule</b> and <b>global</b>
       statements.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/rush.8.html">rush</a></b>(8), <b><a href="../man1/rushlast.1.html">rushlast</a></b>(1), <b><a href="../man1/rushwho.1.html">rushwho</a></b>(1).

</pre><h4><b>AUTHORS</b></h4><pre>
       Sergey Poznyakoff

</pre><h4><b>BUG</b> <b>REPORTS</b></h4><pre>
       Report bugs to &lt;<a href="mailto:bug-rush@gnu.org.ua">bug-rush@gnu.org.ua</a>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  2016-2019 Sergey Poznyakoff
       License GPLv3+: GNU GPL version 3 or later &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;
       This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to  the  extent
       permitted by law.

RUSH.RC                                           July 1, 2019                                        <u><a href="../man5/RUSH.RC.5.html">RUSH.RC</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>