<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>terminfo - terminal capability database</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ncurses-bin">ncurses-bin_6.5+20250216-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>terminfo</b> - terminal capability database

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <a href="file:/etc/terminfo/">/etc/terminfo/</a>*/*

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Terminfo</u>  is  a  database describing terminals, used by screen-oriented programs such as <b><a href="../man1/nvi.1.html">nvi</a></b>(1), <b><a href="../man1/lynx.1.html">lynx</a></b>(1),
       <b><a href="../man1/mutt.1.html">mutt</a></b>(1), and other curses applications, using high-level calls to libraries  such  as  <b><a href="../man3NCURSES/ncurses.3NCURSES.html">ncurses</a></b>(3NCURSES).
       It  is  also  used  via  low-level calls by non-curses applications which may be screen-oriented (such as
       <b><a href="../man1/clear.1.html">clear</a></b>(1)) or non-screen (such as <b><a href="../man1/tabs.1.html">tabs</a></b>(1)).

       <u>Terminfo</u> describes terminals by giving a set of capabilities  which  they  have,  by  specifying  how  to
       perform screen operations, and by specifying padding requirements and initialization sequences.

       This document describes <u>ncurses</u> version 6.5 (patch 20250216).

   <u><b>terminfo</b></u> <b>Entry</b> <b>Syntax</b>
       Entries in <u>terminfo</u> consist of a sequence of fields:

       •   Each  field  ends  with  a  comma  “,” (embedded commas may be escaped with a backslash or written as
           “\054”).

       •   White space between fields is ignored.

       •   The first field in a <u>terminfo</u> entry begins in the first column.

       •   Newlines and leading whitespace (spaces or tabs) may be used for formatting entries for  readability.
           These are removed from parsed entries.

           The  <b>infocmp</b> <b>-f</b> and <b>-W</b> options rely on this to format if-then-else expressions, or to enforce maximum
           line-width.  The resulting formatted terminal description can be read by <b>tic</b>.

       •   The first field for each terminal gives the names which are known for the terminal, separated by  “|”
           characters.

           The  first  name  given is the most common abbreviation for the terminal (its primary name), the last
           name given should be a long name fully identifying the terminal  (see  <b><a href="../man3NCURSES/longname.3NCURSES.html">longname</a></b>(3NCURSES)),  and  all
           others are treated as synonyms (aliases) for the primary terminal name.

           X/Open  Curses advises that all names but the last should be in lower case and contain no blanks; the
           last name may well contain upper case and blanks for readability.

           This implementation is not so strict; it allows mixed case in the primary name and aliases.   If  the
           last  name  has  no  embedded blanks, it allows that to be both an alias and a verbose name (but will
           warn about this ambiguity).

       •   Lines beginning with a “#” in the first column are treated as comments.

           While comment lines are valid at any point, the output of <b>captoinfo</b> and <b>infotocap</b> (aliases  for  <b>tic</b>)
           will move comments so they occur only between entries.

       Terminal  names  (except  for  the last, verbose entry) should be chosen using the following conventions.
       The particular piece of hardware making up the terminal should have a root  name,  thus  “hp2621”.   This
       name  should  not  contain  hyphens.   Modes  that the hardware can be in, or user preferences, should be
       indicated by appending a hyphen and a mode suffix.  Thus, a vt100 in 132-column mode  would  be  vt100-w.
       The following suffixes should be used where possible:

       <b>Suffix</b>   <b>Example</b>     <b>Meaning</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       -<u>nn</u>      aaa-60      Number of lines on the screen
       -<u>n</u>p      c100-4p     Number of pages of memory
       -am      vt100-am    With automargins (usually the default)
       -m       ansi-m      Mono mode; suppress color
       -mc      wy30-mc     Magic cookie; spaces when highlighting
       -na      c100-na     No arrow keys (leave them in local)
       -nam     vt100-nam   Without automatic margins
       -nl      hp2621-nl   No status line
       -ns      hp2626-ns   No status line
       -rv      c100-rv     Reverse video
       -s       vt100-s     Enable status line
       -vb      wy370-vb    Use visible bell instead of beep
       -w       vt100-w     Wide mode (&gt; 80 columns, usually 132)

       For more on terminal naming conventions, see the <b><a href="../man7/term.7.html">term</a></b>(7) manual page.

   <u><b>terminfo</b></u> <b>Capabilities</b> <b>Syntax</b>
       The terminfo entry consists of several <u>capabilities</u>, i.e., features that the terminal has, or methods for
       exercising the terminal's features.

       After  the first field (giving the name(s) of the terminal entry), there should be one or more <u>capability</u>
       fields.  These are Boolean, numeric or string names with corresponding values:

       •   Boolean capabilities are true when present, false when  absent.   There  is  no  explicit  value  for
           Boolean capabilities.

       •   Numeric capabilities have a “#” following the name, then an unsigned decimal integer value.

       •   String  capabilities  have  a  “=”  following  the  name,  then an string of characters making up the
           capability value.

           String capabilities can be split into multiple lines, just as the fields comprising a terminal  entry
           can  be split into multiple lines.  While blanks between fields are ignored, blanks embedded within a
           string value are retained, except for leading blanks on a line.

       Any capability can be <u>canceled</u>, i.e., suppressed from the terminal entry, by following its name with  “@”
       rather than a capability value.

   <b>Similar</b> <b>Terminals</b>
       If  there  are  two very similar terminals, one (the variant) can be defined as being just like the other
       (the base) with certain exceptions.  In the definition of the variant, the string capability <b>use</b>  can  be
       given with the name of the base terminal:

       •   The capabilities given before <b>use</b> override those in the base type named by <b>use</b>.

       •   If there are multiple <b>use</b> capabilities, they are merged in reverse order.  That is, the rightmost <b>use</b>
           reference is processed first, then the one to its left, and so forth.

       •   Capabilities given explicitly in the entry override those brought in by <b>use</b> references.

       A capability can be canceled by placing <b>xx@</b> to the left of the use reference that imports it, where <u>xx</u> is
       the capability.  For example, the entry

              2621-nl, smkx@, rmkx@, use=2621,

       defines  a  2621-nl  that  does  not  have  the <b>smkx</b> or <b>rmkx</b> capabilities, and hence does not turn on the
       function key labels when in visual mode.  This is useful for different  modes  for  a  terminal,  or  for
       different user preferences.

       An  entry  included  via  <b>use</b>  can  contain canceled capabilities, which have the same effect as if those
       cancels were inline in the using terminal entry.

   <b>Predefined</b> <b>Capabilities</b>
       Tables of capabilities <u>ncurses</u> recognizes in a <u>terminfo</u> terminal type description and available to  <u>term‐</u>
       <u>info</u>-using code follow.

       •   The capability name identifies the symbol by which the programmer using the <u>terminfo</u> API accesses the
           capability.

       •   The  TI  (<u>terminfo</u>)  code  is  the  short name used by a person composing or updating a terminal type
           entry.

           Whenever possible, these codes are the same as or similar to those of the  ANSI  X3.64-1979  standard
           (now superseded by ECMA-48, which uses identical or very similar names).  Semantics are also intended
           to match those of the specification.

           <u>terminfo</u>  codes  have  no hard length limit, but <u>ncurses</u> maintains an informal one of 5 characters to
           keep them short and to allow the tabs in the source file <u>Caps</u> to  line  up  nicely.   (Some  standard
           codes exceed this limit regardless.)

       •   The  TC (<u>termcap</u>) code is that used by the corresponding API of <u>ncurses</u>.  (Some capabilities are new,
           and have names that BSD <u>termcap</u> did not originate.)

       •   The description field attempts to convey the capability's semantics.

       The description field employs a handful of notations.

       <b>(P)</b>    indicates that padding may be specified.

       <b>(P*)</b>   indicates that padding may vary in proportion to the number of output lines affected.

       <b>#</b><u>i</u>     indicates the <u>i</u>th parameter of a string capability; the  programmer  should  pass  the  string  to
              <b><a href="../man3NCURSES/tparm.3NCURSES.html">tparm</a></b>(3NCURSES) with the parameters listed.

              If  the  description  lists  no  parameters,  passing  the  string  to <b><a href="../man3NCURSES/tparm.3NCURSES.html">tparm</a></b>(3NCURSES) may produce
              unexpected behavior, for instance if the string contains percent signs.

                                      <b>Code</b>
       <b>Boolean</b> <b>Capability</b> <b>Name</b>    <b>TI</b>        <b>TC</b>  <b>Description</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>auto_left_margin</b>           <b>bw</b>        <b>bw</b>  cub1 wraps from column 0 to last column
       <b>auto_right_margin</b>          <b>am</b>        <b>am</b>  terminal has automatic margins
       <b>no_esc_ctlc</b>                <b>xsb</b>       <b>xb</b>  beehive (f1=escape, f2=ctrl C)
       <b>ceol_standout_glitch</b>       <b>xhp</b>       <b>xs</b>  standout not erased by overwriting (hp)
       <b>eat_newline_glitch</b>         <b>xenl</b>      <b>xn</b>  newline ignored after 80 cols (concept)
       <b>erase_overstrike</b>           <b>eo</b>        <b>eo</b>  can erase overstrikes with a blank
       <b>generic_type</b>               <b>gn</b>        <b>gn</b>  generic line type
       <b>hard_copy</b>                  <b>hc</b>        <b>hc</b>  hardcopy terminal
       <b>has_meta_key</b>               <b>km</b>        <b>km</b>  Has a meta key (i.e., sets 8th-bit)
       <b>has_status_line</b>            <b>hs</b>        <b>hs</b>  has extra status line
       <b>insert_null_glitch</b>         <b>in</b>        <b>in</b>  insert mode distinguishes nulls
       <b>memory_above</b>               <b>da</b>        <b>da</b>  display may be retained above the screen
       <b>memory_below</b>               <b>db</b>        <b>db</b>  display may be retained below the screen
       <b>move_insert_mode</b>           <b>mir</b>       <b>mi</b>  safe to move while in insert mode
       <b>move_standout_mode</b>         <b>msgr</b>      <b>ms</b>  safe to move while in standout mode
       <b>over_strike</b>                <b>os</b>        <b>os</b>  terminal can overstrike
       <b>status_line_esc_ok</b>         <b>eslok</b>     <b>es</b>  escape can be used on the status line
       <b>dest_tabs_magic_smso</b>       <b>xt</b>        <b>xt</b>  tabs destructive, magic so char (t1061)
       <b>tilde_glitch</b>               <b>hz</b>        <b>hz</b>  cannot print ~'s (Hazeltine)
       <b>transparent_underline</b>      <b>ul</b>        <b>ul</b>  underline character overstrikes
       <b>xon_xoff</b>                   <b>xon</b>       <b>xo</b>  terminal uses xon/xoff handshaking
       <b>needs_xon_xoff</b>             <b>nxon</b>      <b>nx</b>  padding will not work, xon/xoff required
       <b>prtr_silent</b>                <b>mc5i</b>      <b>5i</b>  printer will not echo on screen
       <b>hard_cursor</b>                <b>chts</b>      <b>HC</b>  cursor is hard to see
       <b>non_rev_rmcup</b>              <b>nrrmc</b>     <b>NR</b>  smcup does not reverse rmcup
       <b>no_pad_char</b>                <b>npc</b>       <b>NP</b>  pad character does not exist
       <b>non_dest_scroll_region</b>     <b>ndscr</b>     <b>ND</b>  scrolling region is non-destructive
       <b>can_change</b>                 <b>ccc</b>       <b>cc</b>  terminal can re-define existing colors
       <b>back_color_erase</b>           <b>bce</b>       <b>ut</b>  screen erased with background color
       <b>hue_lightness_saturation</b>   <b>hls</b>       <b>hl</b>  terminal uses only HLS color notation (Tektronix)
       <b>col_addr_glitch</b>            <b>xhpa</b>      <b>YA</b>  only positive motion for hpa/mhpa caps
       <b>cr_cancels_micro_mode</b>      <b>crxm</b>      <b>YB</b>  using cr turns off micro mode
       <b>has_print_wheel</b>            <b>daisy</b>     <b>YC</b>  printer needs operator to change character set
       <b>row_addr_glitch</b>            <b>xvpa</b>      <b>YD</b>  only positive motion for vpa/mvpa caps
       <b>semi_auto_right_margin</b>     <b>sam</b>       <b>YE</b>  printing in last column causes cr
       <b>cpi_changes_res</b>            <b>cpix</b>      <b>YF</b>  changing character pitch changes resolution
       <b>lpi_changes_res</b>            <b>lpix</b>      <b>YG</b>  changing line pitch changes resolution

                                      <b>Code</b>
       <b>Numeric</b> <b>Capability</b> <b>Name</b>    <b>TI</b>        <b>TC</b>  <b>Description</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>columns</b>                    <b>cols</b>      <b>co</b>  number of columns in a line
       <b>init_tabs</b>                  <b>it</b>        <b>it</b>  tabs initially every # spaces
       <b>lines</b>                      <b>lines</b>     <b>li</b>  number of lines on screen or page
       <b>lines_of_memory</b>            <b>lm</b>        <b>lm</b>  lines of memory if &gt; line. 0 means varies
       <b>magic_cookie_glitch</b>        <b>xmc</b>       <b>sg</b>  number of blank characters left by smso or rmso
       <b>padding_baud_rate</b>          <b>pb</b>        <b>pb</b>  lowest baud rate where padding needed
       <b>virtual_terminal</b>           <b>vt</b>        <b>vt</b>  virtual terminal number (CB/unix)
       <b>width_status_line</b>          <b>wsl</b>       <b>ws</b>  number of columns in status line
       <b>num_labels</b>                 <b>nlab</b>      <b>Nl</b>  number of labels on screen
       <b>label_height</b>               <b>lh</b>        <b>lh</b>  rows in each label
       <b>label_width</b>                <b>lw</b>        <b>lw</b>  columns in each label
       <b>max_attributes</b>             <b>ma</b>        <b>ma</b>  maximum combined attributes terminal can handle
       <b>maximum_windows</b>            <b>wnum</b>      <b>MW</b>  maximum number of definable windows
       <b>max_colors</b>                 <b>colors</b>    <b>Co</b>  maximum number of colors on screen
       <b>max_pairs</b>                  <b>pairs</b>     <b>pa</b>  maximum number of color-pairs on the screen
       <b>no_color_video</b>             <b>ncv</b>       <b>NC</b>  video attributes that cannot be used with colors

       The following numeric capabilities are present in the SVr4.0 term structure, but are not  yet  documented
       in the man page.  They came in with SVr4's printer support.

                                      <b>Code</b>
       <b>Numeric</b> <b>Capability</b> <b>Name</b>    <b>TI</b>        <b>TC</b>  <b>Description</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>buffer_capacity</b>            <b>bufsz</b>     <b>Ya</b>  numbers of bytes buffered before printing
       <b>dot_vert_spacing</b>           <b>spinv</b>     <b>Yb</b>  spacing of pins vertically in pins per inch
       <b>dot_horz_spacing</b>           <b>spinh</b>     <b>Yc</b>  spacing of dots horizontally in dots per inch
       <b>max_micro_address</b>          <b>maddr</b>     <b>Yd</b>  maximum value in micro_..._address
       <b>max_micro_jump</b>             <b>mjump</b>     <b>Ye</b>  maximum value in parm_..._micro
       <b>micro_col_size</b>             <b>mcs</b>       <b>Yf</b>  character step size when in micro mode
       <b>micro_line_size</b>            <b>mls</b>       <b>Yg</b>  line step size when in micro mode
       <b>number_of_pins</b>             <b>npins</b>     <b>Yh</b>  numbers of pins in print-head
       <b>output_res_char</b>            <b>orc</b>       <b>Yi</b>  horizontal resolution in units per line
       <b>output_res_line</b>            <b>orl</b>       <b>Yj</b>  vertical resolution in units per line
       <b>output_res_horz_inch</b>       <b>orhi</b>      <b>Yk</b>  horizontal resolution in units per inch
       <b>output_res_vert_inch</b>       <b>orvi</b>      <b>Yl</b>  vertical resolution in units per inch
       <b>print_rate</b>                 <b>cps</b>       <b>Ym</b>  print rate in characters per second
       <b>wide_char_size</b>             <b>widcs</b>     <b>Yn</b>  character step size when in double wide mode
       <b>buttons</b>                    <b>btns</b>      <b>BT</b>  number of buttons on mouse
       <b>bit_image_entwining</b>        <b>bitwin</b>    <b>Yo</b>  number of passes for each bit-image row
       <b>bit_image_type</b>             <b>bitype</b>    <b>Yp</b>  type of bit-image device

                                      <b>Code</b>
       <b>String</b> <b>Capability</b> <b>Name</b>     <b>TI</b>        <b>TC</b>  <b>Description</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>back_tab</b>                   <b>cbt</b>       <b>bt</b>  back tab (P)
       <b>bell</b>                       <b>bel</b>       <b>bl</b>  audible signal (bell) (P)
       <b>carriage_return</b>            <b>cr</b>        <b>cr</b>  carriage return (P*) (P*)
       <b>change_scroll_region</b>       <b>csr</b>       <b>cs</b>  change region to line #1 to line #2 (P)
       <b>clear_all_tabs</b>             <b>tbc</b>       <b>ct</b>  clear all tab stops (P)
       <b>clear_screen</b>               <b>clear</b>     <b>cl</b>  clear screen and home cursor (P*)
       <b>clr_eol</b>                    <b>el</b>        <b>ce</b>  clear to end of line (P)
       <b>clr_eos</b>                    <b>ed</b>        <b>cd</b>  clear to end of screen (P*)
       <b>column_address</b>             <b>hpa</b>       <b>ch</b>  horizontal position #1, absolute (P)
       <b>command_character</b>          <b>cmdch</b>     <b>CC</b>  terminal settable cmd character in prototype !?
       <b>cursor_address</b>             <b>cup</b>       <b>cm</b>  move to row #1 columns #2
       <b>cursor_down</b>                <b>cud1</b>      <b>do</b>  down one line
       <b>cursor_home</b>                <b>home</b>      <b>ho</b>  home cursor (if no cup)
       <b>cursor_invisible</b>           <b>civis</b>     <b>vi</b>  make cursor invisible
       <b>cursor_left</b>                <b>cub1</b>      <b>le</b>  move left one space
       <b>cursor_mem_address</b>         <b>mrcup</b>     <b>CM</b>  memory relative cursor addressing, move to row #1 columns #2
       <b>cursor_normal</b>              <b>cnorm</b>     <b>ve</b>  make cursor appear normal (undo civis/cvvis)
       <b>cursor_right</b>               <b>cuf1</b>      <b>nd</b>  non-destructive space (move right one space)
       <b>cursor_to_ll</b>               <b>ll</b>        <b>ll</b>  last line, first column (if no cup)
       <b>cursor_up</b>                  <b>cuu1</b>      <b>up</b>  up one line
       <b>cursor_visible</b>             <b>cvvis</b>     <b>vs</b>  make cursor very visible
       <b>delete_character</b>           <b>dch1</b>      <b>dc</b>  delete character (P*)
       <b>delete_line</b>                <b>dl1</b>       <b>dl</b>  delete line (P*)
       <b>dis_status_line</b>            <b>dsl</b>       <b>ds</b>  disable status line
       <b>down_half_line</b>             <b>hd</b>        <b>hd</b>  half a line down
       <b>enter_alt_charset_mode</b>     <b>smacs</b>     <b>as</b>  start alternate character set (P)
       <b>enter_blink_mode</b>           <b>blink</b>     <b>mb</b>  turn on blinking
       <b>enter_bold_mode</b>            <b>bold</b>      <b>md</b>  turn on bold (extra bright) mode
       <b>enter_ca_mode</b>              <b>smcup</b>     <b>ti</b>  string to start programs using cup
       <b>enter_delete_mode</b>          <b>smdc</b>      <b>dm</b>  enter delete mode
       <b>enter_dim_mode</b>             <b>dim</b>       <b>mh</b>  turn on half-bright mode
       <b>enter_insert_mode</b>          <b>smir</b>      <b>im</b>  enter insert mode
       <b>enter_secure_mode</b>          <b>invis</b>     <b>mk</b>  turn on blank mode (characters invisible)
       <b>enter_protected_mode</b>       <b>prot</b>      <b>mp</b>  turn on protected mode
       <b>enter_reverse_mode</b>         <b>rev</b>       <b>mr</b>  turn on reverse video mode
       <b>enter_standout_mode</b>        <b>smso</b>      <b>so</b>  begin standout mode
       <b>enter_underline_mode</b>       <b>smul</b>      <b>us</b>  begin underline mode
       <b>erase_chars</b>                <b>ech</b>       <b>ec</b>  erase #1 characters (P)
       <b>exit_alt_charset_mode</b>      <b>rmacs</b>     <b>ae</b>  end alternate character set (P)
       <b>exit_attribute_mode</b>        <b>sgr0</b>      <b>me</b>  turn off all attributes
       <b>exit_ca_mode</b>               <b>rmcup</b>     <b>te</b>  strings to end programs using cup
       <b>exit_delete_mode</b>           <b>rmdc</b>      <b>ed</b>  end delete mode
       <b>exit_insert_mode</b>           <b>rmir</b>      <b>ei</b>  exit insert mode
       <b>exit_standout_mode</b>         <b>rmso</b>      <b>se</b>  exit standout mode
       <b>exit_underline_mode</b>        <b>rmul</b>      <b>ue</b>  exit underline mode
       <b>flash_screen</b>               <b>flash</b>     <b>vb</b>  visible bell (may not move cursor)
       <b>form_feed</b>                  <b>ff</b>        <b>ff</b>  hardcopy terminal page eject (P*)
       <b>from_status_line</b>           <b>fsl</b>       <b>fs</b>  return from status line
       <b>init_1string</b>               <b>is1</b>       <b>i1</b>  initialization string
       <b>init_2string</b>               <b>is2</b>       <b>is</b>  initialization string
       <b>init_3string</b>               <b>is3</b>       <b>i3</b>  initialization string
       <b>init_file</b>                  <b>if</b>        <b>if</b>  name of initialization file
       <b>insert_character</b>           <b>ich1</b>      <b>ic</b>  insert character (P)
       <b>insert_line</b>                <b>il1</b>       <b>al</b>  insert line (P*)
       <b>insert_padding</b>             <b>ip</b>        <b>ip</b>  insert padding after inserted character
       <b>key_backspace</b>              <b>kbs</b>       <b>kb</b>  backspace key
       <b>key_catab</b>                  <b>ktbc</b>      <b>ka</b>  clear-all-tabs key
       <b>key_clear</b>                  <b>kclr</b>      <b>kC</b>  clear-screen or erase key
       <b>key_ctab</b>                   <b>kctab</b>     <b>kt</b>  clear-tab key
       <b>key_dc</b>                     <b>kdch1</b>     <b>kD</b>  delete-character key
       <b>key_dl</b>                     <b>kdl1</b>      <b>kL</b>  delete-line key
       <b>key_down</b>                   <b>kcud1</b>     <b>kd</b>  down-arrow key
       <b>key_eic</b>                    <b>krmir</b>     <b>kM</b>  sent by rmir or smir in insert mode
       <b>key_eol</b>                    <b>kel</b>       <b>kE</b>  clear-to-end-of-line key
       <b>key_eos</b>                    <b>ked</b>       <b>kS</b>  clear-to-end-of-screen key
       <b>key_f0</b>                     <b>kf0</b>       <b>k0</b>  F0 function key
       <b>key_f1</b>                     <b>kf1</b>       <b>k1</b>  F1 function key
       <b>key_f10</b>                    <b>kf10</b>      <b>k;</b>  F10 function key
       <b>key_f2</b>                     <b>kf2</b>       <b>k2</b>  F2 function key
       <b>key_f3</b>                     <b>kf3</b>       <b>k3</b>  F3 function key
       <b>key_f4</b>                     <b>kf4</b>       <b>k4</b>  F4 function key
       <b>key_f5</b>                     <b>kf5</b>       <b>k5</b>  F5 function key
       <b>key_f6</b>                     <b>kf6</b>       <b>k6</b>  F6 function key
       <b>key_f7</b>                     <b>kf7</b>       <b>k7</b>  F7 function key
       <b>key_f8</b>                     <b>kf8</b>       <b>k8</b>  F8 function key
       <b>key_f9</b>                     <b>kf9</b>       <b>k9</b>  F9 function key
       <b>key_home</b>                   <b>khome</b>     <b>kh</b>  home key
       <b>key_ic</b>                     <b>kich1</b>     <b>kI</b>  insert-character key
       <b>key_il</b>                     <b>kil1</b>      <b>kA</b>  insert-line key
       <b>key_left</b>                   <b>kcub1</b>     <b>kl</b>  left-arrow key
       <b>key_ll</b>                     <b>kll</b>       <b>kH</b>  lower-left key (home down)
       <b>key_npage</b>                  <b>knp</b>       <b>kN</b>  next-page key
       <b>key_ppage</b>                  <b>kpp</b>       <b>kP</b>  previous-page key
       <b>key_right</b>                  <b>kcuf1</b>     <b>kr</b>  right-arrow key
       <b>key_sf</b>                     <b>kind</b>      <b>kF</b>  scroll-forward key
       <b>key_sr</b>                     <b>kri</b>       <b>kR</b>  scroll-backward key
       <b>key_stab</b>                   <b>khts</b>      <b>kT</b>  set-tab key
       <b>key_up</b>                     <b>kcuu1</b>     <b>ku</b>  up-arrow key
       <b>keypad_local</b>               <b>rmkx</b>      <b>ke</b>  leave keyboard transmit mode
       <b>keypad_xmit</b>                <b>smkx</b>      <b>ks</b>  enter keyboard transmit mode
       <b>lab_f0</b>                     <b>lf0</b>       <b>l0</b>  label on function key f0 if not f0
       <b>lab_f1</b>                     <b>lf1</b>       <b>l1</b>  label on function key f1 if not f1
       <b>lab_f10</b>                    <b>lf10</b>      <b>la</b>  label on function key f10 if not f10
       <b>lab_f2</b>                     <b>lf2</b>       <b>l2</b>  label on function key f2 if not f2
       <b>lab_f3</b>                     <b>lf3</b>       <b>l3</b>  label on function key f3 if not f3
       <b>lab_f4</b>                     <b>lf4</b>       <b>l4</b>  label on function key f4 if not f4
       <b>lab_f5</b>                     <b>lf5</b>       <b>l5</b>  label on function key f5 if not f5
       <b>lab_f6</b>                     <b>lf6</b>       <b>l6</b>  label on function key f6 if not f6
       <b>lab_f7</b>                     <b>lf7</b>       <b>l7</b>  label on function key f7 if not f7
       <b>lab_f8</b>                     <b>lf8</b>       <b>l8</b>  label on function key f8 if not f8
       <b>lab_f9</b>                     <b>lf9</b>       <b>l9</b>  label on function key f9 if not f9
       <b>meta_off</b>                   <b>rmm</b>       <b>mo</b>  turn off meta mode
       <b>meta_on</b>                    <b>smm</b>       <b>mm</b>  turn on meta mode (8th-bit on)
       <b>newline</b>                    <b>nel</b>       <b>nw</b>  newline (behave like cr followed by lf)
       <b>pad_char</b>                   <b>pad</b>       <b>pc</b>  padding char (instead of null)
       <b>parm_dch</b>                   <b>dch</b>       <b>DC</b>  delete #1 characters (P*)
       <b>parm_delete_line</b>           <b>dl</b>        <b>DL</b>  delete #1 lines (P*)
       <b>parm_down_cursor</b>           <b>cud</b>       <b>DO</b>  down #1 lines (P*)
       <b>parm_ich</b>                   <b>ich</b>       <b>IC</b>  insert #1 characters (P*)
       <b>parm_index</b>                 <b>indn</b>      <b>SF</b>  scroll forward #1 lines (P)
       <b>parm_insert_line</b>           <b>il</b>        <b>AL</b>  insert #1 lines (P*)
       <b>parm_left_cursor</b>           <b>cub</b>       <b>LE</b>  move #1 characters to the left (P)
       <b>parm_right_cursor</b>          <b>cuf</b>       <b>RI</b>  move #1 characters to the right (P*)
       <b>parm_rindex</b>                <b>rin</b>       <b>SR</b>  scroll back #1 lines (P)
       <b>parm_up_cursor</b>             <b>cuu</b>       <b>UP</b>  up #1 lines (P*)
       <b>pkey_key</b>                   <b>pfkey</b>     <b>pk</b>  program function key #1 to type string #2
       <b>pkey_local</b>                 <b>pfloc</b>     <b>pl</b>  program function key #1 to execute string #2
       <b>pkey_xmit</b>                  <b>pfx</b>       <b>px</b>  program function key #1 to transmit string #2
       <b>print_screen</b>               <b>mc0</b>       <b>ps</b>  print contents of screen
       <b>prtr_off</b>                   <b>mc4</b>       <b>pf</b>  turn off printer
       <b>prtr_on</b>                    <b>mc5</b>       <b>po</b>  turn on printer
       <b>repeat_char</b>                <b>rep</b>       <b>rp</b>  repeat char #1 #2 times (P*)
       <b>reset_1string</b>              <b>rs1</b>       <b>r1</b>  reset string
       <b>reset_2string</b>              <b>rs2</b>       <b>r2</b>  reset string
       <b>reset_3string</b>              <b>rs3</b>       <b>r3</b>  reset string
       <b>reset_file</b>                 <b>rf</b>        <b>rf</b>  name of reset file
       <b>restore_cursor</b>             <b>rc</b>        <b>rc</b>  restore cursor to position of last save_cursor
       <b>row_address</b>                <b>vpa</b>       <b>cv</b>  vertical position #1 absolute (P)
       <b>save_cursor</b>                <b>sc</b>        <b>sc</b>  save current cursor position (P)
       <b>scroll_forward</b>             <b>ind</b>       <b>sf</b>  scroll text up (P)
       <b>scroll_reverse</b>             <b>ri</b>        <b>sr</b>  scroll text down (P)
       <b>set_attributes</b>             <b>sgr</b>       <b>sa</b>  define video attributes #1-#9 (PG9)
       <b>set_tab</b>                    <b>hts</b>       <b>st</b>  set a tab in every row, current columns
       <b>set_window</b>                 <b>wind</b>      <b>wi</b>  current window is lines #1-#2 cols #3-#4
       <b>tab</b>                        <b>ht</b>        <b>ta</b>  tab to next 8-space hardware tab stop
       <b>to_status_line</b>             <b>tsl</b>       <b>ts</b>  move to status line, column #1
       <b>underline_char</b>             <b>uc</b>        <b>uc</b>  underline char and move past it
       <b>up_half_line</b>               <b>hu</b>        <b>hu</b>  half a line up
       <b>init_prog</b>                  <b>iprog</b>     <b>iP</b>  path name of program for initialization
       <b>key_a1</b>                     <b>ka1</b>       <b>K1</b>  upper left of keypad
       <b>key_a3</b>                     <b>ka3</b>       <b>K3</b>  upper right of keypad
       <b>key_b2</b>                     <b>kb2</b>       <b>K2</b>  center of keypad
       <b>key_c1</b>                     <b>kc1</b>       <b>K4</b>  lower left of keypad
       <b>key_c3</b>                     <b>kc3</b>       <b>K5</b>  lower right of keypad
       <b>prtr_non</b>                   <b>mc5p</b>      <b>pO</b>  turn on printer for #1 bytes
       <b>char_padding</b>               <b>rmp</b>       <b>rP</b>  like ip but when in insert mode
       <b>acs_chars</b>                  <b>acsc</b>      <b>ac</b>  graphics charset pairs, based on vt100
       <b>plab_norm</b>                  <b>pln</b>       <b>pn</b>  program label #1 to show string #2
       <b>key_btab</b>                   <b>kcbt</b>      <b>kB</b>  back-tab key
       <b>enter_xon_mode</b>             <b>smxon</b>     <b>SX</b>  turn on xon/xoff handshaking
       <b>exit_xon_mode</b>              <b>rmxon</b>     <b>RX</b>  turn off xon/xoff handshaking
       <b>enter_am_mode</b>              <b>smam</b>      <b>SA</b>  turn on automatic margins
       <b>exit_am_mode</b>               <b>rmam</b>      <b>RA</b>  turn off automatic margins
       <b>xon_character</b>              <b>xonc</b>      <b>XN</b>  XON character
       <b>xoff_character</b>             <b>xoffc</b>     <b>XF</b>  XOFF character
       <b>ena_acs</b>                    <b>enacs</b>     <b>eA</b>  enable alternate char set
       <b>label_on</b>                   <b>smln</b>      <b>LO</b>  turn on soft labels
       <b>label_off</b>                  <b>rmln</b>      <b>LF</b>  turn off soft labels
       <b>key_beg</b>                    <b>kbeg</b>      <b>@1</b>  begin key
       <b>key_cancel</b>                 <b>kcan</b>      <b>@2</b>  cancel key
       <b>key_close</b>                  <b>kclo</b>      <b>@3</b>  close key
       <b>key_command</b>                <b>kcmd</b>      <b>@4</b>  command key
       <b>key_copy</b>                   <b>kcpy</b>      <b>@5</b>  copy key
       <b>key_create</b>                 <b>kcrt</b>      <b>@6</b>  create key
       <b>key_end</b>                    <b>kend</b>      <b>@7</b>  end key
       <b>key_enter</b>                  <b>kent</b>      <b>@8</b>  enter/send key
       <b>key_exit</b>                   <b>kext</b>      <b>@9</b>  exit key
       <b>key_find</b>                   <b>kfnd</b>      <b>@0</b>  find key
       <b>key_help</b>                   <b>khlp</b>      <b>%1</b>  help key
       <b>key_mark</b>                   <b>kmrk</b>      <b>%2</b>  mark key
       <b>key_message</b>                <b>kmsg</b>      <b>%3</b>  message key
       <b>key_move</b>                   <b>kmov</b>      <b>%4</b>  move key
       <b>key_next</b>                   <b>knxt</b>      <b>%5</b>  next key
       <b>key_open</b>                   <b>kopn</b>      <b>%6</b>  open key
       <b>key_options</b>                <b>kopt</b>      <b>%7</b>  options key
       <b>key_previous</b>               <b>kprv</b>      <b>%8</b>  previous key
       <b>key_print</b>                  <b>kprt</b>      <b>%9</b>  print key
       <b>key_redo</b>                   <b>krdo</b>      <b>%0</b>  redo key
       <b>key_reference</b>              <b>kref</b>      <b>&amp;1</b>  reference key
       <b>key_refresh</b>                <b>krfr</b>      <b>&amp;2</b>  refresh key
       <b>key_replace</b>                <b>krpl</b>      <b>&amp;3</b>  replace key
       <b>key_restart</b>                <b>krst</b>      <b>&amp;4</b>  restart key
       <b>key_resume</b>                 <b>kres</b>      <b>&amp;5</b>  resume key
       <b>key_save</b>                   <b>ksav</b>      <b>&amp;6</b>  save key
       <b>key_suspend</b>                <b>kspd</b>      <b>&amp;7</b>  suspend key
       <b>key_undo</b>                   <b>kund</b>      <b>&amp;8</b>  undo key
       <b>key_sbeg</b>                   <b>kBEG</b>      <b>&amp;9</b>  shifted begin key
       <b>key_scancel</b>                <b>kCAN</b>      <b>&amp;0</b>  shifted cancel key
       <b>key_scommand</b>               <b>kCMD</b>      <b>*1</b>  shifted command key
       <b>key_scopy</b>                  <b>kCPY</b>      <b>*2</b>  shifted copy key
       <b>key_screate</b>                <b>kCRT</b>      <b>*3</b>  shifted create key
       <b>key_sdc</b>                    <b>kDC</b>       <b>*4</b>  shifted delete-character key
       <b>key_sdl</b>                    <b>kDL</b>       <b>*5</b>  shifted delete-line key
       <b>key_select</b>                 <b>kslt</b>      <b>*6</b>  select key
       <b>key_send</b>                   <b>kEND</b>      <b>*7</b>  shifted end key
       <b>key_seol</b>                   <b>kEOL</b>      <b>*8</b>  shifted clear-to-end-of-line key
       <b>key_sexit</b>                  <b>kEXT</b>      <b>*9</b>  shifted exit key
       <b>key_sfind</b>                  <b>kFND</b>      <b>*0</b>  shifted find key
       <b>key_shelp</b>                  <b>kHLP</b>      <b>#1</b>  shifted help key
       <b>key_shome</b>                  <b>kHOM</b>      <b>#2</b>  shifted home key
       <b>key_sic</b>                    <b>kIC</b>       <b>#3</b>  shifted insert-character key
       <b>key_sleft</b>                  <b>kLFT</b>      <b>#4</b>  shifted left-arrow key
       <b>key_smessage</b>               <b>kMSG</b>      <b>%a</b>  shifted message key
       <b>key_smove</b>                  <b>kMOV</b>      <b>%b</b>  shifted move key
       <b>key_snext</b>                  <b>kNXT</b>      <b>%c</b>  shifted next key
       <b>key_soptions</b>               <b>kOPT</b>      <b>%d</b>  shifted options key
       <b>key_sprevious</b>              <b>kPRV</b>      <b>%e</b>  shifted previous key
       <b>key_sprint</b>                 <b>kPRT</b>      <b>%f</b>  shifted print key
       <b>key_sredo</b>                  <b>kRDO</b>      <b>%g</b>  shifted redo key
       <b>key_sreplace</b>               <b>kRPL</b>      <b>%h</b>  shifted replace key
       <b>key_sright</b>                 <b>kRIT</b>      <b>%i</b>  shifted right-arrow key
       <b>key_srsume</b>                 <b>kRES</b>      <b>%j</b>  shifted resume key
       <b>key_ssave</b>                  <b>kSAV</b>      <b>!1</b>  shifted save key
       <b>key_ssuspend</b>               <b>kSPD</b>      <b>!2</b>  shifted suspend key
       <b>key_sundo</b>                  <b>kUND</b>      <b>!3</b>  shifted undo key
       <b>req_for_input</b>              <b>rfi</b>       <b>RF</b>  send next input char (for ptys)
       <b>key_f11</b>                    <b>kf11</b>      <b>F1</b>  F11 function key
       <b>key_f12</b>                    <b>kf12</b>      <b>F2</b>  F12 function key
       <b>key_f13</b>                    <b>kf13</b>      <b>F3</b>  F13 function key
       <b>key_f14</b>                    <b>kf14</b>      <b>F4</b>  F14 function key
       <b>key_f15</b>                    <b>kf15</b>      <b>F5</b>  F15 function key
       <b>key_f16</b>                    <b>kf16</b>      <b>F6</b>  F16 function key
       <b>key_f17</b>                    <b>kf17</b>      <b>F7</b>  F17 function key
       <b>key_f18</b>                    <b>kf18</b>      <b>F8</b>  F18 function key
       <b>key_f19</b>                    <b>kf19</b>      <b>F9</b>  F19 function key
       <b>key_f20</b>                    <b>kf20</b>      <b>FA</b>  F20 function key
       <b>key_f21</b>                    <b>kf21</b>      <b>FB</b>  F21 function key
       <b>key_f22</b>                    <b>kf22</b>      <b>FC</b>  F22 function key
       <b>key_f23</b>                    <b>kf23</b>      <b>FD</b>  F23 function key
       <b>key_f24</b>                    <b>kf24</b>      <b>FE</b>  F24 function key
       <b>key_f25</b>                    <b>kf25</b>      <b>FF</b>  F25 function key
       <b>key_f26</b>                    <b>kf26</b>      <b>FG</b>  F26 function key
       <b>key_f27</b>                    <b>kf27</b>      <b>FH</b>  F27 function key
       <b>key_f28</b>                    <b>kf28</b>      <b>FI</b>  F28 function key
       <b>key_f29</b>                    <b>kf29</b>      <b>FJ</b>  F29 function key
       <b>key_f30</b>                    <b>kf30</b>      <b>FK</b>  F30 function key
       <b>key_f31</b>                    <b>kf31</b>      <b>FL</b>  F31 function key
       <b>key_f32</b>                    <b>kf32</b>      <b>FM</b>  F32 function key
       <b>key_f33</b>                    <b>kf33</b>      <b>FN</b>  F33 function key
       <b>key_f34</b>                    <b>kf34</b>      <b>FO</b>  F34 function key
       <b>key_f35</b>                    <b>kf35</b>      <b>FP</b>  F35 function key
       <b>key_f36</b>                    <b>kf36</b>      <b>FQ</b>  F36 function key
       <b>key_f37</b>                    <b>kf37</b>      <b>FR</b>  F37 function key
       <b>key_f38</b>                    <b>kf38</b>      <b>FS</b>  F38 function key
       <b>key_f39</b>                    <b>kf39</b>      <b>FT</b>  F39 function key
       <b>key_f40</b>                    <b>kf40</b>      <b>FU</b>  F40 function key
       <b>key_f41</b>                    <b>kf41</b>      <b>FV</b>  F41 function key
       <b>key_f42</b>                    <b>kf42</b>      <b>FW</b>  F42 function key
       <b>key_f43</b>                    <b>kf43</b>      <b>FX</b>  F43 function key
       <b>key_f44</b>                    <b>kf44</b>      <b>FY</b>  F44 function key
       <b>key_f45</b>                    <b>kf45</b>      <b>FZ</b>  F45 function key
       <b>key_f46</b>                    <b>kf46</b>      <b>Fa</b>  F46 function key
       <b>key_f47</b>                    <b>kf47</b>      <b>Fb</b>  F47 function key
       <b>key_f48</b>                    <b>kf48</b>      <b>Fc</b>  F48 function key
       <b>key_f49</b>                    <b>kf49</b>      <b>Fd</b>  F49 function key
       <b>key_f50</b>                    <b>kf50</b>      <b>Fe</b>  F50 function key
       <b>key_f51</b>                    <b>kf51</b>      <b>Ff</b>  F51 function key
       <b>key_f52</b>                    <b>kf52</b>      <b>Fg</b>  F52 function key
       <b>key_f53</b>                    <b>kf53</b>      <b>Fh</b>  F53 function key
       <b>key_f54</b>                    <b>kf54</b>      <b>Fi</b>  F54 function key
       <b>key_f55</b>                    <b>kf55</b>      <b>Fj</b>  F55 function key
       <b>key_f56</b>                    <b>kf56</b>      <b>Fk</b>  F56 function key
       <b>key_f57</b>                    <b>kf57</b>      <b>Fl</b>  F57 function key
       <b>key_f58</b>                    <b>kf58</b>      <b>Fm</b>  F58 function key
       <b>key_f59</b>                    <b>kf59</b>      <b>Fn</b>  F59 function key
       <b>key_f60</b>                    <b>kf60</b>      <b>Fo</b>  F60 function key
       <b>key_f61</b>                    <b>kf61</b>      <b>Fp</b>  F61 function key
       <b>key_f62</b>                    <b>kf62</b>      <b>Fq</b>  F62 function key
       <b>key_f63</b>                    <b>kf63</b>      <b>Fr</b>  F63 function key
       <b>clr_bol</b>                    <b>el1</b>       <b>cb</b>  Clear to beginning of line
       <b>clear_margins</b>              <b>mgc</b>       <b>MC</b>  clear right and left soft margins
       <b>set_left_margin</b>            <b>smgl</b>      <b>ML</b>  set left soft margin at current column (not in BSD <u>termcap</u>)
       <b>set_right_margin</b>           <b>smgr</b>      <b>MR</b>  set right soft margin at current column
       <b>label_format</b>               <b>fln</b>       <b>Lf</b>  label format
       <b>set_clock</b>                  <b>sclk</b>      <b>SC</b>  set clock, #1 hrs #2 mins #3 secs
       <b>display_clock</b>              <b>dclk</b>      <b>DK</b>  display clock
       <b>remove_clock</b>               <b>rmclk</b>     <b>RC</b>  remove clock
       <b>create_window</b>              <b>cwin</b>      <b>CW</b>  define a window #1 from #2,#3 to #4,#5
       <b>goto_window</b>                <b>wingo</b>     <b>WG</b>  go to window #1
       <b>hangup</b>                     <b>hup</b>       <b>HU</b>  hang-up phone
       <b>dial_phone</b>                 <b>dial</b>      <b>DI</b>  dial number #1
       <b>quick_dial</b>                 <b>qdial</b>     <b>QD</b>  dial number #1 without checking
       <b>tone</b>                       <b>tone</b>      <b>TO</b>  select touch tone dialing
       <b>pulse</b>                      <b>pulse</b>     <b>PU</b>  select pulse dialing
       <b>flash_hook</b>                 <b>hook</b>      <b>fh</b>  flash switch hook
       <b>fixed_pause</b>                <b>pause</b>     <b>PA</b>  pause for 2-3 seconds
       <b>wait_tone</b>                  <b>wait</b>      <b>WA</b>  wait for dial-tone
       <b>user0</b>                      <b>u0</b>        <b>u0</b>  User string #0
       <b>user1</b>                      <b>u1</b>        <b>u1</b>  User string #1
       <b>user2</b>                      <b>u2</b>        <b>u2</b>  User string #2
       <b>user3</b>                      <b>u3</b>        <b>u3</b>  User string #3
       <b>user4</b>                      <b>u4</b>        <b>u4</b>  User string #4
       <b>user5</b>                      <b>u5</b>        <b>u5</b>  User string #5
       <b>user6</b>                      <b>u6</b>        <b>u6</b>  User string #6
       <b>user7</b>                      <b>u7</b>        <b>u7</b>  User string #7
       <b>user8</b>                      <b>u8</b>        <b>u8</b>  User string #8
       <b>user9</b>                      <b>u9</b>        <b>u9</b>  User string #9
       <b>orig_pair</b>                  <b>op</b>        <b>op</b>  Set default pair to its original value
       <b>orig_colors</b>                <b>oc</b>        <b>oc</b>  Set all color pairs to the original ones
       <b>initialize_color</b>           <b>initc</b>     <b>Ic</b>  initialize color #1 to (#2,#3,#4)
       <b>initialize_pair</b>            <b>initp</b>     <b>Ip</b>  Initialize color pair #1 to fg=(#2,#3,#4), bg=(#5,#6,#7)
       <b>set_color_pair</b>             <b>scp</b>       <b>sp</b>  Set current color pair to #1
       <b>set_foreground</b>             <b>setf</b>      <b>Sf</b>  Set foreground color #1
       <b>set_background</b>             <b>setb</b>      <b>Sb</b>  Set background color #1
       <b>change_char_pitch</b>          <b>cpi</b>       <b>ZA</b>  Change number of characters per inch to #1
       <b>change_line_pitch</b>          <b>lpi</b>       <b>ZB</b>  Change number of lines per inch to #1
       <b>change_res_horz</b>            <b>chr</b>       <b>ZC</b>  Change horizontal resolution to #1
       <b>change_res_vert</b>            <b>cvr</b>       <b>ZD</b>  Change vertical resolution to #1
       <b>define_char</b>                <b>defc</b>      <b>ZE</b>  Define a character #1, #2 dots wide, descender #3
       <b>enter_doublewide_mode</b>      <b>swidm</b>     <b>ZF</b>  Enter double-wide mode
       <b>enter_draft_quality</b>        <b>sdrfq</b>     <b>ZG</b>  Enter draft-quality mode
       <b>enter_italics_mode</b>         <b>sitm</b>      <b>ZH</b>  Enter italic mode
       <b>enter_leftward_mode</b>        <b>slm</b>       <b>ZI</b>  Start leftward carriage motion
       <b>enter_micro_mode</b>           <b>smicm</b>     <b>ZJ</b>  Start micro-motion mode
       <b>enter_near_letter_quality</b>  <b>snlq</b>      <b>ZK</b>  Enter NLQ mode
       <b>enter_normal_quality</b>       <b>snrmq</b>     <b>ZL</b>  Enter normal-quality mode
       <b>enter_shadow_mode</b>          <b>sshm</b>      <b>ZM</b>  Enter shadow-print mode
       <b>enter_subscript_mode</b>       <b>ssubm</b>     <b>ZN</b>  Enter subscript mode
       <b>enter_superscript_mode</b>     <b>ssupm</b>     <b>ZO</b>  Enter superscript mode
       <b>enter_upward_mode</b>          <b>sum</b>       <b>ZP</b>  Start upward carriage motion
       <b>exit_doublewide_mode</b>       <b>rwidm</b>     <b>ZQ</b>  End double-wide mode
       <b>exit_italics_mode</b>          <b>ritm</b>      <b>ZR</b>  End italic mode
       <b>exit_leftward_mode</b>         <b>rlm</b>       <b>ZS</b>  End left-motion mode
       <b>exit_micro_mode</b>            <b>rmicm</b>     <b>ZT</b>  End micro-motion mode
       <b>exit_shadow_mode</b>           <b>rshm</b>      <b>ZU</b>  End shadow-print mode
       <b>exit_subscript_mode</b>        <b>rsubm</b>     <b>ZV</b>  End subscript mode
       <b>exit_superscript_mode</b>      <b>rsupm</b>     <b>ZW</b>  End superscript mode
       <b>exit_upward_mode</b>           <b>rum</b>       <b>ZX</b>  End reverse character motion
       <b>micro_column_address</b>       <b>mhpa</b>      <b>ZY</b>  Like column_address in micro mode
       <b>micro_down</b>                 <b>mcud1</b>     <b>ZZ</b>  Like cursor_down in micro mode
       <b>micro_left</b>                 <b>mcub1</b>     <b>Za</b>  Like cursor_left in micro mode
       <b>micro_right</b>                <b>mcuf1</b>     <b>Zb</b>  Like cursor_right in micro mode
       <b>micro_row_address</b>          <b>mvpa</b>      <b>Zc</b>  Like row_address #1 in micro mode
       <b>micro_up</b>                   <b>mcuu1</b>     <b>Zd</b>  Like cursor_up in micro mode
       <b>order_of_pins</b>              <b>porder</b>    <b>Ze</b>  Match software bits to print-head pins
       <b>parm_down_micro</b>            <b>mcud</b>      <b>Zf</b>  Like parm_down_cursor in micro mode
       <b>parm_left_micro</b>            <b>mcub</b>      <b>Zg</b>  Like parm_left_cursor in micro mode
       <b>parm_right_micro</b>           <b>mcuf</b>      <b>Zh</b>  Like parm_right_cursor in micro mode
       <b>parm_up_micro</b>              <b>mcuu</b>      <b>Zi</b>  Like parm_up_cursor in micro mode
       <b>select_char_set</b>            <b>scs</b>       <b>Zj</b>  Select character set, #1
       <b>set_bottom_margin</b>          <b>smgb</b>      <b>Zk</b>  Set bottom margin at current line
       <b>set_bottom_margin_parm</b>     <b>smgbp</b>     <b>Zl</b>  Set bottom margin at line #1 or (if smgtp is not given) #2 lines
                                                from bottom
       <b>set_left_margin_parm</b>       <b>smglp</b>     <b>Zm</b>  Set left (right) margin at column #1
       <b>set_right_margin_parm</b>      <b>smgrp</b>     <b>Zn</b>  Set right margin at column #1
       <b>set_top_margin</b>             <b>smgt</b>      <b>Zo</b>  Set top margin at current line
       <b>set_top_margin_parm</b>        <b>smgtp</b>     <b>Zp</b>  Set top (bottom) margin at row #1
       <b>start_bit_image</b>            <b>sbim</b>      <b>Zq</b>  Start printing bit image graphics
       <b>start_char_set_def</b>         <b>scsd</b>      <b>Zr</b>  Start character set definition #1, with #2 characters in the set
       <b>stop_bit_image</b>             <b>rbim</b>      <b>Zs</b>  Stop printing bit image graphics
       <b>stop_char_set_def</b>          <b>rcsd</b>      <b>Zt</b>  End definition of character set #1
       <b>subscript_characters</b>       <b>subcs</b>     <b>Zu</b>  List of subscriptable characters
       <b>superscript_characters</b>     <b>supcs</b>     <b>Zv</b>  List of superscriptable characters
       <b>these_cause_cr</b>             <b>docr</b>      <b>Zw</b>  Printing any of these characters causes CR
       <b>zero_motion</b>                <b>zerom</b>     <b>Zx</b>  No motion for subsequent character

       The  following  string  capabilities  are  present  in the SVr4.0 term structure, but were originally not
       documented in the man page.

                                      <b>Code</b>
       <b>String</b> <b>Capability</b> <b>Name</b>     <b>TI</b>        <b>TC</b>  <b>Description</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>char_set_names</b>             <b>csnm</b>      <b>Zy</b>  Produce #1'th item from list of character set names
       <b>key_mouse</b>                  <b>kmous</b>     <b>Km</b>  Mouse event has occurred
       <b>mouse_info</b>                 <b>minfo</b>     <b>Mi</b>  Mouse status information
       <b>req_mouse_pos</b>              <b>reqmp</b>     <b>RQ</b>  Request mouse position
       <b>get_mouse</b>                  <b>getm</b>      <b>Gm</b>  Curses should get button events, parameter #1 not documented.
       <b>set_a_foreground</b>           <b>setaf</b>     <b>AF</b>  Set foreground color to #1, using ANSI escape
       <b>set_a_background</b>           <b>setab</b>     <b>AB</b>  Set background color to #1, using ANSI escape
       <b>pkey_plab</b>                  <b>pfxl</b>      <b>xl</b>  Program function key #1 to type string #2 and show string #3
       <b>device_type</b>                <b>devt</b>      <b>dv</b>  Indicate language, codeset support
       <b>code_set_init</b>              <b>csin</b>      <b>ci</b>  Init sequence for multiple codesets
       <b>set0_des_seq</b>               <b>s0ds</b>      <b>s0</b>  Shift to codeset 0 (EUC set 0, ASCII)
       <b>set1_des_seq</b>               <b>s1ds</b>      <b>s1</b>  Shift to codeset 1
       <b>set2_des_seq</b>               <b>s2ds</b>      <b>s2</b>  Shift to codeset 2
       <b>set3_des_seq</b>               <b>s3ds</b>      <b>s3</b>  Shift to codeset 3
       <b>set_lr_margin</b>              <b>smglr</b>     <b>ML</b>  Set both left and right margins to #1, #2.  (ML is not in BSD
                                                termcap).
       <b>set_tb_margin</b>              <b>smgtb</b>     <b>MT</b>  Sets both top and bottom margins to #1, #2
       <b>bit_image_repeat</b>           <b>birep</b>     <b>Xy</b>  Repeat bit image cell #1 #2 times
       <b>bit_image_newline</b>          <b>binel</b>     <b>Zz</b>  Move to next row of the bit image
       <b>bit_image_carriage_return</b>  <b>bicr</b>      <b>Yv</b>  Move to beginning of same row
       <b>color_names</b>                <b>colornm</b>   <b>Yw</b>  Give name for color #1
       <b>define_bit_image_region</b>    <b>defbi</b>     <b>Yx</b>  Define rectangular bit image region
       <b>end_bit_image_region</b>       <b>endbi</b>     <b>Yy</b>  End a bit-image region
       <b>set_color_band</b>             <b>setcolor</b>  <b>Yz</b>  Change to ribbon color #1
       <b>set_page_length</b>            <b>slines</b>    <b>YZ</b>  Set page length to #1 lines
       <b>display_pc_char</b>            <b>dispc</b>     <b>S1</b>  Display PC character #1
       <b>enter_pc_charset_mode</b>      <b>smpch</b>     <b>S2</b>  Enter PC character display mode
       <b>exit_pc_charset_mode</b>       <b>rmpch</b>     <b>S3</b>  Exit PC character display mode
       <b>enter_scancode_mode</b>        <b>smsc</b>      <b>S4</b>  Enter PC scancode mode
       <b>exit_scancode_mode</b>         <b>rmsc</b>      <b>S5</b>  Exit PC scancode mode
       <b>pc_term_options</b>            <b>pctrm</b>     <b>S6</b>  PC terminal options
       <b>scancode_escape</b>            <b>scesc</b>     <b>S7</b>  Escape for scancode emulation
       <b>alt_scancode_esc</b>           <b>scesa</b>     <b>S8</b>  Alternate escape for scancode emulation

       The XSI Curses standard added these hardcopy capabilities.  They were used in some post-4.1  versions  of
       System  V  curses, e.g., Solaris 2.5 and IRIX 6.x.  Except for <b>YI</b>, the <b>ncurses</b> termcap names for them are
       invented.  According to the XSI Curses standard, they have no termcap names.  If your  compiled  terminfo
       entries use these, they may not be binary-compatible with System V terminfo entries after SVr4.1; beware!

                                      <b>Code</b>
       <b>String</b> <b>Capability</b> <b>Name</b>     <b>TI</b>        <b>TC</b>  <b>Description</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>enter_horizontal_hl_mode</b>   <b>ehhlm</b>     <b>Xh</b>  Enter horizontal highlight mode
       <b>enter_left_hl_mode</b>         <b>elhlm</b>     <b>Xl</b>  Enter left highlight mode
       <b>enter_low_hl_mode</b>          <b>elohlm</b>    <b>Xo</b>  Enter low highlight mode
       <b>enter_right_hl_mode</b>        <b>erhlm</b>     <b>Xr</b>  Enter right highlight mode
       <b>enter_top_hl_mode</b>          <b>ethlm</b>     <b>Xt</b>  Enter top highlight mode
       <b>enter_vertical_hl_mode</b>     <b>evhlm</b>     <b>Xv</b>  Enter vertical highlight mode
       <b>set_a_attributes</b>           <b>sgr1</b>      <b>sA</b>  Define second set of video attributes #1-#6
       <b>set_pglen_inch</b>             <b>slength</b>   <b>YI</b>  Set page length to #1 hundredth of an inch (some implementations
                                                use sL for termcap).

   <b>User-Defined</b> <b>Capabilities</b>
       The  preceding  section  listed  the  <u>predefined</u>  capabilities.  They deal with some special features for
       terminals no longer (or possibly never) produced.  Occasionally  there  are  special  features  of  newer
       terminals which are awkward or impossible to represent by reusing the predefined capabilities.

       <u>ncurses</u>  addresses  this  limitation by allowing user-defined capabilities.  The <b>tic</b> and <b>infocmp</b> programs
       provide the <b>-x</b> option for this purpose.  When <b>-x</b> is set, <b>tic</b> treats unknown capabilities as user-defined.
       That is, if <b>tic</b> encounters a capability name which it does not recognize, it infers  its  type  (Boolean,
       number  or  string)  from  the  syntax  and  makes  an  extended  table  entry  for that capability.  The
       <b><a href="../man3NCURSES/use_extended_names.3NCURSES.html">use_extended_names</a></b>(3NCURSES) function makes this information  conditionally  available  to  applications.
       The <u>ncurses</u> library provides the data leaving most of the behavior to applications:

       •   User-defined capability strings whose name begins with “k” are treated as function keys.

       •   The  types  (Boolean,  number,  string)  determined  by  <b>tic</b>  can  be inferred by successful calls on
           <b>tigetflag</b>, etc.

       •   If the capability name happens to be two characters, the capability is  also  available  through  the
           termcap interface.

       While  termcap  is  said  to  be  extensible because it does not use a predefined set of capabilities, in
       practice it has been limited to the capabilities defined by terminfo implementations.  As a  rule,  user-
       defined  capabilities  intended for use by termcap applications should be limited to Booleans and numbers
       to avoid running past the 1023 byte limit assumed by termcap implementations and their applications.   In
       particular,  providing  extended  sets  of  function  keys  (past the 60 numbered keys and the handful of
       special named keys) is best done using the longer names available using terminfo.

       The <u>ncurses</u> library uses a few of these user-defined capabilities, as described in  <b><a href="../man5/user_caps.5.html">user_caps</a></b>(5).   Other
       user-defined  capabilities  (including  function  keys)  are  described  in the terminal database, in the
       section on <u>NCURSES</u> <u>USER-DEFINABLE</u> <u>CAPABILITIES</u>

   <b>A</b> <b>Sample</b> <b>Entry</b>
       The following entry, describing an ANSI-standard terminal, is representative of what a <b>terminfo</b> entry for
       a modern terminal typically looks like.

       ansi|ansi/pc-term compatible with color,
               am, mc5i, mir, msgr,
               colors#8, cols#80, it#8, lines#24, ncv#3, pairs#64,
               acsc=+\020\,\021-\030.^Y0\333`\004a\261f\370g\361h\260
                    j\331k\277l\332m\300n\305o~p\304q\304r\304s_t\303
                    u\264v\301w\302x\263y\363z\362{\343|\330}\234~\376,
               bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, clear=\E[H\E[J,
               cr=^M, cub=\E[%p1%dD, cub1=\E[D, cud=\E[%p1%dB, cud1=\E[B,
               cuf=\E[%p1%dC, cuf1=\E[C, cup=\E[%i%p1%d;%p2%dH,
               cuu=\E[%p1%dA, cuu1=\E[A, dch=\E[%p1%dP, dch1=\E[P,
               dl=\E[%p1%dM, dl1=\E[M, ech=\E[%p1%dX, ed=\E[J, el=\E[K,
               el1=\E[1K, home=\E[H, hpa=\E[%i%p1%dG, ht=\E[I, hts=\EH,
               ich=\E[%p1%d@, il=\E[%p1%dL, il1=\E[L, ind=^J,
               indn=\E[%p1%dS, invis=\E[8m, kbs=^H, kcbt=\E[Z, kcub1=\E[D,
               kcud1=\E[B, kcuf1=\E[C, kcuu1=\E[A, khome=\E[H, kich1=\E[L,
               mc4=\E[4i, mc5=\E[5i, nel=\r\E[S, op=\E[39;49m,
               rep=%p1%c\E[%p2%{1}%-%db, rev=\E[7m, rin=\E[%p1%dT,
               rmacs=\E[10m, rmpch=\E[10m, rmso=\E[m, rmul=\E[m,
               s0ds=\E(B, s1ds=\E)B, s2ds=\E*B, s3ds=\E+B,
               setab=\E[4%p1%dm, setaf=\E[3%p1%dm,
               sgr=\E[0;10%?%p1%t;7%;
                          %?%p2%t;4%;
                          %?%p3%t;7%;
                          %?%p4%t;5%;
                          %?%p6%t;1%;
                          %?%p7%t;8%;
                          %?%p9%t;11%;m,
               sgr0=\E[0;10m, smacs=\E[11m, smpch=\E[11m, smso=\E[7m,
               smul=\E[4m, tbc=\E[3g, u6=\E[%i%d;%dR, u7=\E[6n,
               u8=\E[?%[;0123456789]c, u9=\E[c, vpa=\E[%i%p1%dd,

       Entries may continue onto multiple lines by placing white space at the beginning of each line except  the
       first.   Comments  may  be  included  on lines beginning with “#”.  Capabilities in <u>terminfo</u> are of three
       types:

       •   Boolean capabilities which indicate that the terminal has some particular feature,

       •   numeric capabilities giving the size of the terminal or the size of particular delays, and

       •   string capabilities, which give  a  sequence  which  can  be  used  to  perform  particular  terminal
           operations.

   <b>Types</b> <b>of</b> <b>Capabilities</b>
       All  capabilities have names.  For instance, the fact that ANSI-standard terminals have <u>automatic</u> <u>margins</u>
       (i.e., an automatic return and line-feed when the  end  of  a  line  is  reached)  is  indicated  by  the
       capability  <b>am</b>.   Hence  the  description  of ansi includes <b>am</b>.  Numeric capabilities are followed by the
       character “#” and then a positive value.  Thus <b>cols</b>, which indicates the number of columns  the  terminal
       has,  gives the value “80” for ansi.  Values for numeric capabilities may be specified in decimal, octal,
       or hexadecimal, using the C programming language conventions (e.g., 255, 0377 and 0xff or 0xFF).

       Finally, string valued capabilities, such as <b>el</b> (clear to end of line sequence) are  given  by  the  two-
       character code, an “=”, and then a string ending at the next following “,”.

       A  number  of  escape  sequences  are  provided  in  the  string valued capabilities for easy encoding of
       characters there:

       •   Both <b>\E</b> and <b>\e</b> map to an ESCAPE character,

       •   <b>^</b><u><b>x</b></u> maps to a control-<u>x</u> for any appropriate <u>x</u>, and

       •   the sequences

             <b>\n</b>, <b>\l</b>, <b>\r</b>, <b>\t</b>, <b>\b</b>, <b>\f</b>, and <b>\s</b>

           produce

             <u>newline</u>, <u>line-feed</u>, <u>return</u>, <u>tab</u>, <u>backspace</u>, <u>form-feed</u>, and <u>space</u>,

           respectively.

       X/Open Curses does not say what “appropriate <u>x</u>” might be.  In practice, that is a printable ASCII graphic
       character.  The special case “^?” is interpreted as DEL (127).  In all other cases, the  character  value
       is logically “and”-ed with 0x1f, mapping to ASCII control codes in the range 0 through 31.

       Other escapes include

       •   <b>\^</b> for <b>^</b>,

       •   <b>\\</b> for <b>\</b>,

       •   <b>\</b>, for comma,

       •   <b>\:</b> for <b>:</b>,

       •   and <b>\0</b> for null.

           <b>\0</b>  will  produce  \200,  which  does  not terminate a string but behaves as a null character on most
           terminals, providing CS7 is specified.  See <b><a href="../man1/stty.1.html">stty</a></b>(1).

           The reason for this quirk is to maintain binary compatibility of the  compiled  terminfo  files  with
           other  implementations,  e.g.,  the  SVr4  systems, which document this.  Compiled terminfo files use
           null-terminated strings, with no lengths.  Modifying this would require a new  binary  format,  which
           would not work with other implementations.

       Finally, characters may be given as three octal digits after a <b>\</b>.

       A  delay  in  milliseconds  may appear anywhere in a string capability, enclosed in $&lt;..&gt; brackets, as in
       <b>el</b>=\EK$&lt;5&gt;, and padding characters are supplied by <b><a href="../man3NCURSES/tputs.3NCURSES.html">tputs</a></b>(3NCURSES) to provide this delay.

       •   The delay must be a number with at most one decimal  place  of  precision;  it  may  be  followed  by
           suffixes “*” or “/” or both.

       •   A  “*”  indicates  that  the  padding required is proportional to the number of lines affected by the
           operation, and the amount given is the per-affected-unit padding required.  (In the  case  of  insert
           character, the factor is still the number of <u>lines</u> affected.)

           Normally,  padding  is advisory if the device has the <b>xon</b> capability; it is used for cost computation
           but does not trigger delays.

       •   A “/” suffix indicates that the padding is mandatory and forces  a  delay  of  the  given  number  of
           milliseconds even on devices for which <b>xon</b> is present to indicate flow control.

       Sometimes  individual capabilities must be commented out.  To do this, put a period before the capability
       name.  For example, see the second <b>ind</b> in the example above.

   <b>Fetching</b> <b>Compiled</b> <b>Descriptions</b>
       Terminal descriptions in <u>ncurses</u> are stored in terminal databases.  These databases, which are  found  by
       their pathname, may be configured either as directory trees or hashed databases (see <b><a href="../man5/term.5.html">term</a></b>(5)),

       The  library  uses  a  compiled-in  list  of pathnames, which can be overridden by environment variables.
       Before starting to search, <u>ncurses</u> checks the search list, eliminating duplicates and pathnames where  no
       terminal database is found.  The <u>ncurses</u> library reads the first description which passes its consistency
       checks.

       •   The  environment  variable <b>TERMINFO</b> is checked first, for a terminal database containing the terminal
           description.

       •   Next, <u>ncurses</u> looks in <u>$HOME/.terminfo</u> for a compiled description.

           This is an optional feature which may be omitted entirely from the library,  or  limited  to  prevent
           accidental use by privileged applications.

       •   Next,  if  the  environment  variable  <u>TERMINFO_DIRS</u>  is set, <u>ncurses</u> interprets the contents of that
           variable as a list of colon-separated pathnames of terminal databases to be searched.

           An empty pathname (i.e., if the variable begins or ends with a colon, or contains adjacent colons) is
           interpreted as the system location <u><a href="file:/etc/terminfo">/etc/terminfo</a></u>.

       •   Finally, <u>ncurses</u> searches these compiled-in locations:

           •   a list of directories (<a href="file:/etc/terminfo">/etc/terminfo</a>:/lib/terminfo:<a href="file:/usr/share/terminfo">/usr/share/terminfo</a>), and

           •   the system terminfo directory, <u><a href="file:/etc/terminfo">/etc/terminfo</a></u>

       The <b>TERMINFO</b> variable can contain a terminal description instead of the pathname of a terminal  database.
       If this variable begins with “hex:” or “b64:” then <u>ncurses</u> reads a terminal description from hexadecimal-
       or  base64-encoded  data,  and  if that description matches the name sought, will use that.  This encoded
       data can be set using the “-Q” option of <b>tic</b> or <b>infocmp</b>.

       The preceding addresses the usual configuration of <u>ncurses</u>, which uses terminal descriptions prepared  in
       <u>terminfo</u>  format.   While  <u>termcap</u>  is  less  expressive,  <u>ncurses</u> can also be configured to read <u>termcap</u>
       descriptions.  In that configuration, it checks the <u>TERMCAP</u>  and  <u>TERMPATH</u>  variables  (for  content  and
       search path, respectively) after the system terminal database.

   <b>Preparing</b> <b>Descriptions</b>
       We  now  outline  how to prepare descriptions of terminals.  The most effective way to prepare a terminal
       description is by imitating the description of  a  similar  terminal  in  <u>terminfo</u>  and  to  build  up  a
       description  gradually, using partial descriptions with <u>vi</u> or some other screen-oriented program to check
       that they are correct.  Be aware that a very unusual terminal may expose deficiencies in the  ability  of
       the <u>terminfo</u> file to describe it or bugs in the screen-handling code of the test program.

       To get the padding for insert line right (if the terminal manufacturer did not document it) a severe test
       is  to  edit a large file at 9600 baud, delete 16 or so lines from the middle of the screen, then hit the
       “u” key several times quickly.  If the terminal messes up, more padding is  usually  needed.   A  similar
       test can be used for insert character.

   <b>Basic</b> <b>Capabilities</b>
       The  number  of  columns  on  each line for the terminal is given by the <b>cols</b> numeric capability.  If the
       terminal is a CRT, then the number of lines on the screen is given  by  the  <b>lines</b>  capability.   If  the
       terminal  wraps around to the beginning of the next line when it reaches the right margin, then it should
       have the <b>am</b> capability.  If the terminal can clear its screen, leaving the cursor in the  home  position,
       then  this  is given by the <b>clear</b> string capability.  If the terminal overstrikes (rather than clearing a
       position when a character is struck over) then it should have the <b>os</b> capability.  If the  terminal  is  a
       printing  terminal,  with  no  soft  copy  unit,  give  it  both <b>hc</b> and <b>os</b>.  (<b>os</b> applies to storage scope
       terminals, such as TEKTRONIX 4010 series, as well as hard copy and APL terminals.)  If there is a code to
       move the cursor to the left edge of the current line, give this as <b>cr</b>.  (Normally this will  be  carriage
       return, control/M.)  If there is a code to produce an audible signal (bell, beep, etc) give this as <b>bel</b>.

       If there is a code to move the cursor one position to the left (such as backspace) that capability should
       be given as <b>cub1</b>.  Similarly, codes to move to the right, up, and down should be given as <b>cuf1</b>, <b>cuu1</b>, and
       <b>cud1</b>.   These  local  cursor motions should not alter the text they pass over, for example, you would not
       normally use “<b>cuf1</b>= ” because the space would erase the character moved over.

       A very important point here is that the local cursor motions encoded in <u>terminfo</u>  are  undefined  at  the
       left  and  top edges of a CRT terminal.  Programs should never attempt to backspace around the left edge,
       unless <b>bw</b> is given, and never attempt to go up locally off the top.   In  order  to  scroll  text  up,  a
       program will go to the bottom left corner of the screen and send the <b>ind</b> (index) string.

       To scroll text down, a program goes to the top left corner of the screen and sends the <b>ri</b> (reverse index)
       string.  The strings <b>ind</b> and <b>ri</b> are undefined when not on their respective corners of the screen.

       Parameterized  versions  of the scrolling sequences are <b>indn</b> and <b>rin</b> which have the same semantics as <b>ind</b>
       and <b>ri</b> except that they take one parameter, and scroll that many lines.  They are also  undefined  except
       at the appropriate edge of the screen.

       The  <b>am</b>  capability  tells whether the cursor sticks at the right edge of the screen when text is output,
       but this does not necessarily apply to a <b>cuf1</b> from the last column.   The  only  local  motion  which  is
       defined  from the left edge is if <b>bw</b> is given, then a <b>cub1</b> from the left edge will move to the right edge
       of the previous line.  If <b>bw</b> is not given, the effect is undefined.  This is useful  for  drawing  a  box
       around the edge of the screen, for example.  If the terminal has switch selectable automatic margins, the
       <u>terminfo</u>  file  usually  assumes that this is on; i.e., <b>am</b>.  If the terminal has a command which moves to
       the first column of the next line, that command can be given as <b>nel</b> (newline).  It does not matter if the
       command clears the remainder of the current line, so if the terminal has no <b>cr</b> and <b>lf</b>  it  may  still  be
       possible to craft a working <b>nel</b> out of one or both of them.

       These  capabilities  suffice to describe hard-copy and “glass-tty” terminals.  Thus the model 33 teletype
       is described as

       33|tty33|tty|model 33 teletype,
               bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,

       while the Lear Siegler ADM-3 is described as

       adm3|3|lsi adm3,
               am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
               ind=^J, lines#24,

   <b>Parameterized</b> <b>Strings</b>
       Cursor addressing and other strings requiring parameters in the terminal are described by a parameterized
       string capability, with <u>printf</u>-like escapes such as <u>%x</u> in it.  For example, to address  the  cursor,  the
       <b>cup</b> capability is given, using two parameters: the line and column to address to.  (Lines and columns are
       numbered  from  zero and refer to the physical screen visible to the user, not to any unseen memory.)  If
       the terminal has memory relative cursor addressing, that can be indicated by <b>mrcup</b>.

       The parameter mechanism uses a stack and special <b>%</b> codes to manipulate it.   Typically  a  sequence  will
       push  one  of  the  parameters  onto the stack and then print it in some format.  Print (e.g., “%d”) is a
       special case.  Other operations, including “%t” pop their operand from the stack.  It is noted that  more
       complex operations are often necessary, e.g., in the <b>sgr</b> string.

       The <b>%</b> encodings have the following meanings:

       <b>%%</b>   outputs “%”

       <b>%</b><u>[[</u>:<u>]flags][width[.precision]][</u><b>doxXs</b><u>]</u>
            as in <b><a href="../man3/printf.3.html">printf</a></b>(3), flags are <u>[-+#]</u> and <u>space</u>.  Use a “:” to allow the next character to be a “-” flag,
            avoiding interpreting “%-” as an operator.

       <b>%c</b>   print <u>pop()</u> like %c in <b>printf</b>

       <b>%s</b>   print <u>pop()</u> like %s in <b>printf</b>

       <b>%p</b><u>[1-9]</u>
            push <u>i</u>'th parameter

       <b>%P</b><u>[a-z]</u>
            set dynamic variable <u>[a-z]</u> to <u>pop()</u>

       <b>%g</b><u>[a-z]</u>
            get dynamic variable <u>[a-z]</u> and push it

       <b>%P</b><u>[A-Z]</u>
            set static variable <u>[a-z]</u> to <u>pop()</u>

       <b>%g</b><u>[A-Z]</u>
            get static variable <u>[a-z]</u> and push it

            The  terms “static” and “dynamic” are misleading.  Historically, these are simply two different sets
            of variables, whose values are not reset between calls to <b><a href="../man3NCURSES/tparm.3NCURSES.html">tparm</a></b>(3NCURSES).  However,  that  fact  is
            not  documented  in other implementations.  Relying on it will adversely impact portability to other
            implementations:

            •   SVr2 curses supported <u>dynamic</u> variables.  Those are set only by a <b>%P</b> operator.  A <b>%g</b> for a given
                variable without first setting it with <b>%P</b>  will  give  unpredictable  results,  because  dynamic
                variables are an uninitialized local array on the stack in the <b>tparm</b> function.

            •   SVr3.2  curses  supported  <u>static</u>  variables.   Those  are  an  array  in the <u>TERMINAL</u> structure
                (declared in <b>term.h</b>), and are zeroed automatically when the  <b>setupterm</b>  function  allocates  the
                data.

            •   SVr4 curses made no further improvements to the <u>dynamic/static</u> variable feature.

            •   Solaris  XPG4  curses  does  not distinguish between <u>dynamic</u> and <u>static</u> variables.  They are the
                same.  Like SVr4 curses, XPG4 curses does not initialize these explicitly.

            •   Before version 6.3, <u>ncurses</u> stores both <u>dynamic</u> and  <u>static</u>  variables  in  persistent  storage,
                initialized to zeros.

            •   Beginning  with  version  6.3, <u>ncurses</u> stores <u>static</u> and <u>dynamic</u> variables in the same manner as
                SVr4.

                •   Unlike other implementations, <u>ncurses</u> zeros dynamic variables before  the  first  <b>%g</b>  or  <b>%P</b>
                    operator.

                •   Like  SVr2,  the  scope of dynamic variables in <u>ncurses</u> is within the current call to <b>tparm</b>.
                    Use static variables if persistent storage is needed.

       <b>%'</b><u>c</u><b>'</b> char constant <u>c</u>

       <b>%{</b><u>nn</u><b>}</b>
            integer constant <u>nn</u>

       <b>%l</b>   push strlen(pop)

       <b>%+</b>, <b>%-</b>, <b>%*</b>, <b>%/</b>, <b>%m</b>
            arithmetic (%m is <u>mod</u>): <u>push(pop()</u> <u>op</u> <u>pop())</u>

       <b>%&amp;</b>, <b>%|</b>, <b>%^</b>
            bit operations (“and”, “or” and exclusive “or”): <u>push(pop()</u> <u>op</u> <u>pop())</u>

       <b>%=</b>, <b>%&gt;</b>, <b>%&lt;</b>
            logical operations: <u>push(pop()</u> <u>op</u> <u>pop())</u>

       <b>%A</b>, <b>%O</b>
            logical “and” and “or” operations (for conditionals)

       <b>%!</b>, <b>%~</b>
            unary operations (logical and bit complement): <u>push(op</u> <u>pop())</u>

       <b>%i</b>   add 1 to first two parameters (for ANSI terminals)

       <b>%?</b> <u>expr</u> <b>%t</b> <u>thenpart</u> <b>%e</b> <u>elsepart</u> <b>%;</b>
            This forms an if-then-else.  The <b>%e</b> <u>elsepart</u> is optional.  Usually the <b>%?</b> <u>expr</u> part pushes  a  value
            onto  the  stack,  and  <b>%t</b>  pops  it from the stack, testing if it is nonzero (true).  If it is zero
            (false), control passes to the <b>%e</b> (else) part.

            It is possible to form else-if's a la Algol 68:
            <b>%?</b> c1 <b>%t</b> b1 <b>%e</b> c2 <b>%t</b> b2 <b>%e</b> c3 <b>%t</b> b3 <b>%e</b> c4 <b>%t</b> b4 <b>%e</b> <b>%;</b>

            where ci are conditions, bi are bodies.

            Use the <b>-f</b> option of <b>tic</b> or <b>infocmp</b> to see the structure of if-then-else's.  Some strings, e.g., <b>sgr</b>
            can be very complicated when written on one line.  The <b>-f</b> option splits the string into  lines  with
            the parts indented.

       Binary  operations  are  in  postfix  form with the operands in the usual order.  That is, to get x-5 one
       would use “%gx%{5}%-”.  <b>%P</b> and <b>%g</b> variables are persistent across escape-string evaluations.

       Consider the HP2645, which, to get to line 3 and column 12, needs to be  sent  \E&amp;a12c03Y  padded  for  6
       milliseconds.   The order of the lines and columns is inverted here, and the lines and column are printed
       as two digits.  The corresponding terminal description is expressed thus:
              cup=\E&amp;a%p2%dc%p1%dY$&lt;6&gt;,

       The Microterm ACT-IV needs the current line and column sent preceded by a <b>^T</b>, with the  line  and  column
       simply encoded in binary,
              cup=^T%p1%c%p2%c

       Terminals  which  use  “%c” need to be able to backspace the cursor (<b>cub1</b>), and to move the cursor up one
       line on the screen (<b>cuu1</b>).  This is necessary because it is not always safe to transmit <b>\n</b> <b>^D</b> and <b>\r</b>,  as
       the system may change or discard them.  (The library routines dealing with terminfo set tty modes so that
       tabs are never expanded, so \t is safe to send.  This turns out to be essential for the Ann Arbor 4080.)

       A final example is the LSI ADM-3A, which uses line and column offset by a space, thus
              cup=\E=%p1%' '%+%c%p2%' '%+%c

       After  sending “\E=”, this pushes the first parameter, pushes the ASCII value for a space (32), adds them
       (pushing the sum on the stack in place of the two previous values) and outputs that value as a character.
       Then the same is done for the second parameter.  More complex arithmetic is possible using the stack.

   <b>Cursor</b> <b>Motions</b>
       If the terminal has a fast way to home the cursor (to very upper left corner of screen) then this can  be
       given as <b>home</b>; similarly a fast way of getting to the lower left-hand corner can be given as <b>ll</b>; this may
       involve  going  up with <b>cuu1</b> from the home position, but a program should never do this itself (unless <b>ll</b>
       does) because it can make no assumption about the effect of moving up from the home position.  Note  that
       the  home  position  is  the  same  as  addressing to (0,0): to the top left corner of the screen, not of
       memory.  (Thus, the \EH sequence on HP terminals cannot be used for <b>home</b>.)

       If the terminal has line or column absolute cursor addressing, these can be  given  as  single  parameter
       capabilities  <b>hpa</b>  (horizontal  position absolute) and <b>vpa</b> (vertical position absolute).  Sometimes these
       are shorter than the more general two parameter sequence  (as  with  the  hp2645)  and  can  be  used  in
       preference to <b>cup</b>.  If there are parameterized local motions (e.g., move <u>n</u> spaces to the right) these can
       be given as <b>cud</b>, <b>cub</b>, <b>cuf</b>, and <b>cuu</b> with a single parameter indicating how many spaces to move.  These are
       primarily useful if the terminal does not have <b>cup</b>, such as the TEKTRONIX 4025.

       If  the  terminal  needs to be in a special mode when running a program that uses these capabilities, the
       codes to enter and exit this mode can be given as <b>smcup</b>  and  <b>rmcup</b>.   This  arises,  for  example,  from
       terminals  like  the Concept with more than one page of memory.  If the terminal has only memory relative
       cursor addressing and not screen relative cursor addressing, a one screen-sized window must be fixed into
       the terminal for cursor addressing to work properly.  This is also used for  the  TEKTRONIX  4025,  where
       <b>smcup</b>  sets the command character to be the one used by terminfo.  If the <b>smcup</b> sequence will not restore
       the screen after an <b>rmcup</b> sequence is output (to the state prior to outputting <b>rmcup</b>), specify <b>nrrmc</b>.

   <b>Margins</b>
       SVr4 (and X/Open Curses) list several string capabilities for setting margins.  Two were intended for use
       with terminals, and another six were intended for use with printers.

       •   The two terminal capabilities assume that the terminal may have the capability of  setting  the  left
           and/or right margin at the current cursor column position.

       •   The printer capabilities assume that the printer may have two types of capability:

           •   the ability to set a top and/or bottom margin using the current line position, and

           •   parameterized  capabilities  for setting the top, bottom, left, right margins given the number of
               lines or columns.

       In practice, the categorization into “terminal” and “printer” is not suitable:

       •   The AT&amp;T SVr4 terminal database uses <b>smgl</b> four times, for AT&amp;T hardware.

           Three of the four are printers.  They lack the ability to set left/right margins  by  specifying  the
           column.

       •   Other (non-AT&amp;T) terminals may support margins but using different assumptions from AT&amp;T.

           For  instance,  the  DEC VT420 supports left/right margins, but only using a column parameter.  As an
           added complication, the VT420 uses two settings to fully enable left/right margins (left/right margin
           mode, and origin mode).  The former enables the margins, which causes printed  text  to  wrap  within
           margins, but the latter is needed to prevent cursor-addressing outside those margins.

       •   Both  DEC VT420 left/right margins are set with a single control sequence.  If either is omitted, the
           corresponding margin is set to the left or right edge of the display (rather than leaving the  margin
           unmodified).

       These are the margin-related capabilities:

                                  <b>Name</b>    <b>Description</b>
                                  ───────────────────────────────────────────────────
                                  <b>smgl</b>    Set left margin at current column
                                  <b>smgr</b>    Set right margin at current column
                                  <b>smgb</b>    Set bottom margin at current line
                                  <b>smgt</b>    Set top margin at current line
                                  <b>smgbp</b>   Set bottom margin at line <u>N</u>
                                  <b>smglp</b>   Set left margin at column <u>N</u>
                                  <b>smgrp</b>   Set right margin at column <u>N</u>
                                  <b>smgtp</b>   Set top margin at line <u>N</u>
                                  <b>smglr</b>   Set both left and right margins to <u>L</u> and <u>R</u>
                                  <b>smgtb</b>   Set both top and bottom margins to <u>T</u> and <u>B</u>

       When writing an application that uses these string capabilities, the pairs should be first checked to see
       if each capability in the pair is set or only one is set:

       •   If both <b>smglp</b> and <b>smgrp</b> are set, each is used with a single argument, <u>N</u>, that gives the column number
           of the left and right margin, respectively.

       •   If both <b>smgtp</b> and <b>smgbp</b> are set, each is used to set the top and bottom margin, respectively:

           •   <b>smgtp</b> is used with a single argument, <u>N</u>, the line number of the top margin.

           •   <b>smgbp</b>  is  used  with two arguments, <u>N</u> and <u>M</u>, that give the line number of the bottom margin, the
               first counting from the top  of  the  page  and  the  second  counting  from  the  bottom.   This
               accommodates the two styles of specifying the bottom margin in different manufacturers' printers.

           When  designing  a  terminfo entry for a printer that has a settable bottom margin, only the first or
           second argument should be used, depending on the printer.  When developing an application  that  uses
           <b>smgbp</b> to set the bottom margin, both arguments must be given.

       Conversely, when only one capability in the pair is set:

       •   If  only  one of <b>smglp</b> and <b>smgrp</b> is set, then it is used with two arguments, the column number of the
           left and right margins, in that order.

       •   Likewise, if only one of <b>smgtp</b> and <b>smgbp</b> is set, then it is used with two arguments that give the top
           and bottom margins, in that order, counting from the top of the page.

           When designing a terminfo entry for a printer that requires setting both left and right  or  top  and
           bottom  margins  simultaneously,  only one capability in the pairs <b>smglp</b> and <b>smgrp</b> or <b>smgtp</b> and <b>smgbp</b>
           should be defined, leaving the other unset.

       Except for very old terminal descriptions, e.g., those developed for  SVr4,  the  scheme  just  described
       should  be  considered  obsolete.   An  improved  set of capabilities was added late in the SVr4 releases
       (<b>smglr</b> and <b>smgtb</b>), which explicitly use two parameters for setting the left/right or top/bottom margins.

       When setting margins, the line- and column-values are zero-based.

       The <b>mgc</b> string capability should be defined.  Applications such as <b><a href="../man1/tabs.1.html">tabs</a></b>(1) rely upon this  to  reset  all
       margins.

   <b>Area</b> <b>Clears</b>
       If  the  terminal can clear from the current position to the end of the line, leaving the cursor where it
       is, this should be given as <b>el</b>.  If the terminal can clear from the beginning of the line to the  current
       position  inclusive,  leaving  the  cursor where it is, this should be given as <b>el1</b>.  If the terminal can
       clear from the current position to the end of the display, then this should be given as <b>ed</b>.  <b>Ed</b>  is  only
       defined  from  the  first  column  of  a line.  (Thus, it can be simulated by a request to delete a large
       number of lines, if a true <b>ed</b> is not available.)

   <b>Insert/Delete</b> <b>Line</b> <b>and</b> <b>Vertical</b> <b>Motions</b>
       If the terminal can open a new blank line before the line where the cursor is, this should  be  given  as
       <b>il1</b>; this is done only from the first position of a line.  The cursor must then appear on the newly blank
       line.  If the terminal can delete the line which the cursor is on, then this should be given as <b>dl1</b>; this
       is  done  only  from  the first position on the line to be deleted.  Versions of <b>il1</b> and <b>dl1</b> which take a
       single parameter and insert or delete that many lines can be given as <b>il</b> and <b>dl</b>.

       If the terminal has a settable scrolling region (like the vt100) the command to set this can be described
       with the <b>csr</b> capability, which takes two parameters: the top and bottom lines of  the  scrolling  region.
       The cursor position is, alas, undefined after using this command.

       It  is  possible to get the effect of insert or delete line using <b>csr</b> on a properly chosen region; the <b>sc</b>
       and <b>rc</b> (save and restore cursor) commands may be useful for ensuring that your synthesized  insert/delete
       string  does  not  move  the  cursor.   (Note  that  the  <b><a href="../man3NCURSES/ncurses.3NCURSES.html">ncurses</a></b>(3NCURSES)  library  does this synthesis
       automatically, so you need not compose insert/delete strings for an entry with <b>csr</b>).

       Yet another way to construct insert and delete might be to use a combination of index  with  the  memory-
       lock feature found on some terminals (like the HP-700/90 series, which however also has insert/delete).

       Inserting  lines  at  the  top or bottom of the screen can also be done using <b>ri</b> or <b>ind</b> on many terminals
       without a true insert/delete line, and is often faster even on terminals with those features.

       The Boolean <b>non_dest_scroll_region</b> should be set if each scrolling window is effectively a view port on a
       screen-sized canvas.  To test for this capability, create a scrolling region in the middle of the screen,
       write something to the bottom line, move the cursor to the top of the region, and do <b>ri</b> followed  by  <b>dl1</b>
       or  <b>ind</b>.   If the data scrolled off the bottom of the region by the <b>ri</b> re-appears, then scrolling is non-
       destructive.  System V and X/Open Curses expect that <b>ind</b>, <b>ri</b>, <b>indn</b>, and  <b>rin</b>  will  simulate  destructive
       scrolling;  their  documentation  cautions  you  not  to  define  <b>csr</b>  unless  this is true.  This <b>curses</b>
       implementation is more liberal and will do explicit erases after scrolling if <b>ndsrc</b> is defined.

       If the terminal has the ability to define a window as part of  memory,  which  all  commands  affect,  it
       should  be given as the parameterized string <b>wind</b>.  The four parameters are the starting and ending lines
       in memory and the starting and ending columns in memory, in that order.

       If the terminal can retain display memory above, then the <b>da</b>  capability  should  be  given;  if  display
       memory  can be retained below, then <b>db</b> should be given.  These indicate that deleting a line or scrolling
       may bring non-blank lines up from below or that scrolling back with <b>ri</b> may bring down non-blank lines.

   <b>Insert/Delete</b> <b>Character</b>
       There are two basic kinds of intelligent terminals with respect to insert/delete character which  can  be
       described  using <u>terminfo</u>.  The most common insert/delete character operations affect only the characters
       on the current line and shift characters off the end of the line rigidly.  Other terminals, such  as  the
       Concept  100 and the Perkin Elmer Owl, make a distinction between typed and untyped blanks on the screen,
       shifting upon an insert or delete only to an untyped blank on the screen which is either  eliminated,  or
       expanded to two untyped blanks.

       You  can determine the kind of terminal you have by clearing the screen and then typing text separated by
       cursor motions.  Type “abc    def” using local cursor motions (not spaces)  between  the  “abc”  and  the
       “def”.   Then  position  the  cursor  before  the  “abc”  and put the terminal in insert mode.  If typing
       characters causes the rest of the line to shift rigidly and characters to fall off  the  end,  then  your
       terminal  does  not  distinguish  between  blanks and untyped positions.  If the “abc” shifts over to the
       “def” which then move together around the end of the current line and onto the next as  you  insert,  you
       have the second type of terminal, and should give the capability <b>in</b>, which stands for “insert null”.

       While  these  are  two logically separate attributes (one line versus multi-line insert mode, and special
       treatment of untyped spaces) we have seen no terminals whose insert mode cannot  be  described  with  the
       single attribute.

       Terminfo  can  describe  both  terminals  which  have  an  insert mode, and terminals which send a simple
       sequence to open a blank position on the current line.  Give as <b>smir</b> the  sequence  to  get  into  insert
       mode.   Give  as <b>rmir</b> the sequence to leave insert mode.  Now give as <b>ich1</b> any sequence needed to be sent
       just before sending the character to be inserted.  Most terminals with a true insert mode will  not  give
       <b>ich1</b>; terminals which send a sequence to open a screen position should give it here.

       If  your  terminal has both, insert mode is usually preferable to <b>ich1</b>.  Technically, you should not give
       both unless the terminal actually requires both to be used in combination.  Accordingly, some  non-curses
       applications  get  confused  if  both  are  present; the symptom is doubled characters in an update using
       insert.  This requirement is now rare; most <b>ich</b> sequences do not require previous  smir,  and  most  smir
       insert  modes do not require <b>ich1</b> before each character.  Therefore, the new <b>curses</b> actually assumes this
       is the case and uses either <b>rmir</b>/<b>smir</b> or <b>ich</b>/<b>ich1</b> as appropriate (but not both).  If you have to write an
       entry to be used under new curses for a terminal old enough to need both, include the <b>rmir</b>/<b>smir</b> sequences
       in <b>ich1</b>.

       If post insert padding is needed, give this as a number of milliseconds in <b>ip</b>  (a  string  option).   Any
       other  sequence  which may need to be sent after an insert of a single character may also be given in <b>ip</b>.
       If your terminal needs both to be placed into an “insert  mode”  and  a  special  code  to  precede  each
       inserted  character,  then  both  <b>smir</b>/<b>rmir</b>  and  <b>ich1</b>  can  be  given,  and  both will be used.  The <b>ich</b>
       capability, with one parameter, <u>n</u>, will repeat the effects of <b>ich1</b> <u>n</u> times.

       If padding is necessary between characters typed while not in insert mode,  give  this  as  a  number  of
       milliseconds padding in <b>rmp</b>.

       It  is  occasionally  necessary to move around while in insert mode to delete characters on the same line
       (e.g., if there is a tab after the insertion position).  If your terminal allows motion while  in  insert
       mode  you  can give the capability <b>mir</b> to speed up inserting in this case.  Omitting <b>mir</b> will affect only
       speed.  Some terminals (notably Datamedia's) must not have <b>mir</b> because  of  the  way  their  insert  mode
       works.

       Finally,  you  can  specify  <b>dch1</b>  to  delete  a  single  character, <b>dch</b> with one parameter, <u>n</u>, to delete
       <u>n</u>characters, and delete mode by giving <b>smdc</b> and <b>rmdc</b> to enter and exit delete mode (any mode the terminal
       needs to be placed in for <b>dch1</b> to work).

       A command to erase <u>n</u> characters (equivalent to outputting <u>n</u> blanks without  moving  the  cursor)  can  be
       given as <b>ech</b> with one parameter.

   <b>Highlighting,</b> <b>Underlining,</b> <b>and</b> <b>Visible</b> <b>Bells</b>
       If  your  terminal  has  one or more kinds of display attributes, these can be represented in a number of
       different ways.  You should choose one display form as <u>standout</u> <u>mode</u>, representing a good, high contrast,
       easy-on-the-eyes, format for highlighting error messages and other attention getters.   (If  you  have  a
       choice, reverse video plus half-bright is good, or reverse video alone.)  The sequences to enter and exit
       standout  mode  are  given as <b>smso</b> and <b>rmso</b>, respectively.  If the code to change into or out of standout
       mode leaves one or even two blank spaces on the screen, as the TVI 912 and  Teleray  1061  do,  then  <b>xmc</b>
       should be given to tell how many spaces are left.

       Codes  to  begin  underlining  and  end  underlining  can be given as <b>smul</b> and <b>rmul</b> respectively.  If the
       terminal has a code to underline the current character and move the cursor one space to the  right,  such
       as the Microterm Mime, this can be given as <b>uc</b>.

       Other  capabilities  to  enter  various  highlighting  modes include <b>blink</b> (blinking) <b>bold</b> (bold or extra
       bright) <b>dim</b> (dim or half-bright) <b>invis</b> (blanking or invisible text) <b>prot</b> (protected) <b>rev</b> (reverse  video)
       <b>sgr0</b>  (turn off <u>all</u> attribute modes) <b>smacs</b> (enter alternate character set mode) and <b>rmacs</b> (exit alternate
       character set mode).  Turning on any of these modes singly may or may not turn off other modes.

       If there is a sequence to set arbitrary  combinations  of  modes,  this  should  be  given  as  <b>sgr</b>  (set
       attributes),  taking  9  parameters.   Each parameter is either zero (0) or nonzero, as the corresponding
       attribute is on or off.  The 9 parameters are, in order: standout, underline, reverse, blink, dim,  bold,
       blank,  protect,  alternate  character set.  Not all modes need be supported by <b>sgr</b>, only those for which
       corresponding separate attribute commands exist.

       For example, the DEC vt220 supports most of the modes:

                                    <b>tparm</b> <b>Parameter</b>   <b>Attribute</b>    <b>Escape</b> <b>Sequence</b>
                                    ────────────────────────────────────────────────
                                    none              none         \E[0m
                                    p1                standout     \E[0;1;7m
                                    p2                underline    \E[0;4m
                                    p3                reverse      \E[0;7m
                                    p4                blink        \E[0;5m
                                    p5                dim          not available
                                    p6                bold         \E[0;1m
                                    p7                invis        \E[0;8m
                                    p8                protect      not used
                                    p9                altcharset   ^O (off) ^N (on)

       We begin each escape sequence by turning off any existing modes, since there is no quick way to determine
       whether they are active.  Standout is set up to be the  combination  of  reverse  and  bold.   The  vt220
       terminal  has a protect mode, though it is not commonly used in sgr because it protects characters on the
       screen from the host's erasures.  The altcharset mode also is different in that it is either  ^O  or  ^N,
       depending  on  whether  it  is  off  or  on.   If  all  modes  are  turned  on, the resulting sequence is
       \E[0;1;4;5;7;8m^N.

       Some sequences are common to different modes.  For example, ;7 is output when either p1 or  p3  is  true,
       that is, if either standout or reverse modes are turned on.

       Writing out the above sequences, along with their dependencies yields

                                  <b>Sequence</b>   <b>When</b> <b>to</b> <b>Output</b>      <b>terminfo</b> <b>Translation</b>
                                  ────────────────────────────────────────────────────
                                  \E[0       always              \E[0
                                  ;1         if p1 or p6         %?%p1%p6%|%t;1%;
                                  ;4         if p2               %?%p2%|%t;4%;
                                  ;5         if p4               %?%p4%|%t;5%;
                                  ;7         if p1 or p3         %?%p1%p3%|%t;7%;
                                  ;8         if p7               %?%p7%|%t;8%;
                                  m          always              m
                                  ^N or ^O   if p9 ^N, else ^O   %?%p9%t^N%e^O%;

       Putting this all together into the sgr sequence gives:

           sgr=\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p4%t;5%;
               %?%p1%p3%|%t;7%;%?%p7%t;8%;m%?%p9%t\016%e\017%;,

       Remember  that  if  you  specify sgr, you must also specify sgr0.  Also, some implementations rely on sgr
       being given if sgr0 is, Not all terminfo entries necessarily have an sgr string, however.  Many  terminfo
       entries  are  derived  from termcap entries which have no sgr string.  The only drawback to adding an sgr
       string is that termcap also assumes that sgr0 does not exit alternate character set mode.

       Terminals with the “magic cookie” glitch (<b>xmc</b>) deposit special “cookies” when they  receive  mode-setting
       sequences,  which  affect  the  display algorithm rather than having extra bits for each character.  Some
       terminals, such as the HP 2621, automatically leave standout mode when they move to a  new  line  or  the
       cursor  is addressed.  Programs using standout mode should exit standout mode before moving the cursor or
       sending a newline, unless the <b>msgr</b> capability, asserting that it is safe to move  in  standout  mode,  is
       present.

       If  the  terminal has a way of flashing the screen to indicate an error quietly (a bell replacement) then
       this can be given as <b>flash</b>; it must not move the cursor.

       If the cursor needs to be made more visible than normal when it is not on the bottom line (to  make,  for
       example,  a non-blinking underline into an easier to find block or blinking underline) give this sequence
       as <b>cvvis</b>.  If there is a way to make the cursor completely invisible, give that as <b>civis</b>.  The capability
       <b>cnorm</b> should be given which undoes the effects of both of these modes.

       If your terminal correctly generates underlined characters (with no special codes needed) even though  it
       does  not overstrike, then you should give the capability <b>ul</b>.  If a character overstriking another leaves
       both characters on the screen, specify the capability <b>os</b>.  If overstrikes are erasable with a blank, then
       this should be indicated by giving <b>eo</b>.

   <b>Keypad</b> <b>and</b> <b>Function</b> <b>Keys</b>
       If the terminal has a keypad that transmits codes when the keys are  pressed,  this  information  can  be
       given.   Note  that  it  is  not  possible to handle terminals where the keypad only works in local (this
       applies, for example, to the unshifted HP 2621 keys).  If the keypad  can  be  set  to  transmit  or  not
       transmit, give these codes as <b>smkx</b> and <b>rmkx</b>.  Otherwise the keypad is assumed to always transmit.

       The codes sent by the left arrow, right arrow, up arrow, down arrow, and home keys can be given as <b>kcub1,</b>
       <b>kcuf1,</b>  <b>kcuu1,</b>  <b>kcud1,</b>  and <b>khome</b> respectively.  If there are function keys such as f0, f1, ..., f10, the
       codes they send can be given as <b>kf0,</b> <b>kf1,</b> <b>...,</b> <b>kf10</b>.  If these keys have labels other than the default f0
       through f10, the labels can be given as <b>lf0,</b> <b>lf1,</b> <b>...,</b> <b>lf10</b>.

       The codes transmitted by certain other special keys can be given:

       •   <b>kll</b> (home down),

       •   <b>kbs</b> (backspace),

       •   <b>ktbc</b> (clear all tabs),

       •   <b>kctab</b> (clear the tab stop in this column),

       •   <b>kclr</b> (clear screen or erase key),

       •   <b>kdch1</b> (delete character),

       •   <b>kdl1</b> (delete line),

       •   <b>krmir</b> (exit insert mode),

       •   <b>kel</b> (clear to end of line),

       •   <b>ked</b> (clear to end of screen),

       •   <b>kich1</b> (insert character or enter insert mode),

       •   <b>kil1</b> (insert line),

       •   <b>knp</b> (next page),

       •   <b>kpp</b> (previous page),

       •   <b>kind</b> (scroll forward/down),

       •   <b>kri</b> (scroll backward/up),

       •   <b>khts</b> (set a tab stop in this column).

       In addition, if the keypad has a 3 by 3 array of keys including the four arrow keys, the other five  keys
       can  be  given  as  <b>ka1</b>,  <b>ka3</b>,  <b>kb2</b>,  <b>kc1</b>,  and  <b>kc3</b>.  These keys are useful when the effects of a 3 by 3
       directional pad are needed.

       Strings to program function keys can be given as <b>pfkey</b>, <b>pfloc</b>, and  <b>pfx</b>.   A  string  to  program  screen
       labels  should  be specified as <b>pln</b>.  Each of these strings takes two parameters: the function key number
       to program (from 0 to 10) and the string to program it with.  Function key numbers out of this range  may
       program  undefined  keys in a terminal dependent manner.  The difference between the capabilities is that
       <b>pfkey</b> causes pressing the given key to be the same as the user typing the given string; <b>pfloc</b> causes  the
       string  to  be  executed  by  the  terminal  in local; and <b>pfx</b> causes the string to be transmitted to the
       computer.

       The capabilities <b>nlab</b>, <b>lw</b> and <b>lh</b> define the number of programmable screen  labels  and  their  width  and
       height.   If  there  are  commands  to  turn  the labels on and off, give them in <b>smln</b> and <b>rmln</b>.  <b>smln</b> is
       normally output after one or more pln sequences to make sure that the change becomes visible.

   <b>Tabs</b> <b>and</b> <b>Initialization</b>
       A few capabilities are used only for tabs:

       •   If the terminal has hardware tabs, the command to advance to the next tab stop can  be  given  as  <b>ht</b>
           (usually control/I).

       •   A “back-tab” command which moves leftward to the preceding tab stop can be given as <b>cbt</b>.

           By  convention,  if  the  teletype modes indicate that tabs are being expanded by the computer rather
           than being sent to the terminal, programs should not use <b>ht</b> or <b>cbt</b> even if they  are  present,  since
           the user may not have the tab stops properly set.

       •   If the terminal has hardware tabs which are initially set every <u>n</u> spaces when the terminal is powered
           up, the numeric parameter <b>it</b> is given, showing the number of spaces the tabs are set to.

           The  <b>it</b>  capability  is  normally  used  by the <b>tset</b> command to determine whether to set the mode for
           hardware tab expansion, and whether to set the tab stops.  If the terminal has tab stops that can  be
           saved in non-volatile memory, the terminfo description can assume that they are properly set.

       Other capabilities include

       •   <b>is1</b>, <b>is2</b>, and <b>is3</b>, initialization strings for the terminal,

       •   <b>iprog</b>, the path name of a program to be run to initialize the terminal,

       •   and <b>if</b>, the name of a file containing long initialization strings.

       These  strings  are  expected  to  set  the  terminal into modes consistent with the rest of the terminfo
       description.  They are normally sent to the terminal, by the <u>init</u> option of the <b>tput</b> program,  each  time
       the user logs in.  They will be printed in the following order:

              run the program
                     <b>iprog</b>

              output
                     <b>is1</b> and
                     <b>is2</b>

              set the margins using
                     <b>mgc</b> or
                     <b>smglp</b> and <b>smgrp</b> or
                     <b>smgl</b> and <b>smgr</b>

              set tabs using
                     <b>tbc</b> and <b>hts</b>

              print the file
                     <b>if</b>

              and finally output
                     <b>is3</b>.

       Most  initialization  is done with <b>is2</b>.  Special terminal modes can be set up without duplicating strings
       by putting the common sequences in <b>is2</b> and special cases in <b>is1</b> and <b>is3</b>.

       A set of sequences that does a harder reset from a totally unknown state can be given as <b>rs1</b>, <b>rs2</b>, <b>rf</b> and
       <b>rs3</b>, analogous to <b>is1</b> <b>,</b> <b>is2</b> <b>,</b> <b>if</b> and <b>is3</b> respectively.  These strings are output by <u>reset</u> option of <b>tput</b>,
       or by the <b>reset</b> program (an alias of <b>tset</b>), which is used when the terminal gets  into  a  wedged  state.
       Commands  are  normally placed in <b>rs1</b>, <b>rs2</b> <b>rs3</b> and <b>rf</b> only if they produce annoying effects on the screen
       and are not necessary when logging in.  For example, the command to set the  vt100  into  80-column  mode
       would  normally be part of <b>is2</b>, but it causes an annoying glitch of the screen and is not normally needed
       since the terminal is usually already in 80-column mode.

       The <b>reset</b> program writes strings including <b>iprog</b>, etc., in the same order as the <u>init</u> program, using <b>rs1</b>,
       etc., instead of <b>is1</b>, etc.  If any of <b>rs1</b>, <b>rs2</b>, <b>rs3</b>, or <b>rf</b> reset  capability  strings  are  missing,  the
       <b>reset</b> program falls back upon the corresponding initialization capability string.

       If  there are commands to set and clear tab stops, they can be given as <b>tbc</b> (clear all tab stops) and <b>hts</b>
       (set a tab stop in the current column of every line).  If a more complex sequence is needed  to  set  the
       tabs than can be described by this, the sequence can be placed in <b>is2</b> or <b>if</b>.

       The  <b>tput</b>  <b>reset</b> command uses the same capability strings as the <b>reset</b> command, although the two programs
       (<b>tput</b> and <b>reset</b>) provide different command-line options.

       In practice, these terminfo capabilities are not often used in initialization of tabs  (though  they  are
       required for the <b>tabs</b> program):

       •   Almost  all hardware terminals (at least those which supported tabs) initialized those to every <u>eight</u>
           columns:

           The only exception was the AT&amp;T 2300 series, which set tabs to every <u>five</u> columns.

       •   In particular, developers of the hardware terminals which are commonly  used  as  models  for  modern
           terminal emulators provided documentation demonstrating that <u>eight</u> columns were the standard.

       •   Because  of this, the terminal initialization programs <b>tput</b> and <b>tset</b> use the <b>tbc</b> (<b>clear_all_tabs</b>) and
           <b>hts</b> (<b>set_tab</b>) capabilities directly only when the <b>it</b> (<b>init_tabs</b>) capability is set to a  value  other
           than <u>eight</u>.

   <b>Delays</b> <b>and</b> <b>Padding</b>
       Many  older  and  slower terminals do not support either XON/XOFF or DTR handshaking, including hard copy
       terminals and some very archaic CRTs (including, for example, DEC VT100s).   These  may  require  padding
       characters after certain cursor motions and screen changes.

       If  the  terminal  uses xon/xoff handshaking for flow control (that is, it automatically emits ^S back to
       the host when its input buffers are close to full), set <b>xon</b>.  This capability suppresses the emission  of
       padding.   You  can  also  set  it for memory-mapped console devices effectively that do not have a speed
       limit.  Padding information should still be included so that routines can  make  better  decisions  about
       relative costs, but actual pad characters will not be transmitted.

       If  <b>pb</b>  (padding  baud rate) is given, padding is suppressed at baud rates below the value of <b>pb</b>.  If the
       entry has no padding baud rate, then whether padding is emitted or not is completely controlled by <b>xon</b>.

       If the terminal requires other than a null (zero) character as a pad, then this  can  be  given  as  <b>pad</b>.
       Only the first character of the <b>pad</b> string is used.

   <b>Status</b> <b>Lines</b>
       Some  terminals  have an extra “status line” which is not normally used by software (and thus not counted
       in the terminal's <b>lines</b> capability).

       The simplest case is a status line which is cursor-addressable but not part of the main scrolling  region
       on  the  screen; the Heathkit H19 has a status line of this kind, as would a 24-line VT100 with a 23-line
       scrolling region set up on initialization.  This situation is indicated by the <b>hs</b> capability.

       Some terminals with status lines need special  sequences  to  access  the  status  line.   These  may  be
       expressed  as  a string with single parameter <b>tsl</b> which takes the cursor to a given zero-origin column on
       the status line.  The capability <b>fsl</b> must return to the main-screen cursor positions before the last <b>tsl</b>.
       You may need to embed the string values of <b>sc</b> (save cursor) and <b>rc</b> (restore cursor) in  <b>tsl</b>  and  <b>fsl</b>  to
       accomplish this.

       The  status  line  is  normally  assumed  to  be the same width as the width of the terminal.  If this is
       untrue, you can specify it with the numeric capability <b>wsl</b>.

       A command to erase or blank the status line may be specified as <b>dsl</b>.

       The Boolean capability <b>eslok</b> specifies that escape sequences, tabs, etc., work ordinarily in  the  status
       line.

       The  <u>ncurses</u> implementation does not yet use any of these capabilities.  They are documented here in case
       they ever become important.

   <b>Line</b> <b>Graphics</b>
       Many terminals have alternate character sets useful for forms-drawing.  Terminfo and <b>curses</b> have built-in
       support for most of the drawing characters supported by the VT100, with some  characters  from  the  AT&amp;T
       4410v1 added.  This alternate character set may be specified by the <b>acsc</b> capability.

                          <b>acsc</b>
       <b>ACS</b> <b>Name</b>      <b>Value</b>   <b>Symbol</b>   <b>ASCII</b> <b>Fallback</b> <b>/</b> <b>Glyph</b> <b>Name</b>
       ──────────────────────────────────────────────────────────────────────────────────────────────────────────
       <b>ACS_RARROW</b>    0x2b      +      <b>&gt;</b>  arrow pointing right
       <b>ACS_LARROW</b>    0x2c      ,      <b>&lt;</b>  arrow pointing left
       <b>ACS_UARROW</b>    0x2d      -      <b>^</b>  arrow pointing up
       <b>ACS_DARROW</b>    0x2e      .      <b>v</b>  arrow pointing down
       <b>ACS_BLOCK</b>     0x30      0      <b>#</b>  solid square block
       <b>ACS_DIAMOND</b>   0x60      `      <b>+</b>  diamond
       <b>ACS_CKBOARD</b>   0x61      a      <b>:</b>  checker board (stipple)
       <b>ACS_DEGREE</b>    0x66      f      <b>\</b>  degree symbol
       <b>ACS_PLMINUS</b>   0x67      g      <b>#</b>  plus/minus
       <b>ACS_BOARD</b>     0x68      h      <b>#</b>  board of squares
       <b>ACS_LANTERN</b>   0x69      i      <b>#</b>  lantern symbol
       <b>ACS_LRCORNER</b>  0x6a      j      <b>+</b>  lower right corner
       <b>ACS_URCORNER</b>  0x6b      k      <b>+</b>  upper right corner
       <b>ACS_ULCORNER</b>  0x6c      l      <b>+</b>  upper left corner
       <b>ACS_LLCORNER</b>  0x6d      m      <b>+</b>  lower left corner
       <b>ACS_PLUS</b>      0x6e      n      <b>+</b>  large plus or crossover
       <b>ACS_S1</b>        0x6f      o      <b>~</b>  scan line 1
       <b>ACS_S3</b>        0x70      p      <b>-</b>  scan line 3
       <b>ACS_HLINE</b>     0x71      q      <b>-</b>  horizontal line
       <b>ACS_S7</b>        0x72      r      <b>-</b>  scan line 7
       <b>ACS_S9</b>        0x73      s      <b>_</b>  scan line 9
       <b>ACS_LTEE</b>      0x74      t      <b>+</b>  tee pointing right
       <b>ACS_RTEE</b>      0x75      u      <b>+</b>  tee pointing left
       <b>ACS_BTEE</b>      0x76      v      <b>+</b>  tee pointing up
       <b>ACS_TTEE</b>      0x77      w      <b>+</b>  tee pointing down
       <b>ACS_VLINE</b>     0x78      x      <b>|</b>  vertical line
       <b>ACS_LEQUAL</b>    0x79      y      <b>&lt;</b>  less-than-or-equal-to
       <b>ACS_GEQUAL</b>    0x7a      z      <b>&gt;</b>  greater-than-or-equal-to
       <b>ACS_PI</b>        0x7b      {      <b>*</b>  greek pi
       <b>ACS_NEQUAL</b>    0x7c      |      <b>!</b>  not-equal
       <b>ACS_STERLING</b>  0x7d      }      <b>f</b>  UK pound sign
       <b>ACS_BULLET</b>    0x7e      ~      <b>o</b>  bullet

       A few notes apply to the table itself:

       •   X/Open  Curses  incorrectly  states  that  the  mapping  for  <u>lantern</u>  is uppercase “I” although Unix
           implementations use the lowercase “i” mapping.

       •   The DEC VT100 implemented graphics using the alternate character set feature,  temporarily  switching
           <u>modes</u>  and  sending  characters  in  the  range 0x60 (96) to 0x7e (126) (the <b>acsc</b> <b>Value</b> column in the
           table).

       •   The AT&amp;T terminal added graphics characters outside that range.

           Some of the characters within the range do not match the VT100; presumably they were used in the AT&amp;T
           terminal: <u>board</u> <u>of</u> <u>squares</u> replaces the VT100 <u>newline</u> symbol, while <u>lantern</u> <u>symbol</u> replaces the VT100
           <u>vertical</u> <u>tab</u> symbol.  The other VT100 symbols for control characters (<u>horizontal</u> <u>tab</u>, <u>carriage</u> <u>return</u>
           and <u>line-feed</u>) are not (re)used in curses.

       The best way to define a new device's graphics set is to add a column to a copy of this  table  for  your
       terminal,  giving the character which (when emitted between <b>smacs</b>/<b>rmacs</b> switches) will be rendered as the
       corresponding graphic.  Then read off the VT100/your terminal character pairs right to left in  sequence;
       these become the ACSC string.

   <b>Color</b> <b>Handling</b>
       The  curses  library  functions  <b>init_pair</b>  and  <b>init_color</b>  manipulate  the <u>color</u> <u>pairs</u> and <u>color</u> <u>values</u>
       discussed in this section (see <b><a href="../man3NCURSES/color.3NCURSES.html">color</a></b>(3NCURSES) for details on these and related functions).

       Most color terminals are either “Tektronix-like” or “HP-like”:

       •   Tektronix-like terminals have a predefined set of <u>N</u> colors (where  <u>N</u>  is  usually  8),  and  can  set
           character-cell foreground and background colors independently, mixing them into <u>N</u> * <u>N</u> color pairs.

       •   On  HP-like terminals, the user must set each color pair up separately (foreground and background are
           not independently settable).  Up to <u>M</u> color pairs may be set up from  2*<u>M</u>  different  colors.   ANSI-
           compatible terminals are Tektronix-like.

       Some  basic  color capabilities are independent of the color method.  The numeric capabilities <b>colors</b> and
       <b>pairs</b> specify the maximum numbers of colors and color pairs that can be displayed simultaneously.  The <b>op</b>
       (original pair) string resets foreground and background colors to their default values for the  terminal.
       The  <b>oc</b> string resets all colors or color pairs to their default values for the terminal.  Some terminals
       (including many PC terminal emulators) erase screen areas with the current background color  rather  than
       the power-up default background; these should have the Boolean capability <b>bce</b>.

       While  the  curses  library  works  with  <u>color</u>  <u>pairs</u>  (reflecting  the inability of some devices to set
       foreground and background colors independently),  there  are  separate  capabilities  for  setting  these
       features:

       •   To  change  the  current  foreground or background color on a Tektronix-type terminal, use <b>setaf</b> (set
           ANSI foreground) and <b>setab</b> (set ANSI background) or <b>setf</b> (set foreground) and <b>setb</b> (set  background).
           These  take  one parameter, the color number.  The SVr4 documentation describes only <b>setaf</b>/<b>setab</b>; the
           XPG4 draft says that  "If  the  terminal  supports  ANSI  escape  sequences  to  set  background  and
           foreground, they should be coded as <b>setaf</b> and <b>setab</b>, respectively.

       •   If  the  terminal  supports  other  escape sequences to set background and foreground, they should be
           coded as <b>setf</b> and <b>setb</b>, respectively.  The <b>vidputs</b> and the <b><a href="../man3NCURSES/refresh.3NCURSES.html">refresh</a></b>(3NCURSES) functions use the  <b>setaf</b>
           and <b>setab</b> capabilities if they are defined.

       The  <b>setaf</b>/<b>setab</b>  and <b>setf</b>/<b>setb</b> capabilities take a single numeric argument each.  Argument values 0-7 of
       <b>setaf</b>/<b>setab</b> are portably defined as follows (the middle column is the symbolic #define available  in  the
       header for the <b>curses</b> or <u>ncurses</u> libraries).  The terminal hardware is free to map these as it likes, but
       the RGB values indicate normal locations in color space.

                                     <b>Color</b>      <b>#define</b>       <b>Value</b>        <b>RGB</b>
                                    ────────────────────────────────────────────────
                                    black     <b>COLOR_BLACK</b>       0     0,   0,   0
                                    red       <b>COLOR_RED</b>         1     max, 0,   0
                                    green     <b>COLOR_GREEN</b>       2     0,   max, 0
                                    yellow    <b>COLOR_YELLOW</b>      3     max, max, 0
                                    blue      <b>COLOR_BLUE</b>        4     0,   0,   max
                                    magenta   <b>COLOR_MAGENTA</b>     5     max, 0,   max
                                    cyan      <b>COLOR_CYAN</b>        6     0,   max, max
                                    white     <b>COLOR_WHITE</b>       7     max, max, max

       The argument values of <b>setf</b>/<b>setb</b> historically correspond to a different mapping, i.e.,

                                     <b>Color</b>      <b>#define</b>       <b>Value</b>        <b>RGB</b>
                                    ────────────────────────────────────────────────
                                    black     <b>COLOR_BLACK</b>       0     0,   0,   0
                                    blue      <b>COLOR_BLUE</b>        1     0,   0,   max
                                    green     <b>COLOR_GREEN</b>       2     0,   max, 0
                                    cyan      <b>COLOR_CYAN</b>        3     0,   max, max
                                    red       <b>COLOR_RED</b>         4     max, 0,   0
                                    magenta   <b>COLOR_MAGENTA</b>     5     max, 0,   max
                                    yellow    <b>COLOR_YELLOW</b>      6     max, max, 0
                                    white     <b>COLOR_WHITE</b>       7     max, max, max

       It  is  important  to  not  confuse  the  two  sets  of  color  capabilities;  otherwise red/blue will be
       interchanged on the display.

       On an HP-like terminal, use <b>scp</b> with a color pair number parameter to set which color pair is current.

       Some terminals allow the <u>color</u> <u>values</u> to be modified:

       •   On a Tektronix-like terminal, the capability <b>ccc</b> may be  present  to  indicate  that  colors  can  be
           modified.   If  so,  the  <b>initc</b>  capability  will take a color number (0 to <b>colors</b> - 1)and three more
           parameters which describe the color.  These three parameters default  to  being  interpreted  as  RGB
           (Red,  Green,  Blue) values.  If the Boolean capability <b>hls</b> is present, they are instead as HLS (Hue,
           Lightness, Saturation) indices.  The ranges are terminal-dependent.

       •   On an HP-like terminal, <b>initp</b> may give a capability for changing a color pair value.   It  will  take
           seven  parameters;  a  color  pair  number  (0  to  <b>max_pairs</b>  - 1), and two triples describing first
           background and then foreground colors.   These  parameters  must  be  (Red,  Green,  Blue)  or  (Hue,
           Lightness, Saturation) depending on <b>hls</b>.

       On  some color terminals, colors collide with highlights.  You can register these collisions with the <b>ncv</b>
       capability.  This is a bit mask of attributes not to be used when colors are enabled.  The correspondence
       with the attributes understood by <b>curses</b> is as follows:

                                          <b>Attribute</b>     <b>Bit</b>   <b>Decimal</b>   <b>Set</b> <b>by</b>
                                         ──────────────────────────────────────
                                         <b>A_STANDOUT</b>      0         1    <b>sgr</b>
                                         <b>A_UNDERLINE</b>     1         2    <b>sgr</b>
                                         <b>A_REVERSE</b>       2         4    <b>sgr</b>
                                         <b>A_BLINK</b>         3         8    <b>sgr</b>
                                         <b>A_DIM</b>           4        16    <b>sgr</b>
                                         <b>A_BOLD</b>          5        32    <b>sgr</b>
                                         <b>A_INVIS</b>         6        64    <b>sgr</b>
                                         <b>A_PROTECT</b>       7       128    <b>sgr</b>
                                         <b>A_ALTCHARSET</b>    8       256    <b>sgr</b>
                                         <b>A_HORIZONTAL</b>    9       512    <b>sgr1</b>
                                         <b>A_LEFT</b>         10      1024    <b>sgr1</b>
                                         <b>A_LOW</b>          11      2048    <b>sgr1</b>
                                         <b>A_RIGHT</b>        12      4096    <b>sgr1</b>
                                         <b>A_TOP</b>          13      8192    <b>sgr1</b>
                                         <b>A_VERTICAL</b>     14     16384    <b>sgr1</b>
                                         <b>A_ITALIC</b>       15     32768    <b>sitm</b>

       For example, on many IBM PC consoles, the underline attribute collides with the foreground color blue and
       is not available in color mode.  These should have an <b>ncv</b> capability of 2.

       SVr4 curses does nothing with <b>ncv</b>, <u>ncurses</u> recognizes it and optimizes the output in favor of colors.

   <b>Miscellaneous</b>
       If the terminal requires other than a null (zero) character as a pad, then this  can  be  given  as  pad.
       Only  the  first  character  of  the  pad string is used.  If the terminal does not have a pad character,
       specify npc.  Note that <u>ncurses</u> implements the termcap-compatible <b>PC</b> variable; though the application may
       set this value to something other than a null, <u>ncurses</u> will test <b>npc</b> first and use napms if the  terminal
       has no pad character.

       If  the  terminal  can  move  up or down half a line, this can be indicated with <b>hu</b> (half-line up) and <b>hd</b>
       (half-line down).  This is primarily useful for superscripts and subscripts on hard-copy terminals.  If a
       hard-copy terminal can eject to the next page (form feed), give this as <b>ff</b> (usually control/L).

       If there is a command to repeat a given character a given number of times (to save  time  transmitting  a
       large number of identical characters) this can be indicated with the parameterized string <b>rep</b>.  The first
       parameter  is  the  character  to  be repeated and the second is the number of times to repeat it.  Thus,
       tparm(repeat_char, 'x', 10) is the same as “xxxxxxxxxx”.

       If the terminal has a settable command character, such as the TEKTRONIX 4025, this can be indicated  with
       <b>cmdch</b>.   A  prototype  command  character is chosen which is used in all capabilities.  This character is
       given in the <b>cmdch</b> capability to identify it.   The  following  convention  is  supported  on  some  Unix
       systems:  The  environment  is  to  be  searched  for a <b>CC</b> variable, and if found, all occurrences of the
       prototype character are replaced with the character in the environment variable.

       Terminal descriptions that do not represent a specific kind of known terminal, such  as  <u>switch</u>,  <u>dialup</u>,
       <u>patch</u>, and <u>network</u>, should include the <b>gn</b> (generic) capability so that programs can complain that they do
       not  know  how to talk to the terminal.  (This capability does not apply to <u>virtual</u> terminal descriptions
       for which the escape sequences are known.)

       If the terminal has a “meta key” which acts as a  shift  key,  setting  the  8th  bit  of  any  character
       transmitted,  this  fact  can  be indicated with <b>km</b>.  Otherwise, software will assume that the 8th bit is
       parity and it will usually be cleared.  If strings exist to turn this “meta mode” on and off, they can be
       given as <b>smm</b> and <b>rmm</b>.

       If the terminal has more lines of memory than will fit on the screen at once,  the  number  of  lines  of
       memory  can  be  indicated with <b>lm</b>.  A value of <b>lm</b>#0 indicates that the number of lines is not fixed, but
       that there is still more memory than fits on the screen.

       If the terminal is one of those supported by the Unix virtual terminal protocol, the terminal number  can
       be given as <b>vt</b>.

       Media  copy  strings  which  control  an auxiliary printer connected to the terminal can be given as <b>mc0</b>:
       print the contents of the screen, <b>mc4</b>: turn off the printer, and <b>mc5</b>: turn  on  the  printer.   When  the
       printer  is  on,  all text sent to the terminal will be sent to the printer.  It is undefined whether the
       text is also displayed on the terminal screen when the  printer  is  on.   A  variation  <b>mc5p</b>  takes  one
       parameter, and leaves the printer on for as many characters as the value of the parameter, then turns the
       printer  off.   The parameter should not exceed 255.  All text, including <b>mc4</b>, is transparently passed to
       the printer while an <b>mc5p</b> is in effect.

   <b>Glitches</b> <b>and</b> <b>Brain</b> <b>Damage</b>
       Hazeltine terminals, which do not allow “~” characters to be displayed should indicate <b>hz</b>.

       Terminals which ignore a line-feed immediately after an <b>am</b> wrap, such as the Concept  and  vt100,  should
       indicate <b>xenl</b>.

       If <b>el</b> is required to get rid of standout (instead of merely writing normal text on top of it), <b>xhp</b> should
       be given.

       Teleray  terminals,  where tabs turn all characters moved over to blanks, should indicate <b>xt</b> (destructive
       tabs).  Note: the variable indicating this is now  “dest_tabs_magic_smso”;  in  older  versions,  it  was
       teleray_glitch.   This glitch is also taken to mean that it is not possible to position the cursor on top
       of a “magic cookie”, that to erase standout mode it is instead necessary to use delete and  insert  line.
       The <u>ncurses</u> implementation ignores this glitch.

       The  Beehive Superbee, which is unable to correctly transmit the escape or control/C characters, has <b>xsb</b>,
       indicating that the f1 key is used for escape and f2 for control/C.  (Only certain  Superbees  have  this
       problem,  depending  on  the  ROM.)   Note  that  in  older terminfo versions, this capability was called
       “beehive_glitch”; it is now “no_esc_ctl_c”.

       Other specific terminal problems may be corrected by adding more capabilities of the form <b>x</b><u>x</u>.

   <b>Pitfalls</b> <b>of</b> <b>Long</b> <b>Entries</b>
       Long terminfo entries are unlikely to be a problem; to date, no  entry  has  even  approached  terminfo's
       4096-byte  string-table  maximum.  Unfortunately, the termcap translations are much more strictly limited
       (to 1023 bytes), thus termcap translations of long terminfo entries can cause problems.

       The man pages for 4.3BSD and older versions of <b>tgetent</b> instruct the user to allocate a  1024-byte  buffer
       for  the termcap entry.  The entry gets null-terminated by the termcap library, so that makes the maximum
       safe length for a termcap entry 1k-1 (1023) bytes.  Depending on what the  application  and  the  termcap
       library  being  used  does, and where in the termcap file the terminal type that <b>tgetent</b> is searching for
       is, several bad things can happen:

       •   some termcap libraries print a warning message,

       •   some exit if they find an entry that's longer than 1023 bytes,

       •   some neither exit nor warn, doing nothing useful, and

       •   some simply truncate the entries to 1023 bytes.

       Some application programs allocate more than the recommended 1K for the termcap entry; others do not.

       Each termcap entry has two important sizes associated with it: before  “tc”  expansion,  and  after  “tc”
       expansion.   “tc” is the capability that tacks on another termcap entry to the end of the current one, to
       add on its capabilities.  If a termcap entry does not use the “tc” capability, then  of  course  the  two
       lengths are the same.

       The  “before  tc  expansion” length is the most important one, because it affects more than just users of
       that particular terminal.  This is the length of the entry  as  it  exists  in  /etc/termcap,  minus  the
       backslash-newline pairs, which <b>tgetent</b> strips out while reading it.  Some termcap libraries strip off the
       final newline, too (GNU termcap does not).  Now suppose:

       •   a termcap entry before expansion is more than 1023 bytes long,

       •   and the application has only allocated a 1k buffer,

       •   and  the  termcap library (like the one in BSD/OS 1.1 and GNU) reads the whole entry into the buffer,
           no matter what its length, to see if it is the entry it wants,

       •   and <b>tgetent</b> is searching for a terminal type that either is the long entry, appears  in  the  termcap
           file  after  the long entry, or does not appear in the file at all (so that <b>tgetent</b> has to search the
           whole termcap file).

       Then <b>tgetent</b> will overwrite memory, perhaps its stack, and probably core dump the program.  Programs like
       telnet  are  particularly  vulnerable;  modern  telnets  pass  along  values  like  the   terminal   type
       automatically.  The results are almost as undesirable with a termcap library, like SunOS 4.1.3 and Ultrix
       4.4,  that  prints  warning  messages  when  it reads an overly long termcap entry.  If a termcap library
       truncates long entries, like OSF/1 3.0, it is immune to dying here but will return incorrect data for the
       terminal.

       The “after tc expansion” length will have a similar effect to the above, but only for people who actually
       set <u>TERM</u> to that terminal type, since <b>tgetent</b> only does “tc” expansion once it is found the terminal type
       it was looking for, not while searching.

       In summary, a termcap entry that is longer than 1023 bytes can cause, on various combinations of  termcap
       libraries and applications, a core dump, warnings, or incorrect operation.  If it is too long even before
       “tc” expansion, it will have this effect even for users of some other terminal types and users whose <u>TERM</u>
       variable does not have a termcap entry.

       When in -C (translate to termcap) mode, the <u>ncurses</u> implementation of <b><a href="../man1/tic.1.html">tic</a></b>(1) issues warning messages when
       the  pre-tc  length  of  a  termcap  translation is too long.  The -c (check) option also checks resolved
       (after tc expansion) lengths.

</pre><h4><b>FILES</b></h4><pre>
       <u><a href="file:/etc/terminfo">/etc/terminfo</a></u>
              compiled terminal description database directory

</pre><h4><b>EXTENSIONS</b></h4><pre>
       Searching for terminal descriptions in <u>$HOME/.terminfo</u>  and  <u>TERMINFO_DIRS</u>  is  not  supported  by  older
       implementations.

       Some  SVr4  <b>curses</b> implementations, and all previous to SVr4, do not interpret the %A and %O operators in
       parameter strings.

       SVr4/XPG4 do not specify whether <b>msgr</b> licenses movement while in an  alternate-character-set  mode  (such
       modes  may,  among  other  things,  map  CR and NL to characters that do not trigger local motions).  The
       <u>ncurses</u> implementation ignores <b>msgr</b> in <b>ALTCHARSET</b>  mode.   This  raises  the  possibility  that  an  XPG4
       implementation making the opposite interpretation may need terminfo entries made for <u>ncurses</u> to have <b>msgr</b>
       turned off.

       The <u>ncurses</u> library handles insert-character and insert-character modes in a slightly non-standard way to
       get better update efficiency.  See the <b>Insert/Delete</b> <b>Character</b> subsection above.

       The  parameter substitutions for <b>set_clock</b> and <b>display_clock</b> are not documented in SVr4 or X/Open Curses.
       They are deduced from the documentation for the AT&amp;T 505 terminal.

       Be careful assigning the <b>kmous</b> capability.  The <u>ncurses</u> library wants to interpret it as  <b>KEY_MOUSE</b>,  for
       use  by  terminals  and  emulators like xterm that can return mouse-tracking information in the keyboard-
       input stream.

       X/Open Curses does not mention italics.  Portable applications must assume that numeric capabilities  are
       signed  16-bit values.  This includes the <u>no_color_video</u> (<b>ncv</b>) capability.  The 32768 mask value used for
       italics with <b>ncv</b> can be confused with an absent or canceled <b>ncv</b>.  If italics  should  work  with  colors,
       then the <b>ncv</b> value must be specified, even if it is zero.

       Different commercial ports of <u>terminfo</u> and <u>curses</u> support different subsets of X/Open Curses and (in some
       cases)  different extensions.  Here is a summary, accurate as of October 1995, after which the commercial
       Unix market contracted and lost diversity.

       •   SVr4, Solaris, and <u>ncurses</u> support all SVr4 capabilities.

       •   IRIX supports the SVr4 set and adds one undocumented extended string capability (<b>set_pglen</b>).

       •   SVr1 and Ultrix support a  restricted  subset  of  <u>terminfo</u>  capabilities.   The  Booleans  end  with
           <b>xon_xoff</b>; the numerics with <b>width_status_line</b>; and the strings with <b>prtr_non</b>.

       •   HP/UX  supports  the  SVr1  subset, plus the SVr[234] numerics <b>num_labels</b>, <b>label_height</b>, <b>label_width</b>,
           plus function keys 11 through  63,  plus  <b>plab_norm</b>,  <b>label_on</b>,  and  <b>label_off</b>,  plus  a  number  of
           incompatible string table extensions.

       •   AIX  supports the SVr1 subset, plus function keys 11 through 63, plus a number of incompatible string
           table extensions.

       •   OSF/1 supports both the SVr4 set and the AIX extensions.

</pre><h4><b>PORTABILITY</b></h4><pre>
       Do not count on compiled (binary) <u>terminfo</u> entries being portable between commercial  Unix  systems.   At
       least  two  implementations  of  <u>terminfo</u>  (those of HP-UX and AIX) diverged from those of other System V
       Unices after SVr1, adding extension capabilities to the string table that (in the binary format)  collide
       with subsequent System V and X/Open Curses extensions.

</pre><h4><b>AUTHORS</b></h4><pre>
       Zeyd M. Ben-Halim, Eric S. Raymond, Thomas E. Dickey.  Based on <u>pcurses</u> by Pavel Curtis.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/infocmp.1.html">infocmp</a></b>(1),      <b><a href="../man1/tabs.1.html">tabs</a></b>(1),     <b><a href="../man1/tic.1.html">tic</a></b>(1),     <b><a href="../man3NCURSES/ncurses.3NCURSES.html">ncurses</a></b>(3NCURSES),     <b><a href="../man3NCURSES/color.3NCURSES.html">color</a></b>(3NCURSES),     <b><a href="../man3NCURSES/terminfo.3NCURSES.html">terminfo</a></b>(3NCURSES),
       <b><a href="../man3NCURSES/curses_variables.3NCURSES.html">curses_variables</a></b>(3NCURSES), <b><a href="../man3/printf.3.html">printf</a></b>(3), <b><a href="../man3NCURSES/terminfo_variables.3NCURSES.html">terminfo_variables</a></b>(3NCURSES), <b><a href="../man5/term.5.html">term</a></b>(5), <b><a href="../man5/user_caps.5.html">user_caps</a></b>(5)

ncurses 6.5                                        2024-05-11                                        <u><a href="../man5/terminfo.5.html">terminfo</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>