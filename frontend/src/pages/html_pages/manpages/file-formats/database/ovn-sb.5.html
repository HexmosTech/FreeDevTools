<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ovn-sb - OVN_Southbound database schema</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ovn-common">ovn-common_25.03.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ovn-sb - OVN_Southbound database schema

       This  database  holds  logical  and  physical  configuration and state for the Open Virtual Network (OVN)
       system  to  support  virtual  network   abstraction.   For   an   introduction   to   OVN,   please   see
       <b><a href="../man7/ovn-architecture.7.html">ovn-architecture</a></b>(7).

       The  OVN  Southbound  database  sits  at the center of the OVN architecture. It is the one component that
       speaks    both    southbound    directly    to    all    the    hypervisors     and     gateways,     via
       <b>ovn-controller</b>/<b>ovn-controller-vtep</b>, and northbound to the Cloud Management System, via <b>ovn-northd</b>:

   <b>Database</b> <b>Structure</b>
       The  OVN  Southbound  database  contains  classes  of data with different properties, as described in the
       sections below.

     <u>Physical</u> <u>network</u>

       Physical network tables contain information about the chassis nodes in the system. This contains all  the
       information  necessary  to  wire  the overlay, such as IP addresses, supported tunnel types, and security
       keys.

       The amount of physical network data is small (O(n) in the number of chassis) and it changes infrequently,
       so it can be replicated to every chassis.

       The <b>Chassis</b> and <b>Encap</b> tables are the physical network tables.

     <u>Logical</u> <u>Network</u>

       Logical network tables contain the topology of logical switches and routers, ACLs,  firewall  rules,  and
       everything  needed  to  describe  how packets traverse a logical network, represented as logical datapath
       flows (see Logical Datapath Flows, below).

       Logical network data may be large (O(n) in the number of  logical  ports,  ACL  rules,  etc.).  Thus,  to
       improve  scaling, each chassis should receive only data related to logical networks in which that chassis
       participates.

       The logical network data is ultimately controlled by the cloud management system (CMS) running northbound
       of OVN. That CMS determines the entire OVN logical configuration and therefore the logical  network  data
       at  any  given  time  is  a  deterministic  function  of  the  CMS’s configuration, although that happens
       indirectly via the <b>OVN_Northbound</b> database and <b>ovn-northd</b>.

       Logical network data is likely to change more quickly than physical network data. This is especially true
       in a container environment where containers are created and destroyed (and therefore added to and deleted
       from logical switches) quickly.

       The <b>Logical_Flow</b>, <b>Multicast_Group</b>, <b>Address_Group</b>, <b>DHCP_Options</b>, <b>DHCPv6_Options</b>, and  <b>DNS</b>  tables  contain
       logical network data.

     <u>Logical-physical</u> <u>bindings</u>

       These  tables link logical and physical components. They show the current placement of logical components
       (such as VMs and VIFs) onto chassis, and map logical entities to the values that represent them in tunnel
       encapsulations.

       These tables change frequently, at least every time a VM powers up or down or  migrates,  and  especially
       quickly in a container environment. The amount of data per VM (or VIF) is small.

       Each  chassis is authoritative about the VMs and VIFs that it hosts at any given time and can efficiently
       flood that state to a central location, so the consistency needs are minimal.

       The <b>Port_Binding</b> and <b>Datapath_Binding</b> tables contain binding data.

     <u>MAC</u> <u>bindings</u>

       The <b>MAC_Binding</b> table tracks the bindings from IP addresses to Ethernet addresses  that  are  dynamically
       discovered  using  ARP  (for  IPv4)  and  neighbor  discovery (for IPv6). Usually, IP-to-MAC bindings for
       virtual machines are statically populated into the <b>Port_Binding</b> table, so <b>MAC_Binding</b> is  primarily  used
       to discover bindings on physical networks.

   <b>Common</b> <b>Columns</b>
       Some  tables  contain a special column named <b>external_ids</b>. This column has the same form and purpose each
       place that it appears, so we describe it here to save space later.

              <b>external_ids</b>: map of string-string pairs
                     Key-value pairs for use by the software that manages the  OVN  Southbound  database  rather
                     than  by  <b>ovn-controller</b>/<b>ovn-controller-vtep</b>.  In  particular, <b>ovn-northd</b> can use key-value
                     pairs in this column to relate entities in the southbound database to higher-level entities
                     (such as entities in the OVN Northbound  database).  Individual  key-value  pairs  in  this
                     column may be documented in some cases to aid in understanding and troubleshooting, but the
                     reader should not mistake such documentation as comprehensive.

</pre><h4><b>TABLE</b> <b>SUMMARY</b></h4><pre>
       The  following  list  summarizes  the purpose of each of the tables in the <b>OVN_Southbound</b> database.  Each
       table is described in more detail on a later page.

       Table     Purpose
       <b>SB_Global</b> Southbound configuration
       <b>Chassis</b>   Physical Network Hypervisor and Gateway Information
       <b>Chassis_Private</b>
                 Chassis Private
       <b>Encap</b>     Encapsulation Types
       <b>Address_Set</b>
                 Address Sets
       <b>Port_Group</b>
                 Port Groups
       <b>Logical_Flow</b>
                 Logical Network Flows
       <b>Logical_DP_Group</b>
                 Logical Datapath Groups
       <b>Multicast_Group</b>
                 Logical Port Multicast Groups
       <b>Mirror</b>    Mirror Entry
       <b>Meter</b>     Meter entry
       <b>Meter_Band</b>
                 Band for meter entries
       <b>Datapath_Binding</b>
                 Physical-Logical Datapath Bindings
       <b>Port_Binding</b>
                 Physical-Logical Port Bindings
       <b>MAC_Binding</b>
                 IP to MAC bindings
       <b>DHCP_Options</b>
                 DHCP Options supported by native OVN DHCP
       <b>DHCPv6_Options</b>
                 DHCPv6 Options supported by native OVN DHCPv6
       <b>Connection</b>
                 OVSDB client connections.
       <b>SSL</b>       SSL configuration.
       <b>DNS</b>       Native DNS resolution
       <b>RBAC_Role</b> RBAC_Role configuration.
       <b>RBAC_Permission</b>
                 RBAC_Permission configuration.
       <b>Gateway_Chassis</b>
                 Gateway_Chassis configuration.
       <b>HA_Chassis</b>
                 HA_Chassis configuration.
       <b>HA_Chassis_Group</b>
                 HA_Chassis_Group configuration.
       <b>Controller_Event</b>
                 Controller Event table
       <b>IP_Multicast</b>
                 IP_Multicast configuration.
       <b>IGMP_Group</b>
                 IGMP_Group configuration.
       <b>Service_Monitor</b>
                 Service_Monitor configuration.
       <b>Load_Balancer</b>
                 Load_Balancer configuration.
       <b>BFD</b>       BFD configuration.
       <b>FDB</b>       Port to MAC bindings
       <b>Static_MAC_Binding</b>
                 IP to MAC bindings
       <b>Chassis_Template_Var</b>
                 Chassis_Template_Var configuration.
       <b>Advertised_Route</b>
                 Advertised_Route configuration.
       <b>Learned_Route</b>
                 Learned_Route configuration.
       <b>ECMP_Nexthop</b>
                 ECMP_Nexthop configuration.
       <b>ACL_ID</b>    ACL_ID configuration.

</pre><h4><b>SB_Global</b> <b>TABLE</b></h4><pre>
       Southbound configuration for an OVN system. This table must have exactly one row.

   <b>Summary:</b>
       <u>Status:</u>
         <b>nb_cfg</b>                      integer
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs
         <b>options</b>                     map of string-string pairs
       <u>Common</u> <u>options:</u>
         <b>options</b>                     map of string-string pairs
         <u>Options</u> <u>for</u> <u>configuring</u> <u>BFD:</u>
            <b>options</b> <b>:</b> <b>bfd-min-rx</b>     optional string
            <b>options</b> <b>:</b> <b>bfd-decay-min-rx</b>
                                     optional string
            <b>options</b> <b>:</b> <b>bfd-min-tx</b>     optional string
            <b>options</b> <b>:</b> <b>bfd-mult</b>       optional string
            <b>options</b> <b>:</b> <b>debug_drop_domain_id</b>
                                     optional string
            <b>options</b> <b>:</b> <b>debug_drop_collector_set</b>
                                     optional string
         <u>Options</u> <u>for</u> <u>configuring</u> <u>ovn-sbctl:</u>
            <b>options</b> <b>:</b> <b>sbctl_probe_interval</b>
                                     optional string
       <u>Connection</u> <u>Options:</u>
         <b>connections</b>                 set of <b>Connection</b>s
         <b>ssl</b>                         optional <b>SSL</b>
       <u>Security</u> <u>Configurations:</u>
         <b>ipsec</b>                       boolean

   <b>Details:</b>
     <u>Status:</u>

       This column allow a client to track the overall configuration state of the system.

       <b>nb_cfg</b>: integer
              Sequence number for the configuration. When a CMS or <b>ovn-nbctl</b> updates the northbound database, it
              increments the <b>nb_cfg</b> column in the <b>NB_Global</b> table in the  northbound  database.  In  turn,  when
              <b>ovn-northd</b>  updates  the southbound database to bring it up to date with these changes, it updates
              this column to the same value.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

       <b>options</b>: map of string-string pairs

     <u>Common</u> <u>options:</u>

       <b>options</b>: map of string-string pairs
              This column provides general key/value settings. The supported options are described  individually
              below.

     <u>Options</u> <u>for</u> <u>configuring</u> <u>BFD:</u>

       These options apply when <b>ovn-controller</b> configures BFD on tunnels interfaces.

       <b>options</b> <b>:</b> <b>bfd-min-rx</b>: optional string
              BFD option <b>min-rx</b> value to use when configuring BFD on tunnel interfaces.

       <b>options</b> <b>:</b> <b>bfd-decay-min-rx</b>: optional string
              BFD option <b>decay-min-rx</b> value to use when configuring BFD on tunnel interfaces.

       <b>options</b> <b>:</b> <b>bfd-min-tx</b>: optional string
              BFD option <b>min-tx</b> value to use when configuring BFD on tunnel interfaces.

       <b>options</b> <b>:</b> <b>bfd-mult</b>: optional string
              BFD option <b>mult</b> value to use when configuring BFD on tunnel interfaces.

       <b>options</b> <b>:</b> <b>debug_drop_domain_id</b>: optional string
              If  set  to a 8-bit number and if <b>debug_drop_collector_set</b> is also configured, <b>ovn-controller</b> will
              add a <b>sample</b> action to every flow that does not come from a logical flow that  contains  a  ’drop’
              action.  The 8 most significant bits of the observation_domain_id field will be those specified in
              the  <b>debug_drop_domain_id</b>. The 24 least significant bits of the observation_domain_id  field  will
              be zero.

              The observation_point_id will be set to the OpenFlow table number.

       <b>options</b> <b>:</b> <b>debug_drop_collector_set</b>: optional string
              If set to a 32-bit number <b>ovn-controller</b> will add a <b>sample</b> action to every flow that does not come
              from  a  logical  flow  that  contains  a ’drop’ action. The sample action will have the specified
              collector_set_id. The value must match that  of  the  local  OVS  configuration  as  described  in
              <b><a href="../man7/ovs-actions.7.html">ovs-actions</a></b>(7).

     <u>Options</u> <u>for</u> <u>configuring</u> <u>ovn-sbctl:</u>

       These options apply when <b>ovn-sbctl</b> connects to OVN Southbound database.

       <b>options</b> <b>:</b> <b>sbctl_probe_interval</b>: optional string
              The  inactivity  probe  interval  of  the connection to the OVN Southbound database from <b>ovn-sbctl</b>
              utility, in milliseconds. If the value is zero, it disables the connection keepalive feature.

              If the value is nonzero, then it will be forced to a value of at least 1000 ms.

              If the value is less than zero, then the default inactivity probe interval for <b>ovn-sbctl</b> would  be
              left intact (120000 ms).

     <u>Connection</u> <u>Options:</u>

       <b>connections</b>: set of <b>Connection</b>s
              Database  clients  to  which the Open vSwitch database server should connect or on which it should
              listen, along with options for how these connections should  be  configured.  See  the  <b>Connection</b>
              table for more information.

       <b>ssl</b>: optional <b>SSL</b>
              Global SSL/TLS configuration.

     <u>Security</u> <u>Configurations:</u>

       <b>ipsec</b>: boolean
              Tunnel  encryption  configuration.  If  this  column  is  set  to be true, all OVN tunnels will be
              encrypted with IPsec.

</pre><h4><b>Chassis</b> <b>TABLE</b></h4><pre>
       Each row in this table represents a hypervisor or gateway (a  chassis)  in  the  physical  network.  Each
       chassis,  via  <b>ovn-controller</b>/<b>ovn-controller-vtep</b>,  adds and updates its own row, and keeps a copy of the
       remaining rows to determine how to reach other hypervisors.

       When a chassis shuts down gracefully, it should remove  its  own  row.  (This  is  not  critical  because
       resources  hosted  on the chassis are equally unreachable regardless of whether the row is present.) If a
       chassis shuts down permanently without removing its row, some kind of  manual  or  automatic  cleanup  is
       eventually needed; we can devise a process for that as necessary.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>hostname</b>                      string
       <b>nb_cfg</b>                        integer
       <b>other_config</b> <b>:</b> <b>ovn-bridge-mappings</b>
                                     optional string
       <b>other_config</b> <b>:</b> <b>datapath-type</b>  optional string
       <b>other_config</b> <b>:</b> <b>iface-types</b>    optional string
       <b>other_config</b> <b>:</b> <b>ovn-cms-options</b>
                                     optional string
       <b>other_config</b> <b>:</b> <b>is-interconn</b>   optional string
       <b>other_config</b> <b>:</b> <b>is-remote</b>      optional string
       <b>transport_zones</b>               set of strings
       <b>other_config</b> <b>:</b> <b>ovn-chassis-mac-mappings</b>
                                     optional string
       <b>other_config</b> <b>:</b> <b>port-up-notif</b>  optional string
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs
       <u>Encapsulation</u> <u>Configuration:</u>
         <b>encaps</b>                      set of 1 or more <b>Encap</b>s
       <u>Gateway</u> <u>Configuration:</u>
         <b>vtep_logical_switches</b>       set of strings

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              OVN does not prescribe a particular format for chassis names. ovn-controller populates this column
              using  <b>external_ids:system-id</b>  in  the Open_vSwitch database’s <b>Open_vSwitch</b> table. ovn-controller-
              vtep populates this column with <b>name</b> in the hardware_vtep database’s <b>Physical_Switch</b> table.

       <b>hostname</b>: string
              The hostname of the chassis, if applicable. ovn-controller will  populate  this  column  with  the
              hostname of the host it is running on. ovn-controller-vtep will leave this column empty.

       <b>nb_cfg</b>: integer
              Deprecated. This column is replaced by the <b>nb_cfg</b> column of the <b>Chassis_Private</b> table.

       <b>other_config</b> <b>:</b> <b>ovn-bridge-mappings</b>: optional string
              <b>ovn-controller</b>  populates  this key with the set of bridge mappings it has been configured to use.
              Other applications should treat this key as read-only. See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more information.

       <b>other_config</b> <b>:</b> <b>datapath-type</b>: optional string
              <b>ovn-controller</b> populates this key with the datapath type configured in the <b>datapath_type</b> column of
              the Open_vSwitch database’s <b>Bridge</b> table. Other applications should treat this key  as  read-only.
              See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more information.

       <b>other_config</b> <b>:</b> <b>iface-types</b>: optional string
              <b>ovn-controller</b> populates this key with the interface types configured in the <b>iface_types</b> column of
              the  Open_vSwitch database’s <b>Open_vSwitch</b> table. Other applications should treat this key as read-
              only. See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more information.

       <b>other_config</b> <b>:</b> <b>ovn-cms-options</b>: optional string
              <b>ovn-controller</b> populates this key with the set of options configured in the  <b>external_ids:ovn-cms-</b>
              <b>options</b>  column  of the Open_vSwitch database’s <b>Open_vSwitch</b> table. See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more
              information.

       <b>other_config</b> <b>:</b> <b>is-interconn</b>: optional string
              <b>ovn-controller</b> populates this key with the setting configured in the <b>external_ids:ovn-is-interconn</b>
              column of the Open_vSwitch database’s <b>Open_vSwitch</b> table. If set to true, the chassis is  used  as
              an interconnection gateway. See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more information.

       <b>other_config</b> <b>:</b> <b>is-remote</b>: optional string
              <b>ovn-ic</b>  set  this  key  to  true  for  remote  interconnection  gateway chassises learned from the
              interconnection southbound database. See <b><a href="../man8/ovn-ic.8.html">ovn-ic</a></b>(8) for more information.

       <b>transport_zones</b>: set of strings
              <b>ovn-controller</b> populates this key with the transport zones  configured  in  the  <b>external_ids:ovn-</b>
              <b>transport-zones</b>  column  of  the Open_vSwitch database’s <b>Open_vSwitch</b> table. See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8)
              for more information.

       <b>other_config</b> <b>:</b> <b>ovn-chassis-mac-mappings</b>: optional string
              <b>ovn-controller</b> populates this key with the set of  options  configured  in  the  <b>external_ids:ovn-</b>
              <b>chassis-mac-mappings</b>   column   of   the   Open_vSwitch   database’s   <b>Open_vSwitch</b>   table.   See
              <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more information.

       <b>other_config</b> <b>:</b> <b>port-up-notif</b>: optional string
              <b>ovn-controller</b> populates this key with <b>true</b> when it supports <b>Port_Binding.up</b>.

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs

     <u>Encapsulation</u> <u>Configuration:</u>

       OVN uses encapsulation to transmit logical dataplane packets between chassis.

       <b>encaps</b>: set of 1 or more <b>Encap</b>s
              Points to supported encapsulation configurations to transmit logical  dataplane  packets  to  this
              chassis. Each entry is a <b>Encap</b> record that describes the configuration.

     <u>Gateway</u> <u>Configuration:</u>

       A  <u>gateway</u>  is  a  chassis  that forwards traffic between the OVN-managed part of a logical network and a
       physical VLAN, extending a tunnel-based logical network into a physical network. Gateways  are  typically
       dedicated nodes that do not host VMs and will be controlled by <b>ovn-controller-vtep</b>.

       <b>vtep_logical_switches</b>: set of strings
              Stores  all  VTEP  logical  switch names connected by this gateway chassis. The <b>Port_Binding</b> table
              entry with <b>options</b>:<b>vtep-physical-switch</b> equal <b>Chassis</b> <b>name</b>, and <b>options</b>:<b>vtep-logical-switch</b>  value
              in <b>Chassis</b> <b>vtep_logical_switches</b>, will be associated with this <b>Chassis</b>.

</pre><h4><b>Chassis_Private</b> <b>TABLE</b></h4><pre>
       Each  row  in  this table maintains per chassis private data that are accessed only by the owning chassis
       (write only) and ovn-northd, not by any other chassis. These data  are  stored  in  this  separate  table
       instead  of the <b>Chassis</b> table for performance considerations: the rows in this table can be conditionally
       monitored by chassises so that each chassis only get update notifications  for  its  own  row,  to  avoid
       unnecessary chassis private data update flooding in a large scale deployment.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>chassis</b>                       optional weak reference to <b>Chassis</b>
       <b>nb_cfg</b>                        integer
       <b>nb_cfg_timestamp</b>              integer
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              The name of the chassis that owns these chassis-private data.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The reference to <b>Chassis</b> table for the chassis that owns these chassis-private data.

       <b>nb_cfg</b>: integer
              Sequence  number for the configuration. When <b>ovn-controller</b> updates the configuration of a chassis
              from the contents of the southbound database, it copies <b>nb_cfg</b> from the <b>SB_Global</b> table into  this
              column.

       <b>nb_cfg_timestamp</b>: integer
              The timestamp when <b>ovn-controller</b> finishes processing the change corresponding to <b>nb_cfg</b>.

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre><h4><b>Encap</b> <b>TABLE</b></h4><pre>
       The  <b>encaps</b>  column  in  the  <b>Chassis</b> table refers to rows in this table to identify how OVN may transmit
       logical dataplane packets to this chassis. Each chassis, via <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) or <b><a href="../man8/ovn-controller-vtep.8.html">ovn-controller-vtep</a></b>(8),
       adds and updates its own rows and keeps a copy of the remaining rows to  determine  how  to  reach  other
       chassis.

   <b>Summary:</b>
       <b>type</b>                          string, one of <b>geneve</b>, <b>stt</b>, or <b>vxlan</b>
       <b>options</b>                       map of string-string pairs
       <b>options</b> <b>:</b> <b>csum</b>                optional string, either <b>true</b> or <b>false</b>
       <b>options</b> <b>:</b> <b>dst_port</b>            optional string, containing an integer
       <b>options</b> <b>:</b> <b>is_default</b>          optional string, either <b>true</b> or <b>false</b>
       <b>ip</b>                            string
       <b>chassis_name</b>                  string

   <b>Details:</b>
       <b>type</b>: string, one of <b>geneve</b>, <b>stt</b>, or <b>vxlan</b>
              The  encapsulation  to  use to transmit packets to this chassis. Hypervisors and gateways must use
              one of: <b>geneve</b>, <b>vxlan</b>, or <b>stt</b>. <b>stt</b> is deprecated.

       <b>options</b>: map of string-string pairs
              Options for configuring the encapsulation, which may be <b>type</b> specific.

       <b>options</b> <b>:</b> <b>csum</b>: optional string, either <b>true</b> or <b>false</b>
              <b>csum</b> indicates whether this chassis can transmit and receive packets that include  checksums  with
              reasonable performance. It hints to senders transmitting data to this chassis that they should use
              checksums  to  protect  OVN  metadata. <b>ovn-controller</b> populates this key with the value defined in
              <b>external_ids:ovn-encap-csum</b> column  of  the  Open_vSwitch  database’s  <b>Open_vSwitch</b>  table.  Other
              applications should treat this key as read-only. See <b><a href="../man8/ovn-controller.8.html">ovn-controller</a></b>(8) for more information.

              In  terms  of performance, checksumming actually significantly increases throughput in most common
              cases when running on Linux based hosts without NICs  supporting  encapsulation  hardware  offload
              (around  60%  for  bulk  traffic). The reason is that generally all NICs are capable of offloading
              transmitted and received TCP/UDP checksums (viewed as ordinary data packets and not  as  tunnels).
              The  benefit  comes  on  the  receive  side  where  the  validated  outer  checksum can be used to
              additionally validate an inner checksum (such as TCP), which in turn allows aggregation of packets
              to be more efficiently handled by the rest of the stack.

              Not all devices see such a benefit. The most notable exception is hardware  VTEPs.  These  devices
              are  designed  to not buffer entire packets in their switching engines and are therefore unable to
              efficiently compute or validate full packet checksums. In addition certain versions of  the  Linux
              kernel  are  not  able  to  fully  take advantage of encapsulation NIC offloads in the presence of
              checksums. (This is actually a pretty narrow corner case though: earlier versions of  Linux  don’t
              support  encapsulation  offloads  at  all  and  later versions support both offloads and checksums
              well.)

              <b>csum</b> defaults to <b>false</b> for hardware VTEPs and <b>true</b> for all other cases.

              This option applies to <b>geneve</b> and <b>vxlan</b> encapsulations.

       <b>options</b> <b>:</b> <b>dst_port</b>: optional string, containing an integer
              If set, overrides the UDP (for <b>geneve</b> and <b>vxlan</b>) or TCP (for <b>stt</b>) destination port.

       <b>options</b> <b>:</b> <b>is_default</b>: optional string, either <b>true</b> or <b>false</b>
              When there are multiple encaps for a chassis with different IPs,  this  option  indicates  if  the
              encap  is  the  default one that matches the IP in <b>external_ids:ovn-encap-ip-default</b> column of the
              Open_vSwitch database’s <b>Open_vSwitch</b> table.

       <b>ip</b>: string
              The IPv4 address of the encapsulation tunnel endpoint.

       <b>chassis_name</b>: string
              The name of the chassis that created this encap.

</pre><h4><b>Address_Set</b> <b>TABLE</b></h4><pre>
       This table contains address sets synced from the <b>Address_Set</b> table in  the  <b>OVN_Northbound</b>  database  and
       address sets generated from the <b>Port_Group</b> table in the <b>OVN_Northbound</b> database.

       See  the  documentation for the <b>Address_Set</b> table and <b>Port_Group</b> table in the <b>OVN_Northbound</b> database for
       details.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>addresses</b>                     set of strings

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)

       <b>addresses</b>: set of strings
</pre><h4><b>Port_Group</b> <b>TABLE</b></h4><pre>
       This table contains names for the logical switch ports in the <b>OVN_Northbound</b> database that belongs to the
       same group that is defined in <b>Port_Group</b> in the <b>OVN_Northbound</b> database.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>ports</b>                         set of strings

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)

       <b>ports</b>: set of strings
</pre><h4><b>Logical_Flow</b> <b>TABLE</b></h4><pre>
       Each row in this table represents one logical flow. <b>ovn-northd</b> populates this table  with  logical  flows
       that  implement  the  L2 and L3 topologies specified in the <b>OVN_Northbound</b> database. Each hypervisor, via
       <b>ovn-controller</b>, translates the logical flows into OpenFlow flows specific to its hypervisor and  installs
       them into Open vSwitch.

       Logical  flows  are  expressed in an OVN-specific format, described here. A logical datapath flow is much
       like an OpenFlow flow, except that the flows are written in terms of logical ports and logical  datapaths
       instead of physical ports and physical datapaths. Translation between logical and physical flows helps to
       ensure isolation between logical datapaths. (The logical flow abstraction also allows the OVN centralized
       components  to  do less work, since they do not have to separately compute and push out physical flows to
       each chassis.)

       The default action when no flow matches is to drop packets.

       <b>Architectural</b> <b>Logical</b> <b>Life</b> <b>Cycle</b> <b>of</b> <b>a</b> <b>Packet</b>

       This following description focuses on the life cycle of a packet through  a  logical  datapath,  ignoring
       physical  details of the implementation. Please refer to <b>Architectural</b> <b>Physical</b> <b>Life</b> <b>Cycle</b> <b>of</b> <b>a</b> <b>Packet</b> in
       <b><a href="../man7/ovn-architecture.7.html">ovn-architecture</a></b>(7) for the physical information.

       The description here is written as if OVN itself  executes  these  steps,  but  in  fact  OVN  (that  is,
       <b>ovn-controller</b>) programs Open vSwitch, via OpenFlow and OVSDB, to execute them on its behalf.

       At  a  high  level, OVN passes each packet through the logical datapath’s logical ingress pipeline, which
       may output the packet to one or more logical port or logical multicast  groups.  For  each  such  logical
       output  port, OVN passes the packet through the datapath’s logical egress pipeline, which may either drop
       the packet or deliver it to the destination. Between the two  pipelines,  outputs  to  logical  multicast
       groups  are  expanded  into  logical  ports,  so that the egress pipeline only processes a single logical
       output port at a time. Between the two pipelines is also where, when necessary, OVN encapsulates a packet
       in a tunnel (or tunnels) to transmit to remote hypervisors.

       In more detail, to start, OVN searches the <b>Logical_Flow</b> table for a row with correct <b>logical_datapath</b>  or
       a  <b>logical_dp_group</b>,  a <b>pipeline</b> of <b>ingress</b>, a <b>table_id</b> of 0, and a <b>match</b> that is true for the packet. If
       none is found, OVN drops the packet. If OVN finds more than one, it chooses the match  with  the  highest
       <b>priority</b>.  Then  OVN  executes  each  of  the actions specified in the row’s <b>actions</b> column, in the order
       specified. Some actions, such as those to modify packet headers, require no further details. The <b>next</b> and
       <b>output</b> actions are special.

       The <b>next</b> action causes the above process to  be  repeated  recursively,  except  that  OVN  searches  for
       <b>table_id</b> of 1 instead of 0. Similarly, any <b>next</b> action in a row found in that table would cause a further
       search  for  a <b>table_id</b> of 2, and so on. When recursive processing completes, flow control returns to the
       action following <b>next</b>.

       The <b>output</b> action also introduces recursion. Its effect depends on  the  current  value  of  the  <b>outport</b>
       field.  Suppose  <b>outport</b>  designates  a  logical port. First, OVN compares <b>inport</b> to <b>outport</b>; if they are
       equal, it treats the <b>output</b> as a no-op by default. In the common case,  where  they  are  different,  the
       packet  enters  the  egress pipeline. This transition to the egress pipeline discards register data, e.g.
       <b>reg0</b> ... <b>reg9</b> and connection tracking state, to achieve uniform behavior regardless of whether the egress
       pipeline is on a different hypervisor (because registers aren’t preserve across tunnel encapsulation).

       To execute the egress pipeline, OVN again  searches  the  <b>Logical_Flow</b>  table  for  a  row  with  correct
       <b>logical_datapath</b>  or  a  <b>logical_dp_group</b>,  a <b>table_id</b> of 0, a <b>match</b> that is true for the packet, but now
       looking for a <b>pipeline</b> of <b>egress</b>. If no matching row is found, the output becomes a no-op. Otherwise, OVN
       executes the actions for the matching flow (which is chosen  from  multiple,  if  necessary,  as  already
       described).

       In  the  <b>egress</b>  pipeline, the <b>next</b> action acts as already described, except that it, of course, searches
       for <b>egress</b> flows. The <b>output</b> action, however, now directly outputs the packet to the output  port  (which
       is now fixed, because <b>outport</b> is read-only within the egress pipeline).

       The  description  earlier  assumed  that  <b>outport</b>  referred to a logical port. If it instead designates a
       logical multicast group, then the description above still applies, with the addition of fan-out from  the
       logical multicast group to each logical port in the group. For each member of the group, OVN executes the
       logical pipeline as described, with the logical output port replaced by the group member.

       <b>Pipeline</b> <b>Stages</b>

       <b>ovn-northd</b> populates the <b>Logical_Flow</b> table with the logical flows described in detail in <b><a href="../man8/ovn-northd.8.html">ovn-northd</a></b>(8).

   <b>Summary:</b>
       <b>logical_datapath</b>              optional <b>Datapath_Binding</b>
       <b>logical_dp_group</b>              optional <b>Logical_DP_Group</b>
       <b>pipeline</b>                      string, either <b>egress</b> or <b>ingress</b>
       <b>table_id</b>                      integer, in range 0 to 32
       <b>priority</b>                      integer, in range 0 to 65,535
       <b>match</b>                         string
       <b>actions</b>                       string
       <b>tags</b>                          map of string-string pairs
       <b>controller_meter</b>              optional string
       <b>flow_desc</b>                     optional string
       <b>external_ids</b> <b>:</b> <b>stage-name</b>     optional string
       <b>external_ids</b> <b>:</b> <b>stage-hint</b>     optional string, containing an uuid
       <b>external_ids</b> <b>:</b> <b>source</b>         optional string
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>logical_datapath</b>: optional <b>Datapath_Binding</b>
              The logical datapath to which the logical flow belongs.

       <b>logical_dp_group</b>: optional <b>Logical_DP_Group</b>
              The group of logical datapaths to which the logical flow belongs. This means that the same logical
              flow belongs to all datapaths in a group.

       <b>pipeline</b>: string, either <b>egress</b> or <b>ingress</b>
              The  primary  flows  used for deciding on a packet’s destination are the <b>ingress</b> flows. The <b>egress</b>
              flows implement ACLs. See <b>Logical</b> <b>Life</b> <b>Cycle</b> <b>of</b> <b>a</b> <b>Packet</b>, above, for details.

       <b>table_id</b>: integer, in range 0 to 32
              The stage in the logical pipeline, analogous to an OpenFlow table number.

       <b>priority</b>: integer, in range 0 to 65,535
              The flow’s priority. Flows with numerically higher priority take precedence over those with lower.
              If two logical datapath flows with the same priority both match, then the one actually applied  to
              the packet is undefined.

       <b>match</b>: string
              A  matching  expression. OVN provides a superset of OpenFlow matching capabilities, using a syntax
              similar to Boolean expressions in a programming language.

              The most important components of match expression are <u>comparisons</u> between <u>symbols</u>  and  <u>constants</u>,
              e.g.  <b>ip4.dst</b>  <b>==</b>  <b>192.168.0.1</b>,  <b>ip.proto</b>  <b>==</b>  <b>6</b>,  <b>arp.op</b> <b>==</b> <b>1</b>, <b>eth.type</b> <b>==</b> <b>0x800</b>. The logical AND
              operator <b>&amp;&amp;</b> and logical OR operator <b>||</b> can combine comparisons into a larger expression.

              Matching expressions also support parentheses for grouping, the logical NOT prefix operator <b>!</b>, and
              literals <b>0</b> and <b>1</b> to express ``false’’ or ``true,’’ respectively. The latter is useful by itself as
              a catch-all expression that matches every packet.

              Match expressions also support a kind of function syntax. The following functions are supported:

              <b>is_chassis_resident(</b><u>lport</u><b>)</b>
                     Evaluates to true on a chassis on which logical port <u>lport</u> (a quoted string)  resides,  and
                     to false elsewhere. This function was introduced in OVN 2.7.

              <b>Symbols</b>

              <b>Type</b>. Symbols have <u>integer</u> or <u>string</u> type. Integer symbols have a <u>width</u> in bits.

              <b>Kinds</b>. There are three kinds of symbols:

              •      <u>Fields</u>.  A  field symbol represents a packet header or metadata field. For example, a field
                     named <b>vlan.tci</b> might represent the VLAN TCI field in a packet.

                     A field symbol can have integer or string type. Integer fields can be  nominal  or  ordinal
                     (see <b>Level</b> <b>of</b> <b>Measurement</b>, below).

              •      <u>Subfields</u>. A subfield represents a subset of bits from a larger field. For example, a field
                     <b>vlan.vid</b>  might  be  defined  as  an  alias for <b>vlan.tci[0..11]</b>. Subfields are provided for
                     syntactic convenience, because it is always possible to instead refer to a subset  of  bits
                     from a field directly.

                     Only  ordinal  fields  (see  <b>Level</b> <b>of</b> <b>Measurement</b>, below) may have subfields. Subfields are
                     always ordinal.

              •      <u>Predicates</u>. A predicate is shorthand for a Boolean expression. Predicates may be used  much
                     like  1-bit  fields.  For  example,  <b>ip4</b>  might expand to <b>eth.type</b> <b>==</b> <b>0x800</b>. Predicates are
                     provided for syntactic convenience, because it is always possible to  instead  specify  the
                     underlying expression directly.

                     A  predicate  whose  expansion  refers  to  any  nominal  field  or predicate (see <b>Level</b> <b>of</b>
                     <b>Measurement</b>, below) is nominal; other predicates have Boolean level of measurement.

              <b>Level</b> <b>of</b> <b>Measurement</b>. See <a href="http://en.wikipedia.org/wiki/Level_of_measurement">http://en.wikipedia.org/wiki/Level_of_measurement</a>  for  the  statistical
              concept on which this classification is based. There are three levels:

              •      <u>Ordinal</u>. In statistics, ordinal values can be ordered on a scale. OVN considers a field (or
                     subfield)  to  be  ordinal  if  its bits can be examined individually. This is true for the
                     OpenFlow fields that OpenFlow or Open vSwitch makes ``maskable.’’

                     Any use  of  a  ordinal  field  may  specify  a  single  bit  or  a  range  of  bits,  e.g.
                     <b>vlan.tci[13..15]</b> refers to the PCP field within the VLAN TCI, and <b>eth.dst[40]</b> refers to the
                     multicast bit in the Ethernet destination address.

                     OVN  supports  all  the  usual  arithmetic  relations (<b>==</b>, <b>!=</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, and <b>&gt;=</b>) on ordinal
                     fields and their subfields, because OVN can implement these in OpenFlow and Open vSwitch as
                     collections of bitwise tests.

              •      <u>Nominal</u>. In statistics, nominal values cannot be usefully  compared  except  for  equality.
                     This  is  true of OpenFlow port numbers, Ethernet types, and IP protocols are examples: all
                     of these are just identifiers assigned arbitrarily with no deeper meaning. In OpenFlow  and
                     Open vSwitch, bits in these fields generally aren’t individually addressable.

                     OVN  only  supports  arithmetic  tests for equality on nominal fields, because OpenFlow and
                     Open vSwitch provide no way for a flow to efficiently implement other comparisons on  them.
                     (A test for inequality can be sort of built out of two flows with different priorities, but
                     OVN matching expressions always generate flows with a single priority.)

                     String fields are always nominal.

              •      <u>Boolean</u>.  A nominal field that has only two values, 0 and 1, is somewhat exceptional, since
                     it is easy to support both equality and inequality tests on such a field: either one can be
                     implemented as a test for 0 or 1.

                     Only predicates (see above) have a Boolean level of measurement.

                     This isn’t a standard level of measurement.

              <b>Prerequisites</b>. Any symbol can have prerequisites, which are additional condition  implied  by  the
              use  of  the  symbol.  For  example, For example, <b>icmp4.type</b> symbol might have prerequisite <b>icmp4</b>,
              which would cause an expression <b>icmp4.type</b> <b>==</b> <b>0</b> to be interpreted as <b>icmp4.type</b>  <b>==</b>  <b>0</b>  <b>&amp;&amp;</b>  <b>icmp4</b>,
              which  would  in  turn  expand to <b>icmp4.type</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>eth.type</b> <b>==</b> <b>0x800</b> <b>&amp;&amp;</b> <b>ip4.proto</b> <b>==</b> <b>1</b> (assuming
              <b>icmp4</b> is a predicate defined as suggested under <b>Types</b> above).

              <b>Relational</b> <b>operators</b>

              All of the standard relational operators <b>==</b>, <b>!=</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, and <b>&gt;=</b> are  supported.  Nominal  fields
              support  only  <b>==</b>  and  <b>!=</b>, and only in a positive sense when outer <b>!</b> are taken into account, e.g.
              given string field <b>inport</b>, <b>inport</b> <b>==</b> <b>"eth0"</b> and <b>!(inport</b> <b>!=</b> <b>"eth0")</b> are acceptable, but not <b>inport</b>
              <b>!=</b> <b>"eth0"</b>.

              The implementation of <b>==</b> (or <b>!=</b> when it is negated), is more efficient  than  that  of  the  other
              relational operators.

              <b>Constants</b>

              Integer  constants may be expressed in decimal, hexadecimal prefixed by <b>0x</b>, or as dotted-quad IPv4
              addresses, IPv6 addresses in their standard forms, or Ethernet addresses  as  colon-separated  hex
              digits.  A  constant  in  any of these forms may be followed by a slash and a second constant (the
              mask) in the same form, to form a masked constant. IPv4 and IPv6 masks may be given  as  integers,
              to express CIDR prefixes.

              String constants have the same syntax as quoted strings in JSON (thus, they are Unicode strings).

              Some  operators  support  sets  of  constants  written inside curly braces <b>{</b> ... <b>}</b>. Commas between
              elements of a set, and after the last elements, are optional. With <b>==</b>,  ``<u>field</u>  <b>==</b>  <b>{</b>  <u>constant1</u><b>,</b>
              <u>constant2</u><b>,</b>  ...  <b>}</b>’’  is  syntactic  sugar  for ``<u>field</u> <b>==</b> <u>constant1</u> <b>||</b> <u>field</u> <b>==</b> <u>constant2</u> <b>||</b> ....
              Similarly, ``<u>field</u> <b>!=</b> <b>{</b> <u>constant1</u><b>,</b> <u>constant2</u><b>,</b> ... <b>}</b>’’ is equivalent to  ``<u>field</u>  <b>!=</b>  <u>constant1</u>  <b>&amp;&amp;</b>
              <u>field</u> <b>!=</b> <u>constant2</u> <b>&amp;&amp;</b> ...’’.

              You  may  refer  to  a  set of IPv4, IPv6, or MAC addresses stored in the <b>Address_Set</b> table by its
              <b>name</b>. An <b>Address_Set</b> with a name of <b>set1</b> can be referred to as <b>$set1</b>.

              You may refer to a group of logical switch ports stored in the <b>Port_Group</b> table by  its  <b>name</b>.  An
              <b>Port_Group</b> with a name of <b>port_group1</b> can be referred to as <b>@port_group1</b>.

              Additionally,  you  may refer to the set of addresses belonging to a group of logical switch ports
              stored in the <b>Port_Group</b> table by its <b>name</b> followed by a suffix ’_ip4’/’_ip6’.  The  IPv4  address
              set  of  a  <b>Port_Group</b>  with a name of <b>port_group1</b> can be referred to as <b>$port_group1_ip4</b>, and the
              IPv6 address set of the same <b>Port_Group</b> can be referred to as <b>$port_group1_ip6</b>

              <b>Miscellaneous</b>

              Comparisons may name the symbol or the constant first, e.g. <b>tcp.src</b> <b>==</b> <b>80</b> and <b>80</b>  <b>==</b>  <b>tcp.src</b>  are
              both acceptable.

              Tests  for  a  range  may  be  expressed  using  a  syntax like <b>1024</b> <b>&lt;=</b> <b>tcp.src</b> <b>&lt;=</b> <b>49151</b>, which is
              equivalent to <b>1024</b> <b>&lt;=</b> <b>tcp.src</b> <b>&amp;&amp;</b> <b>tcp.src</b> <b>&lt;=</b> <b>49151</b>.

              For a one-bit field or predicate, a mention of its  name  is  equivalent  to  <u>symobl</u>  <b>==</b>  <b>1</b>,  e.g.
              <b>vlan.present</b>  is  equivalent  to  <b>vlan.present</b>  <b>==</b> <b>1</b>. The same is true for one-bit subfields, e.g.
              <b>vlan.tci[12]</b>. There is no technical limitation to implementing the same for ordinal fields of  all
              widths,  but  the  implementation  is  expensive enough that the syntax parser requires writing an
              explicit comparison against zero to make mistakes less likely, e.g. in <b>tcp.src</b> <b>!=</b> <b>0</b> the comparison
              against 0 is required.

              <b>Operator</b> <b>precedence</b> is as shown below, from highest to lowest.  There  are  two  exceptions  where
              parentheses  are required even though the table would suggest that they are not: <b>&amp;&amp;</b> and <b>||</b> require
              parentheses when  used  together,  and  <b>!</b>  requires  parentheses  when  applied  to  a  relational
              expression. Thus, in <b>(eth.type</b> <b>==</b> <b>0x800</b> <b>||</b> <b>eth.type</b> <b>==</b> <b>0x86dd)</b> <b>&amp;&amp;</b> <b>ip.proto</b> <b>==</b> <b>6</b> or <b>!(arp.op</b> <b>==</b> <b>1)</b>,
              the parentheses are mandatory.

              •      <b>()</b>

              •      <b>==</b>   <b>!=</b>   <b>&lt;</b>   <b>&lt;=</b>   <b>&gt;</b>   <b>&gt;=</b>

              •      <b>!</b>

              •      <b>&amp;&amp;</b>   <b>||</b>

              <b>Comments</b>  may  be introduced by <b>//</b>, which extends to the next new-line. Comments within a line may
              be bracketed by <b>/*</b> and <b>*/</b>. Multiline comments are not supported.

              <b>Symbols</b>

              Most of the symbols below have integer type. Only <b>inport</b> and  <b>outport</b>  have  string  type.  <b>inport</b>
              names  a logical port. Thus, its value is a <b>logical_port</b> name from the <b>Port_Binding</b> table. <b>outport</b>
              may name a logical port, as <b>inport</b>, or a logical multicast group defined  in  the  <b>Multicast_Group</b>
              table. For both symbols, only names within the flow’s logical datapath may be used.

              The  <b>reg</b><u>X</u> symbols are 32-bit integers. The <b>xxreg</b><u>X</u> symbols are 128-bit integers, which overlay four
              of the 32-bit registers: <b>xxreg0</b>  overlays  <b>reg0</b>  through  <b>reg3</b>,  with  <b>reg0</b>  supplying  the  most-
              significant  bits of <b>xxreg0</b> and <b>reg3</b> the least-significant. <b>xxreg1</b> similarly overlays <b>reg4</b> through
              <b>reg7</b>.

              •      <b>reg0</b>...<b>reg9</b>

              •      <b>xxreg0</b> <b>xxreg1</b>

              •      <b>inport</b> <b>outport</b>

              •      <b>flags.loopback</b>

              •      <b>pkt.mark</b>

              •      <b>eth.src</b> <b>eth.dst</b> <b>eth.type</b>

              •      <b>vlan.tci</b> <b>vlan.vid</b> <b>vlan.pcp</b> <b>vlan.present</b>

              •      <b>ip.proto</b> <b>ip.dscp</b> <b>ip.ecn</b> <b>ip.ttl</b> <b>ip.frag</b>

              •      <b>ip4.src</b> <b>ip4.dst</b>

              •      <b>ip6.src</b> <b>ip6.dst</b> <b>ip6.label</b>

              •      <b>arp.op</b> <b>arp.spa</b> <b>arp.tpa</b> <b>arp.sha</b> <b>arp.tha</b>

              •      <b>rarp.op</b> <b>rarp.spa</b> <b>rarp.tpa</b> <b>rarp.sha</b> <b>rarp.tha</b>

              •      <b>tcp.src</b> <b>tcp.dst</b> <b>tcp.flags</b>

              •      <b>udp.src</b> <b>udp.dst</b>

              •      <b>sctp.src</b> <b>sctp.dst</b>

              •      <b>icmp4.type</b> <b>icmp4.code</b>

              •      <b>icmp6.type</b> <b>icmp6.code</b>

              •      <b>nd.target</b> <b>nd.sll</b> <b>nd.tll</b>

              •      <b>ct_mark</b> <b>ct_label</b>

              •      <b>ct_state</b>, which has several Boolean subfields. The <b>ct_next</b> action initializes the following
                     subfields:

                     •      <b>ct.trk</b>: Always set to true by <b>ct_next</b> to indicate that connection tracking has taken
                            place. All other <b>ct</b> subfields have <b>ct.trk</b> as a prerequisite.

                     •      <b>ct.new</b>: True for a new flow

                     •      <b>ct.est</b>: True for an established flow

                     •      <b>ct.rel</b>: True for a related flow

                     •      <b>ct.rpl</b>: True for a reply flow

                     •      <b>ct.inv</b>: True for a connection entry in a bad state

                     The <b>ct_dnat</b>, <b>ct_snat</b>, and <b>ct_lb</b> actions initialize the following subfields:

                     •      <b>ct.dnat</b>: True for a packet whose destination IP address has been changed.

                     •      <b>ct.snat</b>: True for a packet whose source IP address has been changed.

              The following predicates are supported:

              •      <b>eth.bcast</b> expands to <b>eth.dst</b> <b>==</b> <b>ff:ff:ff:ff:ff:ff</b>

              •      <b>eth.mcast</b> expands to <b>eth.dst[40]</b>

              •      <b>eth.mcastv6</b> expands to <b>eth.dst[32..47]</b> <b>==</b> <b>0x3333</b>

              •      <b>vlan.present</b> expands to <b>vlan.tci[12]</b>

              •      <b>ip4</b> expands to <b>eth.type</b> <b>==</b> <b>0x800</b>

              •      <b>ip4.src_mcast</b> expands to <b>ip4.src[28..31]</b> <b>==</b> <b>0xe</b>

              •      <b>ip4.mcast</b> expands to <b>ip4.dst[28..31]</b> <b>==</b> <b>0xe</b>

              •      <b>ip6</b> expands to <b>eth.type</b> <b>==</b> <b>0x86dd</b>

              •      <b>ip</b> expands to <b>ip4</b> <b>||</b> <b>ip6</b>

              •      <b>icmp4</b> expands to <b>ip4</b> <b>&amp;&amp;</b> <b>ip.proto</b> <b>==</b> <b>1</b>

              •      <b>icmp6</b> expands to <b>ip6</b> <b>&amp;&amp;</b> <b>ip.proto</b> <b>==</b> <b>58</b>

              •      <b>icmp</b> expands to <b>icmp4</b> <b>||</b> <b>icmp6</b>

              •      <b>ip.is_frag</b> expands to <b>ip.frag[0]</b>

              •      <b>ip.later_frag</b> expands to <b>ip.frag[1]</b>

              •      <b>ip.first_frag</b> expands to <b>ip.is_frag</b> <b>&amp;&amp;</b> <b>!ip.later_frag</b>

              •      <b>arp</b> expands to <b>eth.type</b> <b>==</b> <b>0x806</b>

              •      <b>rarp</b> expands to <b>eth.type</b> <b>==</b> <b>0x8035</b>

              •      <b>ip6.mcast</b> expands to <b>eth.mcastv6</b> <b>&amp;&amp;</b> <b>ip6.dst[120..127]</b> <b>==</b> <b>0xff</b>

              •      <b>nd</b> expands to <b>icmp6.type</b> <b>==</b> <b>{135,</b> <b>136}</b> <b>&amp;&amp;</b> <b>icmp6.code</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>ip.ttl</b> <b>==</b> <b>255</b>

              •      <b>nd_ns</b> expands to <b>icmp6.type</b> <b>==</b> <b>135</b> <b>&amp;&amp;</b> <b>icmp6.code</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>ip.ttl</b> <b>==</b> <b>255</b>

              •      <b>nd_ns_mcast</b> expands to <b>ip6.mcast</b>  <b>&amp;&amp;</b> <b>icmp6.type</b> <b>==</b> <b>135</b> <b>&amp;&amp;</b> <b>icmp6.code</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>ip.ttl</b> <b>==</b> <b>255</b>

              •      <b>nd_na</b> expands to <b>icmp6.type</b> <b>==</b> <b>136</b> <b>&amp;&amp;</b> <b>icmp6.code</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>ip.ttl</b> <b>==</b> <b>255</b>

              •      <b>nd_rs</b> expands to <b>icmp6.type</b> <b>==</b> <b>133</b> <b>&amp;&amp;</b> <b>icmp6.code</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>ip.ttl</b> <b>==</b> <b>255</b>

              •      <b>nd_ra</b> expands to <b>icmp6.type</b> <b>==</b> <b>134</b> <b>&amp;&amp;</b> <b>icmp6.code</b> <b>==</b> <b>0</b> <b>&amp;&amp;</b> <b>ip.ttl</b> <b>==</b> <b>255</b>

              •      <b>tcp</b> expands to <b>ip.proto</b> <b>==</b> <b>6</b>

              •      <b>udp</b> expands to <b>ip.proto</b> <b>==</b> <b>17</b>

              •      <b>sctp</b> expands to <b>ip.proto</b> <b>==</b> <b>132</b>

       <b>actions</b>: string
              Logical datapath actions, to be executed when the logical flow represented  by  this  row  is  the
              highest-priority match.

              Actions  share lexical syntax with the <b>match</b> column. An empty set of actions (or one that contains
              just white space or comments), or a set of actions that consists of just <b>drop;</b>, causes the matched
              packets to be dropped. Otherwise, the column should contain a sequence of actions, each terminated
              by a semicolon.

              The following actions are defined:

              <b>output;</b>
                     In the ingress pipeline, this action executes the  <b>egress</b>  pipeline  as  a  subroutine.  If
                     <b>outport</b>  names  a  logical  port,  the  egress pipeline executes once; if it is a multicast
                     group, the egress pipeline runs once for each logical port in the group.

                     In the egress pipeline, this action performs the actual output to the <b>outport</b> logical port.
                     (In the egress pipeline, <b>outport</b> never names a multicast group.)

                     By default, output to the input port is implicitly dropped, that is, <b>output</b> becomes a no-op
                     if <b>outport</b> == <b>inport</b>. Occasionally it may be useful to override this behavior, e.g. to send
                     an ARP reply to an ARP request; to do so, use <b>flags.loopback</b> <b>=</b> <b>1</b> to  allow  the  packet  to
                     "hair-pin" back to the input port.

              <b>next;</b>
              <b>next(</b><u>table</u><b>);</b>
              <b>next(pipeline=</b><u>pipeline</u><b>,</b> <b>table=</b><u>table</u><b>);</b>
                   Executes  the  given logical datapath <u>table</u> in <u>pipeline</u> as a subroutine. The default <u>table</u> is
                   just after the current one. If <u>pipeline</u> is specified,  it  may  be  <b>ingress</b>  or  <b>egress</b>;  the
                   default  <u>pipeline</u>  is  the  one  currently  executing. Actions in the both ingress and egress
                   pipeline can use <b>next</b> to jump across the other pipeline.  Actions  in  the  ingress  pipeline
                   should use <b>next</b> to jump into the specific table of egress pipeline only if it is certain that
                   the  packets  are  local  and  not  tunnelled  and wants to skip certain stages in the packet
                   processing.

              <u>field</u> <b>=</b> <u>constant</u><b>;</b>
                   Sets data or metadata field <u>field</u> to constant value <u>constant</u>, e.g. <b>outport</b> <b>=</b> <b>"vif0";</b>  to  set
                   the  logical  output  port.  To  set only a subset of bits in a field, specify a subfield for
                   <u>field</u> or a masked <u>constant</u>, e.g. one may use <b>vlan.pcp[2]</b> <b>=</b> <b>1;</b> or <b>vlan.pcp</b> <b>=</b> <b>4/4;</b> to  set  the
                   most significant bit of the VLAN PCP.

                   Assigning  to  a field with prerequisites implicitly adds those prerequisites to <b>match</b>; thus,
                   for example, a flow that sets <b>tcp.dst</b> applies only to TCP flows, regardless  of  whether  its
                   <b>match</b> mentions any TCP field.

                   Not  all  fields  are  modifiable  (e.g.  <b>eth.type</b>  and  <b>ip.proto</b> are read-only), and not all
                   modifiable fields may be partially modified (e.g. <b>ip.ttl</b>  must  assigned  as  a  whole).  The
                   <b>outport</b> field is modifiable in the <b>ingress</b> pipeline but not in the <b>egress</b> pipeline.

              <u>ovn_field</u> <b>=</b> <u>constant</u><b>;</b>
                   Sets OVN field <u>ovn_field</u> to constant value <u>constant</u>.

                   <b>OVN</b>  supports setting the values of certain fields which are not yet supported in OpenFlow to
                   set or modify them.

                   Below are the supported <b>OVN</b> <b>fields</b>:

                   •      <b>icmp4.frag_mtu</b> <b>icmp6.frag_mtu</b>

                          This field sets the low-order 16 bits of the ICMP{4,6} header field that  is  labelled
                          "unused" in the ICMP specification as defined in the RFC 1191 with the value specified
                          in <u>constant</u>.

                          Eg. icmp4.frag_mtu = 1500;

              <u>field1</u> <b>=</b> <u>field2</u><b>;</b>
                   Sets data or metadata field <u>field1</u> to the value of data or metadata field <u>field2</u>, e.g. <b>reg0</b> <b>=</b>
                   <b>ip4.src;</b>  copies  <b>ip4.src</b>  into  <b>reg0</b>.  To  modify only a subset of a field’s bits, specify a
                   subfield for <u>field1</u> or <u>field2</u>  or  both,  e.g.  <b>vlan.pcp</b>  <b>=</b>  <b>reg0[0..2];</b>  copies  the  least-
                   significant bits of <b>reg0</b> into the VLAN PCP.

                   <u>field1</u>  and  <u>field2</u> must be the same type, either both string or both integer fields. If they
                   are both integer fields, they must have the same width.

                   If <u>field1</u> or <u>field2</u> has prerequisites, they are added implicitly to <b>match</b>. It is possible  to
                   write  an assignment with contradictory prerequisites, such as <b>ip4.src</b> <b>=</b> <b>ip6.src[0..31];</b>, but
                   the contradiction means that a logical flow with such an assignment will never be matched.

              <u>field1</u> <b>&lt;-&gt;</b> <u>field2</u><b>;</b>
                   Similar to <u>field1</u> <b>=</b> <u>field2</u><b>;</b> except that the two values are exchanged instead of copied.  Both
                   <u>field1</u> and <u>field2</u> must modifiable.

              <b>push(</b><u>field</u><b>);</b>
                   Push the value of <u>field</u> to the stack top.

              <b>pop(</b><u>field</u><b>);</b>
                   Pop the stack top and store the value to <u>field</u>, which must be modifiable.

              <b>ip.ttl--;</b>
                   Decrements the IPv4 or IPv6 TTL. If this would make the TTL zero or negative, then processing
                   of  the  packet  halts;  no  further actions are processed. (To properly handle such cases, a
                   higher-priority flow should match on <b>ip.ttl</b> <b>==</b> <b>{0,</b> <b>1};</b>.)

                   <b>Prerequisite:</b> <b>ip</b>

              <b>ct_next;</b>
              <b>ct_next(dnat);</b>
              <b>ct_next(snat);</b>
                   Apply connection tracking to the flow, initializing <b>ct_state</b> for matching  in  later  tables.
                   Automatically moves on to the next table, as if followed by <b>next</b>.

                   As  a  side  effect, IP fragments will be reassembled for matching. If a fragmented packet is
                   output, then it will be sent with any overlapping fragments squashed. The connection tracking
                   state is scoped by the logical port when the action is used in a flow for a  logical  switch,
                   so  overlapping  addresses may be used. To allow traffic related to the matched flow, execute
                   <b>ct_commit</b> . Connection tracking state is scoped by the logical topology when  the  action  is
                   used in a flow for a router.

                   It  is  possible  to have actions follow <b>ct_next</b>, but they will not have access to any of its
                   side-effects and is not generally useful.

              <b>ct_commit</b> <b>{</b> <b>};</b>
              <b>ct_commit</b> <b>{</b> <b>ct_mark=</b><u>value[/mask]</u><b>;</b> <b>};</b>
              <b>ct_commit</b> <b>{</b> <b>ct_label=</b><u>value[/mask]</u><b>;</b> <b>};</b>
              <b>ct_commit</b> <b>{</b> <b>ct_mark=</b><u>value[/mask]</u><b>;</b> <b>ct_label=</b><u>value[/mask]</u><b>;</b> <b>};</b>
                   Commit the flow to the connection tracking entry associated with it by  a  previous  call  to
                   <b>ct_next</b>.  When <b>ct_mark=</b><u>value[/mask]</u> and/or <b>ct_label=</b><u>value[/mask]</u> are supplied, <b>ct_mark</b> and/or
                   <b>ct_label</b> will be set to the values indicated  by  <u>value[/mask]</u>  on  the  connection  tracking
                   entry.  <b>ct_mark</b>  is  a  32-bit field. <b>ct_label</b> is a 128-bit field. The <u>value[/mask]</u> should be
                   specified in hex string if more than 64bits are to be used. Registers and other named  fields
                   can  be  used  for <u>value</u>. <b>ct_mark</b> and <b>ct_label</b> may be sub-addressed in order to have specific
                   bits set.

                   Note that if you want processing to continue in the next table, you  must  execute  the  <b>next</b>
                   action  after  <b>ct_commit</b>.  You  may also leave out <b>next</b> which will commit connection tracking
                   state, and then drop the packet. This could be useful for setting  <b>ct_mark</b>  on  a  connection
                   tracking entry before dropping a packet, for example.

              <b>ct_commit_to_zone(dnat);</b>
              <b>ct_commit_to_zone(snat);</b>
                   Commit  the  flow  to  the  specific  zone  in  the  connection  tracker.  The packet is then
                   automatically sent to the next tables as if followed by <b>next;</b> action. The  next  tables  will
                   see the changes in the packet caused by the connection tracker.

                   Note that this action is meaningful only in the Logical Router Datapath as the Logical Switch
                   Datapath does not use separate connection tracking zones. Using this action in Logical Switch
                   Datapath falls back to committing the flow into the logical port’s conntrack zone.

              <b>ct_dnat;</b>
              <b>ct_dnat(</b><u>IP</u><b>);</b>
                   <b>ct_dnat</b>  sends  the  packet  through the DNAT zone in connection tracking table to unDNAT any
                   packet that was DNATed in the opposite direction. The packet is then  automatically  sent  to
                   the  next  tables as if followed by <b>next;</b> action. The next tables will see the changes in the
                   packet caused by the connection tracker.

                   <b>ct_dnat(</b><u>IP</u><b>)</b> sends the packet through the DNAT zone to change the destination  IP  address  of
                   the  packet to the one provided inside the parentheses and commits the connection. The packet
                   is then automatically sent to the next tables as if followed by <b>next;</b> action. The next tables
                   will see the changes in the packet caused by the connection tracker.

              <b>ct_snat;</b>
              <b>ct_snat(</b><u>IP</u><b>);</b>
                   <b>ct_snat</b> sends the packet through the SNAT zone to unSNAT any packet that was  SNATed  in  the
                   opposite direction. The packet is automatically sent to the next tables as if followed by the
                   <b>next;</b>  action.  The  next  tables will see the changes in the packet caused by the connection
                   tracker.

                   <b>ct_snat(</b><u>IP</u><b>)</b> sends the packet through the SNAT zone to change the source  IP  address  of  the
                   packet  to  the one provided inside the parenthesis and commits the connection. The packet is
                   then automatically sent to the next tables as if followed by <b>next;</b> action.  The  next  tables
                   will see the changes in the packet caused by the connection tracker.

              <b>ct_dnat_in_czone;</b>
              <b>ct_dnat_in_czone(</b><u>IP</u><b>);</b>
                   <b>ct_dnat_in_czone</b>  sends  the packet through the common NAT zone (used for both DNAT and SNAT)
                   in connection tracking table to unDNAT any packet that was DNATed in the opposite  direction.
                   The  packet is then automatically sent to the next tables as if followed by <b>next;</b> action. The
                   next tables will see the changes in the packet caused by the connection tracker.

                   <b>ct_dnat_in_czone(</b><u>IP</u><b>)</b> sends the packet through the common NAT zone to change  the  destination
                   IP  address  of  the  packet  to  the  one  provided  inside  the parentheses and commits the
                   connection. The packet is then automatically sent to the next tables as if followed by  <b>next;</b>
                   action. The next tables will see the changes in the packet caused by the connection tracker.

              <b>ct_snat_in_czone;</b>
              <b>ct_snat_in_czone(</b><u>IP</u><b>);</b>
                   <b>ct_snat_in_czone</b>  sends  the packet through the common NAT zone to unSNAT any packet that was
                   SNATed in the opposite direction. The packet is automatically sent to the next tables  as  if
                   followed  by  the  <b>next;</b> action. The next tables will see the changes in the packet caused by
                   the connection tracker.

                   <b>ct_snat_in_czone(</b><u>IP</u><b>)</b> sends the packet\ through the common NAT zone to change  the  source  IP
                   address  of the packet to the one provided inside the parenthesis and commits the connection.
                   The packet is then automatically sent to the next tables as if followed by <b>next;</b> action.  The
                   next tables will see the changes in the packet caused by the connection tracker.

              <b>ct_clear;</b>
                   Clears connection tracking state.

              <b>ct_commit_nat;</b>
                   Applies  NAT  and commits the connection to the CT. Automatically moves on to the next table,
                   as if followed by <b>next</b>. This is very useful for connections that are  in  related  state  for
                   already existing connections and allows the NAT to be applied to them as well.

              <b>clone</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Makes  a  copy  of  the  packet being processed and executes each <b>action</b> on the copy. Actions
                   following the <u>clone</u> action, if any, apply to the original, unmodified  packet.  This  can  be
                   used  as  a way to ``save and restore’’ the packet around a set of actions that may modify it
                   and should not persist.

              <b>arp</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Temporarily replaces the IPv4 packet being processed by  an  ARP  packet  and  executes  each
                   nested  <u>action</u>  on  the  ARP  packet.  Actions following the <u>arp</u> action, if any, apply to the
                   original, unmodified packet.

                   The ARP packet that this action operates on is initialized based on  the  IPv4  packet  being
                   processed, as follows. These are default values that the nested actions will probably want to
                   change:

                   •      <b>eth.src</b> unchanged

                   •      <b>eth.dst</b> unchanged

                   •      <b>eth.type</b> <b>=</b> <b>0x0806</b>

                   •      <b>arp.op</b> <b>=</b> <b>1</b> (ARP request)

                   •      <b>arp.sha</b> copied from <b>eth.src</b>

                   •      <b>arp.spa</b> copied from <b>ip4.src</b>

                   •      <b>arp.tha</b> <b>=</b> <b>00:00:00:00:00:00</b>

                   •      <b>arp.tpa</b> copied from <b>ip4.dst</b>

                   The ARP packet has the same VLAN header, if any, as the IP packet it replaces.

                   <b>Prerequisite:</b> <b>ip4</b>

              <b>get_arp(</b><u>P</u><b>,</b> <u>A</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 32-bit IP address field <u>A</u>.

                   Looks  up  <u>A</u>  in  <u>P</u>’s mac binding table. If an entry is found, stores its Ethernet address in
                   <b>eth.dst</b>, otherwise stores <b>00:00:00:00:00:00</b> in <b>eth.dst</b>.

                   <b>Example:</b> <b>get_arp(outport,</b> <b>ip4.dst);</b>

              <b>put_arp(</b><u>P</u><b>,</b> <u>A</u><b>,</b> <u>E</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 32-bit IP address field <u>A</u>, 48-bit  Ethernet  address
                   field <u>E</u>.

                   Adds or updates the entry for IP address <u>A</u> in logical port <u>P</u>’s mac binding table, setting its
                   Ethernet address to <u>E</u>.

                   <b>Example:</b> <b>put_arp(inport,</b> <b>arp.spa,</b> <b>arp.sha);</b>

              <u>R</u> <b>=</b> <b>lookup_arp(</b><u>P</u><b>,</b> <u>A</u><b>,</b> <u>M</u><b>);</b>
                   <b>Parameters</b>:  logical port string field <u>P</u>, 32-bit IP address field <u>A</u>, 48-bit MAC address field
                   <u>M</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Looks up <u>A</u> and <u>M</u> in <u>P</u>’s mac binding table. If an entry  is  found,  stores  <b>1</b>  in  the  1-bit
                   subfield <u>R</u>, else 0.

                   <b>Example:</b> <b>reg0[0]</b> <b>=</b> <b>lookup_arp(inport,</b> <b>arp.spa,</b> <b>arp.sha);</b>

              <u>R</u> <b>=</b> <b>lookup_arp_ip(</b><u>P</u><b>,</b> <u>A</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 32-bit IP address field <u>A</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Looks  up <u>A</u> in <u>P</u>’s mac binding table. If an entry is found, stores <b>1</b> in the 1-bit subfield <u>R</u>,
                   else 0.

                   <b>Example:</b> <b>reg0[0]</b> <b>=</b> <b>lookup_arp_ip(inport,</b> <b>arp.spa);</b>

              <u>P</u> <b>=</b> <b>get_fdb(</b><u>A</u><b>);</b>
                   <b>Parameters</b>:48-bit MAC address field <u>A</u>.

                   Looks up <u>A</u> in fdb table. If an entry is found,  stores  the  logical  port  key  to  the  out
                   parameter <b>P</b>.

                   <b>Example:</b> <b>outport</b> <b>=</b> <b>get_fdb(eth.src);</b>

              <b>put_fdb(</b><u>P</u><b>,</b> <u>A</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 48-bit MAC address field <u>A</u>.

                   Adds  or  updates the entry for Ethernet address <u>A</u> in fdb table, setting its logical port key
                   to <u>P</u>.

                   <b>Example:</b> <b>put_fdb(inport,</b> <b>arp.spa);</b>

              <u>R</u> <b>=</b> <b>lookup_fdb(</b><u>P</u><b>,</b> <u>A</u><b>);</b>
                   <b>Parameters</b>: 48-bit MAC address field <u>M</u>, logical port string field <u>P</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Looks up <u>A</u> in fdb table. If an entry is found and the logical port key is <u>P</u>, <b>P</b>, stores  <b>1</b>  in
                   the  1-bit subfield <u>R</u>, else 0. If <b>flags.localnet</b> is set then <b>1</b> is stored if an entry is found
                   and the logical port key is <u>P</u> or if an entry is found and the entry port type is VIF.

                   <b>Example:</b> <b>reg0[0]</b> <b>=</b> <b>lookup_fdb(inport,</b> <b>eth.src);</b>

              <b>nd_ns</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Temporarily replaces the IPv6 packet being processed by an IPv6 Neighbor Solicitation  packet
                   and executes each nested <u>action</u> on the IPv6 NS packet. Actions following the <u>nd_ns</u> action, if
                   any, apply to the original, unmodified packet.

                   The IPv6 NS packet that this action operates on is initialized based on the IPv6 packet being
                   processed, as follows. These are default values that the nested actions will probably want to
                   change:

                   •      <b>eth.src</b> unchanged

                   •      <b>eth.dst</b> set to IPv6 multicast MAC address

                   •      <b>eth.type</b> <b>=</b> <b>0x86dd</b>

                   •      <b>ip6.src</b> copied from <b>ip6.src</b>

                   •      <b>ip6.dst</b> set to IPv6 Solicited-Node multicast address

                   •      <b>icmp6.type</b> <b>=</b> <b>135</b> (Neighbor Solicitation)

                   •      <b>nd.target</b> copied from <b>ip6.dst</b>

                   The IPv6 NS packet has the same VLAN header, if any, as the IP packet it replaces.

                   <b>Prerequisite:</b> <b>ip6</b>

              <b>nd_na</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Temporarily  replaces  the  IPv6  neighbor  solicitation  packet  being  processed by an IPv6
                   neighbor advertisement (NA) packet and executes each nested <u>action</u> on the NA packet.  Actions
                   following the <b>nd_na</b> action, if any, apply to the original, unmodified packet.

                   The  NA  packet  that  this  action operates on is initialized based on the IPv6 packet being
                   processed, as follows. These are default values that the nested actions will probably want to
                   change:

                   •      <b>eth.dst</b> exchanged with <b>eth.src</b>

                   •      <b>eth.type</b> <b>=</b> <b>0x86dd</b>

                   •      <b>ip6.dst</b> copied from <b>ip6.src</b>

                   •      <b>ip6.src</b> copied from <b>nd.target</b>

                   •      <b>icmp6.type</b> <b>=</b> <b>136</b> (Neighbor Advertisement)

                   •      <b>nd.target</b> unchanged

                   •      <b>nd.sll</b> <b>=</b> <b>00:00:00:00:00:00</b>

                   •      <b>nd.tll</b> copied from <b>eth.dst</b>

                   The ND packet has the same VLAN header, if any, as the IPv6 packet it replaces.

                   <b>Prerequisite:</b> <b>nd_ns</b>

              <b>nd_na_router</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Temporarily replaces the IPv6  neighbor  solicitation  packet  being  processed  by  an  IPv6
                   neighbor  advertisement  (NA)  packet,  sets ND_NSO_ROUTER in the RSO flags and executes each
                   nested <u>action</u> on the NA packet. Actions following the <b>nd_na_router</b> action, if any,  apply  to
                   the original, unmodified packet.

                   The  NA  packet  that  this  action operates on is initialized based on the IPv6 packet being
                   processed, as follows. These are default values that the nested actions will probably want to
                   change:

                   •      <b>eth.dst</b> exchanged with <b>eth.src</b>

                   •      <b>eth.type</b> <b>=</b> <b>0x86dd</b>

                   •      <b>ip6.dst</b> copied from <b>ip6.src</b>

                   •      <b>ip6.src</b> copied from <b>nd.target</b>

                   •      <b>icmp6.type</b> <b>=</b> <b>136</b> (Neighbor Advertisement)

                   •      <b>nd.target</b> unchanged

                   •      <b>nd.sll</b> <b>=</b> <b>00:00:00:00:00:00</b>

                   •      <b>nd.tll</b> copied from <b>eth.dst</b>

                   The ND packet has the same VLAN header, if any, as the IPv6 packet it replaces.

                   <b>Prerequisite:</b> <b>nd_ns</b>

              <b>get_nd(</b><u>P</u><b>,</b> <u>A</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 128-bit IPv6 address field <u>A</u>.

                   Looks up <u>A</u> in <u>P</u>’s mac binding table. If an entry is found, stores  its  Ethernet  address  in
                   <b>eth.dst</b>, otherwise stores <b>00:00:00:00:00:00</b> in <b>eth.dst</b>.

                   <b>Example:</b> <b>get_nd(outport,</b> <b>ip6.dst);</b>

              <b>put_nd(</b><u>P</u><b>,</b> <u>A</u><b>,</b> <u>E</u><b>);</b>
                   <b>Parameters</b>:  logical  port  string  field  <u>P</u>,  128-bit  IPv6 address field <u>A</u>, 48-bit Ethernet
                   address field <u>E</u>.

                   Adds or updates the entry for IPv6 address <u>A</u> in logical port <u>P</u>’s mac binding  table,  setting
                   its Ethernet address to <u>E</u>.

                   <b>Example:</b> <b>put_nd(inport,</b> <b>nd.target,</b> <b>nd.tll);</b>

              <u>R</u> <b>=</b> <b>lookup_nd(</b><u>P</u><b>,</b> <u>A</u><b>,</b> <u>M</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 128-bit IP address field <u>A</u>, 48-bit MAC address field
                   <u>M</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Looks  up  <u>A</u>  and  <u>M</u>  in  <u>P</u>’s  mac binding table. If an entry is found, stores <b>1</b> in the 1-bit
                   subfield <u>R</u>, else 0.

                   <b>Example:</b> <b>reg0[0]</b> <b>=</b> <b>lookup_nd(inport,</b> <b>ip6.src,</b> <b>eth.src);</b>

              <u>R</u> <b>=</b> <b>lookup_nd_ip(</b><u>P</u><b>,</b> <u>A</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>, 128-bit IP address field <u>A</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Looks up <u>A</u> in <u>P</u>’s mac binding table. If an entry is found, stores <b>1</b> in the 1-bit subfield  <u>R</u>,
                   else 0.

                   <b>Example:</b> <b>reg0[0]</b> <b>=</b> <b>lookup_nd_ip(inport,</b> <b>ip6.src);</b>

              <u>R</u> <b>=</b> <b>put_dhcp_opts(</b><u>D1</u> <b>=</b> <u>V1</u><b>,</b> <u>D2</u> <b>=</b> <u>V2</u><b>,</b> <b>...,</b> <u>Dn</u> <b>=</b> <u>Vn</u><b>);</b>
                   <b>Parameters</b>:  one  or more DHCP option/value pairs, which must include an <b>offerip</b> option (with
                   code 0).

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Valid only in the ingress pipeline.

                   When this action is applied to a  DHCP  request  packet  (DHCPDISCOVER  or  DHCPREQUEST),  it
                   changes  the  packet  into  a  DHCP  reply (DHCPOFFER or DHCPACK, respectively), replaces the
                   options by those specified as parameters, and stores 1 in <u>R</u>.

                   When this action is applied to a non-DHCP packet or a DHCP packet that is not DHCPDISCOVER or
                   DHCPREQUEST, it leaves the packet unchanged and stores 0 in <u>R</u>.

                   The contents of the <b>DHCP_Option</b> table control the DHCP option  names  and  values  that  this
                   action supports.

                   <b>Example:</b>   <b>reg0[0]</b>   <b>=</b>  <b>put_dhcp_opts(offerip</b>  <b>=</b>  <b>10.0.0.2,</b>  <b>router</b>  <b>=</b>  <b>10.0.0.1,</b>  <b>netmask</b>  <b>=</b>
                   <b>255.255.255.0,</b> <b>dns_server</b> <b>=</b> <b>{8.8.8.8,</b> <b>7.7.7.7});</b>

              <u>R</u> <b>=</b> <b>put_dhcpv6_opts(</b><u>D1</u> <b>=</b> <u>V1</u><b>,</b> <u>D2</u> <b>=</b> <u>V2</u><b>,</b> <b>...,</b> <u>Dn</u> <b>=</b> <u>Vn</u><b>);</b>
                   <b>Parameters</b>: one or more DHCPv6 option/value pairs.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Valid only in the ingress pipeline.

                   When this action is applied to a DHCPv6 request packet, it changes the packet into  a  DHCPv6
                   reply, replaces the options by those specified as parameters, and stores 1 in <u>R</u>.

                   When  this  action is applied to a non-DHCPv6 packet or an invalid DHCPv6 request packet , it
                   leaves the packet unchanged and stores 0 in <u>R</u>.

                   The contents of the <b>DHCPv6_Options</b> table control the DHCPv6 option names and values that this
                   action supports.

                   <b>Example:</b>  <b>reg0[3]</b>  <b>=</b>  <b>put_dhcpv6_opts(ia_addr</b>  <b>=</b>  <b>aef0::4,</b>  <b>server_id</b>  <b>=</b>   <b>00:00:00:00:10:02,</b>
                   <b>dns_server={ae70::1,ae70::2});</b>

              <b>set_queue(</b><u>queue_number</u><b>);</b>
                   <b>Parameters</b>: Queue number <u>queue_number</u>, in the range 0 to 61440.

                   This is a logical equivalent of the OpenFlow <b>set_queue</b> action. It affects packets that egress
                   a  hypervisor  through  a  physical interface. For nonzero <u>queue_number</u>, it configures packet
                   queuing to match the settings configured for  the  <b>Port_Binding</b>  with  <b>options:qdisc_queue_id</b>
                   matching <u>queue_number</u>. When <u>queue_number</u> is zero, it resets queuing to the default strategy.

                   <b>Example:</b> <b><a href="../man10/set_queue.10.html">set_queue</a>(10);</b>

              <b>ct_lb;</b>
              <b>ct_lb(backends=</b><u>ip</u><b>[:</b><u>port</u><b>][,...][;</b> <b>hash_fields=</b><u>field1</u><b>,</b><u>field2</u><b>,...][;</b> <b>ct_flag]);</b>
                   With  arguments,  <b>ct_lb</b>  commits  the  packet  to the connection tracking table and DNATs the
                   packet’s destination IP address (and port) to the  IP  address  or  addresses  (and  optional
                   ports)  specified  in  the  <b>backends</b>. If multiple comma-separated IP addresses are specified,
                   each is given equal weight for picking the DNAT address. By default, <b>dp_hash</b> is used  as  the
                   OpenFlow  group  selection  method,  but  if  <b>hash_fields</b>  is  specified, <b>hash</b> is used as the
                   selection method, and the fields listed are used  as  the  hash  fields.  The  <b>ct_flag</b>  field
                   represents  one  of  supported  flag:  <b>skip_snat</b>  or  <b>force_snat</b>, this flag will be stored in
                   <b>ct_label</b> register.

                   Without arguments, <b>ct_lb</b> sends the packet  to  the  connection  tracking  table  to  NAT  the
                   packets.  If the packet is part of an established connection that was previously committed to
                   the connection tracker via <b>ct_lb(</b>...<b>)</b>, it will  automatically  get  DNATed  to  the  same  IP
                   address as the first packet in that connection.

                   Processing  automatically  moves  on to the next table, as if <b>next;</b> were specified, and later
                   tables act on the packet as modified by the connection tracker. Connection tracking state  is
                   scoped  by  the  logical  port  when  the  action  is used in a flow for a logical switch, so
                   overlapping addresses may be used.  Connection  tracking  state  is  scoped  by  the  logical
                   topology when the action is used in a flow for a router.

              <b>ct_lb_mark;</b>
              <b>ct_lb_mark(backends=</b><u>ip</u><b>[:</b><u>port</u><b>][,...][;</b> <b>hash_fields=</b><u>field1</u><b>,</b><u>field2</u><b>,...][;</b> <b>ct_flag]);</b>
                   Same as <b>ct_lb</b>, except that it internally uses ct_mark to store the NAT flag, while <b>ct_lb</b> uses
                   ct_label for the same purpose.

              <u>R</u> <b>=</b> <b>dns_lookup();</b>
                   <b>Parameters</b>: No parameters.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Valid only in the ingress pipeline.

                   When  this  action is applied to a valid DNS request (a UDP packet typically directed to port
                   53), it attempts to resolve the query  using  the  contents  of  the  <b>DNS</b>  table.  If  it  is
                   successful,  it  changes  the  packet  into  a  DNS reply and stores 1 in <u>R</u>. If the action is
                   applied to a non-DNS packet, an invalid DNS request packet, or a valid DNS request for  which
                   the <b>DNS</b> table does not supply an answer, it leaves the packet unchanged and stores 0 in <u>R</u>.

                   Regardless  of  success,  the  action  does  not make any of the changes to the flow that are
                   necessary to direct the packet back to the requester. The logical pipeline can implement this
                   behavior with matches and actions in later tables.

                   <b>Example:</b> <b>reg0[3]</b> <b>=</b> <b>dns_lookup();</b>

                   <b>Prerequisite:</b> <b>udp</b>

              <u>R</u> <b>=</b> <b>put_nd_ra_opts(</b><u>D1</u> <b>=</b> <u>V1</u><b>,</b> <u>D2</u> <b>=</b> <u>V2</u><b>,</b> <b>...,</b> <u>Dn</u> <b>=</b> <u>Vn</u><b>);</b>
                   <b>Parameters</b>: The following IPv6 ND Router Advertisement option/value pairs as defined  in  RFC
                   4861.

                   •      <b>addr_mode</b>

                          Mandatory  parameter  which  specifies  the address mode flag to be set in the RA flag
                          options field. The value of this option is a string and the following  values  can  be
                          defined - "slaac", "dhcpv6_stateful" and "dhcpv6_stateless".

                   •      <b>slla</b>

                          Mandatory parameter which specifies the link-layer address of the interface from which
                          the Router Advertisement is sent.

                   •      <b>mtu</b>

                          Optional parameter which specifies the MTU.

                   •      <b>prefix</b>

                          Optional  parameter  which  should  be  specified  if  the  addr_mode  is  "slaac"  or
                          "dhcpv6_stateless". The value should  be  an  IPv6  prefix  which  will  be  used  for
                          stateless IPv6 address configuration. This option can be defined multiple times.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   Valid only in the ingress pipeline.

                   When  this  action  is  applied to an IPv6 Router solicitation request packet, it changes the
                   packet into an IPv6 Router  Advertisement  reply  and  adds  the  options  specified  in  the
                   parameters, and stores 1 in <u>R</u>.

                   When  this  action  is  applied  to  a non-IPv6 Router solicitation packet or an invalid IPv6
                   request packet , it leaves the packet unchanged and stores 0 in <u>R</u>.

                   <b>Example:</b> <b>reg0[3]</b> <b>=</b> <b>put_nd_ra_opts(addr_mode</b> <b>=</b> <b>"slaac",</b> <b>slla</b>  <b>=</b>  <b>00:00:00:00:10:02,</b>  <b>prefix</b>  <b>=</b>
                   <b>aef0::/64,</b> <b>mtu</b> <b>=</b> <b>1450);</b>

              <b>set_meter(</b><u>rate</u><b>);</b>
              <b>set_meter(</b><u>rate</u><b>,</b> <u>burst</u><b>);</b>
                   <b>Parameters</b>: rate limit int field <u>rate</u> in kbps, burst rate limits int field <u>burst</u> in kbps.

                   This action sets the rate limit for a flow.

                   <b>Example:</b> <b>set_meter(100,</b> <b>1000);</b>

              <u>R</u> <b>=</b> <b>check_pkt_larger(</b><u>L</u><b>)</b>
                   <b>Parameters</b>: packet length <u>L</u> to check for in bytes.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   This is a logical equivalent of the OpenFlow <b>check_pkt_larger</b> action. If the packet is larger
                   than the length specified in <u>L</u>, it stores 1 in the subfield <u>R</u>.

                   <b>Example:</b> <b>reg0[6]</b> <b>=</b> <b><a href="../man1000/check_pkt_larger.1000.html">check_pkt_larger</a>(1000);</b>

              <b>log(</b><u>key</u><b>=</b><u>value</u><b>,</b> ...<b>);</b>
                     Causes  <b>ovn-controller</b>  to  log the packet on the chassis that processes it. Packet logging
                     currently uses the same logging mechanism as other Open vSwitch  and  OVN  messages,  which
                     means that whether and where log messages appear depends on the local logging configuration
                     that can be configured with <b>ovs-appctl</b>, etc.

                     The  <b>log</b>  action  takes zero or more of the following key-value pair arguments that control
                     what is logged:

                     <b>name=</b><u>string</u>
                            An optional name for the ACL. The <u>string</u> is currently limited to 64 bytes.

                     <b>severity=</b><u>level</u>
                            Indicates the severity of the event. The <u>level</u> is one of  following  (from  more  to
                            less  serious):  <b>alert</b>,  <b>warning</b>,  <b>notice</b>,  <b>info</b>,  or  <b>debug</b>.  If  a severity is not
                            provided, the default is <b>info</b>.

                     <b>verdict=</b><u>value</u>
                            The verdict for packets matching the flow. The value must be one of <b>allow</b>, <b>deny</b>,  or
                            <b>reject</b>.

                     <b>meter=</b><u>string</u>
                            An  optional  rate-limiting  meter  to  be  applied  to  the logs. The <u>string</u> should
                            reference a <b>name</b> entry  from  the  <b>Meter</b>  table.  The  only  meter  <b>action</b>  that  is
                            appropriate is <b>drop</b>.

              <b>fwd_group(liveness=</b><u>bool</u><b>,</b> <b>childports=</b><u>port</u><b>,</b> <b>...);</b>
                     <b>Parameters</b>:  optional  <b>liveness</b>,  either  <b>true</b> or <b>false</b>, defaulting to false; <b>childports</b>, a
                     comma-delimited list of strings denoting logical ports to load balance across.

                     Load balance traffic to one or  more  child  ports  in  a  logical  switch.  <b>ovn-controller</b>
                     translates  the  <b>fwd_group</b>  into  an OpenFlow group with one bucket for each child port. If
                     <b>liveness=true</b> is specified, it also integrates the bucket selection with BFD status on  the
                     tunnel interface corresponding to child port.

                     <b>Example:</b> <b>fwd_group(liveness=true,</b> <b>childports="p1",</b> <b>"p2");</b>

              <b>icmp4</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
              <b>icmp4_error</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Temporarily  replaces  the  IPv4 packet being processed by an ICMPv4 packet and executes each
                   nested <u>action</u> on the ICMPv4 packet. Actions following these actions, if  any,  apply  to  the
                   original, unmodified packet.

                   The  ICMPv4  packet  that  these  actions operates on is initialized based on the IPv4 packet
                   being processed, as follows. These are default values that the nested actions  will  probably
                   want to change. Ethernet and IPv4 fields not listed here are not changed:

                   •      <b>ip.proto</b> <b>=</b> <b>1</b> (ICMPv4)

                   •      <b>ip.frag</b> <b>=</b> <b>0</b> (not a fragment)

                   •      <b>ip.ttl</b> <b>=</b> <b>255</b>

                   •      <b>icmp4.type</b> <b>=</b> <b>3</b> (destination unreachable)

                   •      <b>icmp4.code</b> <b>=</b> <b>1</b> (host unreachable)

                   <b>icmp4_error</b>  action  is  expected  to  be used to generate an ICMPv4 packet in response to an
                   error in original IP packet. When this action generates the ICMPv4 packet, it also copies the
                   original IP datagram following the ICMPv4 header as per RFC 1122: 3.2.2.

                   <b>Prerequisite:</b> <b>ip4</b>

              <b>icmp6</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
              <b>icmp6_error</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   Temporarily replaces the IPv6 packet being processed by an ICMPv6 packet  and  executes  each
                   nested  <u>action</u> on the ICMPv6 packet. Actions following the <u>icmp6</u> action, if any, apply to the
                   original, unmodified packet.

                   The ICMPv6 packet that this action operates on is initialized based on the IPv6 packet  being
                   processed, as follows. These are default values that the nested actions will probably want to
                   change. Ethernet and IPv6 fields not listed here are not changed:

                   •      <b>ip.proto</b> <b>=</b> <b>58</b> (ICMPv6)

                   •      <b>ip.ttl</b> <b>=</b> <b>255</b>

                   •      <b>icmp6.type</b> <b>=</b> <b>1</b> (destination unreachable)

                   •      <b>icmp6.code</b> <b>=</b> <b>1</b> (administratively prohibited)

                   <b>icmp6_error</b>  action  is  expected  to  be used to generate an ICMPv6 packet in response to an
                   error in original IPv6 packet.

                   <b>Prerequisite:</b> <b>ip6</b>

              <b>tcp_reset;</b>
                   This action transforms the current TCP packet according to the following pseudocode:

                   <b>if</b> <b>(tcp.ack)</b> <b>{</b>
                           <b>tcp.seq</b> <b>=</b> <b>tcp.ack;</b>
                   <b>}</b> <b>else</b> <b>{</b>
                           <b>tcp.ack</b> <b>=</b> <b>tcp.seq</b> <b>+</b> <b>length(tcp.payload);</b>
                           <b>tcp.seq</b> <b>=</b> <b>0;</b>
                   <b>}</b>
                   <b>tcp.flags</b> <b>=</b> <b>RST;</b>

                   Then, the action drops all TCP options and payload data, and updates the TCP checksum. IP ttl
                   is set to 255.

                   <b>Prerequisite:</b> <b>tcp</b>

              <b>reject</b> <b>{</b> <u>action</u><b>;</b> ... <b>};</b>
                   If the original packet is IPv4 or IPv6 TCP packet, it replaces it with IPv4 or IPv6  TCP  RST
                   packet  and  executes  the  inner  actions. Otherwise it replaces it with an ICMPv4 or ICMPv6
                   packet and executes the inner actions.

                   The inner actions should not attempt to swap eth source with eth destination  and  IP  source
                   with IP destination as this action implicitly does that.

              <b>trigger_event;</b>
                   This  action  is  used  to  allow  ovs-vswitchd  to report CMS related events writing them in
                   <b>Controller_Event</b> table. It is possible to associate a meter to a each event in order  to  not
                   overload  pinctrl  thread  under heavy load; each meter is identified though a defined naming
                   convention. Supported events:

                   •      <u>empty_lb_backends</u>. This event is raised if a received packet is destined  for  a  load
                          balancer  VIP  that  has no configured backend destinations. For this event, the event
                          info includes the load balancer  VIP,  the  load  balancer  UUID,  and  the  transport
                          protocol. Associated meter: <b>event-elb</b>

              <b>igmp;</b>
                   This action sends the packet to <b>ovn-controller</b> for multicast snooping.

                   <b>Prerequisite:</b> <b>igmp</b>

              <b>bind_vport(</b><u>V</u><b>,</b> <u>P</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>V</u> of type <b>virtual</b>, logical port string field <u>P</u>.

                   Binds  the virtual logical port <u>V</u> and sets the <b>chassis</b> column and <b>virtual_parent</b> of the table
                   <b>Port_Binding</b>. <b>virtual_parent</b> is set to <u>P</u>.

              <b>handle_svc_check(</b><u>P</u><b>);</b>
                   <b>Parameters</b>: logical port string field <u>P</u>.

                   Handles the service monitor reply received from the VIF of the logical port <u>P</u>. <b>ovn-controller</b>
                   periodically sends out the service  monitor  packets  for  the  services  configured  in  the
                   <b>Service_Monitor</b> table and this action updates the status of those services.

                   <b>Example:</b> <b>handle_svc_check(inport);</b>

              <b>handle_dhcpv6_reply;</b>
                   Handle  DHCPv6  prefix  delegation  advertisements/replies  from  a  IPv6  delegation server.
                   <b>ovn-controller</b> will add an entry  <b>ipv6_ra_pd_list</b>  in  the  <b>options</b>  table  for  each  prefix
                   received from the delegation server

              <u>R</u> <b>=</b> <b>select(</b><u>N1</u><b>[=</b><u>W1</u><b>],</b> <u>N2</u><b>[=</b><u>W2</u><b>],</b> <b>...);</b>
              <u>R</u> <b>=</b> <b>select(values=(</b><u>N1</u><b>[=</b><u>W1</u><b>],</b> <u>N2</u><b>[=</b><u>W2</u><b>],</b> <b>...);</b> <b>hash_fields="</b><u>field1</u><b>,</b><u>field2</u><b>,...");</b>
                   <b>Parameters</b>: Integer <u>N1</u>, <u>N2</u>..., with optional weight <u>W1</u>, <u>W2</u>, ...

                   <b>Result</b>: stored to a logical field or subfield <u>R</u>.

                   Select  from  a  list  of  integers <u>N1</u>, <u>N2</u>..., each within the range 0 ~ 65535, and store the
                   selected one in the field <u>R</u>. There must be 2 or more integers listed, each with  an  optional
                   weight,  which  is  an  integer  within  the  range 1 ~ 65535. If weight is not specified, it
                   defaults to 100. The selection method is based on the 5-tuple hash of packet header.

                   By default, <b>dp_hash</b> is used as the  OpenFlow  group  selection  method,  but  if  <b>values</b>  and
                   <b>hash_fields</b>  are  specified,  <b>hash</b> is used as the selection method, and the fields listed are
                   used as the hash fields.

                   Processing automatically moves on to the next table, as if <b>next;</b> were specified.  The  <b>select</b>
                   action  must  be  put  as the last action of the logical flow when there are multiple actions
                   (actions put after <b>select</b> will not take effect).

                   <b>Example:</b>   <b>reg8[16..31]</b>   <b>=</b>   <b>select(1=20,</b>   <b>2=30,</b>    <b>3=50);</b>    <b>Example:</b>    <b>reg8[16..31]</b>    <b>=</b>
                   <b>select(values=(1=20,</b> <b>2=30,</b> <b>3=50);</b> <b>hash_fields="ip_proto,src_ip,dst_ip");</b>

              <b>handle_dhcpv6_reply;</b>
                   This  action  is  used  to  parse DHCPv6 replies from IPv6 Delegation Router and managed IPv6
                   Prefix delegation state machine

              <u>R</u> <b>=</b> <b>chk_lb_hairpin();</b>
                   This action checks if the packet under consideration was destined to a load balancer VIP  and
                   it  is hairpinned, i.e., after load balancing the destination IP matches the source IP. If it
                   is so, then the 1-bit destination register <u>R</u> is set to 1.

              <u>R</u> <b>=</b> <b>chk_lb_hairpin_reply();</b>
                   This action checks if the packet under consideration is from one of the backend IP of a  load
                   balancer  VIP  and  the  destination IP is the load balancer VIP. If it is so, then the 1-bit
                   destination register <u>R</u> is set to 1.

              <u>R</u> <b>=</b> <b>ct_snat_to_vip;</b>
                   This action sends the packet through the SNAT zone to change the source  IP  address  of  the
                   packet  to  the  load  balancer  VIP if the original destination IP was load balancer VIP and
                   commits the connection. This action applies successfully only for the hairpinned traffic  i.e
                   if  the action <b>chk_lb_hairpin</b> returned success. This action doesn’t take any arguments and it
                   determines the SNAT IP internally. The packet is not automatically sent to  the  next  table.
                   The caller has to execute the <b>next;</b> action explicitly after this action to advance the packet
                   to the next stage.

              <u>R</u> <b>=</b> <b>check_in_port_sec();</b>
                   This  action checks if the packet under consideration passes the inport port security checks.
                   If the packet fails the port security checks, then <b>1</b> is stored in the destination register <u>R</u>.
                   Else 0 is stored. The port security values to check are retrieved from the the <b>inport</b> logical
                   port.

                   This action should be used in the ingress logical switch pipeline.

                   <b>Example:</b> <b>reg8[0..7]</b> <b>=</b> <b>check_in_port_sec();</b>

              <u>R</u> <b>=</b> <b>check_out_port_sec();</b>
                   This action checks if the packet under consideration passes the outport port security checks.
                   If the packet fails the port security checks, then <b>1</b> is stored in the destination register <u>R</u>.
                   Else 0 is stored. The port security values to  check  are  retrieved  from  the  the  <b>outport</b>
                   logical port.

                   This action should be used in the egress logical switch pipeline.

                   <b>Example:</b> <b>reg8[0..7]</b> <b>=</b> <b>check_out_port_sec();</b>

              <b>commit_ecmp_nh(</b><u>ipv6</u><b>);</b>
                   <b>Parameters</b>: IPv4/IPv6 traffic.

                   This  action translates to an openflow "learn" action that inserts two new flows in tables 76
                   and 77.

                   •      Match on the  the  5-tuple  and  the  expected  next-hop  mac  address  in  table  76:
                          <b>nw_src=ip0</b>,  <b>nw_dst=ip1</b>,  <b>ip_proto</b>,<b>tp_src=l4_port0</b>, <b>tp_dst=l4_port1</b>,<b>dl_src=ethaddr</b> and
                          set <b>reg9[5]</b>.

                   •      Match on the 5-tuple in table 77: <b>nw_src=ip1</b>, <b>nw_dst=ip0</b>,  <b>ip_proto</b>,  <b>tp_src=l4_port1</b>,
                          <b>tp_dst=l4_port0</b> and set <b>reg9[5]</b> to 1

                   This  action  is  applied if the packet arrives via ECMP route or if it is routed via an ECMP
                   route

              <u>R</u> <b>=</b> <b>check_ecmp_nh_mac();</b>
                   This action checks if the packet under consideration matches any flow in table 76. If  it  is
                   so, then the 1-bit destination register <u>R</u> is set to 1.

              <u>R</u> <b>=</b> <b>check_ecmp_nh();</b>
                   This  action checks if the packet under consideration matches the any flow in table 77. If it
                   is so, then the 1-bit destination register <u>R</u> is set to 1.

                   commit_lb_aff(<u>vip</u><b>,</b> <u>backend</u><b>,</b> <u>proto</u><b>,</b> <u>timeout</u><b>);</b> <b>Parameters</b>: load-balancer virtual  ip:port  <u>vip</u>,
                   load-balancer  backend  ip:port  <u>backend</u>,  load-balancer  protocol  <u>proto</u>,  affinity  timeout
                   <u>timeout</u>.

                   This action translates to an openflow "learn" action that inserts a new flow in table 78.

                   •      Match on  the  4-tuple  in  table  78:  <b>nw_src=ip</b>  <b>client</b>,  <b>nw_dst=vip</b>  <b>ip</b>,  <b>ip_proto</b>,
                          <b>tp_dst=vip</b>  <b>port</b>  and  set  <b>reg9[6]</b>  to  1,  <b>reg4</b>  and  <b>reg8</b>  to  backend  ip and port
                          respectively. For IPv6 register <b>xxreg1</b> is used to store the backend ip.

                   This action is applied for new connections received by a specific load-balacer with  affinity
                   timeout configured.

              <u>R</u> <b>=</b> <b>chk_lb_aff();</b>
                   This  action  checks if the packet under consideration matches any flow in table 78. If it is
                   so, then the 1-bit destination register <u>R</u> is set to 1.

              <u>R</u> <b>=</b> <b>ct_nw_dst();</b>
                   This action checks if the packet is tracked and stores  the  conntrack  original  destination
                   IPv4 address in the register <u>R</u> of 32-bit size.

              <u>R</u> <b>=</b> <b>ct_ip6_dst();</b>
                   This  action  checks  if  the packet is tracked and stores the conntrack original destination
                   IPv6 address in the register <u>R</u> of 128-bit size.

              <u>R</u> <b>=</b> <b>ct_tp_dst();</b>
                   This action checks if the packet is tracked and stores the conntrack original L4  destination
                   port in the register <u>R</u> of 16-bit size.

              <b>sample(probability=</b><u>packets</u><b>,</b> <b>...)</b>
                   This  action  causes the matched traffic to be sampled using IPFIX protocol. More information
                   about how  per-flow  IPFIX  sampling  works  in  OVS  can  be  found  in  <b><a href="../man7/ovs-actions.7.html">ovs-actions</a></b>(7)  and
                   <b><a href="../man5/ovs-vswitchd.conf.db.5.html">ovs-vswitchd.conf.db</a></b>(5).

                   In order to reliably identify each sampled packet when it is received by the IPFIX collector,
                   this  action  sets the content of the <b>ObservationDomainID</b> and <b>ObservationPointID</b> IPFIX fields
                   (see argument description below).

                   The following key-value arguments are supported:

                   <b>probability=</b><u>packets</u>
                          The number of sampled packets out of 65535. It must be greater or equal to 1.

                   <b>collector_set=</b><u>id</u>
                          The unsigned 32-bit integer identifier of the sample collector to send sampled packets
                          to. It must match the value configured in the <b>Flow_Sample_Collector_Set</b> Table in  OVS.
                          Defaults to 0.

                   <b>obs_domain=</b><u>id</u>
                          An  unsigned 8-bit integer that identifies the sampling application. It will be placed
                          in the 8 most significant bits of the <b>ObservationDomainID</b> field of IPFIX samples.  The
                          24  less  significant  bits  will  be  automatically  filled in with the datapath key.
                          Defaults to 0.

                   <b>obs_point=</b><u>id</u>
                          An unsigned 32-bit integer to be used as <b>ObsservationPointID</b> or the string <b>@cookie</b>  to
                          indicate that the first 32 bits of the <b>Logical_Flow</b>’s UUID shall be used instead.

              <b>mac_cache_use;</b>
                   This action resubmits to corresponding table which updates the use statistics of MAC cache.

              <u>R</u> <b>=</b> <b>dhcp_relay_req_chk(</b><u>relay-ip</u><b>,</b>
                   <u>server-ip</u><b>);</b> <b>Parameters</b>: Logical Router Port IP <u>relay-ip</u>, DHCP Server IP <u>server-ip</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   This  action  executes  on  the  source  node  on  which  the  DHCP  request (DHCPDISCOVER or
                   DHCPREQUEST) originated.

                   When this action applied successfully on the DHCP request packet, it updates  GIADDR  in  the
                   DHCP packet with <u>relay-ip</u> and stores 1 in R.

                   When  this  action failed to apply on the packet, it leaves the packet unchanged and stores 0
                   in R.

              <u>R</u> <b>=</b> <b>dhcp_relay_resp_chk(</b><u>relay-ip</u><b>,</b>
                   <u>server-ip</u><b>);</b> <b>Parameters</b>: Logical Router Port IP <u>relay-ip</u>, DHCP Server IP <u>server-ip</u>.

                   <b>Result</b>: stored to a 1-bit subfield <u>R</u>.

                   This action executes on the first node (Redirect  Chassis  node)  which  processes  the  DHCP
                   response(DHCPOFFER, DHCPACK) from the DHCP server.

                   When this action applied successfully on the DHCP response packet, it updates the destination
                   MAC  and  destination  IP in the packet and stores 1 in R. <u>relay-ip</u> and <u>server-ip</u> are used to
                   validate GIADDR and SERVER-ID in the DHCP response packet.

                   When this action failed to apply on the packet, it leaves the packet unchanged and  stores  0
                   in R.

       <b>tags</b>: map of string-string pairs
              Key-value  pairs that provide additional information to help ovn-controller processing the logical
              flow. Below are the tags used by ovn-controller.

              in_out_port
                     In the logical flow’s "match" column, if a logical port P is compared with "inport" and the
                     logical flow is on a logical switch ingress pipeline, or if P is  compared  with  "outport"
                     and the logical flow is on a logical switch egress pipeline, and the expression is combined
                     with  other  expressions (if any) using the operator &amp;&amp;, then the port P should be added as
                     the value in this tag. If there are multiple logical ports meeting this  criteria,  one  of
                     them  can be added. ovn-controller uses this information to skip parsing flows that are not
                     needed on the chassis. Failing to add the tag will affect efficiency,  while  adding  wrong
                     value will affect correctness.

       <b>controller_meter</b>: optional string
              The  name  of the meter in table <b>Meter</b> to be used for all packets that the logical flow might send
              to <b>ovn-controller</b>.

       <b>flow_desc</b>: optional string
              Human-readable explanation of the flow, this is optional and used to provide context for the given
              flow.

       <b>external_ids</b> <b>:</b> <b>stage-name</b>: optional string
              Human-readable name for this flow’s stage in the pipeline.

       <b>external_ids</b> <b>:</b> <b>stage-hint</b>: optional string, containing an uuid
              UUID of a <b>OVN_Northbound</b> record that caused this logical flow to be created. Currently  used  only
              for attribute of logical flows to northbound <b>ACL</b> records.

       <b>external_ids</b> <b>:</b> <b>source</b>: optional string
              Source file and line number of the code that added this flow to the pipeline.

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre><h4><b>Logical_DP_Group</b> <b>TABLE</b></h4><pre>
       Each  row in this table represents a group of logical datapaths referenced by the <b>logical_dp_group</b> column
       in the <b>Logical_Flow</b> table.

   <b>Summary:</b>
       <b>datapaths</b>                     set of weak reference to <b>Datapath_Binding</b>s

   <b>Details:</b>
       <b>datapaths</b>: set of weak reference to <b>Datapath_Binding</b>s
              List of <b>Datapath_Binding</b> entries.

</pre><h4><b>Multicast_Group</b> <b>TABLE</b></h4><pre>
       The rows in this table define multicast groups of logical ports. Multicast groups allow a  single  packet
       transmitted  over a tunnel to a hypervisor to be delivered to multiple VMs on that hypervisor, which uses
       bandwidth more efficiently.

       Each row in this table defines a logical multicast  group  numbered  <b>tunnel_key</b>  within  <b>datapath</b>,  whose
       logical ports are listed in the <b>ports</b> column.

   <b>Summary:</b>
       <b>datapath</b>                      <b>Datapath_Binding</b>
       <b>tunnel_key</b>                    integer, in range 32,768 to 65,535
       <b>name</b>                          string
       <b>ports</b>                         set of weak reference to <b>Port_Binding</b>s

   <b>Details:</b>
       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath in which the multicast group resides.

       <b>tunnel_key</b>: integer, in range 32,768 to 65,535
              The value used to designate this logical egress port in tunnel encapsulations. An index forces the
              key  to  be  unique within the <b>datapath</b>. The unusual range ensures that multicast group IDs do not
              overlap with logical port IDs.

       <b>name</b>: string
              The logical multicast group’s name. An index forces the name to be  unique  within  the  <b>datapath</b>.
              Logical  flows  in  the  ingress  pipeline  may output to the group just as for individual logical
              ports, by assigning the group’s name to <b>outport</b> and executing an <b>output</b> action.

              Multicast group names and logical port names share a single namespace and thus should not  overlap
              (but  the  database  schema cannot enforce this). To try to avoid conflicts, <b>ovn-northd</b> uses names
              that begin with <b>_MC_</b>.

       <b>ports</b>: set of weak reference to <b>Port_Binding</b>s
              The logical ports included in the multicast group. All of these ports  must  be  in  the  <b>datapath</b>
              logical datapath (but the database schema cannot enforce this).

</pre><h4><b>Mirror</b> <b>TABLE</b></h4><pre>
       Each  row  in  this  table  represents  a  mirror  that can be used for port mirroring. These mirrors are
       referenced by the <b>mirror_rules</b> column in the <b>Port_Binding</b> table.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>filter</b>                        string, one of <b>both</b>, <b>from-lport</b>, or <b>to-lport</b>
       <b>sink</b>                          string
       <b>type</b>                          string, one of <b>erspan</b>, <b>gre</b>, or <b>local</b>
       <b>index</b>                         integer
       <b>external_ids</b>                  map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              Represents the name of the mirror.

       <b>filter</b>: string, one of <b>both</b>, <b>from-lport</b>, or <b>to-lport</b>
              The value of this field represents selection criteria of the mirror. <b>to-lport</b> mirrors the  packets
              coming  into  logical port. <b>from-lport</b> mirrors the packets going out of logical port. <b>both</b> mirrors
              for both directions.

       <b>sink</b>: string
              The value of this field represents the destination/sink of the mirror.  If  the  <u>type</u>  is  <b>gre</b>  or
              <b>erspan</b>,  the value indicates the tunnel remote IP (either IPv4 or IPv6). For a <u>type</u> of <b>local</b>, this
              field defines a local  interface  on  the  OVS  integration  bridge  to  be  used  as  the  mirror
              destination. The interface must possess external-ids:mirror-id that matches this string.

       <b>type</b>: string, one of <b>erspan</b>, <b>gre</b>, or <b>local</b>
              The value of this field specifies the mirror type - <b>gre</b>, <b>erspan</b> or <b>local</b>.

       <b>index</b>: integer
              The value of this field represents the tunnel ID. If the configured tunnel type is <b>gre</b>, this field
              represents  the  <b>GRE</b>  key  value  and  if  the  configured tunnel type is <b>erspan</b> it represents the
              <b>erspan_idx</b> value. It is ignored if the type is <b>local</b>.

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>Meter</b> <b>TABLE</b></h4><pre>
       Each row in this table represents a meter that can be used for QoS or rate-limiting.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>unit</b>                          string, either <b>kbps</b> or <b>pktps</b>
       <b>bands</b>                         set of 1 or more <b>Meter_Band</b>s

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              A name for this meter.

              Names that begin with "__" (two underscores) are reserved for OVN internal use and should  not  be
              added manually.

       <b>unit</b>: string, either <b>kbps</b> or <b>pktps</b>
              The  unit  for  <b>rate</b>  and  <b>burst_rate</b>  parameters  in the <b>bands</b> entry. <b>kbps</b> specifies kilobits per
              second, and <b>pktps</b> specifies packets per second.

       <b>bands</b>: set of 1 or more <b>Meter_Band</b>s
              The bands associated with this meter. Each band specifies a rate above which the band is  to  take
              the  action  <b>action</b>.  If  multiple  bands’ rates are exceeded, then the band with the highest rate
              among the exceeded bands is selected.

</pre><h4><b>Meter_Band</b> <b>TABLE</b></h4><pre>
       Each row in this table represents a meter band which specifies the rate above which the configured action
       should be applied. These bands are referenced by the <b>bands</b> column in the <b>Meter</b> table.

   <b>Summary:</b>
       <b>action</b>                        string, must be <b>drop</b>
       <b>rate</b>                          integer, in range 1 to 4,294,967,295
       <b>burst_size</b>                    integer, in range 0 to 4,294,967,295

   <b>Details:</b>
       <b>action</b>: string, must be <b>drop</b>
              The action to execute when this band matches. The only supported action is <b>drop</b>.

       <b>rate</b>: integer, in range 1 to 4,294,967,295
              The rate limit for this band, in kilobits per second or bits per second, depending on whether  the
              parent <b>Meter</b> entry’s <b>unit</b> column specified <b>kbps</b> or <b>pktps</b>.

       <b>burst_size</b>: integer, in range 0 to 4,294,967,295
              The  maximum burst allowed for the band in kilobits or packets, depending on whether <b>kbps</b> or <b>pktps</b>
              was selected in the parent <b>Meter</b> entry’s <b>unit</b> column. If the size is zero, the switch is  free  to
              select some reasonable value depending on its configuration.

</pre><h4><b>Datapath_Binding</b> <b>TABLE</b></h4><pre>
       Each row in this table represents a logical datapath, which implements a logical pipeline among the ports
       in  the  <b>Port_Binding</b>  table  associated  with  it. In practice, the pipeline in a given logical datapath
       implements either a logical switch or a logical router.

       The main purpose of a row in this table is provide a physical binding for a logical datapath.  A  logical
       datapath  does  not  have  a  physical  location,  so  its  physical binding information is limited: just
       <b>tunnel_key</b>. The rest of the data in this table does not affect packet forwarding.

   <b>Summary:</b>
       <b>tunnel_key</b>                    integer, in range 1 to 16,777,215 (must be unique within table)
       <b>load_balancers</b>                set of uuids
       <u>OVN_Northbound</u> <u>Relationship:</u>
         <b>external_ids</b> <b>:</b> <b>logical-switch</b>
                                     optional string, containing an uuid
         <b>external_ids</b> <b>:</b> <b>logical-router</b>
                                     optional string, containing an uuid
         <b>external_ids</b> <b>:</b> <b>interconn-ts</b>
                                     optional string
         <u>Naming:</u>
            <b>external_ids</b> <b>:</b> <b>name</b>      optional string
            <b>external_ids</b> <b>:</b> <b>name2</b>     optional string
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>tunnel_key</b>: integer, in range 1 to 16,777,215 (must be unique within table)
              The tunnel key value to which the logical datapath is bound. The <b>Tunnel</b> <b>Encapsulation</b>  section  in
              <b><a href="../man7/ovn-architecture.7.html">ovn-architecture</a></b>(7) describes how tunnel keys are constructed for each supported encapsulation.

       <b>load_balancers</b>: set of uuids
              Not used anymore; kept for backwards compatibility of the schema.

     <u>OVN_Northbound</u> <u>Relationship:</u>

       Each  row  in  <b>Datapath_Binding</b>  is  associated with some logical datapath. <b>ovn-northd</b> uses these keys to
       track the association of a logical datapath with concepts in the <b>OVN_Northbound</b> database.

       <b>external_ids</b> <b>:</b> <b>logical-switch</b>: optional string, containing an uuid
              For a logical datapath that represents a logical switch, <b>ovn-northd</b> stores in this key the UUID of
              the corresponding <b>Logical_Switch</b> row in the <b>OVN_Northbound</b> database.

       <b>external_ids</b> <b>:</b> <b>logical-router</b>: optional string, containing an uuid
              For a logical datapath that represents a logical router, <b>ovn-northd</b> stores in this key the UUID of
              the corresponding <b>Logical_Router</b> row in the <b>OVN_Northbound</b> database.

       <b>external_ids</b> <b>:</b> <b>interconn-ts</b>: optional string
              For a logical datapath that represents a logical switch  that  represents  a  transit  switch  for
              interconnection,  <b>ovn-northd</b>  stores  in  this  key  the value of the same <b>interconn-ts</b> key of the
              <b>external_ids</b> column of the corresponding <b>Logical_Switch</b> row in the <b>OVN_Northbound</b> database.

     <u>Naming:</u>

       <b>ovn-northd</b> copies these from the name fields  in  the  <b>OVN_Northbound</b>  database,  either  from  <b>name</b>  and
       <b>external_ids:neutron:router_name</b>     in     the     <b>Logical_Router</b>     table    or    from    <b>name</b>    and
       <b>external_ids:neutron:network_name</b> in the <b>Logical_Switch</b> table.

       <b>external_ids</b> <b>:</b> <b>name</b>: optional string
              A name for the logical datapath.

       <b>external_ids</b> <b>:</b> <b>name2</b>: optional string
              Another name for the logical datapath.

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre><h4><b>Port_Binding</b> <b>TABLE</b></h4><pre>
       Each row in this table binds a logical port to a realization. For most logical ports, this means  binding
       to some physical location, for example by binding a logical port to a VIF that belongs to a VM running on
       a  particular  hypervisor.  Other  logical  ports, such as logical patch ports, can be realized without a
       specific physical location, but their bindings are still expressed through rows in this table.

       For every <b>Logical_Switch_Port</b> record in <b>OVN_Northbound</b> database, <b>ovn-northd</b>  creates  a  record  in  this
       table.  <b>ovn-northd</b>  populates  and  maintains every column except the <b>chassis</b> and <b>virtual_parent</b> columns,
       which it leaves empty in new records.

       <b>ovn-controller</b>/<b>ovn-controller-vtep</b> populates the <b>chassis</b> column for the records that identify the logical
       ports that are located on its hypervisor/gateway, which <b>ovn-controller</b>/<b>ovn-controller-vtep</b> in turn  finds
       out  by  monitoring  the local hypervisor’s Open_vSwitch database, which identifies logical ports via the
       conventions described in <b>IntegrationGuide.rst</b>. (The exceptions are for <b>Port_Binding</b> records with <b>type</b>  of
       <b>l3gateway</b>,  whose locations are identified by <b>ovn-northd</b> via the <b>options:l3gateway-chassis</b> column in this
       table. <b>ovn-controller</b> is still responsible to populate the <b>chassis</b> column.)

       <b>ovn-controller</b> also populates the <b>virtual_parent</b> column of records whose <b>type</b> is <b>virtual</b>.

       When a chassis shuts down gracefully, it should clean up  the  <b>chassis</b>  column  that  it  previously  had
       populated.  (This  is  not  critical  because  resources  hosted  on  the chassis are equally unreachable
       regardless of whether their rows are present.) To handle the case where a VM is shut down abruptly on one
       chassis, then brought up again on a different one, <b>ovn-controller</b>/<b>ovn-controller-vtep</b> must overwrite  the
       <b>chassis</b> column with new information.

   <b>Summary:</b>
       <u>Core</u> <u>Features:</u>
         <b>datapath</b>                    <b>Datapath_Binding</b>
         <b>logical_port</b>                string (must be unique within table)
         <b>encap</b>                       optional weak reference to <b>Encap</b>
         <b>additional_encap</b>            set of weak reference to <b>Encap</b>s
         <b>chassis</b>                     optional weak reference to <b>Chassis</b>
         <b>additional_chassis</b>          set of weak reference to <b>Chassis</b>
         <b>gateway_chassis</b>             set of <b>Gateway_Chassis</b>es
         <b>ha_chassis_group</b>            optional <b>HA_Chassis_Group</b>
         <b>up</b>                          optional boolean
         <b>tunnel_key</b>                  integer, in range 1 to 32,767
         <b>mac</b>                         set of strings
         <b>port_security</b>               set of strings
         <b>type</b>                        string
         <b>requested_chassis</b>           optional weak reference to <b>Chassis</b>
         <b>requested_additional_chassis</b>
                                     set of weak reference to <b>Chassis</b>
       <b>mirror_rules</b>                  set of weak reference to <b>Mirror</b>s
       <u>Patch</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>peer</b>              optional string
         <b>nat_addresses</b>               set of strings
       <u>L3</u> <u>Gateway</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>peer</b>              optional string
         <b>options</b> <b>:</b> <b>l3gateway-chassis</b>
                                     optional string
         <b>nat_addresses</b>               set of strings
       <u>Localnet</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>network_name</b>      optional string
         <b>tag</b>                         optional integer, in range 1 to 4,095
       <u>L2</u> <u>Gateway</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>network_name</b>      optional string
         <b>options</b> <b>:</b> <b>l2gateway-chassis</b>
                                     optional string
         <b>tag</b>                         optional integer, in range 1 to 4,095
       <u>VTEP</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>vtep-physical-switch</b>
                                     optional string
         <b>options</b> <b>:</b> <b>vtep-logical-switch</b>
                                     optional string
       <u>VMI</u> <u>(or</u> <u>VIF)</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>requested-chassis</b>
                                     optional string
         <b>options</b> <b>:</b> <b>activation-strategy</b>
                                     optional string
         <b>options</b> <b>:</b> <b>additional-chassis-activated</b>
                                     optional string
         <b>options</b> <b>:</b> <b>iface-id-ver</b>      optional string
         <b>options</b> <b>:</b> <b>qos_min_rate</b>      optional string
         <b>options</b> <b>:</b> <b>qos_max_rate</b>      optional string
         <b>options</b> <b>:</b> <b>qos_burst</b>         optional string
         <b>options</b> <b>:</b> <b>qos_physical_network</b>
                                     optional string
         <b>options</b> <b>:</b> <b>qdisc_queue_id</b>    optional string, containing an integer, in range 1 to 61,440
       <u>Distributed</u> <u>Gateway</u> <u>Port</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>chassis-redirect-port</b>
                                     optional string
       <u>Chassis</u> <u>Redirect</u> <u>Options:</u>
         <b>options</b> <b>:</b> <b>distributed-port</b>  optional string
         <b>options</b> <b>:</b> <b>redirect-type</b>     optional string
         <b>options</b> <b>:</b> <b>always-redirect</b>   optional string
       <u>Nested</u> <u>Containers:</u>
         <b>parent_port</b>                 optional string
         <b>tag</b>                         optional integer, in range 1 to 4,095
       <u>Virtual</u> <u>ports:</u>
         <b>virtual_parent</b>              optional string
       <u>Naming:</u>
         <b>external_ids</b> <b>:</b> <b>name</b>         optional string
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
     <u>Core</u> <u>Features:</u>

       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath to which the logical port belongs.

       <b>logical_port</b>: string (must be unique within table)
              A  logical  port.  For  a  logical  switch  port,  this  is  taken from <b>name</b> in the OVN_Northbound
              database’s <b>Logical_Switch_Port</b> table. For a logical router port, this is taken from  <b>name</b>  in  the
              OVN_Northbound  database’s  <b>Logical_Router_port</b>  table.  (This means that logical switch ports and
              router port names must not share names in an OVN deployment.) OVN does not prescribe a  particular
              format for the logical port ID.

       <b>encap</b>: optional weak reference to <b>Encap</b>
              Points  to  preferred  encapsulation  configuration  to transmit logical dataplane packets to this
              chassis. The entry is reference to a <b>Encap</b> record.

       <b>additional_encap</b>: set of weak reference to <b>Encap</b>s
              Points to preferred encapsulation configuration to transmit  logical  dataplane  packets  to  this
              additional chassis. The entry is reference to a <b>Encap</b> record. See also <b>additional_chassis</b>.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The  meaning  of this column depends on the value of the <b>type</b> column. This is the meaning for each
              <b>type</b>

              (empty string)
                     The physical location of the logical port. To successfully identify a chassis, this  column
                     must be a <b>Chassis</b> record. This is populated by <b>ovn-controller</b>.

              vtep   The  physical  location  of  the hardware_vtep gateway. To successfully identify a chassis,
                     this column must be a <b>Chassis</b> record. This is populated by <b>ovn-controller-vtep</b>.

              localnet
                     Always empty. A localnet port is realized on every chassis that  has  connectivity  to  the
                     corresponding physical network.

              localport
                     Always empty. A localport port is present on every chassis.

              l3gateway
                     The  physical  location  of the L3 gateway. To successfully identify a chassis, this column
                     must be a <b>Chassis</b> record. This is populated by <b>ovn-controller</b> based on  the  value  of  the
                     <b>options:l3gateway-chassis</b> column in this table.

              l2gateway
                     The  physical  location of this L2 gateway. To successfully identify a chassis, this column
                     must be a <b>Chassis</b> record. This is populated by <b>ovn-controller</b> based on  the  value  of  the
                     <b>options:l2gateway-chassis</b> column in this table.

       <b>additional_chassis</b>: set of weak reference to <b>Chassis</b>
              The  meaning  of  this  column  is  the  same  as  for the <b>chassis</b>. The column is used to track an
              additional physical location of the logical port. Used with regular (empty <b>type</b>) port bindings.

       <b>gateway_chassis</b>: set of <b>Gateway_Chassis</b>es
              A list of <b>Gateway_Chassis</b>.

              This should only be populated for ports with <b>type</b> set to <b>chassisredirect</b>. This column defines  the
              list of chassis used as gateways where traffic will be redirected through.

       <b>ha_chassis_group</b>: optional <b>HA_Chassis_Group</b>
              This  should only be populated for ports with <b>type</b> set to <b>chassisredirect</b>. This column defines the
              HA chassis group with a list of HA chassis used as  gateways  where  traffic  will  be  redirected
              through.

       <b>up</b>: optional boolean
              This is set to <b>true</b> whenever all OVS flows required by this Port_Binding have been installed. This
              is populated by <b>ovn-controller</b>.

       <b>tunnel_key</b>: integer, in range 1 to 32,767
              A  number  that  represents the logical port in the key (e.g. STT key or Geneve TLV) field carried
              within tunnel protocol packets.

              The tunnel ID must be unique within the scope of a logical datapath.

       <b>mac</b>: set of strings
              This column is a misnomer as it may contain MAC addresses and IP addresses. It is copied from  the
              <b>addresses</b>  column in the <b>Logical_Switch_Port</b> table in the Northbound database. It follows the same
              format as that column.

       <b>port_security</b>: set of strings
              This column controls the addresses from which the host attached to the logical port (``the host’’)
              is allowed to send packets and to which it is allowed to receive packets. If this column is empty,
              all addresses are permitted.

              It is copied from the <b>port_security</b> column in the  <b>Logical_Switch_Port</b>  table  in  the  Northbound
              database. It follows the same format as that column.

       <b>type</b>: string
              A  type for this logical port. Logical ports can be used to model other types of connectivity into
              an OVN logical switch. The following types are defined:

              (empty string)
                     VM (or VIF) interface.

              <b>patch</b>  One of a pair of logical ports that act as if  connected  by  a  patch  cable.  Useful  for
                     connecting  two  logical datapaths, e.g. to connect a logical router to a logical switch or
                     to another logical router.

              <b>l3gateway</b>
                     One of a pair of logical ports that act as if connected by a patch  cable  across  multiple
                     chassis.  Useful  for  connecting  a  logical  switch  with a Gateway router (which is only
                     resident on a particular chassis).

              <b>localnet</b>
                     A connection to a locally accessible network from  <b>ovn-controller</b>  instances  that  have  a
                     corresponding  bridge  mapping. A logical switch can have multiple <b>localnet</b> ports attached.
                     This type is used to model direct connectivity to existing networks.  In  this  case,  each
                     chassis  should  have  a  mapping for one of the physical networks only. Note: nothing said
                     above implies that a chassis cannot be plugged to multiple physical  networks  as  long  as
                     they belong to different switches.

              <b>localport</b>
                     A  connection to a local VIF. Traffic that arrives on a <b>localport</b> is never forwarded over a
                     tunnel to another chassis. These ports are present on  every  chassis  and  have  the  same
                     address  in  all  of them. This is used to model connectivity to local services that run on
                     every hypervisor.

              <b>l2gateway</b>
                     An L2 connection to a physical network. The chassis this  <b>Port_Binding</b>  is  bound  to  will
                     serve as an L2 gateway to the network named by <b>options</b>:<b>network_name</b>.

              <b>vtep</b>   A  port  to a logical switch on a VTEP gateway chassis. In order to get this port correctly
                     recognized    by    the    OVN    controller,    the    <b>options</b>:<b>vtep-physical-switch</b>    and
                     <b>options</b>:<b>vtep-logical-switch</b> must also be defined.

              <b>chassisredirect</b>
                     A  logical  port  that represents a particular instance, bound to a specific chassis, of an
                     otherwise distributed parent port (e.g. of type <b>patch</b>). A <b>chassisredirect</b> port should never
                     be used as an <b>inport</b>. When an ingress pipeline sets the <b>outport</b>, it may set the value to  a
                     logical  port  of  type  <b>chassisredirect</b>.  This  will  cause the packet to be directed to a
                     specific chassis to carry out the egress pipeline. At the beginning of the egress pipeline,
                     the <b>outport</b> will be reset to the value of the distributed port.

              <b>virtual</b>
                     Represents a logical port with an <b>virtual</b> <b>ip</b>. This  <b>virtual</b>  <b>ip</b>  can  be  configured  on  a
                     logical port (which is referred as virtual parent).

       <b>requested_chassis</b>: optional weak reference to <b>Chassis</b>
              This  column  exists  so  that the ovn-controller can effectively monitor all <b>Port_Binding</b> records
              destined for it, and is a supplement to the <b>options:requested-chassis</b> option. The option is  still
              required  so that the ovn-controller can check the CMS intent when the chassis pointed to does not
              currently exist, which for example occurs when the ovn-controller is stopped without  passing  the
              -restart  argument. This column must be a <b>Chassis</b> record. This is populated by <b>ovn-northd</b> when the
              <b>options:requested-chassis</b> is defined and contains a string matching the name  or  hostname  of  an
              existing chassis. See also <b>requested_additional_chassis</b>.

       <b>requested_additional_chassis</b>: set of weak reference to <b>Chassis</b>
              This  column  exists  so  that the ovn-controller can effectively monitor all <b>Port_Binding</b> records
              destined for it, and is a supplement to the <b>options:requested-chassis</b> option when multiple chassis
              are listed. This column must be a list of <b>Chassis</b> records. This is populated  by  <b>ovn-northd</b>  when
              the  <b>options:requested-chassis</b>  is  defined  as  a  list  of  chassis names or hostnames. See also
              <b>requested_chassis</b>.

       <b>mirror_rules</b>: set of weak reference to <b>Mirror</b>s
              Mirror rules that apply to the port binding. Please see the <b>Mirror</b> table.

     <u>Patch</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> of <b>patch</b>.

       <b>options</b> <b>:</b> <b>peer</b>: optional string
              The <b>logical_port</b> in  the  <b>Port_Binding</b>  record  for  the  other  side  of  the  patch.  The  named
              <b>logical_port</b> must specify this <b>logical_port</b> in its own <b>peer</b> option. That is, the two patch logical
              ports must have reversed <b>logical_port</b> and <b>peer</b> values.

       <b>nat_addresses</b>: set of strings
              MAC   address   followed  by  a  list  of  SNAT  and  DNAT  external  IP  addresses,  followed  by
              <b>is_chassis_resident("</b><u>lport</u><b>")</b>, where <u>lport</u> is the name of a logical port on the same chassis  where
              the  corresponding  NAT  rules are applied. This is used to send gratuitous ARPs for SNAT and DNAT
              external  IP  addresses  via  <b>localnet</b>,  from  the   chassis   where   <u>lport</u>   resides.   Example:
              <b>80:fa:5b:06:72:b7</b>  <b>158.36.44.22</b>  <b>158.36.44.24</b>  <b>is_chassis_resident("foo1")</b>.  This  would result in
              generation of gratuitous ARPs for IP addresses 158.36.44.22 and 158.36.44.24 with a MAC address of
              80:fa:5b:06:72:b7 from the chassis where the logical port "foo1" resides.

     <u>L3</u> <u>Gateway</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> of <b>l3gateway</b>.

       <b>options</b> <b>:</b> <b>peer</b>: optional string
              The <b>logical_port</b> in the <b>Port_Binding</b> record for the other side of the ’l3gateway’ port. The  named
              <b>logical_port</b>  must  specify this <b>logical_port</b> in its own <b>peer</b> option. That is, the two ’l3gateway’
              logical ports must have reversed <b>logical_port</b> and <b>peer</b> values.

       <b>options</b> <b>:</b> <b>l3gateway-chassis</b>: optional string
              The <b>chassis</b> in which the port resides.

       <b>nat_addresses</b>: set of strings
              MAC address of the <b>l3gateway</b> port followed by a list of SNAT and DNAT external IP addresses.  This
              is  used  to  send  gratuitous ARPs for SNAT and DNAT external IP addresses via <b>localnet</b>. Example:
              <b>80:fa:5b:06:72:b7</b> <b>158.36.44.22</b> <b>158.36.44.24</b>. This would result in generation  of  gratuitous  ARPs
              for  IP  addresses  158.36.44.22 and 158.36.44.24 with a MAC address of 80:fa:5b:06:72:b7. This is
              used in OVS version 2.8 and later versions.

     <u>Localnet</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> of <b>localnet</b>.

       <b>options</b> <b>:</b> <b>network_name</b>: optional string
              Required. <b>ovn-controller</b> uses the configuration entry  <b>ovn-bridge-mappings</b>  to  determine  how  to
              connect  to  this  network.  <b>ovn-bridge-mappings</b>  is a list of network names mapped to a local OVS
              bridge that provides access to that network. An example of configuring  <b>ovn-bridge-mappings</b>  would
              be: .IP
              <b>$</b> <b>ovs-vsctl</b> <b>set</b> <b>open</b> <b>.</b> <b>external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1</b>

              When  a  logical  switch  has  a  <b>localnet</b>  port attached, every chassis that may have a local vif
              attached to that logical switch must have a bridge mapping  configured  to  reach  that  <b>localnet</b>.
              Traffic  that  arrives  on a <b>localnet</b> port is never forwarded over a tunnel to another chassis. If
              there are multiple <b>localnet</b> ports in a logical switch, each chassis  should  only  have  a  single
              bridge  mapping  for  one  of  the physical networks. Note: In case of multiple <b>localnet</b> ports, to
              provide interconnectivity between all VIFs located on  different  chassis  with  different  fabric
              connectivity, the fabric should implement some form of routing between the segments.

       <b>tag</b>: optional integer, in range 1 to 4,095
              If set, indicates that the port represents a connection to a specific VLAN on a locally accessible
              network. The VLAN ID is used to match incoming traffic and is also added to outgoing traffic.

     <u>L2</u> <u>Gateway</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> of <b>l2gateway</b>.

       <b>options</b> <b>:</b> <b>network_name</b>: optional string
              Required.  <b>ovn-controller</b>  uses  the  configuration  entry <b>ovn-bridge-mappings</b> to determine how to
              connect to this network. <b>ovn-bridge-mappings</b> is a list of network names  mapped  to  a  local  OVS
              bridge  that  provides access to that network. An example of configuring <b>ovn-bridge-mappings</b> would
              be: .IP
              <b>$</b> <b>ovs-vsctl</b> <b>set</b> <b>open</b> <b>.</b> <b>external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1</b>

              When a logical switch has a <b>l2gateway</b> port attached, the chassis that the <b>l2gateway</b> port is  bound
              to must have a bridge mapping configured to reach the network identified by <b>network_name</b>.

       <b>options</b> <b>:</b> <b>l2gateway-chassis</b>: optional string
              Required. The <b>chassis</b> in which the port resides.

       <b>tag</b>: optional integer, in range 1 to 4,095
              If  set,  indicates  that the gateway is connected to a specific VLAN on the physical network. The
              VLAN ID is used to match incoming traffic and is also added to outgoing traffic.

     <u>VTEP</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> of <b>vtep</b>.

       <b>options</b> <b>:</b> <b>vtep-physical-switch</b>: optional string
              Required. The name of the VTEP gateway.

       <b>options</b> <b>:</b> <b>vtep-logical-switch</b>: optional string
              Required. A logical switch name connected by the VTEP gateway. Must be set when <b>type</b> is <b>vtep</b>.

     <u>VMI</u> <u>(or</u> <u>VIF)</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> having (empty string)

       <b>options</b> <b>:</b> <b>requested-chassis</b>: optional string
              If set, identifies a specific chassis (by name or hostname) that is allowed  to  bind  this  port.
              Using this option will prevent thrashing between two chassis trying to bind the same port during a
              live  migration.  It  can  also prevent similar thrashing due to a mis-configuration, if a port is
              accidentally created on more than one chassis.

              If set to a comma separated list, the first entry identifies the main chassis and the rest are one
              or more additional chassis that are allowed to bind the same port.

              When multiple chassis are set for the port, and the logical switch is  connected  to  an  external
              network  through  a  <b>localnet</b>  port,  tunneling  is enforced for the port to guarantee delivery of
              packets directed to the port to all its locations. This has MTU implications because  the  network
              used for tunneling must have MTU larger than <b>localnet</b> for stable connectivity.

       <b>options</b> <b>:</b> <b>activation-strategy</b>: optional string
              If  used  with multiple chassis set in <b>requested-chassis</b>, specifies an activation strategy for all
              additional chassis. By default, no activation strategy is used, meaning additional port  locations
              are  immediately available for use. When set to "rarp", the port is blocked for ingress and egress
              communication until a RARP packet is sent from a new location. The "rarp" strategy  is  useful  in
              live migration scenarios for virtual machines.

       <b>options</b> <b>:</b> <b>additional-chassis-activated</b>: optional string
              When  <b>activation-strategy</b>  is  set,  this  option  indicates that the port was activated using the
              strategy specified.

       <b>options</b> <b>:</b> <b>iface-id-ver</b>: optional string
              If set, this port will be bound by <b>ovn-controller</b> only if this same key and value is configured in
              the <b>external_ids</b> column in the Open_vSwitch database’s <b>Interface</b> table.

       <b>options</b> <b>:</b> <b>qos_min_rate</b>: optional string
              If set, indicates the minimum guaranteed rate available for data  sent  from  this  interface,  in
              bit/s.

       <b>options</b> <b>:</b> <b>qos_max_rate</b>: optional string
              If  set,  indicates the maximum rate for data sent from this interface, in bit/s. The traffic will
              be shaped according to this limit.

       <b>options</b> <b>:</b> <b>qos_burst</b>: optional string
              If set, indicates the maximum burst size for data sent from this interface, in bits.

       <b>options</b> <b>:</b> <b>qos_physical_network</b>: optional string
              If set, indicates the name of the egress network name where traffic shaping will be applied.

       <b>options</b> <b>:</b> <b>qdisc_queue_id</b>: optional string, containing an integer, in range 1 to 61,440
              Indicates the queue number on the physical device. This is same as the <b>queue_id</b> used  in  OpenFlow
              in <b>struct</b> <b>ofp_action_enqueue</b>.

     <u>Distributed</u> <u>Gateway</u> <u>Port</u> <u>Options:</u>

       These options apply to the distributed parent ports of logical ports with <b>type</b> of <b>chasssisredirect</b>.

       <b>options</b> <b>:</b> <b>chassis-redirect-port</b>: optional string
              The  name of the chassis redirect port derived from this port if this port is a distributed parent
              of a chassis redirect port.

     <u>Chassis</u> <u>Redirect</u> <u>Options:</u>

       These options apply to logical ports with <b>type</b> of <b>chassisredirect</b>.

       <b>options</b> <b>:</b> <b>distributed-port</b>: optional string
              The name of the distributed port for which  this  <b>chassisredirect</b>  port  represents  a  particular
              instance.

       <b>options</b> <b>:</b> <b>redirect-type</b>: optional string
              The  value  is copied from the column <b>options</b> in the OVN_Northbound database’s <b>Logical_Router_Port</b>
              table for the distributed parent of this port.

       <b>options</b> <b>:</b> <b>always-redirect</b>: optional string
              A boolean option that is set to true if the distributed parent of this chassis redirect port  does
              not need distributed processing.

     <u>Nested</u> <u>Containers:</u>

       These  columns  support containers nested within a VM. Specifically, they are used when <b>type</b> is empty and
       <b>logical_port</b> identifies the interface of a container spawned inside a VM. They are empty  for  containers
       or VMs that run directly on a hypervisor.

       <b>parent_port</b>: optional string
              This is taken from <b>parent_name</b> in the OVN_Northbound database’s <b>Logical_Switch_Port</b> table.

       <b>tag</b>: optional integer, in range 1 to 4,095
              Identifies the VLAN tag in the network traffic associated with that container’s network interface.

              This column is used for a different purpose when <b>type</b> is <b>localnet</b> (see <b>Localnet</b> <b>Options</b>, above) or
              <b>l2gateway</b> (see <b>L2</b> <b>Gateway</b> <b>Options</b>, above).

     <u>Virtual</u> <u>ports:</u>

       <b>virtual_parent</b>: optional string
              This column is set by <b>ovn-controller</b> with one of the value from the <b>options:virtual-parents</b> in the
              OVN_Northbound  database’s  <b>Logical_Switch_Port</b>  table when the OVN action <b>bind_vport</b> is executed.
              <b>ovn-controller</b> also sets the <b>chassis</b> column when it executes this action with its chassis id.

              <b>ovn-controller</b> sets this column only if the <b>type</b> is "virtual".

     <u>Naming:</u>

       <b>external_ids</b> <b>:</b> <b>name</b>: optional string
              For a logical switch port, <b>ovn-northd</b>  copies  this  from  <b>external_ids:neutron:port_name</b>  in  the
              <b>Logical_Switch_Port</b> table in the OVN_Northbound database, if it is a nonempty string.

              For a logical switch port, <b>ovn-northd</b> does not currently set this key.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

              The  <b>ovn-northd</b> program populates this column with all entries into the <b>external_ids</b> column of the
              <b>Logical_Switch_Port</b> and <b>Logical_Router_Port</b> tables of the <b>OVN_Northbound</b> database.

</pre><h4><b>MAC_Binding</b> <b>TABLE</b></h4><pre>
       Each row in this table specifies a binding from an IP address  to  an  Ethernet  address  that  has  been
       discovered  through  ARP  (for  IPv4)  or  neighbor discovery (for IPv6). This table is primarily used to
       discover bindings on physical networks, because IP-to-MAC  bindings  for  virtual  machines  are  usually
       populated statically into the <b>Port_Binding</b> table.

       This table expresses a functional relationship: <b>MAC_Binding</b>(<b>logical_port</b>, <b>ip</b>) = <b>mac</b>.

       In outline, the lifetime of a logical router’s MAC binding looks like this:

              1.  On hypervisor 1, a logical router determines that a packet should be forwarded to IP address <u>A</u>
                  on  one of its router ports. It uses its logical flow table to determine that <u>A</u> lacks a static
                  IP-to-MAC binding and the <b>get_arp</b> action to  determine  that  it  lacks  a  dynamic  IP-to-MAC
                  binding.

              2.  Using  an  OVN  logical  <b>arp</b>  action,  the  logical router generates and sends a broadcast ARP
                  request to the router port. It drops the IP packet.

              3.  The logical switch attached to the router port delivers the ARP request to all of  its  ports.
                  (It  might  make sense to deliver it only to ports that have no static IP-to-MAC bindings, but
                  this could also be surprising behavior.)

              4.  A host or VM on hypervisor 2 (which might be the same as hypervisor 1) attached to the logical
                  switch owns the IP address in question. It composes an  ARP  reply  and  unicasts  it  to  the
                  logical router port’s Ethernet address.

              5.  The logical switch delivers the ARP reply to the logical router port.

              6.  The  logical  router  flow  table  executes a <b>put_arp</b> action. To record the IP-to-MAC binding,
                  <b>ovn-controller</b> adds a row to the <b>MAC_Binding</b> table.

              7.  On hypervisor 1, <b>ovn-controller</b> receives the updated <b>MAC_Binding</b> table from the OVN southbound
                  database. The next packet destined to <u>A</u> through the logical router is  sent  directly  to  the
                  bound Ethernet address.

   <b>Summary:</b>
       <b>logical_port</b>                  string
       <b>ip</b>                            string
       <b>mac</b>                           string
       <b>timestamp</b>                     integer
       <b>datapath</b>                      <b>Datapath_Binding</b>

   <b>Details:</b>
       <b>logical_port</b>: string
              The logical port on which the binding was discovered.

       <b>ip</b>: string
              The bound IP address.

       <b>mac</b>: string
              The Ethernet address to which the IP is bound.

       <b>timestamp</b>: integer
              The  timestamp in msec when the MAC binding was added or updated. Records that existed before this
              column will have 0.

       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath to which the logical port belongs.

</pre><h4><b>DHCP_Options</b> <b>TABLE</b></h4><pre>
       Each row in this table stores the DHCP Options supported by native OVN DHCP.  <b>ovn-northd</b>  populates  this
       table  with  the  supported DHCP options. <b>ovn-controller</b> looks up this table to get the DHCP codes of the
       DHCP   options   defined   in   the   "put_dhcp_opts"   action.   Please   refer   to   the   RFC    2132
       <b>"https://tools.ietf.org/html/rfc2132"</b> for the possible list of DHCP options that can be defined here.

   <b>Summary:</b>
       <b>name</b>                          string
       <b>code</b>                          integer, in range 0 to 254
       <b>type</b>                          string,  one  of  <b>bool</b>, <b>domains</b>, <b>host_id</b>, <b>ipv4</b>, <b>static_routes</b>, <b>str</b>, <b>uint16</b>,
                                     <b>uint32</b>, or <b>uint8</b>

   <b>Details:</b>
       <b>name</b>: string
              Name of the DHCP option.

              Example. name="router"

       <b>code</b>: integer, in range 0 to 254
              DHCP option code for the DHCP option as defined in the RFC 2132.

              Example. code=3

       <b>type</b>: string, one of <b>bool</b>, <b>domains</b>, <b>host_id</b>, <b>ipv4</b>, <b>static_routes</b>, <b>str</b>, <b>uint16</b>, <b>uint32</b>, or <b>uint8</b>
              Data type of the DHCP option code.

              <b>value:</b> <b>bool</b>
                     This indicates that the value of the DHCP option is a bool.

                     Example. "name=ip_forward_enable", "code=19", "type=bool".

                     put_dhcp_opts(..., ip_forward_enable = 1,...)

              <b>value:</b> <b>uint8</b>
                     This indicates that the value of the DHCP option is an unsigned int8 (8 bits)

                     Example. "name=default_ttl", "code=23", "type=uint8".

                     put_dhcp_opts(..., default_ttl = 50,...)

              <b>value:</b> <b>uint16</b>
                     This indicates that the value of the DHCP option is an unsigned int16 (16 bits).

                     Example. "name=mtu", "code=26", "type=uint16".

                     put_dhcp_opts(..., mtu = 1450,...)

              <b>value:</b> <b>uint32</b>
                     This indicates that the value of the DHCP option is an unsigned int32 (32 bits).

                     Example. "name=lease_time", "code=51", "type=uint32".

                     put_dhcp_opts(..., lease_time = 86400,...)

              <b>value:</b> <b>ipv4</b>
                     This indicates that the value of the DHCP option is an IPv4 address or addresses.

                     Example. "name=router", "code=3", "type=ipv4".

                     put_dhcp_opts(..., router = 10.0.0.1,...)

                     Example. "name=dns_server", "code=6", "type=ipv4".

                     put_dhcp_opts(..., dns_server = {8.8.8.8 7.7.7.7},...)

              <b>value:</b> <b>static_routes</b>
                     This indicates that the value of the DHCP option contains a pair of IPv4 route and next hop
                     addresses.

                     Example. "name=classless_static_route", "code=121", "type=static_routes".

                     put_dhcp_opts(..., classless_static_route = {30.0.0.0/24,10.0.0.4,0.0.0.0/0,10.0.0.1}...)

              <b>value:</b> <b>str</b>
                     This indicates that the value of the DHCP option is a string.

                     Example. "name=host_name", "code=12", "type=str".

              <b>value:</b> <b>host_id</b>
                     This indicates that the value of the DHCP option is a host_id. It can either be a host_name
                     or an IP address.

                     Example. "name=tftp_server", "code=66", "type=host_id".

              <b>value:</b> <b>domains</b>
                     This indicates that the value of the DHCP option is a domain name or a comma separated list
                     of domain names.

                     Example. "name=domain_search_list", "code=119", "type=domains".
</pre><h4><b>DHCPv6_Options</b> <b>TABLE</b></h4><pre>
       Each row in this table stores the DHCPv6 Options supported by native  OVN  DHCPv6.  <b>ovn-northd</b>  populates
       this  table with the supported DHCPv6 options. <b>ovn-controller</b> looks up this table to get the DHCPv6 codes
       of the DHCPv6 options defined in the <b>put_dhcpv6_opts</b> action. Please refer to RFC 3315 and  RFC  3646  for
       the list of DHCPv6 options that can be defined here.

   <b>Summary:</b>
       <b>name</b>                          string
       <b>code</b>                          integer, in range 0 to 254
       <b>type</b>                          string, one of <b>domain</b>, <b>ipv6</b>, <b>mac</b>, or <b>str</b>

   <b>Details:</b>
       <b>name</b>: string
              Name of the DHCPv6 option.

              Example. name="ia_addr"

       <b>code</b>: integer, in range 0 to 254
              DHCPv6 option code for the DHCPv6 option as defined in the appropriate RFC.

              Example. code=3

       <b>type</b>: string, one of <b>domain</b>, <b>ipv6</b>, <b>mac</b>, or <b>str</b>
              Data type of the DHCPv6 option code.

              <b>value:</b> <b>ipv6</b>
                     This indicates that the value of the DHCPv6 option is an IPv6 address(es).

                     Example. "name=ia_addr", "code=5", "type=ipv6".

                     put_dhcpv6_opts(..., ia_addr = ae70::4,...)

              <b>value:</b> <b>str</b>
                     This indicates that the value of the DHCPv6 option is a string.

                     Example. "name=domain_search", "code=24", "type=str".

                     put_dhcpv6_opts(..., domain_search = ovn.domain,...)

              <b>value:</b> <b>mac</b>
                     This indicates that the value of the DHCPv6 option is a MAC address.

                     Example. "name=server_id", "code=2", "type=mac".

                     put_dhcpv6_opts(..., server_id = 01:02:03:04L05:06,...)
</pre><h4><b>Connection</b> <b>TABLE</b></h4><pre>
       Configuration for a database connection to an Open vSwitch database (OVSDB) client.

       This table primarily configures the Open vSwitch database server (<b>ovsdb-server</b>).

       The  Open  vSwitch database server can initiate and maintain active connections to remote clients. It can
       also listen for database connections.

   <b>Summary:</b>
       <u>Core</u> <u>Features:</u>
         <b>target</b>                      string (must be unique within table)
         <b>read_only</b>                   boolean
         <b>role</b>                        string
       <u>Client</u> <u>Failure</u> <u>Detection</u> <u>and</u> <u>Handling:</u>
         <b>max_backoff</b>                 optional integer, at least 1,000
         <b>inactivity_probe</b>            optional integer
       <u>Status:</u>
         <b>is_connected</b>                boolean
         <b>status</b> <b>:</b> <b>last_error</b>         optional string
         <b>status</b> <b>:</b> <b>state</b>              optional string, one of <b>ACTIVE</b>, <b>BACKOFF</b>, <b>CONNECTING</b>, <b>IDLE</b>, or <b>VOID</b>
         <b>status</b> <b>:</b> <b>sec_since_connect</b>  optional string, containing an integer, at least 0
         <b>status</b> <b>:</b> <b>sec_since_disconnect</b>
                                     optional string, containing an integer, at least 0
         <b>status</b> <b>:</b> <b>locks_held</b>         optional string
         <b>status</b> <b>:</b> <b>locks_waiting</b>      optional string
         <b>status</b> <b>:</b> <b>locks_lost</b>         optional string
         <b>status</b> <b>:</b> <b>n_connections</b>      optional string, containing an integer, at least 2
         <b>status</b> <b>:</b> <b>bound_port</b>         optional string, containing an integer
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs
         <b>other_config</b>                map of string-string pairs

   <b>Details:</b>
     <u>Core</u> <u>Features:</u>

       <b>target</b>: string (must be unique within table)
              Connection methods for clients.

              The following connection methods are currently supported:

              <b>ssl:</b><u>host</u>[<b>:</b><u>port</u>]
                     The specified SSL/TLS <u>port</u> on the given <u>host</u>, which can either be a DNS name (if built with
                     unbound library) or an IP address. A valid SSL configuration must  be  provided  when  this
                     form  is  used,  this  configuration  can  be specified via command-line options or the <b>SSL</b>
                     table.

                     If <u>port</u> is not specified, it defaults to 6640.

                     SSL/TLS support is an optional feature that is not always built as  part  of  OVN  or  Open
                     vSwitch.

              <b>tcp:</b><u>host</u>[<b>:</b><u>port</u>]
                     The  specified  TCP  <u>port</u>  on the given <u>host</u>, which can either be a DNS name (if built with
                     unbound library) or an IP address (IPv4 or IPv6). If <u>host</u> is an IPv6 address,  wrap  it  in
                     square brackets, e.g. <b>tcp:[::1]:6640</b>.

                     If <u>port</u> is not specified, it defaults to 6640.

              <b>pssl:</b>[<u>port</u>][<b>:</b><u>host</u>]
                     Listens  for  SSL/TLS connections on the specified TCP <u>port</u>. Specify 0 for <u>port</u> to have the
                     kernel automatically choose an available port. If <u>host</u>, which can either be a DNS name  (if
                     built with unbound library) or an IP address, is specified, then connections are restricted
                     to  the resolved or specified local IP address (either IPv4 or IPv6 address). If <u>host</u> is an
                     IPv6 address, wrap in square brackets, e.g. <b>pssl:6640:[::1]</b>. If <u>host</u> is not specified  then
                     it  listens  only  on  IPv4 (but not IPv6) addresses. A valid SSL/TLS configuration must be
                     provided when this form is used, this can be specified either via command-line  options  or
                     the <b>SSL</b> table.

                     If <u>port</u> is not specified, it defaults to 6640.

                     SSL/TLS  support  is  an  optional  feature that is not always built as part of OVN or Open
                     vSwitch.

              <b>ptcp:</b>[<u>port</u>][<b>:</b><u>host</u>]
                     Listens for connections on the specified TCP <u>port</u>. Specify 0 for <u>port</u> to  have  the  kernel
                     automatically  choose  an available port. If <u>host</u>, which can either be a DNS name (if built
                     with unbound library) or an IP address, is specified, then connections  are  restricted  to
                     the  resolved  or  specified  local IP address (either IPv4 or IPv6 address). If <u>host</u> is an
                     IPv6 address, wrap it in square brackets, e.g. <b>ptcp:6640:[::1]</b>. If <u>host</u>  is  not  specified
                     then it listens only on IPv4 addresses.

                     If <u>port</u> is not specified, it defaults to 6640.

              When  multiple  clients  are configured, the <b>target</b> values must be unique. Duplicate <b>target</b> values
              yield unspecified results.

       <b>read_only</b>: boolean
              <b>true</b> to restrict these connections to read-only transactions, <b>false</b> to allow them  to  modify  the
              database.

       <b>role</b>: string
              String containing role name for this connection entry.

     <u>Client</u> <u>Failure</u> <u>Detection</u> <u>and</u> <u>Handling:</u>

       <b>max_backoff</b>: optional integer, at least 1,000
              Maximum  number  of  milliseconds  to wait between connection attempts. Default is implementation-
              specific.

       <b>inactivity_probe</b>: optional integer
              Maximum number of milliseconds of idle  time  on  connection  to  the  client  before  sending  an
              inactivity  probe  message. If Open vSwitch does not communicate with the client for the specified
              number of seconds, it will send a probe. If a response is not received  for  the  same  additional
              amount  of  time,  Open  vSwitch assumes the connection has been broken and attempts to reconnect.
              Default is implementation-specific. A value of 0 disables inactivity probes.

     <u>Status:</u>

       Key-value pair of <b>is_connected</b> is always updated. Other key-value pairs in  the  status  columns  may  be
       updated depends on the <b>target</b> type.

       When  <b>target</b>  specifies  a connection method that listens for inbound connections (e.g. <b>ptcp:</b> or <b>punix:</b>),
       both <b>n_connections</b> and <b>is_connected</b> may also be updated while the remaining key-value pairs are omitted.

       On the other hand, when <b>target</b> specifies an outbound connection, all  key-value  pairs  may  be  updated,
       except  the  above-mentioned  two  key-value  pairs  associated with inbound connection targets. They are
       omitted.

       <b>is_connected</b>: boolean
              <b>true</b> if currently connected to this client, <b>false</b> otherwise.

       <b>status</b> <b>:</b> <b>last_error</b>: optional string
              A  human-readable  description  of  the  last  error  on  the  connection  to  the  manager;  i.e.
              <b>strerror(errno)</b>. This key will exist only if an error has occurred.

       <b>status</b> <b>:</b> <b>state</b>: optional string, one of <b>ACTIVE</b>, <b>BACKOFF</b>, <b>CONNECTING</b>, <b>IDLE</b>, or <b>VOID</b>
              The state of the connection to the manager:

              <b>VOID</b>   Connection is disabled.

              <b>BACKOFF</b>
                     Attempting to reconnect at an increasing period.

              <b>CONNECTING</b>
                     Attempting to connect.

              <b>ACTIVE</b> Connected, remote host responsive.

              <b>IDLE</b>   Connection is idle. Waiting for response to keep-alive.

              These values may change in the future. They are provided only for human consumption.

       <b>status</b> <b>:</b> <b>sec_since_connect</b>: optional string, containing an integer, at least 0
              The  amount  of  time  since this client last successfully connected to the database (in seconds).
              Value is empty if client has never successfully been connected.

       <b>status</b> <b>:</b> <b>sec_since_disconnect</b>: optional string, containing an integer, at least 0
              The amount of time since this client last disconnected from the database (in  seconds).  Value  is
              empty if client has never disconnected.

       <b>status</b> <b>:</b> <b>locks_held</b>: optional string
              Space-separated  list  of  the  names  of  OVSDB  locks  that the connection holds. Omitted if the
              connection does not hold any locks.

       <b>status</b> <b>:</b> <b>locks_waiting</b>: optional string
              Space-separated list of the names of OVSDB locks that  the  connection  is  currently  waiting  to
              acquire. Omitted if the connection is not waiting for any locks.

       <b>status</b> <b>:</b> <b>locks_lost</b>: optional string
              Space-separated  list  of  the  names of OVSDB locks that the connection has had stolen by another
              OVSDB client. Omitted if no locks have been stolen from this connection.

       <b>status</b> <b>:</b> <b>n_connections</b>: optional string, containing an integer, at least 2
              When <b>target</b> specifies a connection method that listens for  inbound  connections  (e.g.  <b>ptcp:</b>  or
              <b>pssl:</b>)  and  more  than  one  connection  is  actually  active,  the value is the number of active
              connections. Otherwise, this key-value pair is omitted.

       <b>status</b> <b>:</b> <b>bound_port</b>: optional string, containing an integer
              When <b>target</b> is <b>ptcp:</b> or <b>pssl:</b>, this is the TCP port on which the OVSDB server is listening.  (This
              is  particularly  useful  when  <b>target</b>  specifies  a  port of 0, allowing the kernel to choose any
              available port.)

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs

       <b>other_config</b>: map of string-string pairs
</pre><h4><b>SSL</b> <b>TABLE</b></h4><pre>
       SSL/TLS configuration for ovn-sb database access.

   <b>Summary:</b>
       <b>private_key</b>                   string
       <b>certificate</b>                   string
       <b>ca_cert</b>                       string
       <b>bootstrap_ca_cert</b>             boolean
       <b>ssl_protocols</b>                 string
       <b>ssl_ciphers</b>                   string
       <b>ssl_ciphersuites</b>              string
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>private_key</b>: string
              Name of a PEM file  containing  the  private  key  used  as  the  switch’s  identity  for  SSL/TLS
              connections to the controller.

       <b>certificate</b>: string
              Name  of a PEM file containing a certificate, signed by the certificate authority (CA) used by the
              controller and manager, that certifies the switch’s private key, identifying a trustworthy switch.

       <b>ca_cert</b>: string
              Name of a PEM file containing the CA certificate used to verify that the switch is connected to  a
              trustworthy controller.

       <b>bootstrap_ca_cert</b>: boolean
              If set to <b>true</b>, then Open vSwitch will attempt to obtain the CA certificate from the controller on
              its  first  SSL/TLS  connection  and  save  it to the named PEM file. If it is successful, it will
              immediately drop the connection and reconnect, and from then on all SSL/TLS  connections  must  be
              authenticated by a certificate signed by the CA certificate thus obtained. <b>This</b> <b>option</b> <b>exposes</b> <b>the</b>
              <b>SSL/TLS</b>  <b>connection</b>  <b>to</b>  <b>a</b>  <b>man-in-the-middle</b>  <b>attack</b> <b>obtaining</b> <b>the</b> <b>initial</b> <b>CA</b> <b>certificate.</b> It may
              still be useful for bootstrapping.

       <b>ssl_protocols</b>: string
              Range or a comma- or  space-delimited  list  of  the  SSL/TLS  protocols  to  enable  for  SSL/TLS
              connections.

              Supported  protocols include <b>TLSv1</b> (deprecated), <b>TLSv1.1</b> (deprecated), <b>TLSv1.2</b> and <b>TLSv1.3</b>. Ranges
              can be provided in a form of two protocol names separated with a dash (<b>TLSv1.1-TLSv1.2</b>), or  as  a
              single  protocol name with a plus sign (<b>TLSv1.2+</b>). The value can be a list of protocols or exactly
              one range. The range is a preferred way of  specifying  protocols  and  the  configuration  always
              behaves  as  if the range between the minimum and the maximum specified version is provided, i.e.,
              if the value is set to <b>TLSv1.1,TLSv1.3</b>, the <b>TLSv1.2</b> will also be enabled as if  it  was  a  range.
              Regardless  of  order, the highest protocol supported by both sides will be chosen when making the
              connection.

              The default when this option is omitted is <b>TLSv1.2+</b>.

       <b>ssl_ciphers</b>: string
              List of ciphers (in OpenSSL cipher string format) to be supported  for  SSL/TLS  connections  with
              TLSv1.2 and earlier. The default when this option is omitted is <b>DEFAULT:@SECLEVEL=2</b>.

       <b>ssl_ciphersuites</b>: string
              List  of  ciphersuites  (in  OpenSSL  ciphersuites  string  format)  to  be  supported for SSL/TLS
              connections with TLSv1.3 and later. Default value from OpenSSL will be used when  this  option  is
              omitted.

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre><h4><b>DNS</b> <b>TABLE</b></h4><pre>
       Each  row  in  this  table  stores  the  DNS  records.  The OVN action <b>dns_lookup</b> uses this table for DNS
       resolution.

   <b>Summary:</b>
       <b>records</b>                       map of string-string pairs
       <b>datapaths</b>                     set of 1 or more <b>Datapath_Binding</b>s
       <b>options</b> <b>:</b> <b>ovn-owned</b>           optional string
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>records</b>: map of string-string pairs
              Key-value pair of DNS records with <b>DNS</b> <b>query</b> <b>name</b> as the  key  and  a  string  of  IP  address(es)
              separated by comma or space as the value. ovn-northd stores the DNS query name in all lowercase in
              order to facilitate case-insensitive lookups.

              <b>Example:</b>  "vm1.ovn.org" = "10.0.0.4 aef0::4"

       <b>datapaths</b>: set of 1 or more <b>Datapath_Binding</b>s
              The  DNS records defined in the column <b>records</b> will be applied only to the DNS queries originating
              from the datapaths defined in this column.

       <b>options</b> <b>:</b> <b>ovn-owned</b>: optional string
              This column indicates that all the <b>Domains</b> in this table are owned by OVN, and all <b>DNS</b> <b>queries</b> for
              those domains will be answered locally by either an IP address or <b>DNS</b> <b>rejection</b>.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>RBAC_Role</b> <b>TABLE</b></h4><pre>
       Role table for role-based access controls.

   <b>Summary:</b>
       <b>name</b>                          string
       <b>permissions</b>                   map of string-weak reference to <b>RBAC_Permission</b> pairs

   <b>Details:</b>
       <b>name</b>: string
              The role name, corresponding to the <b>role</b> column in the <b>Connection</b> table.

       <b>permissions</b>: map of string-weak reference to <b>RBAC_Permission</b> pairs
              A mapping of table names to rows in the <b>RBAC_Permission</b> table.

</pre><h4><b>RBAC_Permission</b> <b>TABLE</b></h4><pre>
       Permissions table for role-based access controls.

   <b>Summary:</b>
       <b>table</b>                         string
       <b>authorization</b>                 set of strings
       <b>insert_delete</b>                 boolean
       <b>update</b>                        set of strings

   <b>Details:</b>
       <b>table</b>: string
              Name of table to which this row applies.

       <b>authorization</b>: set of strings
              Set of strings identifying columns and column:key pairs to be compared with client  ID.  At  least
              one  match  is  required  in  order to be authorized. A zero-length string is treated as a special
              value indicating all clients should be considered authorized.

       <b>insert_delete</b>: boolean
              When "true", row insertions and authorized row deletions are permitted.

       <b>update</b>: set of strings
              Set of strings identifying columns and column:key pairs that authorized  clients  are  allowed  to
              modify.

</pre><h4><b>Gateway_Chassis</b> <b>TABLE</b></h4><pre>
       Association  of  <b>Port_Binding</b>  rows of <b>type</b> <b>chassisredirect</b> to a <b>Chassis</b>. The traffic going out through a
       specific <b>chassisredirect</b> port will be redirected to a chassis, or a set  of  them  in  high  availability
       configurations.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>chassis</b>                       optional weak reference to <b>Chassis</b>
       <b>priority</b>                      integer, in range 0 to 32,767
       <b>options</b>                       map of string-string pairs
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              Name of the <b>Gateway_Chassis</b>.

              A suggested, but not required naming convention is <b>${port_name}_${chassis_name}</b>.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The <b>Chassis</b> to which we send the traffic.

       <b>priority</b>: integer, in range 0 to 32,767
              This  is  the  priority  the  specific  <b>Chassis</b>  among  all  Gateway_Chassis belonging to the same
              <b>Port_Binding</b>.

       <b>options</b>: map of string-string pairs
              Reserved for future use.

     <u>Common</u> <u>Columns:</u>

       The overall purpose of these columns is described under <b>Common</b> <b>Columns</b> at the beginning of this document.

       <b>external_ids</b>: map of string-string pairs
</pre><h4><b>HA_Chassis</b> <b>TABLE</b></h4><pre>
   <b>Summary:</b>
       <b>chassis</b>                       optional weak reference to <b>Chassis</b>
       <b>priority</b>                      integer, in range 0 to 32,767
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              The <b>Chassis</b> which provides the HA functionality.

       <b>priority</b>: integer, in range 0 to 32,767
              Priority of the HA chassis. Chassis with highest priority will be the active  chassis  in  the  HA
              chassis group.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>HA_Chassis_Group</b> <b>TABLE</b></h4><pre>
       Table  representing  a group of chassis which can provide High availability services. Each chassis in the
       group is represented by the table <b>HA_Chassis</b>. The HA chassis with highest priority  will  be  the  active
       chassis  of  this  group. If the active chassis failover is detected, the HA chassis with the next higher
       priority takes over the responsibility of providing the HA.  If  <b>ha_chassis_group</b>  column  of  the  table
       <b>Port_Binding</b>  references  this  table,  then this HA chassis group provides the gateway functionality and
       redirects the gateway traffic to the active chassis of this group.

   <b>Summary:</b>
       <b>name</b>                          string (must be unique within table)
       <b>ha_chassis</b>                    set of <b>HA_Chassis</b>es
       <b>ref_chassis</b>                   set of weak reference to <b>Chassis</b>
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string (must be unique within table)
              Name of the <b>HA_Chassis_Group</b>. Name should be unique.

       <b>ha_chassis</b>: set of <b>HA_Chassis</b>es
              A list of <b>HA_Chassis</b> which belongs to this group.

       <b>ref_chassis</b>: set of weak reference to <b>Chassis</b>
              The set of <b>Chassis</b> that reference this HA chassis group. To determine the  correct  <b>Chassis</b>,  find
              the  <b>chassisredirect</b> type <b>Port_Binding</b> that references this <b>HA_Chassis_Group</b>. This <b>Port_Binding</b> is
              derived from some particular logical router. Starting from that LR, find the set  of  all  logical
              switches  and  routers  connected to it, directly or indirectly, across router ports that link one
              LRP to another or to a LSP. For each  LSP  in  these  logical  switches,  find  the  corresponding
              <b>Port_Binding</b> and add its bound <b>Chassis</b> (if any) to <b>ref_chassis</b>.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>Controller_Event</b> <b>TABLE</b></h4><pre>
       Database  table  used by <b>ovn-controller</b> to report CMS related events. Please note there is no guarantee a
       given event is written exactly once in the db. It is CMS responsibility to squash duplicated lines or  to
       filter out duplicated events

   <b>Summary:</b>
       <b>event_type</b>                    string, must be <b>empty_lb_backends</b>
       <b>event_info</b>                    map of string-string pairs
       <b>chassis</b>                       optional weak reference to <b>Chassis</b>
       <b>seq_num</b>                       integer

   <b>Details:</b>
       <b>event_type</b>: string, must be <b>empty_lb_backends</b>
              Event type occurred

       <b>event_info</b>: map of string-string pairs
              Key-value pairs used to specify event info to the CMS. Possible values are:

              •      <b>vip</b>: VIP reported for the <b>empty_lb_backends</b> event

              •      <b>protocol</b>: Transport protocol reported for the <b>empty_lb_backends</b> event

              •      <b>load_balancer</b>: UUID of the load balancer reported for the <b>empty_lb_backends</b> event

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              This column is a <b>Chassis</b> record to identify the chassis that has managed a given event.

       <b>seq_num</b>: integer
              Event  sequence  number. Global counter for controller generated events. It can be used by the CMS
              to detect possible duplication of the same event.

</pre><h4><b>IP_Multicast</b> <b>TABLE</b></h4><pre>
       IP Multicast configuration options. For now only applicable to IGMP.

   <b>Summary:</b>
       <b>datapath</b>                      weak reference to <b>Datapath_Binding</b> (must be unique within table)
       <b>enabled</b>                       optional boolean
       <b>querier</b>                       optional boolean
       <b>table_size</b>                    optional integer
       <b>idle_timeout</b>                  optional integer
       <b>query_interval</b>                optional integer
       <b>seq_no</b>                        integer
       <u>Querier</u> <u>configuration</u> <u>options:</u>
         <b>eth_src</b>                     string
         <b>ip4_src</b>                     string
         <b>ip6_src</b>                     string
         <b>query_max_resp</b>              optional integer

   <b>Details:</b>
       <b>datapath</b>: weak reference to <b>Datapath_Binding</b> (must be unique within table)
              <b>Datapath_Binding</b> entry for which these configuration options are defined.

       <b>enabled</b>: optional boolean
              Enables/disables multicast snooping. Default: disabled.

       <b>querier</b>: optional boolean
              Enables/disables multicast querying. If <b>enabled</b> then multicast querying is enabled by default.

       <b>table_size</b>: optional integer
              Limits the number of multicast groups that can be learned. Default: 2048 groups per datapath.

       <b>idle_timeout</b>: optional integer
              Configures the idle timeout (in seconds) for IP multicast groups if multicast snooping is enabled.
              Default: 300 seconds.

       <b>query_interval</b>: optional integer
              Configures the interval (in seconds) for sending multicast queries if  snooping  and  querier  are
              enabled. Default: <b>idle_timeout</b>/2 seconds.

       <b>seq_no</b>: integer
              <b>ovn-controller</b>  reads  this  value  and  flushes all learned multicast groups when it detects that
              <b>seq_no</b> was changed.

     <u>Querier</u> <u>configuration</u> <u>options:</u>

       The <b>ovn-controller</b> process that runs on OVN hypervisor nodes uses  the  following  columns  to  determine
       field values in IGMP/MLD queries that it originates:

       <b>eth_src</b>: string
              Source Ethernet address.

       <b>ip4_src</b>: string
              Source IPv4 address.

       <b>ip6_src</b>: string
              Source IPv6 address.

       <b>query_max_resp</b>: optional integer
              Value (in seconds) to be used as "max-response" field in multicast queries. Default: 1 second.

</pre><h4><b>IGMP_Group</b> <b>TABLE</b></h4><pre>
       Contains learned IGMP groups indexed by address/datapath/chassis.

   <b>Summary:</b>
       <b>address</b>                       string
       <b>protocol</b>                      string
       <b>datapath</b>                      optional weak reference to <b>Datapath_Binding</b>
       <b>chassis</b>                       optional weak reference to <b>Chassis</b>
       <b>ports</b>                         set of weak reference to <b>Port_Binding</b>s
       <b>chassis_name</b>                  string

   <b>Details:</b>
       <b>address</b>: string
              Destination IPv4 address for the IGMP group.

       <b>protocol</b>: string
              Group protocol version either IGMPv1,v2,v3 or MLDv1,v2.

       <b>datapath</b>: optional weak reference to <b>Datapath_Binding</b>
              Datapath to which this IGMP group belongs.

       <b>chassis</b>: optional weak reference to <b>Chassis</b>
              Chassis to which this IGMP group belongs.

       <b>ports</b>: set of weak reference to <b>Port_Binding</b>s
              The destination port bindings for this IGMP group.

       <b>chassis_name</b>: string
              The chassis that inserted this record. This column is used for RBAC purposes only.

</pre><h4><b>Service_Monitor</b> <b>TABLE</b></h4><pre>
       Each  row  in this table configures monitoring a service for its liveness. The service can be an IPv4 TCP
       or UDP service. <b>ovn-controller</b> periodically sends out service monitor packets and updates the  status  of
       the service.

       <b>ovn-northd</b>  uses  this  feature  to  implement  the load balancer health check feature offered to the CMS
       through the northbound database.

   <b>Summary:</b>
       <u>Configuration:</u>
         <b>ip</b>                          string
         <b>protocol</b>                    optional string, either <b>tcp</b> or <b>udp</b>
         <b>port</b>                        integer, in range 0 to 65,535
         <b>logical_port</b>                string
         <b>src_mac</b>                     string
         <b>src_ip</b>                      string
         <b>chassis_name</b>                string
         <b>options</b> <b>:</b> <b>interval</b>          optional string, containing an integer
         <b>options</b> <b>:</b> <b>timeout</b>           optional string, containing an integer
         <b>options</b> <b>:</b> <b>success_count</b>     optional string, containing an integer
         <b>options</b> <b>:</b> <b>failure_count</b>     optional string, containing an integer
       <u>Status</u> <u>Reporting:</u>
         <b>status</b>                      optional string, one of <b>error</b>, <b>offline</b>, or <b>online</b>
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
     <u>Configuration:</u>

       <b>ovn-northd</b> sets these columns and values to configure the service monitor.

       <b>ip</b>: string
              IP of the service to be monitored. Only IPv4 is supported.

       <b>protocol</b>: optional string, either <b>tcp</b> or <b>udp</b>
              The protocol of the service.

       <b>port</b>: integer, in range 0 to 65,535
              The TCP or UDP port of the service.

       <b>logical_port</b>: string
              The VIF of the logical port on which the service is running. The <b>ovn-controller</b>  that  binds  this
              <b>logical_port</b> monitors the service by sending periodic monitor packets.

       <b>src_mac</b>: string
              Source Ethernet address to use in the service monitor packet.

       <b>src_ip</b>: string
              Source IPv4 or IPv6 address to use in the service monitor packet.

       <b>chassis_name</b>: string
              The name of the chassis where the logical port is bound.

       <b>options</b> <b>:</b> <b>interval</b>: optional string, containing an integer
              The interval, in seconds, between service monitor checks.

       <b>options</b> <b>:</b> <b>timeout</b>: optional string, containing an integer
              The time, in seconds, after which the service monitor check times out.

       <b>options</b> <b>:</b> <b>success_count</b>: optional string, containing an integer
              The number of successful checks after which the service is considered <b>online</b>.

       <b>options</b> <b>:</b> <b>failure_count</b>: optional string, containing an integer
              The number of failure checks after which the service is considered <b>offline</b>.

     <u>Status</u> <u>Reporting:</u>

       The <b>ovn-controller</b> on the chassis that hosts the <b>logical_port</b> updates this column to report the service’s
       status.

       <b>status</b>: optional string, one of <b>error</b>, <b>offline</b>, or <b>online</b>
              For TCP service, <b>ovn-controller</b> sends a SYN to the service and expects an ACK response to consider
              the service to be <b>online</b>.

              For UDP service, <b>ovn-controller</b> sends a UDP packet to the service and doesn’t expect any reply. If
              it receives an ICMP reply, then it considers the service to be <b>offline</b>.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>Load_Balancer</b> <b>TABLE</b></h4><pre>
       Each row represents a load balancer.

   <b>Summary:</b>
       <b>name</b>                          string
       <b>vips</b>                          map of string-string pairs
       <b>protocol</b>                      optional string, one of <b>sctp</b>, <b>tcp</b>, or <b>udp</b>
       <b>datapaths</b>                     set of <b>Datapath_Binding</b>s
       <b>datapath_group</b>                optional <b>Logical_DP_Group</b>
       <b>ls_datapath_group</b>             optional <b>Logical_DP_Group</b>
       <b>lr_datapath_group</b>             optional <b>Logical_DP_Group</b>
       <u>Load_Balancer</u> <u>options:</u>
         <b>options</b> <b>:</b> <b>hairpin_snat_ip</b>   optional string
         <b>options</b> <b>:</b> <b>hairpin_orig_tuple</b>
                                     optional string, either <b>true</b> or <b>false</b>
       <u>Common</u> <u>Columns:</u>
         <b>external_ids</b>                map of string-string pairs

   <b>Details:</b>
       <b>name</b>: string
              A  name  for  the load balancer. This name has no special meaning or purpose other than to provide
              convenience for human interaction with the ovn-nb database.

       <b>vips</b>: map of string-string pairs
              A map of virtual IP addresses (and an optional port number with <b>:</b> as a separator) associated  with
              this load balancer and their corresponding endpoint IP addresses (and optional port numbers with <b>:</b>
              as separators) separated by commas.

       <b>protocol</b>: optional string, one of <b>sctp</b>, <b>tcp</b>, or <b>udp</b>
              Valid  protocols  are  <b>tcp</b>,  <b>udp</b>, or <b>sctp</b>. This column is useful when a port number is provided as
              part of the <b>vips</b> column. If this column is empty and a port number is provided  as  part  of  <b>vips</b>
              column, OVN assumes the protocol to be <b>tcp</b>.

       <b>datapaths</b>: set of <b>Datapath_Binding</b>s
              Datapaths to which this load balancer applies to.

       <b>datapath_group</b>: optional <b>Logical_DP_Group</b>
              Deprecated.  The  group  of  datapaths to which this load balancer applies to. This means that the
              same load balancer applies to all datapaths in a group.

       <b>ls_datapath_group</b>: optional <b>Logical_DP_Group</b>
              The group of datapaths to which this load balancer applies to.  This  means  that  the  same  load
              balancer applies to all datapaths in a group.

       <b>lr_datapath_group</b>: optional <b>Logical_DP_Group</b>
              The  group of logical router datapaths to which this load balancer applies to. This means that the
              same load balancer applies to all datapaths in a group.

     <u>Load_Balancer</u> <u>options:</u>

       <b>options</b> <b>:</b> <b>hairpin_snat_ip</b>: optional string
              IP to be used as source IP for packets that have been hair-pinned after load balancing. This value
              is automatically populated by <b>ovn-northd</b>.

       <b>options</b> <b>:</b> <b>hairpin_orig_tuple</b>: optional string, either <b>true</b> or <b>false</b>
              This value is automatically set to <b>true</b> by <b>ovn-northd</b> when original destination IP  and  transport
              port of the load balanced packets are stored in registers <b>reg1,</b> <b>reg2,</b> <b>xxreg1</b>.

     <u>Common</u> <u>Columns:</u>

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>BFD</b> <b>TABLE</b></h4><pre>
       Contains BFD parameter for ovn-controller bfd configuration.

   <b>Summary:</b>
       <u>Configuration:</u>
         <b>src_port</b>                    integer, in range 49,152 to 65,535
         <b>disc</b>                        integer
         <b>logical_port</b>                string
         <b>dst_ip</b>                      string
         <b>min_tx</b>                      integer
         <b>min_rx</b>                      integer
         <b>detect_mult</b>                 integer
         <b>chassis_name</b>                string
         <b>options</b>                     map of string-string pairs
         <b>external_ids</b>                map of string-string pairs
       <u>Status</u> <u>Reporting:</u>
         <b>status</b>                      string, one of <b>admin_down</b>, <b>down</b>, <b>init</b>, or <b>up</b>

   <b>Details:</b>
     <u>Configuration:</u>

       <b>src_port</b>: integer, in range 49,152 to 65,535
              udp  source  port  used in bfd control packets. The source port MUST be in the range 49152 through
              65535 (RFC5881 section 4).

       <b>disc</b>: integer
              A unique, nonzero discriminator value generated by the transmitting system,  used  to  demultiplex
              multiple BFD sessions between the same pair of systems.

       <b>logical_port</b>: string
              OVN logical port when BFD engine is running.

       <b>dst_ip</b>: string
              BFD peer IP address.

       <b>min_tx</b>: integer
              This  is  the  minimum  interval,  in  milliseconds,  that the local system would like to use when
              transmitting BFD Control packets, less any jitter applied. The value zero is reserved.

       <b>min_rx</b>: integer
              This is the minimum interval, in milliseconds, between received  BFD  Control  packets  that  this
              system is capable of supporting, less any jitter applied by the sender. If this value is zero, the
              transmitting system does not want the remote system to send any periodic BFD Control packets.

       <b>detect_mult</b>: integer
              Detection  time  multiplier.  The negotiated transmit interval, multiplied by this value, provides
              the Detection Time for the receiving system in Asynchronous mode.

       <b>chassis_name</b>: string
              The name of the chassis where the logical port is bound.

       <b>options</b>: map of string-string pairs
              Reserved for future use.

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

     <u>Status</u> <u>Reporting:</u>

       <b>status</b>: string, one of <b>admin_down</b>, <b>down</b>, <b>init</b>, or <b>up</b>
              BFD port logical states. Possible values are:

              •      <b>admin_down</b>

              •      <b>down</b>

              •      <b>init</b>

              •      <b>up</b>
</pre><h4><b>FDB</b> <b>TABLE</b></h4><pre>
       This table  is  primarily  used  to  learn  the  MACs  observed  on  a  VIF  (or  a  localnet  port  with
       ’localnet_learn_fdb’  enabled) which belongs to a <b>Logical_Switch_Port</b> record in <b>OVN_Northbound</b> whose port
       security is disabled and ’unknown’ address set. If port security is  disabled  on  a  <b>Logical_Switch_Port</b>
       record,  OVN  should allow traffic with any source mac from the VIF. This table will be used to deliver a
       packet to the VIF, If a packet’s <b>eth.dst</b> is learnt.

   <b>Summary:</b>
       <b>mac</b>                           string
       <b>dp_key</b>                        integer, in range 1 to 16,777,215
       <b>port_key</b>                      integer, in range 1 to 16,777,215
       <b>timestamp</b>                     integer

   <b>Details:</b>
       <b>mac</b>: string
              The learnt mac address.

       <b>dp_key</b>: integer, in range 1 to 16,777,215
              The key of the datapath on which this FDB was learnt.

       <b>port_key</b>: integer, in range 1 to 16,777,215
              The key of the port binding on which this FDB was learnt.

       <b>timestamp</b>: integer
              The timestamp in msec when the FDB was added or updated. Records that existed before  this  column
              will have 0.

</pre><h4><b>Static_MAC_Binding</b> <b>TABLE</b></h4><pre>
       Each record represents a Static_MAC_Binding entry for a logical router.

   <b>Summary:</b>
       <b>logical_port</b>                  string
       <b>ip</b>                            string
       <b>mac</b>                           string
       <b>override_dynamic_mac</b>          boolean
       <b>datapath</b>                      <b>Datapath_Binding</b>

   <b>Details:</b>
       <b>logical_port</b>: string
              The logical router port for the binding.

       <b>ip</b>: string
              The bound IP address.

       <b>mac</b>: string
              The Ethernet address to which the IP is bound.

       <b>override_dynamic_mac</b>: boolean
              Override dynamically learnt MACs.

       <b>datapath</b>: <b>Datapath_Binding</b>
              The logical datapath to which the logical router port belongs.

</pre><h4><b>Chassis_Template_Var</b> <b>TABLE</b></h4><pre>
       Each  record  represents the set of template variable instantiations for a given chassis and is populated
       by <b>ovn-northd</b> from the contents of the <b>OVN_Northbound.Chassis_Template_Var</b> table.

   <b>Summary:</b>
       <b>chassis</b>                       string (must be unique within table)
       <b>variables</b>                     map of string-string pairs

   <b>Details:</b>
       <b>chassis</b>: string (must be unique within table)
              The chassis this set of variable values applies to.

       <b>variables</b>: map of string-string pairs
              The set of variable values for a given chassis.

</pre><h4><b>Advertised_Route</b> <b>TABLE</b></h4><pre>
       Each record represents a route that should be exported from ovn to the  outside  network  fabric.  It  is
       populated    by    <b>ovn-northd</b>    based    on    the    addresses,   routes   and   NAT   Entries   of   a
       <b>OVN_Northbound.Logical_Router_Port</b>.

   <b>Summary:</b>
       <b>datapath</b>                      <b>Datapath_Binding</b>
       <b>logical_port</b>                  <b>Port_Binding</b>
       <b>ip_prefix</b>                     string
       <b>tracked_port</b>                  optional <b>Port_Binding</b>
       <b>external_ids</b>                  map of string-string pairs

   <b>Details:</b>
       <b>datapath</b>: <b>Datapath_Binding</b>
              The datapath belonging to the <b>OVN_Northbound.Logical_Router</b> that this route is valid for.

       <b>logical_port</b>: <b>Port_Binding</b>
              This is the <b>Port_Binding</b> that the router will send packets out that are  received  for  the  below
              prefix.

       <b>ip_prefix</b>: string
              IP prefix of this route (e.g. 192.168.100.0/24).

       <b>tracked_port</b>: optional <b>Port_Binding</b>
              In  combination  with  a host <b>ip_prefix</b> this tracks the port OVN will forward the packets for this
              destination to. If set the <b>ip_prefix</b> will always contain a /32  (for  ipv4)  or  /128  (for  ipv6)
              prefix.  An  announcing chassis can use this information to check if this destination is local and
              adjust the route priorities based on that.

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>Learned_Route</b> <b>TABLE</b></h4><pre>
       Each record represents a route that learned by ovn using some dynamic routing logic outside of ovn. It is
       populated by <b>ovn-controller</b> with routes it learns locally.

   <b>Summary:</b>
       <b>datapath</b>                      <b>Datapath_Binding</b>
       <b>logical_port</b>                  <b>Port_Binding</b>
       <b>ip_prefix</b>                     string
       <b>nexthop</b>                       string
       <b>external_ids</b>                  map of string-string pairs

   <b>Details:</b>
       <b>datapath</b>: <b>Datapath_Binding</b>
              The datapath belonging to the <b>OVN_Northbound.Logical_Router</b> that this route is valid for.

       <b>logical_port</b>: <b>Port_Binding</b>
              This is the <b>Port_Binding</b> that the route was learned on.

       <b>ip_prefix</b>: string
              IP prefix of this route (e.g. 192.168.100.0/24).

       <b>nexthop</b>: string
              This is the nexthop ip we learned from outside of OVN.

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>ECMP_Nexthop</b> <b>TABLE</b></h4><pre>
       Each  record  in  this  table  represents   an   active   next-hop   for   ECMP   routes   created   with
       <b>--ecmp-symmetric-reply</b>   option  that  are  committed  by  <b>ovn-northd</b>  to  <b>ovs</b>  connection  tracker.  The
       <b>ECMP_Nexthop</b> table is used by <b>ovn-controller</b> to track active ct entries and to flush stale ones.

   <b>Summary:</b>
       <b>nexthop</b>                       string
       <b>port</b>                          <b>Port_Binding</b>
       <b>datapath</b>                      <b>Datapath_Binding</b>
       <b>mac</b>                           string
       <b>external_ids</b>                  map of string-string pairs

   <b>Details:</b>
       <b>nexthop</b>: string
              Nexthop IP address for this ECMP route. Nexthop IP address should be the IP address of a connected
              router port or the IP address of an external device used as nexthop for the given destination.

       <b>port</b>: <b>Port_Binding</b>
              The reference to <b>Port_Binding</b> table for the port used to connect to the configured next-hop.

       <b>datapath</b>: <b>Datapath_Binding</b>
              The reference to <b>Datapath_Binding</b> table for the datapath where the port used  to  connect  to  the
              configured next-hop is running.

       <b>mac</b>: string
              Nexthop mac address.

       <b>external_ids</b>: map of string-string pairs
              See <b>External</b> <b>IDs</b> at the beginning of this document.

</pre><h4><b>ACL_ID</b> <b>TABLE</b></h4><pre>
       Each   record   represents  an  identifier  that  <b>ovn-northd</b>  needs  to  synchronize  with  instances  of
       <b>ovn-controller</b>. The UUID of each record corresponds  directly  with  an  <b>ACL</b>  record  in  the  northbound
       database.

   <b>Summary:</b>
       <b>id</b>                            integer, in range 0 to 32,767

   <b>Details:</b>
       <b>id</b>: integer, in range 0 to 32,767
              An identifier corresponding to a northbound <b>allow-established</b> ACL.

Open vSwitch 25.03.0                            DB Schema 20.41.0                                      <u><a href="../man5/ovn-sb.5.html">ovn-sb</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>