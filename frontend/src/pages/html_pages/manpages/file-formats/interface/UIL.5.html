<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UIL — The user interface language file format "user interface language" "UIL"</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmotif-dev">libmotif-dev_2.3.8-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>UIL</b> — The user interface language file format "user interface language" "UIL"

</pre><h4><b>SYNOPSIS</b></h4><pre>
       MODULE <u>module_name</u>
       [ NAMES = CASE_INSENSITIVE | CASE_SENSITIVE ]
       [ CHARACTER_SET = character_set ]
       [ OBJECTS = { <u>widget_name</u> = GADGET | WIDGET; [...] } ]
       { [
       [ <u>value_section</u> ] |
       [ <u>procedure_section</u> ] |
       [ <u>list_section</u> ] |
       [ <u>object_section</u> ] |
       [ <u>identifier_section</u> ]
       [ ... ]
       ] }
       END MODULE;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  UIL  language  is  used  for  describing  the  initial  state of a user interface for a widget based
       application. UIL describes the widgets used in the interface, the resources of  those  widgets,  and  the
       callbacks  of  those  widgets.  The  UIL file is compiled into a UID file using the command <b>uil</b> or by the
       callable compiler <b>Uil()</b>. The contents of the compiled UID file can then be accessed by the various  Motif
       Resource Management (MRM) functions from within an application program.

       The  UID  file is independent of the platform on which the Motif program will eventually be run. In other
       words, the same UID file can be used on any system that can run Motif.

   <b>File</b>
       A UIL file consists of a single complete module, described in the syntax description above,  or,  if  the
       file  is  to  be included in a larger UIL file, one complete "section," as described below. UIL uses five
       different kinds of sections: value, procedure, list, object, and identifier.

       UIL is a free-form language. This means that high-level constructs such as object and value  declarations
       do not need to begin in any particular column and can span any number of lines. Low-level constructs such
       as  keywords and punctuation characters can also begin in any column; however, except for string literals
       and comments, they cannot span lines.

       The UIL compiler accepts input lines up to 132 characters in length.

       <b>MODULE</b> <u>module_name</u>
                 The name by which the UIL module is known in the UID file.  This name is stored in the UID file
                 for later use in the retrieval of resources  by  the  MRM.   This  name  is  always  stored  in
                 uppercase in the UID file.

       <b>NAMES</b> <b>=</b> <b>CASE_INSENSITIVE</b> | <b>CASE_SENSITIVE</b>
                 "UIL" "case sensitivity clause"

                 Indicates whether names should be treated as case sensitive or case insensitive. The default is
                 case  sensitive.   The case-sensitivity clause should be the first clause in the module header,
                 and in any case must precede any statement that contains a name.  If names are  case  sensitive
                 in  a  UIL module, UIL keywords in that module must be in lowercase. Each name is stored in the
                 UIL file in the same case as it appears in the UIL module.  If names are case insensitive, then
                 keywords can be in uppercase, lowercase, or mixed case, and the uppercase  equivalent  of  each
                 name is stored in the UID file.

       <b>CHARACTER_SET</b> <b>=</b> <b>character_set</b>
                 "UIL" "default character set clause"

                 Specifies  the  default  character set for string literals in the module that do not explicitly
                 set their character set.  The default character set, in the  absence  of  this  clause  is  the
                 codeset  component of the <b>LANG</b> environment variable, or the value of <b>XmFALLBACK_CHARSET</b> if <b>LANG</b>
                 is not set or has no codeset component.  The value of <b>XmFALLBACK_CHARSET</b> is defined by the  UIL
                 supplier,  but  is  usually ISO8859-1 (equivalent to ISO_LATIN1).  Use of this clause turns off
                 all  localized  string  literal  processing  turned  on  by  the  compiler  flag  <b>-s</b>   or   the
                 <b>Uil_command_type</b> data structure element <b>use_setlocale_flag</b>.

       <b>OBJECTS</b> <b>=</b> <b>{</b> <u>widget_name</u> = <b>GADGET</b> | <b>WIDGET;</b> <b>}</b>
                 "UIL" "objects clause"

                 Indicates  whether the widget or gadget form of the control specified by <u>widget_name</u> is used by
                 default.  By default the widget form is used, so the gadget keyword is  usually  the  only  one
                 used.   The  specified  control  should  be  one  that  has  both  a widget and gadget version:
                 XmCascadeButton, XmLabel, XmPushButton, XmSeparator, and XmToggleButton.  The form of more than
                 one control can be specified by delimiting them with semicolons.  The gadget or widget form  of
                 an  instance  of a control can be specified with the <b>GADGET</b> and <b>WIDGET</b> keywords in a particular
                 object declaration.

       <u>value_section</u>
                 Provides a way to name a value expression or literal.  The value name can then be  referred  to
                 by  declarations  that  occur  elsewhere  in the UIL module in any context where a value can be
                 used.  Values can be forward referenced.  Value sections are described in more detail later  in
                 the reference page.

       <u>procedure_section</u>
                 Defines  the  callback  routines  used  by  a widget and the creation routines for user-defined
                 widgets. These definitions are used for error checking.  Procedure sections  are  described  in
                 more detail later in the reference page.

       <u>list_section</u>
                 Provides  a  way  to  group  together  a  set  of arguments, controls (children), callbacks, or
                 procedures for later use in the UIL module.  Lists can contain other lists, so that you can set
                 up a hierarchy to clearly show which arguments, controls, callbacks, and procedures are  common
                 to which widgets.  List sections are described in more detail later in the reference page.

       <u>object_section</u>
                 Defines  the objects that make up the user interface of the application.  You can reference the
                 object names in declarations that occur elsewhere in the UIL module in  any  context  where  an
                 object  name  can be used (for example, in a controls list, as a symbolic reference to a widget
                 ID, or as the <u>tag_value</u> argument for a callback procedure).  Objects can be forward referenced.
                 Object sections are described in more detail later in the reference page.

       <u>identifier_section</u>
                 Defines a run-time binding of data to names that appear in the UIL module.  Identifier sections
                 are described in more detail later in the reference page.

       The UIL file can also contain comments and include directives, which are described along  with  the  main
       elements of the UIL file format in the following sections.

   <b>Comments</b>
       Comments can take one of two forms, as follows:

          •  The  comment  is introduced with the sequence <b>/*</b> followed by the text of the comment and terminated
             with the sequence <b>*/</b>.  This form of comment can span multiple source lines.

          •  The comment is introduced with an ! (exclamation point), followed by the text of  the  comment  and
             terminated by the end of the source line.

       Neither form of comment can be nested.

   <b>Value</b> <b>sections</b>
       "UIL"  "value  section"  A  value  section  consists of the keyword <b>VALUE</b> followed by a sequence of value
       declarations. It has the following syntax:

       <b>VALUE</b> <u>value_name</u> <b>:</b> [ <b>EXPORTED</b> | <b>PRIVATE</b> ] <u>value_expression</u> | <b>IMPORTED</b> <u>value_type</u> <b>;</b>

       Where <u>value_expression</u> is assigned to <u>value_name</u> or a <u>value_type</u> is assigned to an imported  value  name.
       A value declaration provides a way to name a value expression or literal.  The value name can be referred
       to  by  declarations that occur later in the UIL module in any context where a value can be used.  Values
       can be forward referenced.  "IMPORTED" "EXPORTED" "PRIVATE"

       <b>EXPORTED</b>  A value that you define as exported is stored  in  the  UID  file  as  a  named  resource,  and
                 therefore  can  be  referenced by name in other UID files. When you define a value as exported,
                 MRM looks outside the module in which the exported value is declared to get its  value  at  run
                 time.

       <b>PRIVATE</b>   A  private  value  is  a  value  that  is not imported or exported.  A value that you define as
                 private is not stored as a distinct resource in the UID file.   You  can  reference  a  private
                 value  only in the UIL module containing the value declaration. The value or object is directly
                 incorporated into anything in the UIL module that references the declaration.

       <b>IMPORTED</b>  A value that you define as imported is one that is defined as a named resource in a  UID  file.
                 MRM  resolves  this  declaration with the corresponding exported declaration at application run
                 time.

       By default, values and objects are private.  The following is a list of the supported value types in UIL:

          •  <b>ANY</b>

          •  <b>ARGUMENT</b>

          •  <b>BOOLEAN</b>

          •  <b>COLOR</b>

          •  <b>COLOR_TABLE</b>

          •  <b>COMPOUND_STRING</b>

          •  <b>FLOAT</b>

          •  <b>FONT</b>

          •  <b>FONT_TABLE</b>

          •  <b>FONTSET</b>

          •  <b>ICON</b>

          •  <b>INTEGER</b>

          •  <b>INTEGER_TABLE</b>

          •  <b>KEYSYM</b>

          •  <b>REASON</b>

          •  <b>SINGLE_FLOAT</b>

          •  <b>STRING</b>

          •  <b>STRING_TABLE</b>

          •  <b>TRANSLATION_TABLE</b>

          •  <b>WIDE_CHARACTER</b>

          •  <b>WIDGET</b>

   <b>Procedure</b> <b>sections</b>
       "UIL" "procedure section" A procedure section consists of the keyword <b>PROCEDURE</b> followed by a sequence of
       procedure declarations. It has the following syntax:

       PROCEDURE
            <u>procedure_name</u> [ ( [ <u>value_type</u> ]) ];

       "UIL" "procedure declaration" Use a procedure declaration to declare

          •  A routine that can be used as a callback routine for a widget

          •  The creation function for a user-defined widget

       You can reference a procedure name in declarations that occur later in the  UIL  module  in  any  context
       where  a  procedure can be used. Procedures can be forward referenced.  You cannot use a name you used in
       another context as a procedure name.

       In a procedure declaration, you have the option of specifying that a parameter  will  be  passed  to  the
       corresponding  callback  routine  at run time. This parameter is called the callback tag. You can specify
       the data type of the callback tag by putting the data type in parentheses following the  procedure  name.
       When  you  compile the module, the UIL compiler checks that the argument you specify in references to the
       procedure is of this type. Note that the data type of the callback tag must be one of the valid UIL  data
       types.   You  can  use  a  widget  as a callback tag, as long as the widget is defined in the same widget
       hierarchy as the callback, that is they have a common ancestor that is in the same UIL hierarchy.

       The following list summarizes how the UIL compiler checks argument type and argument count, depending  on
       the procedure declaration.

       No parameters
                 No  argument  type or argument count checking occurs.  You can supply either 0 or one arguments
                 in the procedure reference.

       <b>(</b> <b>)</b>       Checks that the argument count is 0 (zero).

       <b>(ANY)</b>     Checks that the argument count is 1. Does not check the argument type.  Use  the  <b>ANY</b>  type  to
                 prevent type checking on procedure tags.

       <b>(</b><u>type</u><b>)</b>    Checks for one argument of the specified type.

       <b>(class_name)</b>
                 Checks for one widget argument of the specified widget class.

       While  it  is  possible to use any UIL data type to specify the type of a tag in a procedure declaration,
       you must be able to represent that data type in the programming language you are using. Some  data  types
       (such  as  integer,  Boolean, and string) are common data types recognized by most programming languages.
       Other UIL data types (such as string tables) are more complicated and may require  that  you  set  up  an
       appropriate  corresponding  data  structure  in  the application in order to pass a tag of that type to a
       callback routine.

       You can also use a procedure declaration to specify the creation function for a user-defined  widget.  In
       this  case, you specify no formal parameters.  The procedure is invoked with the standard three arguments
       passed to all widget creation functions.  (See the Motif Toolkit documentation for more information about
       widget creation functions.)

   <b>List</b> <b>sections</b>
       "UIL" "list section" A list section consists  of  the  keyword  <b>LIST</b>  followed  by  a  sequence  of  list
       declarations. It has the following syntax:

       LIST
            <u>list_name</u>: { list_item; [...] }
            [...]

       You  can  also use list sections to group together a set of arguments, controls (children), callbacks, or
       procedures for later use in the UIL module. Lists can contain other lists, so  that  you  can  set  up  a
       hierarchy  to  clearly  show  which  arguments,  controls,  callbacks, and procedures are common to which
       widgets.  You cannot mix the different types of lists; a list of a particular type cannot contain entries
       of a different list type or reference the name of a different list type.  A list name is  always  private
       to the UIL module in which you declare the list and cannot be stored as a named resource in a UID file.

       The additional list types are described in the following sections.

       <b>Arguments</b> <b>List</b> <b>Structure</b>

       "List  types"  "argument"  "UIL"  "arguments  list"  An  arguments list defines which arguments are to be
       specified in the arguments list parameter when the creation routine for a particular object is called  at
       run  time.   An  arguments  list  also specifies the values for those arguments.  Argument lists have the
       following syntax:

       LIST
            <u>list_name</u>: ARGUMENTS {
                 <u>argument_name</u> = <u>value_expression</u>;
                 [...] }
       [...]

       The argument name must be either a built-in argument  name  or  a  user-defined  argument  name  that  is
       specified with the <b>ARGUMENT</b> function.

       If  you use a built-in argument name as an arguments list entry in an object definition, the UIL compiler
       checks the argument name to be sure that it is supported by the type of object that you are defining.  If
       the  same  argument  name appears more than once in a given arguments list, the last entry that uses that
       argument name supersedes all previous entries with that name, and the compiler issues a message.

       Some arguments, such as <b>XmNitems</b> and <b>XmNitemCount</b>, are coupled by the UIL compiler.  When you specify one
       of the arguments, the compiler also sets the other. The coupled argument is not available to you.   "UIL"
       "coupled arguments" "Arguments" "coupled in UIL"

       The  Motif Toolkit and the X Toolkit (intrinsics) support constraint arguments.  A constraint argument is
       one that is passed to children of an object, beyond those arguments normally available.  For example, the
       Form widget grants a set of constraint arguments to its children.  These arguments control  the  position
       of the children within the Form.

       Unlike  the arguments used to define the attributes of a particular widget, constraint arguments are used
       exclusively to define additional attributes of the children of a  particular  widget.   These  attributes
       affect the behavior of the children within their parent.  To supply constraint arguments to the children,
       you include the arguments in the arguments list for the child.

       See  <b>Appendix</b>  <b>B</b> for information about which arguments are supported by which widgets. See <b>Appendix</b> <b>C</b> for
       information about what the valid value type is for each built-in argument.

       <b>Callbacks</b> <b>List</b> <b>Structure</b> "UIL" "callbacks list" "List types" "callback"

       Use a callbacks list to define which callback reasons are to be processed by a particular widget  at  run
       time.  Callback lists have the following syntax:

       <b>LIST</b>  <u>list_name</u>  <b>:</b>  <b>CALLBACKS</b>  <b>{</b>  <u>reason_name</u>  <b>=</b> <b>PROCEDURE</b> <u>procedure_name</u> <b>[</b> <b>(</b> [ <u>value_expression</u> ] <b>)</b> ]<b>;</b> |
       <u>reason_name</u> <b>=</b> <u>procedure_list</u> <b>;</b> [...] <b>}</b> [...]

       For Motif Toolkit widgets, the reason name must be a built-in reason name. For a user-defined widget, you
       can use a reason name that you previously specified using the <b>REASON</b> function.  If  you  use  a  built-in
       reason  in  an object definition, the UIL compiler ensures that reason is supported by the type of object
       you are defining. Appendix B shows which reasons each object supports.

       If the same reason appears more than once in a callbacks list, the last  entry  referring  to  that  name
       supersedes all previous entries using the same reason, and the UIL compiler issues a diagnostic message.

       If  you  specify a named value for the procedure argument (callback tag), the data type of the value must
       match the type specified  for  the  callback  tag  in  the  corresponding  procedure  declaration.   When
       specifying a widget name as a procedure value expression you must also specify the type of the widget and
       a space before the name of the widget.

       Because  the  UIL  compiler produces a UID file rather than an object module (.o), the binding of the UIL
       name to the address of the entry point to the procedure is not done by the loader, but is established  at
       run  time  with  the  MRM function <b>MrmRegisterNames</b>.  You call this function before fetching any objects,
       giving it both the UIL names and the procedure addresses of each callback. The name you register with MRM
       in the application program must match the name you specified for the procedure in the UIL module.

       Each callback procedure receives three arguments. The first two arguments have the  same  form  for  each
       callback. The form of the third argument varies from object to object.

       The  first  argument is the address of the data structure maintained by the Motif Toolkit for this object
       instance. This address is called the widget ID for this object.

       The second argument is the address of the value you specified in the callbacks list for  this  procedure.
       If  you  do  not  specify  an  argument, the address is NULL.  Note that, in the case where the value you
       specified is a string or an <b>XmString</b>, the value specified in the callbacks  list  already  represents  an
       address  rather  than  an  actual  value.  In  the case of a simple string, for example, the value is the
       address of the first character of that string. In these cases, UIL does not add a level  of  indirection,
       and the second argument to the callback procedure is simply the value as specified in the callbacks list.

       The third argument is the reason name you specified in the callbacks list.

       <b>Controls</b> <b>List</b> <b>Structure</b>

       "UIL"  "controls  list"  A  controls  list  defines  which  objects  are children of, or controlled by, a
       particular object.  Each entry in a controls list has the following syntax:

       LIST
            <u>list_name</u>: CONTROLS {
                 [<u>child_name</u>: ] [MANAGED | UNMANAGED] <u>object_definition</u>;
                 [...] }
            [...]

       If you specify the keyword <b>MANAGED</b> at run time, the  object  is  created  and  managed;  if  you  specify
       <b>UNMANAGED</b> at run time, the object is only created.  Objects are managed by default.

       You  can  use  <u>child_name</u>  to  specify  resources  for the automatically created children of a particular
       control. Names for automatically created children are formed by appending <b>Xm_</b> to the name  of  the  child
       widget.  This name is specified in the documentation for the parent widget.

       Unlike  the  arguments list and the callbacks list, a controls list entry that is identical to a previous
       entry does not supersede the previous entry. At run time, each controls list entry causes a child  to  be
       created when the parent is created. If the same object definition is used for multiple children, multiple
       instances  of  the child are created at run time.  See <b>Appendix</b> <b>B</b> for a list of which widget types can be
       controlled by which other widget types.

       <b>Procedures</b> <b>List</b> <b>Structure</b>

       You can specify multiple procedures for a callback reason in UIL by defining a procedures list.  Just  as
       with  other  list  types,  procedures lists can be defined in-line or in a list section and referenced by
       name.

       If you define a reason more than once (for example, when the reason  is  defined  both  in  a  referenced
       procedures  list  and  in  the callbacks list for the object), previous definitions are overridden by the
       latest definition.  The syntax for a procedures list is as follows:

       LIST
            <u>list_name</u>: PROCEDURES {
                 <u>procedure_name</u> [ ( [ <u>value_expression</u> ]) ];
                 [...] }
            [...]

       When specifying a widget name as a procedure value expression you must  also  specify  the  type  of  the
       widget and a space before the name of the widget.

   <b>Object</b> <b>Sections</b>
       "UIL"  "object section" An object section consists of the keyword <b>OBJECT</b> followed by a sequence of object
       declarations. It has the following syntax:

       OBJECT <u>object_name</u>:
            [ EXPORTED | PRIVATE | IMPORTED ] <u>object_type</u>
                 [ PROCEDURE <u>creation_function</u> ]
                 [ <u>object_name</u> [ WIDGET | GADGET ] | {<u>list_definitions</u> } ]

       "UIL" "object declaration" Use an object declaration to define the objects that are to be stored  in  the
       UID file. You can reference the object name in declarations that occur elsewhere in the UIL module in any
       context  where  an object name can be used (for example, in a controls list, as a symbolic reference to a
       widget ID, or as the <u>tag_value</u> argument for a callback procedure).  Objects can  be  forward  referenced;
       that  is, you can declare an object name after you reference it. All references to an object name must be
       consistent with the type of the object, as specified in the  object  declaration.   You  can  specify  an
       object as exported, imported, or private.

       The object definition can contain a sequence of lists that define the arguments, hierarchy, and callbacks
       for  the  widget.   You  can  specify only one list of each type for an object.  When you declare a user-
       defined widget, you must include a reference to the widget creation function for the user-defined widget.

       Note: Several widgets in the  Motif  Toolkit  actually  consist  of  two  linked  widgets.  For  example,
       <b>XmScrolledText</b>   and  <b>XmScrolledList</b>  each  consist  of  children  <b>XmText</b>  and  <b>XmList</b>  widgets  under  a
       <b>XmScrolledWindow</b> widget. When such a widget is created, its  resources  are  available  to  both  of  the
       underlying   widgets.   This   can   occasionally   cause  problems,  as  when  the  programmer  wants  a
       <b>XmNdestroyCallback</b> routine named to act when the widget is destroyed. In this case, the callback resource
       will be available to both sub-widgets, and will cause an error when the widget  is  destroyed.  To  avoid
       these problems, the programmer should separately create the parent and child widgets, rather than relying
       on these linked widgets.

       Use  the  <b>GADGET</b> or <b>WIDGET</b> keyword to specify the object type or to override the default variant for this
       object type.  You can use the Motif Toolkit name of an  object  type  that  has  a  gadget  variant  (for
       example,  <b>XmLabelGadget</b>)  as  an  attribute  of an object declaration.  The <u>object_type</u> can be any object
       type, including gadgets.  You need to specify the <b>GADGET</b> or <b>WIDGET</b> keyword only in the declaration of  an
       object,  not  when  you reference the object. You cannot specify the <b>GADGET</b> or <b>WIDGET</b> keyword for a user-
       defined object; user-defined objects are always widgets.

   <b>Identifier</b> <b>sections</b>
       "UIL" "identifiers" The identifier section allows you to define an identifier, a mechanism that  achieves
       run-time  binding  of  data to names that appear in a UIL module.  The identifier section consists of the
       reserved keyword <b>IDENTIFIER</b>, followed by a list of names, each name followed by a semicolon.

       <b>IDENTIFIER</b> <u>identifier_name</u><b>;</b> [...<b>;</b>]

       You can later use these names in the UIL module as either the value of an argument to a widget or the tag
       value  to  a  callback  procedure.  At  run  time,  you  use  the  MRM  functions  <b>MrmRegisterNames</b>   and
       <b>MrmRegisterNamesInHierarchy</b> to bind the identifier name with the data (or, in the case of callbacks, with
       the address of the data) associated with the identifier.

       Each  UIL  module has a single name space; therefore, you cannot use a name you used for a value, object,
       or procedure as an identifier name in the same module.

       The UIL compiler does not do any type checking on the use of identifiers in a UIL module.  Unlike  a  UIL
       value,  an  identifier  does not have a UIL type associated with it. Regardless of what particular type a
       widget argument or callback procedure tag is defined to be, you can use an  identifier  in  that  context
       instead of a value of the corresponding type.

       To reference these identifier names in a UIL module, you use the name of the identifier wherever you want
       its value to be used.

   <b>Include</b> <b>directives</b>
       "UIL"  "include directive" The include directive incorporates the contents of a specified file into a UIL
       module. This mechanism allows several UIL modules to share common definitions. The syntax for the include
       directive is as follows:

       INCLUDE FILE <u>file_name</u>;

       The UIL compiler replaces the include directive with the contents of the include file and processes it as
       if these contents had appeared in the current UIL source file.

       You can nest include files; that is, an include file can contain include directives.   The  UIL  compiler
       can  process  up  to  100  references  (including the file containing the UIL module). Therefore, you can
       include up to 99 files in a single UIL module, including nested files. Each time a file is opened  counts
       as a reference, so including the same file twice counts as two references.

       The <u>file_name</u> is a simple string containing a file specification that identifies the file to be included.
       The  rules  for finding the specified file are similar to the rules for finding header, or <b>.h</b> files using
       the include directive, <b>#include</b>, with a quoted string in C. The UIL uses the <b>-I</b> <b>option</b> <b>for</b>  <b>specifying</b>  <b>a</b>
       <b>search</b> <b>directory</b> <b>for</b> <b>include</b> <b>files.</b>

          •  If  you  do not supply a directory, the UIL compiler searches for the include file in the directory
             of the main source file.

          •  If the compiler does not find the include file there, the compiler looks in the same  directory  as
             the source file.

          •  If you supply a directory, the UIL compiler searches only that directory for the file.

   <b>Names</b> <b>and</b> <b>Strings</b>
       Names  can  consist of any of the characters A to Z, a to z, 0 to 9, $ (dollar sign), and _ (underscore).
       Names cannot begin with a digit (0 to 9). The maximum length of a name is 31 characters.

       UIL gives you a choice of either case-sensitive or case-insensitive names through a clause in the  <b>MODULE</b>
       header.  For example, if names are case sensitive, the names "sample" and "Sample" are distinct from each
       other.  If  names  are  case  insensitive,  these  names  are  treated  as  the same name and can be used
       interchangeably. By default, UIL assumes names are case sensitive.

       In <b>CASE-INSENSITIVE</b> mode, the compiler outputs all names in the UID file in  uppercase  form.   In  <b>CASE-</b>
       <b>SENSITIVE</b> mode, names appear in the UIL file exactly as they appear in the source.

       The  following table lists the reserved keywords, which are not available for defining programmer defined
       names.  "UIL" "keywords" "UIL module" "keywords" "UIL specification file" "keywords" "Keywords"
       ┌────────────────────────────────────────────────┐
       │               <b>Reserved</b> <b>Keywords</b>                │
       ├────────────────────────────────────────────────┤
       │ ARGUMENTS    CALLBACKS   CONTROLS   END        │
       │ EXPORTED     FALSE       GADGET     IDENTIFIER │
       │ INCLUDE      LIST        MODULE     OFF        │
       │ ON           OBJECT      PRIVATE    PROCEDURE  │
       │ PROCEDURES   TRUE        VALUE      WIDGET     │
       └────────────────────────────────────────────────┘

       The UIL unreserved keywords are described in the following list and table.  These keywords can be used as
       programmer defined names, however, if you use any keyword as a name,  you  cannot  use  the  UIL-supplied
       usage of that keyword.

          •  Built-in argument names (for example, <b>XmNx</b>, <b>XmNheight</b>)

          •  Built-in reason names (for example, <b>XmNactivateCallback</b>, <b>XmNhelpCallback</b>)

          •  Character set names (for example, <b>ISO_LATIN1</b>, <b>ISO_HEBREW_LR</b>)

          •  Constant value names (for example, <b>XmMENU_OPTION</b>, <b>XmBROWSE_SELECT</b>)

          •  Object types (for example, <b>XmPushButton</b>, <b>XmBulletinBoard</b>)
             ┌────────────────────────────────────────────────────────────────────────┐
             │                          <b>Unreserved</b> <b>Keywords</b>                           │
             ├────────────────────────────────────────────────────────────────────────┤
             │ ANY                         ARGUMENT                ASCIZ_STRING_TABLE │
             │ ASCIZ_TABLE                 BACKGROUND              BOOLEAN            │
             │ CASE_INSENSITIVE            CASE_SENSITIVE          CHARACTER_SET      │
             │ COLOR                       COLOR_TABLE             COMPOUND_STRING    │
             │ COMPOUND_STRING_COMPONENT   COMPOUND_STRING_TABLE   FILE               │
             │ FLOAT                       FONT                    FONT_TABLE         │
             │ FONTSET                     FOREGROUND              ICON               │
             │ IMPORTED                    INTEGER                 INTEGER_TABLE      │
             │ KEYSYM                      MANAGED                 NAMES              │
             │ OBJECTS                     REASON                  RGB                │
             │ RIGHT_TO_LEFT               SINGLE_FLOAT            STRING             │
             │ STRING_TABLE                TRANSLATION_TABLE       UNMANAGED          │
             │ USER_DEFINED                VERSION                 WIDE_CHARACTER     │
             │ WIDGET                      XBITMAPFILE                                │
             └────────────────────────────────────────────────────────────────────────┘

       String  literals  can  be  composed  of  the  uppercase  and  lowercase  letters, digits, and punctuation
       characters.  Spaces, tabs, and comments are special elements  in  the  language.  They  are  a  means  of
       delimiting  other  elements,  such as two names. One or more of these elements can appear before or after
       any other element in the language.  However, spaces, tabs, and comments that appear  in  string  literals
       are treated as character sequences rather than delimiters.

   <b>Data</b> <b>Types</b>
       "UIL" "literals" "UIL module" "literals" "UIL specification file" "literals" "Values" "literals"

       UIL  provides  literals  for  several  of  the  value  types it supports. Some of the value types are not
       supported as literals (for example, pixmaps and string tables). You can specify values for these types by
       using functions described in the <u>Functions</u> section.  UIL directly supports the following literal types:

          •  String literal

          •  Integer literal

          •  Boolean literal

          •  Floating-point literal

       UIL also includes the data type <b>ANY</b>, which is used to turn off compile time checking of data types.

   <b>String</b> <b>Literals</b>
       "UIL" "string literals" "UIL  module"  "string  literals"  "UIL  specification  file"  "string  literals"
       "Values" "string literals"

       A string literal is a sequence of zero or more 8-bit or 16-bit characters or a combination delimited by <b>'</b>
       (single  quotation  marks)  or  <b>"</b>  (double  quotation marks).  String literals can also contain multibyte
       characters delimited with double quotation marks.  String literals can be no more  than  2000  characters
       long.

       A  single-quoted  string  literal  can  span  multiple  source  lines. To continue a single-quoted string
       literal, terminate the continued line with  a  <b>\</b>  (backslash).  The  literal  continues  with  the  first
       character on the next line.

       Double-quoted  string  literals  cannot  span  multiple source lines.  (Because double-quoted strings can
       contain escape sequences and other  special  characters,  you  cannot  use  the  backslash  character  to
       designate  continuation of the string.) To build a string value that must span multiple source lines, use
       the concatenation operator described later in this section.

       The syntax of a string literal is one of the following:

       '[<u>character_string</u>]'
       [#<u>char_set</u>]"[<u>character_string</u>]"

       Both string forms associate a character set with a  string  value.   UIL  uses  the  following  rules  to
       determine the character set and storage format for string literals:

          •  A  string declared as <b>'</b><u>string</u><b>'</b> is equivalent to <b>#</b><u>cur_charset</u><b>"</b><u>string</u><b>"</b>, where <u>cur_charset</u> will be the
             codeset portion of the value of the <b>LANG</b> environment  variable  if  it  is  set  or  the  value  of
             <b>XmFALLBACK_CHARSET</b>  if <b>LANG</b> is not set or has no codeset component.  By default, <b>XmFALLBACK_CHARSET</b>
             is <b>ISO8859-1</b> (equivalent to <b>ISO_LATIN1</b>), but vendors may define a different default.

          •  A string declared as <b>"</b><u>string</u><b>"</b> is equivalent to <b>#</b><u>char_set</u><b>"</b><u>string</u><b>"</b> if you specified <u>char_set</u>  as  the
             default  character  set  for  the  module.   If no default character set has been specified for the
             module, then if the <b>-s</b> option is provided to the <b>uil</b> command or the <b>use_setlocale_flag</b> is  set  for
             the  callable compiler, <b>Uil()</b>, the string will be interpreted to be a string in the current locale.
             This means that the string is parsed in the locale of the user by calling <u>setlocale</u>, its charset is
             <b>XmFONTLIST_DEFAULT_TAG</b>, and that if the string is converted to a compound string, it is stored as a
             locale encoded text segment.  Otherwise, <b>"</b><u>string</u><b>"</b>  is  equivalent  to  <b>#</b><u>cur_charset</u><b>"</b><u>string</u><b>"</b>,  where
             <u>cur_charset</u> is interpreted as described for single quoted strings.

          •  A string of the form <b>"</b><u>string</u><b>"</b> or <b>#</b><u>char_set</u><b>"</b><u>string</u><b>"</b> is stored as a null-terminated string.

       If  the  <u>char_set</u>  in  a string specified in the form above is not a built-in charset, and is not a user-
       defined charset, the charset of the string will be set to <b>XmFONTLIST_DEFAULT_TAG</b>,  and  an  informational
       message will be issued to the user to note that this substitution has been made.

       The  following  table  lists  the character sets supported by the UIL compiler for string literals.  Note
       that several UIL names map to the same character set. In some cases, the UIL name influences  how  string
       literals  are  read.  For  example, strings identified by a UIL character set name ending in <b>_LR</b> are read
       left-to-right.  Names that end in a different number reflect different fonts (for example, ISO_LATIN1  or
       ISO_LATIN6).  All character sets in this table are represented by 8 bits.
       ┌───────────────────────────────────────────────────────┐
       │               <b>Supported</b> <b>Character</b> <b>Sets</b>                │
       ├───────────────────────────────────────────────────────┤
       │ <b>UIL</b> <b>Name</b>        <b>Description</b>                           │
       ├───────────────────────────────────────────────────────┤
       │ <b>ISO_LATIN1</b>      GL: ASCII, GR: Latin-1 Supplement     │
       │ <b>ISO_LATIN2</b>      GL: ASCII, GR: Latin-2 Supplement     │
       │ <b>ISO_ARABIC</b>      GL:     ASCII,    GR:    Latin-Arabic │
       │                 Supplement                            │
       │ <b>ISO_LATIN6</b>      GL:    ASCII,    GR:     Latin-Arabic │
       │                 Supplement                            │
       │ <b>ISO_GREEK</b>       GL: ASCII, GR: Latin-Greek Supplement │
       │ <b>ISO_LATIN7</b>      GL: ASCII, GR: Latin-Greek Supplement │
       │ <b>ISO_HEBREW</b>      GL:     ASCII,    GR:    Latin-Hebrew │
       │                 Supplement                            │
       │ <b>ISO_LATIN8</b>      GL:    ASCII,    GR:     Latin-Hebrew │
       │                 Supplement                            │
       │ <b>ISO_HEBREW_LR</b>   GL:     ASCII,    GR:    Latin-Hebrew │
       │                 Supplement                            │
       │ <b>ISO_LATIN8_LR</b>   GL:    ASCII,    GR:     Latin-Hebrew │
       │                 Supplement                            │
       │ <b>JIS_KATAKANA</b>    GL: JIS Roman, GR: JIS Katakana       │
       └───────────────────────────────────────────────────────┘

       Following are the parsing rules for each of the character sets:

       All character sets
                 Character  codes  in  the  range 00...1F, 7F, and 80...9F are control characters including both
                 bytes of 16-bit characters.  The compiler flags these as illegal characters.

       <b>ISO_LATIN1</b> <b>ISO_LATIN2</b> <b>ISO_LATIN3</b> <b>ISO_GREEK</b> <b>ISO_LATIN4</b>
                 These sets are parsed from left to right.  The escape sequences for null-terminated strings are
                 also supported by these character sets.

       <b>ISO_HEBREW</b> <b>ISO_ARABIC</b> <b>ISO_LATIN8</b>
                 These sets are parsed from right to left. For  example,  the  string  #ISO_HEBREW"012345"  will
                 generate a primitive string of "543210" with character set <b>ISO_HEBREW</b>. The string direction for
                 such a string would be right-to-left, so when rendered, the string will appear as "012345." The
                 escape  sequences  for  null-terminated strings are also supported by these character sets, and
                 the characters that compose the escape sequences are in left-to-right order. For  example,  you
                 would enter \n, not n\.

       <b>ISO_HEBREW_LR</b> <b>ISO_ARABIC_LR</b> <b>ISO_LATIN8_LR</b>
                 These  sets  are  parsed  from  left  to  right. For example, the string #ISO_HEBREW_LR"012345"
                 generates a primitive string "012345" with character set <b>ISO_HEBREW</b>. The string  direction  for
                 such  a  string  would  still  be  right-to-left,  however, so when rendered, it will appear as
                 "543210." In other words, the characters were originally typed in the <u>same</u> <u>order</u> in which  they
                 would  have  been  typed in Hebrew (although in Hebrew, the typist would have been using a text
                 editor that went from right to left). The escape sequences for null-terminated strings are also
                 supported by these character sets.

       <b>JIS_KATAKANA</b>
                 This set is parsed from left to right. The escape sequences  for  null-terminated  strings  are
                 also  supported  by  this  character set. Note that the <b>\</b> (backslash) may be displayed as a yen
                 symbol.

       In addition to designating parsing rules for strings, character set information remains an attribute of a
       compound string.  If the string is included in a string consisting of several concatenated segments,  the
       character  set  information  is  included  with  that  string  segment.  This gives the Motif Toolkit the
       information it needs to decipher the compound string and choose a font to display the string.

       For an application interface displayed only in English, UIL lets you ignore the distinctions between  the
       two  uses  of  strings.   The  compiler  recognizes  by  context  when a string must be passed as a null-
       terminated string or as a compound string.

       The UIL compiler recognizes enough about the various character sets to correctly parse  string  literals.
       The  compiler  also  issues  errors  if  you  use a compound string in a context that supports only null-
       terminated strings.

       Since the character set names are keywords, you must put them in lowercase if case-sensitive names are in
       force.  If names are case insensitive, character set names can be uppercase, lowercase, or mixed case.

       In addition to the built-in character sets recognized by UIL, you can define your own character sets with
       the <b>CHARACTER_SET</b> function. You can use the <b>CHARACTER_SET</b>  function  anywhere  a  character  set  can  be
       specified.

       String  literals  can  contain  characters  with the eighth (high-order) bit set. You cannot type control
       characters (00-1F, 7F, and 80-9F) directly in a single-quoted string literal. However, you can  represent
       these  characters  with  escape  sequences.  The  following  list  shows the escape sequences for special
       characters.  "UIL" "escape sequences" "Escape sequences"

       <b>\b</b>        Backspace

       <b>\f</b>        Form-feed

       <b>\n</b>        Newline

       <b>\r</b>        Carriage return

       <b>\t</b>        Horizontal tab

       <b>\v</b>        Vertical tab

       <b>\'</b>        Single quotation mark

       <b>\"</b>        Double quotation mark

       <b>\\</b>        Backslash

       <b>\</b><u>integer</u><b>\</b> Character whose internal representation is given by <u>integer</u> (in the range 0 to 255 decimal)

       Note that escape sequences are processed literally in strings that  are  parsed  in  the  current  locale
       (localized strings).

       The  UIL  compiler  does  not  process  newline  characters in compound strings.  The effect of a newline
       character in a compound string depends only on the character set of the string, and  the  result  is  not
       guaranteed to be a multiline string.

       <b>Compound</b> <b>String</b> <b>Literals</b>

       A  compound string consists of a string of 8-bit, 16-bit, or multibyte characters, a named character set,
       and a writing direction. Its UIL data type is <b>compound_string</b>.

       The writing direction of a compound string is implied by the character set specified for the string.  You
       can explicitly set the writing direction for a compound string by using the <b>COMPOUND_STRING</b> function.

       A compound string can consist of a sequence of concatenated compound strings, null-terminated strings, or
       a  combination  of both, each of which can have a different character set property and writing direction.
       Use the concatenation operator &amp; (ampersand) to create a sequence of compound strings.

       Each string in the sequence is stored, including the character set and writing direction information.

       Generally, a string literal is stored in the UID file as a compound string when the literal  consists  of
       concatenated strings having different character sets or writing directions, or when you use the string to
       specify  a  value  for an argument that requires a compound string value. If you want to guarantee that a
       string literal is stored as a compound string, you must use the <b>COMPOUND_STRING</b> function.

       <b>Data</b> <b>Storage</b> <b>Consumption</b> <b>for</b> <b>String</b> <b>Literals</b>

       The way a string literal is stored in the UID file depends on how you declare and use the string. The UIL
       compiler automatically converts a null-terminated string to a compound string if you use  the  string  to
       specify  the value of an argument that requires a compound string.  However, this conversion is costly in
       terms of storage consumption.

       <b>PRIVATE</b>, <b>EXPORTED</b>, and <b>IMPORTED</b> string literals require storage for a single allocation when the  literal
       is declared; thereafter, storage is required for each reference to the literal. Literals declared in-line
       require storage for both an allocation and a reference.

       The  following table summarizes data storage consumption for string literals. The storage requirement for
       an allocation consists of a fixed portion and a variable portion. The fixed portion of an  allocation  is
       roughly  the  same as the storage requirement for a reference (a few bytes).  The storage consumed by the
       variable portion depends on the size of the literal value  (that  is,  the  length  of  the  string).  To
       conserve storage space, avoid making string literal declarations that result in an allocation per use.
       ┌──────────────────────────────────────────────┐
--
</pre><h4><b>RELATED</b> <b>INFORMATION</b></h4><pre>
       <b><a href="../man1/uil.1.html">uil</a></b>(1), <b><a href="../man3/Uil.3.html">Uil</a></b>(3)

                                                                                                          <u><a href="../man5/UIL.5.html">UIL</a></u>(5)
</pre>
 </div>
</div></section>
</div>
</body>
</html>