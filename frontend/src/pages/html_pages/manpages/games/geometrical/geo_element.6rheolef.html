<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>geo_element - geometrical element of a mesh (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       geo_element - geometrical element of a mesh (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class defines a geometrical element. This element is obtained after the Piola geometrical
       transformation from a <b><a href="../man6/reference_element.6.html">reference_element</a>(6)</b>. The <b>geo_element</b> is mainly an array of indices for its nodes.
       These indices refer to the node table of the <b><a href="../man2/geo.2.html">geo</a>(2)</b> class. In addition, this class provides a list of
       indexes for edges (in 2D and 3D) and faces (in 3D). These indices refer to the edge and face lists,
       respectively, of the <b><a href="../man2/geo.2.html">geo</a>(2)</b> class.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file fem/geo_element/geo_element.h

       class geo_element {
       public:

       // typedefs:

         enum {
               _variant_offset    = 0, // i.e. type, as triangle(t) or tetra(T), etc
               _order_offset      = 1, // i.e. k, when Pk curved element
               _dis_ie_offset     = 2, // internal numbering, depend upon partitionand nproc
               _ios_dis_ie_offset = 3, // i/o numbering, independent of parition and nproc
               _master_offset     = 4, // (d-1)-side has one or two master d-element that contains it
               _last_offset       = 6  // here starts node indexes, face indexes, etc
         };
         // Implementation note: _master_offset  reserve 2 size_type but is used only for sides,
         // i.e. tri or quad in 3d mesh, edge in 2d mesh, or point in 1d
         // =&gt; waste a lot of place
         // it would be better with a polymorphic class
         // and the geo class would define an array of smart_pointers on this class
         // so, we could define edge with or without the 2 size_type for master elements
         // then, hack_array will become obsolete (good thing)
         // and reference_element could be also polymorphic, avoiding large swich (variant)
         // in all internal loops. This change of implementation will be considered
         // in the future.
         typedef reference_element::size_type    size_type;
         typedef reference_element::variant_type variant_type;
         typedef size_type*                         iterator;
         typedef const size_type*                   const_iterator;
         typedef size_type                          raw_type;

         typedef geo_element                                  generic_type;
         typedef geo_element_auto&lt;heap_allocator&lt;size_type&gt; &gt; automatic_type;

         typedef geo_element_indirect::orientation_type orientation_type; // for sign (+1,-1)
         typedef geo_element_indirect::shift_type       shift_type;       // for 0..3 face shift
         struct  parameter_type {
           variant_type variant;
           size_type    order;
           parameter_type (variant_type v = reference_element::max_variant, size_type o = 0)
             : variant(v), order(o) {}
         };

       // affectation:

         geo_element&amp; operator= (const geo_element&amp; K)
         {
           reset (K.variant(), K.order()); // resize auto, nothing for hack
           std::copy (K._data_begin(), K._data_begin() + _data_size(), _data_begin());
           reset (K.variant(), K.order()); // reset order=1 for hack, resize nothing for auto
           return *this;
         }
         virtual ~geo_element() {}
         virtual void reset (variant_type variant, size_type order) = 0;

       // implicit conversion:

         operator reference_element () const { return reference_element(variant()); }

       // accessors &amp; modifiers:

         variant_type variant()    const { return variant_type( *(_data_begin() +  _variant_offset)); }
         size_type order()         const { return *(_data_begin() + _order_offset); }
         size_type dis_ie()        const { return *(_data_begin() + _dis_ie_offset); }
         size_type ios_dis_ie()    const { return *(_data_begin() + _ios_dis_ie_offset); }
         size_type master (bool i) const { return *(_data_begin() + _master_offset + i); }

         size_type dimension()  const { return reference_element::dimension (variant()); }
         size_type size()       const { return reference_element::n_vertex (variant()); }
         char      name()       const { return reference_element::name     (variant()); }
         size_type n_node()     const { return reference_element::n_node (variant(), order()); }

         void set_dis_ie         (size_type dis_ie) { *(_data_begin() + _dis_ie_offset)     = dis_ie; }
         void set_ios_dis_ie (size_type ios_dis_ie) { *(_data_begin() + _ios_dis_ie_offset) = ios_dis_ie; }
         void set_master (bool i, size_type dis_ie) const {
           const_iterator p = _data_begin() + _master_offset + i; // mutable member fct
           *(const_cast&lt;iterator&gt;(p)) = dis_ie;
         }

         iterator       begin()       { return _data_begin() +  _node_offset (variant(), order()); }
         const_iterator begin() const { return _data_begin() +  _node_offset (variant(), order()); }
         iterator       end()         { return begin() + size(); }
         const_iterator end()   const { return begin() + size(); }
         size_type&amp; operator[] (size_type loc_inod)       { return *(begin() + loc_inod); }
         size_type  operator[] (size_type loc_inod) const { return *(begin() + loc_inod); }
         size_type&amp; node       (size_type loc_inod)       { return operator[] (loc_inod); }
         size_type  node       (size_type loc_inod) const { return operator[] (loc_inod); }

         iterator       begin(size_type node_subgeo_dim)       { return begin() + first_inod (node_subgeo_dim); }
         const_iterator begin(size_type node_subgeo_dim) const { return begin() + first_inod (node_subgeo_dim); }
         iterator       end  (size_type node_subgeo_dim)       { return begin() +  last_inod (node_subgeo_dim); }
         const_iterator end  (size_type node_subgeo_dim) const { return begin() +  last_inod (node_subgeo_dim); }

         const geo_element_indirect&amp;  edge_indirect (size_type i) const {
           const_iterator p = _data_begin() +  _edge_offset (variant(), order()) + i;
           return *(reinterpret_cast&lt;const geo_element_indirect*&gt;(p));
         }
         const geo_element_indirect&amp;  face_indirect (size_type i) const {
           const_iterator p = _data_begin() +  _face_offset (variant(), order()) + i;
           return *(reinterpret_cast&lt;const geo_element_indirect*&gt;(p));
         }
         geo_element_indirect&amp;  edge_indirect (size_type i)       {
           iterator p = _data_begin() +  _edge_offset (variant(), order()) + i;
           return *(reinterpret_cast&lt;geo_element_indirect*&gt;(p));
         }
         geo_element_indirect&amp;  face_indirect (size_type i)       {
           iterator p = _data_begin() +  _face_offset (variant(), order()) + i;
           return *(reinterpret_cast&lt;geo_element_indirect*&gt;(p));
         }
         size_type edge (size_type i) const { return (dimension() &lt;= 1) ? dis_ie() : edge_indirect(i).index(); }
         size_type face (size_type i) const { return (dimension() &lt;= 2) ? dis_ie() : face_indirect(i).index(); }

         size_type n_subgeo (size_type subgeo_dim) const {
            return reference_element::n_subgeo (variant(), subgeo_dim); }
         size_type subgeo_dis_index (size_type subgeo_dim, size_type i) const {
           return (subgeo_dim == 0) ? operator[](i) : (subgeo_dim == 1) ? edge(i) : (subgeo_dim == 2) ? face(i) : dis_ie(); }

         size_type subgeo_n_node (size_type subgeo_dim, size_type loc_isid) const {
            return reference_element::subgeo_n_node (variant(), order(), subgeo_dim, loc_isid); }
         size_type subgeo_local_node (size_type subgeo_dim, size_type loc_isid, size_type loc_jsidnod) const {
            return reference_element::subgeo_local_node (variant(), order(), subgeo_dim, loc_isid, loc_jsidnod); }
         size_type subgeo_size (size_type subgeo_dim, size_type loc_isid) const {
            return reference_element::subgeo_n_node (variant(), 1, subgeo_dim, loc_isid); }
         size_type subgeo_local_vertex(size_type subgeo_dim, size_type i_subgeo, size_type i_subgeo_vertex) const {
            return reference_element::subgeo_local_node (variant(), 1, subgeo_dim, i_subgeo, i_subgeo_vertex); }
         size_type first_inod (size_type subgeo_dim) const {
            return reference_element::first_inod (variant(), order(), subgeo_dim); }
         size_type  last_inod (size_type subgeo_dim) const {
            return reference_element::last_inod (variant(), order(), subgeo_dim); }

         size_type n_edge () const { return n_subgeo (1); }
         size_type n_face () const { return n_subgeo (2); }

       // orientation accessors:

           // search S in all sides of K
           orientation_type get_side_informations (
                       const geo_element&amp; S,
                       size_type&amp; loc_isid,
                       size_type&amp; shift) const;

           void get_side_informations (
                       const geo_element&amp; S,
                       side_information_type&amp; sid) const;

           orientation_type get_side_orientation (const geo_element&amp; S) const;

           // compare two sides: S and *this
           bool get_orientation_and_shift (const geo_element&amp; S,
                 orientation_type&amp; orient, shift_type&amp; shift) const;
           orientation_type get_edge_orientation (size_type dis_iv0, size_type dis_iv1) const;
           void get_orientation_and_shift (
             size_type dis_iv0, size_type dis_iv1, size_type dis_iv2,
             orientation_type&amp;  orient,
             shift_type&amp;        shift) const;
           void get_orientation_and_shift (
             size_type dis_iv0, size_type dis_iv1, size_type dis_iv2, size_type dis_iv3,
             orientation_type&amp;  orient,
             shift_type&amp;        shift) const;

       // i/o;

         void put (std::ostream&amp; is) const;
         void get (std::istream&amp; os);

       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                             <u><a href="../man6rheolef/geo_element.6rheolef.html">geo_element</a></u>(6rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>