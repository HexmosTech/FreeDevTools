<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cual - Cuyo Animation Language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/cuyo-data">cuyo-data_2.1.0-1build3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cual - Cuyo Animation Language

       Cual  is  the  main  language  used to describe the animations in cuyo.  Strictly speaking it's the stuff
       between the &lt;&lt; &gt;&gt; brackets in the level description files (xxx.ld).

       On the other hand this man page aims at being a complete description of how to  write  levels  for  cuyo.
       But it's still under construction.  See the file "example.ld" to get an idea of how the rest of the level
       description  works.   There's  also  a  bit of example Cual code in "example.ld".  And of course, all the
       existing levels are examples.

       Note that Cual is probably still very buggy.  So if strange things happen and you're sure it's  not  your
       fault, tell me (<a href="mailto:cuyo@karimmi.de">cuyo@karimmi.de</a>).

</pre><h4><b>HOW</b> <b>IT</b> <b>WORKS</b></h4><pre>
       The  level  description  is organized in sections.  There is a global section and every level has its own
       section, which is a subsection of the global section.  It is common practice to place  each  level  in  a
       separate file, which then basically starts by opening its section and ends by closing it.

       A section is defined by <u>name</u> <b>=</b> <b>{</b><u>contents</u><b>}</b>.  <u>name</u> is the name of the new section and <u>contents</u> contains the
       definitions  that  pertain  to that section.  This is a sequence of definitions of the form <u>name</u> <b>=</b> <u>stuff</u>.
       Here <u>stuff</u> can be <b>{</b><u>contents</u><b>}</b> as above, or it can be a single datum, or it can be a  comma-separated  list
       of  data.   Inside  such  a list, <u>datum</u> <b>*</b> <u>number</u> can be used as a shorthand for <u>datum</u><b>,</b> ...<b>,</b> <u>datum</u>, i.e. a
       <u>number</u>-fold repetition of <u>datum</u>.  A datum can be an identifier, a string (enclosed by '"'), a word, or  a
       number.   In place of a number <b>&lt;</b><u>expression</u><b>&gt;</b> can be used, where <u>expression</u> is an arbitrary expression made
       up from literal numbers, previously defined numeric data, and the operators <b>+</b>, <b>-</b>, <b>*</b>, <b>/</b> and <b>%</b>.

       Definitions can also depend on versions.  See section <b>VERSIONING</b> below.

       Apart from definitions, a section can also contain cual  definitions  (see  below).   These  have  to  be
       enclosed in <b>&lt;&lt;</b> and <b>&gt;&gt;</b>.

       Each  blob  has  its  own  (main)  Cual  procedure  which  does the drawing and the animation stuff.  The
       procedure only depends on the kind of the blob, that is, it is the same  for  blobs  of  the  same  kind.
       However each blob has its own instance of the variables.

       In  every  game  step, the procedure of each of the blobs is called once.  (There are 12.5 game steps per
       second.)  It has to draw the blob each time, even if nothing has changed.  (However, there's an  internal
       routine  in  cuyo  which  checks  if  the  same is drawn as in the last step and which then supresses the
       drawing.)

       There may be other procedures associated to a kind of blob, which are executed  at  special  events,  for
       example  when  a  falling  blob  lands.   In contrast to the main procedure, these event handlers are not
       allowed to draw anything.  See section <b>EVENT</b> <b>HANDLERS</b> for a list of the existing events.

       The name of the main procedure of a blob (the one which draws the blob) is the name of the  kind  of  the
       blob.   Normally,  that  name  is  the  word listed after <u>pics=</u> entry in the .ld file; but if that "word"
       contains  a   dot,   only   the   part   before   the   dot   makes   up   the   name.    (E.   g.   with
       <b>pics=redblob.xpm,greenblob.xpm</b>, the names are "redblob" and "greenblob".)

       The  name of an event handler procedure is the name of the kind, followed by a dot, followed by the event
       name.  (E.g. "redblob.land" for the landing event of the redblob from above.)

       [Explain the default procedures.]

</pre><h4><b>LEVEL</b> <b>DATA</b></h4><pre>
   <b>String</b> <b>valued</b> <b>data</b>
       <b>name</b>   The name of the level.  This appears in the list of levels as well as in the level intro.

       <b>description</b>
              This is an optional further description of the level in its intro.

       <b>author</b> The name of the level author(s) for credit at the beginning of a level.

   <b>Identifier</b> <b>valued</b> <b>data</b>
       <b>bgpic</b>  Background picture (file name).  If too small, placed at bottom.  Defaults to none.

       <b>toppic</b> Appearance of the top border coming down (file name).  Defaults to none.

       <b>explosionpic</b>
              Appearance of the explosions (file name).  Has a default.

   <b>Number</b> <b>valued</b> <b>data</b>
       <b>numexplode</b>
              The size that a group of blobs has to reach in order to explode.   This  is  only  the  level-wide
              default.   Each  kind  can  override  this.   Whether the group does explode is also controlled by
              <b>behaviour</b>.  See section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> for details.

       <b>toptime</b>
              Time the border takes to come down, in number of game steps.  Each  game  step  lasts  80ms.   The
              default value is 50 (i.e. one pixel every four seconds).

       <b>topoverlap</b>
              Placement  of  <b>toppic</b>  relative  to the actual border.  More precisely, number of pixels the lower
              border of the picture is below the actual border.  Defaults to the height of the picture.

       <b>topstop</b>
              When the border comes down at the end of the level, number of pixels it  should  stop  before  the
              bottom.   Set this to the same value as topoverlap if you want your toppic to be comletely visible
              at the end.  Defaults to 0.

       <b>chaingrass</b>
              Must be 0 or 1.  If set to 1, chain reactions are necessary to kill the  grass.   Defaults  to  0.
              More  precisely,  <b>chaingrass</b> only controls the default for <b>behaviour</b> for grass blobs.  See section
              <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> for details.

       <b>mirror</b> Must be 0 or 1.  If set to 1, the level appears upside-down.  Defaults to 0.

       <b>randomfallpos</b>
              Must be 0 or 1.  If set to 1, the initial fall position is randomized horizontally.   Defaults  to
              0.

       <b>neighbours</b>
              Determines  in which directions the blobs can connect to each other in order to form groups.  This
              is only the level-wide default.  Each kind can override this.  See section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b>
              for values.  Defaults to <b>neighbours_rect</b>.

       <b>hexflip</b>
              In hex mode, determines whether the even or the odd  columns  are  shifted  upwards.   By  default
              (hexflip  =  0),  the  odd  columns are shifted. 1 means: shift even columns of player 1; 2 means:
              shift even columns of player 2; 3 means: shift even columns of both players.

       <b>randomgreys</b>
              The expected time between two randomly appearing greys in game steps (80ms).  Use -1 for  none  at
              all, which is the default.

       <b>nogreyprob</b>
              The probability that a grey does not appear.  See <b>greyprob</b> and <b>colourprob</b> in section <b>KIND</b> <b>DATA</b> for
              details.  The default is 0.

       <b>aiu_color,</b> <b>aiu_grass,</b> <b>aiu_grey,</b> <b>aiu_two_above,</b> <b>aiu_monochromic_vertical,</b> <b>aiu_height</b>
              Parameters  for the AI player's utility function.  Default respectively to &lt;10*(number of kinds)&gt;,
              20, 10, &lt;aiu_color/2&gt;, &lt;aiu_color&gt;, and 10.  See section <b>THE</b> <b>AI</b> <b>UTILITY</b> <b>FUNCTION</b> for details.

   <b>Colour</b> <b>valued</b> <b>data</b>
       (A colour is an RGB triple of numbers between 0 and 255.)

       <b>bgcolor</b>
              The background colour.  Defaults to white.

       <b>textcolor</b>
              Colour of any text.  This includes the  beginning-of-level  information,  message()s,  and  score.
              Defaults to a certain shade of dark grey.

       <b>topcolor</b>
              The colour of the top border comming down (where not determined by <b>toppic</b>).  Defaults to a certain
              shade of light grey.

   <b>Other</b> <b>data</b>
       <b>startdist</b>
              Distribution of blobs at the beginning of the level.  It is a list of strings, the format of which
              is described in the section <b>STARTDIST</b>.

       <b>pics,</b> <b>greypic,</b> <b>startpic,</b> <b>emptypic</b>
              Lists  of  kinds.   These  can  be  either  file  names  referring  to  the picture to be used, or
              declarations of kinds that have to be defined  later  on.   The  different  keywords  (e.g.  pics,
              emptypic) define different defaults.  In fact, only the first three may be real lists, <b>emptypic</b> is
              limited  to  exactly  one  entry.   In  these  lists,  it is advisable to use <b>*</b> whenever possible.
              Besides being shorter to write, it also speeds up loading of the level and cuts down memory usage.
              This is because cuyo does some initializations only once for each entry with multiplier.

              The intentions of these lists are normal blob kinds resp. grey blob kind  resp.  grass  blob  kind
              resp.  nothing-blob.   However,  the  only  differences between <b>pics</b>, <b>greypic</b> and <b>startpic</b> are the
              default values for <b>behaviour</b>, <b>colourprob</b>, <b>goalprob</b>, <b>greyprob</b>, <b>versions</b> and  <b>distkey</b>  (see  there).
              All  of  these  can also be overridden individually.  Also, the default drawing code is different.
              (The default drawing code for <b>startpic</b> does not draw connections.)

       <u>kind</u>   Each kind can have its own section.  See <b>KIND</b> <b>DATA</b> below for the entries of that section.

</pre><h4><b>KIND</b> <b>DATA</b></h4><pre>
       <b>numexplode,</b> <b>neighbours</b>
              Defining these data in the section of a kind overrides the level-wide value  for  the  kind.   See
              section <b>LEVEL</b> <b>DATA</b> for a description of these data.

       <b>pics</b>   A list of file names of pictures to be used for this kind.  The <u>n</u>th entry can later be accessed in
              cual with <b>file=</b><u>n-1</u>.

       <b>colourprob</b>
              The  probability  that this kind appears as one of the two steered falling blobs.  More precisely,
              this is a nonnegative integer weight.  For  determining  the  actual  probability,  the  value  is
              divided  by the sum of the <b>colourprob</b>s of all kinds.  This sum must be positive.  The default is 1
              for kinds declared with <b>pics=</b> and 0 for all other kinds.  The probability is also used  for  <b>+</b>  in
              <b>startdist</b>.  For more details see section <b>STARTDIST</b>.

       <b>goalprob</b>
              This  affects  the  semantics  of  <b>*</b>  in <b>startdist</b> in the same way, as <b>colourprob</b> does for <b>+</b>.  The
              default is 1 for kinds declared with <b>startpic=</b> and 0 for all other kinds.

       <b>greyprob</b>
              The probability that this kind appears as a grey blob.  This is similar to <b>colourprob</b>,  but  there
              is  a difference: For greyprob, <b>nogreyprob</b> is included in the sum, so that it might happen that no
              blob appears at all.  There is a notable difference between a positive <b>nogreyprob</b> and  a  positive
              <b>greyprob</b> in kind <b>nothing</b>, when several lines of grey blobs appear: In the latter case, empty blobs
              appear  in  the  wall  of  greys,  making  holes.  In the former case, the wall is made less high.
              Usually this is preferable.  The default is 1 for kinds declared with <b>greypic=</b> and 0 for all other
              kinds.  The value also affects the semantics of <b>-</b> in <b>startdist</b>.  In this case, <b>nogreyprob</b>  is  not
              included in the sum.

       <b>versions</b>
              At  the  creation of a blob, its <b>version</b> variable is initialized.  Usually, it is chosen at random
              from <b>0</b> to <b>versions-1</b>, but <b>startdist</b> provides the possibility to specify it exactly.   See  section
              <b>STARTDIST</b> for details.  The default is 1.

       <b>distkey</b>
              An alphanumerical key, which is used in <b>startdist</b> to identify this kind of blob.  The default is <b>A</b>
              for  kinds  declared  with  <b>startpic</b> and undefined for all other kinds.  See section <b>STARTDIST</b> for
              details.

</pre><h4><b>CUAL</b> <b>DEFINITIONS</b></h4><pre>
       Inside &lt;&lt; &gt;&gt;, variable and procedure definitions are expected.

       <u>procname</u> <b>=</b> <u>code</u> <b>;</b>
              Defines a "procedure".  The next section describes how <u>code</u> looks like.  Example:

                redblob = {
                  schema16; 0*;
                  1; A,B,C; *;
                };

       <b>var</b> <u>varname1</u> [<b>=</b> <u>def1</u> [<b>:</b> <b>reapply</b>]]<b>,</b> <u>varname2</u> [<b>=</b> <u>def2</u> [<b>:</b> <b>reapply</b>]]<b>,</b> ... <b>;</b>
              Defines variables with default values.  If no default is specified, zero  is  used.   See  section
              <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> about the meaning of the default value and the optional suffix <b>:</b> <b>reapply</b>.

       <b>default</b> <u>varname1</u> <b>=</b> <u>def1</u> [<b>:</b> <b>reapply</b>]<b>,</b> <u>varname2</u> <b>=</b> <u>def2</u> [<b>:</b> <b>reapply</b>]<b>,</b> ... <b>;</b>
              Changes the default for already defined variables.  Again, the suffix <b>:</b> <b>reapply</b> is optional.  This
              is  useful  to  give  to a single kind a different default for a variable than to the other kinds.
              Also, the default of a system variable can be changed this way.

</pre><h4><b>CODE</b></h4><pre>
       A code fragment can be one of the following:

       <b>{</b> <u>code</u><b>;</b> <u>code</u><b>;</b> <b>...}</b>
              Executes one command after the other.

       <u>code</u><b>,</b> <u>code</u><b>,</b> <b>...</b>
              This is useful for simple animations.  Executes exactly one of the commands: In the n-th call, the
              n-th command is executed. After the last command, the first one is executed  again.   However,  if
              one  of  the  commands is "busy" (see section <b>BUSIENESS</b>), this one will be executed until it stops
              being busy, and only after that, the next command will be executed.

       <u>procname</u>
              Executes the procedure <u>procname</u>, which has to be already defined.  The result is the  same  as  if
              the code from procname would have been inserted in that place.

       <b>&amp;</b><u>procname</u>
              Executes  the  procedure  <u>procname</u>;  however, every instance of such a procname is the same.  This
              concerns busieness and the state of an animation sequence.  (See sections <b>BUSIENESS</b> and <b>AMPERSAND-</b>
              <b>CALL</b>.)

       <b>busy</b>   Does nothing except being busy.  (See section <b>BUSIENESS</b>.)

       <u>varname</u> <b>=</b> <u>expr</u>
              Sets the variable.  See section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> for details.

       The same with <b>+=</b>, <b>-=</b>, <b>*=</b>, <b>/=</b>, <b>%=</b>, <b>.+=</b>, <b>.-=</b>.
              Does what you would expect.

       <b>[</b> <u>varname</u> <b>=</b> <u>expr</u> <b>]</b> <u>code</u>
              Sets the variable <u>varname</u> to <u>expr</u>, executes <u>code</u> and then resets the variable to the old value.

       <u>number</u> A shortcut for <b>file</b> <b>=</b> <u>number</u>.

       <u>letter</u> A shortcut for <b>pos</b> <b>=</b> <u>number</u>, where different letters mean different numbers: A: 0, B: 1,  ...,  Z:
              25, a: 26, ..., z: 51

       <b>*</b>      Draw  the  icon  specified  by the variables <u>kind</u>, <u>file</u> and <u>pos</u>.  May also draw only a part of the
              icon, if specified by the variable <u>qu</u> (see section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b>).

       <b>*@(</b><u>position</u><b>)</b>
              Like <b>*</b>, but draws the icon at some other position.  This drawing is performed <u>after</u> all drawing by
              *.  If <b>*@</b> is used from several blobs, the further order  of  drawing  is  not  specified.   It  is
              guaranteed,  however,  that  at  any  given  time  this order is the same for all positions.  (See
              section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> for more details about @.)

       <b>@(</b><u>position</u><b>)*</b>
              Like <b>*</b>, but draws the icon at some other position.  This drawing is performed <u>before</u>  all  drawing
              by  *.   If  <b>@*</b>  is used from several blobs, the further order of drawing is not specified.  It is
              guaranteed, however, that at any given time this order  is  the  same  for  all  positions.   (See
              section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> for more details about @.)

       <b>if</b> <u>expr</u> <u>if-arrow</u> <u>if-code</u> <b>;</b>
       <b>if</b> <u>expr</u> <u>if-arrow</u> <u>if-code</u> <b>else</b> [<u>else-arrow</u>] <u>else-code</u> <b>;</b>
              The  arrows  can  be  either "-&gt;" or "=&gt;".  If you use "-&gt;" arrows, it does exactly what you would
              expect.  If the if-arrow  is "=&gt;", then once  the  expression  gets  true,  the  if-code  will  be
              executed every subsequent time (without testing the condition), as long as it is "busy".  For more
              details  see  section  <b>BUSIENESS</b>.  If the else-arrow is "=&gt;", then once the expression gets false,
              the else-code will be executed every subsequent time as long as it is busy.   The  else-arrow  may
              only  be  omitted,  if  the  if-arrow is "-&gt;".  Then the else-arrow also is "-&gt;".  (But this might
              change in the future.)

       <b>switch</b> <b>{</b>
         <u>expr1</u> <u>arrow1</u> <u>code1</u> <b>;</b>
         <u>expr2</u> <u>arrow2</u> <u>code2</u> <b>;</b>
         <b>...</b>
       <b>}</b>      The arrows can be either "-&gt;" or "=&gt;".  Does the same as:

                if <u>expr1</u> <u>arrow1</u> <u>code1</u>
                else =&gt; if <u>expr2</u> <u>arrow2</u> <u>code2</u>
                ...

              The last <u>expr</u> may be omitted.  This is equivalent to setting it to true.

       <b>bonus(</b><u>expr</u><b>)</b>
              The player gets <u>expr</u> bonus points.

       <b>message(</b><u>String</u><b>)</b>
              The string is displayed (blinking) on the screen.  To be used together with bonus(...).  Example:

                <a href="../man50/bonus.50.html">bonus</a>(50);
                message("You get 50 bonus points");

       <b>explode</b>
              Makes the blob explode.  For the next 8 steps or so, the blob is still what it was before, but the
              explosion is drawn over the graphics.  After that, it's changed to a nothing-blob.

       <b>lose</b>   The players immediately lose the level.

       <b>sound(</b><u>Filename</u><b>)</b>
              Plays the given sound file.

       You can also omit the code completely.  Then, of course, it does not do anything.  This can be useful  as
       part of <b>,</b>-sequences.

       There's a shortcut for drawing: You may omit the ";" between a number, a letter and the "*".

</pre><h4><b>EXPRESSIONS</b></h4><pre>
       The  only  data type in cual is int.  Bools are represented by 0 and 1, like in C.  (And any number other
       than 0 is interpreted as true, if a boolean is expected.)

       Of course, variables, constants and numbers are expressions, and you can use parentheses.  There are  the
       following operators (listed here in order of increasing precedence):

              <b>||</b>     Boolean or

              <b>&amp;&amp;</b>     Boolean and

              <b>==</b>, <b>!=</b>, <b>&lt;</b>, <b>&gt;</b>, <b>&lt;=</b>, <b>&gt;=</b>
                     Comparison

              <b>==..</b>   A special comparison

              <b>!</b>      Boolean not

              <b>+</b>, <b>-</b>   Add, substract

              <b>:</b>      Special operator

              <b>*</b>, <b>/</b>, <b>%</b>
                     Multiply, divide, modulo

              <b>&amp;</b>, <b>|</b>, <b>.+</b>, <b>.-</b>
                     Bitwise and, bitwise or, setting of bits (same as bitwise or), unsetting of bits

              <b>-</b>      Unary minus

              <b>.</b>      Testing of bits (<u>a</u><b>.</b><u>b</u> is the same as <u>a</u><b>&amp;</b><u>b</u> <b>!=</b> <b>0</b>)

       <b>/</b> and <b>%</b> work mathematically correct and do not make funny changes when the sign of the numerator changes.
       More  specifically,  if  <u>b</u>  is  positive,  then  <u>a</u><b>/</b><u>b</u>  is the largest integer <u>n</u> such that <u>n</u><b>*</b><u>b</u><b>&lt;=</b><u>a</u>.  If <u>b</u> is
       negative, then <u>a</u><b>/</b><u>b</u> is the largest integer <u>n</u> such that <u>n</u><b>*</b><u>b</u><b>&gt;=</b><u>a</u>.  In both cases <u>a</u><b>%</b><u>b</u> is such that <b>(</b><u>a</u><b>/</b><u>b</u><b>)*</b><u>b</u><b>+</b><u>a</u><b>%</b><u>b</u>
       <b>=</b> <u>a</u>.  Examples:

       13/5=2       13%5=3
       -13/5=-3     -13%5=2
       13/-5=-3     13%-5=-2
       -13/-5=2     -13%-5=-3

       The following are the special operators:

       <u>expr1</u> <b>==</b> <u>expr2</u> <b>..</b> <u>expr3</u>
              Is true, if <u>expr1</u> lies between <u>expr2</u> and <u>expr3</u>.  You may also omit one of <u>expr2</u> and <u>expr3</u>.  (Then,
              it does the same as &lt;= resp.  &gt;=.)   The  precedence  implies  that  <b>x==y==2..3</b>  is  the  same  as
              <b>x==(y==2..3)</b>  and  is neither <b>(x==y)==2..3</b> nor <b>x==(y==2)..3</b>.  Note that this operator might change
              in the future. (I plan to make something like "<u>expr</u> in <u>set</u>" in Pascal.)

       <u>expr1</u> <b>:</b> <u>expr2</u>
              Is true (that is, 1) with probability <u>expr1</u>/<u>expr2</u>

       <u>neighbour_pattern</u>
              <u>neighbour_pattern</u> is a sequence of six or eight characters <b>0</b>, <b>1</b> and <b>?</b>.  It is true if the sequence
              fits to the neighbour sequence of the blob.  The neighbour sequence is a string of "0"s  and  "1"s
              with a "1" for each neighbour of the same kind, starting above and going clockwise.  This way, you
              get a string of "0"s and "1"s (six or eight, depending on wether this level is in hex mode).

              Example:  <b>1???0???</b>  is true iff the blob above this blob is of the same kind and the blob below it
              is of different kind.

              For an empty blob the semantics is slightly different: If in some direction there is no neighbour,
              because the field ends there, the entry in the neighbour sequence is 1 nevertheless.   So  for  an
              empty  blob <b>1???0???</b> is true, iff the blob above this blob does not exist or is empty as well, and
              the blob below this blob exists and is not empty.

              If some blob changes its kind during a step, the expression will still test the neighbours as they
              were at the beginning of the step.  (See the section <b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b> for details.)

       The following functions exist:

       <b>rnd(</b><u>expr</u><b>)</b>
              Returns a random value between 0 and <u>expr</u>-1

       <b>gcd(</b><u>expr1</u><b>,</b> <u>expr2</u><b>)</b>
              Returns the greatest common divisor of <u>expr1</u> and <u>expr2</u>

</pre><h4><b>VARIABLES</b> <b>AND</b> <b>CONSTANTS</b></h4><pre>
       The following kinds of variables and constants exist:

       —  User defined variables (see section <b>CUAL</b> <b>DEFINITIONS</b>).  At the start of the level (or at the  creation
          of the blob) the value is the default value you provided.  If you supplied the default with <b>:</b> <b>reapply</b>,
          whenever  a blob's kind changes, the value of the variable is also set to the default of the new kind.
          There is a subtlety: This only happens if the new value of kind is in fact different from the old one.

       —  System variables.  These variables are always defined and have special meanings, e.g.  <b>file</b>  and  <b>pos</b>.
          Some of them are read-only.

       —  User defined constants.  These are defined in the main .ld part, not in cual (not inside &lt;&lt; &gt;&gt;).

       —  System constants.  Some of them depend on properties of the level, some are really constant.

       Of each variable, there's one instance in each blob.  Normally, you access the instance in your own blob,
       but with the following syntax, you can access variables of other blops:

         <u>varname</u><b>@@(</b><u>x</u><b>,</b> <u>y</u><b>;</b> <u>side</u><b>)</b>
         <u>varname</u><b>@@(</b><u>x</u><b>;</b> <u>side</u><b>)</b>
         <u>varname</u><b>@@(;</b> <u>side</u><b>)</b>
         <u>varname</u><b>@(</b><u>dx</u><b>,</b> <u>dy</u><b>;</b> <u>side</u><b>)</b>
         <u>varname</u><b>@(</b><u>dx</u><b>;</b> <u>side</u><b>)</b>
         <u>varname</u><b>@()</b>

       If  <u>x</u> and <u>y</u> are given, these are absolute coordinates in the grid of blops, that is the variable is taken
       from the blob with loc_x=x and loc_y=y (see under  <b>The</b>  <b>system</b>  <b>variables</b>).   If  only  <u>x</u>  is  given,  it
       specifies  one of the two blobs that are currently falling.  If there is only one such blob left, because
       the other one got stuck on some tower, the remaining blob's coordinate is 0.  Otherwise one  of  the  two
       has coordinate 0, the other 1.

       In  the  <b>@</b>  variants, the coordinates are relative to the current blob.  The variant <b>@@(;</b> <u>side</u><b>)</b> refers to
       the semiglobal blob, the variant <b>@()</b> to the global blob (See section <b>THE</b> <b>GLOBAL</b> <b>BLOB</b>).  The extra part  <b>;</b>
       <u>side</u> is optional and specifies the side of the game.  This is only meaningful in two-player mode.  <u>side</u> =
       <b>&lt;</b>  specifies  the  left  player, <u>side</u> = <b>&gt;</b> the right player, <u>side</u> = <b>=</b> the player to which the current blob
       pertains, and <u>side</u> = <b>!</b> the other player.  <b>@()</b> and <b>@@()</b> can also be given as <b>@</b> respectively <b>@@</b>.

       This can be done for both, reading and writing variables.  It also works for system  variables  (but  not
       for constants).

       In  hex mode levels, for odd <u>dx</u>, <u>dy</u> should be a "half integer", that is a number ending in ".5".  This is
       the only place in Cual  where  non-integers  appear.   Especially,  ".5"  is  not  allowed  in  composite
       expressions.  Therefore, also integer <u>dy</u> is always allowed.  If a half-integer is expected and an integer
       is given, it is assumed to be rounded to above, that is 5 then represents 4.5 and -5 represents -5.5.

       Caution:  With  <b>mirror=1</b>  the  absolute  and  the  relative coordinates use different coordinate systems.
       Handle with extreme care.

       Accessing foreign variables is not as easy as it might look at first glance; it might easily introduce  a
       dependence of the internal order of execution of the blob codes.  For this reason,

       —  reading variables with <b>@</b> or <b>@@</b> always returns the value of the variable it had at the <u>beginning</u> of the
          current step, that is, before any of the blob codes has been executed.

       —  when  writing  variables  with  <b>@</b>  or  <b>@@</b>, the write operation will only be executed at the <u>end</u> of the
          current step.  (The write operations are stored in a kind of queue.)

       This is also true if a blob accesses its own variables with <b>@(0,0)</b>.

       The operators <b>+=</b>, <b>-=</b>, etc.  are also performed in the future if the left hand side is an <b>@</b>-variable.  (To
       be more precice, the right hand side is calculated instantanousely.)

       For illustration, look at the following six statements:

       1)   X += 1
       2)   X@(0, 0) += 1
       3)   X = X + 1
       4)   X = X@(0, 0) + 1
       5)   X@(0, 0) = X + 1
       6)   X@(0, 0) = X@(0, 0) + 1

       Only 1) and 3) do the same; they simply increment X by 1.  Statement 4) sets X to one more than it was at
       the beginning of the step.  Statements 2), 5) and 6) cause the value of X to be  changed  in  the  future
       (after the current step): X is set to one more than:

       2)     the value of X just before the change (that is, X is incremented in the future),

       5)     the current value of X,

       6)     the value of X at the beginning of the step.

   <b>Some</b> <b>more</b> <b>details</b>
       —  Whenever  you  try  to  access  a variable at a location which doesn't exist, you will get the default
          value.  If default values depend on the kind, the default pertaining to the blob executing the code is
          used.  This may change in the future.

       —  Changing a variable which doesn't exist does nothing (and does not result in an error).

       [Add explanation of <u>time</u> <u>slices</u>; roughly:
          @-access of variables in reality don't access the value at the beginning/end of the game step, but  of
          the  time slice.  The call of the main procedure of all blobs happens in the same time slice, but each
          other kind of event has its own time slice.]

   <b>The</b> <b>system</b> <b>variables</b>
       <b>file</b>   Specifies the file number from which to take the icon that is drawn  by  "*".   This  variable  is
              reset to 0 before the drawing procedure is executed.

       <b>pos</b>    Specifies  the position in the file of the icon that is drawn by "*".  This variable is reset to 0
              before the drawing procedure is executed.

       <b>kind</b>   The kind of the blob.  There are constants for the possible  values  of  this  variable.   If  you
              change the kind, you should be aware of three things:

              —  Expressions  like  "001???01"  test the neighbour pattern at the <u>beginning</u> of the current step.
                 So the change of the variable <u>kind</u> will not be reflected.

              —  In the current step, the program to draw the blob has already been invoked (it  might  even  be
                 the program which changed this variable); so in this step, the blob will still look like one of
                 the old kind.  However, if things are drawn after the kind has been changed, icons from the new
                 kind are taken.

              —  Defaults  of  the  new  kind that are declared with <b>:</b> <b>reapply</b> are applied.  This happens at the
                 same time that kind changed, but only if the new kind is different from the old one.

       <b>version</b>
              Is assigned a hopefully distinctive value at the blob's creation.  See <b>versions</b>  in  section  <b>KIND</b>
              <b>DATA</b> for details.

       <b>qu</b>     Tells  "*"  which  part of the icon to draw.  It's possible to draw the whole icon, or only one of
              its quarters.  If a quarter is drawn, you may specify independently which of the quarters to  take
              and at which position to draw it.  Use the constants (see below).  This variable is reset to "draw
              all" before the drawing procedure is executed.

       <b>out1,</b> <b>out2</b>
              Set  these  Variables  for  debug  output.   The values will be printed on top of the blob.  These
              variable are reset to "output nothing" before  the  drawing  procedure  is  executed.   (In  fact,
              "output nothing" is one special big value.)

       <b>weight</b> When  <b>calculate_size</b>  is  set in <b>behaviour</b>, <b>size</b> will be regularly updated to the sum of <b>weight</b> in
              the connected component.  The default is 1.

       <b>inhibit</b>
              Set this variable to a sum of the constants DIR_...; this will inhibit  that  this  blob  connects
              into  the given directions.  This is <u>not</u> for the graphics but for the calculation of the connected
              components and the explosions.

       <b>behaviour</b>
              This is a bit field.  Refer to <b>The</b> <b>Constants</b> below for the meaningful of its bits.  The default is
              <b>calculate_size</b>+<b>explodes_on_size</b> for normal blobs,  <b>explodes_on_explosion</b>+<b>explodes_on_chainreaction</b>
              for        grey        blobs,        <b>floats</b>        for        the       empty       blob       and
              <b>goalblob</b>+<b>explodes_on_explosion</b>+<b>explodes_on_chainreaction</b>   or   <b>goalblob</b>+<b>explodes_on_chainreaction</b>
              (depending on whether chaingrass is set) for grass blobs.

       <b>falling_speed,</b> <b>falling_fast_speed</b>
              These  variables  are  only  used  in the semiglobal blobs.  They define the vertical speed of the
              steered falling blobs.  The unit is pixels per game step.  The defaults are 6 and 32.

   <b>The</b> <b>system</b> <b>read-only</b> <b>variables</b>
       <b>time</b>   The number of time steps since the level was started.

       <b>turn</b>   Is 1 resp. 2 if the blob is falling and just being turned by the user and 0 otherwise.  (1 in  the
              first  turning  step,  2  in the second one.)  Be aware that if the user presses the turn key fast
              several times, some of these steps may be omitted.  (Use the turn event if you  want  to  be  sure
              that a program block is executed once for every turn.)

       <b>connect</b>
              Contains internal data.  Will be removed.  Probably.

       <b>size</b>   The size of the component of the blob.  (That is, how many blobs are connected.)

       <b>basekind</b>
              The value of the constant generated for the name of the kind of the blop.  Example:

                <b>pics</b> <b>=</b> <b>orange,</b> <b>pear,</b> <b>apple</b> <b>*</b> <b>3,</b> <b>banana,</b> <b>apple</b>

              Here, all four kinds <b>apple</b> have the same value for basekind, and this value is <b>apple</b>.

       <b>loc_x,</b> <b>loc_y</b>
              The absolute coordinates of the blob.  (0,0) = top left corner

       <b>loc_xx,</b> <b>loc_yy</b>
              The  absolute  coordinates  of  the  blob  in pixels.  This is not always the same as loc_x*32 and
              loc_y*32, particularly for the steered falling blobs.

       <b>loc_p</b>  The player of the blob (1 or 2)

       <b>falling</b>
              true, if the blob is falling or it is a preview of a falling  blob.   (Falling  in  the  sense  of
              steered by the player.  Grey blobs are not falling in that sense.)

       <b>falling_fast</b>
              True, if the blob is falling fast, that is, the user pressed the down key.

       <b>informational</b>
              True,  if  the  blob  is  one  of the info-blobs at the side of the game area.  In this sense, the
              previews of the falling blobs also count as info-blobs.

       <b>players</b>
              The number of players.

       <b>exploding</b>
              When the blob is exploding, the position in the explosion animation (1 to 8); 0 else.

              Currently, there is one exception: if the explosion has been triggered  by  the  <b>explode</b>  command,
              then <b>exploding</b> will have value 1 only <u>after</u> the current game step [more precisely: time slice; fix
              that].   Reason:  when  reading <b>exploding@(x,y)</b>, we maybe don't know yet that the other blob calls
              <b>explode</b>.

   <b>The</b> <b>Constants:</b>
       <b>Constants</b> <b>for</b> <b>behaviour:</b>

       <b>goalblob</b>
              Set goalblob if this blob should act like grass: You will have to get rid of it to win  the  level
              and making this blob explode will give more points.

       <b>calculate_size</b>
              When  this  bit  is  set,  <b>size</b>  will  be  regularly updated to the sum of <b>weight</b> in the connected
              component.

       <b>explodes_on_size</b>
              When this bit is set, a connected component explodes, when it has <b>size</b>&gt;=<b>numexplode</b>.

       <b>explodes_on_explosion,</b> <b>explodes_on_chainreaction</b>
              When these bits  are  set,  the  blob  explodes  whenever  an  explosion  that  was  triggered  by
              <b>explodes_on_size</b>   happens  in  its  neighbourhood.   <b>explodes_on_chainreaction</b>  refers  to  those
              triggering  explosions  that   are   the   second   or   later   part   of   a   chain   reaction.
              <b>explodes_on_explosion</b> refers to the other ones.

       <b>floats</b> When  this  bit is set, the blob keeps its vertical position even if there is an empty blob below.
              This bit has no effect on the steered falling blobs.

       <b>Constants</b> <b>for</b> <b>kind:</b>

       <b>&lt;name</b> <b>of</b> <b>kind</b> <b>of</b> <b>blob&gt;</b>
              For each kind of blob, there's one constant with the name of that kind. Use it to check if a  blob
              is  of that kind using <b>kind@(</b><u>x</u><b>,</b><u>y</u><b>)</b> <b>==</b> <u>aKind</u> or to change to that kind using <b>kind</b> <b>=</b> <u>aKind</u>.  See <b>kind</b>
              under <b>The</b> <b>system</b> <b>variables</b> for the side-effects of setting <b>kind</b>.

              Sometimes it is necessary to perform arithmetic on kinds,  for  example  when  several  have  been
              declared  using  the  <b>*</b>  multiplier.   The values of the constants are successive in the order, in
              which the kinds have been declared.  When a name is used several times, the first use defines  the
              value.  Example:

                <b>startpic</b> <b>=</b> <b>apple,</b> <b>orange</b>
                <b>pics</b> <b>=</b> <b>orange,</b> <b>pear,</b> <b>apple</b> <b>*</b> <b>3,</b> <b>banana</b>
                <b>greypic</b> <b>=</b> <b>pineapple</b>

              This initializes 2 kinds with the defaults for startpic, 6 kinds with the defaults for pics, and 1
              kind  with  the  defaults  for  greypic.   The value of the constant <b>orange</b> is 1 more than that of
              <b>apple</b>, <b>pear</b> is 2 more than <b>orange</b>, <b>banana</b> is 4 more than <b>pear</b> and <b>pineapple</b> is 1 more than <b>banana</b>.
              We do not specify what these values actually are.

              This constant also exists for the empty kind, if one has been declared using  emptypic.   In  this
              case the value's relation to the other values is not specified at all.

       <b>global,</b> <b>semiglobal</b>
              Denote the kind of the global, respectively semiglobal, blob.

       <b>nothing</b>
              Is the same as the constant for the empty kind.  Is provided, because sometimes, you don't have an
              empty kind, but you still need to test if a blob is empty.

       <b>outside</b>
              The value of kind if the coordinates are outside of the game board.

       <b>Constants</b> <b>for</b> <b>neighbours:</b>

       <b>neighbours_rect</b>
              A blob connects up, down, left, and right.  This is the default.

       <b>neighbours_horizontal</b>
              A blob connects left and right.

       <b>neighbours_vertical</b>
              A blob connects up and down.

       <b>neighbours_diagonal</b>
              A blob connects diagonally.

       <b>neighbours_hex6</b>
              When used in the level-wide <b>neighbours</b>, this sets hex mode.  A blob connects up, down, left with a
              slight  upwards  shift, left with a slight downwards shift, right with a slight upwards shift, and
              right with a slight downwards shift.

       <b>neighbours_hex4</b>
              When used in the level-wide <b>neighbours</b>, this sets hex mode.  A blob connects left  with  a  slight
              upwards  shift,  left  with a slight downwards shift, right with a slight upwards shift, and right
              with a slight downwards shift.

       <b>neighbours_knight</b>
              A blob connects in knight moves (Two forward and then one sideways.  Forward is one of  up,  down,
              left or right.  Sideways is perpendicular to forward.  This makes a total of eight directions.).

       <b>neighbours_eight</b>
              Combines <b>neighbours_rect</b> with <b>neighbours_diagonal</b>.

       <b>neighbours_3D</b>
              A  more  obscure  mode created especially for 3d.ld.  When used in the level-wide <b>neighbours</b>, this
              sets hex mode.  A blob connects up, down, two (but not one) to the left, and two to the right.  In
              even columns it also connects right with a slight upwards shift.  In odd columns it also  connects
              left with a slight downwards shift.

       <b>neighbours_none</b>
              A blob does not connect at all.

       <b>Constants</b> <b>for</b> <b>qu:</b>

       <b>Q_ALL</b>  Value for qu, which means "draw the complete picture".

       <b>Q_TL,</b> <b>Q_TR,</b> <b>Q_BL,</b> <b>Q_BR</b>
              Values for qu.  "TL" means draw top-left quarter, etc.  (See the "*" command in the Code section.)

       <b>Q_SRC_DST</b>
              SRC and DST may be TL, TR, BL, BR.  Take quarter SRC and draw it at position DST.

       <b>Miscellanious</b> <b>constants:</b>

       <b>DIR_XX</b> To  be  used with the variable inhibit to prevent the blob connecting in the given directions.  XX
              can be U, D, L, R (horizontal and vertical); UL, UR, DL, DR (diagonal); UUL, UUR, DDL,  DDR,  LLU,
              LLD, RRU, RRD (knight); F, B (3d)

</pre><h4><b>VERSIONING</b></h4><pre>
       Sometimes it is necessary to define a level slightly differently for different purposes.  For example you
       might  need to decrease <b>numexplode</b> for the two-player version lest it becomes unplayable.  The difficulty
       settings from cuyo's main menu provide another example.

       This is done by qualifiing a definition with the versions it should apply to.  It is best explained by an
       example:

         numexplode = 8
         numexplode[2] = 6
         numexplode[1,hard] = 10

       This specifies that normally numexplode should be 8.  In two-player mode it should be 6.   In  one-player
       hard mode it should be 10.  Here the specifiers <b>2</b> for two-player mode, <b>1</b> for one-player mode and <b>hard</b> for
       hard  mode  are  used.   Along  with  <b>easy</b> for easy mode these are all predefined specifiers intended for
       levels.  Additionally (and for internal purposes), there are specifiers for the level tracks: <b>main</b>,  <b>all</b>,
       <b>game</b>, <b>extreme</b>, <b>nofx</b>, <b>weird</b>, and <b>contrib</b>.

       Furthermore,  you can make up and use your own specifiers.  In order for them to take effect, though, you
       have to give cuyo additional information about the current version.  This is done  on  the  command  line
       using the <b>--version</b> option.  For example

         cuyo --version=hard,geek

       Specifies  both  hard  version  (you  can  change  that  in  the  menu)  and version "geek", which is not
       predefined.

       There are several constraints to be observed:

       —  All versions of a definition must be made before the first use of the thing defined.  As sometimes  it
          is  not  obvious  where  the  defined  thing  is used (for example startpic uses a previous greypic by
          assigning successive numbers to kinds), it is best to group all these versions into one block.

       —  A given version also applies to every more specialized version, for which no definition is given.   In
          the above example, <b>numexplode</b> is set to <b>6</b> in two-player hard mode and in two-player easy mode as well.

          All  resulting  conflicts must be resolved.  For example, if you make a definition for <b>[2]</b> and one for
          <b>[hard]</b>, you must also make a  definition  for  <b>[2,hard]</b>  (or,  equivalently,  for  <b>[hard,2]</b>),  because
          otherwise it would be ambiguous which of the two former should apply in two-player hard mode.

       —  Cuyo  knows  that  <b>easy</b>  and  <b>hard</b>  exclude  each  other.  Consequently, it is unnecessary (and indeed
          prohibited) to give an <b>[easy,hard]</b> definition, even if both <b>[easy]</b> and <b>[hard]</b>  are  given.   The  same
          holds for <b>1</b> and <b>2</b>, and for level tracks.

       —  Furthermore,  cuyo  knows that <b>1</b> and <b>2</b> are exhaustive: There is no mode which is neither single-player
          nor two-player.  (The human-versus-AI mode  counts  as  two-player  as  far  as  cual  is  concerned.)
          Therefore,  if there are definitions for both, it is unnecessary, (and again illegal) also to define a
          version without any of both.  For example, if <b>[1,de]</b> and <b>[2,de]</b>  are  given,  <b>[de]</b>  must  be  omitted.
          Alternatively,  you  could  of  course  give  <b>[1,de]</b>  and  <b>[de]</b>  or  <b>[de]</b> and <b>[de,2]</b>.  The level track
          specifiers are exhaustive as well.

</pre><h4><b>BUSIENESS</b></h4><pre>
       (No, not Business ;-)

       Busieness is a concept to make it easier to implement simple animated sequences which  are  triggered  by
       certain events.  Each code fragment has an internal state which tells if it is busy.

       —  Normal statements like assignments are never busy.

       —  A chain of commands separated by "," is busy as long as not all of the commands have been executed.

       —  <u>code1</u> ; <u>code2</u> is busy as long as at least one of <u>code1</u> and <u>code2</u> are busy.

       Here's an example of how to use busieness for an animation which appears at random intervals:

         <b>switch</b> <b>{</b>
           <b>1:100</b> <b>=&gt;</b> <b>{B*,</b> <b>C*,</b> <b>D*,</b> <b>E*};</b>
           <b>-&gt;</b> <b>A*;</b>
         <b>};</b>

       This  code  fragment  normally draws the icon at position A (0).  But in each step, with a probability of
       1/100, an animation sequence consisting of icons B, C, D and E is started.  With a  normal  arrow  ("-&gt;")
       after  the  "1:100",  after the step in which B has been drawn, the probability would be 99/100 that A is
       drawn again.  But with the double arrow, the switch statement won't switch back to A until the  animation
       has terminated.

       (Btw: It doesn't matter if there's a "-&gt;" or a "=&gt;" before the "A*"; A* isn't busy anyway.)

</pre><h4><b>THE</b> <b>GLOBAL</b> <b>BLOB</b></h4><pre>
       Apart from the normal blobs which you can see on screen, there's one global blob (for the whole game, not
       one for each player), which, well, isn't really a blob, but behaves a bit like it.  It has its own set of
       variables,  and it can have a program which is run once every step.  To define such a global program, use
       <b>global=</b><u>code</u>.  However, the global variables do exist even if you don't define global code.   See  section
       <b>VARIABLES</b>  <b>AND</b>  <b>CONSTANTS</b> on how to access them.  Note that the global blob is always executed before any
       of the normal blobs.

       There  are  also  semiglobal  blobs.   There  is  one  for  each  player.   These  are  programmed   with
       <b>semiglobal=</b><u>code</u>.

</pre><h4><b>EVENT</b> <b>HANDLERS</b></h4><pre>
       The following events exist:

       <b>init</b>   Is  called  only  once,  when the blob gets into life, just before the first time its main drawing
              routine is called.

       <b>turn</b>   Is called for falling blobs each time they are rotated.

       <b>land</b>   Is called when the steered blob lands (just after it landed).

       <b>changeside</b>
              Is called when a blob moves from one player to the other, just after the blob has arrived  at  the
              new player.

       <b>connect</b>
              Is called when the connection of blobs is recalculated.

       <b>row_up</b> Is called when a player got a row from the other side, after everything is finished and just after
              the loc_y of all blobs has been decreased by 1.  Is only called for the semiglobal blob, though.

       <b>row_down</b>
              Is  called  when a player gives a row to the other side, before anything visible happens, but just
              after the loc_y of all blobs has been increased by 1.  Is only called  for  the  semiglobal  blob,
              though.

       <b>keyleft,</b> <b>keyright,</b> <b>keyturn,</b> <b>keyfall</b>
              Are  called  when  the  player presses the left, right, turn or fall key.  Are only called for the
              steered falling blobs and the semiglobal blob, though.  (Note that, in contrast to  turn,  keyturn
              is  called  even if the steered blob cannot be rotated due to some obstacles, and also if there is
              no steered blob.)

</pre><h4><b>THE</b> <b>LIFE</b> <b>OF</b> <b>A</b> <b>BLOB</b></h4><pre>
       Normal blobs come into life at the beginning of the game, or they  fall  into  life:  either  as  colored
       blobs,  steered  by the user, or as grey blobs.  More precisely, the steered blobs already come into life
       when they appear as the preview.  When a blob moves (by gravitiy or when  rows  go  from  one  player  to
       another),  it  takes its variables with it.  When a blob explodes, it does not stop existing.  Rather, it
       transforms into an empty blob.  That's important for the variables: The empty  blob  still  has  all  the
       variables  set  to  the  values  they had before; only its kind is different.  Empty blobs are everywhere
       where there's no other blob.  (However, the falling blobs steered by the user are in some  sense  "above"
       everything else; there are empty blobs beneath them.)

       The  life  of  empty  blobs  is  different from the one of normal blobs.  Empty blobs are not affected by
       gravity, and they often start or stop existing.  For example, when a single grey blob  is  falling  down,
       the  empty  blob  below it stops existing when the grey blob arrives and a new empty blob starts existing
       when the grey blob moves on.  There is only one situation in which empty blobs move:  When  a  row  moves
       from one player to the other, and everything moves up resp. down, the empty blobs move, too.

</pre><h4><b>STARTDIST</b></h4><pre>
       The  format  of the startdist field is rather complicated.  On the plus side, this means that many things
       can be done with little effort.  We first describe the single-character format, which,  at  the  time  of
       this writing, has sufficed for all needs.  After that, we describe the general format as an extension.

       Every  line  of  the  startdist  describes  one row of blobs in the level's initial state.  The lines are
       aligned to the bottom and the topmost lines come first (normal reading order).  Each  line  must  contain
       exactly  10 or exactly 20 characters, except the last which is special.  In a line of length 20 the first
       10 characters describe the left player, the second 10 characters describe the right player.   A  line  of
       length 10 describes both players.  Hence, each character describes one blob.  The semantics are:

       <b>.</b>      An empty blop.

       <b>+,</b> <b>-,</b> <b>*</b>
              A  blop  chosen  at  random according to <b>colourprob</b>, respectively <b>greyprob</b>, respectively <b>goalprob</b>.
              The value of <b>nogreyprob</b> has no influence.

       <b>0..9,</b> <b>A..Z,</b> <b>a..z</b>
              These characters denote a specific kind.  If the character matches the <b>distkey</b> of some kinds,  the
              first of these is chosen.  More generally, these characters are ordered such that <b>"9"</b> comes before
              <b>"A"</b>  and  <b>"Z"</b> comes before <b>"a"</b>.  In this order, the maximal <b>distkey</b>, which does not come after the
              character, specifies the blob's <b>kind</b>.  The difference between the character and the  <b>distkey</b>  then
              specifies the blob's <b>version</b>.

              Example  1:  In the special case, where the character exactly matches a <b>distkey</b>, <b>version</b> is set to
              0.

              Example 2: Suppose kind <b>apple</b> has <b>distkey</b> <b>=</b> <b>"A"</b>, kind <b>orange</b> has <b>distkey</b>  <b>=</b>  <b>"O"</b>  and  no  further
              <b>distkey</b>s exist.  Then the character <b>"C"</b> denotes an apple with <b>version=2</b>, the character <b>"N"</b> denotes
              an  apple  with  <b>version=13</b>, the character <b>"O"</b> denotes an orange with <b>version=0</b>, the character <b>"S"</b>
              denotes an orange with <b>version=4</b>, the character <b>"a"</b> denotes an orange  with  <b>version=12</b>,  and  the
              character <b>"8"</b> does not denote anything (and hence is illegal).

       <b>%</b>      An info blop with the version set according to the level-wide neighbours.

       <b>&amp;</b>      An info blop with the version set according to the level-wide chaingrass.

       The  last  line  may have length 4, 8, 10, or 20.  If it has length 10 or 20, it is just a normal line as
       above.  Otherwise it describes the informational blops next to the field.  In case of length 4, the first
       entry describes the blop which depicts the number of greys.  The second entry describes  the  blop  which
       depicts  the  number  of  grass  blops.   The  third  entry  describes  the blop which depicts connection
       information.  The fourth entry describes the blop whoch  depicts  chaingrass  information.   In  case  of
       length  8,  the  above holds for the left player.  The remaining 4 entries then describe the same for the
       right player, but in reversed order.  The default is "-*%&amp;&amp;%*-" (or equivalently "-*%&amp;").

       As seen above, startdist can reference 62  kind/version  combinations  directly  (and  more  at  random).
       Because  this  might  at  some  time not be enough, the multichar extension has been introduced.  In this
       case, each blob is described by more than one character.  However, the number of characters per blob must
       be the same for all keys.  Hence, the lengths of <b>startdist</b> lines then must be this number  multiplied  by
       10  or  by  20.   Every  multicharacter combination starting with <b>"."</b>, <b>"+"</b>, <b>"-"</b>, or <b>"*"</b> is treated as the
       corresponding character in single-character format.  All other  character  combinations  are  treated  as
       numbers  in  base 62 representation.  Here, <b>"A"</b> to <b>"Z"</b> are digits with decimal value 10 to 35, and <b>"a"</b> to
       <b>"z"</b> are digits with decimal value 36 to 61.  Leading spaces are allowed instead of zeroes  (however,  the
       all-space  string  is  forbidden).  The maximal <b>distkey</b> which (as a number) is not larger than the number
       given in <b>startdist</b>, specifies the blob's <b>kind</b>.  The difference  between  the  <b>startdist</b>  number  and  the
       <b>distkey</b>  then  specifies the blob's <b>version</b>.  In the case of multichar <b>distkey</b>s, the default for <b>distkey</b>s
       of kinds declared by <b>startpic=</b> is 10 in decimal.

       For blops whose  kinds  are  chosen  at  random  (i.e.  characters  <b>"+"</b>,  <b>"-"</b>,  <b>"*"</b>  in  single-character
       <b>startdist</b>s), cuyo tries to make these as different as possible.  That means, by a certain heuristic, cuyo
       minimizes  the  number  of neighbouring blobs of the same kind.  "Neighbouring", of course, refers to the
       <b>neighbours</b> entry.  <b>inhibit</b> and the <b>calculate_size</b> bit of <b>behaviour</b> have  no  effect  (these  are  mutable
       during  the  lifetime of blobs, while at the time of <b>startdist</b> processing, no blob's lifetime has started
       yet).  So the only way to influence the unneighbouring (if you really wish  to  do  so),  is  by  setting
       <b>neighbours</b>  appropriately.  (Of course, this possibility is even more limited, when you intend to set the
       <b>calculate_size</b> bit during the blob's lifetime.)

</pre><h4><b>WHERE</b> <b>DO</b> <b>I</b> <b>PUT</b> <b>THE</b> <b>CUAL</b> <b>CODE?</b></h4><pre>
       Cual procedures and variables can be defined in different sections of the .ld files:

       —  Outside of everything; that code is accessible from every level coming after that definition.

       —  In the section of a level.

       —  In the section of a kind.

       This basically does what you expect.  However, there's one thing you might want  to  know:  Even  if  you
       define  a  variable  inside a kind, <u>every</u> blob in that level will have that variable.  The only effect of
       defining the variable in the section of a kind is that this kind is the only one which can access it.

</pre><h4><b>AMPERSAND-CALL</b></h4><pre>
       To explain a bit what calling a procecure with an &amp; means, here two examples:

       <u>Example</u> <u>1:</u>
       &lt;&lt;
       myblob = {
         ...
         switch {
           myvar -&gt; { 0A*; 1; A,B,C,D; *; 2A*};
                 -&gt; { 0B*; 1; A,B,C,D; *; 2B*};
         };
       };
       &gt;&gt;

       <u>Example</u> <u>2:</u>
       &lt;&lt;
       anim = {1; A,B,C,D; *};

       myblob = {
         ...
         switch {
           myvar -&gt; { 0A*; &amp;anim; 2A*};
                 -&gt; { 0B*; &amp;anim; 2B*};
         };
       };
       &gt;&gt;

       The difference between these examples is what happens when myvar changes.  In example  1,  the  animation
       "A, B, C, D" will restart at the beginning (because the two animations are different ones); in example 2,
       the  "same"  animation  is  used  in  both  cases,  so the animation will simply continue.  (Removing the
       ampersands from example 2 will turn the behaviour to the one of example 1.)

</pre><h4><b>THE</b> <b>AI</b> <b>UTILITY</b> <b>FUNCTION</b></h4><pre>
       When deciding how to place the steered falling blobs, the AI player tries to maximize a  certain  utility
       function.    Its   value   is   the   sum   of   the   values   for   both  steered  falling  blobs  plus
       <b>aiu_monochromic_vertical</b> in case both blobs have the same color and  they  get  placed  vertically.   The
       value for a single blob is the sum of the following:

       —  For each new neighbour of blob, the neighbour utility.

       —  <b>aiu_two_above</b>, if the blob is two above a blob of same kind.

       —  <b>aiu_height*20/</b>(the blob's <b>y</b> coordinate).

       The  neighbour  utility  for  a  single new blob and a single one of its new neighbours is the sum of the
       following:

       —  <b>aiu_color</b>, if the neighbour has the same kind as the blob.

       —  <b>aiu_grass</b>, if the neighbour fulfills <b>behaviour.goalblob</b>.

       —  <b>aiu_grey</b>, if the neighbour fulfills <b>behaviour.explodes_on_explosion</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man6/cuyo.6.html">cuyo</a></b>(6)

</pre><h4><b>BUGS</b></h4><pre>
       Probably a lot.  The following are just a few known ones:

       There are several problems with busieness and that stuff.  There are several  situations  in  which  Cual
       doesn't behave in the way I would like, and in other situations I don't know how Cual should behave.

                                                   2014-10-25                                            <u><a href="../man6/CUAL.6.html">CUAL</a></u>(6)
</pre>
 </div>
</div></section>
</div>
</body>
</html>