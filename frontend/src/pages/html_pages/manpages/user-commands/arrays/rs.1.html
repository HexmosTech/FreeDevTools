<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rs — reshape a data array</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/rs">rs_20200313-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rs — reshape a data array

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>rs</b> [<b>-CcSs</b>[<u>x</u>]] [<b>-GgKkw</b> <u>N</u>] [<b>-EeHhjmnTtyz</b>] [<u>rows</u> [<u>cols</u>]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>rs</b>  reads  the  standard  input,  interpreting each line as a row of blank-separated entries in an array,
       transforms the array according to the options, and writes it on the standard output.  With  no  arguments
       (argc <b>&lt;</b> <b>2</b>) it transforms stream input into a columnar format convenient for terminal viewing, i.e. if the
       length (in bytes!) of the first line is smaller than the display width, <b>-et</b> is implied, <b>-t</b> otherwise.

       The  shape  of the input array is deduced from the number of lines and the number of columns on the first
       line.  If that shape is inconvenient, a more useful one might be obtained by skipping some of  the  input
       with the <b>-k</b> option.  Other options control interpretation of the input columns.

       The shape of the output array is influenced by the <u>rows</u> and <u>cols</u> specifications, which should be positive
       integers.   If  only  one  of  them  is  a positive integer, <b>rs</b> computes a value for the other which will
       accommodate all of the data.  When necessary, missing data are supplied in  a  manner  specified  by  the
       options  and  surplus data are deleted.  There are options to control presentation of the output columns,
       including transposition of the rows and columns.

       The options are as follows:

       <b>-C</b>[<u>x</u>]  Output columns are delimited by the single character <u>x</u>.
              A missing <u>x</u> is taken to be ‘^I’.

       <b>-c</b>[<u>x</u>]  Input columns are delimited by the single character <u>x</u>.
              A missing <u>x</u> is taken to be ‘^I’.

       <b>-E</b>     Consider each character of input as an array entry.

       <b>-e</b>     Consider each line of input as an array entry.

       <b>-G</b><u>N</u>    The gutter width (inter-column space) has <u>N</u> percent of the maximum column width added to it.

       <b>-g</b><u>N</u>    The gutter width, normally 2, is taken to be <u>N</u>.

       <b>-H</b>     Like <b>-h</b>, but also print the length of each line.

       <b>-h</b>     Print the shape of the input array and do nothing else.  The shape is just the number of lines and
              the number of entries on the first line.

       <b>-j</b>     Right adjust entries within columns.

       <b>-K</b><u>N</u>    Like <b>-k</b>, but print the ignored lines.

       <b>-k</b><u>N</u>    Ignore the first <u>N</u> lines of input.

       <b>-m</b>     Do not trim excess delimiters from the ends of the output array.

       <b>-n</b>     On lines having fewer entries than the  first  line,  use  null  entries  to  pad  out  the  line.
              Normally, missing entries are taken from the next line of input.

       <b>-S</b>[<u>x</u>]  Like <b>-C</b>, but padded strings of <u>x</u> are delimiters.

       <b>-s</b>[<u>x</u>]  Like <b>-c</b>, but maximal strings of <u>x</u> are delimiters.

       <b>-T</b>     Print the pure transpose of the input, ignoring any <u>rows</u> or <u>cols</u> specification.

       <b>-t</b>     Fill  in the rows of the output array using the columns of the input array, that is, transpose the
              input while honoring any <u>rows</u> and <u>cols</u> specifications.

       <b>-w</b><u>N</u>    The width of the display, normally 80, is taken to be the positive integer <u>N</u>.

       <b>-y</b>     If there are too few entries to make up the output dimensions, pad the  output  by  recycling  the
              input from the beginning.  Normally, the output is padded with blanks.

       <b>-z</b>     Shrink column widths to fit the largest entries appearing in them.

       With  no  arguments, <b>rs</b> transposes its input, and assumes one array entry per input line unless the first
       non-ignored line is longer than the  display  width.   Option  letters  which  take  numerical  arguments
       interpret a missing number as zero unless otherwise indicated.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       LC_CTYPE  The  character  encoding  <u><a href="../man1/locale.1.html">locale</a></u>(1).   It decides which byte sequences form characters and what
                 their display width is.  If unset or set to "<b>C</b>", "<b>POSIX</b>" or an unsupported value, each byte  is
                 treated as a character of display width 1.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>rs</b>  can  be  used  as  a  filter to convert the stream output of certain programs (e.g., <u><a href="../man1/spell.1.html">spell</a></u>(1), <u><a href="../man1/du.1.html">du</a></u>(1),
       <u><a href="../man1/file.1.html">file</a></u>(1), <u><a href="../man1/look.1.html">look</a></u>(1), <u><a href="../man1/nm.1.html">nm</a></u>(1), <u><a href="../man1/who.1.html">who</a></u>(1), and <u><a href="../man1/wc.1.html">wc</a></u>(1)) into a convenient “window” format, as in

             $ who | rs

       This function has been incorporated into the <u><a href="../man1/ls.1.html">ls</a></u>(1) program, though for most programs with similar  output
       <b>rs</b> suffices.

       To convert stream input into vector output and back again, use

             $ rs 1 0 | rs 0 1

       A 10 by 10 array of random numbers from 1 to 100 and its transpose can be generated with

             $ jot -r 100 | rs 10 10 | tee array | rs -T &gt;tarray

       In  the  editor  <u><a href="../man1/vi.1.html">vi</a></u>(1),  a  file  consisting  of a multi-line vector with 9 elements per line can undergo
       insertions and deletions, and then be neatly reshaped into 9 columns with

             :1,$!rs 0 9

       Finally, to sort a database by the first line of each 4-line field, try

             $ rs -eC 0 4 | sort | rs -c 0 1

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/jot.1.html">jot</a></u>(1), <u><a href="../man1/pr.1.html">pr</a></u>(1), <u><a href="../man1/sort.1.html">sort</a></u>(1), <u><a href="../man1/vi.1.html">vi</a></u>(1)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>rs</b> utility first appeared in 4.2BSD.

</pre><h4><b>AUTHORS</b></h4><pre>
       John A. Kunze

</pre><h4><b>BUGS</b></h4><pre>
       Handles only two dimensional arrays.

       The algorithm currently reads the whole file into memory, so files that do not fit in memory will not  be
       reshaped.

       Fields cannot be defined yet on character positions.

       Re-ordering of columns is not yet possible.

       There are too many options.

Debian                                           March 13, 2020                                            <u><a href="../man1/RS.1.html">RS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>