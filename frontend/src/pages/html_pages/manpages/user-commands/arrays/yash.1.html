<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yash - a POSIX-compliant command line shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/yash">yash_2.55-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       yash - a POSIX-compliant command line shell

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>yash</b> <b>[options...]</b> <b>[--]</b> <b>[operands...]</b>

</pre><h4><b>INTRODUCTION</b></h4><pre>
       <u>Yet</u> <u>another</u> <u>shell</u> (yash) is a command line shell for UNIX-like operating systems. The shell conforms to
       the POSIX.1-2008 standard (for the most parts), and actually is more conforming than other
       POSIX-conforming shells. Moreover, it has many features that are used for interactive use, such as
       command history and command line editing.

       This program can be freely modified and redistributed under the terms of GNU General Public License
       (Version 2). <b>Use</b> <b>of</b> <b>this</b> <b>program</b> <b>is</b> <b>all</b> <b>at</b> <b>your</b> <b>own</b> <b>risk.</b> <b>There</b> <b>is</b> <b>no</b> <b>warranty</b> <b>and</b> <b>the</b> <b>author</b> <b>is</b> <b>not</b>
       <b>responsible</b> <b>for</b> <b>any</b> <b>consequences</b> <b>caused</b> <b>by</b> <b>use</b> <b>of</b> <b>this</b> <b>program.</b>

       This manual can be freely modified and redistributed under the terms of Creative Commons
       Attribution-ShareAlike 2.1 Japan.

       Yash is developed and maintained by 渡邊裕貴 (WATANABE Yuki) aka Magicant. Yash development project and
       Yash’s homepage are hosted by OSDN.

</pre><h4><b>INVOCATION</b></h4><pre>
       When invoked as a program, yash performs the predefined initialization steps and repeatedly reads and
       executed commands. Command line arguments given in the invocation determines how the shell initializes
       itself and executes commands.

   <b>Command</b> <b>line</b> <b>arguments</b>
       The syntax of command line arguments for yash conforms to POSIX. As defined in POSIX, arguments are
       separated into <u>options</u> and <u>operands</u>. For more detailed explanation about options and operands, see
       Command argument syntax. All options must come before operands. The interpretation of operands depends on
       options specified.

       When you specify the <b>-c</b> (<b>--cmdline</b>) option, you must give at least one operand. The shell interprets and
       executes the first operand as a command string. The second operand, if any, is used to initialize the <b>0</b>
       special parameter. The other operands, if any, are used to initialize the positional parameters. When the
       <b>-c</b> (<b>--cmdline</b>) option is specified, the shell does not read any file or the standard input (unless the
       dot built-in is used).

       If you specify the <b>-s</b> (<b>--stdin</b>) option, the shell reads the standard input, interprets the input as
       commands, and executes them. All the operands given are used to initialize the positional parameters. The
       <b>0</b> special parameter is initialized to the name the shell is invoked as.

       If you specify neither the <b>-c</b> (<b>--cmdline</b>) nor <b>-s</b> (<b>--stdin</b>) option, the shell reads a file, interprets the
       file contents as commands, and executes them. The first operand specifies the pathname of the file. The
       remaining operands are used to initialize the positional parameters. If you do not give any operands, the
       shell reads the standard input as if the <b>-s</b> (<b>--stdin</b>) option is specified.

       You cannot use both the <b>-c</b> (<b>--cmdline</b>) and <b>-s</b> (<b>--stdin</b>) options at a time.

       If you specify either the <b>--help</b> or <b>-V</b> (<b>--version</b>) option, the shell never performs the usual
       initialization or command execution. Instead, it just prints brief usage (for <b>--help</b>) or version
       information (for <b>-V</b> and <b>--version</b>). If the <b>-V</b> (<b>--version</b>) option is accompanied by the <b>-v</b> (<b>--verbose</b>)
       option, the shell prints a list of the available optional features as well.

       If you specify the <b>-i</b> (<b>--interactive</b>) option, the shell goes into the interactive mode. If you specify
       the <b>+i</b> (<b>++interactive</b>) option, conversely, the shell never goes into the interactive mode.

       If you specify the <b>-l</b> (<b>--login</b>) option, the shell behaves as a login shell.

       The <b>--noprofile</b>, <b>--norcfile</b>, <b>--profile</b>, and <b>--rcfile</b> options determine how the shell is initialized (see
       below for details).

       In addition to the options described above, you can specify options that can be specified to the set
       built-in.

       If the first operand is <b>-</b> and the options and the operands are not separated by <b>--</b>, the first operand is
       ignored.

   <b>Initialization</b> <b>of</b> <b>yash</b>
       Yash initializes itself as follows:

        1. Yash first parses the name it was invoked as. If the name starts with <b>-</b>, the shell behaves as a login
           shell. If the name is <b>sh</b> (including names such as <b><a href="file:/bin/sh">/bin/sh</a></b>), the shell goes into the POSIXly-correct
           mode.

        2. If no operands are given and the standard input and standard error are both connected to a terminal,
           the shell goes into the interactive mode unless the <b>+i</b> (<b>++interactive</b>) option is specified.

        3. Job control is automatically enabled in an interactive shell unless the <b>+m</b> (<b>++monitor</b>) option is
           specified.

        4. Yash reads and executes commands from the following files (unless the real and effective user IDs of
           the shell process are different or the real and effective group IDs of the shell process are
           different):

            1. If it is behaving as a login shell, the shell reads the file specified by the <b>--profile=</b><u>filename</u>
               option unless the <b>--noprofile</b> option is specified or the shell is in the POSIXly-correct mode.

               If the <b>--profile=</b><u>filename</u> option is not specified, the shell reads <a href="file:~/.yash_profile">~/.yash_profile</a> as a default.

            2. If in the interactive mode, the shell reads the file specified by the <b>--rcfile=</b><u>filename</u> option
               unless the <b>--norcfile</b> option is specified.

               If the <b>--rcfile=</b><u>filename</u> option is not specified, the shell instead reads the following files:

               •   If not in the POSIXly-correct mode, the shell reads <a href="file:~/.yashrc.">~/.yashrc.</a> If it cannot be read, the
                   shell searches <b>YASH_LOADPATH</b> for a file named initialization/default.

               •   If in the POSIXly-correct mode, the shell performs parameter expansion on the value of the
                   <b>ENV</b> environment variable and treats the expansion result as the name of the file to read.

           <b>Note</b>

           Yash never automatically reads <a href="file:/etc/profile">/etc/profile</a>, /etc/yashrc, nor <a href="file:~/.profile.">~/.profile.</a>

</pre><h4><b>SYNTAX</b></h4><pre>
       The shell reads, parses, and executes command line by line. If there is more than one command on a line,
       all the commands are parsed before executed. If a command is continued to next lines, the shell reads
       more enough lines to complete the command. On a syntax error, the shell neither reads nor executes any
       more commands.

   <b>Tokens</b> <b>and</b> <b>keywords</b>
       A command is composed of one or more tokens. In the shell syntax, a <u>token</u> is a word that is part of a
       command. Normally, tokens are separated by whitespaces, that is, the space or tab character. Whitespaces
       inside a command substitution or a parameter expansion, however, do not separate tokens.

       The following symbols have special meanings in the shell syntax and in most cases separate tokens:

           ; &amp; | &lt; &gt; ( ) [newline]

       The following symbols do not separate tokens, but have syntactic meanings:

           $ ` \ " ' * ? [ # ~ = %

       The following tokens are treated as <u>keywords</u> depending on the context in which they appear:

           ! { } [[ case do done elif else esac fi
           for function if in then until while

       A token is treated as a keyword when:

       •   it is the first token of a command,

       •   it follows another keyword (except <b>case</b>, <b>for</b>, and <b>in</b>), or

       •   it is a non-first token of a command and is supposed to be a keyword to compose a composite command.

       If a token begins with <b>#</b>, then the <b>#</b> and any following characters up to the end of the line are treated
       as a <u>comment</u>, which is completely ignored in syntax parsing.

   <b>Quotations</b>
       If you want whitespaces, separator characters, or keywords described above to be treated as a normal
       characters, you must quote the characters using appropriate quotation marks. Quotation marks are not
       treated as normal characters unless they are themselves quoted. You can use the following three quotation
       marks:

       •   A backslash (<b>\</b>) quotes a character that immediately follows.

           The only exception about a backslash is the case where a backslash is followed by a newline. In this
           case, the two characters are treated as a <u>line</u> <u>continuation</u> rather than a newline being quoted. The
           two characters are removed from the input and the two lines surrounding the line continuation are
           concatenated into a single line.

       •   A pair of single-quotation marks (<b>'</b>) quote any characters between them except another
           single-quotation. Note that newlines can be quoted using single-quotations.

       •   Double-quotation marks (<b>"</b>) are like single-quotations, but they have a few exceptions: Parameter
           expansion, command substitution, and arithmetic expansion are interpreted as usual even between
           double-quotations. A backslash between double-quotations is treated as a quotation mark only when it
           is followed by <b>$</b>, <b>`</b>, <b>"</b>, <b>\</b>, or a newline; other backslashes are treated as normal characters.

   <b>Aliases</b>
       Tokens that compose a command are subject to <u>alias</u> <u>substitution</u>. A token that matches the name of an
       alias that has already been defined is substituted with the value of the alias before the command is
       parsed.

       Tokens that contain quotations are not alias-substituted since an alias name cannot contain quotation
       marks. Keywords and command separator characters are not alias-substituted either.

       There are two kinds of aliases: normal aliases and global aliases. A <u>normal</u> <u>alias</u> can only substitute the
       first token of a command while a <u>global</u> <u>alias</u> can substitute any part of a command. Global aliases are
       yash extension that is not defined in POSIX.

       If a token is alias-substituted with the value of a normal alias that ends with a whitespace, the next
       token is exceptionally subject to alias substitution for normal aliases.

       The results of alias substitution are again subject to alias substitution for other aliases (but not for
       the aliases that have been already applied).

       You can define aliases using the alias built-in and remove using the unalias built-in.

   <b>Simple</b> <b>commands</b>
       A command that does not start with a keyword token is a <u>simple</u> <u>command</u>. Simple commands are executed as
       defined in Execution of simple commands.

       If the first and any number of following tokens of a simple command have the form <u>name</u><b>=</b><u>value</u>, they are
       interpreted as variable assignments. A variable name must consist of one or more alphabets, digits and/or
       underlines (<b>_</b>) and must not start with a digit. The first token that is not a variable assignment is
       considered as a command name and all the following tokens (whether or not they have the form <u>name</u><b>=</b><u>value</u>)
       as command arguments.

       A variable assignment of the form <u>var</u><b>=(</b><u>tokens</u><b>)</b> is interpreted as assignment to an array. You can write
       any number of tokens between a pair of parentheses. Tokens can be separated by not only spaces and tabs
       but also newlines.

   <b>Pipelines</b>
       A <u>pipeline</u> is a sequence of one or more simple commands, compound commands, and/or function definitions
       that are separated by <b>|</b>.

       A pipeline that has more than one subcommand is executed by executing each subcommand of the pipeline in
       a subshell simultaneously. The standard output of each subcommand except the last one is redirected to
       the standard input of the next subcommand. The standard input of the first subcommand and the standard
       output of the last subcommand are not redirected.

       The exit status of the pipeline is that of the last subcommand unless the pipe-fail option is enabled, in
       which case the exit status of the pipeline is that of the last subcommand that exits with a non-zero exit
       status. If all the subcommands exit with an exit status of zero, the exit status of the pipeline is also
       zero.

       A pipeline can be prefixed by <b>!</b>, in which case the exit status of the pipeline is <u>reversed</u>: the exit
       status of the pipeline is 1 if that of the last subcommand is 0, and 0 otherwise.

       Korn shell treats a word of the form <b>!(...)</b> as an extended pathname expansion pattern that is not defined
       in POSIX. In the POSIXly-correct mode, the tokens <b>!</b> and <b>(</b> must be separated by one or more white spaces.

           <b>Note</b>

           When the execution of a pipeline finishes, at least the execution of the last subcommand has finished
           since the exit status of the last subcommand defines that of the whole pipeline. The execution of
           other subcommands, however, may not have finished then. On the other hand, the execution of the
           pipeline may not finish soon after that of the last subcommand finished because the shell may choose
           to wait for the execution of other subcommands to finish.

           <b>Note</b>

           The POSIX standard allows executing any of subcommands in the current shell rather than subshells,
           though yash does not do so.

   <b>And/or</b> <b>lists</b>
       An <u>and/or</u> <u>list</u> is a sequence of one or more pipelines separated by <b>&amp;&amp;</b> or <b>||</b>.

       An and/or list is executed by executing some of the pipelines conditionally. The first pipeline is always
       executed. The other pipelines are either executed or not executed according to the exit status of the
       previous pipelines.

       •   If two pipelines are separated by <b>&amp;&amp;</b> and the exit status of the first pipeline is zero, the second
           pipeline is executed.

       •   If two pipelines are separated by <b>||</b> and the exit status of the first pipeline is not zero, the
           second pipeline is executed.

       •   In other cases, the execution of the and/or list ends: the second and any remaining pipelines are not
           executed.

       The exit status of an and/or list is that of the last pipeline that was executed.

       Normally, an and/or list must be terminated by a semicolon, ampersand, or newline. See Command separators
       and asynchronous commands.

   <b>Command</b> <b>separators</b> <b>and</b> <b>asynchronous</b> <b>commands</b>
       The whole input to the shell must be composed of any number of and/or lists separated by a semicolon or
       ampersand. A terminating semicolon can be omitted if it is followed by <b>;;</b>, <b>)</b>, or a newline. Otherwise, an
       and/or list must be terminated by a semicolon or ampersand.

       If an and/or list is terminated by a semicolon, it is executed synchronously: the shell waits for the
       and/or list to finish before executing the next and/or list. If an and/or list is terminated by an
       ampersand, it is executed asynchronously: after the execution of the and/or list is started, the next
       and/or list is executed immediately. An asynchronous and/or list is always executed in a subshell and its
       exit status is zero.

       If the shell is not doing job control, the standard input of an asynchronous and/or list is automatically
       redirected to /dev/null. Signal handlers of the and/or list for the SIGINT and SIGQUIT signals are set to
       “ignore” the signal so that the execution of the and/or list cannot be stopped by those signals.

       When the execution of an asynchronous and/or list is started, the shell remembers its process ID. You can
       obtain the ID by referencing the <b>!</b> special parameter. You can obtain the current and exit status of the
       asynchronous list as well by using the jobs and wait built-ins.

   <b>Compound</b> <b>commands</b>
       Compound commands provide you with programmatic control of shell command execution.

       <b>Grouping</b>

           A grouping is a list of commands that is treated as a simple command.

           Normal grouping syntax
               <b>{</b> <u>command</u><b>...;</b> <b>}</b>

           Subshell grouping syntax
               <b>(</b><u>command</u><b>...)</b>

           The <b>{</b> and <b>}</b> tokens are keywords, which must be separated from other tokens. The <b>(</b> and <b>)</b> tokens,
           however, are special separators that need not to be separated.

           In the normal grouping syntax, the commands in a grouping are executed in the current shell. In the
           subshell grouping syntax, the commands are executed in a new subshell.

           In the POSIXly-correct mode, a grouping must contain at least one command. If the shell is not in the
           POSIXly-correct mode, a grouping may contain no commands.

           The exit status of a grouping is that of the last command in the grouping. If the grouping contains
           no commands, its exit status is that of the last executed command before the grouping.

       <b>If</b> <b>command</b>

           The if command performs a conditional branch.

           Basic if command syntax
               <b>if</b> <u>condition</u><b>...;</b> <b>then</b> <u>body</u><b>...;</b> <b>fi</b>

           Syntax with the else clause
               <b>if</b> <u>condition</u><b>...;</b> <b>then</b> <u>body</u><b>...;</b> <b>else</b> <u>body</u><b>...;</b> <b>fi</b>

           Syntax with the elif clause
               <b>if</b> <u>condition</u><b>...;</b> <b>then</b> <u>body</u><b>...;</b> <b>elif</b> <u>condition</u><b>...;</b> <b>then</b> <u>body</u><b>...;</b> <b>fi</b>

           Syntax with the elif clause
               <b>if</b> <u>condition</u><b>...;</b> <b>then</b> <u>body</u><b>...;</b> <b>elif</b> <u>condition</u><b>...;</b> <b>then</b> <u>body</u><b>...;</b> <b>else</b> <u>body</u><b>...;</b> <b>fi</b>

           For all the syntaxes, the execution of an if command starts with the execution of the <u>condition</u>
           commands that follows the <b>if</b> token. If the exit status of the condition commands is zero, the
           condition is considered as “true”. In this case, the <u>body</u> commands that follows the <b>then</b> token are
           executed and the execution of the if command finishes. If the exit status of the condition commands
           is non-zero, the condition is considered as “false”. In this case, the <u>condition</u> commands for the
           next elif clause are executed and the exit status is tested in the same manner as above. If there is
           no elif clause, the <u>body</u> commands that follow the <b>else</b> token are executed and the execution of the if
           command finishes. If there is no else clause either, the execution of the if command just ends.

           An if command may have more than one elif-then clause.

           The exit status of an if command is that of the <u>body</u> commands that were executed. The exit status is
           zero if no <u>body</u> commands were executed, that is, all the conditions were false and there was no else
           clause.

       <b>While</b> <b>and</b> <b>until</b> <b>loops</b>

           The while loop and until loop are simple loops with condition.

           While loop syntax
               <b>while</b> <u>condition</u><b>...;</b> <b>do</b> <u>body</u><b>...;</b> <b>done</b>

           Until loop syntax
               <b>until</b> <u>condition</u><b>...;</b> <b>do</b> <u>body</u><b>...;</b> <b>done</b>

           If the shell is not in the POSIXly-correct mode, you can omit the <u>condition</u> and/or <u>body</u> commands of a
           while/until loop.

           The execution of a while loop is started by executing the <u>condition</u> commands. If the exit status of
           the <u>condition</u> commands is zero, the shell executes the <u>body</u> commands and returns to the execution of
           the <u>condition</u> commands. The <u>condition</u> and <u>body</u> commands are repeatedly executed until the exit status
           of the <u>condition</u> commands is non-zero.

               <b>Note</b>

               The <u>body</u> commands are not executed at all if the first execution of the <u>condition</u> commands yields
               a non-zero exit status.

           An until loop is executed in the same manner as a while loop except that the condition to repeat the
           loop is reversed: the <u>body</u> commands are executed when the exit status of the <u>condition</u> commands is
           non-zero.

           The exit status of a while/until loop is that of the last executed <u>body</u> command. The exit status is
           zero if the <u>body</u> commands are empty or were not executed at all.

       <b>For</b> <b>loop</b>

           The for loop repeats commands with a variable assigned one of given values in each round.

           For loop syntax
               <b>for</b> <u>varname</u> <b>in</b> <u>word</u><b>...;</b> <b>do</b> <u>command</u><b>...;</b> <b>done</b>

               <b>for</b> <u>varname</u> <b>do</b> <u>command</u><b>...;</b> <b>done</b>

           The <u>word</u> list after the <b>in</b> token may be empty, but the semicolon (or newline) before the <b>do</b> token is
           required even in that case. The <u>word</u>s are not treated as keywords, but you need to quote separator
           characters (such as <b>&amp;</b> and <b>|</b>) to include them as part of a <u>word</u>. The <u>command</u> list may be empty if not
           in the POSIXly-correct mode.

           The <u>varname</u> must be a portable (ASCII-only) name in the POSIXly-correct mode.

           The execution of a for loop is started by expanding the <u>word</u>s in the same manner as in the execution
           of a simple command. If the <b>in</b> and <u>word</u> tokens are omitted, the shell assumes the <u>word</u> tokens to be
           <b>"$@"</b>. Next, the following steps are taken for each word expanded (in the order the words were
           expanded):

            1. Assign the word to the variable whose name is <u>varname</u>.

            2. Execute the <u>command</u>s.

           By default, if a for loop is executed within a function, <u>varname</u> is created as a local variable, even
           if it already exists globally. Turning off the for-local shell option or enabling the POSIXly-correct
           mode mode will disable this behavior.

           If the expansion of the <u>word</u>s yields no words, no variable is created and the <u>command</u>s are not
           executed at all.

           The exit status of a for loop is that of the last executed <u>command</u>. The exit status is zero if the
           <u>command</u>s are not empty and not executed at all. If the <u>command</u>s are empty, the exit status is that of
           the last executed command before the for loop.

           If the variable is read-only, the execution of the for loop is interrupted and the exit status will
           be non-zero.

       <b>Case</b> <b>command</b>

           The case command performs a pattern matching to select commands to execute.

           Case command syntax
               <b>case</b> <u>word</u> <b>in</b> <u>caseitem</u><b>...</b> <b>esac</b>

           Case item syntax
               <b>(</b><u>patterns</u><b>)</b> <u>command</u><b>...;;</b>

           The <u>word</u> between the <b>case</b> and <b>in</b> tokens must be exactly one word. The <u>word</u> is not treated as a
           keyword, but you need to quote separator characters (such as <b>&amp;</b> and <b>|</b>) to include them as part of the
           <u>word</u>. Between the <b>in</b> and <b>esac</b> tokens you can put any number of case items (may be none). You can omit
           the first <b>(</b> token of a case item and the last <b>;;</b> token before the <b>esac</b> token. If the last <u>command</u> of
           a case item is terminated by a semicolon, you can omit the semicolon as well. The <u>command</u>s in a case
           item may be empty.

           The <u>patterns</u> in a case item are one or more tokens each separated by a <b>|</b> token.

           The execution of a case command starts with subjecting the <u>word</u> to the four expansions. Next, the
           following steps are taken for each case item (in the order of appearance):

            1. For each word in the <u>patterns</u>, expand the word in the same manner as the <u>word</u> and test if the
               expanded pattern matches the expanded word. (If a pattern is found that matches the word, the
               remaining patterns are not expanded nor tested, so some of the <u>patterns</u> may not be expanded. Yash
               expands and tests the patterns in the order of appearance, but it may not be the case for other
               shells.)

            2. If one of the <u>patterns</u> was found to match the <u>word</u> in the previous step, the <u>command</u>s in this
               case item are executed and the execution of the whole case item ends. Otherwise, proceed to the
               next case item.

           The exit status of a case command is that of the <u>command</u>s executed. The exit status is zero if no
           <u>command</u>s were executed, that is, there were no case items, no matching pattern was found, or no
           commands were associated with the matching pattern.

           In the POSIXly-correct mode, the first pattern in a case item cannot be <b>esac</b> (even if you do not omit
           the <b>(</b> token).

       <b>Double-bracket</b> <b>command</b>

           The <u>double-bracket</u> <u>command</u> is a syntactic construct that works similarly to the test built-in. It
           expands and evaluates the words between the brackets.

           Double-bracket command syntax
               <b>[[</b> <u>expression</u> <b>]]</b>

           The <u>expression</u> can be a single primary or combination of primaries and operators. The expression
           syntax is parsed when the command is parsed, not executed. Operators (either primary or non-primary)
           must not be quoted, or it will be parsed as a normal word.

           When the command is executed, operand words are subjected to the four expansions, but not brace
           expansion, field splitting, or pathname expansion.

           In the double-bracket command, the following primaries from the test built-in can be used:

           Unary primaries
               <b>-b</b>, <b>-c</b>, <b>-d</b>, <b>-e</b>, <b>-f</b>, <b>-G</b>, <b>-g</b>, <b>-h</b>, <b>-k</b>, <b>-L</b>, <b>-N</b>, <b>-n</b>, <b>-O</b>, <b>-o</b>, <b>-p</b>, <b>-r</b>, <b>-S</b>, <b>-s</b>, <b>-t</b>, <b>-u</b>, <b>-w</b>, <b>-x</b>, <b>-z</b>

           Binary primaries
               <b>-ef</b>, <b>-eq</b>, <b>-ge</b>, <b>-gt</b>, <b>-le</b>, <b>-lt</b>, <b>-ne</b>, <b>-nt</b>, <b>-ot</b>, <b>-veq</b>, <b>-vge</b>, <b>-vgt</b>, <b>-vle</b>, <b>-vlt</b>, <b>-vne</b>, <b>===</b>, <b>!==</b>, <b>=~</b>, <b>&lt;</b>,
               <b>&gt;</b>

           Additionally, some binary primaries can be used to compare strings, which works slightly differently
           from those for the test built-in: The <b>=</b> primary treats the right-hand-side operand word as a pattern
           and tests if it matches the left-hand-side operand word. The <b>==</b> primary is the same as <b>=</b>. The <b>!=</b>
           primary is negation of the <b>=</b> primary (reverse result).

           The operand word of a primary must be quoted if it is <b>]]</b> or can be confused with another primary
           operator.

               <b>Note</b>

               More primaries may be added in future versions of the shell. You should quote any words that
               start with a hyphen.

               <b>Note</b>

               The <b>&lt;=</b> and <b>&gt;=</b> binary primaries cannot be used in the double-bracket command because it cannot be
               parsed correctly in the shell grammar.

           The following operands (listed in the descending order of precedence) can be used to combine
           primaries:

           <b>(</b> <u>expression</u> <b>)</b>
               A pair of parentheses change operator precedence.

           <b>!</b> <u>expression</u>
               An exclamation mark negates (reverses) the result.

           <u>expression</u> <b>&amp;&amp;</b> <u>expression</u>
               A double ampersand represents logical conjugation (the “and” operation). The entire expression is
               true if and only if the operand expressions are both true. The left-hand-side expression is first
               expanded and tested. The right-hand-side is expanded only if the left-hand-side is true.

           <u>expression</u> <b>||</b> <u>expression</u>
               A double vertical line represents logical conjugation (the “or” operation). The entire expression
               is false if and only if the operand expressions are both false. The left-hand-side expression is
               first expanded and tested. The right-hand-side is expanded only if the left-hand-side is false.

               <b>Note</b>

               Unlike the test built-in, neither <b>-a</b> nor <b>-o</b> can be used as a binary operator in the
               double-bracket command.

           The exit status of the double-bracket command is 0 if <u>expression</u> is true, 1 if false, and 2 if it
           cannot be evaluated because of expansion error or any other reasons.

               <b>Note</b>

               The double-bracket command is also supported in bash, ksh, mksh, and zsh, but not defined in the
               POSIX standard. The behavior slightly differs between the shells. The test built-in should be
               preferred over the double-bracket command for maximum portability.

   <b>Function</b> <b>definition</b>
       The function definition command defines a function.

       Function definition syntax
           <u>funcname</u> <b>(</b> <b>)</b> <u>compound_command</u>

           <b>function</b> <u>funcname</u> <u>compound_command</u>

           <b>function</b> <u>funcname</u> <b>(</b> <b>)</b> <u>compound_command</u>

       In the first syntax without the <b>function</b> keyword, <u>funcname</u> cannot contain any special characters such as
       semicolons and quotation marks. In the second and third syntax, which cannot be used in the
       POSIXly-correct mode, <u>funcname</u> is subjected to the four expansions when executed. In the POSIXly-correct
       mode, <u>funcname</u> is limited to a portable (ASCII-only) name.

       When a function definition command is executed, a function whose name is <u>funcname</u> is defined with its
       body being <u>compound_command</u>.

       A function definition command cannot be directly redirected. Any redirections that follow a function
       definition are associated with <u>compound_command</u> rather than the whole function definition command. In
       <b>func()</b> <b>{</b> <b>cat;</b> <b>}</b> <b>&gt;/dev/null</b>, for example, it is not <b>func()</b> <b>{</b> <b>cat;</b> <b>}</b> but <b>{</b> <b>cat;</b> <b>}</b> that is redirected.

       The exit status of a function definition is zero if the function was defined without errors, and non-zero
       otherwise.

</pre><h4><b>PARAMETERS</b> <b>AND</b> <b>VARIABLES</b></h4><pre>
       <u>Parameters</u> are string values that are expanded in parameter expansion. There are three types of
       parameters: positional parameters, special parameters and variables.

   <b>Positional</b> <b>parameters</b>
       <u>Positional</u> <u>parameters</u> are parameters that are identified by natural numbers. If there are three
       positional parameters, for example, they are identified as <b>1</b>, <b>2</b>, and <b>3</b>. You can obtain the number of
       positional parameters by the <b>#</b> special parameter. The <b>*</b> and <b>@</b> special parameters are expanded to all
       positional parameters.

       Positional parameters are initialized from the shell’s command line arguments when the shell is started
       (see Command line arguments). In the initialization, the order of the operands are preserved as the order
       of the positional parameters.

       When the shell executes a function call, positional parameters are changed to the arguments to the
       function call so that you can access the arguments while the function is being executed. Positional
       parameters are restored to the original values when the execution of the function is finished.

       Positional parameters can be manipulated by built-in commands like set and shift.

       Note that <b>0</b> is not a positional parameter but a special parameter.

   <b>Special</b> <b>parameters</b>
       <u>Special</u> <u>parameters</u> are parameters each identified by a single symbol. They cannot be directly assigned to
       by the user.

       Yash provides the following special parameters:

       <b>0</b>
           The name of the shell executable file or the script file that was specified in the invocation of the
           shell.

       <b>#</b>
           The number of current positional parameters. The value is a non-negative integer.

       <b>$</b>
           The process ID of the shell. The value is a positive integer and is never changed even in subshells.

       <b>-</b>
           Currently enabled shell options. The value is a concatenation of alphabet characters that are the
           names of currently enabled single-character options that can be specified in shell invocation. The
           value reflects changes of enabled options when you enable or disable options using the set built-in.

       <b>?</b>
           The exit status of the last executed pipeline. The value is a non-negative integer.

       <b>!</b>
           The process ID of the last executed asynchronous list.

       <b>*</b>
           This special parameter represents the whole positional parameters. When there is no positional
           parameters, the value of this special parameter is the empty string. When there is more than one
           positional parameter, the value is a concatenation of all the positional parameters, each of which is
           separated as follows:

           •   If the <b>IFS</b> variable exists and its value is not empty, positional parameters are each separated
               by the first character of the value of the <b>IFS</b> variable.

           •   If the <b>IFS</b> variable exists and has an empty value, positional parameters are just concatenated
               without any separator.

           •   If the <b>IFS</b> variable does not exist, positional parameters are each separated by a space
               character.

           If field-splitting is applied to an expansion result of this parameter, the value is first split into
           the original positional parameters and then further split depending on the current <b>IFS</b> variable. The
           first splitting is performed even if the <b>IFS</b> variable is empty.

       <b>@</b>
           This special parameter represents the whole positional parameters like the <b>*</b> special parameter above.
           The difference between the two is the results of expansion that occurs between a pair of
           double-quotation marks. If the <b>@</b> special parameter is expanded inside double-quotations, the result
           is field-split into the exact positional parameter values. If there are no positional parameters, the
           expansion yields no word rather than an empty word. (Even if the expansion is double-quoted, the
           result is not always a single word.)

           •   When there are no positional parameters, the command words <b>echo</b> <b>1</b> <b>"$@"</b> <b>2</b> are expanded to the
               three words <b>echo</b>, <b>1</b>, and <b>2</b>.

           •   When positional parameters are the three words <b>1</b>, <b>2</b> <b>2</b>, and <b>3</b>, the command words <b>echo</b> <b>"$@"</b> are
               expanded to the four words <b>echo</b>, <b>1</b>, <b>2</b> <b>2</b>, and <b>3</b>, and the words <b>echo</b> <b>"a$@b"</b> to the four words <b>echo</b>,
               <b>a1</b>, <b>2</b> <b>2</b>, and <b>3b</b>.

   <b>Variables</b>
       <u>Variables</u> are parameters the user can assign values to. Each variable has a name that identifies it and a
       value that defines the results of expansion.

       A variable name is composed of one or more alphanumeric characters and underscores (<b>_</b>). A name cannot
       start with a digit. Other characters may be used in a name depending on internationalization support of
       your environment.

       Variables that are exported to external commands are called <u>environment</u> <u>variables</u>. They are passed to all
       external commands the shell invokes. Variables passed to the shell in invocation will be automatically
       exported.

       You can assign to variables by a simple command as well as the typeset built-in. You can remove variables
       by using the unset built-in.

       <b>Variables</b> <b>used</b> <b>by</b> <b>the</b> <b>shell</b>

           The following variables are used by the shell for special purposes.

           <b>CDPATH</b>
               This variable is used by the cd built-in to find a destination directory.

           <b>COLUMNS</b>
               This variable specifies the width (the number of character columns) of the terminal screen. The
               value affects the display of line-editing.

           <b>COMMAND_NOT_FOUND_HANDLER</b>
               When the shell cannot find a command to be executed, the value of this variable is interpreted
               and executed instead. You can override the shell’s error handling behavior with this variable.
               See Execution of simple commands for detail.

               This feature is disabled in the POSIXly-correct mode.

           <b>DIRSTACK</b>
               This array variable is used by the shell to store the directory stack contents. If you modify the
               value of this variable, the directory stack may be corrupted.

           <b>ECHO_STYLE</b>
               This variable specifies the behavior of the echo built-in.

           <b>ENV</b>
               When an interactive shell is started in the POSIXly-correct mode, the value of this variable is
               used to find the initialization file. See Initialization of yash.

           <b>FCEDIT</b>
               This variable specifies an editor program used to edit command lines during execution of the fc
               built-in.

           <b>HANDLED</b>
               This variable can be set in the command-not-found handler to tell the shell not to produce a
               further error message. See Execution of simple commands for detail.

           <b>HISTFILE</b>
               This variable specifies the pathname of the file to save the command history in.

           <b>HISTRMDUP</b>
               This variable specifies the number of command history items to be checked for duplication. When
               the shell is adding a new history item to the command history, if some of the most recent <u>n</u> items
               have the same contents as the new one, then the duplicate existing items are removed from the
               history before the new one is added, where <u>n</u> is the value of this variable.

               If the value of this variable is <b>1</b>, for example, the most recent item is removed when a new item
               that have the same contents is added.

               Items older than the <u>n</u>th recent item are not removed. No items are removed if the value of this
               variable is <b>0</b>. All items are subject to removal if the variable value is greater than or equal to
               the value of the <b>HISTSIZE</b> variable.

           <b>HISTSIZE</b>
               This variable specifies the maximum number of items in the command history.

           <b>HOME</b>
               This variable specifies the pathname of the user’s home directory and affects results of tilde
               expansion and cd built-in.

           <b>IFS</b>
               This variable specifies separators used in field splitting. The variable value is initialized to
               the three characters of a space, a tab, and a newline when the shell is started.

           <b>LANG</b>, <b>LC_ALL</b>, <b>LC_COLLATE</b>, <b>LC_CTYPE</b>, <b>LC_MESSAGES</b>, <b>LC_MONETARY</b>, <b>LC_NUMERIC</b>, <b>LC_TIME</b>
               These variables specify a locale in which the shell runs. The shell chooses the file input/output
               encoding, the error message language, etc. according to the locale specified.

               Unless the shell is interactive and not in the POSIXly-correct mode, the value of the <b>LC_CTYPE</b>
               variable is considered only when the shell is started. Once the shell has been initialized,
               changing the value of <b>LC_CTYPE</b> will have no effect on the shell’s behavior.

           <b>LINENO</b>
               The value of this variable is automatically set to the line number in which the currently
               executed command appears in the file.

               In the interactive shell, the line number is reset to 1 each time the shell reads and executes a
               command.

               If you assign to or remove this variable, it will no longer provide line numbers.

           <b>LINES</b>
               This variable specifies the height (the number of character lines) of the terminal screen. The
               value affects the display of line-editing.

           <b>MAIL</b>
               This variable specifies the pathname of a file that is checked in mail checking.

           <b>MAILCHECK</b>
               This variable specifies how often the shell should do mail checking. The value has to be
               specified as a positive integer in seconds. The value is initialized to the default value of <b>600</b>
               when the shell is started.

           <b>MAILPATH</b>
               This variable specifies the pathnames of files that are checked in mail checking.

           <b>NLSPATH</b>
               The POSIX standard prescribes that the value of this variable specifies pathname templates of
               locale-dependent message data files, but yash does not use it.

           <b>OLDPWD</b>
               This variable is set to the previous working directory path when you change the working directory
               by using the cd or other built-ins. This variable is exported by default.

           <b>OPTARG</b>
               When the getopts built-in parses an option that takes an argument, the argument value is assigned
               to this variable.

           <b>OPTIND</b>
               The value of this variable specifies the index of an option that is to be parsed by the next
               getopts built-in execution. This variable is initialized to <b>1</b> when the shell is started.

           <b>PATH</b>
               This variable specifies paths that are searched for a command in command search.

           <b>PPID</b>
               The value of this variable is the process ID of the shell’s parent process, which is a positive
               integer. This variable is initialized when the shell is started. The value is not changed when
               the shell makes a new subshell.

           <b>PROMPT_COMMAND</b>
               The shell interprets and executes the value of this variable before printing each command prompt
               if the shell is interactive and not in the POSIXly-correct mode. This behavior is equivalent to
               executing the command <b>eval</b> <b>-i</b> <b>--</b> <b>"${PROMPT_COMMAND-}"</b> before each command prompt, but its exit
               status does not affect the expansion of the <b>?</b>  special parameter in the next command.

           <b>PS1</b>
               This variable specifies the main command prompt string printed by an interactive shell. See
               Prompts for the format of the variable value. The value is initialized to either <b>$</b> or <b>#</b> depending
               on whether the effective user ID of the shell process is zero or not.

           <b>PS1P</b>
               This variable specifies the font style of predicted commands. See Prompts for the format of the
               variable value.

           <b>PS1R</b>
               This variable specifies the auxiliary prompt string printed to the right of the cursor when you
               input a command line to an interactive shell. See Prompts for the format of the variable value.

           <b>PS1S</b>
               This variable specifies the font style of command strings you enter to an interactive shell. See
               Prompts for the format of the variable value.

           <b>PS2</b>
               This variable is like the <b>PS1</b> variable, but it is used for the second and following lines of a
               command that is longer than one line. See Prompts for the format of the variable value. The value
               is initialized to <b>&gt;</b> when the shell is started.

           <b>PS2P</b>
               This variable is like the <b>PS1P</b> variable, but it is used when <b>PS2</b> is used. See Prompts for the
               format of the variable value.

           <b>PS2R</b>
               This variable is like the <b>PS1R</b> variable, but it is used when <b>PS2</b> is used. See Prompts for the
               format of the variable value.

           <b>PS2S</b>
               This variable is like the <b>PS1S</b> variable, but it is used when <b>PS2</b> is used. See Prompts for the
               format of the variable value.

           <b>PS4</b>
               The value of this variable is printed before each command trace output when the xtrace option is
               enabled. The value is subject to parameter expansion, command substitution, arithmetic expansion.
               You can also use backslash notations if the shell is not in the POSIXly-correct mode. The value
               is initialized to <b>+</b> when the shell is started.

           <b>PS4S</b>
               This variable is like the <b>PS1S</b> variable, but it is used when <b>PS4</b> is used. You can use this
               variable to modify font style of command trace output.

           <b>PWD</b>
               The value of this variable is the pathname of the current working directory. The value is set
               when the shell is started and reset each time the working directory is changed by the cd or other
               built-ins. This variable is exported by default.

           <b>RANDOM</b>
               You can use this variable to get random numbers. The value of this variable is a uniformly
               distributed random integer between 0 and 32767 (inclusive). You will get a different number each
               time the variable is expanded.

               You can set the “seed” of random numbers by assigning a non-negative integer to the variable.

               If you remove this variable, it will no longer work as a random number generator. If the shell
               was invoked in the POSIXly-correct mode, this variable does not work as a random number
               generator.

           <b>TERM</b>
               This variable specifies the type of the terminal in which the shell is running. The value affects
               the behavior of line-editing. This variable has to be exported to take effect.

           <b>YASH_AFTER_CD</b>
               The shell interprets and executes the value of this variable after each time the shell’s working
               directory is changed by the cd or other built-ins. This behavior is equivalent to executing the
               command <b>eval</b> <b>-i</b> <b>--</b> <b>"${YASH_AFTER_CD-}"</b> after the directory was changed.

           <b>YASH_LOADPATH</b>
               This variable specifies directories the dot built-in searches for a script file. More than one
               directory can be specified by separating them by colons like the <b>PATH</b> variable. When the shell is
               started, this variable is initialized to the pathname of the directory where common script files
               are installed.

           <b>YASH_LE_TIMEOUT</b>
               This variable specifies how long the shell should wait for a next possible input from the
               terminal when it encountered an ambiguous control sequence while line-editing. The value must be
               specified in milliseconds. If you do not define this variable, the default value of 100
               milliseconds is assumed.

           <b>YASH_PS1</b>, <b>YASH_PS1P</b>, <b>YASH_PS1R</b>, <b>YASH_PS1S</b>, <b>YASH_PS2</b>, <b>YASH_PS2P</b>, <b>YASH_PS2R</b>, <b>YASH_PS2S</b>, <b>YASH_PS4</b>,
           <b>YASH_PS4S</b>
               When not in the POSIXly-correct mode, if any of these variables is defined, it takes precedence
               over the corresponding variable without the <b>YASH_</b> prefix in the name (e.g.  <b>PS1</b>). These variables
               are ignored in the POSIXly-correct mode. You should define them to include yash-specific
               notations in the prompt, so that unhandled notations do not mangle the prompt in the
               POSIXly-correct mode.

           <b>YASH_VERSION</b>
               The value is initialized to the version number of the shell when the shell is started.

       <b>Arrays</b>

           An <u>array</u> is a variable that contains zero or more strings. The string values of an array are
           identified by natural numbers (like positional parameters).

           You can assign values to an array by using a simple command as well as the array built-in. You can
           use the unset built-in to remove arrays.

           Arrays cannot be exported as arrays. When an array is exported, it is treated as a normal variable
           whose value is a concatenation of all the array values, each separated by a colon.

           Arrays are not supported in the POSIXly-correct mode.

</pre><h4><b>WORD</b> <b>EXPANSIONS</b></h4><pre>
       <u>Word</u> <u>expansion</u> is substitution of part of a word with another particular string. There are seven types of
       word expansions:

        1. Tilde expansion

        2. Parameter expansion

        3. Command substitution

        4. Arithmetic expansion

        5. Brace expansion

        6. Field splitting

        7. Pathname expansion (globbing)

       These types of expansions are performed in the order specified above.

       Tilde expansion, parameter expansion, command substitution, and arithmetic expansion are called the <u>four</u>
       <u>expansions</u>.

   <b>Tilde</b> <b>expansion</b>
       In <u>tilde</u> <u>expansion</u>, parts of words that start with a tilde (<b>~</b>) are substituted with particular pathnames.
       The part of each word that gets substituted is from the beginning of the word, which is a tilde, up to
       (but not including) the first slash (<b>/</b>) in the word. If the word does not contain a slash, the whole word
       is substituted. If any character in the substituted part is quoted, tilde expansion is not performed on
       the word.

       The results of expansion are determined by the format of the substituted part:

       <b>~</b>
           A single tilde is substituted with the value of the <b>HOME</b> variable.

       <b>~</b><u>username</u>
           A tilde followed by a user name is substituted with the pathname of the user’s home directory.

       <b>~+</b>
           <b>~+</b> is substituted with the value of the <b>PWD</b> variable.

       <b>~-</b>
           <b>~-</b> is substituted with the value of the <b>OLDPWD</b> variable.

       <b>~+</b><u>n</u>, <b>~-</b><u>n</u>
           where <u>n</u> is a non-negative integer. This type of tilde expansion yields the pathname of a directory of
           which <b>~+</b><u>n</u> or <b>~-</b><u>n</u> is the index in the directory stack.

       When tilde expansion is performed on the value of a variable assignment that occurs during execution of a
       simple command, the value is considered as a colon-separated list of words and those words are each
       subject to tilde expansion. For example, the variable assignment

           VAR=<a href="file:~/a">~/a</a>:<a href="file:~/b">~/b</a>:<a href="file:~/c">~/c</a>

       is equivalent to

           VAR=/home/foo/a:/home/foo/b:/home/foo/c

       if the value of <b>HOME</b> variable is <b>/home/foo</b>.

       The POSIX standard does not prescribe how the shell should behave when it encounters an error during
       tilde expansion (e.g., when the <b>HOME</b> variable is not defined). Yash silently ignores any errors during
       tilde expansion; the part of the word that would be substituted is left intact.

       In the POSIXly-correct mode, tilde expansion supports the formats of <b>~</b> and <b>~</b><u>username</u> only.

   <b>Parameter</b> <b>expansion</b>
       <u>Parameter</u> <u>expansion</u> expands to the value of a parameter.

       The syntax of typical, simple parameter expansion is <b>${</b><u>parameter</u><b>}</b>, which expands to the value of the
       parameter whose name is <u>parameter</u>. You can omit the braces (e.g., <b>$</b><u>parameter</u>) if

       •   <u>parameter</u> is a special parameter,

       •   <u>parameter</u> is a positional parameter whose index is a one-digit integer, or

       •   <u>parameter</u> is a variable and the parameter expansion is not followed by a character that can be used
           as part of a variable name.  For example, <b>${path}-name</b> is equivalent to <b>$path-name</b>, but <b>${path}name</b>
           and <b>$pathname</b> are different.

       If <u>parameter</u> is none of a special parameter, positional parameter, and variable, it is a syntax error.
       (Some shells other than yash may treat such a case as an expansion error.)

       If the unset option is disabled and the <u>parameter</u> is an undefined variable, it is an expansion error. If
       the unset option is enabled, an undefined variable expands to the empty string.

       More complex syntax of parameter expansion allows modifying the value of a parameter.

       Parameter expansion
           <b>${</b> <u>prefix</u> <u>parameter</u> <u>index</u> <u>modifier</u> <b>}</b>

       The spaces in the syntax definition above are for readability only and must be omitted. You can omit
       <u>prefix</u>, <u>index</u>, and/or <u>modifier</u>.

       <b>Prefix</b>

           The <u>prefix</u>, if any, must be a hash sign (<b>#</b>). If a parameter expansion has the prefix, the result of
           expansion is the number of characters in the value this expansion would be expanded to without the
           prefix.

       <b>Parameter</b> <b>name</b>

           The parameter name (<u>parameter</u>) must be either

           •   a name of a special parameter, positional parameter, or variable; or

           •   another parameter expansion, command substitution, or arithmetic expansion.

           The parameter expansion is expanded to the value of the <u>parameter</u>. If <u>parameter</u> is an array variable,
           the values of the array are field-split like the <b>@</b> special parameter unless the index <b>[*]</b> is
           specified.

           If <u>parameter</u> is another expansion, it is called a <u>nested</u> <u>expansion</u>. Nested expansion cannot be used
           in the POSIXly-correct mode. The braces (<b>{</b> <b>}</b>) of a nested parameter expansion cannot be omitted.
       Index.sp An <u>index</u> allows extracting part of the parameter value (or some of array values).

       Index
           <b>[</b><u>word1</u><b>]</b>

           <b>[</b><u>word1</u><b>,</b><u>word2</u><b>]</b>

       where <u>word1</u> and <u>word2</u> are parsed in the same manner as normal tokens except that they are always
       delimited by <b>,</b> or <b>]</b> and can contain whitespace characters.

       If there is an <u>index</u> in a parameter expansion, it is interpreted as follows:

        1. Words <u>word1</u> and <u>word2</u> are subjected to parameter expansion, command substitution, and arithmetic
           expansion.

        2. If there is no <u>word2</u> and if <u>word1</u> expands to one of <b>*</b>, <b>@</b>, and <b>#</b>, then that is the interpretation of
           <u>index</u> and the next step is not taken.

        3. The results of the previous steps (the expanded <u>word1</u> and <u>word2</u>) are interpreted and evaluated as an
           arithmetic expression in the same manner as in arithmetic expansion. The resulting integers are the
           interpretation of <u>index</u>. If the results are not integers, it is an expansion error. If there is no
           <u>word2</u>, it is assumed that <u>word2</u> is equal to <u>word1</u>.

       If <u>parameter</u> is an array variable, the <u>index</u> specifies the part of the array. If <u>parameter</u> is either the
       <b>*</b> or <b>@</b> special parameter, the <u>index</u> specifies the index range of positional parameters. In other cases,
       the <u>index</u> specifies the index range of a substring of the parameter value that is being expanded. In all
       cases, the specified range of the array values, positional parameters, or parameter value remains in the
       results of the expansion and other values are dropped.

       If the interpretation of <u>index</u> is one or two integers, the following rules apply:

       •   If the interpreted index value is negative, it <u>wraps</u> <u>around</u>. For example, the index value of -1
           corresponds to the last value/character.

       •   It is not an error when the index value is out of range. Existing values/characters within the range
           are just selected.

       •   If the interpretation of either <u>word1</u> or <u>word2</u> is 0, the range is assumed empty and the expansion
           results in nothing.

       If the interpretation of <u>index</u> is one of <b>*</b>, <b>@</b>, and <b>#</b>, it is treated as follows:

       <b>*</b>
           If <u>parameter</u> is an array, all the array values are field-split or concatenated in the same manner as
           the <b>*</b> special parameter. If <u>parameter</u> is the <b>*</b> or <b>@</b> special parameter, the positional parameters are
           likewise field-split or concatenated. In other cases, the interpretation of <u>index</u> is treated as if
           the interpretation is the two integers 1 and -1.

       <b>@</b>
           The interpretation of <u>index</u> is treated as if the interpretation is the two integers 1 and -1.

       <b>#</b>
           The interpretation of the <b>#</b> <u>index</u> is special in that it does not simply specify a range. Instead, the
           expanded values are substituted with the count.

           If <u>parameter</u> is an array, the result of this parameter expansion will be the number of values in the
           array being expanded. If <u>parameter</u> is the <b>*</b> or <b>@</b> special parameter, the result will be the number of
           current positional parameters. Otherwise, the result will be the number of characters in the value
           that is being expanded.

       If a parameter expansion does not contain an <u>index</u>, it is assumed to be <b>[@]</b>. In the POSIXly-correct mode,
       <u>index</u> cannot be specified.

       <b>Example</b> <b>1.</b> <b>Expansion</b> <b>of</b> <b>a</b> <b>normal</b> <b>variable</b>

       The following commands will print the string <b>ABC</b>:

           var='123ABC789'
           echo "${var[4,6]}"

       <b>Example</b> <b>2.</b> <b>Expansion</b> <b>of</b> <b>positional</b> <b>parameters</b>

       The following commands will print the string <b>2</b> <b>3</b> <b>4</b>:

           set 1 2 3 4 5
           echo "${*[2,-2]}"

       <b>Example</b> <b>3.</b> <b>Expansion</b> <b>of</b> <b>an</b> <b>array</b>

       The following commands will print the string <b>2</b> <b>3</b> <b>4</b>:

           array=(1 2 3 4 5)
           echo "${array[2,-2]}"

       <b>Modifier</b>

           You can modify the value to be expanded by using <u>modifiers</u>:

           <b>-</b><u>word</u>
               If the parameter name (<u>parameter</u>) is an undefined variable, the parameter expansion is expanded
               to <u>word</u>. It is not treated as an error if the unset option is disabled.

           <b>+</b><u>word</u>
               If the parameter name (<u>parameter</u>) is an existing variable, the parameter expansion is expanded to
               <u>word</u>. It is not treated as an error if the unset option is disabled.

           <b>=</b><u>word</u>
               If the parameter name (<u>parameter</u>) is an undefined variable, <u>word</u> is assigned to the variable and
               the parameter expansion is expanded to <u>word</u>. It is not treated as an error if the unset option is
               disabled.

           <b>?</b><u>word</u>
               If the parameter name (<u>parameter</u>) is an undefined variable, <u>word</u> is printed as an error message
               to the standard error. If <u>word</u> is empty, the default error message is printed instead.

           <b>:-</b><u>word</u>, <b>:+</b><u>word</u>, <b>:=</b><u>word</u>, <b>:?</b><u>word</u>
               These are similar to the four types of modifiers above. The only difference is that, if <u>parameter</u>
               exists and has an empty value, it is also treated as an undefined variable.

           <b>#</b><u>word</u>
               The shell performs pattern matching against the value that is being expanded, using <u>word</u> as a
               pattern. If <u>word</u> matches the beginning of the value, the matching part is removed from the value
               and the other part remains as expansion results. The shortest matching is used if more than one
               matching is possible.

           <b>##</b><u>word</u>
               This is similar to <b>#</b><u>word</u> above. The only difference is that the longest matching is used if more
               than one matching is possible.

           <b>%</b><u>word</u>
               This is similar to <b>#</b><u>word</u> above. The only difference is that matching is tried at the end of the
               value rather than at the beginning: if <u>word</u> matches the end of the value, the matching part is
               removed from the value and the other part remains as expansion results.

           <b>%%</b><u>word</u>
               This is similar to <b>%</b><u>word</u> above. The only difference is that the longest matching is used if more
               than one matching is possible.

           <b>/</b><u>word1</u><b>/</b><u>word2</u>
               The shell performs pattern matching against the value that is being expanded, using <u>word1</u> as a
               pattern. If <u>word1</u> matches any part of the value, the matching part is replaced with <u>word2</u> and the
               whole value after the replacement remains as expansion results. If <u>word1</u> matches more than one
               part of the value, only the first part is replaced. The shortest matching is replaced if more
               than one matching is possible for the same starting point in the value.

               This modifier cannot be used in the POSIXly-correct mode.

           <b>/#</b><u>word1</u><b>/</b><u>word2</u>
               This is similar to <b>/</b><u>word1</u><b>/</b><u>word2</u> above. The only difference is that <u>word1</u> matches only at the
               beginning of the value being expanded.

           <b>/%</b><u>word1</u><b>/</b><u>word2</u>
               This is similar to <b>/</b><u>word1</u><b>/</b><u>word2</u> above. The only difference is that <u>word1</u> matches only at the end
               of the value being expanded.

           <b>//</b><u>word1</u><b>/</b><u>word2</u>
               This is similar to <b>/</b><u>word1</u><b>/</b><u>word2</u> above. The only difference is that all matched parts are replaced
               if <u>word1</u> matches more than one part of the value.

           <b>:/</b><u>word1</u><b>/</b><u>word2</u>
               This is similar to <b>/</b><u>word1</u><b>/</b><u>word2</u> above. The only difference is that the value is replaced only
               when <u>word1</u> matches the whole value.

           In all types of modifiers above, words are subjected to the four expansions when (and only when) they
           are used.

           If <u>parameter</u> is an array variable or the <b>@</b> or <b>*</b> special parameter, modifiers affect each value of the
           array or all positional parameters.

   <b>Command</b> <b>substitution</b>
       <u>Command</u> <u>substitution</u> expands to output of commands specified.

       Command substitution
           <b>$(</b><u>commands</u><b>)</b>

           <b>`</b><u>commands</u><b>`</b>

       When command substitution is evaluated, <u>commands</u> are executed by a subshell with output pipelined to the
       shell. When the <u>commands</u> finished, command substitution is substituted with the output of the <u>commands</u>.
       Any trailing newline characters in the output are ignored.

       When command substitution of the form <b>$(</b><u>commands</u><b>)</b> is parsed, the <u>commands</u> are parsed carefully so that
       complex commands such as nested command substitution are parsed correctly. If <u>commands</u> start with <b>(</b>, you
       should put a space before <u>commands</u> so that the whole command substitution is not confused with arithmetic
       expansion. If the shell is in the POSIXly-correctly mode, the <u>commands</u> are parsed each time the command
       substitution is expanded; otherwise, <u>commands</u> are parsed only when the command substitution is parsed.

       If command substitution is of the form <b>`</b><u>commands</u><b>`</b>, the <u>commands</u> are not parsed when the command
       substitution is parsed; the <u>commands</u> are parsed each time the command substitution is expanded. The end
       of <u>commands</u> is detected by the first backquote character (<b>`</b>) after the beginning of <u>commands</u> that is not
       quoted by a backslash. Backquotes that are part of <u>commands</u> (typically used for nested command
       substitution) must be quoted by backslashes. In <u>commands</u>, backslashes are treated as quotes only when
       preceding a dollar (<b>$</b>), backquote, newline, or another backslash. Additionally, if the command
       substitution occurs inside double quotes, double quotes in <u>commands</u> must be quoted with a backslash.
       Those backslashes are removed before <u>commands</u> are parsed.

   <b>Arithmetic</b> <b>expansion</b>
       <u>Arithmetic</u> <u>expansion</u> evaluates an arithmetic expression and expands to the value of the expression.

       Arithmetic expansion
           <b>$((</b><u>expression</u><b>))</b>

       When arithmetic expansion is expanded, the <u>expression</u> is subject to parameter expansion, command
       substitution, and (nested) arithmetic expansion. The <u>expression</u> is parsed in (almost) same manner as an
       expression of the C programming language.

       Yash allows an expression to be either an integer (of the long type in C) or a floating-point number (of
       the double type in C). An operation on integers yields an integer and an operation involving a
       floating-point number yields a floating-point number. In the POSIXly-correct mode, you can use integers
       only.

       The following operators are available (in the order of precedence):

        1. <b>(</b> <b>)</b>

        2. <b>++</b> <b>--</b> (postfix operators)

        3. <b>++</b> <b>--</b> <b>+</b> <b>-</b> <b>~</b> <b>!</b>  (prefix operators)

        4. <b>*</b> <b>/</b> <b>%</b>

        5. <b>+</b> <b>-</b> (binary operators)

        6. <b>&lt;&lt;</b> <b>&gt;&gt;</b>

        7. <b>&lt;</b> <b>&lt;=</b> <b>&gt;</b> <b>&gt;=</b>

        8. <b>==</b> <b>!=</b>

        9. <b>&amp;</b>

       10. <b>^</b>

       11. <b>|</b>

       12. <b>&amp;&amp;</b>

       13. <b>||</b>

       14. <b>?</b> <b>:</b>

       15. <b>=</b> <b>*=</b> <b>/=</b> <b>%=</b> <b>+=</b> <b>-=</b> <b>&lt;&lt;=</b> <b>&gt;&gt;=</b> <b>&amp;=</b> <b>^=</b> <b>|=</b>

       The <b>++</b> and <b>--</b> operators cannot be used in the POSIXly-correct mode.

       An atomic expression can be one of an integer literal, a floating-point number literal, and a variable.
       Literals are parsed in the same manner as in C. An octal integer literal starts with <b>0</b>, and hexadecimal
       with <b>0x</b>. A floating-point number literal may have an exponent (i.e. <b>1.23e+6</b>). A variable with a
       non-numeric value will result in an error when parsed as a number. An unset variable is treated as a
       value of zero if the unset option is enabled.

       In the POSIXly-correct mode, variables are always parsed as numbers. Otherwise, variables are parsed only
       when they are used as numbers in computation. Unparsed variables are left intact.

           set +o posixly-correct
           foo=bar
           echo $((0 ? foo : foo)) # prints "bar"
           echo $((foo + 0))       # error

       It is an expansion error if the result of an expression is not defined in C.

   <b>Brace</b> <b>expansion</b>
       <u>Brace</u> <u>expansion</u> expands to several split words with preceding and succeeding portions duplicated to each
       split words. Brace expansion is expanded only when the brace-expand option is enabled.

       Comma-separated brace expansion
           <b>{</b><u>word1</u><b>,</b><u>word2</u><b>,...,</b><u>wordn</u><b>}</b>

       Range brace expansion
           <b>{</b><u>start</u><b>..</b><u>end</u><b>}</b>

           <b>{</b><u>start</u><b>..</b><u>end</u><b>..</b><u>delta</u><b>}</b>

       Comma-separated brace expansion is expanded to each comma-separated word. For example, <b>a{1,2,3}b</b> is
       expanded to the three words <b>a1b</b>, <b>a2b</b>, and <b>a3b</b>.

       Range brace expansion is expanded to integers in the range defined by <u>start</u> and <u>end</u>. The difference
       between each integer can be defined by <u>delta</u>. If <u>start</u> is larger than <u>end</u>, the results will be in
       descending order. When <b>..</b><u>delta</u> is omitted, it defaults to 1 or -1. For example, <b>a{1..3}b</b> is expanded to
       the three words <b>a1b</b>, <b>a2b</b>, and <b>a3b</b>; and <b>a{1..7..2}b</b> to the four words <b>a1b</b>, <b>a3b</b>, <b>a5b</b>, and <b>a7b</b>.

       Multiple brace expansions can be used in one word. Brace expansions can also be nested. You can quote
       braces and/or commas to prevent them from being treated as brace expansion.

       Any errors in brace expansion are silently ignored.

   <b>Field</b> <b>splitting</b>
       In <u>field</u> <u>splitting</u>, words are split at predefined separators.

       Field splitting can occur only within parts of words that resulted from parameter expansion, command
       substitution, and arithmetic expansion that are not between double-quotation marks. Expansion results of
       the <b>@</b> special parameter are exceptionally split even between double-quotation marks.

       Separators used in field splitting are defined by the value of the <b>IFS</b> variable. If the variable does not
       exist, the value is assumed to be the three characters of space, tab, and newline.

       Characters included in the value of the <b>IFS</b> variable are called <u>IFS</u> <u>characters</u>. IFS characters that are
       any of space, tab, and newline are called <u>IFS</u> <u>whitespace</u> and other IFS characters are called <u>IFS</u>
       <u>non-whitespace</u>.

       Field splitting is performed as follows:

        1. The shell searches words for split points. A split point is one or more adjacent IFS characters
           within the word portions where field splitting can occur. The following steps are taken for each
           split point found.

        2. If the split point includes one or more IFS non-whitespaces, all the IFS whitespaces in the split
           point are ignored and the word is split at each IFS non-whitespace in the split point.

        3. If the split point includes no IFS non-whitespaces, the word is split at the split point unless it is
           at the beginning or end of the word.

        4. The split points are removed from the results.

       Finally, the last word is removed from the results if:

       •   the empty-last-field option is not enabled;

       •   the result is more than one word; and

       •   the last word is empty.

           <b>Note</b>

           Words are not split at all when the value of the <b>IFS</b> variable is empty.

   <b>Pathname</b> <b>expansion</b>
       <u>Pathname</u> <u>expansion</u> performs pattern matching and expands to pathnames matched by the pattern.

       A word subjected to pathname expansion is treated as a pattern. If one or more pathnames are found that
       are matched by the pattern, the pathnames become the results of the pathname expansion.

       Pathname expansion is not performed when the glob option is disabled.

       The shell searches readable directories for matching pathnames. Unreadable directories are silently
       ignored.

       The following options affect the behavior of pathname expansion:

       null-glob
           This option affects the result of pathname expansion when no matching pathnames are found. If
           enabled, the result is no word. If disabled, the result is the original pattern word.

       case-glob
           This option specifies case-sensitivity in matching. If enabled, pattern matching is done
           case-sensitively.

       dot-glob
           This option affects matching of filenames that start with a period (<b>.</b>). If disabled, a period at the
           beginning of a filename does not match wildcard patterns (<b>?</b>  and <b>*</b>) or bracket expressions. If
           enabled, there is no such special treatment of periods.

       mark-dirs
           If enabled, each resulting pathname that is a directory name is suffixed by a slash (<b>/</b>).

       extended-glob
           This option enables the extension. (See below)

       Any errors in pathname expansion are silently ignored. If the word is an invalid pattern, it just becomes
       the result. The results depend on the null-glob option when no matching pathnames are found.

       Pattern matching is done for each filename (or pathname component) of pathnames. The shell skips matching
       for literal patterns that contain no wildcards or bracket expressions. As a result, the patterns <b>/*/foo</b>
       and <b>/*/fo[o]</b> may yield different expansion results when the case-glob option is disabled; for example,
       the pattern <b>/*/fo[o]</b> matches the pathname <b>/bar/FOO</b> but the pattern <b>/*/foo</b> does not because matching is
       skipped for <b>foo</b>.

       <b>Extension</b> <b>in</b> <b>pathname</b> <b>expansion</b>

           The following patterns can be used when the extended-glob option is enabled.

           <b>**</b>
               The directory is searched recursively and the pattern matches any number of directory filenames
               (each separated by a slash). Any directory whose name begins with a period is excluded from
               search. For example, the pattern <b>dir/**/file</b> can match the pathnames <b>dir/file</b>, <b>dir/foo/file</b>,
               <b>dir/a/b/c/file</b>, etc.

               This pattern is not effective when appearing at the end of the whole pattern (i.e.  <b>foo/bar/**</b>).

           <b>.**</b>
               This pattern is like <b>**</b>, but all directories are searched including ones with a name starting
               with a period.

           <b>***</b>
               This pattern is like <b>**</b>, but if a symbolic link to a directory is found during recursive search,
               the directory is searched recursively as well.

           <b>.***</b>
               This pattern is like <b>***</b>, but all directories are searched including ones with a name starting
               with a period.

</pre><h4><b>PATTERN</b> <b>MATCHING</b> <b>NOTATION</b></h4><pre>
       <u>Pattern</u> <u>matching</u> <u>notation</u> is a syntax of <u>patterns</u> that represent particular sets of strings. When a
       string is included in the set of strings a pattern represents, the pattern is said to <u>match</u> the string.
       Whether a pattern matches a string or not is defined as follows.

   <b>Normal</b> <b>characters</b>
       A character that is not quoted or any of special characters defined below is a normal character, which
       matches the character itself.

       For example, the pattern <b>abc</b> matches the string <b>abc</b>, and not any other strings.

   <b>Single-character</b> <b>wildcard</b>
       The character <b>?</b> matches any single character.

       For example, the pattern <b>a?c</b> matches any three-character strings that starts with <b>a</b> and ends with <b>c</b>, such
       as <b>aac</b>, <b>abc</b>, and <b>a;c</b>.

   <b>Multi-character</b> <b>wildcard</b>
       The character <b>*</b> matches any strings (of any length, including the empty string).

       For example, the pattern <b>a*c</b> matches any string that starts with <b>a</b> and ends with <b>c</b>, such as <b>ac</b>, <b>abc</b>, and
       <b>a;xyz;c</b>.

   <b>Bracket</b> <b>expression</b>
       A pattern that is enclosed by brackets (<b>[</b> and <b>]</b>) is a <u>bracket</u> <u>expression</u>. A bracket expression must have
       at least one character between the brackets. The characters between the brackets are interpreted as a
       <u>bracket</u> <u>expression</u> <u>pattern</u>, which is a below-defined special notation for bracket expression. A bracket
       expression pattern represents a set of characters. The bracket expression matches any one of the
       characters in the set the bracket expression pattern represents.

       If the opening bracket (<b>[</b>) is followed by an exclamation mark (<b>!</b>), the exclamation is not treated as part
       of the bracket expression pattern and the whole bracket expression instead matches a character that is
       <u>not</u> included in the set the bracket expression pattern represents. If the opening bracket is followed by
       a caret (<b>^</b>), it is treated like an exclamation mark as above (but shells other than yash may treat the
       caret differently).

       If the opening bracket (or the following exclamation or caret, if any) is followed by a closing bracket
       (<b>]</b>), it is treated as part of the bracket expression pattern rather than the end of the bracket
       expression. You cannot quote characters in the bracket expression pattern because quotation is treated
       before bracket expression.

       An opening bracket in a pattern is treated as a normal character if it is not the beginning of a valid
       bracket expression.

   <b>Normal</b> <b>characters</b> <b>(in</b> <b>bracket</b> <b>expression</b> <b>pattern)</b>
       A character that is not any of special characters defined below is a normal character, which represents
       the character itself.

       For example, the bracket expression pattern <b>abc</b> represents the set of the three characters <b>a</b>, <b>b</b>, and <b>c</b>.
       The bracket expression <b>[abc]</b> therefore matches any of the three characters.

   <b>Range</b> <b>expressions</b>
       A hyphen preceded and followed by a character (or collating symbol) is a <u>range</u> <u>expression</u>, which
       represents the set of the two characters and all characters between the two in the collation order. A
       <u>collation</u> <u>order</u> is an order of characters that is defined in the locale data.

       If a hyphen is followed by a closing bracket (<b>]</b>), the bracket is treated as the end of the bracket
       expression and the hyphen as a normal character.

       For example, the range expression <b>3-5</b> represents the set of the three characters <b>3</b>, <b>4</b>, and <b>5</b>. The bracket
       expression <b>[3-5-]</b> therefore matches one of the four characters <b>3</b>, <b>4</b>, <b>5</b>, and <b>-</b>.

   <b>Collating</b> <b>symbols</b>
       A <u>collating</u> <u>symbol</u> allows more than one character to be treated as a single character in matching. A
       collating symbol is made up of one or more characters enclosed by the special brackets <b>[.</b> and <b>.]</b>.

       One or more characters that are treated as a single character in matching are called a <u>collating</u> <u>element</u>.
       Precisely, a bracket expression pattern represents a set of collating elements and a bracket expression
       matches a collating element rather than a character, but we do not differentiate them for brevity here.

       For example, the character combination “ch” was treated as a single character in the traditional Spanish
       language. If this character combination is registered as a collating element in the locale data, the
       bracket expression <b>[[.ch.]df]</b> matches one of <b>ch</b>, <b>d</b>, and <b>f</b>.

   <b>Equivalence</b> <b>classes</b>
       An <u>equivalence</u> <u>class</u> represents a set of characters that are considered <u>equivalent</u>. A equivalence class
       is made up of a character (or more precisely, a collating element) enclosed by the special brackets <b>[=</b>
       and <b>=]</b>.

       An equivalence class represents the set of characters that consists of the character enclosed by the
       brackets and the characters that are in the same primary equivalence class as the enclosed character. The
       shell consults the locale data for the definition of equivalence classes in the current locale.

       For example, if the six characters <b>a</b>, <b>à</b>, <b>á</b>, <b>â</b>, <b>ã</b>, <b>ä</b> are defined to be in the same primary equivalence
       class, the bracket expressions <b>[[=a=]]</b>, <b>[[=à=]]</b>, and <b>[[=á=]]</b> match one of the six.

   <b>Character</b> <b>classes</b>
       A <u>character</u> <u>class</u> represents a predefined set of characters. A character class is made up of a class name
       enclosed by the special brackets <b>[:</b> and <b>:]</b>. The shell consults the locale data for which class a
       character belongs to.

       The following character classes can be used in all locales:

       <b>[:lower:]</b>
           set of lowercase letters

       <b>[:upper:]</b>
           set of uppercase letters

       <b>[:alpha:]</b>
           set of letters, including the <b>[:lower:]</b> and <b>[:upper:]</b> classes.

       <b>[:digit:]</b>
           set of decimal digits

       <b>[:xdigit:]</b>
           set of hexadecimal digits

       <b>[:alnum:]</b>
           set of letters and digits, including the <b>[:alpha:]</b> and <b>[:digit:]</b> classes.

       <b>[:blank:]</b>
           set of blank characters, not including the newline character

       <b>[:space:]</b>
           set of space characters, including the newline character

       <b>[:punct:]</b>
           set of punctuations

       <b>[:print:]</b>
           set of printable characters

       <b>[:cntrl:]</b>
           set of control characters

       For example, the bracket expression <b>[[:lower:][:upper:]]</b> matches a lower or upper case character. In
       addition to the classes listed above, other classes may be used depending on the definition of the
       current locale.

</pre><h4><b>REDIRECTION</b></h4><pre>
       <u>Redirection</u> is a feature you can use to modify file descriptors of commands. By using redirection, you
       can execute commands with their standard input/output connected with files or devices other than the
       terminal.

       You can do redirection by adding redirection operators to a command (simple command or compound command)
       In a simple command, redirection operators may appear anywhere in the command as long as operator tokens
       are separated from other tokens. In a compound command, redirection operators must appear at the end of
       the command.

       Redirection operators are processed before the command body is executed. More than one redirection
       operator in a command are processed in the order of appearance. Redirection operators affect only the
       command in which they appear, except when they appear in an exec built-in without command operands. That
       is, file descriptors modified by redirection are restored after the command has finished.

       A redirection operator starts with <b>&lt;</b> or <b>&gt;</b>. Redirection operators starting with <b>&lt;</b> affects the standard
       input (file descriptor 0) by default. Redirection operators starting with <b>&gt;</b> affects the standard output
       (file descriptor 1) by default. To affect another file descriptor, you can prefix a redirection operator
       with a non-negative integer; the operator will affect the file descriptor specified by the integer. The
       integer must immediately precede the <b>&lt;</b> or <b>&gt;</b> without any whitespaces in between. The integer must not be
       quoted, either.

   <b>Redirection</b> <b>to</b> <b>files</b>
       The most common type of redirection is redirection to files.

       Redirection of input
           <b>&lt;</b> <u>token</u>

       Redirection of output
           <b>&gt;</b> <u>token</u>

           <b>&gt;|</b> <u>token</u>

           <b>&gt;&gt;</b> <u>token</u>

       Redirection of input and output
           <b>&lt;&gt;</b> <u>token</u>

       The <u>token</u> is subject to the four expansions. It is also subject to pathname expansion if the shell is
       interactive. The expansion result is treated as the pathname of the file to which redirection is
       performed. If the pathname expansion does not result in a single pathname, it is an error.

       In redirection of input, the standard input is replaced with a file descriptor which is open for
       read-only access to the target file. If the target file cannot be opened for read-only access, it is an
       error.

       In redirection of output, the standard output is replaced with a file descriptor which is open for
       write-only access to the target file. If the target file cannot be opened for write-only access, it is an
       error. If the target file does not exist, a new empty file is created and opened. If the target file
       already exists, the file is opened as follows:

       •   For the <b>&gt;|</b> operator, the file is emptied when opened if it is a regular file.

       •   For the <b>&gt;</b> operator, the behavior is the same as the <b>&gt;|</b> operator if the clobber option is enabled. If
           the option is disabled and the file is a regular file, it is treated as an error.

       •   For the <b>&gt;&gt;</b> operator, the file is opened for appending; any output to the file descriptor is appended
           to the end of the file.

       In redirection of input and output, the standard input is replaced with a file descriptor which is open
       for read-and-write access to the target file. If the file does not exist, a new empty file is created and
       opened.

       <b>Socket</b> <b>redirection</b>

           If the pathname of the target file is of the form <b>/dev/tcp/</b><u>host</u><b>/</b><u>port</u> or <b>/dev/udp/</b><u>host</u><b>/</b><u>port</u> and the
           file cannot be opened in the usual manner, a new socket is opened for communication with the <u>port</u> of
           the <u>host</u>. The redirection replaces the standard input or output with the file descriptor to the
           socket.

           A stream socket is opened for the form <b>/dev/tcp/</b><u>host</u><b>/</b><u>port</u> and a datagram socket for the form
           <b>/dev/udp/</b><u>host</u><b>/</b><u>port</u>. The protocol actually used for communication is determined by the socket library
           the shell uses. Typically, stream sockets use TCP and datagram sockets UDP.

           In socket redirection, the file descriptor is both readable and writable regardless of the type of
           the redirection operator used.

           Socket redirection is yash’s extension that is not defined in POSIX. Bash as well has socket
           redirection as extension.

   <b>Duplication</b> <b>of</b> <b>file</b> <b>descriptors</b>
       Redirection allows duplicating or closing existing file descriptors.

       Duplication of file descriptor
           <b>&lt;&amp;</b> <u>token</u>

           <b>&gt;&amp;</b> <u>token</u>

       The <u>token</u> is subject to expansion as in redirection to files, but it is treated as a file descriptor
       rather than a pathname. Thus the expanded <u>token</u> must be a non-negative integer.

       The <b>&lt;&amp;</b> and <b>&gt;&amp;</b> operators duplicate the file descriptor specified by <u>token</u> to the standard input and
       output, respectively. (The operators can be prefixed with a non-negative integer so that the file
       descriptor is duplicated to a file descriptor other than the standard input or output.)

       If the expanded <u>token</u> is a single hyphen rather than a non-negative integer, the file descriptor is
       closed rather than duplicated. By default, the <b>&lt;&amp;</b> and <b>&gt;&amp;</b> operators close the standard input and output,
       respectively, but the operators can be prefixed with a non-negative integer so that another file
       descriptor is closed.

       In the POSIXly-correct mode, a file descriptor must be readable when duplicated by the <b>&lt;&amp;</b> operator and
       writable when duplicated by the <b>&gt;&amp;</b> operator.

   <b>Here</b> <b>documents</b> <b>and</b> <b>here</b> <b>strings</b>
       <u>Here</u> <u>document</u> and <u>here</u> <u>string</u> allow redirection to file descriptors that reads strings directly specified
       in shell commands.

       Here document
           <b>&lt;&lt;</b> <u>token</u>

           <b>&lt;&lt;-</b> <u>token</u>

       Here string
           <b>&lt;&lt;&lt;</b> <u>token</u>

       In a here document or here string, the standard input is replaced with a readable file descriptor. When
       the command reads from the file descriptor, it will read the contents of the here document/string, which
       is defined below.

       When a here document operator (<b>&lt;&lt;</b> or <b>&lt;&lt;-</b>) appears in a command, the shell reads the contents of the here
       document starting from the next line. The contents of here documents are not parsed nor executed as
       commands. The <u>token</u> after the operand specifies a delimiter that indicates the end of the contents. (The
       <u>token</u> is not subject to any expansion, but quotation is processed.) The contents of the here document is
       terminated just before the first line containing the <u>token</u> only. When using the <b>&lt;&lt;-</b> operator, all tab
       characters at the beginning of each line in the here document contents are removed and the delimiter
       <u>token</u> may be preceded by tab characters.

       If there are more than one here document operator on one line, the contents of the here documents are
       parsed in order: The contents of the first here document starts from the next line and ends before the
       first line containing the <u>token</u> that followed the first operator. Just after that line, the contents of
       the second here document starts, and so on.

       The contents of here documents are treated literally: whitespaces, tabs, etc. remain as is. The exception
       is that, when the <u>token</u> is not quoted at all:

       •   the contents are subject to parameter expansion, command substitution, arithmetic expansion.

       •   a backslash in the contents is treated as quotation if and only if it precedes <b>$</b>, <b>`</b>, <b>"</b>, or another
           backslash.

       •   a backslash followed by a newline is treated as line continuation.

       In here string, the <u>token</u> after the operator is subject to expansion as in redirection to files. The
       expansion result becomes the contents of the here string. A newline character is automatically appended
       to the end of here string contents.

       Here string is yash’s extension that is not defined in POSIX. Other shells like bash, ksh, and zsh have
       the same feature.

   <b>Pipeline</b> <b>redirection</b>
       <u>Pipeline</u> <u>redirection</u> allows opening pipelines that can be used for arbitrary purposes.

       Pipeline redirection
           <b>&gt;&gt;|</b> <u>token</u>

       The <u>token</u> is subject to expansion as in redirection to files, but it is treated as a file descriptor
       rather than a pathname. Thus the expanded <u>token</u> must be a non-negative integer.

       Pipeline redirection opens a new pipeline. The standard output (or the file descriptor specified before
       the operator, if any) is replaced with the file descriptor open for writing to the pipeline. The file
       descriptor specified by <u>token</u> is replaced with the file descriptor open for reading from the pipeline.

       Pipeline redirection is yash’s extension that is not defined in POSIX.

   <b>Process</b> <b>redirection</b>
       <u>Process</u> <u>redirection</u> creates a pipeline connected to another command.

       Process redirection
           <b>&lt;(</b><u>command</u><b>...)</b>

           <b>&gt;(</b><u>command</u><b>...)</b>

       In process redirection, the <u>command</u> specified is executed in a subshell. If the process redirection is of
       the form <b>&lt;(</b><u>command</u><b>...)</b>, the standard output of <u>command</u> is connected with a pipeline to the standard input
       of the command the redirection is associated with. If the process redirection is of the form
       <b>&gt;(</b><u>command</u><b>...)</b>, the standard input of <u>command</u> is connected with a pipeline to the standard output of the
       command the redirection is associated with.

       Process redirection is yash’s extension that is not defined in POSIX. Bash and zsh have a feature called
       process substitution, which uses the same syntax as yash’s process redirection, but incompatibly differs
       in behavior.

</pre><h4><b>COMMAND</b> <b>EXECUTION</b></h4><pre>
       This section describes how commands are executed.

   <b>Execution</b> <b>of</b> <b>simple</b> <b>commands</b>
       A simple command is executed as follows:

        1. All tokens in the simple command are expanded except for assignment and redirection tokens. If an
           error occurs during expansion, the execution of the simple command is aborted with a non-zero exit
           status.

           In the following steps, the first word of the expansion results is referred to as <u>command</u> <u>name</u>, and
           the other words as <u>command</u> <u>arguments</u>. If there is only one word of the expansion results, there are
           no command argument words. If there are none of the expansion results, there is no command name
           either.

        2. If the command name exists and there are any redirections specified in the command, they are
           processed. The word token after each redirection operator is expanded. If an error occurs during
           processing the redirections (including when expanding the word token), the execution of this simple
           command is aborted with a non-zero exit status.

               <b>Note</b>
               In other shells, redirections may be processed in a different step: POSIX does not specify the
               order in which redirections and assignments are processed when there is no command name or the
               name denotes a special built-in.

        3. Assignments specified in the command, if any, are processed. For each assignment token, the value is
           expanded and assigned to the specified variable. If an error occurs during assignments (including
           when expanding the values to be assigned), the execution of this simple command is aborted with a
           non-zero exit status.

           •   If there is no command name or the name denotes a special built-in, the assignments are
               permanent: the assigned values remain after the command has finished (until the variable is
               reassigned).

           •   Otherwise, the assignments are temporary: the assigned values only last during the execution of
               this simple command.

           The assigned variables are automatically exported when the command name is specified or the
           all-export option is enabled.

               <b>Note</b>
               In other shells, assignments may behave differently: For special built-ins and functions,
               assigned variables may not be exported. For functions, assigned variables may be persistent, that
               is, may remain even after the execution of the simple command.

        4. If there is no command name, the redirections are processed in a subshell, then the command execution
           ends. If an error occurs in the redirections, the exit status of the simple command is non-zero. If
           there were any command substitutions performed in the assignments, the exit status of the simple
           command is that of the last executed command substitution. Otherwise, the exit status is zero.

        5. A command to be executed is determined using the command search algorithm and the command is
           executed.

           •   If the command is an external command, the command is executed by creating a new subshell and
               calling the “exec” system call in the subshell. The command name and arguments are passed to the
               executed command. Exported variables are passed to the executed command as environment variables.

           •   If the command is a built-in, the built-in is executed with the command arguments passed to the
               built-in. As an exception, in the POSIXly-correct mode, the built-in is not executed if it is an
               elective built-in.

           •   If the command is a function, the contents of the function are executed with the command
               arguments as function arguments.

           If the command was executed, the exit status of this simple command is that of the executed command.
           If the algorithm failed to determine a command, no command is executed and the exit status is 127. If
           the shell failed to execute the determined command, the exit status is 126. If the executed command
           was killed by a signal, the exit status is the signal number plus 384. If the elective built-in was
           not executed in the POSIXly-correct mode, the exit status is 127.

               <b>Note</b>
               In shells other than yash, the exit status may be different when the command was killed by a
               signal, because the POSIX standard only requires that the exit status be "greater than 128."
           If the shell is not in the POSIXly-correct mode and the algorithm failed to determine a command, the
           command <b>eval</b> <b>-i</b> <b>--</b> <b>"${COMMAND_NOT_FOUND_HANDLER-}"</b> is evaluated. During the command execution,
           positional parameters are temporarily set to the command name and arguments that resulted in the
           first step. Any local variables defined during the execution are removed when the execution is
           finished. The <b>HANDLED</b> local variable is automatically defined with the initial value being the empty
           string. If the <b>HANDLED</b> variable has a non-empty value when the execution of the command string is
           finished, the shell pretends that the command was successfully determined and executed. The exit
           status of the simple command is that of the command string in this case.

       <b>Command</b> <b>search</b>

           A command that is executed in a simple command is determined by the command name using the following
           algorithm:

            1. If the command name contains a slash (<b>/</b>), the whole name is treated as the pathname of an
               external command. The external command is determined as the executed command.

            2. If the command name is a special built-in, the built-in is determined as the executed command.

            3. If the command name is the name of an existing function, the function is determined as the
               executed command.

            4. If the command name is a mandatory or elective built-in, the built-in is determined as the
               executed command.

            5. If the command name is an extension built-in and the shell is not in the POSIXly-correct mode,
               the built-in is determined as the executed command.

            6. The shell searches the PATH for a executed command:

               The value of the <b>PATH</b> variable is separated by colons. Each separated part is considered as a
               directory pathname (an empty pathname denotes the current working directory). The shell searches
               the directories (in the order of appearance) and checks if any directory directly contains an
               executable regular file whose name is equal to the command name. If such a file is found:

               •   If the command name is the name of a substitutive built-in, the built-in is determined as the
                   executed command.

               •   Otherwise, the file is determined as the executed command. (The file will be executed as an
                   external command.)

               If no such file is found, no command is determined as the executed command.

           When the shell finds a file that matches the command name during the search above, the shell
           remembers the pathname of the file if it is an absolute path. When the algorithm above is used for
           the same command name again, the shell skips searching and directly determines the command to be
           executed. If an executable regular file no longer exists at the remembered pathname, however, the
           shell searches again to update the remembered pathname. You can manage remembered pathnames using the
           hash built-in.

   <b>Termination</b> <b>of</b> <b>the</b> <b>shell</b>
       The shell exits when it reached the end of input and has parsed and executed all input commands or when
       the exit built-in is executed. The exit status of the shell is that of the last command the shell
       executed (or zero if no commands were executed). The exit status of the shell is always between 0 and 255
       (inclusive). If the exit status of the last command is 256 or larger, the exit status of the shell will
       be the remainder of the exit status divided by 256.

       If an exit handler has been registered by the trap built-in, the handler is executed just before the
       shell exits. The exit status of the commands executed in the handler does not affect the exit status of
       the shell.

       If a non-interactive shell encountered one of the following errors, the shell immediately exits with a
       non-zero exit status:

       •   A command cannot be parsed due to an syntax error (except during shell initialization).

       •   An error occurs during execution of a special built-in in the POSIXly-correct mode.

       •   A redirection error occurs in a simple command whose command name is a special built-in and the shell
           is in the POSIXly-correct mode.

       •   An assignment error occurs in a simple command.

       •   An error occurs during expansion (except during shell initialization).

           <b>Note</b>

           Some shells other than yash exit when they fail to find a command to execute in command search.

   <b>Functions</b>
       <u>Functions</u> allow executing a compound command as a simple command. A function can be defined by the
       function definition command and executed by a simple command. You can use the unset built-in to remove
       function definitions.

       There are no functions predefined when yash is started.

       A function is executed by executing its body, which is a compound command. While the function is being
       executed, positional parameters are set to the arguments given to the function. The old positional
       parameters are restored when the function execution finishes.

       <b>Local</b> <b>variables</b>

           <u>Local</u> <u>variables</u> are temporary variables that are defined in a function and exist during the function
           execution only. They can be defined by the typeset built-in or implicitly created by a for loop. They
           are removed when the function execution finishes.

           Local variables may <u>hide</u> variables that have already been defined before the function execution had
           started. An existing variable becomes inaccessible if a local variable of the same name is defined in
           a function. The old variable becomes accessible again when the function execution finishes.

           You cannot create a local variable when not executing a function. A normal variable is created if you
           try to do so.

   <b>Command</b> <b>execution</b> <b>environment</b>
       The shell holds following properties during execution.

       •   The working directory

       •   Open file descriptors

       •   The file creation mask (umask)

       •   The set of signals whose handler is set to “ignore” (trap)

       •   Environment variables

       •   Resource limits (ulimit)

       Those properties are inherited from the invoker of the shell to the shell, and from the shell to each
       external command executed by the shell.

       The properties can be changed during the execution of the shell by built-in commands, variable
       assignments, etc.

       <b>Subshells</b>

           A <u>subshell</u> is a copy of the shell process. Subshells are used in execution of groupings, pipelines,
           etc.

           Subshells inherit functions, aliases, etc. defined in the shell as well as the properties above since
           subshells are copies of the shell process. Notable exceptions are:

           •   Traps registered by the trap built-in are all reset in subshells except for ones whose action is
               set to “ignore”. (See below)

           •   The interactive mode and job control are disabled in subshells. Jobs are not inherited by
               subshells.

           Subshells are executed independently of the original shell, so changes of any properties above do not
           affect those of the original shell.

               <b>Note</b>

               If the subshell contains a single trap built-in, some shells (but not yash) may not reset the
               traps on entry to the subshell.

</pre><h4><b>INTERACTIVE</b> <b>MODE</b></h4><pre>
       The <u>interactive</u> <u>mode</u> is a mode of the shell intended for direct interaction with a user. If yash is in
       the interactive mode, it is called an <u>interactive</u> <u>shell</u>.

       Whether a shell runs in the interactive mode or not is determined in the invocation of the shell. After
       the shell has started up, the interactive mode cannot be switched on or off.

       When the shell is interactive:

       •   Initialization scripts are executed during invocation.

       •   The shell checks for mail and prints a command prompt when it reads a command. Job status changes are
           also reported if job control is active.  Line-editing may be used depending on the capability of the
           terminal.

       •   Commands executed are automatically registered in command history.

       •   If a command executed by the shell is killed by a signal other than SIGINT and SIGPIPE, the shell
           reports the fact to the standard error.

       •   The filename token is subject to pathname expansion in file redirection.

       •   The shell does not exit when it encounters a syntax or expansion error during command execution. (cf.
           Termination of the shell)

       •   The shell does not exit when it receives the SIGINT, SIGTERM, or SIGQUIT signal.

       •   A signal handler can be changed by the trap built-in even if the handler had been set to “ignore”
           when the shell was invoked.

       •   The value of the <b>-</b> special parameter contains <b>i</b>.

       •   The shell’s locale reflects the value of the <b>LC_CTYPE</b> variable whenever the value is changed (if the
           shell is not in the POSIXly-correct mode).

       •   Commands are executed even when the exec option is off.

       •   The ignore-eof option takes effect when enabled.

       •   When the shell reaches the end of input or the exit built-in is executed, the shell checks if there
           is any stopped job. If so, the shell prints a warning and does not actually exit.

       •   The suspend built-in by default cannot stop the shell if it is a session leader.

       •   The shell does not exit when the dot built-in fails to find a script file to read.

       •   The shell does not exit when the exec built-in fails to execute a command (if not in the
           POSIXly-correct mode).

       •   When a job finished for which the wait built-in has been waiting, the fact is reported (only if job
           control is active and not in the POSIXly-correct mode).

       •   A prompt is printed when the read built-in reads a second or following line.

   <b>Prompts</b>
       The interactive shell prints a <u>prompt</u> just before it reads a command. The contents of the prompt is
       specified by the value of the <b>PS1</b> and <b>PS2</b> variables. The former is used for reading the first line of the
       command and the latter for other lines.

       When the prompt is printed, the variable value is subjected to parameter expansion, command substitution,
       and arithmetic expansion (but note that the POSIX standard requires parameter expansion only). The result
       of the expansion is parsed by the rules below to make the actual prompt string, which is printed to the
       standard error.

       In the POSIXly-correct mode, each exclamation mark (<b>!</b>) in the string is substituted with the command
       history number of the command that is being input. Two adjacent exclamation marks (<b>!!</b>) are printed as a
       single exclamation. Other characters are printed intact.

       If the shell is not in the POSIXly-command mode, the following notations can be used to format the prompt
       string. Notations are replaced with the strings designated in the list below. Characters that are not
       interpreted as notations are printed intact.

       <b>\a</b>
           Bell character (ASCII code: 7)

       <b>\e</b>
           Escape character (ASCII code: 27)

       <b>\j</b>
           The number of jobs in the shell.

       <b>\n</b>
           Newline character (ASCII code: 10)

       <b>\r</b>
           Carriage return character (ASCII code: 13)

       <b>\!</b>
           The command history number of the command that is being input

       <b>\$</b>
           <b>#</b> if the shell’s effective user ID is 0; <b>$</b> otherwise.

       <b>\\</b>
           Backslash

       <b>\[</b>, <b>\]</b>
           These two notations can surround part of the prompt string that is not visible on the terminal. The
           surrounded part is ignored when the shell counts the number of characters that is displayed on the
           terminal, thus making characters correctly aligned on the terminal when the prompt string contains
           special invisible characters.

       <b>\f</b><u>fontspecs</u><b>.</b>
           When line-editing is active, this notation is replaced with special characters to change font styles
           on the terminal if the terminal is capable of it. If line-editing is inactive or the terminal is
           incapable of changing font styles, this notation is silently ignored. One or more of the following
           can be used for <u>fontspecs</u>:

           <b>k</b>
               Change font color to black

           <b>r</b>
               Change font color to red

           <b>g</b>
               Change font color to green

           <b>y</b>
               Change font color to yellow

           <b>b</b>
               Change font color to blue

           <b>m</b>
               Change font color to magenta

           <b>c</b>
               Change font color to cyan

           <b>w</b>
               Change font color to white

           <b>K</b>
               Change background color to black

           <b>R</b>
               Change background color to red

           <b>G</b>
               Change background color to green

           <b>Y</b>
               Change background color to yellow

           <b>B</b>
               Change background color to blue

           <b>M</b>
               Change background color to magenta

           <b>C</b>
               Change background color to cyan

           <b>W</b>
               Change background color to white

           <b>t</b>
               Make font color or background brighter (can only be used just after one of the characters above)

           <b>d</b>
               Change font and background colors to normal

           <b>s</b>
               Make font standout

           <b>u</b>
               Make font underlined

           <b>v</b>
               Make font and background colors reversed

           <b>b</b>
               Make font blink

           <b>i</b>
               Make font dim

           <b>o</b>
               Make font bold

           <b>x</b>
               Make font invisible

           <b>D</b>
               Make color and style normal

           The actual colors of font and background are defined by the terminal. Different terminals may use
           different colors.

       In addition to the normal prompt, a prompt string can be displayed to the right of the cursor if
       line-editing is active. Those prompts are called <u>right</u> <u>prompts</u>. The contents of right prompts are defined
       by the value of the <b>PS1R</b> and <b>PS2R</b> variables, each corresponding to the <b>PS1</b> and <b>PS2</b> variables.

       Using the above-said notations, the font style of command strings the user inputs can be changed as well
       as that of prompts. The font style of command strings is defined by the value of the <b>PS1S</b> and <b>PS2S</b>
       variables, each corresponding to the <b>PS1</b> and <b>PS2</b> variables. The value can contain the <b>\f</b><u>fontspecs</u><b>.</b>
       notation only. If you enable command line prediction, the predicted part of the command line can also be
       styled with the <b>PS1P</b> and <b>PS2P</b> variables.

       When the shell is not in the POSIXly-correct mode, the prompt variables can be defined with a name
       prefixed with <b>YASH_</b> (e.g. <b>YASH_PS1</b>). This allows using a different prompt string than that in the
       POSIXly-correct mode.

       When the shell is not in the POSIXly-correct mode, the value of the <b>PROMPT_COMMAND</b> variable is executed
       before each prompt.

   <b>Command</b> <b>history</b>
       <u>Command</u> <u>history</u> is a feature of the shell that remembers executed commands to allow re-executing them
       later. Commands executed in the interactive mode are automatically saved in the command history. Saved
       commands can be edited and re-executed using line-editing and the fc and history built-ins.

       Commands are saved line by line. Lines that do not contain any non-whitespace characters are not saved in
       the history. Lines that start with whitespaces are not saved when the hist-space option is on.

       Command history is saved in a file. When history is first used after an interactive shell was started,
       the shell opens a file to save history in. The filename is specified by the value of the <b>HISTFILE</b>
       variable. If the file contains history data when opened, the data is restored to the shell’s history. The
       file contents are updated in real time as the user inputs commands into the shell. If the <b>HISTFILE</b>
       variable is not set or the file cannot be opened successfully, history is not saved in the file, but the
       history feature will be functional in all other respects.

       The number of commands saved in history is specified by the value of the <b>HISTSIZE</b> variable. The shell
       automatically removes old history data so that the number of saved commands does not exceed the value. If
       the <b>HISTSIZE</b> variable is not set or its value is not a natural number, 500 items will be saved in
       history.

       The shell looks at the value of the <b>HISTFILE</b> and <b>HISTSIZE</b> variables only when the history feature is
       first used after the shell was started. “The history feature is used” when:

       •   the fc or history built-in is executed,

       •   line-editing is used (regardless of whether or not history data is recalled in line-editing), or

       •   a command is input to the shell

       Therefore, the variables should be set in initialization scripts.

       When more than one instance of yash shares a single history file, all the shells use the same history
       data. As a result, commands that have been executed by a shell instance can be recalled on another shell
       instance. Shells sharing the same history should have the same <b>HISTSIZE</b> value so that they manipulate
       history data properly.

       Yash’s history data file has its own format that is incompatible with other kinds of shells.

       The <b>HISTRMDUP</b> variable can be set to remove duplicate history items.

   <b>Mail</b> <b>checking</b>
       An interactive shell can notify receipt of email. The shell periodically checks the modification
       date/time of a file specified by the user. If the file has been modified since the previous check, the
       shell prints a notification message (except when the shell is not in the POSIXly-correct mode and the
       file is empty). By specifying a mailbox file to be checked, the shell will print a message when the file
       has been modified, that is, some mail has been received.

       Check is done just before the shell prints a command line prompt. The interval of checks can be specified
       by the <b>MAILCHECK</b> variable in seconds. If the variable value is 0, check is done before every prompt. If
       the variable value is not a non-negative integer, no checks are done.

       The file whose modification time is checked is specified by the <b>MAIL</b> variable. The variable value should
       be set to the pathname of the file.

       If you want to check more than one file or customize the notification message, you can set the <b>MAILPATH</b>
       variable instead of the <b>MAIL</b> variable. When the <b>MAILPATH</b> variable is set, the <b>MAIL</b> variable is ignored.
       The value of the <b>MAILPATH</b> variable should be set to one or more colon-separated pathnames of files to be
       checked. Each pathname can be followed by a percent sign (<b>%</b>) and a custom notification message, which is
       printed when the corresponding file has been modified. If the pathname contains a percent sign, it should
       be quoted by a backslash. The specified message is subject to parameter expansion. For example, if the
       value of the <b>MAILPATH</b> variable is <b>/foo/mail%New</b> <b>mail!:/bar/mailbox%You've</b> <b>got</b> <b>mail:/baz/mail\%data</b>, the
       shell will print

       •   <b>New</b> <b>mail!</b>  when the file /foo/mail has been modified

       •   <b>You've</b> <b>got</b> <b>mail</b> when the file /bar/mailbox has been modified

       •   the default message when the file /baz/mail%data has been modified.

</pre><h4><b>JOB</b> <b>CONTROL</b></h4><pre>
       <u>Job</u> <u>control</u> is a function of the shell that executes multiple commands simultaneously and
       suspends/resumes the commands.

       When job control is active:

       •   Every pipeline executed by the shell becomes a <u>job</u>. A job has its unique process group ID that is
           shared among all processes in the job.

       •   If the processes of a job are suspended while the shell is waiting for the processes to finish, the
           shell continues to the next command as if the process have finished. The shell remembers the job as
           suspended so that it can be resumed later.

       •   If a job is executed synchronously, the shell sets the foreground process group of the terminal to
           the process group of the job. When the job is finished (or suspended), the shell gets back to the
           foreground.

       •   If the shell is interactive, job status is reported before every command line prompt as if the
           command <b>jobs</b> <b>-n</b> is executed.

       •   The standard input of an asynchronous command is not automatically redirected to /dev/null.

       •   The shell does not stop when it receives the SIGTTIN, SIGTTOU, or SIGTSTP signal.

       •   The value of the <b>-</b> special parameter contains <b>m</b>.

       •   When a job finished for which the wait built-in has been waiting, the fact is reported (only if the
           shell is interactive and not in the POSIXly-correct mode).

       When job control is inactive, processes executed by the shell have the same process group ID as the
       shell. The shell treats asynchronous commands as an uncontrolled job.

       You can use the following built-ins to manipulate jobs:

       jobs
           prints existing jobs

       fg and bg
           run jobs in the foreground or background

       wait
           waits for jobs to be finished (or suspended)

       disown
           forgets jobs

       kill
           sends a signal to jobs

       An interactive job-controlling shell reports jobs status before every prompt by default. You can set the
       following options to make the shell report status at other timings:

       notify
           the shell reports immediately whenever job status changes.

       notify-le
           the shell reports immediately when job status changes while line-editing.

       A job is removed from the shell’s job list when:

       •   it has finished and the jobs built-in reported it,

       •   the wait built-in successfully waited for the job to finish, or

       •   the disown built-in removed the job.

       Jobs are not removed from the list when an interactive shell automatically reports the status of jobs.

           <b>Note</b>

           The word “stop” is synonymous to “suspend” in the context of job control.

   <b>Job</b> <b>ID</b>
       Some built-ins use the following notation, which is called <u>job</u> <u>ID</u>, to specify a job to operate on:

       <b>%</b>, <b>%%</b>, <b>%+</b>
           the current job

       <b>%-</b>
           the previous job

       <b>%</b><u>n</u>
           the job that has job number <u>n</u>, where <u>n</u> is a positive integer

       <b>%</b><u>string</u>
           the job whose name begins with <u>string</u>

       <b>%?</b><u>string</u>
           the job whose name contains <u>string</u>

       The <u>current</u> <u>job</u> and <u>previous</u> <u>job</u> are jobs selected by the shell according to the following rules:

       •   When there is one or more suspended jobs, the current job is selected from them.

       •   When there is one or more suspended jobs other than the current job, the previous job is selected
           from them.

       •   The current and previous jobs are always different. When the shell has only one job, it is the
           current job and there is no previous job.

       •   When the current job finished, the previous job becomes the current job.

       •   When the current job is changed, the old current job becomes the previous job except when the old job
           finished.

       •   When the foreground job is suspended, the job becomes the current job.

       Yash has some options to modify the rules of the current/previous job selection. (The rules above have
       priority over the options below.)

       cur-async
           When a new asynchronous command is started, it becomes the current job.

       cur-bg
           When a job is resumed by the bg built-in, the job becomes the current job.

       cur-stop
           When a job is suspended, it becomes the current job.

       The current and previous jobs are not changed as long as the rules above are met.

       The rules of the current/previous job selection defined in the POSIX standard are looser than yash’s
       rules above. Other POSIX-compliant shells may select the current and previous jobs differently.

</pre><h4><b>BUILT-IN</b> <b>COMMANDS</b></h4><pre>
       <u>Built-in</u> <u>commands</u> are commands that are implemented in the shell and are executed by the shell without
       starting external programs.

   <b>Types</b> <b>of</b> <b>built-in</b> <b>commands</b>
       Yash has several types of built-in commands described below.

       <u>Special</u> <u>built-in</u> <u>commands</u> are the most important kinds of built-in commands. They are executed regardless
       of whether the corresponding external commands exist or not. Results of variable assignments that occur
       in a simple command that invokes a special built-in last after the command has finished. Moreover, in the
       POSIXly-correct mode, a non-interactive shell immediately exits with a non-zero exit status when an error
       occurs in a simple command executing a special built-in.

       <u>Mandatory</u> <u>built-in</u> <u>commands</u> and <u>elective</u> <u>built-in</u> <u>commands</u> are similar to special built-ins in that they
       do not need external commands to be executed but differ in that they may be overridden by functions.
       While mandatory built-ins are always available, you cannot use elective built-ins in the POSIXly-correct
       mode because POSIX only reserves their names without defining their behavior.

       An <u>extension</u> <u>built-in</u> <u>command</u> is a built-in that is not mentioned in POSIX. Like an elective built-in, it
       can be executed without an external command when the POSIXly-correct mode is off. However, when the
       POSIXly-correct mode is on, the shell works as if the built-in does not exist.

       <u>Substitutive</u> <u>built-in</u> <u>commands</u> work on behalf of external commands found in PATH. These built-ins improve
       execution speed by bypassing invocation overheads for external programs.

   <b>Syntax</b> <b>of</b> <b>command</b> <b>arguments</b>
       In this section we explain common rules about command arguments. The built-in commands of yash follow the
       rules unless otherwise stated.

       There are two types of command arguments. One is options and the other is operands. An option is an
       argument that starts with a hyphen (<b>-</b>) and changes the way the command behaves. Some options take
       arguments. An operand is an argument that is not an option and specifies objects the command operates on.

       If you specify more than one option to a command, the order of the options are normally not significant.
       The order of operands, however, affects the command behavior.

       An option is either a single-character option or a long option. A single-character option is identified
       by one alphabetic character. A long option is identified by multiple alphabetic characters. The POSIX
       standard only prescribes single-character options, so in the POSIXly-correct mode you cannot use long
       options.

       A single-character option is composed of a hyphen followed by a letter. For example, <b>-a</b> is a
       single-character option. A single-character option that takes an argument requires the argument to be
       just after the option name.

       <b>Example</b> <b>4.</b> <b>The</b> <b>set</b> <b>built-in</b> <b>and</b> <b>single-character</b> <b>options</b>

       For the set built-in, <b>-m</b> is a single-character option that does not take an argument and <b>-o</b> is one that
       takes an argument.

       •   <b>set</b> <b>-o</b> <b>errexit</b> <b>-m</b>

       •   <b>set</b> <b>-oerrexit</b> <b>-m</b>

       In these two command lines, <b>errexit</b> is the argument to the <b>-o</b> option.

       In the second example above, the <b>-o</b> option and its argument are combined into a single command line
       argument. The POSIX standard deprecates that style and any POSIX-conforming applications must specify
       options and their arguments as separate command line arguments, although yash accepts both styles.

       You can combine single-character options that do not take arguments into a single command line argument.
       For example, the three options <b>-a</b>, <b>-b</b> and <b>-c</b> can be combined into <b>-abc</b>.

       A long option is composed of two hyphens followed by an option name. For example, <b>--long-option</b> is a long
       option. You can omit some last characters of a long option name as long as it is not ambiguous. For
       example, you can use <b>--long</b> instead of <b>--long-option</b> if there is no other options beginning with <b>--long</b>.
       Like a single-character option, a long option that takes an argument requires the argument to be a
       command line argument just after the option name or to be specified in the same command line argument as
       the option name, separated by an equal sign (<b>=</b>).

       <b>Example</b> <b>5.</b> <b>The</b> <b>fc</b> <b>built-in</b> <b>and</b> <b>long</b> <b>options</b>

       For the fc built-in, <b>--quiet</b> is a long option that does not take an argument and <b>--editor</b> is one that
       takes an argument.

       •   <b>fc</b> <b>--editor</b> <b>vi</b> <b>--quiet</b>

       •   <b>fc</b> <b>--editor=vi</b> <b>--quiet</b>

       In these command lines, <b>vi</b> is the argument to the <b>--editor</b> option.

       Arguments that are not options (nor arguments to them) are interpreted as operands. The POSIX standard
       requires all options should be specified before any operands. Therefore, in the POSIXly-correct mode, any
       arguments that come after the first operand are interpreted as operands (even if they look like options).
       If not in the POSIXly-correct mode, you can specify options after operand.

       Regardless of whether the shell is in the POSIXly-correct mode or not, an argument that is just composed
       of two hyphens (<b>--</b>) can be used as a separator between options and operands. All command line arguments
       after the <b>--</b> separator are interpreted as operands, so you can specify operands that start with a hyphen
       correctly using the separator.

       <b>Example</b> <b>6.</b> <b>Options</b> <b>and</b> <b>operands</b> <b>to</b> <b>the</b> <b>set</b> <b>built-in</b>

       •   <b>set</b> <b>-a</b> <b>-b</b> <b>--</b> <b>-c</b> <b>-d</b>

       In this example, <b>-a</b> and <b>-b</b> are options and <b>-c</b> and <b>-d</b> are operands. The <b>--</b> separator itself is neither an
       option nor an operand.

       Regardless of whether the shell is in the POSIXly-correct mode or not, an argument that is just composed
       of a single hyphen (<b>-</b>) is interpreted as an operand.

</pre><h4><b>LINE-EDITING</b></h4><pre>
       With the <u>line-editing</u> feature, you can edit the command text when you input a command to an interactive
       shell. It not only works as a simple visual-interface editor, but also is integrated with the command
       history. You can recall, edit, and execute commands in the history with line-editing instead of using the
       fc built-in.

       Line-editing has two editing modes, the vi and emacs modes, which each have their own key binding
       settings. By switching editing modes, you can change key bindings used in line-editing. Each mode has a
       corresponding shell option, which determines whether the mode is currently active or not. No more than
       one mode can be active at a time, so the options for the other modes are automatically turned off when
       you turn on the option for one mode. The whole line-editing feature is deactivated when those options are
       off.

       When an interactive shell is started, the vi mode is automatically activated if the standard input and
       error are both connected to a terminal.

       Line-editing can be used only when the standard input and error are both connected to a terminal. If not,
       the shell silently falls back to the normal input mechanism. While line-editing is being used, the shell
       uses the termios interface to change I/O settings of the terminal and the terminfo interface to parse
       input key sequences.

   <b>Shell</b> <b>options</b> <b>on</b> <b>line-editing</b>
       The following options can be set by the set built-in to enable line-editing and choose an editing mode to
       activate:

       vi
           activates the vi mode.

       emacs
           activates the emacs mode.

       The other line-editing-related options are:

       le-always-rp
           When this options is enabled, the right prompt is always visible: when the cursor reaches the right
           prompt, it moves to the next line from the original position, which would otherwise be overwritten by
           input text.

       le-comp-debug
           When enabled, internal information is printed during completion, which will help debugging completion
           scripts.

       le-conv-meta
           When enabled, the 8th bit of each input byte is always treated as a meta-key flag, regardless of
           terminfo data.

       le-no-conv-meta
           When enabled, the 8th bit of each input byte is never treated as a meta-key flag, regardless of
           terminfo data.

           The le-conv-meta and le-no-conv-meta options cannot be both enabled at a time. When either is
           enabled, the other is automatically disabled. When neither is enabled, the 8th bit may be treated as
           a meta-key flag depending on terminfo data.

       le-predict
           activates command line prediction.

       le-predict-empty
           When enabled, and command line prediction is active, suggestions are also provided for empty input
           lines.

       le-prompt-sp
           When enabled, the shell prints a special character sequence before printing each prompt so that every
           prompt is printed at the beginning of a line.

           This option is enabled by default.

       le-visible-bell
           When enabled, the shell flashes the terminal instead of sounding an alarm when an alert is required.

       le-trim-right
           When enabled, the right prompt, set by YASH_PS1R will right justify all the way to the edge of the
           screen, the default behaviour is to leave an empty space for the cursor when the prompt is too large.

   <b>Editing</b> <b>modes</b>
       The <u>vi</u> <u>mode</u> is an editing mode that offers key bindings similar to that of the vi editor. The vi mode has
       two sub-modes that are switched during editing: the insert and command modes. The sub-mode is always
       reset to the insert mode when line-editing is started for a new command line. In the insert mode, most
       characters are inserted to the buffer as typed. In the command mode, input characters are treated as
       commands that move the cursor, insert/delete text, etc.

       The <u>emacs</u> <u>mode</u> offers key bindings similar to the emacs editor. Most characters are inserted to the
       buffer as typed, but more characters are treated as commands than the vi insert mode.

       Another sub-mode is used while you enter search keywords. The sub-mode is called the <u>search</u> <u>mode</u>, which
       offers slightly different key bindings depending on the active editing mode.

   <b>Line-editing</b> <b>commands</b>
       All characters the user enters while line-editing is active are treated as line-editing commands listed
       below. The bindkey built-in allows customizing the key bindings of each mode (except for the search
       mode).

       The list below shows not only the functions of commands but also the default key bindings. The keywords
       “vi-insert”, “vi-command”, “vi-search”, “emacs”, “emacs-search” means the vi insert mode, the vi command
       mode, the search mode for the vi mode (the vi search mode), the emacs mode, and the search mode for the
       emacs mode (the emacs search mode), respectively.

       Some commands take an argument that affects the function of the commands. For example, the forward-char
       command moves the cursor by as many characters as specified by the argument. To specify an argument, use
       the digit-argument command just before another command that takes an argument.

       <b>Basic</b> <b>editing</b> <b>commands</b>

           noop
               Do nothing.

               vi-command
                   <b>\^[</b>

           alert
               Alert.

           self-insert
               Insert the input character at the current cursor position. Characters escaped by escape sequences
               cannot be inserted.

               vi-insert, emacs
                   <b>\\</b>

           insert-tab
               Insert a tab character at the current cursor position.

               emacs
                   <b>\^[\^I</b>

           expect-verbatim
               Insert a character that is entered just after this command at the current cursor position. This
               command can input a character that cannot be input by the self-insert command, except a null
               character (<b>'\0'</b>).

               vi-insert, vi-search, emacs-search
                   <b>\^V</b>

               emacs
                   <b>\^Q</b>, <b>\^V</b>

           digit-argument
               Pass the input digit to the next command as an argument.

               This command can be bound to a digit or hyphen. To pass “12” as an argument to the forward-char
               command in the vi mode, for example, enter <b>12l</b>.

               vi-command
                   <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b>

               emacs
                   <b>\^[0</b>, <b>\^[1</b>, <b>\^[2</b>, <b>\^[3</b>, <b>\^[4</b>, <b>\^[5</b>, <b>\^[6</b>, <b>\^[7</b>, <b>\^[8</b>, <b>\^[9</b>, <b>\^[-</b>,

           bol-or-digit
               Like the beginning-of-line command if there is no argument; like the digit-argument command
               otherwise.

               vi-command
                   <b>0</b>

           accept-line
               Finish editing the current line. A newline is automatically appended to the line. The line will
               be executed by the shell.

               If command line prediction is active, the current prediction (if any) is ignored. See also the
               accept-prediction command.

               vi-insert, vi-command, emacs
                   <b>\^J</b>, <b>\^M</b>, <b>\et</b>

               emacs-search
                   <b>\^M</b>, <b>\et</b>

           abort-line
               Abandon the current buffer and finish editing as if an empty line was input.

               vi-insert, vi-command, vi-search, emacs, emacs-search
                   <b>\!</b>, <b>\^C</b>

           eof
               Abandon the current buffer and finish editing as if the shell reached the end of input. This
               normally makes the shell exit.

           eof-if-empty
               Like the eof command if the buffer is empty; like the alert command otherwise.

               vi-insert, vi-command
                   <b>\#</b>, <b>\^D</b>

           eof-or-delete
               Like the eof command if the buffer is empty; like the delete-char command otherwise.

               emacs
                   <b>\#</b>, <b>\^D</b>

           accept-with-hash
               If the current line does not begin with a hash sign (<b>#</b>) or there is no argument specified for
               this command, a hash sign is inserted at the beginning of the line. Otherwise, the beginning hash
               sign is removed from the line. Finally, the line is accepted like the accept-line command.

               vi-command
                   <b>#</b>

               emacs
                   <b>\^[#</b>

           accept-prediction
               Like the accept-line command, but include the predicted part.

           setmode-viinsert
               Switch to the vi insert mode.

               vi-command
                   <b>i</b>, <b>\I</b>

           setmode-vicommand
               Switch to the vi command mode.

               vi-insert
                   <b>\^[</b>

           setmode-emacs
               Switch to the emacs mode.

           expect-char, abort-expect-char
               These commands are not meant for use by the user. They are used by the shell to implement some
               other commands.

           redraw-all
               Reprint the prompt and the current line to the terminal. If any argument is passed, the terminal
               screen is cleared.

               vi-insert, vi-command, vi-search, emacs, emacs-search
                   <b>\^L</b>

           clear-and-redraw-all
               Clear the terminal screen and reprint the prompt and the current line. If any argument is passed,
               the screen is not cleared.

       <b>Motion</b> <b>commands</b>

           <u>Motion</u> <u>commands</u> move the cursor on the line. Most motion commands accept an argument. When passed an
           argument, they repeat the cursor motion as many times as specified by the argument. Passing “4” as an
           argument to the forward-char command, for example, advances the cursor by four characters.

           The shell has several definitions of words as units of distance: A <u>bigword</u> is one or more adjacent
           non-whitespace characters. A <u>semiword</u> is one or more adjacent characters that contain no whitespaces
           or punctuations. An <u>emacsword</u> is one or more adjacent alphanumeric characters. A <u>viword</u> is either:

           •   one or more adjacent alphanumeric characters and/or underscores (<b>_</b>), or

           •   one or more adjacent characters that contain none of alphanumeric characters, underscores, and
               whitespaces.

           forward-char
               Move the cursor to the next character.

               vi-insert
                   <b>\R</b>

               vi-command
                   <b>l</b>, (space), <b>\R</b>

               emacs
                   <b>\R</b>, <b>\^F</b>

           backward-char
               Move the cursor to the previous character.

               vi-insert
                   <b>\L</b>

               vi-command
                   <b>h</b>, <b>\B</b>, <b>\L</b>, <b>\?</b>, <b>\^H</b>

               emacs
                   <b>\L</b>, <b>\^B</b>

           forward-bigword
               Move the cursor to the next bigword.

               vi-command
                   <b>W</b>

           end-of-bigword
               Move the cursor to the next end of a bigword.

               vi-command
                   <b>E</b>

           backward-bigword
               Move the cursor to the previous bigword.

               vi-command
                   <b>B</b>

           forward-semiword
               Move the cursor to the next semiword.

           end-of-semiword
               Move the cursor to the next end of a semiword.

           backward-semiword
               Move the cursor to the previous semiword.

           forward-viword
               Move the cursor to the next viword.

               vi-command
                   <b>w</b>

           end-of-viword
               Move the cursor to the next end of a viword.

               vi-command
                   <b>e</b>

           backward-viword
               Move the cursor to the previous viword.

               vi-command
                   <b>b</b>

           forward-emacsword
               Move the cursor to the next emacsword.

               emacs
                   <b>\^[f</b>, <b>\^[F</b>

           backward-emacsword
               Move the cursor to the previous emacsword.

               emacs
                   <b>\^[b</b>, <b>\^[B</b>

           beginning-of-line
               Move the cursor to the beginning of the line.

               vi-insert, vi-command
                   <b>\H</b>

               emacs
                   <b>\H</b>, <b>\^A</b>

           end-of-line
               Move the cursor to the end of the line.

               vi-insert
                   <b>\E</b>

               vi-command
                   <b>$</b>, <b>\E</b>

               emacs
                   <b>\E</b>, <b>\^E</b>

           go-to-column
               Move the cursor to the <u>n</u>th character on the line, where <u>n</u> is the argument. Assume <u>n</u> = 1 when no
               argument.

               vi-command
                   <b>|</b>

           first-nonblank
               Move the cursor to the first non-blank character on the line.

               vi-command
                   <b>^</b>

           find-char
               Move the cursor to the first position where a character that is entered just after this command
               appears after the current cursor position.

               vi-command
                   <b>f</b>

               emacs
                   <b>\^]</b>

           find-char-rev
               Move the cursor to the last position where a character that is entered just after this command
               appears before the current cursor position.

               vi-command
                   <b>F</b>

               emacs
                   <b>\^[\^]</b>

           till-char
               Move the cursor to the first position just before a character that is entered just after this
               command appears after the current cursor position.

               vi-command
                   <b>t</b>

           till-char-rev
               Move the cursor to the last position just after a character that is entered just after this
               command appears before the current cursor position.

               vi-command
                   <b>T</b>

           refind-char
               Redo the last find-char, find-char-rev, till-char, till-char-rev command.

               vi-command
                   <b>;</b>

           refind-char-rev
               Redo the last find-char, find-char-rev, till-char, till-char-rev command in the reverse
               direction.

               vi-command
                   <b>,</b>

       <b>Editing</b> <b>commands</b>

           Editing commands modify contents of the buffer. Most editing commands accept an argument. When passed
           an argument, they repeat the modification as many times as specified by the argument.

           Texts deleted by commands whose name starts with “kill” are saved in <u>kill</u> <u>ring</u>, from which deleted
           contents can be restored to the buffer. The most recent 32 texts are kept in the kill ring.

           delete-char
               Delete a character at the current cursor position if no argument is passed; like the kill-char
               command otherwise.

               vi-insert, emacs
                   <b>\X</b>

           delete-bigword
               Delete a bigword at the current cursor position if no argument is passed; like the kill-bigword
               command otherwise.

           delete-semiword
               Delete a semiword at the current cursor position if no argument is passed; like the kill-semiword
               command otherwise.

           delete-viword
               Delete a viword at the current cursor position if no argument is passed; like the kill-viword
               command otherwise.

           delete-emacsword
               Delete a emacsword at the current cursor position if no argument is passed; like the
               kill-emacsword command otherwise.

           backward-delete-char
               Delete a character just before the current cursor position if no argument is passed; like the
               backward-kill-char command otherwise.

               vi-insert, emacs
                   <b>\B</b>, <b>\?</b>, <b>\^H</b>

           backward-delete-bigword
               Delete a bigword just before the current cursor position if no argument is passed; like the
               backward-kill-bigword command otherwise.

           backward-delete-semiword
               Delete a semiword just before the current cursor position if no argument is passed; like the
               backward-kill-semiword command otherwise.

               vi-insert
                   <b>\^W</b>

           backward-delete-viword
               Delete a viword just before the current cursor position if no argument is passed; like the
               backward-kill-viword command otherwise.

           backward-delete-emacsword
               Delete a emacsword just before the current cursor position if no argument is passed; like the
               backward-kill-emacsword command otherwise.

           delete-line
               Delete the whole buffer contents.

           forward-delete-line
               Delete all characters from the current cursor position to the end of the buffer.

           backward-delete-line
               Delete all characters before the current cursor position.

               vi-insert
                   <b>\$</b>, <b>\^U</b>

           kill-char
               Delete a character at the current cursor position and add it to the kill ring.

               vi-command
                   <b>x</b>, <b>\X</b>

           kill-bigword
               Delete a bigword at the current cursor position and add it to the kill ring.

           kill-semiword
               Delete a semiword at the current cursor position and add it to the kill ring.

           kill-viword
               Delete a viword at the current cursor position and add it to the kill ring.

           kill-emacsword
               Delete a emacsword at the current cursor position and add it to the kill ring.

               emacs
                   <b>\^[d</b>, <b>\^[D</b>

           backward-kill-char
               Delete a character just before the current cursor position and add it to the kill ring.

               vi-command
                   <b>X</b>

           backward-kill-bigword
               Delete a bigword just before the current cursor position and add it to the kill ring.

               emacs
                   <b>\^W</b>

           backward-kill-semiword
               Delete a semiword just before the current cursor position and add it to the kill ring.

           backward-kill-viword
               Delete a viword just before the current cursor position and add it to the kill ring.

           backward-kill-emacsword
               Delete a emacsword just before the current cursor position and add it to the kill ring.

               emacs
                   <b>\^[\B</b>, <b>\^[\?</b>, <b>\^[\^H</b>

           kill-line
               Delete the whole buffer contents and add it to the kill ring.

           forward-kill-line
               Delete all characters from the current cursor position to the end of the buffer and add it to the
               kill ring.

               emacs
                   <b>\^K</b>

           backward-kill-line
               Delete all characters before the current cursor position and add it to the kill ring.

               emacs
                   <b>\$</b>, <b>\^U</b>, <b>\^X\B</b>, <b>\^X\?</b>

           put-before
               Insert the last-killed text before the current cursor position and move the cursor to the last
               character that was inserted.

               vi-command
                   <b>P</b>

           put
               Insert the last-killed text after the current cursor position and move the cursor to the last
               character that was inserted.

               vi-command
                   <b>p</b>

           put-left
               Insert the last-killed text before the current cursor position and move the cursor to the last
               character that was inserted.

               emacs
                   <b>\^Y</b>

           put-pop
               Replace the just put text with the next older killed text.

               This command can be used only just after the put-before, put, put-left, or put-pop command.

               emacs
                   <b>\^[y</b>, <b>\^[Y</b>

           undo
               Cancel modification by the last editing command.

               vi
                   <b>u</b>

               emacs
                   <b>\^_</b>, <b>\^X\$</b>, <b>\^X\^U</b>

           undo-all
               Cancel all modification in the current buffer, restoring the initial contents.

               vi
                   <b>U</b>

               emacs
                   <b>\^[\^R</b>, <b>\^[r</b>, <b>\^[R</b>

           cancel-undo
               Cancel cancellation by the last undo or undo-all command.

               vi
                   <b>\^R</b>

           cancel-undo-all
               Cancel all cancellation by all most recent undo and undo-all commands.

           redo
               Repeat modification by the last editing command.

               vi-command
                   <b>.</b>

       <b>Completion</b> <b>commands</b>

           complete
               Complete a word just before the cursor position and, if there is more than one candidate, show a
               list of the candidates.

           complete-next-candidate
               Like the complete command when candidates are not being listed; otherwise, select the next
               candidate in the list.

               vi-insert, emacs
                   <b>\^I</b>

           complete-prev-candidate
               Like the complete command when candidates are not being listed; otherwise, select the previous
               candidate in the list.

               vi-insert, emacs
                   <b>\bt</b>

           complete-next-column
               Like the complete command when candidates are not being listed; otherwise, select the first
               candidate in the next column in the list.

           complete-prev-column
               Like the complete command when candidates are not being listed; otherwise, select the first
               candidate in the previous column in the list.

           complete-next-page
               Like the complete command when candidates are not being listed; otherwise, select the first
               candidate in the next page in the list.

           complete-prev-page
               Like the complete command when candidates are not being listed; otherwise, select the first
               candidate in the previous page in the list.

           complete-list
               Complete a word just before the cursor position.

               If you pass no argument, a list of completion candidates is shown. Otherwise, the word is
               completed with the <u>n</u>th candidate where <u>n</u> is the argument.

               emacs
                   <b>\^[?</b>, <b>\^[=</b>

           complete-all
               Replace a word just before the cursor position with all possible completion candidates, each
               separated by a space.

               emacs
                   <b>\^[*</b>

           complete-max
               Complete a word just before the cursor position with the longest prefix of all possible
               completion candidates.

           complete-max-then-list
               Works like the complete-max command for the first use, then like the complete command when used
               successively.

           complete-max-then-next-candidate
               Works like the complete-max command for the first use, then like the complete-next-candidate
               command when used successively.

           complete-max-then-prev-candidate
               Works like the complete-max command for the first use, then like the complete-prev-candidate
               command when used successively.

           clear-candidates
               Clear the list of completion candidates.

       <b>Vi-specific</b> <b>commands</b>

           vi-replace-char
               Replace the character at the cursor position with a character that is entered just after this
               command.

               vi-command
                   <b>r</b>

           vi-insert-beginning
               Move the cursor to the beginning of the line and switch to the vi insert mode.

               vi-command
                   <b>I</b>

           vi-append
               Move the cursor to the next character and switch to the vi insert mode.

               vi-command
                   <b>I</b>

           vi-append-to-eol
               Move the cursor to the end of the line and switch to the vi insert mode.

               vi-command
                   <b>A</b>

           vi-replace
               Switch to the vi insert mode and start overwriting. While overwriting, the self-insert command
               replaces the character at cursor position rather than inserting a character. Overwriting ends
               when the editing mode is changed.

               vi-command
                   <b>R</b>

           vi-switch-case
               Switch case of characters between the current and next cursor positions. This command must be
               followed by a motion command, which determines the next cursor position.

           vi-switch-case-char
               Switch case of the character at the current cursor position and move the cursor to the next
               character.

               vi-command
                   <b>~</b>

           vi-yank
               Add to the kill ring the characters between the current and next cursor positions. This command
               must be followed by a motion command, which determines the next cursor position.

               vi-command
                   <b>y</b>

           vi-yank-to-eol
               Add to the kill ring the characters from the current cursor position to the end of the line.

               vi-command
                   <b>Y</b>

           vi-delete
               Delete characters between the current and next cursor positions and add it to the kill ring. This
               command must be followed by a motion command, which determines the next cursor position.

               vi-command
                   <b>d</b>

           vi-delete-to-eol
               Delete the characters from the current cursor position to the end of the line and add it to the
               kill ring.

               vi-command
                   <b>D</b>

           vi-change
               Delete characters between the current and next cursor positions and switch to the vi insert mode.
               This command must be followed by a motion command, which determines the next cursor position.

               vi-command
                   <b>c</b>

           vi-change-to-eol
               Delete the characters from the current cursor position to the end of the line and switch to the
               vi insert mode.

               vi-command
                   <b>C</b>

           vi-change-line
               Delete the whole buffer contents and switch to the vi insert mode.

               vi-command
                   <b>S</b>

           vi-yank-and-change
               Like the vi-change command, but the deleted text is added to the kill ring.

           vi-yank-and-change-to-eol
               Like the vi-change-to-eol command, but the deleted text is added to the kill ring.

           vi-yank-and-change-line
               Like the vi-change-line command, but the deleted text is added to the kill ring.

           vi-substitute
               Delete a character at the current cursor position, add it to the kill ring, and switch to the vi
               insert mode.

               vi-command
                   <b>s</b>

           vi-append-last-bigword
               Insert a space and the last bigword in the most recent command history entry just after the
               current cursor position and switch to the vi insert mode. If argument <u>n</u> is passed, the <u>n</u>th
               bigword in the entry is inserted instead of the last.

               vi-command
                   <b>_</b>

           vi-exec-alias
               Execute the value of an alias named <b>_</b><u>c</u> as editing commands where <u>c</u> is a character input just
               after this command.

               vi-command
                   <b>@</b>

           vi-edit-and-accept
               Start the vi editor to edit the current buffer contents. When the editor finished, the edited
               buffer contents is accepted like the accept-line command unless the exit status of the editor is
               non-zero.

               vi-command
                   <b>v</b>

           vi-complete-list
               Like the complete-list command, but also switch to the vi insert mode.

               vi-command
                   <b>=</b>

           vi-complete-all
               Like the complete-all command, but also switch to the vi insert mode.

               vi-command
                   <b>*</b>

           vi-complete-max
               Like the complete-max command, but also switch to the vi insert mode.

               vi-command
                   <b>\\</b>

           vi-search-forward
               Switch to the vi search mode and start forward history search.

               vi-command
                   <b>?</b>

           vi-search-backward
               Switch to the vi search mode and start backward history search.

               vi-command
                   <b>/</b>

       <b>Emacs-specific</b> <b>commands</b>

           emacs-transpose-chars
               Move a character just before the cursor to the right.

               emacs
                   <b>\^T</b>

           emacs-transpose-words
               Move an emacsword just before the cursor to the right.

               emacs
                   <b>\^[t</b>, <b>\^[T</b>

           emacs-downcase-word
               Make an emacsword just after the cursor lowercase.

               emacs
                   <b>\^[l</b>, <b>\^[L</b>

           emacs-upcase-word
               Make an emacsword just after the cursor uppercase.

               emacs
                   <b>\^[u</b>, <b>\^[U</b>

           emacs-capitalize-word
               Capitalize the first letter of an emacsword just after the cursor.

               emacs
                   <b>\^[c</b>, <b>\^[u</b>

           emacs-delete-horizontal-space
               Delete spaces around the cursor. If any argument was passed, delete spaces just before the cursor
               only.

               emacs
                   <b>\^[\\</b>

           emacs-just-one-space
               Delete spaces around the cursor and leave one space. If an argument is specified, leave as many
               spaces as the argument.

               emacs
                   <b>\^[</b> (Escape followed by a space)

           emacs-search-forward
               Switch to the emacs search mode and start forward history search.

               emacs
                   <b>\^S</b>

           emacs-search-backward
               Switch to the emacs search mode and start backward history search.

               emacs
                   <b>\^R</b>

       <b>History-related</b> <b>commands</b>

           oldest-history
               Recall the oldest entry in the history. If argument <u>n</u> is passed, the entry whose number is <u>n</u> is
               recalled instead. The cursor position remains unchanged.

           newest-history
               Recall the newest entry in the history. If argument <u>n</u> is passed, the entry whose number is <u>n</u> is
               recalled instead. The cursor position remains unchanged.

           return-history
               Return to the initial buffer corresponding to none of existing history entries. If argument <u>n</u> is
               passed, the entry whose number is <u>n</u> is recalled instead. The cursor position remains unchanged.

           oldest-history-bol
               Recall the oldest entry in the history and move the cursor to the beginning of the line. If
               argument <u>n</u> is passed, the entry whose number is <u>n</u> is recalled instead.

               vi-command
                   <b>G</b>

           newest-history-bol
               Recall the newest entry in the history and move the cursor to the beginning of the line. If
               argument <u>n</u> is passed, the entry whose number is <u>n</u> is recalled instead.

           return-history-bol
               Return to the initial buffer corresponding to none of existing history entries and move the
               cursor to the beginning of the line. If argument <u>n</u> is passed, the entry whose number is <u>n</u> is
               recalled instead.

               vi-command
                   <b>g</b>

           oldest-history-eol
               Recall the oldest entry in the history and move the cursor to the end of the line. If argument <u>n</u>
               is passed, the entry whose number is <u>n</u> is recalled instead.

               emacs
                   <b>\^[&lt;</b>

           newest-history-eol
               Recall the newest entry in the history and move the cursor to the end of the line. If argument <u>n</u>
               is passed, the entry whose number is <u>n</u> is recalled instead.

           return-history-eol
               Return to the initial buffer corresponding to none of existing history entries and move the
               cursor to the end of the line. If argument <u>n</u> is passed, the entry whose number is <u>n</u> is recalled
               instead.

               emacs
                   <b>\^[&gt;</b>

           next-history
               Recall the next history entry. The cursor position remains unchanged.

           prev-history
               Recall the previous history entry. The cursor position remains unchanged.

           next-history-bol
               Recall the next history entry and move the cursor to the beginning of the line.

               vi-command
                   <b>j</b>, <b>+</b>, <b>\D</b>, <b>\^N</b>

           prev-history-bol
               Recall the previous history entry and move the cursor to the beginning of the line.

               vi-command
                   <b>k</b>, <b>-</b>, <b>\U</b>, <b>\^P</b>

           next-history-eol
               Recall the next history entry and move the cursor to the end of the line.

               vi-insert, emacs
                   <b>\D</b>, <b>\^N</b>

           prev-history-eol
               Recall the previous history entry and move the cursor to the end of the line.

               vi-insert, emacs
                   <b>\U</b>, <b>\^P</b>

           search-again
               Repeat the last command history search.

               vi-command
                   <b>n</b>

           search-again-rev
               Repeat the last command history search in the reverse direction.

               vi-command
                   <b>N</b>

           search-again-forward
               Repeat the last command history search in the forward direction.

           search-again-backward
               Repeat the last command history search in the backward direction.

           beginning-search-forward
               Recall the next history entry that starts with the same text as the text from the beginning of
               the line up to the current cursor position. The cursor position remains unchanged.

           beginning-search-backward
               Recall the previous history entry that starts with the same text as the text from the beginning
               of the line up to the current cursor position. The cursor position remains unchanged.

       <b>Search</b> <b>mode</b> <b>commands</b>

           srch-self-insert
               Insert the input character at the current cursor position. Characters escaped by escape sequences
               cannot be inserted.

               vi-search, emacs-search
                   <b>\\</b>

           srch-backward-delete-char
               Delete the last character in the search text. If the text is empty:

               •   like the srch-abort-search command when in the vi search mode, or

               •   like the alert command when in the emacs search mode.

               vi-search, emacs-search
                   <b>\B</b>, <b>\?</b>, <b>\^H</b>

           srch-backward-delete-line
               Delete the whole search text.

               vi-search, emacs-search
                   <b>\$</b>, <b>\^U</b>

           srch-continue-forward
               Find the next matching history entry.

               emacs-search
                   <b>\^S</b>

           srch-continue-backward
               Find the previous matching history entry.

               emacs-search
                   <b>\^R</b>

           srch-accept-search
               Finish the search mode, accepting the result being shown.

               vi-search
                   <b>\^J</b>, <b>\^M</b>, <b>\et</b>

               emacs-search
                   <b>\^J</b>, <b>\^[</b>

           srch-abort-search
               Abort search and restore the previous buffer contents.

               vi-search
                   <b>\^[</b>

               emacs-search
                   <b>\^G</b>

   <b>Escape</b> <b>sequences</b>
       In the bindkey built-in, escape sequences are used to represent special keys such as function keys and
       arrow keys. Every escape sequence starts with a backslash (<b>\</b>) and thus there is also an escape sequence
       for a backslash itself.

       Below are available escape sequences:

       <b>\\</b>
           Backslash (<b>\</b>)

       <b>\B</b>
           Backspace

       <b>\D</b>
           Down arrow

       <b>\E</b>
           End

       <b>\H</b>
           Home

       <b>\I</b>
           Insert (Insert-char, Enter-insert-mode)

       <b>\L</b>
           Left arrow

       <b>\N</b>
           Page-down (Next-page)

       <b>\P</b>
           Page-up (Previous-page)

       <b>\R</b>
           Right arrow

       <b>\U</b>
           Up arrow

       <b>\X</b>
           Delete

       <b>\!</b>
           INTR

       <b>\#</b>
           EOF

       <b>\$</b>
           KILL

       <b>\?</b>
           ERASE

       <b>\^@</b>
           Ctrl + @

       <b>\^A</b>, <b>\^B</b>, ..., <b>\^Z</b>
           Ctrl + A, Ctrl + B, ..., Ctrl + Z

           Note that Ctrl + I, Ctrl + J, and Ctrl + M are tab, newline, and carriage return, respectively.

       <b>\^[</b>
           Ctrl + [ (Escape)

       <b>\^\</b>
           Ctrl + \

       <b>\^]</b>
           Ctrl + ]

       <b>\^^</b>
           Ctrl + ^

       <b>\^_</b>
           Ctrl + _

       <b>\^?</b>
           Ctrl + ? (Delete)

       <b>\F00</b>, <b>\F01</b>, ..., <b>\F63</b>
           F0, F1, ..., F63

       <b>\a1</b>
           Top-left on keypad

       <b>\a3</b>
           Top-right on keypad

       <b>\b2</b>
           Center on keypad

       <b>\bg</b>
           Beginning

       <b>\bt</b>
           Back-tab

       <b>\c1</b>
           Bottom-left on keypad

       <b>\c3</b>
           Bottom-right on keypad

       <b>\ca</b>
           Clear-all-tabs

       <b>\cl</b>
           Close

       <b>\cn</b>
           Cancel

       <b>\co</b>
           Command

       <b>\cp</b>
           Copy

       <b>\cr</b>
           Create

       <b>\cs</b>
           Clear-screen or erase

       <b>\ct</b>
           Clear-tab

       <b>\dl</b>
           Delete-line

       <b>\ei</b>
           Exit-insert-mode

       <b>\el</b>
           Clear-to-end-of-line

       <b>\es</b>
           Clear-to-end-of-screen

       <b>\et</b>
           Enter (Send)

       <b>\ex</b>
           Exit

       <b>\fd</b>
           Find

       <b>\hp</b>
           Help

       <b>\il</b>
           Insert-line

       <b>\ll</b>
           Home-down

       <b>\me</b>
           Message

       <b>\mk</b>
           Mark

       <b>\ms</b>
           Mouse event

       <b>\mv</b>
           Move

       <b>\nx</b>
           Next-object

       <b>\on</b>
           Open

       <b>\op</b>
           Options

       <b>\pr</b>
           Print (Copy)

       <b>\pv</b>
           Previous-object

       <b>\rd</b>
           Redo

       <b>\re</b>
           Resume

       <b>\rf</b>
           Ref (Reference)

       <b>\rh</b>
           Refresh

       <b>\rp</b>
           Replace

       <b>\rs</b>
           Restart

       <b>\sf</b>
           Scroll-forward (Scroll-down)

       <b>\sl</b>
           Select

       <b>\sr</b>
           Scroll-backward (Scroll-up)

       <b>\st</b>
           Set-tab

       <b>\su</b>
           Suspend

       <b>\sv</b>
           Save

       <b>\ud</b>
           Undo

       <b>\SE</b>
           Shift + End

       <b>\SH</b>
           Shift + Home

       <b>\SI</b>
           Shift + Insert

       <b>\SL</b>
           Shift + Left arrow

       <b>\SR</b>
           Shift + Right arrow

       <b>\SX</b>
           Shift + Delete

       <b>\Sbg</b>
           Shift + Beginning

       <b>\Scn</b>
           Shift + Cancel

       <b>\Sco</b>
           Shift + Command

       <b>\Scp</b>
           Shift + Copy

       <b>\Scr</b>
           Shift + Create

       <b>\Sdl</b>
           Shift + Delete-line

       <b>\Sel</b>
           Shift + End-of-line

       <b>\Sex</b>
           Shift + Exit

       <b>\Sfd</b>
           Shift + Find

       <b>\Shp</b>
           Shift + Help

       <b>\Smg</b>
           Shift + Message

       <b>\Smv</b>
           Shift + Move

       <b>\Snx</b>
           Shift + Next

       <b>\Sop</b>
           Shift + Options

       <b>\Spr</b>
           Shift + Print

       <b>\Spv</b>
           Shift + Previous

       <b>\Srd</b>
           Shift + Redo

       <b>\Sre</b>
           Shift + Resume

       <b>\Srp</b>
           Shift + Replace

       <b>\Ssu</b>
           Shift + Suspend

       <b>\Ssv</b>
           Shift + Save

       <b>\Sud</b>
           Shift + Undo

       INTR, EOF, KILL, and ERASE are special characters configured by the stty command. In a typical
       configuration, they are sent by typing Ctrl+C, Ctrl+D, Ctrl+U, and Ctrl+H, respectively, but some
       configuration uses Ctrl+? instead of Ctrl+H for ERASE.

   <b>Command</b> <b>line</b> <b>completion</b>
       By using the complete and complete-next-candidate commands, etc., you can complete command names,
       options, and operands. By default, the complete-next-candidate command is bound with the Tab key in the
       vi insert and emacs modes.

       Type a few first letters of a command name or pathname and hit the Tab key, and a list of matching names
       will be shown. You can choose a candidate from the list to complete the name by hitting the Tab key
       again. If there is only one matching name, no list will be shown and the name will directly be completed.

       If the name to be completed contains characters like <b>*</b> and <b>?</b>, it is treated as a pattern. The name on the
       command line will be directly substituted with all possible names matching the pattern (you cannot choose
       from a list).

       Normally, command names are completed with command names and command arguments with pathnames. However,
       <u>completion</u> <u>functions</u> can be defined to refine completion results.

       <b>Completion</b> <b>details</b>

           When doing completion for the first time after the shell has been started, the INIT file is loaded as
           if the command string <b>.</b> <b>-AL</b> <b>completion/INIT</b> is executed. If the file is not found, it is silently
           ignored. This automatic loading is mainly intended for loading completion functions bundled with the
           shell, but you can let the shell load your own functions by putting a file in the load path.

           When completing a command name, the shell executes the <b>completion//command</b> function and when
           completing a command argument, the <b>completion//argument</b> function. If those completion functions are
           not defined, the shell just completes with command names or pathnames. When completing other names,
           such as the user name in tilde expansion and the parameter name in parameter expansion, completion
           functions are never used: the shell just completes with user names, parameter names, or whatever
           applicable.

           Completion functions are executed without any arguments. The following local variables are
           automatically defined while executing completion functions:

           <b>IFS</b>
               The value is the three characters of a space, a tab, and a newline, which are the default value
               of the variable.

           <b>WORDS</b>
               This variable is an array whose elements are a command name and arguments that have already been
               entered before the argument being completed. When completing a command name, the array has no
               elements.

           <b>TARGETWORD</b>
               The value is the partially entered command name or argument that is being completed.

           Completion candidates are generated by executing the complete built-in during a completion function.

           Completion functions must not perform I/O to the terminal, or displayed text will be corrupted.
           Completion functions should run as quickly as possible for better user experience.

           While a completion function is being executed:

           •   the POSIXly-correct mode and the err-return option are temporarily disabled,

           •   the err-exit option is temporarily ignored, and

           •   traps are not executed.

   <b>Command</b> <b>line</b> <b>prediction</b>
       This is an experimental feature. When the le-predict option is enabled, the shell automatically tries to
       predict a command string fragment that follows the part of the command you have already typed in
       line-editing.

       For example, assume you have once typed the command <b>ls</b> <b>Documents</b>. Next time you start typing <b>ls</b> <b>Doc</b>, the
       shell will show <b>uments</b> just after the cursor. If you are satisfied with this suggestion, you can move the
       cursor to the right by the forward-char or any other motion commands instead of typing the rest of the
       command. After moving the cursor after the last <b>s</b>, you can use the accept-line command to execute the
       command. You can also use the accept-prediction command to immediately execute the suggested command
       without moving the cursor.

       To distinguish the typed and predicted parts of a command string, you can change the font style of those
       parts by setting the <b>PS1S</b> and <b>PS1P</b> variables.

       When you move the cursor to the right, the predicted part up to the cursor becomes the typed part as if
       you actually typed it. Moving the cursor to the left does <u>not</u> turn the typed part back to the prediction.
       Use deletion commands such as backward-delete-char to delete typed command fragment.

       The predicted part of the command is shown only when the cursor is at the end of the typed part.

       By default, the predicted part is shown after you start typing a command string. By enabling the
       le-predict-empty option, the predicted part is also shown before you type the first character of the
       command string.

       The prediction algorithm suggests command fragments on the basis of the command history. The algorithm
       considers recent history entries more probable. It also takes command succession patterns into account. A
       predicted command fragment is not always a complete valid command because less probable part of the
       fragment is excluded from prediction.

</pre><h4><b>POSIXLY-CORRECT</b> <b>MODE</b></h4><pre>
       Yash behaves as defined in POSIX.1-2008, Shell &amp; Utilities for the most part, but some functionalities
       disobey POSIX for usability. When full POSIX-conformance is needed, you can enable the <u>POSIXly-correct</u>
       <u>mode</u> to make yash obey POSIX as much as possible.

       If yash is started with the name “sh”, the POSIXly-correct mode is automatically enabled. The <b>-o</b>
       <b>posixly-correct</b> command-line option also enables the POSIXly-correct mode. After yash has been started,
       the POSIXly-correct mode can be enabled by executing the command string <b>set</b> <b>-o</b> <b>posixly-correct</b>.

       When the POSIXly-correct mode is on, yash not only tries to obey the requirements by POSIX, but also
       treats as errors most conditions where the behavior is <u>undefined</u> or <u>unspecified</u> by POSIX. As a result,
       most yash-specific functionalities are disabled in the POSIXly-correct mode.

       Below is the complete list of the behavioral differences between when yash is in the POSIXly-correct mode
       and when not. When the POSIXly-correct mode is enabled:

       •   Different initialization scripts are used.

       •   If the shell was started with the <b>-c</b> option, <b>sh</b> <b>-c</b> (instead of <b>yash</b> <b>-c</b>) is printed as the script
           pathname on a syntax error.

       •   Global aliases are not substituted.

       •   Nested commands in a compound command must not be empty.

       •   The for loop iteration variable is created as global, regardless of the for-local shell option. The
           variable must have a portable (ASCII-only) name.

       •   The first pattern in a case command cannot be <b>esac</b>.

       •   The <b>!</b>  keyword cannot be followed by <b>(</b> without any whitespaces in-between.

       •   The double-bracket command cannot be used.

       •   The <b>function</b> keyword cannot be used for function definition. The function must have a portable
           (ASCII-only) name.

       •   Simple commands cannot assign to arrays.

       •   Changing the value of the <b>LC_CTYPE</b> variable after the shell has been initialized does not affect the
           shell’s locale.

       •   The <b>RANDOM</b> variable cannot be used to generate random numbers.

       •   Tilde expansion only expands <b>~</b> and <b>~</b><u>username</u>.

       •   Parameter expansion cannot be nested. No indexes or modifiers with <u>word2</u> are allowed.

       •   The commands in a command substitution of the form <b>$(</b><u>commands</u><b>)</b> are parsed every time the substitution
           is executed.

       •   In arithmetic expansion, fractional numbers and the <b>++</b> and <b>--</b> operators cannot be used. All variables
           must be numeric.

       •   The operand of a redirection cannot be the integer prefix to a next redirection operator.

       •   A compound command with a redirection cannot be immediately followed by a keyword like <b>}</b> and <b>fi</b>.

       •   In a redirection to a file, if the pathname expansion yielded more than one or no pathname, it is not
           immediately treated as an error. Instead, the shell tries to treat the word before the expansion as a
           pathname.

       •   A file descriptor must be readable and writable when duplicated by the <b>&lt;&amp;</b> and <b>&gt;&amp;</b> redirection
           operator, respectively.

       •   Socket redirection, here strings, pipe redirection, and process redirection cannot be used.

       •   When executing a simple command, failure in command search does not trigger execution of the
           <b>COMMAND_NOT_FOUND_HANDLER</b> variable.

       •   Elective and extension built-ins cannot be executed.

       •   Some built-ins behave differently. Especially, long command-line options (as well as some others)
           cannot be used.

       •   A non-interactive shell exits when a special built-in is given a syntactically wrong arguments or
           when an error occurs in assignment or redirection with a special built-in.

       •   An interactive shell does not execute the <b>PROMPT_COMMAND</b> variable before printing a prompt. The
           values of the <b>PS1</b>, <b>PS2</b>, and <b>PS4</b> variables are parsed differently. Prompt variables with a <b>YASH_</b>
           prefix (e.g.  <b>YASH_PS1</b>) are not used.

       •   In mail checking, a notification message is printed if the file has been modified, regardless of
           whether the file is empty.

</pre><h4><b>FREQUENTLY</b> <b>ASKED</b> <b>QUESTIONS</b> <b>AND</b> <b>TROUBLESHOOTING</b></h4><pre>
   <b>How</b> <b>can</b> <b>I</b> <b>use</b> <b>Unicode</b> <b>(non-ASCII)</b> <b>characters?</b>
       You need to set locale environment variables to enable Unicode character support.

       If the variables have already been configured for your preference, you probably don’t have to do
       anything. To check the current locale configurations, you can use the <b>locale</b> command:

           $ locale
           LANG=
           LC_CTYPE="en_US.utf8"
           LC_NUMERIC="en_US.utf8"
           LC_TIME="en_US.utf8"
           LC_COLLATE="en_US.utf8"
           LC_MONETARY="en_US.utf8"
           LC_MESSAGES="en_US.utf8"
           LC_PAPER="en_US.utf8"
           LC_NAME="en_US.utf8"
           LC_ADDRESS="en_US.utf8"
           LC_TELEPHONE="en_US.utf8"
           LC_MEASUREMENT="en_US.utf8"
           LC_IDENTIFICATION="en_US.utf8"
           LC_ALL=en_US.utf8

       In this example, the <b>locale</b> command shows that all the locale setting categories are configured for the
       English language, the United States region, and the UTF-8 encoding.

       If the current configuration does not seem to match your preference, set the <b>LC_ALL</b> variable like this:

           export LC_ALL=en_US.utf8

       If you want to use other languages, regions, or encodings, you have to set the variable to a different
       value. Please consult your OS’s documentation to learn how to configure these variables in detail.

       If you want to apply the same configuration every time you start yash, write the command in <a href="file:~/.yashrc">~/.yashrc</a> or
       <a href="file:~/.yash_profile.">~/.yash_profile.</a>

       If yash still rejects Unicode characters being entered, see the section below regarding line-editing.

   <b>Line-editing</b> <b>does</b> <b>not</b> <b>work</b>
       First, type <b>echo</b> <b>$TERM</b> and see if it prints a <u>sane</u> value. <b>xterm</b> is the safest value that should work on
       any existing environment. Colored versions like <b>xterm-16color</b> and other terminal types like <b>rxvt</b> and
       <b>vt100</b> may also work. All possible values can be listed by the <b>toe</b> command. It’s most desirable to choose
       a value that matches the actual terminal type you are using, but it might not work if the terminal type
       you chose is not supported on the system on which yash is running. If so, try changing the <b>TERM</b> value by
       <b>export</b> <b>TERM=xterm</b>, for example, to find a value that works.

       If line-editing works but you have trouble entering Unicode (non-ASCII) characters, try enabling the
       le-no-conv-meta option by <b>set</b> <b>-o</b> <b>le-no-conv-meta</b>.

</pre><h4><b>FORMAL</b> <b>DEFINITION</b> <b>OF</b> <b>COMMAND</b> <b>SYNTAX</b></h4><pre>
       This chapter defines the syntax of the shell command language.

           <b>Note</b>

           Some of the syntactic features described below are not supported in the POSIXly-correct mode.

   <b>Tokenization</b>
       The characters of the input source code are first delimited into tokens. Tokens are delimited so that the
       earlier token spans as long as possible. A sequence of one or more unquoted blank characters delimits a
       token.

       The following tokens are the operator tokens:

       <b>&amp;</b> <b>&amp;&amp;</b> <b>(</b> <b>)</b> <b>;</b> <b>;;</b> <b>|</b> <b>||</b> <b>&lt;</b> <b>&lt;&lt;</b> <b>&lt;&amp;</b> <b>&lt;(</b> <b>&lt;&lt;-</b> <b>&lt;&lt;&lt;</b> <b>&lt;&gt;</b> <b>&gt;</b> <b>&gt;&gt;</b> <b>&gt;&amp;</b> <b>&gt;(</b> <b>&gt;&gt;|</b> <b>&gt;|</b> (newline)

           <b>Note</b>

           Unlike other programming languages, the newline operator is a token rather than a white space.

       Characters that are not blank nor part of an operator compose a word token. Words are parsed by the
       following parsing expression grammar:

       Word
           (WordElement / !SpecialChar .)+

       WordElement
           <b>\</b> . /

           <b>'</b> (!<b>'</b> .)*  <b>'</b> /

           <b>"</b> QuoteElement* <b>"</b> /

           Parameter /

           Arithmetic /

           CommandSubstitution

       QuoteElement
           <b>\</b> ([<b>$`"\</b>] / &lt;newline&gt;) /

           Parameter /

           Arithmetic /

           CommandSubstitutionQuoted /

           ![<b>`"\</b>] .

       Parameter
           <b>$</b> [<b>@*#?-$!</b>  [:digit:]] /

           <b>$</b> PortableName /

           <b>$</b> ParameterBody

       PortableName
           ![<b>0</b>-<b>9</b>] [<b>0</b>-<b>9</b> <b>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_</b>]+

       ParameterBody
           <b>{</b> ParameterNumber? (ParameterName / ParameterBody / <b>$</b> ParameterBody / Arithmetic /
           CommandSubstitution) ParameterIndex?  ParameterMatch?  <b>}</b>

       ParameterNumber
           <b>#</b> ![<b>}+=:/%</b>] !([<b>-?#</b>] !<b>}</b>)

       ParameterName
           [<b>@*#?-$!</b>] /

           [[:alnum:] <b>_</b>]+

       ParameterIndex
           <b>[</b> ParameterIndexWord (<b>,</b> ParameterIndexWord)?  <b>]</b>

       ParameterIndexWord
           (WordElement / ![<b>"'],</b>] .)+

       ParameterMatch
           <b>:</b>? [<b>-+=?</b>]  ParameterMatchWord /

           (<b>#</b> / <b>##</b> / <b>%</b> / <b>%%</b>) ParameterMatchWord /

           (<b>:/</b> / <b>/</b> [<b>#%/</b>]?)  ParameterMatchWordNoSlash (<b>/</b> ParameterMatchWord)?

       ParameterMatchWord
           (WordElement / ![<b>"'}</b>] .)*

       ParameterMatchWordNoSlash
           (WordElement / ![<b>"'/}</b>] .)*

       Arithmetic
           <b>$((</b> ArithmeticBody* <b>))</b>

       ArithmeticBody
           <b>\</b> . /

           Parameter /

           Arithmetic /

           CommandSubstitution /

           <b>(</b> ArithmeticBody <b>)</b> /

           ![<b>`()</b>] .

       CommandSubstitution
           <b>$(</b> CompleteProgram <b>)</b> /

           <b>`</b> CommandSubstitutionBody* <b>`</b>

       CommandSubstitutionQuoted
           <b>$(</b> CompleteProgram <b>)</b> /

           <b>`</b> CommandSubstitutionBodyQuoted* <b>`</b>

       CommandSubstitutionBody
           <b>\</b> [<b>$`\</b>] /

           !<b>`</b> .

       CommandSubstitutionBodyQuoted
           <b>\</b> [<b>$`\`</b>] /

           !<b>`</b> .

       SpecialChar
           [<b>|&amp;;&lt;&gt;()`\"'</b> [:blank:]] / &lt;newline&gt;

       The set of terminals of the grammar is the set of characters that can be handled on the environment in
       which the shell is run (a.k.a. execution character set), with the exception that the set does not contain
       the null character (<b>'\0'</b>).

       Strictly speaking, the definition above is not a complete parsing expression grammar because the rule for
       CommandSubstitution (Quoted) depends on CompleteProgram which is a non-terminal of the syntax.

       <b>Token</b> <b>classification</b>

           After a word token is delimited, the token may be further classified as an IO_NUMBER token, reserved
           word, name word, assignment word, or just normal word. Classification other than the normal word is
           applied only when applicable in the context in which the word appears. See Tokens and keywords for
           the list of the reserved words (keywords) and the context in which a word may be recognized as a
           reserved word.

           A token is an IO_NUMBER token iff it is composed of digit characters only and immediately followed by
           <b>&lt;</b> or <b>&gt;</b>.

           An assignment token is a token that starts with a name followed by <b>=</b>:

           AssignmentWord
               AssignmentPrefix Word

           AssignmentPrefix
               Name <b>=</b>

           Name
               ![[:digit:]] \[[:alnum:] <b>_</b>]+

       <b>Comments</b>

           A comment begins with <b>#</b> and continues up to (but not including) the next newline character. Comments
           are treated like a blank character and do not become part of a token. The initial <b>#</b> of a comment must
           appear as if it would otherwise be the first character of a word token; Other <b>#</b>s are just treated as
           part of a word token.

           Comment
               <b>#</b> (!&lt;newline&gt; .)*

   <b>Syntax</b>
       After tokens have been delimited, the sequence of the tokens is parsed according to the context-free
       grammar defined below, where <b>*</b>, <b>+</b>, and <b>?</b> should be interpreted in the same manner as standard regular
       expression:

       CompleteProgram
           NL* | CompoundList

       CompoundList
           NL* AndOrList ((<b>;</b> | <b>&amp;</b> | NL) CompleteProgram)?

       AndOrList
           Pipeline ((<b>&amp;&amp;</b> | <b>||</b>) NL* Pipeline)*

       Pipeline
           <b>!</b>?  Command (<b>|</b> NL* Command)*

       Command
           CompoundCommand Redirection* |

           FunctionDefinition |

           SimpleCommand

       CompoundCommand
           Subshell |

           Grouping |

           IfCommand |

           ForCommand |

           WhileCommand |

           CaseCommand |

           DoubleBracketCommand |

           FunctionCommand

       Subshell
           <b>(</b> CompoundList <b>)</b>

       Grouping
           <b>{</b> CompoundList <b>}</b>

       IfCommand
           <b>if</b> CompoundList <b>then</b> CompoundList (<b>elif</b> CompoundList <b>then</b> CompoundList)* (<b>else</b> CompoundList)?  <b>fi</b>

       ForCommand
           <b>for</b> Name ((NL* <b>in</b> Word*)? (<b>;</b> | NL) NL*)?  <b>do</b> CompoundList <b>done</b>

       WhileCommand
           (<b>while</b> | <b>until</b>) CompoundList <b>do</b> CompoundList <b>done</b>

       CaseCommand
           <b>case</b> Word NL* <b>in</b> NL* CaseList?  <b>esac</b>

       CaseList
           CaseItem (<b>;;</b> NL* CaseList)?

       CaseItem
           <b>(</b>?  Word (<b>|</b> Word)* <b>)</b> CompleteProgram

       DoubleBracketCommand
           <b>[[</b> Ors <b>]]</b>

       Ors
           Ands (<b>||</b> Ands)*

       Ands
           Nots (<b>&amp;&amp;</b> Nots)*

       Nots
           <b>!</b>*  Primary

       Primary
           (<b>-b</b> | <b>-c</b> | <b>-d</b> | <b>-e</b> | <b>-f</b> | <b>-G</b> | <b>-g</b> | <b>-h</b> | <b>-k</b> | <b>-L</b> | <b>-N</b> | <b>-n</b> | <b>-O</b> | <b>-o</b> | <b>-p</b> | <b>-r</b> | <b>-S</b> | <b>-s</b> | <b>-t</b> | <b>-u</b> |
           <b>-w</b> | <b>-x</b> | <b>-z</b>) Word |

           Word (<b>-ef</b> | <b>-eq</b> | <b>-ge</b> | <b>-gt</b> | <b>-le</b> | <b>-lt</b> | <b>-ne</b> | <b>-nt</b> | <b>-ot</b> | <b>-veq</b> | <b>-vge</b> | <b>-vgt</b> | <b>-vle</b> | <b>-vlt</b> | <b>-vne</b> |
           <b>=</b> | <b>==</b> | <b>===</b> | <b>=~</b> | <b>!=</b> | <b>!==</b> | <b>&lt;</b> | <b>&gt;</b>) Word |

           <b>(</b> Ors <b>)</b> |

           Word

       FunctionCommand
           <b>function</b> Word (<b>(</b> <b>)</b>)?  NL* CompoundCommand Redirection*

       FunctionDefinition
           Name <b>(</b> <b>)</b> NL* CompoundCommand Redirection*

       SimpleCommand
           (Assignment | Redirection) SimpleCommand? |

           Word (Word | Redirection)*

       Assignment
           AssignmentWord |

           AssignmentPrefix<b>(</b> NL* (Word NL*)* <b>)</b>

       Redirection
           IO_NUMBER?  RedirectionOperator Word |

           IO_NUMBER?  <b>&lt;(</b> CompleteProgram <b>)</b> |

           IO_NUMBER?  <b>&gt;(</b> CompleteProgram <b>)</b>

       RedirectionOperator
           <b>&lt;</b> | <b>&lt;&gt;</b> | <b>&gt;</b> | <b>&gt;|</b> | <b>&gt;&gt;</b> | <b>&gt;&gt;|</b> | <b>&lt;&amp;</b> | <b>&gt;&amp;</b> | <b>&lt;&lt;</b> | <b>&lt;&lt;-</b> | <b>&lt;&lt;&lt;</b>

       NL
           &lt;newline&gt;

       In the rule for Primary, Word tokens must not be <b>]]</b>. Additionally, if a Primary starts with a Word, it
       must not be any of the possible unary operators allowed in the rule.

       In the rule for SimpleCommand, a Word token is accepted only when the token cannot be parsed as the first
       token of an Assignment.

       In the rule for Assignment, the <b>(</b> token must immediately follow the AssignmentPrefix token, without any
       blank characters in between.

       Here-document contents do not appear as part of the grammar above. They are parsed just after the newline
       (NL) token that follows the corresponding redirection operator.

       <b>Alias</b> <b>substitution</b>

           Word tokens are subject to alias substitution.

           •   If a word is going to be parsed as a Word of a SimpleCommand, the word is subjected to alias
               substitution of any kind (normal and global aliases).

           •   If a word is the next token after the result of an alias substitution and the substitution string
               ends with a blank character, then the word is also subjected to alias substitution of any kind.

           •   Other words are subjected to global alias substitution unless the shell is in the POSIXly-correct
               mode.

           Tokens that are classified as reserved words are not subject to alias substitution.

</pre><h4><b>ALIAS</b> <b>BUILT-IN</b></h4><pre>
       The <u>alias</u> <u>built-in</u> defines and/or prints aliases.

   <b>Syntax</b>
       •   <b>alias</b> <b>[-gp]</b> <b>[</b><u>name</u><b>[=</b><u>value</u><b>]...]</b>

   <b>Description</b>
       The alias built-in defines and/or prints aliases as specified by operands. The printed aliases can be
       used as (part of) shell commands. The built-in prints all currently defined aliases when given no
       operands.

   <b>Options</b>
       <b>-g</b>, <b>--global</b>
           With this option, aliases are defined as global aliases; without this option, as normal aliases.

       <b>-p</b>, <b>--prefix</b>
           With this option, aliases are printed in a full command form like <b>alias</b> <b>-g</b> <b>foo='bar'</b>. Without this
           option, only command operands are printed like <b>foo='bar'</b>.

   <b>Operands</b>
       <u>name</u>
           The name of an alias that should be printed.

       <u>name</u>=<u>value</u>
           The name and value of an alias that is being defined.

   <b>Exit</b> <b>status</b>
       The exit status of the alias built-in is zero unless there is any error.

   <b>Notes</b>
       The characters that cannot be used in an alias name are the space, tab, newline, and any of
       <b>=$&lt;&gt;\'"`;&amp;|()#</b>. You can use any characters in an alias value.

       The alias built-in is a mandatory built-in.

       The POSIX standard defines no options for the alias built-in, thus no options are available in the
       POSIXly correct mode.

</pre><h4><b>ARRAY</b> <b>BUILT-IN</b></h4><pre>
       The <u>array</u> <u>built-in</u> prints or modifies arrays.

   <b>Syntax</b>
       •   <b>array</b>

       •   <b>array</b> <u>name</u> <b>[</b><u>value</u><b>...]</b>

       •   <b>array</b> <b>-d</b> <u>name</u> <b>[</b><u>index</u><b>...]</b>

       •   <b>array</b> <b>-i</b> <u>name</u> <u>index</u> <b>[</b><u>value</u><b>...]</b>

       •   <b>array</b> <b>-s</b> <u>name</u> <u>index</u> <u>value</u>

   <b>Description</b>
       When executed without any option or operands, the built-in prints all array definitions to the standard
       output in a form that can be parsed as commands.

       When executed with <u>name</u> and <u>value</u>s (but without an option), the built-in sets the <u>value</u>s as the values of
       the array named <u>name</u>.

       With the <b>-d</b> (<b>--delete</b>) option, the built-in removes the <u>index</u>th values of the array named <u>name</u>. The
       number of values in the array will be decreased by the number of the <u>index</u>es specified. If the <u>index</u>th
       value does not exist, it is silently ignored.

       With the <b>-i</b> (<b>--insert</b>) option, the built-in inserts <u>value</u>s into the array named <u>name</u>. The number of
       values in the array will be increased by the number of the <u>value</u>s specified. The values are inserted
       between the <u>index</u>th and next values. If <u>index</u> is zero, the values are inserted before the first value. If
       <u>index</u> is larger than the number of values in the array, the values are appended after the last element.

       With the <b>-s</b> (<b>--set</b>) option, the built-in sets <u>value</u> as the <u>index</u>th value of the array named <u>name</u>. The
       array must have at least <u>index</u> values.

   <b>Options</b>
       <b>-d</b>, <b>--delete</b>
           Delete array values.

       <b>-i</b>, <b>--insert</b>
           Insert array values.

       <b>-s</b>, <b>--set</b>
           Set an array value.

   <b>Operands</b>
       <u>name</u>
           The name of an array to operate on.

       <u>index</u>
           The index to an array element. The first element has the index of 1.

       <u>value</u>
           A string to which the array element is set.

   <b>Exit</b> <b>status</b>
       The exit status of the array built-in is zero unless there is any error.

   <b>Notes</b>
       The array built-in is not defined in the POSIX standard. Yash implements the built-in as an extension.

       The command <b>array</b> <u>name</u> <u>value</u><b>...</b> is equivalent to the assignment <u>name</u><b>=(</b><u>value</u><b>...)</b>.

</pre><h4><b>BG</b> <b>BUILT-IN</b></h4><pre>
       The <u>bg</u> <u>built-in</u> resumes a job in the background.

   <b>Syntax</b>
       •   <b>bg</b> <b>[</b><u>job</u><b>...]</b>

   <b>Description</b>
       The bg built-in sends the SIGCONT signal to the specified job. As a result, the job is resumed in the
       background (if it has been suspended).

       The name of the job is printed when the job is resumed.

       The built-in can be used only when job control is enabled.

   <b>Operands</b>
       <u>job</u>
           The job ID of the job to be resumed.

           More than one job can be specified at a time. The current job is resumed if none is specified.

           The percent sign (<b>%</b>) at the beginning of a job ID can be omitted if the shell is not in the
           POSIXly-correct mode.

   <b>Exit</b> <b>status</b>
       The exit status of the bg built-in is zero unless there is any error.

   <b>Notes</b>
       The bg built-in is a mandatory built-in.

       The POSIX standard provides that the built-in shall have no effect when the job is already running. The
       bg built-in of yash, however, always sends the SIGCONT signal to the job.

</pre><h4><b>BINDKEY</b> <b>BUILT-IN</b></h4><pre>
       The <u>bindkey</u> <u>built-in</u> prints or modifies key bindings used in line-editing.

   <b>Syntax</b>
       •   <b>bindkey</b> <b>-aev</b> <b>[</b><u>key</u> <b>[</b><u>command</u><b>]]</b>

       •   <b>bindkey</b> <b>-l</b>

   <b>Description</b>
       When executed with the <b>-l</b> (<b>--list</b>) option, the built-in lists all available line-editing commands to the
       standard output.

       When executed with one of the other options, the built-in prints or modifies key bindings for the editing
       mode specified by the option:

       •   Without <u>key</u> or <u>command</u>, all currently defined bindings are printed to the standard output in a form
           that can be parsed as commands that restore the current bindings when executed.

       •   With <u>key</u> but without <u>command</u>, only the binding for the given <u>key</u> is printed.

       •   With <u>key</u> and <u>command</u>, <u>key</u> is bound to <u>command</u>.

   <b>Options</b>
       <b>-a</b>, <b>--vi-command</b>
           Print or modify bindings for the vi command mode.

       <b>-e</b>, <b>--emacs</b>
           Print or modify bindings for the emacs mode.

       <b>-v</b>, <b>--vi-insert</b>
           Print or modify bindings for the vi insert mode.

   <b>Operands</b>
       <u>key</u>
           A character sequence of one or more keys that is bound to an editing command. The sequence may
           include escape sequences.

       <u>command</u>
           A line-editing command to which <u>key</u> is bound. If <u>command</u> is a single hyphen (<b>-</b>), <u>key</u> is unbound.

   <b>Exit</b> <b>status</b>
       The exit status of the bindkey built-in is zero unless there is any error.

   <b>Notes</b>
       The bindkey built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>BREAK</b> <b>BUILT-IN</b></h4><pre>
       The <u>break</u> <u>built-in</u> aborts a loop being executed.

   <b>Syntax</b>
       •   <b>break</b> <b>[</b><u>nest</u><b>]</b>

       •   <b>break</b> <b>-i</b>

   <b>Description</b>
       When executed without the <b>-i</b> (<b>--iteration</b>) option, the built-in aborts a currently executed for, while,
       or until loop. When executed in nested loops, it aborts the <u>nest</u>th innermost loop. The default <u>nest</u> is
       one. If the number of currently executed nested loops is less than <u>nest</u>, the built-in aborts the
       outermost loop.

       When executed with the <b>-i</b> (<b>--iteration</b>) option, the built-in aborts the currently executed (innermost)
       iterative execution.

   <b>Options</b>
       <b>-i</b>, <b>--iteration</b>
           Abort an iterative execution instead of a loop.

   <b>Operands</b>
       <u>nest</u>
           The number of loops to abort, which must be a positive integer.

   <b>Exit</b> <b>status</b>
       The exit status of the break built-in is:

       •   zero if a loop was successfully aborted.

       •   that of the command that was executed just before the break built-in if an iterative execution was
           successfully aborted.

   <b>Notes</b>
       The break built-in is a special built-in.

       The POSIX standard defines no options for the break built-in; the built-in accepts no options in the
       POSIXly-correct mode.

       Treatment of currently executed loops that are not lexically enclosing the break built-in is unspecified
       in POSIX. Examples of such loops include:

       •   A loop invoking a function in which the break built-in is used.

       •   A loop in which a trap action is executed in which the break built-in is used.

       Yash does not allow breaking such loops.

</pre><h4><b>CD</b> <b>BUILT-IN</b></h4><pre>
       The <u>cd</u> <u>built-in</u> changes the working directory.

   <b>Syntax</b>
       •   <b>cd</b> <b>[-L|-P]</b> <b>[</b><u>directory</u><b>]</b>

   <b>Description</b>
       The cd built-in changes the working directory to the directory specified by the operand.

       The pathname of the new working directory is assigned to the <b>PWD</b> variable, whose previous value is again
       assigned to the <b>OLDPWD</b> variable. The new <b>PWD</b> value will not contain any <b>.</b> or <b>..</b> components except when
       the shell is in the POSIXly-correct mode and the new pathname begins with <b><a href="file:/..">/..</a></b>.

       If <u>directory</u> is a relative path that does not start with ‘.’ or ‘..’, paths in the <b>CDPATH</b> variable are
       searched to find a new working directory. The search is done in a manner similar to the last step of
       command search, but a directory is sought instead of an executable regular file. If a new working
       directory was found from <b>CDPATH</b>, its pathname is printed to the standard output. If no applicable
       directory was found in the search, <u>directory</u> is simply treated as a pathname relative to the current
       working directory.

       If the working directory was successfully changed, the value of the <b>YASH_AFTER_CD</b> variable is executed as
       a command unless the shell is in the POSIXly-correct mode. If the variable is an array, its values are
       executed iteratively (cf. eval built-in).

   <b>Options</b>
       <b>-L</b>, <b>--logical</b>
           Symbolic links in the pathname of the new working directory are not resolved. The new value of the
           <b>PWD</b> may include pathname components that are symbolic links.

       <b>-P</b>, <b>--physical</b>
           Symbolic links in the pathname of the new working directory are resolved. The new value of the <b>PWD</b>
           variable never includes pathname components that are symbolic links.

       <b>--default-directory=</b><u>directory</u>
           If this option is specified and the <u>directory</u> operand is omitted, the argument to this option is used
           for the <u>directory</u> operand. If the <u>directory</u> operand is specified, this option is ignored.

       The <b>-L</b> (<b>--logical</b>) and <b>-P</b> (<b>--physical</b>) options are mutually exclusive: only the last specified one is
       effective. If neither is specified, <b>-L</b> is assumed.

   <b>Operands</b>
       <u>directory</u>
           The pathname of the new working directory.

           If <u>directory</u> is a single hyphen (‘-’), the value of the <b>OLDPWD</b> variable is assumed for the new
           directory pathname, which is printed to the standard output.

           If <u>directory</u> is omitted, the working directory is changed to the directory specified by the
           <b>--default-directory=...</b>  option. If that option is not specified either, the default is the home
           directory.

   <b>Exit</b> <b>status</b>
       The exit status of the cd built-in is zero if the working directory was successfully changed and non-zero
       if there was an error.

   <b>Notes</b>
       The cd built-in is a mandatory built-in.

       The POSIX standard does not define the use of the <b>YASH_AFTER_CD</b> variable or the <b>--default-directory=...</b>
       option. The standard does not allow using an option with a single hyphen operand.

       The exit status of the commands in the <b>YASH_AFTER_CD</b> variable does not affect that of the cd built-in.

</pre><h4><b>COLON</b> <b>BUILT-IN</b></h4><pre>
       The <u>colon</u> <u>built-in</u> does nothing.

   <b>Syntax</b>
       •   <b>:</b> <b>[</b><u>argument</u><b>...]</b>

   <b>Description</b>
       The colon built-in does nothing. Any command line arguments are ignored.

   <b>Exit</b> <b>status</b>
       The exit status of the colon built-in is zero.

   <b>Notes</b>
       The colon built-in is a special built-in.

       Arguments are expanded and redirections are performed as usual. The colon and true built-ins have the
       same effect, but colon is a special built-in while true is a mandatory.

</pre><h4><b>COMMAND</b> <b>BUILT-IN</b></h4><pre>
       The <u>command</u> <u>built-in</u> executes or identifies a command.

   <b>Syntax</b>
       •   <b>command</b> <b>[-befp]</b> <u>command</u> <b>[</b><u>argument</u><b>...]</b>

       •   <b>command</b> <b>-v|-V</b> <b>[-abefkp]</b> <u>command</u><b>...</b>

   <b>Description</b>
       Without the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>) option, the built-in executes <u>command</u> with
       <u>argument</u>s in the same manner as the last step of execution of simple commands. The command is treated as
       a built-in or external command or a function according to the options specified to the command built-in.
       The shell does not exit on argument syntax error etc. even if the command is a special built-in

       With the <b>-v</b> (<b>--identify</b>) option, <u>command</u> is identified. If the command is found in <b>$PATH</b>, its full
       pathname is printed. If it is a keyword, function, or built-in that is not found in <b>$PATH</b>, the command
       name is simply printed. If it is an alias, it is printed in the form like <b>alias</b> <b>ll='ls</b> <b>-l'</b>. If the
       command is not found, nothing is printed and the exit status is non-zero.

       The <b>-V</b> (<b>--verbose-identify</b>) option is similar to the <b>-v</b> (<b>--identify</b>) option, but the output format is
       more human-friendly.

   <b>Options</b>
       <b>-a</b>, <b>--alias</b>
           Search for the command as an alias. Must be used with the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>)
           option.

       <b>-b</b>, <b>--builtin-command</b>
           Search for the command as a built-in.

       <b>-e</b>, <b>--external-command</b>
           Search for the command as an external command.

       <b>-f</b>, <b>--function</b>
           Search for the command as a function.

       <b>-k</b>, <b>--keyword</b>
           Search for the command as a keyword. Must be used with the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>)
           option.

       <b>-p</b>, <b>--standard-path</b>
           Search the system’s default <b>PATH</b> instead of the current <b>$PATH</b>.

       <b>-v</b>, <b>--identify</b>
           Identify <u>command</u>s and print in the format defined in the POSIX standard.

       <b>-V</b>, <b>--verbose-identify</b>
           Identify <u>command</u>s and print in a human-friendly format.

       If none of the <b>-a</b> (<b>--alias</b>), <b>-b</b> (<b>--builtin-command</b>), <b>-e</b> (<b>--external-command</b>), <b>-f</b> (<b>--function</b>), and <b>-k</b>
       (<b>--keyword</b>) options is specified, the following defaults are assumed:

       Without the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>) option
           <b>-b</b> <b>-e</b>

       With the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>) option
           <b>-a</b> <b>-b</b> <b>-e</b> <b>-f</b> <b>-k</b>

   <b>Operands</b>
       <u>command</u>
           A command to be executed or identified.

       <u>argument</u>...
           Arguments passed to the executed command.

   <b>Exit</b> <b>status</b>
       The exit status of the command built-in is:

       Without the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>) option
           the exit status of the executed command.

       With the <b>-v</b> (<b>--identify</b>) or <b>-V</b> (<b>--verbose-identify</b>) option
           zero unless there is any error.

   <b>Notes</b>
       The command built-in is a mandatory built-in.

       In the POSIXly-correct mode, options other than <b>-p</b>, <b>-v</b>, and <b>-V</b> cannot be used and at most one <u>command</u> can
       be specified. The POSIX standard does not allow specifying both <b>-v</b> and <b>-V</b> together, but yash does (only
       the last specified one is effective).

</pre><h4><b>COMPLETE</b> <b>BUILT-IN</b></h4><pre>
       The <u>complete</u> <u>built-in</u> generates completion candidates. This built-in can only be executed from completion
       functions during command line completion.

   <b>Syntax</b>
       •   <b>complete</b> <b>[-A</b> <u>pattern</u><b>]</b> <b>[-R</b> <u>pattern</u><b>]</b> <b>[-T]</b> <b>[-P</b> <u>prefix</u><b>]</b> <b>[-S</b> <u>suffix</u><b>]</b> <b>[-abcdfghjkuv]</b> <b>[[-O]</b> <b>[-D</b> <u>description</u><b>]</b>
           <u>word</u><b>...]</b>

   <b>Description</b>
       The built-in generates completion candidates according to the specified arguments. No matter how
       candidates are generated, only candidates that match the word being completed are generated.

   <b>Options</b>
       <b>-A</b> <u>pattern</u>, <b>--accept=</b><u>pattern</u>
           Only accept candidates that match the pattern specified by this option. When more than one of this
           option is specified, only candidates that match all of the patterns are generated.

       <b>-D</b> <u>description</u>, <b>--description=</b><u>description</u>
           Give a description of the <u>word</u> candidates. The description is shown beside the candidates in the
           candidate list.

       <b>-O</b>, <b>--option</b>
           The candidates are treated as command line options. A hyphen is prepended to each candidate that is
           treated as an option.

       <b>-P</b> <u>prefix</u>, <b>--prefix=</b><u>prefix</u>
           Ignore <u>prefix</u> of the word being completed when generating candidates. The specified <u>prefix</u> must be
           initial part of the word.

           If the word being completed is <b>file:///home/user/docume</b> for example, the command line <b>complete</b> <b>-P</b>
           <b>file://</b> <b>-f</b> will generate pathname candidates that complete <b>/home/user/docume</b>.

       <b>-R</b> <u>pattern</u>, <b>--reject=</b><u>pattern</u>
           Reject candidates that match the pattern specified by this option. When more than one of this option
           is specified, only candidates that match none of the patterns are generated.

       <b>-S</b> <u>suffix</u>, <b>--suffix=</b><u>suffix</u>
           Append <u>suffix</u> to each generated candidate.

       <b>-T</b>, <b>--no-termination</b>
           Do not append a space after the word is completed. Without this option, a space is appended to the
           completed word so that you do not have to enter a space before the next word.

       <b>Options</b> <b>that</b> <b>select</b> <b>candidate</b> <b>types</b>

           <b>-a</b>, <b>--alias</b>
               Aliases. (same as <b>--normal-alias</b> <b>--global-alias</b>)

           <b>--array-variable</b>
               Arrays.

           <b>--bindkey</b>
               Line-editing commands the <b>bindkey</b> built-in accepts.

           <b>-b</b>, <b>--builtin-command</b>
               Built-in commands. (same as <b>--special-builtin</b> <b>--mandatory-builtin</b> <b>--elective-builtin</b>
               <b>--extension-builtin</b> <b>--substitutive-builtin</b>)

           <b>-c</b>, <b>--command</b>
               Commands. (same as <b>--builtin-command</b> <b>--external-command</b> <b>--function</b>)

           <b>-d</b>, <b>--directory</b>
               Directories.

           <b>--dirstack-index</b>
               Valid indices of the directory stack.

           <b>--elective-builtin</b>
               Elective built-in commands.

           <b>--executable-file</b>
               Executable regular files.

           <b>--extension-builtin</b>
               Extension built-in commands.

           <b>--external-command</b>
               External commands.

           <b>-f</b>, <b>--file</b>
               Files (including directories).

           <b>--finished-job</b>
               Job IDs of finished jobs.

           <b>--function</b>
               Functions.

           <b>--global-alias</b>
               Global aliases.

           <b>-g</b>, <b>--group</b>
               User groups.

           <b>-h</b>, <b>--hostname</b>
               Host names.

           <b>-j</b>, <b>--job</b>
               Job IDs.

           <b>-k</b>, <b>--keyword</b>
               Keywords.

           <b>--mandatory-builtin</b>
               Mandatory built-in commands.

           <b>--normal-alias</b>
               Normal aliases.

           <b>--regular-builtin</b>
               Obsolete synonym for <b>--extension-builtin</b> <b>--substitutive-builtin</b>.

           <b>--running-job</b>
               Job IDs of jobs that are being executed.

           <b>--scalar-variable</b>
               Variables that are not arrays.

           <b>--semi-special-builtin</b>
               Obsolete synonym for <b>--mandatory-builtin</b> <b>--elective-builtin</b>.

           <b>--signal</b>
               Signals.

           <b>--special-builtin</b>
               Special built-in commands.

           <b>--stopped-job</b>
               Job IDs of jobs that are suspended.

           <b>--substitutive-builtin</b>
               Substitutive built-in commands.

           <b>-u</b>, <b>--username</b>
               Users' log-in names.

           <b>-v</b>, <b>--variable</b>
               Variables.

           If the <b>-d</b> (<b>--directory</b>) option is specified without the <b>-f</b> (<b>--file</b>) option, the <b>-S</b> <b>/</b> <b>-T</b> options are
           assumed.

           Generated candidates for job IDs do not have leading percent signs (<b>%</b>). If the word being completed
           starts with a percent sign, the <b>-P</b> <b>%</b> option should be specified.

   <b>Operands</b>
       Operands are treated as completion candidates.

   <b>Exit</b> <b>status</b>
       The exit status of the built-in is zero if one or more candidates were generated, one if no candidates
       were generated, or larger than one if an error occurred.

   <b>Notes</b>
       The complete built-in is an elective built-in. It can be used in completion functions even in the
       POSIXly-correct mode because the mode is temporarily disabled during completion.

</pre><h4><b>CONTINUE</b> <b>BUILT-IN</b></h4><pre>
       The <u>continue</u> <u>built-in</u> skips an iteration of a loop being executed.

   <b>Syntax</b>
       •   <b>continue</b> <b>[</b><u>nest</u><b>]</b>

       •   <b>continue</b> <b>-i</b>

   <b>Description</b>
       When executed without the <b>-i</b> (<b>--iteration</b>) option, the built-in aborts the current iteration of for,
       while, or until loop and starts the next iteration of the loop. When executed in nested loops, it affects
       the <u>nest</u>th innermost loop. The default <u>nest</u> is one. If the number of currently executed nested loops is
       less than <u>nest</u>, the built-in affects the outermost loop.

       When executed with the <b>-i</b> (<b>--iteration</b>) option, the built-in aborts the current iteration of (innermost)
       iterative execution.

   <b>Options</b>
       <b>-i</b>, <b>--iteration</b>
           Skip an iterative execution instead of a loop.

   <b>Operands</b>
       <u>nest</u>
           The <u>nest</u>th innermost loop is affected.  <u>nest</u> must be a positive integer.

   <b>Exit</b> <b>status</b>
       The exit status of the continue built-in is:

       •   zero if loop iteration was successfully skipped.

       •   that of the command that was executed just before the continue built-in if iterative execution was
           successfully skipped.

   <b>Notes</b>
       The continue built-in is a special built-in.

       The POSIX standard defines no options for the continue built-in; the built-in accepts no options in the
       POSIXly-correct mode.

       Treatment of currently executed loops that are not lexically enclosing the continue built-in is
       unspecified in POSIX. Examples of such loops include:

       •   A loop invoking a function in which the continue built-in is used

       •   A loop in which a trap action is executed in which the continue built-in is used

       Yash does not allow continuing such loops.

</pre><h4><b>DIRS</b> <b>BUILT-IN</b></h4><pre>
       The <u>dirs</u> <u>built-in</u> prints the contents of the directory stack.

   <b>Syntax</b>
       •   <b>dirs</b> <b>[-cv]</b> <b>[</b><u>index</u><b>..]</b>

   <b>Description</b>
       The <u>directory</u> <u>stack</u> is a feature that records history of working directories. You can use the pushd
       built-in to save a working directory in the directory stack, the popd built-in to recall the saved
       working directory, and the dirs built-in to see the stack contents. Those built-ins use the <b>DIRSTACK</b>
       array and the <b>PWD</b> variable to save the stack contents. Modifying the array means modifying the stack
       contents.

       Directory stack entries are indexed by signed integers. The entry of index +0 is the current working
       directory, +1 is the last saved directory, +2 is the second last, and so on. Negative indices are in the
       reverse order: the entry of index -0 is the first saved directory, -1 is the second, and -<u>n</u> is the
       current working directory if the stack has <u>n</u> entries,

       When executed without the <b>-c</b> (<b>--clear</b>) option, the dirs built-in prints the current contents of the
       directory stack to the standard output. With the <b>-c</b> (<b>--clear</b>) option, the built-in clears the directory
       stack.

   <b>Options</b>
       <b>-c</b>, <b>--clear</b>
           Clear the directory stack contents except for the current working directory, which has index +0.

       <b>-v</b>, <b>--verbose</b>
           Print indices when printing stack contents.

   <b>Operands</b>
       <u>index</u>
           The index of a stack entry to be printed.

           You can specify more than one index. If you do not specify any index, all the entries are printed.

   <b>Exit</b> <b>status</b>
       The exit status of the dirs built-in is zero unless there is any error.

   <b>Notes</b>
       The dirs built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>DISOWN</b> <b>BUILT-IN</b></h4><pre>
       The <u>disown</u> <u>built-in</u> removes jobs.

   <b>Syntax</b>
       •   <b>disown</b> <b>[-a]</b> <b>[</b><u>job</u><b>...}</b>

   <b>Description</b>
       The disown built-in removes the specified jobs from the job list. The removed jobs will no longer be
       job-controlled, but the job processes continue execution (unless they have been suspended).

   <b>Options</b>
       <b>-a</b>, <b>--all</b>
           Removes all jobs.

   <b>Operands</b>
       <u>job</u>
           The job ID of the job to be removed.

           You can specify more than one job ID. If you do not specify any job ID, the current job is removed.
           If the shell is not in the POSIXly-correct mode, the %-prefix of the job ID can be omitted.

   <b>Exit</b> <b>status</b>
       The exit status of the disown built-in is zero unless there is any error.

   <b>Notes</b>
       The disown built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>DOT</b> <b>BUILT-IN</b></h4><pre>
       The <u>dot</u> <u>built-in</u> reads a file and executes commands in it.

   <b>Syntax</b>
       •   <b>.</b> <b>[-AL]</b> <u>file</u> <b>[</b><u>argument</u><b>...]</b>

   <b>Description</b>
       The dot built-in reads the specified <u>file</u>, parses its contents as commands, and executes them in the
       current command execution environment.

       If <u>argument</u>s are specified, positional parameters are temporarily set to them. The positional parameters
       will be restored when the dot built-in finishes. If no <u>argument</u>s are specified, the positional parameters
       are not changed.

       If <u>file</u> does not contain any slashes, the shell searches <b>$PATH</b> for a readable (but not necessarily
       executable) shell script file whose name is <u>file</u> in the same manner as command search. If no such file
       was found, the shell searches the current working directory for a file unless in the POSIXly-correct
       mode. To ensure that the file in the current working directory is used, start <u>file</u> with ‘./’.

   <b>Options</b>
       <b>-A</b>, <b>--no-alias</b>
           Disable alias substitution while parsing.

       <b>-L</b>, <b>--autoload</b>
           Search <b>$YASH_LOADPATH</b> instead of <b>$PATH</b>, regardless of whether <u>file</u> contains slashes. The <u>file</u> value
           is not considered relative to the current working directory.

       The dot built-in treats as operands any command line arguments after the first operand.

   <b>Operands</b>
       <u>file</u>
           The pathname of a file to be read.

       <u>arguments</u>...
           Strings to which positional parameters are set while execution.

   <b>Exit</b> <b>status</b>
       The exit status of the dot built-in is that of the last command executed. The exit status is zero if the
       file contains no commands to execute and non-zero if a file was not found or could not be opened.

   <b>Notes</b>
       The dot built-in is a special built-in.

       A non-interactive shell immediately exits with a non-zero exit status if the dot built-in fails to find
       or open a file to execute.

       The POSIX standard defines no options for the dot built-in; the built-in accepts no options in the
       POSIXly-correct mode.

       The POSIX standard does not define the <u>arguments</u>... operands. It is an error to specify the <u>arguments</u>...
       operands in the POSIXly-correct mode.

</pre><h4><b>ECHO</b> <b>BUILT-IN</b></h4><pre>
       The <u>echo</u> <u>built-in</u> prints its arguments.

   <b>Syntax</b>
       •   <b>echo</b> <b>[</b><u>string</u><b>...]</b>

       The built-in treats all command line arguments as operands except for the options described below. Any
       word that cannot be parsed as an acceptable option is treated as an operand. Options must precede all
       operands. Syntax errors never happen in the echo built-in.

   <b>Description</b>
       The echo built-in prints the operand <u>string</u>s followed by a newline to the standard output. The <u>string</u>s
       are each separated by a space.

       <b>Escape</b> <b>sequences</b>

           The <b>ECHO_STYLE</b> variable and the <b>-e</b> option enable escape sequences that are replaced with
           corresponding characters:

           <b>\a</b>
               Bell character (ASCII code: 7)

           <b>\b</b>
               Backspace (ASCII code: 8)

           <b>\c</b>
               Nothing. After this escape sequence, no characters are printed at all.

           <b>\e</b>
               Escape character (ASCII code: 27)

           <b>\f</b>
               Form feed character (ASCII code: 12)

           <b>\n</b>
               Newline character (ASCII code: 10)

           <b>\r</b>
               Carriage return character (ASCII code: 13)

           <b>\t</b>
               Horizontal tab character (ASCII code: 9)

           <b>\v</b>
               Vertical tab character (ASCII code: 11)

           <b>\\</b>
               Backslash

           <b>\0</b><u>xxx</u>
               Character whose code is <u>xxx</u>, where <u>xxx</u> is an octal number of at most three digits.

           When escape sequences are not enabled, they are just printed intact.

       <b>ECHO_STYLE</b> <b>variable</b>

           The <b>ECHO_STYLE</b> variable defines which options are accepted and whether escape sequences are enabled
           by default. The variable value should be set to one of the following:

           <b>SYSV</b>, <b>XSI</b>
               No options are accepted. Escape sequences are always enabled.

           <b>BSD</b>
               The <b>-n</b> option is accepted. Escape sequences are never enabled.

           <b>GNU</b>
               The <b>-n</b>, <b>-e</b>, and <b>-E</b> options are accepted. Escape sequences are not enabled by default, but can be
               enabled by the <b>-e</b> option.

           <b>ZSH</b>
               The <b>-n</b>, <b>-e</b>, and <b>-E</b> options are accepted. Escape sequences are enabled by default, but can be
               disabled by the <b>-E</b> option.

           <b>DASH</b>
               The <b>-n</b> option is accepted. Escape sequences are always enabled.

           <b>RAW</b>
               No options are accepted. Escape sequences are never enabled.

           When the <b>ECHO_STYLE</b> variable is not set, it defaults to <b>SYSV</b>.

   <b>Options</b>
       <b>-n</b>
           Do not print a newline at the end.

       <b>-e</b>
           Enable escape sequences.

       <b>-E</b>
           Disable escape sequences.

   <b>Exit</b> <b>status</b>
       The exit status of the echo built-in is zero unless there is any error.

   <b>Notes</b>
       The POSIX standard does not define the <b>ECHO_STYLE</b> variable nor any options for the built-in. According to
       POSIX, the behavior of the built-in is implementation-defined when the first argument is <b>-n</b> or when any
       argument contains a backslash. For maximum portability, the printf built-in should be preferred over the
       echo built-in.

       Although many values for the <b>ECHO_STYLE</b> variable are defined on the basis of other existing
       implementations, yash is not intended to exactly imitate those originals. Zsh’s echo built-in interprets
       a single hyphen argument as a separator between options and operands. Yash does not support such use of
       hyphen.

</pre><h4><b>EVAL</b> <b>BUILT-IN</b></h4><pre>
       The <u>eval</u> <u>built-in</u> evaluates operands as commands.

   <b>Syntax</b>
       •   <b>eval</b> <b>[-i]</b> <b>[</b><u>command</u><b>...]</b>

       The eval built-in requires that all options precede operands. Any command line arguments after the first
       operand are all treated as operands.

   <b>Description</b>
       The eval parses operands as commands and executes them in the current command execution environment.

       When executed without the <b>-i</b> (<b>--iteration</b>) option, all the operands are concatenated into one string
       (with a space inserted between each operand) and parsed/executed at once.

       With the <b>-i</b> (<b>--iteration</b>) option, the built-in performs <u>iterative</u> <u>execution</u>: operands are parsed/executed
       one by one. If the continue built-in is executed with the <b>-i</b> (<b>--iteration</b>) option during the iterative
       execution, the execution of the current operand is aborted and the next operand is parsed/executed
       immediately. The break built-in with the <b>-i</b> (<b>--iteration</b>) option is similar but the remaining operands
       are not parsed/executed. The value of the <b>?</b> special parameter is saved before the iterative execution is
       started. The parameter value is restored to the saved one after each iteration.

   <b>Options</b>
       <b>-i</b>, <b>--iteration</b>
           Perform iterative execution.

   <b>Operands</b>
       <u>command</u>
           A string that is parsed and executed as commands.

   <b>Exit</b> <b>status</b>
       The exit status is zero if no <u>command</u> was specified or <u>command</u> contained no actual command that can be
       executed. Otherwise, that is, if the eval built-in executed one or more commands, the exit status of the
       eval built-in is that of the last executed command.

   <b>Notes</b>
       The eval built-in is a special built-in.

       The POSIX standard defines no options for the eval built-in; the built-in accepts no options in the
       POSIXly-correct mode.

</pre><h4><b>EXEC</b> <b>BUILT-IN</b></h4><pre>
       The <u>exec</u> <u>built-in</u> replaces the shell process with another external command.

   <b>Syntax</b>
       •   <b>exec</b> <b>[-cf]</b> <b>[-a</b> <u>name</u><b>]</b> <b>[</b><u>command</u> <b>[</b><u>argument</u><b>...]]</b>

       The exec built-in requires that all options precede operands. It is important so that options to the exec
       built-in are not confused with options to <u>command</u>. Any command line arguments after <u>command</u> are treated
       as <u>argument</u>s.

   <b>Description</b>
       When the exec built-in is executed with <u>command</u>, the shell executes <u>command</u> with <u>argument</u>s in a manner
       similar to the last step of execution of a simple command. The differences are that <u>command</u> is always
       treated as an external command ignoring any existing functions and built-ins and that the exec system
       call that starts the external command is called in the current command execution environment instead of a
       subshell, replacing the shell process with the new command process.

       If the shell is in the POSIXly-correct mode or not interactive, failure in execution of <u>command</u> causes
       the shell to exit immediately.

       If an interactive shell that is not in the POSIXly-correct mode has a stopped job, the shell prints a
       warning message and refuses to execute <u>command</u>. Once the shell process is replaced with an external
       command, information about the shell’s jobs is lost, so you will have to resume or kill the stopped jobs
       by sending signals by hand. To force the shell to execute <u>command</u> regardless, specify the <b>-f</b> (<b>--force</b>)
       option.

       When executed without <u>command</u>, the built-in does nothing. As a side effect, however, redirection applied
       to the built-in remains in the current command execution environment even after the built-in finished.

   <b>Options</b>
       <b>-a</b> <u>name</u>, <b>--as=</b><u>name</u>
           Pass <u>name</u>, instead of <u>command</u>, to the external command as its name.

       <b>-c</b>, <b>--clear</b>
           Pass to the external command only variables that are assigned in the simple command in which the
           built-in is being executed. Other environment variables are not passed to the command.

       <b>-f</b>, <b>--force</b>
           Suppress warnings that would prevent command execution.

   <b>Operands</b>
       <u>command</u>
           An external command to be executed.

       <u>argument</u>...
           Arguments to be passed to the command.

   <b>Exit</b> <b>status</b>
       If the shell process was successfully replaced with the external command, there is no exit status since
       the shell process no longer exists.

       The exit status is:

       •   127 if the command was not found,

       •   126 if the command was found but could not be executed, and

       •   zero if no <u>command</u> was specified.

   <b>Notes</b>
       The exec built-in is a special built-in.

       The POSIX standard defines no options for the exec built-in; the built-in accepts no options in the
       POSIXly-correct mode.

</pre><h4><b>EXIT</b> <b>BUILT-IN</b></h4><pre>
       The <u>exit</u> <u>built-in</u> causes the shell process to exit.

   <b>Syntax</b>
       •   <b>exit</b> <b>[-f]</b> <b>[</b><u>exit_status</u><b>]</b>

   <b>Description</b>
       The exit built-in causes the current shell (or subshell) process to exit.

       If an interactive shell has a stopped job, the shell prints a warning message and refuses to exit. To
       force the shell to exit regardless, specify the <b>-f</b> (<b>--force</b>) option or execute the built-in twice in a
       row.

       If an EXIT trap has been set, the shell executes the trap before exiting.

   <b>Options</b>
       <b>-f</b>, <b>--force</b>
           Suppress warnings that would prevent the shell from exiting.

   <b>Operands</b>
       <u>exit_status</u>
           A non-negative integer that will be the exit status of the exiting shell.

           If this operand is omitted, the exit status of the shell will be that of the last command executed
           before the exit built-in (but, if the built-in is executed during a trap, the exit status will be
           that of the last command before the trap is entered).

           If <u>exit_status</u> is 256 or larger, the actual exit status will be the remainder of <u>exit_status</u> divided
           by 256.

   <b>Exit</b> <b>status</b>
       Because the built-in causes the shell to exit, there is no exit status of the built-in.

       As an exception, if the shell refused to exit, the exit status of the built-in is non-zero.

   <b>Notes</b>
       The exit built-in is a special built-in.

       The POSIX standard defines no options for the exit built-in; the built-in accepts no options in the
       POSIXly-correct mode.

       The POSIX standard provides that the <u>exit_status</u> operand should be between 0 and 255 (inclusive). Yash
       accepts integers larger than 255 as an extension.

       If the built-in is executed during an EXIT trap, the shell just exits without executing the trap again.
       If <u>exit_status</u> was not specified, the exit status of the shell is what the exit status would be if the
       trap had not been set. See also Termination of the shell.

</pre><h4><b>EXPORT</b> <b>BUILT-IN</b></h4><pre>
       The <u>export</u> <u>built-in</u> marks variables for export to child processes.

   <b>Syntax</b>
       •   <b>export</b> <b>[-prX]</b> <b>[</b><u>name</u><b>[=</b><u>value</u><b>]...]</b>

   <b>Description</b>
       The export built-in is equivalent to the typeset built-in with the <b>-gx</b> option.

   <b>Notes</b>
       The export built-in is a special built-in.

       The POSIX standard defines the <b>-p</b> option only; other options cannot be used in the POSIXly-correct mode.
       The POSIX does not allow using the option together with operands.

</pre><h4><b>FALSE</b> <b>BUILT-IN</b></h4><pre>
       The <u>false</u> <u>built-in</u> does nothing unsuccessfully.

   <b>Syntax</b>
       •   <b>false</b>

   <b>Description</b>
       The false built-in does nothing. Any command line arguments are ignored.

   <b>Exit</b> <b>status</b>
       The exit status of the false built-in is non-zero.

   <b>Notes</b>
       The false built-in is a mandatory built-in.

</pre><h4><b>FC</b> <b>BUILT-IN</b></h4><pre>
       The <u>fc</u> <u>built-in</u> re-executes or prints commands from command history.

   <b>Syntax</b>
       •   <b>fc</b> <b>[-qr]</b> <b>[-e</b> <u>editor</u><b>]</b> <b>[</b><u>start</u> <b>[</b><u>end</u><b>]]</b>

       •   <b>fc</b> <b>-s[q]</b> <b>[</b><u>old</u><b>=</b><u>new</u><b>]</b> <b>[</b><u>start</u><b>]</b>

       •   <b>fc</b> <b>-l[nrv]</b> <b>[</b><u>start</u> <b>[</b><u>end</u><b>]]</b>

   <b>Description</b>
       When executed without the <b>-l</b> (<b>--list</b>) option, the built-in executes the commands in the command history
       range specified by the operands. If the <b>-s</b> (<b>--silent</b>) option is not specified, the shell invokes an
       editor which allows you to edit the commands before they are executed. The commands are executed when you
       quit the editor. If the <b>-s</b> (<b>--silent</b>) option is specified, the commands are immediately executed. In
       either case, the executed commands are printed to the standard output and added to the history.

       When executed with the <b>-l</b> (<b>--list</b>) option, the built-in prints the commands in the command history range
       specified by the operands. By default, commands are printed with their history entry numbers, but output
       format can be changed using the <b>-n</b> (<b>--no-numbers)</b>) and <b>-v</b> (<b>--verbose</b>) options.

   <b>Options</b>
       <b>-e</b> <u>editor</u>, <b>--editor=</b><u>editor</u>
           Specify an editor that is used to edit commands.

           If this option is not specified, the value of the <b>FCEDIT</b> variable is used. If the variable is not set
           either, <b>ed</b> is used.

       <b>-l</b>, <b>--list</b>
           Print command history entries.

       <b>-n</b>, <b>--no-numbers</b>
           Don’t print entry numbers when printing history entries.

       <b>-q</b>, <b>--quiet</b>
           Don’t print commands before executing.

       <b>-r</b>, <b>--reverse</b>
           Reverse the order of command entries in the range.

       <b>-s</b>, <b>--silent</b>
           Execute commands without editing them.

       <b>-v</b>, <b>--verbose</b>
           Print execution time before each history entry when printing.

   <b>Operands</b>
       <u>start</u> and <u>end</u>
           The <u>start</u> and <u>end</u> operands specify a range of command history entries that are executed or printed.
           If one of the operands is an integer, it is treated as a history entry number. A negative integer
           means the <u>n</u>th most recent entry where <u>n</u> is the absolute value of the integer. If one of the operands
           is not an integer, it is treated as part of a command string: the most recent entry that starts with
           the string is selected as the start or end of the range.

           If the first entry of the range that is specified by <u>start</u> is newer than the last entry of the range
           that is specified by <u>end</u>, the range is reversed as if the <b>-r</b> (<b>--reverse</b>) option was specified. (If
           the option is already specified, it is cancelled.)

           The default values for <u>start</u> and <u>end</u> are:
           ┌───────┬─────────┬───────────────┐
           │       │ <b>with</b> <b>-l</b> │ <b>without</b> <b>-l</b>    │
           ├───────┼─────────┼───────────────┤
           │ <u>start</u> │ -16     │ -1            │
           ├───────┼─────────┼───────────────┤
           │ <u>end</u>   │ -16     │ same as <u>start</u> │
           └───────┴─────────┴───────────────┘

       <u>old</u>=<u>new</u>
           An operand of this format replaces part of the command string. If the command string contains <u>old</u>, it
           is replaced with <u>new</u> and the new string is executed. Only the first occurrence of <u>old</u> is replaced.

   <b>Exit</b> <b>status</b>
       If commands was executed, the exit status of the fc built-in is that of the last executed command.
       Otherwise, the exit status is zero unless there is any error.

   <b>Notes</b>
       The fc built-in is a mandatory built-in.

       The POSIX standard does not define the <b>-q</b> (<b>--quiet</b>) or <b>-v</b> (<b>--verbose</b>) options, so they cannot be used in
       the POSIXly-correct mode.

       Command history cannot be modified during line-editing.

</pre><h4><b>FG</b> <b>BUILT-IN</b></h4><pre>
       The <u>fg</u> <u>built-in</u> resumes a job in the foreground.

   <b>Syntax</b>
       •   <b>fg</b> <b>[</b><u>job</u><b>...]</b>

   <b>Description</b>
       The fg built-in brings the specified job to the foreground and sends the SIGCONT signal to the job. As a
       result, the job is resumed in the foreground (if it has been suspended). The built-in then waits for the
       job to finish and returns the exit status of it.

       The name of the job is printed when the job is resumed. When not in the POSIXly-correct mode, the job
       number is also printed.

       The built-in can be used only when job control is enabled.

   <b>Operands</b>
       <u>job</u>
           The job ID of the job to be resumed.

           If more than one job is specified, they are resumed in order, one at a time. The current job is
           resumed if none is specified.

           The percent sign (<b>%</b>) at the beginning of a job ID can be omitted if the shell is not in the
           POSIXly-correct mode.

   <b>Exit</b> <b>status</b>
       The exit status of the fg built-in is that of the (last) job resumed. The exit status is non-zero when
       there was some error.

   <b>Notes</b>
       The fg built-in is a mandatory built-in.

       You cannot specify more than one job in the POSIXly-correct mode.

</pre><h4><b>GETOPTS</b> <b>BUILT-IN</b></h4><pre>
       The <u>getopts</u> <u>built-in</u> parses command options.

   <b>Syntax</b>
       •   <b>getopts</b> <u>optionlist</u> <u>variable</u> <b>[</b><u>argument</u><b>...]</b>

   <b>Description</b>
       The getopts built-in parses single-character options that appear in <u>argument</u>s. Each time the built-in is
       invoked, it parses one option and assigns the option character to <u>variable</u>.

       The <u>optionlist</u> operand is a list of option characters that should be accepted by the parser. In
       <u>optionlist</u>, an option that takes an argument should be specified as the option character followed by a
       colon. For example, if you want the <b>-a</b>, <b>-b</b> and <b>-c</b> options to be parsed and the <b>-b</b> option to take an
       argument, then <u>optionlist</u> should be <b>ab:c</b>.

       When an option that takes an argument is parsed, the argument is assigned to the <b>OPTARG</b> variable.

       When an option that is not specified in <u>optionlist</u> is found or when an option argument is missing, the
       result depends on the first character of <u>optionlist</u>:

       •   If <u>optionlist</u> starts with a colon, the option character is assigned to the <b>OPTARG</b> variable and
           <u>variable</u> is set to either <b>?</b>  (when the option is not in <u>optionlist</u>) or <b>:</b> (when the option argument is
           missing).

       •   Otherwise, <u>variable</u> is set to <b>?</b>, the <b>OPTARG</b> variable is unset, and an error message is printed.

       The built-in parses one option for each execution. For all options in a set of command line arguments to
       be parsed, the built-in has to be executed repeatedly with the same arguments. The built-in uses the
       <b>OPTIND</b> variable to remember which <u>argument</u> should be parsed next. When the built-in is invoked for the
       first time, the variable value must be <b>1</b>, which is the default value. You must not modify the variable
       until all the options have been parsed, when the built-in sets the variable to the index of the first
       operand in <u>argument</u>s. (If there are no operands, it will be set to the number of <u>argument</u>s plus one.)

       When you want to start parsing a new set of <u>argument</u>s, you have to reset the <b>OPTIND</b> variable to <b>1</b>
       beforehand.

   <b>Operands</b>
       <u>optionlist</u>
           A list of options that should be accepted as valid options in parsing.

       <u>variable</u>
           The name of a variable the result is to be assigned to.

       <u>argument</u>s
           Command line arguments that are to be parsed.

           When no <u>argument</u>s are given, the positional parameters are parsed.

   <b>Exit</b> <b>status</b>
       If an option is found, whether or not it is specified in <u>optionlist</u>, the exit status is zero. If there is
       no more option to be parsed, the exit status is non-zero.

   <b>Example</b>
           aopt=false bopt= copt=false
           while getopts ab:c opt
           do
             case $opt in
             a) aopt=true ;;
             b) bopt=$OPTARG ;;
             c) copt=true ;;
             \?) return 2 ;;
             esac
           done
           if $aopt;          then echo Option -a specified;       fi
           if [ -n "$bopt" ]; then echo Option -b $bopt specified; fi
           if $copt;          then echo Option -c specified;       fi
           shift $((OPTIND - 1))
           echo Operands are: $*

   <b>Notes</b>
       In <u>argument</u>s that are parsed, options must precede operands. The built-in ends parsing when it encounters
       the first operand.

       The getopts built-in is a mandatory built-in.

       The POSIX standard does not specify what will happen when the <b>OPTIND</b> variable is assigned a value other
       than <b>1</b>.

       In the POSIXly-correct mode, option characters in <u>optionlist</u> must be alphanumeric.

</pre><h4><b>HASH</b> <b>BUILT-IN</b></h4><pre>
       The <u>hash</u> <u>built-in</u> remembers, forgets, or reports command locations.

   <b>Syntax</b>
       •   <b>hash</b> <u>command</u><b>...</b>

       •   <b>hash</b> <b>-r</b> <b>[</b><u>command</u><b>...]</b>

       •   <b>hash</b> <b>[-a]</b>

       •   <b>hash</b> <b>-d</b> <u>user</u><b>...</b>

       •   <b>hash</b> <b>-dr</b> <b>[</b><u>user</u><b>...]</b>

       •   <b>hash</b> <b>-d</b>

   <b>Description</b>
       When executed with <u>command</u>s but without options, the built-in immediately performs command path search
       and caches <u>command</u>s' full paths.

       When executed with the <b>-r</b> (<b>--remove</b>) option, it removes the paths of <u>command</u>s (or all cached paths if
       none specified) from the cache.

       When executed without options or <u>command</u>s, it prints the currently cached paths to the standard output.

       With the <b>-d</b> (<b>--directory</b>) option, the built-in does the same things to the home directory cache, rather
       than the command path cache. Cached home directory paths are used in tilde expansion.

   <b>Options</b>
       <b>-a</b>, <b>--all</b>
           Print all cached paths.

           Without this option, paths for built-ins are not printed.

       <b>-d</b>, <b>--directory</b>
           Affect the home directory cache instead of the command path cache.

       <b>-r</b>, <b>--remove</b>
           Remove cached paths.

   <b>Operands</b>
       <u>command</u>
           The name of an external command (that does not contain any slash).

       <u>user</u>
           A user name.

   <b>Exit</b> <b>status</b>
       The exit status of the hash built-in is zero unless there is any error.

   <b>Notes</b>
       The shell automatically caches command and directory paths when executing a command or performing tilde
       expansion, so normally there is no need to use this built-in explicitly to cache paths.

       Assigning a value to the <b>PATH</b> variable removes all command paths from the cache as if <b>hash</b> <b>-r</b> was
       executed.

       The POSIX standard defines the <b>-r</b> option only: other options cannot be used in the POSIXly-correct mode.

       The hash built-in is a mandatory built-in.

</pre><h4><b>HELP</b> <b>BUILT-IN</b></h4><pre>
       The <u>help</u> <u>built-in</u> prints usage of built-ins.

   <b>Syntax</b>
       •   <b>help</b> <b>[</b><u>built-in</u><b>...]</b>

   <b>Description</b>
       The help built-in prints a description of <u>built-in</u>s.

   <b>Operands</b>
       <u>built-in</u>s
           Names of built-ins.

   <b>Exit</b> <b>status</b>
       The exit status of the help built-in is zero unless there is any error.

   <b>Notes</b>
       The help built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

       Many built-ins of yash accept the <b>--help</b> option that prints the same description.

</pre><h4><b>HISTORY</b> <b>BUILT-IN</b></h4><pre>
       The <u>history</u> <u>built-in</u> prints or edits command history.

   <b>Syntax</b>
       •   <b>history</b> <b>[-cF]</b> <b>[-d</b> <u>entry</u><b>]</b> <b>[-s</b> <u>command</u><b>]</b> <b>[-r</b> <u>file</u><b>]</b> <b>[-w</b> <u>file</u><b>]</b> <b>[</b><u>count</u><b>]</b>

   <b>Description</b>
       The history built-in prints or edits command history.

       When executed with an option, the built-in edits history according to the option. If more than one option
       is specified, each option is processed in order.

       When executed with the <u>count</u> operand, the built-in prints the most recent <u>count</u> history entries to the
       standard output in the same manner as the fc built-in.

       When executed with neither options nor operands, the built-in prints the whole history.

   <b>Options</b>
       <b>-c</b>, <b>--clear</b>
           Clear all history entries completely.

       <b>-d</b> <u>entry</u>, <b>--delete=</b><u>entry</u>
           Delete the specified <u>entry</u>. The <u>entry</u> should be specified in the same manner as the <u>start</u> and <u>end</u>
           operands of the fc built-in.

       <b>-F</b>, <b>--flush-file</b>
           Rebuild the history file. This operation removes unused old data from the file.

       <b>-r</b> <u>file</u>, <b>--read=</b><u>file</u>
           Read command lines from <u>file</u> and add them to the history. The file contents are treated as lines of
           simple text.

       <b>-s</b> <u>command</u>, <b>--set=</b><u>command</u>
           Add <u>command</u> as a new history entry after removing the most recent entry.

       <b>-w</b> <u>file</u>, <b>--write=</b><u>file</u>
           Write the whole history to <u>file</u>. Any existing data in the file will be lost. The output format is
           lines of simple text, each of which is a command string.

   <b>Operands</b>
       <u>count</u>
           The number of entries to be printed.

   <b>Exit</b> <b>status</b>
       The exit status of the history built-in is zero unless there is any error.

   <b>Notes</b>
       The history built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

       Command history cannot be modified during line-editing.

</pre><h4><b>JOBS</b> <b>BUILT-IN</b></h4><pre>
       The <u>jobs</u> <u>built-in</u> reports job status.

   <b>Syntax</b>
       •   <b>jobs</b> <b>[-lnprs]</b> <b>[</b><u>job</u><b>...]</b>

   <b>Description</b>
       The jobs built-in prints information of jobs the shell is currently controlling.

       By default, the following information is printed for each job, line by line:

       •   the job number,

       •   the <b>+</b> or <b>-</b> symbol if the job is the current or previous job, respectively,

       •   the status, and

       •   the command string.

   <b>Options</b>
       <b>-l</b>, <b>--verbose</b>
           Print the process ID, status, and command string for each process in the jobs.

       <b>-n</b>, <b>--new</b>
           Print new jobs only: jobs whose status has never been reported since the status changed.

       <b>-p</b>, <b>--pgid-only</b>
           Print process group IDs of jobs only.

       <b>-r</b>, <b>--running-only</b>
           Print running jobs only.

       <b>-s</b>, <b>--stopped-only</b>
           Print stopped jobs only.

   <b>Operands</b>
       <u>job</u>s
           The job IDs of jobs to be reported. When no <u>job</u> is specified, all jobs under the shell’s control are
           reported.

           The percent sign (<b>%</b>) at the beginning of a job ID can be omitted if the shell is not in the
           POSIXly-correct mode.

   <b>Exit</b> <b>status</b>
       The exit status of the jobs built-in is zero unless there is any error.

   <b>Notes</b>
       The jobs built-in is a mandatory built-in.

       The POSIX standard defines the <b>-l</b> and <b>-p</b> options only: other options cannot be used in the
       POSIXly-correct mode. In the POSIXly-correct mode, the effect of the <b>-l</b> option is different in that
       status is reported for each job rather than for each process.

       The process group ID of a job executed by yash is equal to the process ID of the first command of the
       pipeline that forms the job.

</pre><h4><b>KILL</b> <b>BUILT-IN</b></h4><pre>
       The <u>kill</u> <u>built-in</u> sends a signal to processes.

   <b>Syntax</b>
       •   <b>kill</b> <b>[-</b><u>signal</u><b>|-s</b> <u>signal</u><b>|-n</b> <u>signal</u><b>]</b> <u>process</u><b>...</b>

       •   <b>kill</b> <b>-l</b> <b>[-v]</b> <b>[</b><u>signal</u><b>...]</b>

       The kill built-in requires that all options precede operands. Any command line arguments after the first
       operand are all treated as operands.

   <b>Description</b>
       When executed without the <b>-l</b> option, the built-in sends a signal to processes. The signal sent can be
       specified by option. The SIGTERM signal is sent if no signal is specified.

       When executed with the <b>-l</b> option, the built-in prints information of <u>signal</u>s to the standard output. If
       no <u>signal</u> is specified, information of all signals is printed.

   <b>Options</b>
       <b>Signal-specifying</b> <b>options</b>

           <b>-</b><u>signal</u>, <b>-s</b> <u>signal</u>, <b>-n</b> <u>signal</u>
               A signal-specifying option specifies a signal to be sent to processes.  <u>signal</u> can be specified
               by name or number. If number <b>0</b> is specified, the built-in checks if a signal could be sent to the
               processes but no signal is actually sent. Signal names are case-insensitive.

           You can specify at most one signal-specifying option at a time.

       <b>Other</b> <b>options</b>

           <b>-l</b>
               Print signal information instead of sending a signal.

           <b>-v</b>
               Print more signal information.

               Without this option, the built-in prints the signal name only. This option adds the signal number
               and a short description.

               When the <b>-v</b> option is specified, the <b>-l</b> option can be omitted.

   <b>Operands</b>
       <u>process</u>es
           Specify processes to which a signal is sent.

           Processes can be specified by the process ID, the process group ID, or the job ID. The process group
           ID must be prefixed with a hyphen (<b>-</b>) so that it is not treated as a process ID.

           When <b>0</b> is specified as <u>process</u>, the signal is sent to the process group to which the shell process
           belongs. When <b>-1</b> is specified, the signal is sent to all processes on the system.

       <u>signal</u>
           Specify a signal of which information is printed.

           The signal can be specified by the name, the number, or the exit status of a command that was killed
           by the signal.

   <b>Exit</b> <b>status</b>
       The exit status of the kill built-in is zero unless there is any error. If the signal was sent to at
       least one process, the exit status is zero even if the signal was not sent to all of the specified
       processes.

   <b>Notes</b>
       The kill built-in is a mandatory built-in.

       Command arguments that start with a hyphen should be used with care. The command <b>kill</b> <b>-1</b> <b>-2</b>, for example,
       sends signal 1 to process group 2 since <b>-1</b> is treated as a signal-specifying option and <b>-2</b> as an operand
       that specifies a process group. The commands <b>kill</b> <b>--</b> <b>-1</b> <b>-2</b> and <b>kill</b> <b>-TERM</b> <b>-1</b> <b>-2</b>, on the other hand,
       treats both <b>-1</b> and <b>-2</b> as operands.

       The POSIX standard does not define the <b>-n</b> or <b>-v</b> options, so they cannot be used in the POSIXly-correct
       mode. The standard does not allow specifying a signal number as the argument of the <b>-s</b> option or a signal
       name as the <u>signal</u> operand.

       The standard requires signal names to be specified without the <b>SIG</b> prefix, like <b>INT</b> and <b>QUIT</b>. If the
       shell is not in the POSIXly-correct mode, the built-in accepts <b>SIG</b>-prefixed signal names as well.

</pre><h4><b>LOCAL</b> <b>BUILT-IN</b></h4><pre>
       The <u>local</u> <u>built-in</u> prints or sets local variables.

   <b>Syntax</b>
       •   <b>local</b> <b>[-rxX]</b> <b>[</b><u>name</u><b>[=</b><u>value</u><b>]...]</b>

   <b>Description</b>
       The local built-in is equivalent to the typeset built-in except that the <b>-f</b> (<b>--functions</b>) and <b>-g</b>
       (<b>--global</b>) options cannot be used.

   <b>Notes</b>
       The local built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>POPD</b> <b>BUILT-IN</b></h4><pre>
       The <u>popd</u> <u>built-in</u> pops a directory from the directory stack.

   <b>Syntax</b>
       •   <b>popd</b> <b>[</b><u>index</u><b>]</b>

   <b>Description</b>
       The popd built-in removes the last entry from the directory stack, returning to the previous working
       directory. If <u>index</u> is given, the entry specified by <u>index</u> is removed instead of the last one.

   <b>Operands</b>
       <u>index</u>
           The index of a directory stack entry you want to remove.

           If omitted, <b>+0</b> (the last entry) is assumed.

   <b>Exit</b> <b>status</b>
       The exit status of the popd built-in is zero unless there is any error.

   <b>Notes</b>
       It is an error to use this built-in when there is only one directory stack entry.

       The popd built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>PRINTF</b> <b>BUILT-IN</b></h4><pre>
       The <u>printf</u> <u>built-in</u> prints formatted values.

   <b>Syntax</b>
       •   <b>printf</b> <u>format</u> <b>[</b><u>value</u><b>...]</b>

   <b>Description</b>
       The printf built-in formats <u>value</u>s according to <u>format</u> and prints them to the standard output. Unlike the
       echo built-in, the printf built-in does not print a newline automatically.

       The formatting process is very similar to that of the printf function in the C programming language. You
       can use conversion specifications (which start with <b>%</b>) and escape sequences (which start with <b>\</b>) in
       <u>format</u>. Any other characters that are not part of a conversion specification or escape sequence are
       printed literally.

       <b>Conversion</b> <b>specifications</b>

           A conversion specification starts with a percent sign (<b>%</b>).

           A conversion specification except <b>%%</b> consumes a <u>value</u>, which is formatted according to the
           specification and printed. Each conversion specification consumes one <u>value</u> in the order of
           appearance. If there are more <u>value</u>s than conversion specifications, the entire <u>format</u> is
           re-processed until all the <u>value</u>s are consumed. If a <u>value</u> to be consumed is missing, it is assumed
           to be an empty string (if the specification requires a string) or zero (if a number). If no <u>value</u>s
           are given, <u>format</u> is processed just once.

           Available conversion specifications are:

           <b>%d</b>, <b>%i</b>
               prints a signed integer in decimal

           <b>%u</b>
               prints an unsigned integer in decimal

           <b>%o</b>
               prints an unsigned integer in octal

           <b>%x</b>
               prints an unsigned integer in lowercase hexadecimal

           <b>%X</b>
               prints an unsigned integer in uppercase hexadecimal

           <b>%f</b>
               prints a floating-point number in lowercase

           <b>%F</b>
               prints a floating-point number in uppercase

           <b>%e</b>
               prints a floating-point number with exponent in lowercase

           <b>%E</b>
               prints a floating-point number with exponent in uppercase

           <b>%g</b>
               the same as <b>%f</b> or <b>%e</b>, automatically selected

           <b>%G</b>
               the same as <b>%F</b> or <b>%E</b>, automatically selected

           <b>%c</b>
               prints the first character of string

           <b>%s</b>
               prints a string

           <b>%b</b>
               prints a string (recognizing escape sequences like the echo built-in)

           <b>%%</b>
               prints a percent sign (<b>%</b>)

           For <b>%g</b> and <b>%G</b>, the specification that is actually used is <b>%f</b> or <b>%F</b> if the exponent part is between -5
           and the precision (exclusive); <b>%e</b> or <b>%E</b> otherwise.

           In a conversion specification except <b>%%</b>, the leading percent sign may be followed by flags, field
           width, and/or precision in this order.

           The flags are a sequence of any number of the following characters:

           Minus sign (<b>-</b>)
               With this flag, spaces are appended to the formatted value to fill up to the field width.
               Otherwise, spaces are prepended.

           Plus sign (<b>+</b>)
               A plus or minus sign is always prepended to a number.

           Space ( )
               A space is prepended to a formatted number if it has no plus or minus sign.

           Hash sign (<b>#</b>)
               The value is formatted in an alternative form: For <b>%o</b>, the printed octal integer has at least one
               leading zero. For <b>%x</b> and <b>%X</b>, a non-zero integer is formatted with <b>0x</b> and <b>0X</b> prefixes,
               respectively. For <b>%e</b>, <b>%E</b>, <b>%f</b>, <b>%F</b>, <b>%g</b>, and <b>%G</b>, a decimal mark (a.k.a. radix character) is always
               printed even if the value is an exact integer. For <b>%g</b> and <b>%G</b>, the printed number has at least one
               digit in the fractional part.

           Zero (<b>0</b>)
               Zeros are prepended to a formatted number to fill up to the field width. This flag is ignored if
               the minus flag is specified or if the conversion specification is <b>%d</b>, <b>%i</b>, <b>%u</b>, <b>%o</b>, <b>%x</b>, or <b>%X</b> with
               a precision.

           A field width is specified as a decimal integer that has no leading zeros.

           A field width defines a minimum byte count of a formatted value. If the formatted value does not
           reach the minimum byte count, so many spaces are prepended that the printed value has the specified
           byte count.

           A precision is specified as a period (<b>.</b>) followed by a decimal integer. If the integer is omitted
           after the period, the precision is assumed to be zero.

           For conversion specifications <b>%d</b>, <b>%i</b>, <b>%u</b>, <b>%o</b>, <b>%x</b>, and <b>%X</b>, a precision defines a minimum digit count.
           If the formatted integer does not reach the minimum digit count, so many zeros are prepended that the
           printed integer has the specified number of digits. The default precision is one for these conversion
           specifications.

           For conversion specifications <b>%e</b>, <b>%E</b>, <b>%f</b>, and <b>%F</b>, a precision defines the number of digits after the
           decimal mark. The default precision is six for these conversion specifications.

           For conversion specifications <b>%g</b>, and <b>%G</b>, a precision defines a maximum number of significant digits
           in the printed value. The default precision is six for these conversion specifications.

           For conversion specifications <b>%s</b>, and <b>%b</b>, a precision defines a maximum byte count of the printed
           string. The default precision is infinity for these conversion specifications.

           In the conversion specification <b>%08.3f</b>, the zero flag is specified, the field width is 8, and the
           precision is 3. If this specification is applied to value 12.34, the output will be <b>0012.340</b>.

       <b>Escape</b> <b>sequences</b>

           The following escape sequences are recognized in <u>format</u>:

           <b>\a</b>
               Bell character (ASCII code: 7)

           <b>\b</b>
               Backspace (ASCII code: 8)

           <b>\f</b>
               Form feed character (ASCII code: 12)

           <b>\n</b>
               Newline character (ASCII code: 10)

           <b>\r</b>
               Carriage return character (ASCII code: 13)

           <b>\t</b>
               Horizontal tab character (ASCII code: 9)

           <b>\v</b>
               Vertical tab character (ASCII code: 11)

           <b>\\</b>
               Backslash

           <b>\"</b>
               Double quotation

           <b>\'</b>
               Single quotation (apostrophe)

           <b>\</b><u>xxx</u>
               Character whose code is <u>xxx</u>, where <u>xxx</u> is an octal number of at most three digits.

   <b>Operands</b>
       <u>format</u>
           A string that defines how <u>value</u>s should be formatted.

       <u>value</u>s
           Values that are formatted according to <u>format</u>.

           A value is either a number or a string.

           When a numeric value is required, <u>value</u> can be a single or double quotation followed by a character,
           instead of a normal number. For example, the command <b>printf</b> <b>'%d'</b> <b>'"3'</b> will print <b>51</b> on a typical
           environment where character <b>3</b> has character code 51.

   <b>Exit</b> <b>status</b>
       The exit status of the printf built-in is zero unless there is any error.

   <b>Notes</b>
       The POSIX standard does not precisely define how multibyte characters should be handled by the built-in.
       When you use the <b>%s</b> conversion specification with precision or the <b>%c</b> conversion specification, you may
       obtain unexpected results if the formatted value contains a character that is represented by more than
       one byte. Yash never prints only part of the bytes that represent a single multibyte character because
       all multibyte characters are converted to wide characters when processed in the shell.

       If the shell is not in the POSIXly-correct mode and the “long double” floating-point arithmetic is
       supported on the running system, then “long double” is used for floating-point conversion specifications.
       Otherwise, “double” is used.

</pre><h4><b>PUSHD</b> <b>BUILT-IN</b></h4><pre>
       The <u>pushd</u> <u>built-in</u> pushes a directory into the directory stack.

   <b>Syntax</b>
       •   <b>pushd</b> <b>[-L|-P]</b> <b>[</b><u>directory</u><b>]</b>

   <b>Description</b>
       The pushd built-in changes the working directory to <u>directory</u> in the same manner as the cd built-in and
       adds it to the directory stack. If the working directory could not be changed successfully, the stack is
       not modified.

   <b>Options</b>
       The pushd built-in accepts the following option as well as the options that can be used for the cd
       built-in:

       <b>--remove-duplicates</b>
           If the new working directory has already been in the directory stack, the existing entry is removed
           from the stack before the new directory is pushed into the stack.

   <b>Operands</b>
       <u>directory</u>
           The pathname of the new working directory.

           If <u>directory</u> is a single hyphen (‘-’), the value of the <b>OLDPWD</b> variable is assumed for the new
           directory pathname, which is printed to the standard output.

           If <u>directory</u> is an integer with a plus or minus sign, it is considered as an entry index of the
           directory stack. The entry is removed from the stack and then pushed to the stack again.

           If <u>directory</u> is omitted, the working directory is changed to the directory specified by the
           <b>--default-directory=...</b>  option. If that option is not specified either, the default is index <b>+1</b>.

   <b>Exit</b> <b>status</b>
       The exit status of the pushd built-in is zero unless there is any error.

   <b>Notes</b>
       The pushd built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>PWD</b> <b>BUILT-IN</b></h4><pre>
       The <u>pwd</u> <u>built-in</u> prints the current working directory.

   <b>Syntax</b>
       •   <b>pwd</b> <b>[-L|-P]</b>

   <b>Description</b>
       The pwd built-in prints an absolute path to the shell’s current working directory to the standard output.

   <b>Options</b>
       <b>-L</b>, <b>--logical</b>
           If the value of the <b>PWD</b> variable is an absolute path to the shell’s working directory and the path
           does not contain any <b>.</b>  or <b>..</b>  components, then the path is printed. Otherwise, the printed path is
           the same as when the <b>-P</b> option is specified.

       <b>-P</b>, <b>--physical</b>
           The printed path does not contain any <b>.</b>  or <b>..</b>  components, symbolic link components, or redundant
           slashes.

       The <b>-L</b> (<b>--logical</b>) and <b>-P</b> (<b>--physical</b>) options are mutually exclusive: only the last specified one is
       effective. If neither is specified, <b>-L</b> is assumed.

   <b>Exit</b> <b>status</b>
       The exit status of the pwd built-in is zero unless there is any error.

   <b>Notes</b>
       The pwd built-in is a mandatory built-in.

</pre><h4><b>READ</b> <b>BUILT-IN</b></h4><pre>
       The <u>read</u> <u>built-in</u> reads a line from the standard input.

   <b>Syntax</b>
       •   <b>read</b> <b>[-Aer]</b> <b>[-P|-p]</b> <u>variable</u><b>...</b>

   <b>Description</b>
       The read built-in reads a line of string from the standard input and assigns it to the specified
       variables.

       If the <b>-r</b> (<b>--raw-mode</b>) option is specified, all characters in the line are treated literally.

       If the <b>-r</b> (<b>--raw-mode</b>) option is not specified, backslashes in the line are treated as quotations. If a
       backslash is at the end of the line, it is treated as a line continuation. When the built-in reads the
       next line, the <b>PS2</b> variable is used as a prompt if the shell is interactive and the standard input is a
       terminal.

       The input line is subject to field splitting. The resulting words are assigned to <u>variable</u>s in order. If
       there are more words than <u>variable</u>s, the last variable is assigned all the remaining words (as if the
       words were not split). If the words are fewer than <u>variable</u>s, the remaining variables are assigned empty
       strings.

   <b>Options</b>
       <b>-A</b>, <b>--array</b>
           Make the last <u>variable</u> an array. Instead of assigning a concatenation of the remaining words to a
           normal variable, the words are assigned to an array.

       <b>-e</b>, <b>--line-editing</b>
           Use line-editing to read the line.

           To use line-editing, all of the following conditions must also be met:

           •   The shell is interactive.

           •   The vi or emacs option is enabled.

           •   The standard input and standard error are connected to a terminal.

       <b>-P</b>, <b>--ps1</b>
           Print the <b>PS1</b> variable as a prompt before reading the (first) line if the shell is interactive and
           the standard input is a terminal.

       <b>-p</b> <u>prompt</u>, <b>--prompt=</b><u>prompt</u>
           Print the specified <u>prompt</u> before reading the (first) line if the shell is interactive and the
           standard input is a terminal.

       <b>-r</b>, <b>--raw-mode</b>
           Don’t treat backslashes as quotations.

   <b>Operands</b>
       <u>variable</u>s
           Names of variables to which input words are assigned.

   <b>Exit</b> <b>status</b>
       The exit status of the read built-in is zero unless there is any error.

       Note that the exit status is non-zero if an end of input is encountered before reading the entire line.

   <b>Notes</b>
       The read built-in is a mandatory built-in.

       The POSIX standard defines the <b>-r</b> option only: other options cannot be used in the POSIXly-correct mode.

       The <b>PS1R</b> and <b>PS1S</b> variables affect the behavior of line-editing if the <b>PS1</b> prompt is used. The same for
       <b>PS2</b>.

</pre><h4><b>READONLY</b> <b>BUILT-IN</b></h4><pre>
       The <u>readonly</u> <u>built-in</u> makes variables and functions read-only.

   <b>Syntax</b>
       •   <b>readonly</b> <b>[-pxX]</b> <b>[</b><u>name</u><b>[=</b><u>value</u><b>]...]</b>

       •   <b>readonly</b> <b>-f[p]</b> <b>[</b><u>name</u><b>...]</b>

   <b>Description</b>
       The readonly built-in is equivalent to the typeset built-in with the <b>-gr</b> option.

   <b>Notes</b>
       The readonly built-in is a special built-in.

       The POSIX standard defines the <b>-p</b> option only; other options cannot be used in the POSIXly-correct mode.
       The POSIX does not allow using the option together with operands.

</pre><h4><b>RETURN</b> <b>BUILT-IN</b></h4><pre>
       The <u>return</u> <u>built-in</u> returns from a function or script.

   <b>Syntax</b>
       •   <b>return</b> <b>[-n]</b> <b>[</b><u>exit_status</u><b>]</b>

   <b>Description</b>
       When executed without the <b>-n</b> (<b>--no-return</b>) option, one of the following happens:

       •   If the shell is executing a function, the execution of the function is terminated.

       •   If the dot built-in is executing a script, the execution of the script is terminated.

       •   If the shell is executing a script during initialization, the execution of the script is terminated.

       •   If the shell is executing a trap, the execution of the trap is terminated for the currently handled
           signal.

       •   Otherwise, the shell exits unless it is interactive.

       When executed with the <b>-n</b> (<b>--no-return</b>) option, the built-in does nothing but return the specified
       <u>exit_status</u>.

   <b>Options</b>
       <b>-n</b>, <b>--no-return</b>
           Do not terminate a function, script, trap, or the shell.

   <b>Operands</b>
       <u>exit_status</u>
           The exit status of the built-in.

           The value must be a non-negative integer.

           If omitted, the exit status of the last executed command is used. (But when the shell is executing a
           trap, the exit status of the last command before the trap is used.)

   <b>Exit</b> <b>status</b>
       The exit status of the return built-in is defined by the <u>exit_status</u> operand. The exit status is used
       also as the exit status of the terminated function, script, or the shell.

   <b>Notes</b>
       The return built-in is a special built-in.

       The POSIX standard provides that the <u>exit_status</u> operand should be between 0 and 255 (inclusive). Yash
       accepts integers larger than 255 as an extension.

       In the POSIX standard, the behavior of the return built-in is defined only when the shell is executing a
       function or script.

       The POSIX standard defines no options for the return built-in; the built-in accepts no options in the
       POSIXly-correct mode.

</pre><h4><b>SET</b> <b>BUILT-IN</b></h4><pre>
       The <u>set</u> <u>built-in</u> sets shell options and positional parameters.

   <b>Syntax</b>
       •   <b>set</b> <b>[</b><u>option</u><b>s]</b> <b>[</b><u>operand</u><b>s]</b>

       •   <b>set</b> <b>-o</b>

       •   <b>set</b> <b>+o</b>

       The set built-in requires that all options precede operands. Any command line arguments after the first
       operand are all treated as operands.

   <b>Description</b>
       When executed without any command arguments, the built-in prints a list of all existing variables to the
       standard input in a form that can be reused as commands that will restore the variable definitions.

       When <b>-o</b> is the only command argument, the built-in prints a list of shell options with their current
       settings. When <b>+o</b> is the only command argument, the built-in prints commands that can be reused to
       restore the current shell option settings.

       In other cases, the built-in changes shell option settings and/or positional parameters.

   <b>Options</b>
       When one or more options are specified, the built-in enables or disables the shell options. A normal
       hyphen-prefixed option enables a shell option. An option that is prefixed with a plus (<b>+</b>) instead of a
       hyphen disables a shell option. For example, options <b>-m</b>, <b>-o</b> <b>monitor</b>, and <b>--monitor</b> enable the monitor
       option and options <b>+m</b>, <b>+o</b> <b>monitor</b>, <b>++monitor</b> disable it.

       The name of a long option is case-insensitive and may include irrelevant non-alphanumeric characters,
       which are ignored. For example, options <b>--le-comp-debug</b> and <b>--LeCompDebug</b> are equivalent. If <b>no</b> is
       prepended to the name of a long option, the meaning is reversed. For example, <b>--noallexport</b> is equivalent
       to <b>++allexport</b> and <b>++nonotify</b> to <b>--notify</b>.

       An option can be specified in one of the following forms:

       •   a long option e.g.  <b>--allexport</b>

       •   an <b>-o</b> option with a option name specified as the argument e.g.  <b>-o</b> <b>allexport</b>

       •   a single-character option e.g.  <b>-a</b>

       Not all options can be specified as single-character options.

       The available options are:

       all-export (<b>-a</b>)
           When enabled, all variables are automatically exported when assigned.

       brace-expand
           This option enables brace expansion.

       case-glob
           (Enabled by default) When enabled, pattern matching is case-sensitive in pathname expansion.

       clobber (<b>+C</b>)
           (Enabled by default) When enabled, the <b>&gt;</b> redirection behaves the same as the <b>&gt;|</b> redirection.

       cur-async, cur-bg, cur-stop
           (Enabled by default) These options affect choice of the current job (cf.  job ID).

       dot-glob
           When enabled, periods at the beginning of filenames are not treated specially in pathname expansion.

       emacs
           This option enables line-editing in the emacs mode.

       empty-last-field
           When enabled, field splitting does not remove the last field even if it is empty.

       err-exit (<b>-e</b>)
           When enabled, if a pipeline ends with a non-zero exit status, the shell immediately exits unless the
           following suppress condition is met:

           •   the pipeline is a condition of an if command or while or until loop;

           •   the pipeline is prefixed by <b>!</b>; or

           •   the pipeline is a single compound command other than a subshell grouping.

       err-return
           This option is like the err-exit option, but the return built-in is executed instead of the shell
           exiting on a non-zero exit status. Unlike err-exit, the suppress condition does not apply inside a
           function, subshell grouping, or script file.

       exec (<b>+n</b>)
           (Enabled by default) Commands are actually executed only when this option is enabled. Otherwise,
           commands are just parsed and not executed. Disabling this option may be useful for syntax checking.
           In an interactive shell, this option is always assumed enabled.

       extended-glob
           This option enables extension in pathname expansion.

       for-local
           (Enabled by default) If a for loop is executed within a function, this option causes the iteration
           variable to be created as a local variable, even if the variable already exists globally. This option
           has no effect if the POSIXly-correct mode is active.

       glob (<b>+f</b>)
           (Enabled by default) This option enables pathname expansion.

       hash-on-def (<b>-h</b>)
           When a function is defined when this option is enabled, the shell immediately performs command path
           search for each command that appears in the function and caches the command’s full path.

       hist-space
           When enabled, command lines that start with a whitespace are not saved in command history.

       ignore-eof
           When enabled, an interactive shell does not exit when EOF (end of file) is input. This prevents the
           shell from exiting when you accidentally hit Ctrl-D.

       le-always-rp, le-comp-debug, le-conv-meta, le-no-conv-meta, le-predict, le-predict-empty, le-prompt-sp,
       le-visible-bell, le-trim-right
           See shell options on line-editing.

       mark-dirs
           When enabled, resulting directory names are suffixed by a slash in pathname expansion.

       monitor (<b>-m</b>)
           This option enables job control. This option is enabled by default for an interactive shell.

       notify (<b>-b</b>)
           When the status of a job changes when this option is enabled, the shell immediately notifies at any
           time. This option overrides the notify-le option.

       notify-le
           This option is similar to the notify option, but the status change is notified only while the shell
           is waiting for input with line-editing.

       null-glob
           When enabled, in pathname expansion, patterns that do not match any pathname are removed from the
           command line rather than left as is.

       pipe-fail
           When enabled, the exit status of a pipeline is zero if and only if all the subcommands of the
           pipeline exit with an exit status of zero.

       posixly-correct
           This option enables the POSIXly-correct mode.

       trace-all
           (Enabled by default) When this option is disabled, the x-trace option is temporarily disabled while
           the shell is executing commands defined in the <b>COMMAND_NOT_FOUND_HANDLER</b>, <b>PROMPT_COMMAND</b>, or
           <b>YASH_AFTER_CD</b> variable.

       unset (<b>+u</b>)
           (Enabled by default) When enabled, an undefined parameter is expanded to an empty string in parameter
           expansion and treated as zero in arithmetic expansion. When disabled, expansion of an undefined
           parameter results in an error.

       verbose (<b>-v</b>)
           When enabled, the shell prints each command line to the standard error before parsing and executing
           it.

       vi
           This option enables line-editing in the vi mode. This option is enabled by default in an interactive
           shell if the standard input and error are both terminals.

       x-trace (<b>-x</b>)
           When enabled, the results of expansion are printed to the standard error for each simple command
           being executed. When printed, each line is prepended with an expansion result of the <b>PS4</b> variable.
           See also the trace-all option.

   <b>Operands</b>
       If one or more operands are passed to the set built-in, current positional parameters are all removed and
       the operands are set as new positional parameters. If the <b>--</b> separator (cf. syntax of command arguments)
       is passed, the positional parameters are set even when there are no operands, in which case new
       positional parameters will be nothing.

   <b>Exit</b> <b>status</b>
       The exit status of the set built-in is zero unless there is any error.

   <b>Notes</b>
       The set built-in is a special built-in.

       In the POSIX standard, available shell options are much limited. The standard does not define:

       •   long options such as <b>--allexport</b>,

       •   prepending <b>no</b> to negate an option,

       •   using uppercase letters and/or non-alphanumeric characters in option names

       The options defined in the standard are:

       •   <b>-a</b>, <b>-o</b> <b>allexport</b>

       •   <b>-e</b>, <b>-o</b> <b>errexit</b>

       •   <b>-m</b>, <b>-o</b> <b>monitor</b>

       •   <b>-C</b>, <b>-o</b> <b>noclobber</b>

       •   <b>-n</b>, <b>-o</b> <b>noexec</b>

       •   <b>-f</b>, <b>-o</b> <b>noglob</b>

       •   <b>-b</b>, <b>-o</b> <b>notify</b>

       •   <b>-u</b>, <b>-o</b> <b>nounset</b>

       •   <b>-v</b>, <b>-o</b> <b>verbose</b>

       •   <b>-x</b>, <b>-o</b> <b>xtrace</b>

       •   <b>-h</b>

       •   <b>-o</b> <b>ignoreeof</b>

       •   <b>-o</b> <b>nolog</b>

       •   <b>-o</b> <b>vi</b>

       Yash does not support the nolog option, which prevents function definitions from being added to command
       history.

</pre><h4><b>SHIFT</b> <b>BUILT-IN</b></h4><pre>
       The <u>shift</u> <u>built-in</u> removes some positional parameters or array values.

   <b>Syntax</b>
       •   <b>shift</b> <b>[-A</b> <u>array</u><b>]</b> <b>[</b><u>count</u><b>]</b>

   <b>Description</b>
       The shift built-in removes the first <u>count</u> positional parameters or array values, where <u>count</u> is
       specified by the operand.

   <b>Options</b>
       <b>-A</b> <u>array</u>, <b>--array=</b><u>array</u>
           Remove first <u>count</u> values of <u>array</u> instead of positional parameters.

   <b>Operands</b>
       <u>count</u>
           The number of positional parameters or array values to be removed.

           It is an error if the actual number of positional parameters or array values is less than <u>count</u>. If
           omitted, the default value is one. If negative, the last -<u>count</u> positional parameters or array values
           are removed instead of the first ones.

   <b>Exit</b> <b>status</b>
       The exit status of the shift built-in is zero unless there is any error.

   <b>Notes</b>
       The shift built-in is a special built-in.

       The number of positional parameters can be obtained with the <b>#</b> special parameter. The number of array
       values can be obtained with <b>${</b><u>array</u><b>[#]}</b>.

       The POSIX standard defines no options for the shift built-in; the built-in accepts no options in the
       POSIXly-correct mode.

       Negative operands are not allowed in the POSIXly-correct mode.

</pre><h4><b>SUSPEND</b> <b>BUILT-IN</b></h4><pre>
       The <u>suspend</u> <u>built-in</u> suspends the shell.

   <b>Syntax</b>
       •   <b>suspend</b> <b>[-f]</b>

   <b>Description</b>
       The suspend built-in sends a SIGSTOP signal to all processes in the process group to which the shell
       process belongs. The signal suspends the processes (including the shell). The suspended processes resume
       when they receive a SIGCONT signal.

       If the shell is interactive and its process group ID is equal to the process ID of the session leader,
       the shell prints a warning message and refuses to send a signal unless the <b>-f</b> (<b>--force</b>) option is
       specified. (In such a case, there is no other job-controlling shell that can send a SIGCONT signal to
       resume the suspended shell, so the shell could never be resumed.)

   <b>Options</b>
       <b>-f</b>, <b>--force</b>
           Suppress warnings that would prevent the shell from sending a signal.

   <b>Exit</b> <b>status</b>
       The exit status is zero if the signal was successfully sent and non-zero otherwise.

   <b>Notes</b>
       The suspend built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

</pre><h4><b>TEST</b> <b>BUILT-IN</b></h4><pre>
       The <u>test</u> <u>built-in</u> evaluates an expression.

   <b>Syntax</b>
       •   <b>test</b> <u>expression</u>

       •   <b>[</b> <u>expression</u> <b>]</b>

       The test built-in does not distinguish options and operands; all command line arguments are interpreted
       as <u>expression</u>. If the built-in is executed with the name <b>[</b>, <u>expression</u> must be followed by <b>]</b>.

   <b>Description</b>
       The test built-in evaluates <u>expression</u> as a conditional expression that is made up of operators and
       operands described below. The exit status is 0 if the condition is true and 1 otherwise.

       The unary operators below test a file. If the operand <u>file</u> is a symbolic link, the file referred to by
       the link is tested (except for the <b>-h</b> and <b>-L</b> operators).

       <b>-b</b> <u>file</u>
           <u>file</u> is a block special file

       <b>-c</b> <u>file</u>
           <u>file</u> is a character special file

       <b>-d</b> <u>file</u>
           <u>file</u> is a directory

       <b>-e</b> <u>file</u>
           <u>file</u> exists

       <b>-f</b> <u>file</u>
           <u>file</u> is a regular file

       <b>-G</b> <u>file</u>
           <u>file</u>'s group ID is same as the shell’s effective group ID

       <b>-g</b> <u>file</u>
           <u>file</u>'s set-group-ID flag is set

       <b>-h</b> <u>file</u>
           same as -L

       <b>-k</b> <u>file</u>
           <u>file</u>'s sticky bit is set

       <b>-L</b> <u>file</u>
           <u>file</u> is a symbolic link

       <b>-N</b> <u>file</u>
           <u>file</u> has not been accessed since last modified

       <b>-O</b> <u>file</u>
           <u>file</u>'s user ID is same as the shell’s effective user ID

       <b>-p</b> <u>file</u>
           <u>file</u> is a FIFO (named pipe)

       <b>-r</b> <u>file</u>
           <u>file</u> is readable

       <b>-S</b> <u>file</u>
           <u>file</u> is a socket

       <b>-s</b> <u>file</u>
           <u>file</u> is not empty

       <b>-u</b> <u>file</u>
           <u>file</u>'s set-user-ID flag is set

       <b>-w</b> <u>file</u>
           <u>file</u> is writable

       <b>-x</b> <u>file</u>
           <u>file</u> is executable

       The unary operator below tests a file descriptor:

       <b>-t</b> <u>fd</u>
           <u>fd</u> is associated with a terminal

       The unary operators below test a string:

       <b>-n</b> <u>string</u>
           <u>string</u> is not empty

       <b>-z</b> <u>string</u>
           <u>string</u> is empty

       The unary operator below tests a shell option:

       <b>-o</b> <b>?</b><u>option</u>
           <u>option</u> is a valid shell option name

       <b>-o</b> <u>option</u>
           <u>option</u> is a valid shell option name that is enabled

       The binary operators below compare files. Non-existing files are considered older than any existing
       files.

       <u>file1</u> <b>-nt</b> <u>file2</u>
           <u>file1</u> is newer than <u>file2</u>

       <u>file1</u> <b>-ot</b> <u>file2</u>
           <u>file1</u> is older than <u>file2</u>

       <u>file1</u> <b>-ef</b> <u>file2</u>
           <u>file1</u> is a hard link to <u>file2</u>

       The binary operators below compare strings:

       <u>string1</u> <b>=</b> <u>string2</u>, <u>string1</u> <b>==</b> <u>string2</u>
           <u>string1</u> is the same string as <u>string2</u>

       <u>string1</u> <b>!=</b> <u>string2</u>
           <u>string1</u> is not the same string as <u>string2</u>

       The binary operators below compare strings according to the alphabetic order in the current locale:

       <u>string1</u> <b>===</b> <u>string2</u>
           <u>string1</u> is equal to <u>string2</u>

       <u>string1</u> <b>!==</b> <u>string2</u>
           <u>string1</u> is not equal to <u>string2</u>

       <u>string1</u> <b>&lt;</b> <u>string2</u>
           <u>string1</u> is less than <u>string2</u>

       <u>string1</u> <b>&lt;=</b> <u>string2</u>
           <u>string1</u> is less than or equal to <u>string2</u>

       <u>string1</u> <b>&gt;</b> <u>string2</u>
           <u>string1</u> is greater than <u>string2</u>

       <u>string1</u> <b>&gt;=</b> <u>string2</u>
           <u>string1</u> is greater than or equal to <u>string2</u>

       The binary operator below performs pattern matching:

       <u>string</u> <b>=~</b> <u>pattern</u>
           extended regular expression <u>pattern</u> matches (part of) <u>string</u>

       The binary operators below compare integers:

       <u>v1</u> <b>-eq</b> <u>v2</u>
           <u>v1</u> is equal to <u>v2</u>

       <u>v1</u> <b>-ne</b> <u>v2</u>
           <u>v1</u> is not equal to <u>v2</u>

       <u>v1</u> <b>-gt</b> <u>v2</u>
           <u>v1</u> is greater than <u>v2</u>

       <u>v1</u> <b>-ge</b> <u>v2</u>
           <u>v1</u> is greater than or equal to <u>v2</u>

       <u>v1</u> <b>-lt</b> <u>v2</u>
           <u>v1</u> is less than <u>v2</u>

       <u>v1</u> <b>-le</b> <u>v2</u>
           <u>v1</u> is less than or equal to <u>v2</u>

       The binary operators below compare version numbers:

       <u>v1</u> <b>-veq</b> <u>v2</u>
           <u>v1</u> is equal to <u>v2</u>

       <u>v1</u> <b>-vne</b> <u>v2</u>
           <u>v1</u> is not equal to <u>v2</u>

       <u>v1</u> <b>-vgt</b> <u>v2</u>
           <u>v1</u> is greater than <u>v2</u>

       <u>v1</u> <b>-vge</b> <u>v2</u>
           <u>v1</u> is greater than or equal to <u>v2</u>

       <u>v1</u> <b>-vlt</b> <u>v2</u>
           <u>v1</u> is less than <u>v2</u>

       <u>v1</u> <b>-vle</b> <u>v2</u>
           <u>v1</u> is less than or equal to <u>v2</u>

       The operators below can be used to make complex expressions:

       <b>!</b> <u>expression</u>
           negate (reverse) the result

       <b>(</b> <u>expression</u> <b>)</b>
           change operator precedence

       <u>expression1</u> <b>-a</b> <u>expression2</u>
           logical conjunction (and)

       <u>expression1</u> <b>-o</b> <u>expression2</u>
           logical disjunction (or)

       If the expression is a single word without operators, the <b>-n</b> operator is assumed. An empty expression
       evaluates to false.

       <b>Comparison</b> <b>of</b> <b>version</b> <b>numbers</b>

           Comparison of version numbers is similar to comparison of strings in alphabetic order. The
           differences are:

           •   Adjacent digits are treated as an integer. Integers are compared in mathematical order rather
               than alphabetic order.

           •   Digits are considered larger than any non-digit characters.

           For example, version numbers <b>0.1.2-3</b> and <b>00.001.02-3</b> are equal and <b>0.2.1</b> is smaller than <b>0.10.0</b>.

   <b>Exit</b> <b>status</b>
       The exit status of the test built-in is 0 if <u>expression</u> is true and 1 otherwise. The exit status is 2 if
       <u>expression</u> cannot be evaluated because of a syntax error or any other reasons.

   <b>Notes</b>
       Complex expressions may cause confusion and should be avoided. Use the shell’s compound commands. For
       example, <b>[</b> <b>1</b> <b>-eq</b> <b>1</b> <b>]</b> <b>&amp;&amp;</b> <b>[</b> <b>-t</b> <b>=</b> <b>1</b> <b>]</b> <b>&amp;&amp;</b> <b>!</b> <b>[</b> <b>foo</b> <b>]</b> is preferred over <b>[</b> <b>1</b> <b>-eq</b> <b>1</b> <b>-a</b> <b>-t</b> <b>=</b> <b>1</b> <b>-a</b> <b>!</b> <b>foo</b> <b>]</b>.

       The POSIX standard provides that the exit status should be larger than 1 on error. The POSIX standard
       does not define the following operators: <b>-G</b>, <b>-k</b>, <b>-N</b>, <b>-O</b>, <b>-nt</b>, <b>-ot</b>, <b>-ef</b>, <b>==</b>, <b>===</b>, <b>!==</b>, <b>&lt;</b>, <b>&lt;=</b>, <b>&gt;</b>, <b>&gt;=</b>, <b>=~</b>,
       <b>-veq</b>, <b>-vne</b>, <b>-vgt</b>, <b>-vge</b>, <b>-vlt</b>, and <b>-vle</b>. POSIX neither specifies <b>-o</b> as a unary operator.

</pre><h4><b>TIMES</b> <b>BUILT-IN</b></h4><pre>
       The <u>times</u> <u>built-in</u> prints CPU time usage.

   <b>Syntax</b>
       •   <b>times</b>

   <b>Description</b>
       The times built-in prints the CPU times consumed by the shell process and its child processes to the
       standard output.

       The built-in prints two lines: the first line shows the CPU time of the shell process and the second one
       that of its child processes (not including those which have not terminated). Each line shows the CPU
       times consumed in the user and system mode.

   <b>Exit</b> <b>status</b>
       The exit status of the times built-in is zero unless there is any error.

   <b>Notes</b>
       The times built-in is a special built-in.

</pre><h4><b>TRAP</b> <b>BUILT-IN</b></h4><pre>
       The <u>trap</u> <u>built-in</u> sets or prints signal handlers.

   <b>Syntax</b>
       •   <b>trap</b>

       •   <b>trap</b> <u>action</u> <u>signal</u><b>...</b>

       •   <b>trap</b> <u>signal_number</u> <b>[</b><u>signal</u><b>...]</b>

       •   <b>trap</b> <b>-p</b> <b>[</b><u>signal</u><b>...]</b>

   <b>Description</b>
       The trap built-in sets or prints actions that are taken when the shell receives signals. (Those actions
       are called <u>traps</u>.)

       When executed with <u>action</u> and one or more <u>signal</u>s, the built-in sets the traps for <u>signal</u>s to <u>action</u>. If
       the shell receives one of the signals, the action will be taken.

       If the first operand is <u>signal_number</u> instead of <u>action</u>, the built-in resets the traps for <u>signal_number</u>
       and <u>signal</u>s as if <u>action</u> was <b>-</b>.

       When executed with the <b>-p</b> (<b>--print</b>) option or with no operands, the built-in prints currently set traps
       to the standard output in a format that can be executed as commands that restore the current traps. If
       one or more <u>signal</u>s are specified, only those signals are printed. Otherwise, all signals with
       non-default actions are printed. (In some situations, however, the built-in may print previous trap
       settings instead of the current. See notes below.)

   <b>Options</b>
       <b>-p</b>, <b>--print</b>
           Print current trap settings.

   <b>Operands</b>
       <u>action</u>
           An action that will be taken when <u>signal</u> is received.

           If <u>action</u> is a single hyphen (<b>-</b>), the action is reset to the default action that is defined by the
           operating system. If <u>action</u> is an empty string, the signal is ignored on receipt. Otherwise, <u>action</u>
           is treated as a command string: the string is parsed and executed as commands when the signal is
           received. (If a signal is received while a command is being executed, the action is taken just after
           the command finishes.)

       <u>signal</u>
           The number or name of a signal.

           If <u>signal</u> is number <b>0</b> or name <b>EXIT</b>, it is treated as a special imaginary signal that is always
           received when the shell exits. The action set for this signal is taken when the shell exits normally.

       <u>signal_number</u>
           This is like <u>signal</u>, but must be a number.

   <b>Exit</b> <b>status</b>
       The exit status of the trap built-in is zero unless there is any error.

   <b>Notes</b>
       The trap built-in is a special built-in.

       The POSIX standard defines no options for the trap built-in; the built-in accepts no options in the
       POSIXly-correct mode.

       The POSIX standard requires that signal names must be specified without the <b>SIG</b>-prefix, like <b>INT</b> and
       <b>QUIT</b>. As an extension, yash accepts <b>SIG</b>-prefixed names like <b>SIGINT</b> and <b>SIGQUIT</b> and treats signal names
       case-insensitively.

       <b>Reusing</b> <b>output</b> <b>of</b> <b>the</b> <b>built-in</b>

           Output of the trap built-in can be saved in a variable, which can be later executed by the eval
           built-in to restore the traps.

               saved_traps=$(trap)
               trap '...' INT
               eval "$saved_traps"

           There are some tricks behind the scenes to allow this idiom. You use a command substitution to save
           the output of the trap built-in in the variable. The command substitution is executed in a subshell.
           The subshell resets all traps (except ignored ones) at the beginning of itself. This seemingly would
           result in (almost) empty output from the built-in that would fail to restore the traps as expected.

           To avoid that pitfall, POSIX requires the shell to follow one of the two options below:

           •   If a command substitution just contains a single trap built-in, traps should not be reset when
               the subshell is started to execute the built-in; or

           •   A subshell always resets the traps but remembers the previous traps. If the trap built-in is
               executed in the subshell but no other trap built-in has been executed to modify traps in the
               subshell, then the built-in should print the remembered traps.

           Yash obeys the second.

</pre><h4><b>TRUE</b> <b>BUILT-IN</b></h4><pre>
       The <u>true</u> <u>built-in</u> does nothing successfully.

   <b>Syntax</b>
       •   <b>true</b>

   <b>Description</b>
       The true built-in does nothing. Any command line arguments are ignored.

   <b>Exit</b> <b>status</b>
       The exit status of the true built-in is zero.

   <b>Notes</b>
       The true built-in is a mandatory built-in.

       The true and colon built-ins have the same effect, but true is a mandatory built-in while colon is a
       special.

</pre><h4><b>TYPE</b> <b>BUILT-IN</b></h4><pre>
       The <u>type</u> <u>built-in</u> identifies a command.

   <b>Syntax</b>
       •   <b>type</b> <b>[-abefkp]</b> <b>[</b><u>command</u><b>...]</b>

   <b>Description</b>
       The type built-in is equivalent to the command built-in with the <b>-V</b> option.

   <b>Notes</b>
       The POSIX standard does not define the relation between the type and command built-ins. The standard does
       not define options for the type built-in.

       At least one <u>command</u> operand must be specified in the POSIXly-correct mode.

       The type built-in is a mandatory built-in.

</pre><h4><b>TYPESET</b> <b>BUILT-IN</b></h4><pre>
       The <u>typeset</u> <u>built-in</u> prints or sets variables or functions.

   <b>Syntax</b>
       •   <b>typeset</b> <b>[-gprxX]</b> <b>[</b><u>variable</u><b>[=</b><u>value</u><b>]...]</b>

       •   <b>typeset</b> <b>-f[pr]</b> <b>[</b><u>function</u><b>...]</b>

   <b>Description</b>
       If executed without the <b>-f</b> (<b>--functions</b>) option, the typeset built-in prints or sets variables to the
       standard output. Otherwise, it prints or sets functions.

       If executed with the <b>-p</b> (<b>--print</b>) option, the built-in prints the variables or functions specified by
       operands. Without the option, it sets variables or functions. If no operands are specified, it prints all
       existing variables or functions, regardless of whether the <b>-p</b> (<b>--print</b>) option is specified.

   <b>Options</b>
       <b>-f</b>, <b>--functions</b>
           Print or set functions rather than variables.

       <b>-g</b>, <b>--global</b>
           When setting a new variable, the variable will be a global variable if this option is specified.
           Without this option, the variable would be a local variable.

           When printing variables, all existing variables including global variables are printed if this option
           is specified. Without this option, only local variables are printed.

       <b>-p</b>, <b>--print</b>
           Print variables or functions in a form that can be parsed and executed as commands that will restore
           the currently set variables or functions.

       <b>-r</b>, <b>--readonly</b>
           When setting variables or functions, make them read-only.

           When printing variables or functions, print read-only variables or functions only.

       <b>-x</b>, <b>--export</b>
           When setting variables, mark them for export, so that they will be exported to external commands.

           When printing variables, print exported variables only.

       <b>-X</b>, <b>--unexport</b>
           When setting variables, cancel exportation of the variables.

   <b>Operands</b>
       <u>variable</u> (without <u>value</u>)
           The name of a variable that is to be set or printed.

           Without the <b>-p</b> (<b>--print</b>) option, the variable is defined (if not yet defined) but its value is not
           set nor changed. Variables that are defined without values are treated as unset in parameter
           expansion.

       <u>variable</u>=<u>value</u>
           The name of a variable and its new value.

           The value is assigned to the variable (regardless of the <b>-p</b> (<b>--print</b>) option).

       <u>function</u>
           The name of an existing function that is to be set or printed.

   <b>Exit</b> <b>status</b>
       The exit status of the typeset built-in is zero unless there is any error.

   <b>Notes</b>
       A global variable cannot be newly defined if a local variable has already been defined with the same
       name. The local variable will be set regardless of the <b>-g</b> (<b>--global</b>) option.

       The typeset built-in is an elective built-in. It cannot be used in the POSIXly-correct mode because POSIX
       does not define its behavior.

       The export and readonly built-ins are equivalent to the typeset built-in with the <b>-gx</b> and <b>-gr</b> options,
       respectively. The local built-in is equivalent to the typeset built-in except that the <b>-f</b> (<b>--functions</b>)
       and <b>-g</b> (<b>--global</b>) options cannot be used.

</pre><h4><b>ULIMIT</b> <b>BUILT-IN</b></h4><pre>
       The <u>ulimit</u> <u>built-in</u> sets or prints a resource limit.

   <b>Syntax</b>
       •   <b>ulimit</b> <b>-a</b> <b>[-H|-S]</b>

       •   <b>ulimit</b> <b>[-H|-S]</b> <b>[-efilnqrstuvx]</b> <b>[</b><u>limit</u><b>]</b>

   <b>Description</b>
       The ulimit built-in sets or prints a resource limit.

       If executed with the <b>-a</b> (<b>--all</b>) option, the built-in prints the current limits for all resource types.
       Otherwise, it sets or prints the limit of a single resource type. The resource type can be specified by
       the options listed below. The resource limits will affect the current shell process and all commands
       invoked from the shell.

       Each resource type has two limit values: the hard and soft limit. You can change a soft limit freely as
       long as it does not exceed the hard limit. You can decrease a hard limit but cannot increase it without a
       proper permission.

       When the <b>-H</b> (<b>--hard</b>) or <b>-S</b> (<b>--soft</b>) option is specified, the built-in sets or prints the hard or soft
       limit, respectively. If neither of the options is specified, the built-in sets both the hard and soft
       limit or prints the soft limit.

   <b>Options</b>
       <b>-H</b>, <b>--hard</b>
           Set or print a hard limit.

       <b>-S</b>, <b>--soft</b>
           Set or print a soft limit.

       <b>-a</b>, <b>--all</b>
           Print all current limit settings.

       The following options specify the type of resources. If none of them is specified, <b>-f</b> is the default. The
       types of resources that can be set depend on the operating system.

       <b>-c</b>, <b>--core</b>
           Maximum size of core files created (in 512-byte blocks)

       <b>-d</b>, <b>--data</b>
           Maximum size of a process’s data segment (in kilobytes)

       <b>-e</b>, <b>--nice</b>
           Maximum scheduling priority (‘nice’)

       <b>-f</b>, <b>--fsize</b>
           Maximum size of files created by a process (in 512-byte blocks)

       <b>-i</b>, <b>--sigpending</b>
           Maximum number of pending signals

       <b>-l</b>, <b>--memlock</b>
           Maximum memory size that can be locked into RAM (in kilobytes)

       <b>-m</b>, <b>--rss</b>
           Maximum size of a process’s resident set (in kilobytes)

       <b>-n</b>, <b>--nofile</b>
           Maximum file descriptor + 1

       <b>-q</b>, <b>--msgqueue</b>
           Maximum size of POSIX message queues

       <b>-r</b>, <b>--rtprio</b>
           Maximum real-time scheduling priority

       <b>-s</b>, <b>--stack</b>
           Maximum size of a process’s stack (in kilobytes)

       <b>-t</b>, <b>--cpu</b>
           Maximum CPU time that can be used by a process (in seconds)

       <b>-u</b>, <b>--nproc</b>
           Maximum number of processes for a user

       <b>-v</b>, <b>--as</b>
           Maximum size of memory used by a process (in kilobytes)

       <b>-x</b>, <b>--locks</b>
           Maximum number of file locks

   <b>Operands</b>
       <u>limit</u>
           A limit to be set.

           The value must be a non-negative integer or one of <b>hard</b>, <b>soft</b>, and <b>unlimited</b>. If <u>value</u> is <b>hard</b> or
           <b>soft</b>, the new limit is set to the current hard or soft limit. If <u>limit</u> is not specified, the current
           limit is printed.

   <b>Exit</b> <b>status</b>
       The exit status of the ulimit built-in is zero unless there is any error.

   <b>Notes</b>
       The POSIX standard defines no options other than <b>-f</b>. It neither defines <b>hard</b>, <b>soft</b>, or <b>unlimited</b> for
       <u>limit</u> values.

       The ulimit built-in is a mandatory built-in.

</pre><h4><b>UMASK</b> <b>BUILT-IN</b></h4><pre>
       The <u>umask</u> <u>built-in</u> sets or prints the file mode creation mask.

   <b>Syntax</b>
       •   <b>umask</b> <u>mask</u>

       •   <b>umask</b> <b>[-S]</b>

   <b>Description</b>
       If executed without the <u>mask</u> operand, the built-in prints the current file mode creation mask of the
       shell to the standard output in a form that can later be used as <u>mask</u> to restore the current mask.

       Otherwise, the built-in sets the file mode creation mask to <u>mask</u>.

   <b>Options</b>
       <b>-S</b>, <b>--symbolic</b>
           Print in the symbolic form instead of the octal integer form.

   <b>Operands</b>
       <u>mask</u>
           The new file mode creation mask either in the symbolic or octal integer form.

       <b>Octal</b> <b>integer</b> <b>form</b>

           In the octal integer form, the mask is specified as a non-negative octal integer that is the sum of
           the following permissions:

           0400
               read by owner

           0200
               write by owner

           0100
               execute/search by owner

           0040
               read by group

           0020
               write by group

           0010
               execute/search by group

           0004
               read by others

           0002
               write by others

           0001
               execute/search by others

       <b>Symbolic</b> <b>form</b>

           In the symbolic form, the mask is specified as a symbolic expression that denotes permissions that
           are <b>not</b> included in the mask.

           The entire expression is one or more <u>clause</u>s separated by comma. A <u>clause</u> is a sequence of <u>who</u>s
           followed by one or more <u>action</u>s.

           A <u>who</u> is one of:

           <b>u</b>
               owner

           <b>g</b>
               group

           <b>o</b>
               others

           <b>a</b>
               all of owner, group, and others

           An empty sequence of <u>who</u>s is equivalent to who <b>a</b>.

           An <u>action</u> is an <u>operator</u> followed by <u>permission</u>. An <u>operator</u> is one of:

           <b>=</b>
               set <u>who</u>'s permission to <u>permission</u>

           <b>+</b>
               add <u>permission</u> to <u>who</u>'s permission

           <b>-</b>
               remove <u>permission</u> from <u>who</u>'s permission

           and <u>permission</u> is one of:

           <b>r</b>
               read

           <b>w</b>
               write

           <b>x</b>
               execute/search

           <b>X</b>
               execute/search (only if some user already has execute/search permission)

           <b>s</b>
               set-user-ID and set-group-ID

           <b>u</b>
               user’s current permissions

           <b>g</b>
               group’s current permissions

           <b>o</b>
               others' current permissions

           but more than one of <b>r</b>, <b>w</b>, <b>x</b>, <b>X</b>, and <b>s</b> can be specified after a single <u>operand</u>.

           For example, the command <b>umask</b> <b>u=rwx,go+r-w</b>

           •   unmasks the user’s read, write, and execute/search permissions;

           •   unmasks the group’s and others' read permission; and

           •   masks the group’s and others' write permission.

   <b>Exit</b> <b>status</b>
       The exit status of the umask built-in is zero unless there is any error.

   <b>Notes</b>
       The umask built-in is a mandatory built-in.

       The POSIX standard does not require the default output format (used when the <b>-S</b> option is not specified)
       to be the octal integer form.

</pre><h4><b>UNALIAS</b> <b>BUILT-IN</b></h4><pre>
       The <u>unalias</u> <u>built-in</u> undefines aliases.

   <b>Syntax</b>
       •   <b>unalias</b> <u>name</u><b>...</b>

       •   <b>unalias</b> <b>-a</b>

   <b>Description</b>
       The unalias built-in removes the definition of the aliases specified by operands.

   <b>Options</b>
       <b>-a</b>, <b>--all</b>
           Undefine all aliases.

   <b>Operands</b>
       <u>name</u>
           The name of an alias to be undefined.

   <b>Exit</b> <b>status</b>
       The exit status of the unalias built-in is zero unless there is any error. It is an error to specify the
       name of a non-existing alias as <u>name</u>.

   <b>Notes</b>
       The unalias built-in is a mandatory built-in.

</pre><h4><b>UNSET</b> <b>BUILT-IN</b></h4><pre>
       The <u>unset</u> <u>built-in</u> undefines variables or functions.

   <b>Syntax</b>
       •   <b>unset</b> <b>[-fv]</b> <b>[</b><u>name</u><b>...]</b>

   <b>Description</b>
       The unset built-in removes the definition of the variables or functions specified by operands.

       It is not an error if any of the specified variables or functions do not exist; they are silently
       ignored.

   <b>Options</b>
       <b>-f</b>, <b>--functions</b>
           Undefine functions.

       <b>-v</b>, <b>--variables</b>
           Undefine variables.

       These options are mutually exclusive: only the last specified one is effective. If neither is specified,
       <b>-v</b> is assumed.

   <b>Operands</b>
       <u>name</u>
           The name of a variable or function to be undefined.

   <b>Exit</b> <b>status</b>
       The exit status of the unset built-in is zero unless there is any error.

   <b>Notes</b>
       The unset built-in is a special built-in.

       Although yash does not do so, the POSIX standard allows removing a function if neither of the <b>-f</b> and <b>-v</b>
       options is specified and the specified variable does not exist.

       At least one <u>name</u> operand must be specified in the POSIXly-correct mode.

</pre><h4><b>WAIT</b> <b>BUILT-IN</b></h4><pre>
       The <u>wait</u> <u>built-in</u> waits for jobs to terminate.

   <b>Syntax</b>
       •   <b>wait</b> <b>[</b><u>job</u><b>...]</b>

   <b>Description</b>
       The wait built-in waits for background jobs to terminate. If job control is enabled, stopped jobs are
       considered as terminated.

       The built-in can be used to wait for asynchronous commands if job control is disabled.

       If the shell receives a signal while the built-in is waiting and if a trap has been set for the signal,
       then the trap is executed and the built-in immediately finishes (without waiting for the jobs). If the
       shell receives a SIGINT signal when job control is enabled, the built-in aborts waiting.

       If the shell is interactive, job-controlling, and not in the POSIXly-correct mode, the job status is
       printed when the job is terminated or stopped.

   <b>Operands</b>
       <u>job</u>
           The job ID of the job or the process ID of a process in the job.

       If no <u>job</u>s are specified, the built-in waits for all existing jobs.

       If the specified job does not exist, the job is considered to have terminated with the exit status of
       127.

   <b>Exit</b> <b>status</b>
       If no <u>job</u>s were specified and the built-in successfully waited for all the jobs, the exit status is zero.
       If one or more <u>job</u>s were specified, the exit status is that of the last <u>job</u>.

       If the built-in was aborted by a signal, the exit status is an integer (&gt; 128) that denotes the signal.
       If there was any other error, the exit status is between 1 and 126 (inclusive).

   <b>Notes</b>
       The wait built-in is a mandatory built-in.

       The process ID of the last process of a job can be obtained by the <b>!</b> special parameter. You can use the
       jobs built-in as well to obtain process IDs of job processes.

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Yuki</b> <b>Watanabe</b> &lt;<a href="mailto:magicant@users.osdn.me">magicant@users.osdn.me</a>&gt;
           Author.

  2.55                                             2023-12-28                                            <u><a href="../man1/YASH.1.html">YASH</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>