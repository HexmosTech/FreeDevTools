<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dash — command interpreter (shell)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/dash">dash_0.5.12-12ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dash — command interpreter (shell)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>dash</b>      [<b>-aCefnuvxIimqVEbp</b>]      [<b>+aCefnuvxIimqVEbp</b>]      [<b>-o</b>     <u>option_name</u>]     [<b>+o</b>     <u>option_name</u>]
            [<u>command_file</u> [<u>argument</u> <u>...</u>]]
       <b>dash</b>  <b>-c</b>  [<b>-aCefnuvxIimqVEbp</b>]  [<b>+aCefnuvxIimqVEbp</b>]  [<b>-o</b>  <u>option_name</u>]  [<b>+o</b>  <u>option_name</u>]   <u>command_string</u>
            [<u>command_name</u> [<u>argument</u> <u>...</u>]]
       <b>dash</b> <b>-s</b> [<b>-aCefnuvxIimqVEbp</b>] [<b>+aCefnuvxIimqVEbp</b>] [<b>-o</b> <u>option_name</u>] [<b>+o</b> <u>option_name</u>] [<u>argument</u> <u>...</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>dash</b>  is  the standard command interpreter for the system.  The current version of <b>dash</b> is in the process
       of being changed to conform with the POSIX 1003.2 and 1003.2a specifications for the shell.  This version
       has many features which make it appear similar in some respects to the Korn shell, but it is not  a  Korn
       shell  clone  (see <u><a href="../man1/ksh.1.html">ksh</a></u>(1)).  Only features designated by POSIX, plus a few Berkeley extensions, are being
       incorporated into this shell.  This man page is not intended to be a tutorial or a complete specification
       of the shell.

   <b>Overview</b>
       The shell is a command that reads lines from  either  a  file  or  the  terminal,  interprets  them,  and
       generally  executes  other  commands.  It is the program that is running when a user logs into the system
       (although a user can select a different shell with the <u><a href="../man1/chsh.1.html">chsh</a></u>(1) command).  The shell implements a language
       that has flow control constructs, a macro facility that provides a variety of  features  in  addition  to
       data  storage,  along with built in history and line editing capabilities.  It incorporates many features
       to aid interactive use and has  the  advantage  that  the  interpretative  language  is  common  to  both
       interactive  and  non-interactive  use  (shell  scripts).  That is, commands can be typed directly to the
       running shell or can be put into a file and the file can be executed directly by the shell.

   <b>Invocation</b>
       If no args are present and if the standard input of the shell is connected to a terminal (or  if  the  <b>-i</b>
       flag  is  set),  and  the  <b>-c</b>  option  is  not present, the shell is considered an interactive shell.  An
       interactive shell generally prompts before each  command  and  handles  programming  and  command  errors
       differently  (as  described below).  When first starting, the shell inspects argument 0, and if it begins
       with a dash ‘-’, the shell is also considered a login shell.  This is normally done automatically by  the
       system  when  the user first logs in.  A login shell first reads commands from the files <u><a href="file:/etc/profile">/etc/profile</a></u> and
       <u>.profile</u> if they exist.  If the environment variable ENV is set on entry to an interactive shell,  or  is
       set  in  the  <u>.profile</u>  of  a  login  shell,  the  shell  next reads commands from the file named in ENV.
       Therefore, a user should place commands that are to be executed only at login time in the <u>.profile</u>  file,
       and  commands that are executed for every interactive shell inside the ENV file.  To set the ENV variable
       to some file, place the following line in your <u>.profile</u> of your home directory

             <b>ENV=$HOME/.shinit;</b> <b>export</b> <b>ENV</b>

       substituting for “.shinit” any filename you wish.

       If command line arguments besides the options have been  specified,  then  the  shell  treats  the  first
       argument  as the name of a file from which to read commands (a shell script), and the remaining arguments
       are set as the positional parameters of the shell ($1, $2, etc).  Otherwise,  the  shell  reads  commands
       from its standard input.

   <b>Argument</b> <b>List</b> <b>Processing</b>
       All  of  the  single  letter  options that have a corresponding name can be used as an argument to the <b>-o</b>
       option.  The set <b>-o</b> name is provided  next  to  the  single  letter  option  in  the  description  below.
       Specifying  a  dash  “-”  turns the option on, while using a plus “+” disables the option.  The following
       options can be set from the command line or with the <b>set</b> builtin (described later).

             <b>-a</b> <u>allexport</u>     Export all variables assigned to.

             <b>-c</b>               Read commands from the <u>command_string</u> operand instead of from the standard  input.
                              Special  parameter  0 will be set from the <u>command_name</u> operand and the positional
                              parameters ($1, $2, etc.)  set from the remaining argument operands.

             <b>-C</b> <u>noclobber</u>     Don't overwrite existing files with “&gt;”.

             <b>-e</b> <u>errexit</u>       If not interactive, exit immediately if any  untested  command  fails.   The  exit
                              status  of  a command is considered to be explicitly tested if the command is used
                              to control an <b>if</b>, <b>elif</b>, <b>while</b>, or <b>until</b>; or  if  the  command  is  the  left  hand
                              operand of an “&amp;&amp;” or “||” operator.

             <b>-f</b> <u>noglob</u>        Disable pathname expansion.

             <b>-n</b> <u>noexec</u>        If  not  interactive,  read  commands but do not execute them.  This is useful for
                              checking the syntax of shell scripts.

             <b>-u</b> <u>nounset</u>       Write a message to standard error when attempting to expand a variable that is not
                              set, and if the shell is not interactive, exit immediately.

             <b>-v</b> <u>verbose</u>       The shell writes its input to standard error as it is read.  Useful for debugging.

             <b>-x</b> <u>xtrace</u>        Write each command to standard error (preceded by a ‘+ ’) before it  is  executed.
                              Useful for debugging.

             <b>-I</b> <u>ignoreeof</u>     Ignore EOF's from input when interactive.

             <b>-i</b> <u>interactive</u>   Force the shell to behave interactively.

             <b>-l</b>               Make dash act as if it had been invoked as a login shell.

             <b>-m</b> <u>monitor</u>       Turn on job control (set automatically when interactive).

             <b>-s</b> <u>stdin</u>         Read  commands  from  standard  input  (set automatically if no file arguments are
                              present).  This option has no effect when set after the shell has already  started
                              running (i.e. with <b>set</b>).

             <b>-V</b> <u>vi</u>            Enable the built-in <u><a href="../man1/vi.1.html">vi</a></u>(1) command line editor (disables <b>-E</b> if it has been set).

             <b>-E</b> <u>emacs</u>         Enable the built-in <u><a href="../man1/emacs.1.html">emacs</a></u>(1) command line editor (disables <b>-V</b> if it has been set).

             <b>-b</b> <u>notify</u>        Enable asynchronous notification of background job completion.  (UNIMPLEMENTED for
                              4.4alpha)

             <b>-p</b> <u>priviliged</u>    Do not attempt to reset effective uid if it does not match uid. This is not set by
                              default  to  help  avoid  incorrect usage by setuid root programs via <a href="../man3/system.3.html">system</a>(3) or
                              <a href="../man3/popen.3.html">popen</a>(3).

   <b>Lexical</b> <b>Structure</b>
       The shell reads input in terms of lines from a file and breaks it up into words at whitespace (blanks and
       tabs), and at certain sequences of characters that are special to the shell  called  “operators”.   There
       are  two  types  of  operators:  control  operators and redirection operators (their meaning is discussed
       later).  Following is a list of operators:

             Control operators:
                   <b>&amp;</b> <b>&amp;&amp;</b> <b>(</b> <b>)</b> <b>;</b> <b>;;</b> | <b>||</b> <b>&lt;newline&gt;</b>

             Redirection operators:
                   <b>&lt;</b> <b>&gt;</b> <b>&gt;|</b> <b>&lt;&lt;</b> <b>&gt;&gt;</b> <b>&lt;&amp;</b> <b>&gt;&amp;</b> <b>&lt;&lt;-</b> <b>&lt;&gt;</b>

   <b>Quoting</b>
       Quoting is used to remove the special meaning of certain characters  or  words  to  the  shell,  such  as
       operators,  whitespace,  or  keywords.   There are three types of quoting: matched single quotes, matched
       double quotes, and backslash.

   <b>Backslash</b>
       A backslash preserves the literal meaning of the following character, with the exception of ⟨newline⟩.  A
       backslash preceding a ⟨newline⟩ is treated as a line continuation.

   <b>Single</b> <b>Quotes</b>
       Enclosing characters in single quotes preserves the literal meaning of all the characters (except  single
       quotes, making it impossible to put single-quotes in a single-quoted string).

   <b>Double</b> <b>Quotes</b>
       Enclosing  characters  within  double  quotes  preserves  the  literal  meaning  of all characters except
       dollarsign ($), backquote (`), and backslash (\).  The backslash inside  double  quotes  is  historically
       weird, and serves to quote only the following characters:
             <b>$</b> <b>`</b> <b>"</b> <b>\</b> <b>&lt;newline&gt;</b>.
       Otherwise it remains literal.

   <b>Reserved</b> <b>Words</b>
       Reserved  words are words that have special meaning to the shell and are recognized at the beginning of a
       line and after a control operator.  The following are reserved words:

             !       elif    fi      while   case
             else    for     then    {       }
             do      done    until   if      esac

       Their meaning is discussed later.

   <b>Aliases</b>
       An alias is a name and corresponding value set using the <u><a href="../man1/alias.1.html">alias</a></u>(1) builtin command.  Whenever  a  reserved
       word may occur (see above), and after checking for reserved words, the shell checks the word to see if it
       matches  an alias.  If it does, it replaces it in the input stream with its value.  For example, if there
       is an alias called “lf” with the value “ls -F”, then the input:

             <b>lf</b> <b>foobar</b> ⟨return⟩

       would become

             <b>ls</b> <b>-F</b> <b>foobar</b> ⟨return⟩

       Aliases provide a convenient way for naive users to create shorthands  for  commands  without  having  to
       learn  how  to  create functions with arguments.  They can also be used to create lexically obscure code.
       This use is discouraged.

   <b>Commands</b>
       The shell interprets the words it reads according to a language, the specification of  which  is  outside
       the  scope  of this man page (refer to the BNF in the POSIX 1003.2 document).  Essentially though, a line
       is read and if the first word of the line (or after a control operator) is not a reserved word, then  the
       shell  has recognized a simple command.  Otherwise, a complex command or some other special construct may
       have been recognized.

   <b>Simple</b> <b>Commands</b>
       If a simple command has been recognized, the shell performs the following actions:

             1.   Leading words of the form “name=value” are stripped off and assigned to the environment of the
                  simple command.  Redirection operators and their arguments (as described below)  are  stripped
                  off and saved for processing.

             2.   The  remaining  words  are  expanded  as described in the section called “Expansions”, and the
                  first remaining word is considered the command name and the command is located.  The remaining
                  words are considered the arguments of the command.  If no  command  name  resulted,  then  the
                  “name=value” variable assignments recognized in item 1 affect the current shell.

             3.   Redirections are performed as described in the next section.

   <b>Redirections</b>
       Redirections  are  used  to  change  where  a  command  reads its input or sends its output.  In general,
       redirections open, close, or duplicate an existing reference to a file.   The  overall  format  used  for
       redirection is:

             <b>[n]</b> <u>redir-op</u> <u>file</u>

       where  <u>redir-op</u>  is  one  of  the redirection operators mentioned previously.  Following is a list of the
       possible redirections.  The [n] is an optional number between 0 and 9, as in ‘3’ (not ‘[3]’), that refers
       to a file descriptor.

             [n]&gt; file   Redirect standard output (or n) to file.

             [n]&gt;| file  Same, but override the <b>-C</b> option.

             [n]&gt;&gt; file  Append standard output (or n) to file.

             [n]&lt; file   Redirect standard input (or n) from file.

             [n1]&lt;&amp;n2    Copy file descriptor n2 as stdout (or fd n1).  fd n2.

             [n]&lt;&amp;-      Close standard input (or n).

             [n1]&gt;&amp;n2    Copy file descriptor n2 as stdin (or fd n1).  fd n2.

             [n]&gt;&amp;-      Close standard output (or n).

             [n]&lt;&gt; file  Open file for reading and writing on standard input (or n).

       The following redirection is often called a “here-document”.

             <b>[n]&lt;&lt;</b> <b>delimiter</b>
                   <b>here-doc-text</b> <b>...</b>
             <b>delimiter</b>

       All the text on successive lines up to the delimiter is saved away and made available to the  command  on
       standard  input,  or  file descriptor n if it is specified.  If the delimiter as specified on the initial
       line is quoted, then the here-doc-text is treated literally, otherwise the text is subjected to parameter
       expansion, command substitution, and arithmetic expansion (as described in the section on  “Expansions”).
       If the operator is “&lt;&lt;-” instead of “&lt;&lt;”, then leading tabs in the here-doc-text are stripped.

   <b>Search</b> <b>and</b> <b>Execution</b>
       There  are  three  types  of  commands:  shell functions, builtin commands, and normal programs – and the
       command is searched for (by name) in that order.  They each are executed in a different way.

       When a shell function is executed, all of the shell  positional  parameters  (except  $0,  which  remains
       unchanged)  are set to the arguments of the shell function.  The variables which are explicitly placed in
       the environment of the command (by placing assignments to them before the function name) are  made  local
       to  the  function  and are set to the values given.  Then the command given in the function definition is
       executed.  The positional parameters are restored to their original values when  the  command  completes.
       This all occurs within the current shell.

       Shell builtins are executed internally to the shell, without spawning a new process.

       Otherwise,  if  the  command  name  doesn't match a function or builtin, the command is searched for as a
       normal program in the file system (as described in the next section).  When a normal program is executed,
       the shell runs the program, passing the arguments and the environment to the program.  If the program  is
       not  a  normal  executable  file  (i.e.,  if  it  does  not  begin  with  the  "magic number" whose ASCII
       representation is "#!", so <u><a href="../man2/execve.2.html">execve</a></u>(2) returns ENOEXEC then) the shell will  interpret  the  program  in  a
       subshell.   The child shell will reinitialize itself in this case, so that the effect will be as if a new
       shell had been invoked to handle the ad-hoc shell script, except that the  location  of  hashed  commands
       located in the parent shell will be remembered by the child.

       Note  that  previous  versions  of this document and the source code itself misleadingly and sporadically
       refer to a shell script without a magic number as a "shell procedure".

   <b>Path</b> <b>Search</b>
       When locating a command, the shell first looks to see if it has a shell function by that name.   Then  it
       looks for a builtin command by that name.  If a builtin command is not found, one of two things happen:

       1.   Command names containing a slash are simply executed without performing any searches.

       2.   The  shell  searches  each  entry  in  PATH in turn for the command.  The value of the PATH variable
            should be a series of entries separated by colons.  Each entry consists of a  directory  name.   The
            current  directory may be indicated implicitly by an empty directory name, or explicitly by a single
            period.

   <b>Command</b> <b>Exit</b> <b>Status</b>
       Each command has an exit status that can influence the behaviour of other shell commands.   The  paradigm
       is  that  a  command  exits  with zero for normal or success, and non-zero for failure, error, or a false
       indication.  The man page for each command should indicate the various exit codes  and  what  they  mean.
       Additionally, the builtin commands return exit codes, as does an executed shell function.

       If a command consists entirely of variable assignments then the exit status of the command is that of the
       last command substitution if any, otherwise 0.

   <b>Complex</b> <b>Commands</b>
       Complex  commands  are combinations of simple commands with control operators or reserved words, together
       creating a larger complex command.  More generally, a command is one of the following:

       <b>•</b>   simple command

       <b>•</b>   pipeline

       <b>•</b>   list or compound-list

       <b>•</b>   compound command

       <b>•</b>   function definition

       Unless otherwise stated, the exit status of a command is that of the last simple command executed by  the
       command.

   <b>Pipelines</b>
       A  pipeline  is  a  sequence  of  one or more commands separated by the control operator |.  The standard
       output of all but the last command is connected to the standard input of the next command.  The  standard
       output of the last command is inherited from the shell, as usual.

       The format for a pipeline is:

             <b>[!]</b> <b>command1</b> [| <b>command2</b> <b>...]</b>

       The  standard  output  of  command1  is connected to the standard input of command2.  The standard input,
       standard output, or both of a command is considered to be assigned by the pipeline before any redirection
       specified by redirection operators that are part of the command.

       If the pipeline is not in the background (discussed later), the shell waits for all commands to complete.

       If the <u>pipefail</u> option was enabled when the shell began execution of the pipeline,  the  pipeline's  exit
       status is the exit status of the last command specified in the pipeline that exited with non-zero status,
       or  zero  if  all  commands  in the pipeline exited with a status of zero. If the <u>pipefail</u> option was not
       enabled, the pipeline's exit status is the exit status of the last command specified in the pipeline; the
       exit statuses of any other commands are not used. If the reserved word ! precedes the pipeline, its  exit
       status is the logical NOT of the exit status described above.

       Because  pipeline assignment of standard input or standard output or both takes place before redirection,
       it can be modified by redirection.  For example:

             <b>$</b> <b>command1</b> <b>2&gt;&amp;1</b> | <b>command2</b>

       sends both the standard output and standard error of command1 to the standard input of command2.

       A  ;  or  ⟨newline⟩  terminator  causes  the  preceding  AND-OR-list  (described  next)  to  be  executed
       sequentially; a &amp; causes asynchronous execution of the preceding AND-OR-list.

       Note that unlike some other shells, each process in the pipeline is a child of the invoking shell (unless
       it  is  a  shell  builtin,  in which case it executes in the current shell – but any effect it has on the
       environment is wiped).

   <b>Background</b> <b>Commands</b> <b>–</b> <b>&amp;</b>
       If a command is terminated by the  control  operator  ampersand  (&amp;),  the  shell  executes  the  command
       asynchronously  –  that  is,  the shell does not wait for the command to finish before executing the next
       command.

       The format for running a command in background is:

             <b>command1</b> <b>&amp;</b> <b>[command2</b> <b>&amp;</b> <b>...]</b>

       If the shell is not interactive, the standard input of an asynchronous command is set to <u>/dev/null</u>.

   <b>Lists</b> <b>–</b> <b>Generally</b> <b>Speaking</b>
       A list is a sequence of zero or more commands separated  by  newlines,  semicolons,  or  ampersands,  and
       optionally terminated by one of these three characters.  The commands in a list are executed in the order
       they  are  written.  If command is followed by an ampersand, the shell starts the command and immediately
       proceeds onto the next command; otherwise it waits for the command to terminate before proceeding to  the
       next one.

   <b>Short-Circuit</b> <b>List</b> <b>Operators</b>
       “&amp;&amp;”  and  “||” are AND-OR list operators.  “&amp;&amp;” executes the first command, and then executes the second
       command if and only if the exit status of the first command is zero.  “||” is similar, but  executes  the
       second  command  if and only if the exit status of the first command is nonzero.  “&amp;&amp;” and “||” both have
       the same priority.

   <b>Flow-Control</b> <b>Constructs</b> <b>–</b> <b>if,</b> <b>while,</b> <b>for,</b> <b>case</b>
       The syntax of the if command is

             if list
             then list
             [ elif list
             then    list ] ...
             [ else list ]
             fi

       The syntax of the while command is

             while list
             do   list
             done

       The two lists are executed repeatedly while the exit status of the first list is zero.  The until command
       is similar, but has the word until in place of while, which causes it to repeat until the exit status  of
       the first list is zero.

       The syntax of the for command is

             for variable [ in [ word ... ] ]
             do   list
             done

       The  words  following  <u>in</u> are expanded, and then the list is executed repeatedly with the variable set to
       each word in turn.  Omitting in word ... is equivalent to in "$@".

       The syntax of the break and continue command is

             break [ num ]
             continue [ num ]

       Break terminates the num innermost for or while loops.  Continue continues with the next iteration of the
       innermost loop.  These are implemented as builtin commands.

       The syntax of the case command is

             case word in
             [(]pattern) list ;;
             ...
             esac

       The pattern can actually be one or more patterns (see “Shell Patterns” described later), separated by “|”
       characters.  The “(” character before the pattern is optional.

   <b>Grouping</b> <b>Commands</b> <b>Together</b>
       Commands may be grouped by writing either

             <b>(list)</b>

       or

             <b>{</b> <b>list;</b> <b>}</b>

       The first of these executes the commands in a subshell.  Builtin commands grouped into a (list) will  not
       affect  the  current  shell.   The second form does not fork another shell so is slightly more efficient.
       Grouping commands together this way allows you to redirect their output as though they were one program:

             { printf " hello " ; printf " world\n" ; } &gt; greeting

       Note that “}” must follow a control operator (here, “;”) so that it is recognized as a reserved word  and
       not as another command argument.

   <b>Functions</b>
       The syntax of a function definition is

             <b>name</b> () <b>command</b>

       A  function  definition  is  an executable statement; when executed it installs a function named name and
       returns an exit status of zero.  The command is normally a list enclosed between “{” and “}”.

       Variables may be declared to be local to a function by using a local command.  This should appear as  the
       first statement of a function, and the syntax is

             <b>local</b> [<b>variable</b> | <b>-</b>] <b>...</b>

       Local is implemented as a builtin command.

       When  a  variable  is  made local, it inherits the initial value and exported and readonly flags from the
       variable with the same name in the surrounding scope, if  there  is  one.   Otherwise,  the  variable  is
       initially unset.  The shell uses dynamic scoping, so that if you make the variable x local to function f,
       which  then  calls  function  g,  references to the variable x made inside g will refer to the variable x
       declared inside f, not to the global variable named x.

       The only special parameter that can be made local is “-”.  Making “-” local any shell  options  that  are
       changed via the set command inside the function to be restored to their original values when the function
       returns.

       The syntax of the return command is

             <b>return</b> [<b>exitstatus</b>]

       It terminates the currently executing function.  Return is implemented as a builtin command.

   <b>Variables</b> <b>and</b> <b>Parameters</b>
       The  shell  maintains  a  set  of  parameters.  A parameter denoted by a name is called a variable.  When
       starting up, the shell turns all the environment variables into shell variables.  New  variables  can  be
       set using the form

             <b>name=value</b>

       Variables  set by the user must have a name consisting solely of alphabetics, numerics, and underscores -
       the first of which must not be numeric.  A parameter can also  be  denoted  by  a  number  or  a  special
       character as explained below.

   <b>Positional</b> <b>Parameters</b>
       A positional parameter is a parameter denoted by a number (n &gt; 0).  The shell sets these initially to the
       values  of its command line arguments that follow the name of the shell script.  The <b>set</b> builtin can also
       be used to set or reset them.

   <b>Special</b> <b>Parameters</b>
       A special parameter is a parameter denoted by one of the following special characters.  The value of  the
       parameter is listed next to its character.

       *            Expands to the positional parameters, starting from one.  When the expansion occurs within a
                    double-quoted string it expands to a single field with the value of each parameter separated
                    by the first character of the IFS variable, or by a ⟨space⟩ if IFS is unset.

       @            Expands  to  the positional parameters, starting from one.  When the expansion occurs within
                    double-quotes, each positional parameter expands as a separate argument.  If  there  are  no
                    positional  parameters,  the expansion of @ generates zero arguments, even when @ is double-
                    quoted.  What this basically means, for example, is if $1 is “abc” and $2 is “def ghi”, then
                    "$@" expands to the two arguments:

                          <b>"abc"</b> <b>"def</b> <b>ghi"</b>

       #            Expands to the number of positional parameters.

       ?            Expands to the exit status of the most recent pipeline.

       - (Hyphen.)  Expands to the current option flags (the single-letter  option  names  concatenated  into  a
                    string) as specified on invocation, by the set builtin command, or implicitly by the shell.

       $            Expands  to  the process ID of the invoked shell.  A subshell retains the same value of $ as
                    its parent.

       !            Expands to the process ID of the most recent background command executed  from  the  current
                    shell.  For a pipeline, the process ID is that of the last command in the pipeline.

       0 (Zero.)    Expands to the name of the shell or shell script.

   <b>Word</b> <b>Expansions</b>
       This  clause  describes  the  various  expansions  that  are  performed on words.  Not all expansions are
       performed on every word, as explained later.

       Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote  removals
       that  occur  within  a  single  word  expand  to  a single field.  It is only field splitting or pathname
       expansion that can create multiple fields from a single word.  The single exception to this rule  is  the
       expansion of the special parameter @ within double-quotes, as was described above.

       The order of word expansion is:

       1.   Tilde Expansion, Parameter Expansion, Command Substitution, Arithmetic Expansion (these all occur at
            the same time).

       2.   Field Splitting is performed on fields generated by step (1) unless the IFS variable is null.

       3.   Pathname Expansion (unless set <b>-f</b> is in effect).

       4.   Quote Removal.

       The $ character is used to introduce parameter expansion, command substitution, or arithmetic evaluation.

   <b>Tilde</b> <b>Expansion</b> <b>(substituting</b> <b>a</b> <b>user's</b> <b>home</b> <b>directory)</b>
       A  word  beginning  with  an  unquoted  tilde  character  (~)  is  subjected to tilde expansion.  All the
       characters up to a slash (/) or the end of the word are treated as a username and are replaced  with  the
       user's home directory.  If the username is missing (as in <u><a href="file:~/foobar">~/foobar</a></u>), the tilde is replaced with the value
       of the <u>HOME</u> variable (the current user's home directory).

   <b>Parameter</b> <b>Expansion</b>
       The format for parameter expansion is as follows:

             <b>${expression}</b>

       where  expression  consists  of all characters until the matching “}”.  Any “}” escaped by a backslash or
       within a quoted string, and characters in embedded  arithmetic  expansions,  command  substitutions,  and
       variable expansions, are not examined in determining the matching “}”.

       The simplest form for parameter expansion is:

             <b>${parameter}</b>

       The value, if any, of parameter is substituted.

       The  parameter  name  or  symbol  can  be  enclosed  in  braces, which are optional except for positional
       parameters with more than one digit  or  when  parameter  is  followed  by  a  character  that  could  be
       interpreted as part of the name.  If a parameter expansion occurs inside double-quotes:

       1.   Pathname expansion is not performed on the results of the expansion.

       2.   Field splitting is not performed on the results of the expansion, with the exception of @.

       In addition, a parameter expansion can be modified by using one of the following formats.

       ${parameter:-word}    Use  Default  Values.   If  parameter  is  unset  or null, the expansion of word is
                             substituted; otherwise, the value of parameter is substituted.

       ${parameter:=word}    Assign Default Values.  If parameter is unset or null, the  expansion  of  word  is
                             assigned  to parameter.  In all cases, the final value of parameter is substituted.
                             Only variables, not positional parameters or special parameters, can be assigned in
                             this way.

       ${parameter:?[word]}  Indicate Error if Null or Unset.  If parameter is unset or null, the  expansion  of
                             word  (or  a  message  indicating  it  is  unset  if word is omitted) is written to
                             standard error and the shell exits with a  nonzero  exit  status.   Otherwise,  the
                             value of parameter is substituted.  An interactive shell need not exit.

       ${parameter:+word}    Use  Alternative  Value.   If  parameter  is  unset  or  null, null is substituted;
                             otherwise, the expansion of word is substituted.

       In the parameter expansions shown previously, use of the colon in the format results  in  a  test  for  a
       parameter  that  is  unset  or null; omission of the colon results in a test for a parameter that is only
       unset.

       ${#parameter}         String Length.  The length in characters of the value of parameter.

       The following four varieties of parameter expansion provide for  substring  processing.   In  each  case,
       pattern  matching  notation  (see  “Shell Patterns”), rather than regular expression notation, is used to
       evaluate the patterns.  If parameter is * or @, the result of the expansion  is  unspecified.   Enclosing
       the  full  parameter  expansion  string  in  double-quotes does not cause the following four varieties of
       pattern characters to be quoted, whereas quoting characters within the braces has this effect.

       ${parameter%word}     Remove Smallest Suffix Pattern.  The word is expanded to produce  a  pattern.   The
                             parameter  expansion  then  results  in parameter, with the smallest portion of the
                             suffix matched by the pattern deleted.

       ${parameter%%word}    Remove Largest Suffix Pattern.  The word is expanded to  produce  a  pattern.   The
                             parameter  expansion  then  results  in  parameter, with the largest portion of the
                             suffix matched by the pattern deleted.

       ${parameter#word}     Remove Smallest Prefix Pattern.  The word is expanded to produce  a  pattern.   The
                             parameter  expansion  then  results  in parameter, with the smallest portion of the
                             prefix matched by the pattern deleted.

       ${parameter##word}    Remove Largest Prefix Pattern.  The word is expanded to  produce  a  pattern.   The
                             parameter  expansion  then  results  in  parameter, with the largest portion of the
                             prefix matched by the pattern deleted.

   <b>Command</b> <b>Substitution</b>
       Command substitution allows the output of a command to be  substituted  in  place  of  the  command  name
       itself.  Command substitution occurs when the command is enclosed as follows:

             <b>$(command)</b>

       or (“backquoted” version):

             <b>`command`</b>

       The  shell  expands the command substitution by executing command in a subshell environment and replacing
       the command substitution with the standard output of the command,  removing  sequences  of  one  or  more
       ⟨newline⟩s  at  the  end  of the substitution.  (Embedded ⟨newline⟩s before the end of the output are not
       removed; however, during field splitting, they may be translated into ⟨space⟩s, depending on the value of
       IFS and quoting that is in effect.)

   <b>Arithmetic</b> <b>Expansion</b>
       Arithmetic expansion provides a mechanism for evaluating an arithmetic expression  and  substituting  its
       value.  The format for arithmetic expansion is as follows:

             <b>$((expression))</b>

       The  expression  is  treated  as  if  it  were  in  double-quotes,  except that a double-quote inside the
       expression is not treated specially.  The shell expands  all  tokens  in  the  expression  for  parameter
       expansion, command substitution, and quote removal.

       Next, the shell treats this as an arithmetic expression and substitutes the value of the expression.

   <b>White</b> <b>Space</b> <b>Splitting</b> <b>(Field</b> <b>Splitting)</b>
       After  parameter expansion, command substitution, and arithmetic expansion the shell scans the results of
       expansions and substitutions that did not occur in double-quotes for field splitting and multiple  fields
       can result.

       The shell treats each character of the IFS as a delimiter and uses the delimiters to split the results of
       parameter expansion and command substitution into fields.

   <b>Pathname</b> <b>Expansion</b> <b>(File</b> <b>Name</b> <b>Generation)</b>
       Unless the <b>-f</b> flag is set, file name generation is performed after word splitting is complete.  Each word
       is viewed as a series of patterns, separated by slashes.  The process of expansion replaces the word with
       the  names  of  all existing files whose names can be formed by replacing each pattern with a string that
       matches the specified pattern.  There are two restrictions on this:  first,  a  pattern  cannot  match  a
       string  containing a slash, and second, a pattern cannot match a string starting with a period unless the
       first character of the pattern is a period.  The next  section  describes  the  patterns  used  for  both
       Pathname Expansion and the <b>case</b> command.

   <b>Shell</b> <b>Patterns</b>
       A  pattern  consists  of  normal  characters,  which  match  themselves,  and meta-characters.  The meta-
       characters are “!”, “*”, “?”, and “[”.  These characters lose their special meanings if they are  quoted.
       When  command  or  variable  substitution  is performed and the dollar sign or back quotes are not double
       quoted, the value of the variable or the output of the command is scanned for these characters  and  they
       are turned into meta-characters.

       An  asterisk  (“*”)  matches  any string of characters.  A question mark matches any single character.  A
       left bracket (“[”) introduces a character class.  The end of the character class is indicated by a (“]”);
       if the “]” is missing then the “[” matches a “[” rather than introducing a character class.  A  character
       class  matches any of the characters between the square brackets.  A range of characters may be specified
       using a minus sign.  The character class may be complemented by making an  exclamation  point  the  first
       character of the character class.

       To  include  a  “]” in a character class, make it the first character listed (after the “!”, if any).  To
       include a minus sign, make it the first or last character listed.

   <b>Builtins</b>
       This section lists the builtin commands which are builtin because they need  to  perform  some  operation
       that  can't  be  performed by a separate process.  In addition to these, there are several other commands
       that may be builtin for efficiency (e.g.  <u><a href="../man1/printf.1.html">printf</a></u>(1), <u><a href="../man1/echo.1.html">echo</a></u>(1), <u><a href="../man1/test.1.html">test</a></u>(1), etc).

       :

       true   A null command that returns a 0 (true) exit value.

       false  A null command that returns a 1 (false) exit value.

       . file
              The commands in the specified file are read and executed by the shell.

       alias [<u>name</u>[<u>=string</u> <u>...</u>]]
              If <u>name=string</u> is specified, the shell defines the alias <u>name</u> with value <u>string</u>.  If just <u>name</u>  is
              specified,  the  value  of the alias <u>name</u> is printed.  With no arguments, the <b>alias</b> builtin prints
              the names and values of all defined aliases (see <b>unalias</b>).

       bg [<u>job</u>] <u>...</u>
              Continue the specified jobs (or the current job if no jobs are given) in the background.

       command [<b>-p</b>] [<b>-v</b>] [<b>-V</b>] <u>command</u> [<u>arg</u> <u>...</u>]
              Execute the specified command but ignore shell functions when searching for it.  (This  is  useful
              when you have a shell function with the same name as a builtin command.)

              <b>-p</b>     search for command using a PATH that guarantees to find all the standard utilities.

              <b>-V</b>     Do  not  execute  the  command  but  search for the command and print the resolution of the
                     command search.  This is the same as the type builtin.

              <b>-v</b>     Do not execute the command but search for the command and print the  absolute  pathname  of
                     utilities, the name for builtins or the expansion of aliases.

       cd|chdir <u>-</u>

       cd|chdir [<b>-LP</b>] [<u>directory</u>]
              Switch  to  the  specified  directory  (default  HOME).   If  an  entry  for CDPATH appears in the
              environment of the <b>cd</b> command or the shell variable CDPATH is set and the directory name does  not
              begin  with  a  slash,  then  the  directories listed in CDPATH will be searched for the specified
              directory.  The format of CDPATH is the same as that of PATH.  If a single dash  is  specified  as
              the  argument, it will be replaced by the value of OLDPWD.  The <b>cd</b> command will print out the name
              of the directory that it actually switched to if this is different from the  name  that  the  user
              gave.  These may be different either because the CDPATH mechanism was used or because the argument
              is  a single dash.  The <b>-P</b> option causes the physical directory structure to be used, that is, all
              symbolic links are resolved to their respective values.  The <b>-L</b> option turns off the effect of any
              preceding <b>-P</b> options.

       echo [<b>-n</b>] <u>args...</u>
              Print the arguments on the standard output, separated by spaces.  Unless the <b>-n</b> option is present,
              a newline is output following the arguments.

              If any of the following sequences of characters is encountered during output, the sequence is  not
              output.  Instead, the specified action is performed:

              <b>\b</b>      A backspace character is output.

              <b>\c</b>      Subsequent output is suppressed.  This is normally used at the end of the last argument to
                      suppress the trailing newline that <b>echo</b> would otherwise output.

              <b>\e</b>      Outputs an escape character (ESC).

              <b>\f</b>      Output a form feed.

              <b>\n</b>      Output a newline character.

              <b>\r</b>      Output a carriage return.

              <b>\t</b>      Output a (horizontal) tab character.

              <b>\v</b>      Output a vertical tab.

              <b>\0</b><u>digits</u>
                      Output  the  character  whose  value is given by zero to three octal digits.  If there are
                      zero digits, a nul character is output.

              <b>\\</b>      Output a backslash.

              All other backslash sequences elicit undefined behaviour.

       eval <u>string</u> <u>...</u>
              Concatenate all the arguments with spaces.  Then re-parse and execute the command.

       exec [<u>command</u> <u>arg</u> <u>...</u>]
              Unless command is omitted, the shell process is replaced with the specified program (which must be
              a real program, not a shell builtin or function).  Any redirections on the <b>exec</b> command are marked
              as permanent, so that they are not undone when the <b>exec</b> command finishes.

       exit [<u>exitstatus</u>]
              Terminate the shell process.  If <u>exitstatus</u> is given it is used as the exit status of  the  shell;
              otherwise the exit status of the preceding command is used.

       export <u>name</u> <u>...</u>

       export <b>-p</b>
              The  specified  names  are  exported  so  that  they  will appear in the environment of subsequent
              commands.  The only way to un-export a variable is to unset it.  The shell allows the value  of  a
              variable to be set at the same time it is exported by writing

                    <b>export</b> <b>name=value</b>

              With  no  arguments  the  export  command  lists the names of all exported variables.  With the <b>-p</b>
              option specified the output will be formatted suitably for non-interactive use.

       fc [<b>-e</b> <u>editor</u>] [<u>first</u> [<u>last</u>]]

       fc <b>-l</b> [<b>-nr</b>] [<u>first</u> [<u>last</u>]]

       fc <b>-s</b> [<u>old=new</u>] [<u>first</u>]
              The <b>fc</b> builtin lists, or edits and re-executes, commands  previously  entered  to  an  interactive
              shell.

              <b>-e</b> editor
                     Use  the editor named by editor to edit the commands.  The editor string is a command name,
                     subject to search via the PATH variable.  The value in the FCEDIT variable  is  used  as  a
                     default  when  <b>-e</b>  is  not  specified.  If FCEDIT is null or unset, the value of the EDITOR
                     variable is used.  If EDITOR is null or unset, <u><a href="../man1/ed.1.html">ed</a></u>(1) is used as the editor.

              <b>-l</b> (ell)
                     List the commands rather than invoking an editor on them.  The commands are written in  the
                     sequence  indicated  by  the  first and last operands, as affected by <b>-r</b>, with each command
                     preceded by the command number.

              <b>-n</b>     Suppress command numbers when listing with -l.

              <b>-r</b>     Reverse the order of the commands listed (with <b>-l</b>) or edited (with neither <b>-l</b> nor <b>-s</b>).

              <b>-s</b>     Re-execute the command without invoking an editor.

              first

              last   Select the commands to list or edit.  The number of previous commands that can be  accessed
                     are  determined  by the value of the HISTSIZE variable.  The value of first or last or both
                     are one of the following:

                     [+]number
                            A positive number representing a command number; command numbers  can  be  displayed
                            with the <b>-l</b> option.

                     <b>-number</b>
                            A  negative  decimal  number  representing  the  command that was executed number of
                            commands previously.  For example, -1 is the immediately previous command.

              string
                     A string indicating the most recently entered command that begins with that string.  If the
                     old=new operand is not also specified with <b>-s</b>, the string form of the first operand  cannot
                     contain an embedded equal sign.

              The following environment variables affect the execution of fc:

              FCEDIT    Name of the editor to use.

              HISTSIZE  The number of previous commands that are accessible.

       fg [<u>job</u>]
              Move the specified job or the current job to the foreground.

       getopts <u>optstring</u> <u>var</u> [<u>arg</u> <u>...</u>]
              The POSIX <b>getopts</b> command, not to be confused with the <u>Bell</u> <u>Labs</u>-derived <u><a href="../man1/getopt.1.html">getopt</a></u>(1).

              The  first  argument  should be a series of letters, each of which may be optionally followed by a
              colon to indicate that the option requires an argument.  The variable  specified  is  set  to  the
              parsed option.

              The  <b>getopts</b>  command  deprecates  the  older  <u><a href="../man1/getopt.1.html">getopt</a></u>(1)  utility due to its handling of arguments
              containing whitespace.

              The <b>getopts</b> builtin may be used to obtain options and their arguments from a list  of  parameters.
              When  invoked,  <b>getopts</b>  places the value of the next option from the option string in the list in
              the shell variable specified by <u>var</u> and its index in the shell variable OPTIND.  When the shell is
              invoked, OPTIND is initialized to 1.  For each option  that  requires  an  argument,  the  <b>getopts</b>
              builtin  will  place  it  in  the  shell  variable OPTARG.  If an option is not allowed for in the
              <u>optstring</u>, then OPTARG will be unset.

              By default, the variables <u>$1</u>, <u>...</u>, <u>$n</u> are inspected; if <u>arg</u>s  are  specified,  they'll  be  parsed
              instead.

              <u>optstring</u>  is a string of recognized option letters (see <u><a href="../man3/getopt.3.html">getopt</a></u>(3)).  If a letter is followed by a
              colon, the option is expected to have an argument which may or may not be  separated  from  it  by
              white  space.   If  an option character is not found where expected, <b>getopts</b> will set the variable
              <u>var</u> to a “?”; <b>getopts</b> will then unset OPTARG and write output to standard error.  By specifying  a
              colon as the first character of <u>optstring</u> all errors will be ignored.

              After the last option <b>getopts</b> will return a non-zero value and set <u>var</u> to “?”.

              The  following code fragment shows how one might process the arguments for a command that can take
              the options [a] and [b], and the option [c], which requires an argument.

                    while getopts abc: f
                    do
                            case $f in
                            a | b)  flag=$f;;
                            c)      carg=$OPTARG;;
                            \?)     echo $USAGE; exit 1;;
                            esac
                    done
                    shift $((OPTIND - 1))

              This code will accept any of the following as equivalent:

                    cmd -acarg file file
                    cmd -a -c arg file file
                    cmd -carg -a file file
                    cmd -a -carg -- file file

       hash [<u>command</u> <u>...</u>]

       hash <b>-r</b>
              The shell maintains a hash table which remembers the locations of  commands.   With  no  arguments
              whatsoever,  the  <b>hash</b> command prints out the contents of this table.  Entries which have not been
              looked at since the last <b>cd</b> command are marked with an asterisk; it is possible for these  entries
              to be invalid.

              With  arguments,  the <b>hash</b> command removes the specified commands from the hash table (unless they
              are functions) and then locates them.  The <b>-r</b> option causes the hash command  to  delete  all  the
              entries in the hash table except for functions.

       jobs [<b>-lp</b>] [<u>job</u> <u>...</u>]
              Display the status of all, or just the specified, <u>job</u>s:
                   By default  display  the  job  number,  currency  (<b>+-</b>) status, if any, the job state, and its
                               shell command.
                   <b>-l</b>          also output the PID of the group leader, and just the PID and shell  commands  of
                               other members of the job.
                   <b>-p</b>          Display only leader PIDs, one per line.

       kill [<b>-s</b> <u>sigspec</u> | <b>-</b><u>signum</u> | <b>-</b><u>sigspec</u>] [<u>pid</u> | <u>job</u> <u>...</u>]
              Equivalent  to  <u><a href="../man1/kill.1.html">kill</a></u>(1),  but  a  <u>job</u>  spec  may  also  be specified.  Signals can be either case-
              insensitive names without SIG prefixes or decimal numbers; the default is TERM.

       kill <b>-l</b> [<u>signum</u> | <u>exitstatus</u>]
              List available signal names without the SIG prefix (<u>sigspec</u>s).  If <u>signum</u> specified, display  just
              the  <u>sigspec</u>  for  that  signal.   If  <u>exitstatus</u> specified (&gt; <b>128</b>), display just the <u>sigspec</u> that
              caused it.

       pwd [<b>-LP</b>]
              builtin command remembers what the current directory is rather  than  recomputing  it  each  time.
              This  makes  it  faster.  However, if the current directory is renamed, the builtin version of <b>pwd</b>
              will continue to print the old name for the directory.  The <b>-P</b> option causes the physical value of
              the current working directory to be shown, that is, all  symbolic  links  are  resolved  to  their
              respective values.  The <b>-L</b> option turns off the effect of any preceding <b>-P</b> options.

       read [<b>-p</b> <u>prompt</u>] [<b>-r</b>] <u>variable</u> [<u>...</u>]
              The  prompt is printed if the <b>-p</b> option is specified and the standard input is a terminal.  Then a
              line is read from the standard input.  The trailing newline is deleted from the line and the  line
              is  split  as described in the section on word splitting above, and the pieces are assigned to the
              variables in order.  At least one variable must be specified.   If  there  are  more  pieces  than
              variables,  the  remaining  pieces  (along  with  the  characters  in IFS that separated them) are
              assigned to the last variable.  If there are more variables than pieces, the  remaining  variables
              are assigned the null string.  The <b>read</b> builtin will indicate success unless EOF is encountered on
              input, in which case failure is returned.

              By  default,  unless  the  <b>-r</b>  option is specified, the backslash “\” acts as an escape character,
              causing the following character to be treated literally.  If a backslash is followed by a newline,
              the backslash and the newline will be deleted.

       readonly <u>name</u> <u>...</u>

       readonly <b>-p</b>
              The specified names are marked as read only, so that  they  cannot  be  subsequently  modified  or
              unset.  The shell allows the value of a variable to be set at the same time it is marked read only
              by writing

                    <b>readonly</b> <b>name=value</b>

              With  no  arguments  the readonly command lists the names of all read only variables.  With the <b>-p</b>
              option specified the output will be formatted suitably for non-interactive use.

       printf <u>format</u> [<u>value</u>]...
              <b>printf</b> formats and prints its arguments according to <u>format</u>, a  character  string  which  contains
              three  types  of  objects: plain characters, which are simply copied to standard output, character
              escape sequences which are converted and copied to the standard output, and format specifications,
              each of which causes printing of the next successive <u>value</u>.

              Each <u>value</u> is treated as a string if the corresponding format specification is either <b>b</b>, <b>c</b>, or  <b>s</b>;
              otherwise it is evaluated as a C constant, with the following additions:
                    <b>•</b>   A leading plus or minus sign is allowed.
                    <b>•</b>   If the leading character is a single or double quote, the value of the next byte.

              The format string is reused as often as necessary until all <u>value</u>s are consumed.  Any extra format
              specifications are evaluated with zero or the null string.

              Character  escape sequences are in backslash notation as defined in ANSI X3.159-1989 (“ANSI C89”).
              The characters and their meanings are as follows:

                    <b>\a</b>      Write a &lt;bell&gt; character.

                    <b>\b</b>      Write a &lt;backspace&gt; character.

                    <b>\e</b>      Write an &lt;escape&gt; (ESC) character.

                    <b>\f</b>      Write a &lt;form-feed&gt; character.

                    <b>\n</b>      Write a &lt;new-line&gt; character.

                    <b>\r</b>      Write a &lt;carriage return&gt; character.

                    <b>\t</b>      Write a &lt;tab&gt; character.

                    <b>\v</b>      Write a &lt;vertical tab&gt; character.

                    <b>\\</b>      Write a backslash character.

                    <b>\</b><u>num</u>    Write an 8-bit character whose ASCII value is the 1-, 2-, or  3-digit  octal  number
                            <u>num</u>.

              Each  format  specification  is introduced by the percent character (``%'').  The remainder of the
              format specification includes, in the following order:

              Zero or more of the following flags:

                      <b>#</b>       A `#' character specifying that the value should be printed  in  an  ``alternative
                              form''.   For <b>b</b>, <b>c</b>, <b>d</b>, and <b>s</b> formats, this option has no effect.  For the <b>o</b> format
                              the precision of the number is increased to  force  the  first  character  of  the
                              output  string  to a zero.  For the <b>x</b> (<b>X</b>) format, a non-zero result has the string
                              <b>0x</b> (<b>0X</b>) prepended to it.  For <b>e</b>, <b>E</b>, <b>f</b>, <b>g</b>, and <b>G</b> formats, the  result  will  always
                              contain  a  decimal point, even if no digits follow the point (normally, a decimal
                              point only appears in the results of those formats if a digit follows the  decimal
                              point).   For  <b>g</b>  and <b>G</b> formats, trailing zeros are not removed from the result as
                              they would otherwise be.

                      <b>-</b>       A minus sign `-' which specifies <u>left</u> <u>adjustment</u> of the output  in  the  indicated
                              field;

                      <b>+</b>       A  `+'  character  specifying that there should always be a sign placed before the
                              number when using signed formats.

                      ‘ ’     A space specifying that a blank should be left before  a  positive  number  for  a
                              signed format.  A `+' overrides a space if both are used;

                      <b>0</b>       A  zero  `0'  character  indicating  that  zero-padding should be used rather than
                              blank-padding.  A `-' overrides a `0' if both are used;

              Field Width:
                      An optional digit string specifying  a  <u>field</u>  <u>width</u>;  if  the  output  string  has  fewer
                      characters  than  the  field  width  it will be blank-padded on the left (or right, if the
                      left-adjustment indicator has been given) to make up the field width (note that a  leading
                      zero is a flag, but an embedded zero is part of a field width);

              Precision:
                      An  optional  period,  ‘<b>.</b>’,  followed by an optional digit string giving a <u>precision</u> which
                      specifies the number of digits to appear after the decimal point, for <b>e</b> and <b>f</b> formats,  or
                      the  maximum  number  of bytes to be printed from a string (<b>b</b> and <b>s</b> formats); if the digit
                      string is missing, the precision is treated as zero;

              Format:
                      A character which indicates the type of format to use (one of <b>diouxXfwEgGbcs</b>).

              A field width or precision may be ‘<b>*</b>’ instead of  a  digit  string.   In  this  case  an  <u>argument</u>
              supplies the field width or precision.

              The format characters and their meanings are:

              <b>diouXx</b>      The  <u>argument</u>  is  printed  as  a  signed  decimal  (d or i), unsigned octal, unsigned
                          decimal, or unsigned hexadecimal (X or x), respectively.

              <b>f</b>           The <u>argument</u> is printed in the style [-]ddd<b>.</b>ddd where the  number  of  d's  after  the
                          decimal  point  is  equal  to  the  precision  specification for the argument.  If the
                          precision is missing, 6 digits are given; if the precision is explicitly 0, no  digits
                          and no decimal point are printed.

              <b>eE</b>          The  <u>argument</u> is printed in the style [-]d<b>.</b>ddd<b>e</b>±dd where there is one digit before the
                          decimal point and the number after is equal to the  precision  specification  for  the
                          argument;  when  the  precision is missing, 6 digits are produced.  An upper-case E is
                          used for an `E' format.

              <b>gG</b>          The <u>argument</u> is printed in style <b>f</b> or in style <b>e</b> (<b>E</b>) whichever gives full precision in
                          minimum space.

              <b>b</b>           Characters from the  string  <u>argument</u>  are  printed  with  backslash-escape  sequences
                          expanded.
                          The following additional backslash-escape sequences are supported:

                          <b>\c</b>      Causes  <b>dash</b>  to  ignore  any  remaining  characters  in  the  string  operand
                                  containing it, any remaining string operands, and any additional characters in
                                  the format operand.

                          <b>\0</b><u>num</u>   Write an 8-bit character whose ASCII value is the 1-,  2-,  or  3-digit  octal
                                  number <u>num</u>.

              <b>c</b>           The first character of <u>argument</u> is printed.

              <b>s</b>           Characters  from the string <u>argument</u> are printed until the end is reached or until the
                          number of bytes indicated by the precision specification is reached; if the  precision
                          is omitted, all characters in the string are printed.

              <b>%</b>           Print a `%'; no argument is used.

              In  no  case  does  a non-existent or small field width cause truncation of a field; padding takes
              place only if the specified field width exceeds the actual width.

       set [{ <b>-options</b> | <b>+options</b> | <b>--</b> <b>}</b>] <u>arg</u> <u>...</u>
              The <b>set</b> command performs three different functions.

              With no arguments, it lists the values of all shell variables.

              If options are given, it sets the specified option flags, or  clears  them  as  described  in  the
              section  called  “Argument  List Processing”.  As a special case, if the option is -o or +o and no
              argument is supplied, the shell prints the settings of all its options.  If the option is -o,  the
              settings  are printed in a human-readable format; if the option is +o, the settings are printed in
              a format suitable for reinput to the shell to affect the same option settings.

              In addition to the option names listed in the “Argument List Processing”  section,  the  following
              options may be specified as arguments to -o or +o:

              <u>pipefail</u>  Derive  the  exit  status of a pipeline from the exit statuses of all of the commands in
                        the pipeline, not just the last command, as described in the “Pipelines” section.

              The third use of the set command is to set the values of the shell's positional parameters to  the
              specified args.  To change the positional parameters without changing any options, use “--” as the
              first  argument  to  set.   If  no args are present, the set command will clear all the positional
              parameters (equivalent to executing “shift $#”.)

       shift [<u>n</u>]
              Shift the positional parameters n times.  A <b>shift</b> sets the value of <u>$1</u> to the  value  of  <u>$2</u>,  the
              value  of  <u>$2</u>  to  the value of <u>$3</u>, and so on, decreasing the value of <u>$#</u> by one.  If n is greater
              than the number of positional parameters, <b>shift</b> will issue an error message, and exit with  return
              status 2.

       test <u>expression</u>

       [ <u>expression</u> <b>]</b>
              The <b>test</b> utility evaluates the expression and, if it evaluates to true, returns a zero (true) exit
              status; otherwise it returns 1 (false).  If there is no expression, test also returns 1 (false).

              All operators and flags are separate arguments to the <b>test</b> utility.

              The following primaries are used to construct expression:

              <b>-b</b> <u>file</u>       True if <u>file</u> exists and is a block special file.

              <b>-c</b> <u>file</u>       True if <u>file</u> exists and is a character special file.

              <b>-d</b> <u>file</u>       True if <u>file</u> exists and is a directory.

              <b>-e</b> <u>file</u>       True if <u>file</u> exists (regardless of type).

              <b>-f</b> <u>file</u>       True if <u>file</u> exists and is a regular file.

              <b>-g</b> <u>file</u>       True if <u>file</u> exists and its set group ID flag is set.

              <b>-h</b> <u>file</u>       True if <u>file</u> exists and is a symbolic link.

              <b>-k</b> <u>file</u>       True if <u>file</u> exists and its sticky bit is set.

              <b>-n</b> <u>string</u>     True if the length of <u>string</u> is nonzero.

              <b>-p</b> <u>file</u>       True if <u>file</u> is a named pipe (FIFO).

              <b>-r</b> <u>file</u>       True if <u>file</u> exists and is readable.

              <b>-s</b> <u>file</u>       True if <u>file</u> exists and has a size greater than zero.

              <b>-t</b> <u>file_descriptor</u>
                            True  if  the  file  whose  file descriptor number is <u>file_descriptor</u> is open and is
                            associated with a terminal.

              <b>-u</b> <u>file</u>       True if <u>file</u> exists and its set user ID flag is set.

              <b>-w</b> <u>file</u>       True if <u>file</u> exists and is writable.  True indicates only that the write flag is on.
                            The file is not writable on a read-only file system  even  if  this  test  indicates
                            true.

              <b>-x</b> <u>file</u>       True if <u>file</u> exists and is executable.  True indicates only that the execute flag is
                            on.  If <u>file</u> is a directory, true indicates that <u>file</u> can be searched.

              <b>-z</b> <u>string</u>     True if the length of <u>string</u> is zero.

              <b>-L</b> <u>file</u>       True  if  <u>file</u>  exists  and  is  a  symbolic  link.   This  operator is retained for
                            compatibility with previous versions of this program.  Do not rely on its existence;
                            use <b>-h</b> instead.

              <b>-O</b> <u>file</u>       True if <u>file</u> exists and its owner matches the effective user id of this process.

              <b>-G</b> <u>file</u>       True if <u>file</u> exists and its group matches the effective group id of this process.

              <b>-S</b> <u>file</u>       True if <u>file</u> exists and is a socket.

              <u>file1</u> <b>-nt</b> <u>file2</u>
                            True if <u>file1</u> and <u>file2</u> exist and <u>file1</u> is newer than <u>file2</u>, or if <u>file1</u> exists  but
                            <u>file2</u> doesn't.

              <u>file1</u> <b>-ot</b> <u>file2</u>
                            True  if <u>file1</u> and <u>file2</u> exist and <u>file1</u> is older than <u>file2</u>, or if <u>file2</u> exists but
                            <u>file1</u> doesn't.

              <u>file1</u> <b>-ef</b> <u>file2</u>
                            True if <u>file1</u> and <u>file2</u> exist and refer to the same file.

              <u>string</u>        True if <u>string</u> is not the null string.

              <u>s1</u> <b>=</b> <u>s2</u>       True if the strings <u>s1</u> and <u>s2</u> are identical.

              <u>s1</u> <b>!=</b> <u>s2</u>      True if the strings <u>s1</u> and <u>s2</u> are not identical.

              <u>s1</u> <b>&lt;</b> <u>s2</u>       True if string <u>s1</u> comes before <u>s2</u> based on the ASCII value of their characters.

              <u>s1</u> <b>&gt;</b> <u>s2</u>       True if string <u>s1</u> comes after <u>s2</u> based on the ASCII value of their characters.

              <u>n1</u> <b>-eq</b> <u>n2</u>     True if the integers <u>n1</u> and <u>n2</u> are algebraically equal.

              <u>n1</u> <b>-ne</b> <u>n2</u>     True if the integers <u>n1</u> and <u>n2</u> are not algebraically equal.

              <u>n1</u> <b>-gt</b> <u>n2</u>     True if the integer <u>n1</u> is algebraically greater than the integer <u>n2</u>.

              <u>n1</u> <b>-ge</b> <u>n2</u>     True if the integer <u>n1</u> is algebraically greater than or equal to the integer <u>n2</u>.

              <u>n1</u> <b>-lt</b> <u>n2</u>     True if the integer <u>n1</u> is algebraically less than the integer <u>n2</u>.

              <u>n1</u> <b>-le</b> <u>n2</u>     True if the integer <u>n1</u> is algebraically less than or equal to the integer <u>n2</u>.

              These primaries can be combined with the following operators:

              <b>!</b> <u>expression</u>  True if <u>expression</u> is false.

              <u>expression1</u> <b>-a</b> <u>expression2</u>
                            True if both <u>expression1</u> and <u>expression2</u> are true.

              <u>expression1</u> <b>-o</b> <u>expression2</u>
                            True if either <u>expression1</u> or <u>expression2</u> are true.

              <b>(</b><u>expression</u><b>)</b>  True if expression is true.

              The <b>-a</b> operator has higher precedence than the <b>-o</b> operator.

       times  Print the accumulated user and system times for the shell and for processes run  from  the  shell.
              The return status is 0.

       trap [<u>action</u> <u>signal</u> <u>...</u>]
              Cause  the  shell to parse and execute action when any of the specified signals are received.  The
              signals are specified by signal number or as the name of the signal.  If <u>signal</u> is <b>0</b> or <b>EXIT</b>,  the
              action  is  executed  when  the shell exits.  <u>action</u> may be empty (<b>''</b>), which causes the specified
              signals to be ignored.  With <u>action</u> omitted or set to `-' the specified signals are set  to  their
              default  action.  When the shell forks off a subshell, it resets trapped (but not ignored) signals
              to the default action.  The <b>trap</b> command has no effect on signals that were ignored  on  entry  to
              the  shell.   <b>trap</b>  without any arguments cause it to write a list of signals and their associated
              action to the standard output in a format that is suitable as an input to the shell that  achieves
              the same trapping results.

              Examples:

                    <b>trap</b>

              List trapped signals and their corresponding action

                    <b>trap</b> <b>''</b> <b>INT</b> <b>QUIT</b> <b>tstp</b> <b>30</b>

              Ignore signals INT QUIT TSTP USR1

                    <b>trap</b> <b>date</b> <b>INT</b>

              Print date upon receiving signal INT

       type [<u>name</u> <u>...</u>]
              Interpret  each  name  as  a  command  and  print  the resolution of the command search.  Possible
              resolutions are: shell keyword, alias, shell builtin, command, tracked alias and not  found.   For
              aliases  the alias expansion is printed; for commands and tracked aliases the complete pathname of
              the command is printed.

       ulimit [<b>-H</b> | <b>-S</b>] [<b>-a</b> | <b>-tfdscmlpnvwr</b> [<u>value</u>]]
              Inquire about or set the hard or soft limits on processes or set new limits.  The  choice  between
              hard  limit  (which no process is allowed to violate, and which may not be raised once it has been
              lowered) and soft limit (which causes processes to be signaled but  not  necessarily  killed,  and
              which may be raised) is made with these flags:

              <b>-H</b>          set or inquire about hard limits

              <b>-S</b>          set  or  inquire about soft limits.  If neither <b>-H</b> nor <b>-S</b> is specified, the soft limit
                          is displayed or both limits are set.  If both are specified, the last one wins.

              The limit to be interrogated or set, then, is chosen by specifying any one of these flags:

              <b>-a</b>          show all the current limits

              <b>-t</b>          show or set the limit on CPU time (in seconds)

              <b>-f</b>          show or set the limit on the largest file that can be created (in 512-byte blocks)

              <b>-d</b>          show or set the limit on the data segment size of a process (in kilobytes)

              <b>-s</b>          show or set the limit on the stack size of a process (in kilobytes)

              <b>-c</b>          show or set the limit on the largest core dump size that can be produced (in  512-byte
                          blocks)

              <b>-m</b>          show or set the limit on the total physical memory that can be in use by a process (in
                          kilobytes)

              <b>-l</b>          show  or  set  the  limit  on  how  much  memory  a process can lock with <u><a href="../man2/mlock.2.html">mlock</a></u>(2) (in
                          kilobytes)

              <b>-p</b>          show or set the limit on the number of processes this user can have at one time

              <b>-n</b>          show or set the limit on the number files a process can have open at once

              <b>-v</b>          show or set the limit on the total virtual memory that can be in use by a process  (in
                          kilobytes)

              <b>-w</b>          show or set the limit on the total number of locks held by a process

              <b>-r</b>          show or set the limit on the real-time scheduling priority of a process

              If  none  of  these  is specified, it is the limit on file size that is shown or set.  If value is
              specified, the limit is set to that number; otherwise the current limit is displayed.

              Limits of an arbitrary process can be displayed or set using the <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) utility.

       umask [<u>mask</u>]
              Set the value of umask (see <u><a href="../man2/umask.2.html">umask</a></u>(2)) to the specified octal value.  If the argument  is  omitted,
              the umask value is printed.

       unalias [<b>-a</b>] [<u>name</u>]
              If <u>name</u> is specified, the shell removes that alias.  If <b>-a</b> is specified, all aliases are removed.

       unset [<b>-fv</b>] <u>name</u> <u>...</u>
              The  specified  variables  and  functions are unset and unexported.  If <b>-f</b> or <b>-v</b> is specified, the
              corresponding function or variable is unset, respectively.  If a given name corresponds to both  a
              variable and a function, and no options are given, only the variable is unset.

       wait [<u>job</u>]
              Wait  for the specified job to complete and return the exit status of the last process in the job.
              If the argument is omitted, wait for all jobs to complete and return an exit status of zero.

   <b>Command</b> <b>Line</b> <b>Editing</b>
       When <b>dash</b> is being used interactively from a terminal, the current command and the command  history  (see
       <b>fc</b>  in  “Builtins”) can be edited using vi-mode command-line editing.  This mode uses commands, described
       below, similar to a subset of those described in the vi man page.  The command ‘set -o  vi’  enables  vi-
       mode  editing and places sh into vi insert mode.  With vi-mode enabled, sh can be switched between insert
       mode and command mode.  It is similar to vi: typing ⟨ESC⟩ enters vi command mode.  Hitting ⟨return⟩ while
       in command mode will pass the line to the shell.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       Errors that are detected by the shell, such as a syntax error, will cause the shell to exit with  a  non-
       zero  exit  status.   If  the  shell is not an interactive shell, the execution of the shell file will be
       aborted.  Otherwise the shell will return the exit status of the last command executed, or  if  the  exit
       builtin is used with a numeric argument, it will return the argument.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       HOME       Set  automatically  by  <u><a href="../man1/login.1.html">login</a></u>(1)  from  the  user's  login  directory  in  the  password  file
                  (<u><a href="../man4/passwd.4.html">passwd</a></u>(4)).  This environment variable also functions as the  default  argument  for  the  cd
                  builtin.

       PATH       The default search path for executables.  See the above section “Path Search”.

       CDPATH     The search path used with the cd builtin.

       MAIL       The  name  of  a  mail  file, that will be checked for the arrival of new mail.  Overridden by
                  MAILPATH.

       MAILCHECK  The frequency in seconds that the shell checks for the arrival of mail in the files  specified
                  by the MAILPATH or the MAIL file.  If set to 0, the check will occur at each prompt.

       MAILPATH   A  colon  “:”  separated  list  of file names, for the shell to check for incoming mail.  This
                  environment setting overrides the MAIL setting.  There is a maximum of 10 mailboxes  that  can
                  be monitored at once.

       PS1        The primary prompt string, which defaults to “$ ”, unless you are the superuser, in which case
                  it defaults to “# ”.

       PS2        The secondary prompt string, which defaults to “&gt; ”.

       PS4        Output before each line when execution trace (set -x) is enabled, defaults to “+ ”.

       IFS        Input  Field  Separators.   This  is  normally  set to ⟨space⟩, ⟨tab⟩, and ⟨newline⟩.  See the
                  “White Space Splitting” section for more details.

       TERM       The default terminal setting for the shell.  This is inherited by children of the  shell,  and
                  is used in the history editing modes.

       HISTSIZE   The number of lines in the history buffer for the shell.

       PWD        The logical value of the current working directory.  This is set by the <b>cd</b> command.

       OLDPWD     The previous logical value of the current working directory.  This is set by the <b>cd</b> command.

       PPID       The process ID of the parent process of the shell.

</pre><h4><b>FILES</b></h4><pre>
       <u>$HOME/.profile</u>

       <u><a href="file:/etc/profile">/etc/profile</a></u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/csh.1.html">csh</a></u>(1),  <u><a href="../man1/echo.1.html">echo</a></u>(1),  <u><a href="../man1/getopt.1.html">getopt</a></u>(1),  <u><a href="../man1/ksh.1.html">ksh</a></u>(1),  <u><a href="../man1/login.1.html">login</a></u>(1),  <u><a href="../man1/printf.1.html">printf</a></u>(1),  <u><a href="../man1/test.1.html">test</a></u>(1), <u><a href="../man3/getopt.3.html">getopt</a></u>(3), <u><a href="../man5/passwd.5.html">passwd</a></u>(5), <u><a href="../man7/environ.7.html">environ</a></u>(7),
       <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       <b>dash</b> is a POSIX-compliant implementation of <a href="file:/bin/sh">/bin/sh</a> that aims to be as small  as  possible.   <b>dash</b>  is  a
       direct  descendant  of the NetBSD version of ash (the Almquist SHell), ported to Linux in early 1997.  It
       was renamed to <b>dash</b> in 2002.

</pre><h4><b>BUGS</b></h4><pre>
       Setuid shell scripts should be avoided at all costs, as they are a significant security risk.

       PS1, PS2, and PS4 should be subject to parameter expansion before being displayed.

Debian                                          January 19, 2003                                         <u><a href="../man1/DASH.1.html">DASH</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>