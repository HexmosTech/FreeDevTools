<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>slepc4py - SLEPc for Python</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python-slepc4py-doc">python-slepc4py-doc_3.22.2-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       slepc4py - SLEPc for Python

       <b>Authors</b>
              Lisandro Dalcin, Jose E. Roman

       <b>Contact</b>
              <u><a href="mailto:dalcinl@gmail.com">dalcinl@gmail.com</a></u>, <u><a href="mailto:jroman@dsic.upv.es">jroman@dsic.upv.es</a></u>

       <b>Web</b> <b>Site</b>
              <u>https://gitlab.com/slepc/slepc</u>

       <b>Date</b>   Mar 04, 2025

   <b>Abstract</b>
       This document describes <u>slepc4py</u>, a <u>Python</u> port to the <u>SLEPc</u> libraries.

       <u>SLEPc</u>  is a software package for the parallel solution of large-scale eigenvalue problems. It can be used
       for computing eigenvalues and eigenvectors of large, sparse matrices,  or  matrix  pairs,  and  also  for
       computing singular values and vectors of a rectangular matrix.

       <u>SLEPc</u> relies on <u>PETSc</u> for basic functionality such as the representation of matrices and vectors, and the
       solution  of  linear  systems  of  equations.  Thus,  <u>slepc4py</u> must be used together with its companion ‐
       <u>petsc4py</u>.

</pre><h4><b>CONTENTS</b></h4><pre>
   <b>Overview</b>
       <u>SLEPc</u> <u>for</u> <u>Python</u> (slepc4py) is a Python package that provides convenient access to the  functionality  of
       SLEPc.

       SLEPc  [1],  [2]  implements  algorithms and tools for the numerical solution of large, sparse eigenvalue
       problems on parallel computers. It can be used for linear  eigenvalue  problems  in  either  standard  or
       generalized  form, with real or complex arithmetic.  It can also be used for computing a partial SVD of a
       large, sparse, rectangular matrix, and to solve nonlinear eigenvalue problems  (polynomial  or  general).
       Additionally, SLEPc provides solvers for the computation of the action of a matrix function on a vector.

       SLEPc  is  intended  for  computing  a  subset  of the spectrum of a matrix (or matrix pair). One can for
       instance approximate the largest magnitude eigenvalues, or the smallest ones, or even  those  eigenvalues
       located  near  a  given region of the complex plane. Interior eigenvalues are harder to compute, so SLEPc
       provides different  methodologies.  One  such  method  is  to  use  a  spectral  transformation.  Cheaper
       alternatives are also available.

       [1]  J.  E.  Roman,  C.  Campos,  L.  Dalcin,  E.  Romero, A. Tomas.  SLEPc Users Manual. DSIC-II/24/02 -
            Revision 3.22.  D. Sistemas Informaticos y Computacion, Universitat Politecnica de Valencia. 2024.

       [2]  Vicente Hernandez, Jose E. Roman and Vicente Vidal.  SLEPc: A Scalable and Flexible Toolkit for  the
            Solution of Eigenvalue Problems, ACM Trans. Math. Softw. <a href="../man3/31.3.html">31</a>(3), pp. 351-362, 2005.

   <b>Features</b>
       Currently, the following types of eigenproblems can be addressed:

       • Standard eigenvalue problem, <u>Ax=kx</u>, either for Hermitian or non-Hermitian matrices.

       • Generalized eigenvalue problem, <u>Ax=kBx</u>, either Hermitian positive-definite or not.

       • Partial singular value decomposition of a rectangular matrix, <u>Au=sv</u>.

       • Polynomial eigenvalue problem, <u>P(k)x=0</u>.

       • Nonlinear eigenvalue problem, <u>T(k)x=0</u>.

       • Computing the action of a matrix function on a vector, <u>w=f(alpha</u> <u>A)v</u>.

       For the linear eigenvalue problem, the following methods are available:

       • Krylov eigensolvers, particularly Krylov-Schur, Arnoldi, and Lanczos.

       • Davidson-type eigensolvers, including Generalized Davidson and Jacobi-Davidson.

       • Subspace iteration and single vector iterations (inverse iteration, RQI).

       • Conjugate gradient for the minimization of the Rayleigh quotient.

       • A contour integral solver.

       For singular value computations, the following alternatives can be used:

       • Use an eigensolver via the cross-product matrix <u>A’A</u> or the cyclic matrix <u>[0</u> <u>A;</u> <u>A’</u> <u>0]</u>.

       • Explicitly restarted Lanczos bidiagonalization.

       • Implicitly restarted Lanczos bidiagonalization (thick-restart Lanczos).

       For polynomial eigenvalue problems, the following methods are available:

       • Use an eigensolver to solve the generalized eigenvalue problem obtained after linearization.

       • TOAR and Q-Arnoldi, memory efficient variants of Arnoldi for polynomial eigenproblems.

       For general nonlinear eigenvalue problems, the following methods can be used:

       • Solve a polynomial eigenproblem obtained via polynomial interpolation.

       • Rational interpolation and linearization (NLEIGS).

       • Newton-type methods such as SLP or RII.

       Computation of interior eigenvalues is supported by means of the following methodologies:

       • Spectral  transformations,  such as shift-and-invert. This technique implicitly uses the inverse of the
         shifted matrix <u>(A-tI)</u> in order to compute eigenvalues closest to a given target value, <u>t</u>.

       • Harmonic extraction, a cheap alternative to shift-and-invert that also tries to approximate eigenvalues
         closest to a target, <u>t</u>, but without requiring a matrix inversion.

       Other remarkable features include:

       • High computational efficiency, by using NumPy and SLEPc under the hood.

       • Data-structure neutral implementation, by using efficient sparse  matrix  storage  provided  by  PETSc.
         Implicit  matrix  representation  is also available by providing basic operations such as matrix-vector
         products as user-defined Python functions.

       • Run-time flexibility, by specifying numerous setting at the command line.

       • Ability to do the computation in parallel.

   <b>Components</b>
       SLEPc provides the following components, which are mirrored by slepc4py for  its  use  from  Python.  The
       first  five  components  are  solvers for different classes of problems, while the rest can be considered
       auxiliary object.

       <b>EPS</b>    The Eigenvalue Problem Solver is the component that provides all the  functionality  necessary  to
              define  and  solve  an eigenproblem. It provides mechanisms for completely specifying the problem:
              the problem type (e.g. standard symmetric), number of eigenvalues to compute, part of the spectrum
              of interest. Once the problem has been defined, a collection of solvers can be used to compute the
              required solutions.  The behaviour of the solvers can be tuned by means of a few parameters,  such
              as the maximum dimension of the subspace to be used during the computation.

       <b>SVD</b>    This  component  is  the  analog  of  EPS  for the case of Singular Value Decompositions. The user
              provides a rectangular matrix and specifies how  many  singular  values  and  vectors  are  to  be
              computed,  whether  the largest or smallest ones, as well as some other parameters for fine tuning
              the computation. Different solvers are available, as in the case of EPS.

       <b>PEP</b>    This component is the analog of EPS for the case  of  Polynomial  Eigenvalue  Problems.  The  user
              provides  the  coefficient  matrices of the polynomial. Several parameters can be specified, as in
              the case of EPS. It is also possible to indicate whether the problem belongs to  a  special  type,
              e.g., symmetric or gyroscopic.

       <b>NEP</b>    This component covers the case of general nonlinear eigenproblems, T(lambda)x=0. The user provides
              the parameter-dependent matrix T via the split form or by means of callback functions.

       <b>MFN</b>    This  component  provides  the  functionality  for  computing the action of a matrix function on a
              vector. Given a matrix A and a vector b, the call MFNSolve(mfn,b,x) computes x=f(A)b, where f is a
              function such as the exponential.

       <b>ST</b>     The Spectral Transformation is a component that  provides  convenient  implementations  of  common
              spectral  transformations.  These  are  simple  transformations  that map eigenvalues to different
              positions, in such a way that convergence to wanted  eigenvalues  is  enhanced.  The  most  common
              spectral  transformation  is  shift-and-invert,  that  allows  for  the computation of eigenvalues
              closest to a given target value.

       <b>BV</b>     This component encapsulates the concept of a set of Basis Vectors spanning a  vector  space.  This
              component  provides  convenient  access to common operations such as orthogonalization of vectors.
              The BV component is usually not required by end-users.

       <b>DS</b>     The Dense System (or Direct Solver) component, used internally to  solve  dense  eigenproblems  of
              small size that appear in the course of iterative eigensolvers.

       <b>FN</b>     A  component  used to define mathematical functions. This is required by the end-user for instance
              to define function T(.) when solving nonlinear eigenproblems with NEP in split form.

       <b>RG</b>     A component used to define a region of the complex plane such as an ellipse or a  rectangle.  This
              is required by end-users in some cases such as contour-integral eigensolvers.

       In  addition  to  the  above  components,  some  extra  functionality is provided in the :Sys: and :Util:
       sections.

   <b>Tutorial</b>
       This tutorial is intended for basic use of slepc4py. For more advanced use, the  reader  is  referred  to
       SLEPc tutorials as well as to slepc4py reference documentation.

   <b>Commented</b> <b>source</b> <b>of</b> <b>a</b> <b>simple</b> <b>example</b>
       In  this  section,  we  include  the  source  code  of  example  <b>demo/ex1.py</b>  available  in  the slepc4py
       distribution, with comments inserted inline.

       The first thing to do is initialize the  libraries.  This  is  normally  not  required,  as  it  is  done
       automatically  at  import  time.  However,  if  you  want  to gain access to the facilities for accessing
       command-line options, the following lines must be executed by the main script prior to  any  petsc4py  or
       slepc4py calls:

          import sys, slepc4py
          slepc4py.init(sys.argv)

       Next,  we have to import the relevant modules. Normally, both PETSc and SLEPc modules have to be imported
       in all slepc4py programs. It may be useful to import NumPy as well:

          from petsc4py import PETSc
          from slepc4py import SLEPc
          import numpy

       At this point, we can use any petsc4py and slepc4py operations. For instance, the following  lines  allow
       the  user  to specify an integer command-line argument <b>n</b> with a default value of 30 (see the next section
       for example usage of command-line options):

          opts = PETSc.Options()
          n = opts.getInt('n', 30)

       It is necessary to build a matrix  to  define  an  eigenproblem  (or  two  in  the  case  of  generalized
       eigenproblems).  The  following  fragment  of  code creates the matrix object and then fills the non-zero
       elements one by one. The matrix of this particular example is tridiagonal, with value 2 in the  diagonal,
       and -1 in off-diagonal positions. See petsc4py documentation for details about matrix objects:

          A = PETSc.Mat().create()
          A.setSizes([n, n])
          A.setFromOptions()
          A.setUp()

          rstart, rend = A.getOwnershipRange()

          # first row
          if rstart == 0:
              A[0, :2] = [2, -1]
              rstart += 1
          # last row
          if rend == n:
              A[n-1, -2:] = [-1, 2]
              rend -= 1
          # other rows
          for i in range(rstart, rend):
              A[i, i-1:i+2] = [-1, 2, -1]

          A.assemble()

       The solver object is created in a similar way as other objects in petsc4py:

          E = SLEPc.EPS(); E.create()

       Once  the  object  is  created,  the  eigenvalue  problem  must be specified. At least one matrix must be
       provided. The problem type must be indicated as well, in  this  case  it  is  HEP  (Hermitian  eigenvalue
       problem).  Apart  from  these, other settings could be provided here (for instance, the tolerance for the
       computation). After all options have been set, the user should call the  <b>setFromOptions()</b>  operation,  so
       that any options specified at run time in the command line are passed to the solver object:

          E.setOperators(A)
          E.setProblemType(SLEPc.EPS.ProblemType.HEP)
          E.setFromOptions()

       After that, the <b>solve()</b> method will run the selected eigensolver, keeping the solution stored internally:

          E.solve()

       Once  the  computation has finished, we are ready to print the results.  First, some informative data can
       be retrieved from the solver object:

          Print = PETSc.Sys.Print

          Print()
          Print("******************************")
          Print("*** SLEPc Solution Results ***")
          Print("******************************")
          Print()

          its = E.getIterationNumber()
          Print("Number of iterations of the method: %d" % its)

          eps_type = E.getType()
          Print("Solution method: %s" % eps_type)

          nev, ncv, mpd = E.getDimensions()
          Print("Number of requested eigenvalues: %d" % nev)

          tol, maxit = E.getTolerances()
          Print("Stopping condition: tol=%.4g, maxit=%d" % (tol, maxit))

       For retrieving the solution, it is necessary to find out  how  many  eigenpairs  have  converged  to  the
       requested precision:

          nconv = E.getConverged()
          Print("Number of converged eigenpairs %d" % nconv)

       For  each  of  the  <b>nconv</b>  eigenpairs,  we  can  retrieve the eigenvalue <b>k</b>, and the eigenvector, which is
       represented by means of two petsc4py vectors <b>vr</b> and <b>vi</b> (the real and imaginary part of  the  eigenvector,
       since  for  real  matrices  the  eigenvalue  and  eigenvector  may  be  complex).   We  also  compute the
       corresponding relative errors in order to make sure that the computed solution is indeed correct:

          if nconv &gt; 0:
              # Create the results vectors
              vr, wr = A.getVecs()
              vi, wi = A.getVecs()
              #
              Print()
              Print("        k          ||Ax-kx||/||kx|| ")
              Print("----------------- ------------------")
              for i in range(nconv):
                  k = E.getEigenpair(i, vr, vi)
                  error = E.computeError(i)
                  if k.imag != 0.0:
                      Print(" %9f%+9f j %12g" % (k.real, k.imag, error))
                  else:
                      Print(" %12f      %12g" % (k.real, error))
              Print()

   <b>Example</b> <b>of</b> <b>command-line</b> <b>usage</b>
       Now we illustrate how to specify command-line options in order to extract the full potential of slepc4py.

       A simple execution of the <b>demo/ex1.py</b> script will result in the following output:

          $ python demo/ex1.py

          ******************************
          *** SLEPc Solution Results ***
          ******************************

          Number of iterations of the method: 4
          Solution method: krylovschur
          Number of requested eigenvalues: 1
          Stopping condition: tol=1e-07, maxit=100
          Number of converged eigenpairs 4

              k          ||Ax-kx||/||kx||
          ----------------- ------------------
               3.989739        5.76012e-09
               3.959060        1.41957e-08
               3.908279        6.74118e-08
               3.837916        8.34269e-08

       For specifying different setting for the solver parameters, we can use SLEPc  command-line  options  with
       the <b>-eps</b> prefix. For instance, to change the number of requested eigenvalues and the tolerance:

          $ python demo/ex1.py -eps_nev 10 -eps_tol 1e-11

       The method used by the solver object can also be set at run time:

          $ python demo/ex1.py -eps_type subspace

       All  the  above  settings  can  also  be  changed within the source code by making use of the appropriate
       slepc4py method. Since options can be set from within the code and the command-line, it is  often  useful
       to view the particular settings that are currently being used:

          $ python demo/ex1.py -eps_view

          EPS Object: 1 MPI process
            type: krylovschur
              50% of basis vectors kept after restart
              using the locking variant
            problem type: symmetric eigenvalue problem
            selected portion of the spectrum: largest eigenvalues in magnitude
            number of eigenvalues (nev): 1
            number of column vectors (ncv): 16
            maximum dimension of projected problem (mpd): 16
            maximum number of iterations: 100
            tolerance: 1e-08
            convergence test: relative to the eigenvalue
          BV Object: 1 MPI process
            type: mat
            17 columns of global length 30
            orthogonalization method: classical Gram-Schmidt
            orthogonalization refinement: if needed (eta: 0.7071)
            block orthogonalization method: GS
            doing matmult as a single matrix-matrix product
          DS Object: 1 MPI process
            type: hep
            solving the problem with: Implicit QR method (_steqr)
          ST Object: 1 MPI process
            type: shift
            shift: 0
            number of matrices: 1

       Note  that for computing eigenvalues of smallest magnitude we can use the option <b>-eps_smallest_magnitude</b>,
       but for interior eigenvalues things are not so straightforward. One possibility is to try  with  harmonic
       extraction, for instance to get the eigenvalues closest to 0.6:

          $ python demo/ex1.py -eps_harmonic -eps_target 0.6

       Depending  on  the  problem, harmonic extraction may fail to converge. In those cases, it is necessary to
       specify a spectral transformation other than the default. In the command-line, this is indicated with the
       <b>-st_</b> prefix. For example, shift-and-invert with a value of the shift equal to 0.6 would be:

          $ python demo/ex1.py -st_type sinvert -eps_target 0.6

   <b>Installation</b>
   <b>Using</b> <b>pip</b> <b>or</b> <b>easy_install</b>
       You can use <b>pip</b> to install <b>slepc4py</b> and its dependencies (<b>mpi4py</b> is optional but highly recommended):

          $ pip install [--user] numpy mpi4py
          $ pip install [--user] petsc petsc4py
          $ pip install [--user] slepc slepc4py

       Alternatively, you can use <b>easy_install</b> (deprecated):

          $ easy_install [--user] slepc4py

       If you already have working PETSc and SLEPc installs, set environment variables <b>SLEPC_DIR</b>  and  <b>PETSC_DIR</b>
       (and perhaps <b>PETSC_ARCH</b> for non-prefix installs) to appropriate values and next use <b>pip</b>:

          $ export SLEPC_DIR=/path/to/slepc
          $ export PETSC_DIR=/path/to/petsc
          $ export PETSC_ARCH=arch-linux2-c-opt
          $ pip install [--user] petsc4py slepc4py

   <b>Using</b> <b>distutils</b>
   <b>Requirements</b>
       You need to have the following software properly installed in order to build <u>SLEPc</u> <u>for</u> <u>Python</u>:

       • Any <u>MPI</u> implementation [1] (e.g., <u>MPICH</u> or <u>Open</u> <u>MPI</u>), built with shared libraries.

       • A matching version of <u>PETSc</u> built with shared libraries.

       • A matching version of <u>SLEPc</u> built with shared libraries.

       • <u>NumPy</u> package.

       • <u>petsc4py</u> package.

       [1]  Unless  you  have  appropriately  configured and built SLEPc and PETSc without MPI (configure option
            <b>--with-mpi=0</b>).

       [2]  You may need to use a parallelized version of the Python interpreter with some MPI-1 implementations
            (e.g. MPICH1).

   <b>Downloading</b>
       The <u>SLEPc</u> <u>for</u> <u>Python</u> package is available for download at the Python Package Index. You can use  <b>curl</b>  or
       <b>wget</b> to get a release tarball.

       • Using <b>curl</b>:

            $ curl -LO https://pypi.io/packages/source/s/slepc4py/slepc4py-X.Y.Z.tar.gz

       • Using <b>wget</b>:

            $ wget https://pypi.io/packages/source/s/slepc4py/slepc4py-X.Y.Z.tar.gz

   <b>Building</b>
       After unpacking the release tarball:

          $ tar -zxf slepc4py-X.Y.tar.gz
          $ cd slepc4py-X.Y

       the distribution is ready for building.

       <b>NOTE:</b>
          <b>Mac</b>  <b>OS</b>  <b>X</b>  users  employing  a  Python distribution built with <b>universal</b> <b>binaries</b> may need to set the
          environment variables <b>MACOSX_DEPLOYMENT_TARGET</b>, <b>SDKROOT</b>, and <b>ARCHFLAGS</b> to appropriate  values.  As  an
          example,  assume your Mac is running <b>Snow</b> <b>Leopard</b> on a <b>64-bit</b> <b>Intel</b> processor and you want to override
          the hard-wired cross-development SDK in Python configuration, your environment should be modified like
          this:

              $ export MACOSX_DEPLOYMENT_TARGET=10.6
              $ export SDKROOT=/
              $ export ARCHFLAGS='-arch x86_64'

       Some environment configuration is needed to inform the location of PETSc and SLEPc. You  can  set  (using
       <b>setenv</b>,  <b>export</b>  or what applies to you shell or system) the environment variables <b>SLEPC_DIR`</b>, <b>PETSC_DIR</b>,
       and <b>PETSC_ARCH</b> indicating where you have built/installed SLEPc and PETSc:

          $ export SLEPC_DIR=/usr/local/slepc
          $ export PETSC_DIR=/usr/local/petsc
          $ export PETSC_ARCH=arch-linux2-c-opt

       Alternatively, you can edit the file <b>setup.cfg</b> and provide the required information  below  the  <b>[config]</b>
       section:

          [config]
          slepc_dir  = /usr/local/slepc
          petsc_dir  = /usr/local/petsc
          petsc_arch = arch-linux2-c-opt
          ...

       Finally, you can build the distribution by typing:

          $ python setup.py build

   <b>Installing</b>
       After building, the distribution is ready for installation.

       If  you have root privileges (either by log-in as the root user of by using <b>sudo</b>) and you want to install
       <u>SLEPc</u> <u>for</u> <u>Python</u> in your system for all users, just do:

          $ python setup.py install

       The    previous    steps    will    install    the    <b>slepc4py</b>    package    at     standard     location
       <u>prefix</u><b>/lib/python</b><u>X</u><b>.</b><u>X</u><b>/site-packages</b>.

       If you do not have root privileges or you want to install <u>SLEPc</u> <u>for</u> <u>Python</u> for your private use, just do:

          $ python setup.py install --user

   <b>Citations</b>
       If  SLEPc  for  Python  been  significant  to  a  project  that  leads to an academic publication, please
       acknowledge that fact by citing the project.

       • L. Dalcin, P. Kler, R. Paz, and A. Cosimo, <u>Parallel</u> <u>Distributed</u> <u>Computing</u>  <u>using</u>  <u>Python</u>,  Advances  in
         Water Resources, <a href="../man9/34.9.html">34</a>(9):1124-1139, 2011.  <u><a href="http://dx.doi.org/10.1016/j.advwatres.2011.04.013">http://dx.doi.org/10.1016/j.advwatres.2011.04.013</a></u>

       • V.  Hernandez,  J.E.  Roman,  and  V. Vidal, <u>SLEPc:</u> <u>A</u> <u>scalable</u> <u>and</u> <u>flexible</u> <u>toolkit</u> <u>for</u> <u>the</u> <u>solution</u> <u>of</u>
         <u>eigenvalue</u>  <u>problems</u>,  ACM   Transactions   on   Mathematical   Software,   <a href="../man3/31.3.html">31</a>(3):351-362,   2005.    ‐
         <u><a href="http://dx.doi.org/10.1145/1089014.1089019">http://dx.doi.org/10.1145/1089014.1089019</a></u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Lisandro Dalcin

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2023, Lisandro Dalcin and Jose Roman

3.2                                               Mar 04, 2025                                       <u><a href="../man1/SLEPC4PY.1.html">SLEPC4PY</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>