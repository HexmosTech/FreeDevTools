<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rc - shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/rc">rc_1.7.4+97.gceb59bb-5build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rc - shell

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>rc</b> [<b>-deiIlnopsvx</b>] [<b>-c</b> <u>command</u>] [<u>arguments</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>rc</u>  is  a  command interpreter and programming language similar to <u><a href="../man1/sh.1.html">sh</a></u>(1).  It is based on the AT&amp;T Plan 9
       shell of the same name.  The shell offers a C-like syntax (much more so than the C shell), and a powerful
       mechanism for manipulating variables.  It is  reasonably  small  and  reasonably  fast,  especially  when
       compared  to  contemporary  shells.  Its use is intended to be interactive, but the language lends itself
       well to scripts.

</pre><h4><b>OPTIONS</b></h4><pre>
       -c0    If -c0 is present, commands are executed from the immediately  following  argument.   Any  further
              arguments to <u>rc</u> are placed in $*.0 Thus:

                   rc -c 'echo $*' 1 2 30

              prints out

                   1 2 30

       -d0    This  flag  causes <u>rc</u> not to ignore SIGQUIT0 or SIGTERM.0 Thus <u>rc</u> can be made to dump core if sent
              SIGQUIT.0 This flag is only useful for debugging <u>rc</u>.

       -e0    If the -e0 flag is present, then <u>rc</u> will exit if any command fails (exits with  non-zero  status).
              However  <u>rc</u>  <u>-e</u>  does  not  exit  if  a  conditional fails. A conditional is the test of an if ()0
              command, the test of a while ()0 command, or the left hand side of the ||0 or the &amp;&amp;0 operator.

       -i0    If the -i0 flag is present or if the input to <u>rc</u> is from a terminal (as determined  by  <u><a href="../man3/isatty.3.html">isatty</a></u>(3))
              then  <u>rc</u> will be in <u>interactive</u> mode.  That is, a prompt (from $<a href="../man1/prompt.1.html">prompt</a>(1))0 will be printed before
              an input line is taken, and <u>rc</u> will ignore SIGINT.0

       -I0    If the -I0 flag is present, or if the input to <u>rc</u> is not from a terminal, then <u>rc</u> will not  be  in
              interactive mode.  No prompts will be printed, and SIGINT0 will cause <u>rc</u> to exit.

       -l0    If  the -l0 flag is present, or if <u>rc</u>'s argv[0][0]0 is a dash (-),0 then <u>rc</u> will behave as a login
              shell.  That is, it will run commands from $home/.rcrc,0 if this file exists, before  reading  any
              other input.

       -n0    This  flag  causes  <u>rc</u>  to  read its input and parse it, but not to execute any commands.  This is
              useful for syntax checking on scripts.  If used in combination with the -x0 flag,  <u>rc</u>  will  print
              each  command  as  it is parsed in a form similar to the one used for exporting functions into the
              environment.

       -o0    This flag prevents the usual practice of trying to open /dev/null0 on file descriptors 0,  1,  and
              2, if any of those descriptors are inherited closed.

       -p0    This  flag  prevents <u>rc</u> from initializing shell functions from the environment.  This allows <u>rc</u> to
              run in a protected mode, whereby it becomes more difficult for an <u>rc</u> script  to  be  subverted  by
              placing  false  commands  in  the environment.  (Note that the presence of this flag does <u>not</u> mean
              that it is safe to run setuid <u>rc</u> scripts; the usual caveats about the setuid bit still apply.)

       -s0    This flag causes <u>rc</u> to read from standard input.  Any arguments are placed in $*.0

       -v0    This flag causes <u>rc</u> to echo its input to standard error as it is read.

       -x0    This flag causes <u>rc</u> to print every command on standard error before it is  executed.   It  can  be
              useful for debugging <u>rc</u> scripts.

</pre><h4><b>COMMANDS</b></h4><pre>
       A  simple  command  is a sequence of words, separated by white space (space and tab) characters that ends
       with a newline, semicolon (;),0 or ampersand (&amp;).0 The first word of  a  command  is  the  name  of  that
       command.   If  the  name  begins  with  /,0  ./,0 or ../,0 then the name is used as an absolute path name
       referring to an executable file.  Otherwise, the name of the command is looked up in  a  table  of  shell
       functions, builtin commands, or as a file in the directories named by $path.0

   <b>Background</b> <b>Tasks</b>
       A  command  ending  with  &amp;0 is run in the background; that is, the shell returns immediately rather than
       waiting for the command to complete.  Background commands have /dev/null0  connected  to  their  standard
       input unless an explicit redirection for standard input is used.

   <b>Subshells</b>
       A  command prefixed with an at-sign (@)0 is executed in a subshell.  This insulates the parent shell from
       the effects of state changing operations such as a <b>cd</b> or a variable assignment.  For example:

            @ {cd ..; make}0

       will run <u><a href="../man1/make.1.html">make</a></u>(1) in the parent directory (..),0 but leaves the shell running in the current directory.

   <b>Line</b> <b>continuation</b>
       A long logical line may be continued over several physical lines by terminating  each  line  (except  the
       last)  with  a  backslash (\).0 The backslash-newline sequence is treated as a space.  A backslash is not
       otherwise special to <u>rc</u>.  (In addition, inside quotes a backslash loses its special meaning even when  it
       is followed by a newline.)

   <b>Quoting</b>
       <u>rc</u>  interprets  several  characters  specially;  special  characters  automatically terminate words.  The
       following characters are special:

            # ; &amp; | ^ $ ` ' { } ( ) &lt; &gt;0

       The single quote (')0 prevents special treatment of any character other  than  itself.   All  characters,
       including  control  characters,  newlines, and backslashes between two quote characters are treated as an
       uninterpreted string.  A quote character itself may be quoted by  placing  two  quotes  in  a  row.   The
       minimal  sequence  needed  to enter the quote character is ''''.0 The empty string is represented by ''.0
       Thus:

            echo 'What''s the plan, Stan?'0

       prints out

            What's the plan, Stan?0

       The number sign (#)0 begins a comment in <u>rc</u>.  All characters up to but not including the next newline are
       ignored.  Note that backslash continuation does not work inside a comment, i.e., the backslash is ignored
       along with everything else.

   <b>Grouping</b>
       Zero or more commands may be grouped within braces (“{”0 and “}”),0 and are then treated as one  command.
       Braces do not otherwise define scope; they are used only for command grouping.  In particular, be wary of
       the command:

            for (i) {0
                command0
            } | command0

       Since  pipe binds tighter than for,0 this command does not perform what the user expects it to.  Instead,
       enclose the whole for0 statement in braces:

            {for (i) command} | command0

       Fortunately, <u>rc</u>'s grammar is simple enough that a (confident) user can understand  it  by  examining  the
       skeletal <u><a href="../man1/yacc.1.html">yacc</a></u>(1) grammar at the end of this man page (see the section entitled <b>GRAMMAR</b>).

   <b>Input</b> <b>and</b> <b>output</b>
       The standard output may be redirected to a file with

            command &gt; file0

       and the standard input may be taken from a file with

            command &lt; file0

       Redirections  can  appear anywhere in the line: the word following the redirection symbol is the filename
       and must be quoted if it contains spaces or other special characters.  These are all equivalent.

            echo 1 2 3 &gt; foo0
            &gt; foo echo 1 2 30
            echo 1 2 &gt; foo 30

       File descriptors other than 0 and 1 may be specified also.  For example, to redirect standard error to  a
       file, use:

            command &gt;[2] file0

       In  order to duplicate a file descriptor, use &gt;[<u>n</u>=<u>m</u>].0 Thus to redirect both standard output and standard
       error to the same file, use

            command &gt; file &gt;[2=1]0

       As in <u>sh</u>, redirections are processed from left to right.  Thus this sequence

            command &gt;[2=1] &gt; file0

       is usually a mistake.  It first duplicates standard error to standard  output;  then  redirects  standard
       output to a file, leaving standard error wherever standard output originally was.

       To close a file descriptor that may be open, use &gt;[<u>n</u>=].0 For example, to close file descriptor 7:

            command &gt;[7=]0

       Note that no spaces may appear in these constructs:

            command &gt; [2] file0

       would  send  the  output of the command to a file named [2],0 with the intended filename appearing in the
       command's argument list.

       In order to place the output of a command at the end of an already existing file, use:

            command &gt;&gt; file0

       If the file does not exist, then it is created.

       “Here documents” are supported as in <u>sh</u> with the use of

            command &lt;&lt; 'eof-marker'0

       Subsequent lines form the standard input of the command, till a line containing just the marker, in  this
       case eof-marker,0 is encountered.

       If  the  end-of-file  marker  is enclosed in quotes, then no variable substitution occurs inside the here
       document.  Otherwise, every variable is substituted by its space-separated-list value  (see  <b>Flat</b>  <b>Lists</b>,
       below), and if a ^0 character follows a variable name, it is deleted.  This allows the unambiguous use of
       variables adjacent to text, as in

            $variable^follow0

       To include a literal $0 in a here document when an unquoted end-of-file marker is being used, enter it as
       $$.0

       Additionally,  <u>rc</u>  supports  “here  strings”,  which  are like here documents, except that input is taken
       directly from a string on the command line.  Their use is illustrated here:

            cat &lt;&lt;&lt; 'this is a here string' | wc0

       (This feature enables <u>rc</u> to export functions using here documents into the environment; the  author  does
       not expect users to find this feature useful.)

   <b>Pipes</b>
       Two  or  more  commands may be combined in a pipeline by placing the vertical bar (|)0 between them.  The
       standard output (file descriptor 1) of the command on the left  is  tied  to  the  standard  input  (file
       descriptor  0) of the command on the right.  The notation |[<u>n</u>=<u>m</u>]0 indicates that file descriptor <u>n</u> of the
       left process is connected to file descriptor <u>m</u> of the right process.  |[<u>n</u>]0 is a shorthand  for  |[<u>n</u>=0].0
       As an example, to pipe the standard error of a command to <u><a href="../man1/wc.1.html">wc</a></u>(1), use:

            command |[2] wc0

       As with file redirections, no spaces may occur in the construct specifying numbered file descriptors.

       The exit status of a pipeline is considered true if and only if every command in the pipeline exits true.

   <b>Commands</b> <b>as</b> <b>Arguments</b>
       Some  commands,  like  <u><a href="../man1/cmp.1.html">cmp</a></u>(1) or <u><a href="../man1/diff.1.html">diff</a></u>(1), take their arguments on the command line, and do not read input
       from standard input.  It is convenient sometimes to build nonlinear pipelines so that a command like  <u>cmp</u>
       can read the output of two other commands at once.  <u>rc</u> does it like this:

            cmp &lt;{command} &lt;{command}0

       compares  the  output of the two commands in braces.  Note: since this form of redirection is implemented
       with some kind of pipe, and since one cannot <u><a href="../man2/lseek.2.html">lseek</a></u>(2) on a pipe, commands that use  <u><a href="../man2/lseek.2.html">lseek</a></u>(2)  will  hang.
       For example, some versions of <u><a href="../man1/diff.1.html">diff</a></u>(1) use <u><a href="../man2/lseek.2.html">lseek</a></u>(2) on their inputs.

       Data can be sent down a pipe to several commands using <u><a href="../man1/tee.1.html">tee</a></u>(1) and the output version of this notation:

            echo hi there | tee &gt;{sed 's/^/p1 /'} &gt;{sed 's/^/p2 /'}0

</pre><h4><b>CONTROL</b> <b>STRUCTURES</b></h4><pre>
       The following may be used for control flow in <u>rc</u>:

   <b>If-Else</b> <b>Statements</b>
       if (<u>test</u>) {0
           <u>cmd</u>
       } else <u>cmd</u>0
              The  <u>test</u>  is executed, and if its return status is zero, the first command is executed, otherwise
              the second is.  Braces are not mandatory around the commands.   However,  an  else0  statement  is
              valid  only  if  it  follows  a close-brace on the same line.  Otherwise, the if0 is taken to be a
              simple-if:

                   if (test)0
                       command0

   <b>While</b> <b>and</b> <b>For</b> <b>Loops</b>
       while (<u>test</u>) <u>cmd</u>0
              <u>rc</u> executes the <u>test</u> and performs the command as long as the <u>test</u> is true.

       for (<u>var</u> in <u>list</u>) <u>cmd</u>0
              <u>rc</u> sets <u>var</u> to each element of <u>list</u> (which may contain variables and backquote substitutions)  and
              runs <u>cmd</u>.  If “in0 <u>list</u>” is omitted, then <u>rc</u> will set <u>var</u> to each element of $*.0 For example:

                   for (i in `{ls -F | grep '\*$' | sed 's/\*$//'}) { commands }0

              will set $i0 to the name of each file in the current directory that is executable.

   <b>Switch</b>
       switch (<u>list</u>) { case <u>...</u> }0
              <u>rc</u> looks inside the braces after a switch0 for statements beginning with the word case.0 If any of
              the  patterns  following  case0 match the list supplied to switch,0 then the commands up until the
              next case0 statement are executed.  The metacharacters *,0 [0 or ?0 should not be quoted; matching
              is performed only against the strings in  <u>list</u>,  not  against  file  names.   (Matching  for  case
              statements is the same as for the ~0 command.)

   <b>Logical</b> <b>Operators</b>
       There are a number of operators in <u>rc</u> which depend on the exit status of a command.

            command &amp;&amp; command0

       executes  the  first  command and then executes the second command if and only if the first command exits
       with a zero exit status (“true” in Unix).

            command || command0

       executes the first command and then executes the second command if and only if the  first  command  exits
       with a nonzero exit status (“false” in Unix).

            ! command0

       negates the exit status of a command.

</pre><h4><b>PATTERN</b> <b>MATCHING</b></h4><pre>
       There  are  two  forms  of  pattern  matching  in <u>rc</u>.  One is traditional shell globbing.  This occurs in
       matching for file names in argument lists:

            command argument argument ...0

       When the characters *,0 [0 or ?0 occur in an argument or command, <u>rc</u> looks at the argument as  a  pattern
       for matching against files.  (Contrary to the behavior other shells exhibit, <u>rc</u> will only perform pattern
       matching if a metacharacter occurs unquoted and literally in the input.  Thus,

            foo='*'0
            echo $foo0

       will always echo just a star.  In order for non-literal metacharacters to be expanded, an eval0 statement
       must  be used in order to rescan the input.)  Pattern matching occurs according to the following rules: a
       *0 matches any number (including zero) of characters.  A ?0  matches  any  single  character,  and  a  [0
       followed  by a number of characters followed by a ]0 matches a single character in that class.  The rules
       for character class matching are the same as those for <u><a href="../man1/ed.1.html">ed</a></u>(1), with the  exception  that  character  class
       negation  is  achieved  with  the tilde (~),0 not the caret (^),0 since the caret already means something
       else in <u>rc</u>.

       <u>rc</u> also matches patterns against strings with the ~0 command:

            ~ subject pattern pattern ...0

       The ~0 command succeeds (sets $status0 to zero) if and only if one of  the  patterns0  matches  subject.0
       Thus

            ~ foo f*0

       succeeds (sets status to zero), while

            ~ bar f*0

       fails (sets status to one).

       The null list is matched by the null list, so

            ~ $foo ()0

       checks  to  see  whether $foo0 is empty or not. Because <u>rc</u> does not have hierarchical lists, the test for
       emptiness cannot be combined with other tests. To test whether $foo0 is empty,  or  one  of  the  strings
       nada0 or rien,0 do <u>not</u> write

            ~ $x () nada rien # WRONG means the same as: ~ $x nada rien0

       instead write

            ~ $x () || ~ $x nada rien0

       Another way to test if $foo0 is empty is

            ~ $#foo 00

       Note  that  inside  a ~0 command <u>rc</u> does not match patterns against file names, so it is not necessary to
       quote the characters *,0 [0 and ?.0 However, <u>rc</u> does expand the subject against filenames if it  contains
       metacharacters.  Thus, the command

            ~ * ?0

       succeeds if any of the files in the current directory have a single-character name.

       If  the  ~0  command  is  given  a list as its first argument, then a successful match against any of the
       elements of that list will cause ~0 to succeed.  For example:

            ~ (foo goo zoo) z*0

       is true.

</pre><h4><b>LISTS</b> <b>AND</b> <b>VARIABLES</b></h4><pre>
       The primary data structure in <u>rc</u> is the list, which is a sequence of  words.   Parentheses  are  used  to
       group  lists.   The empty list is represented by ().0 Lists have no hierarchical structure; a list inside
       another list is expanded so the outer list contains all the  elements  of  the  inner  list.   Thus,  the
       following are all equivalent

            one two three0

            (one two three)0

            ((one) () ((two three)))0

       Note  that  the  null  string, '',0 and the null list, (),0 are two very different things.  Assigning the
       null string to a variable is a valid operation, but it does not remove its definition.

            null = '' empty = () echo $#null $#empty0

       produces the output

            1 00

   <b>List</b> <b>Concatenation</b>
       Two lists may be joined by  the  concatenation  operator  (^).0  Concatenation  works  according  to  the
       following rules: if the two lists have the same number of elements, then concatenation is pairwise:

            echo (a- b- c-)^(1 2 3)0

       produces the output

            a-1 b-2 c-30

       Otherwise,  at  least  one  of  the  lists  must  have  a  single  element, and then the concatenation is
       distributive:

            cc -^(O g c) (malloc alloca)^.c0

       has the effect of performing the command

            cc -O -g -c malloc.c alloca.c0

       A single word is a list of length one, so

            echo foo^bar0

       produces the output

            foobar0

   <b>Free</b> <b>Carets</b>
       <u>rc</u> inserts carets (concatenation operators) for free in certain situations, in order to save some  typing
       on the user's behalf.  For example, the above example could also be typed in as:

            opts=(O g c) files=(malloc alloca) cc -$opts $files.c0

       <u>rc</u>  takes  care to insert a free caret between the ``-''0 and $opts,0 as well as between $files0 and .c.0
       The rule for free carets is as follows: if a word or keyword is immediately  followed  by  another  word,
       keyword, dollar-sign or backquote, then <u>rc</u> inserts a caret between them.

   <b>Variables</b>
       A list may be assigned to a variable, using the notation:

            <u>var</u> = <u>list</u>0

       The special variable *0 may also be assigned to using this notation; <u>rc</u> has no <b>set</b> builtin.

       Any  non-empty sequence of characters, except a sequence including only digits, may be used as a variable
       name.  Any character except =0 may be used, but special characters  must  be  quoted.   All  user-defined
       variables are exported into the environment.

       The value of a variable is referenced with the dollar ($)0 operator:

            $<u>var</u>0

       Any  variable  which has not been assigned a value returns the null list, (),0 when referenced.  Multiple
       references are allowed:

            a = foo0
            b = a0
            echo $ $ b0

       prints

            foo0

       A variable's definition may also be removed by assigning the null list to a variable:

            <u>var</u>=()0

       For “free careting” to work correctly, <u>rc</u> must make certain assumptions about what characters may  appear
       in a variable name.  <u>rc</u> assumes that a variable name consists only of alphanumeric characters, underscore
       (_)0  and  star (*).0 To reference a variable with other characters in its name, quote the variable name.
       Thus:

            echo $'we$Ird:Variab!le'0

   <b>Local</b> <b>Variables</b>
       Any number of variable assignments may be made local to a single command by typing:

            a=foo b=bar ... command0

       The command may be a compound command, so for example:

            path=. ifs=() {0
                ...0
            }0

       sets path0 to .0 and removes ifs0 for the duration of one long compound command.

   <b>Variable</b> <b>Subscripts</b>
       Variables may be subscripted with the notation

            $var(<u>n</u>)0

       where <u>n</u> is a list of integers (origin 1).  The opening parenthesis must immediately follow  the  variable
       name.  The list of subscripts need not be in order or even unique.  Thus,

            a=(one two three)0
            echo $a(3 3 3)0

       prints

            three three three0

       If <u>n</u> references a nonexistent element, then $var(<u>n</u>)0 returns the null list.  The notation $<u>n</u>,0 where <u>n</u> is
       an integer, is a shorthand for $*(<u>n</u>).0 Thus, <u>rc</u>'s arguments may be referred to as $1,0 $2,0 and so on.

       Note also that the list of subscripts may be given by any of <u>rc</u>'s list operations:

            $var(`{awk 'BEGIN{for(i=1;i&lt;=10;i++)print i;exit; }'})0

       returns the first 10 elements of $var.0

       To count the number of elements in a variable, use

            $#var0

       This returns a single-element list, with the number of elements in $var.0

   <b>Flat</b> <b>Lists</b>
       In  order to create a single-element list from a multi-element list, with the components space-separated,
       use the dollar-caret ($^)0 operator:

            $^var0

       This is useful when the normal list concatenation rules need to be bypassed.  For example,  to  append  a
       single period at the end of $path,0 use:

            echo $^path.0

       For compatibility with the Plan 9 rc,

            $"var0

       is accepted as a synonym for dollar-caret.

   <b>Backquote</b> <b>Substitution</b>
       A list may be formed from the output of a command by using backquote substitution:

            `{ command }0

       returns  a  list  formed  from  the standard output of the command in braces.  $ifs0 is used to split the
       output into list elements.  By default, $ifs0 has the value space-tab-newline.

       The braces may be omitted if the command is a single word.  Thus `ls0 may be used instead of `{ls}.0 This
       last feature can be used to create shortcuts by defining functions that expand to useful argument  lists.
       For example:

            fn src { echo *.[chy] }0

       followed by

            wc `src0

       This will print out a word-count of all C source files in the current directory.

       In order to override the value of $ifs0 for a single backquote substitution, use:

            `` (ifs-list) { command }0

       $ifs0  will  be  temporarily  ignored  and  the  command's  output will be split as specified by the list
       following the double backquote.  For example:

            `` ($nl :) {cat <a href="file:/etc/passwd">/etc/passwd</a>}0

       splits up /etc/passwd0 into fields.

       As a convenience, <u>rc</u> defines $nl0 to contain  the  newline  character,  and  $tab0  to  contain  the  tab
       character.  Thus,  if you want to process everything in the current directory, but in a random order, you
       could use:

            for (f in `` $nl {ls | shuf}) { ... process $f }0

       This will correctly handle filenames that contain spaces.

       Note that <u>rc</u> scripts that use backquote substitution should avoid relying on the default values of $ifs,0
       $nl,0 or $tab.0 Instead, they should explicitly set what they need.

</pre><h4><b>SPECIAL</b> <b>VARIABLES</b></h4><pre>
       Several variables are known to <u>rc</u> and are treated specially.  In the following list, “default”  indicates
       that  <u>rc</u>  gives the variable a default value on startup; “no-export” indicates that the variable is never
       exported; and “read-only” indicates that an attempt to set the variable will silently have no effect.

       Also, “alias” means that the variable is  aliased  to  the  same  name  in  capitals.   For  example,  an
       assignment  to  $cdpath0  causes an automatic assignment to $CDPATH,0 and vice-versa.  If $CDPATH0 is set
       when <u>rc</u> is started, its value is imported into $cdpath.0 $cdpath0 and $path0 are <u>rc</u> lists;  $CDPATH0  and
       $PATH0 are colon-separated lists.  Only the names spelt in capitals are exported into the environment.

       * (no-export)0
              The argument list of <u>rc</u>.  $1, $2,0 etc. are the same as $*(1),0 $*(2),0 etc.

       0 (default no-export)0
              The  variable $00 holds the value of argv[0]0 with which <u>rc</u> was invoked.  Additionally, $00 is set
              to the name of a function for the duration of the execution of that function, and $00 is also  set
              to the name of the file being interpreted for the duration of a .0 command.  $00 is not an element
              of $*,0 and is never treated as one.

       apid (no-export)0
              The process ID of the last process started in the background.

       apids (no-export read-only)0
              A  list  whose  elements are the process IDs of all background processes which are still alive, or
              which have died and have not been waited for yet.

       bqstatus (no-export)0
              The exit status of the <u>rc</u> forked to execute the most recent  backquote  substitution.  Note  that,
              unlike $status,0 $bqstatus0 is always a single element list (see <b>EXIT</b> <b>STATUS</b> below). For example:

                   echo foo |grep bar; whatis status0

              prints

                   status=(0 1)0

              whereas

                   x=`{echo foo |grep bar}; whatis bqstatus0

              prints

                   bqstatus=10

       cdpath (alias)0
              A  list  of directories to search for the target of a <b>cd</b> command.  The empty string stands for the
              current directory.  Note that if the $cdpath0 variable does not  contain  the  current  directory,
              then  the  current  directory  will not be searched; this allows directory searching to begin in a
              directory other than the current directory.

       history0
              $history0 contains the name of a file to which commands are  appended  as  <u>rc</u>  reads  them.   This
              facilitates  the  use  of  a  stand-alone  history  program  (such as <u><a href="../man1/history.1.html">history</a></u>(1)) which parses the
              contents of the history file and presents them to <u>rc</u> for reinterpretation.  If  $history0  is  not
              set, then <u>rc</u> does not append commands to any file.

       home (alias)0
              The  default directory for the builtin <b>cd</b> command, and the directory in which <u>rc</u> looks to find its
              initialization file, .rcrc,0 if <u>rc</u> has been started up as a login shell.

       ifs (default)0
              The internal field separator, used for splitting up the output of backquote commands for digestion
              as a list. On startup, <u>rc</u> assigns the list containing the characters space, tab,  and  newline  to
              $ifs.0

       nl (default)0
              Contains the newline character (see <b>Backquote</b> <b>substitution</b> above).

       path (alias)0
              This  is a list of directories to search in for commands.  The empty string stands for the current
              directory.  If neither $PATH0 nor $path0 is set at startup time, $path0 assumes  a  default  value
              suitable for your system.  This is typically (<a href="file:/usr/local/bin">/usr/local/bin</a> <a href="file:/usr/bin">/usr/bin</a> /usr/ucb <a href="file:/bin">/bin</a> .)0

       pid (default no-export)0
              On startup, $pid0 is initialized to the numeric process ID of the currently running <u>rc</u>.

       prompt (default)0
              This  variable  holds  the  two  prompts (in list form, of course) that <u>rc</u> prints.  $<a href="../man1/prompt.1.html">prompt</a>(1)0 is
              printed before each command is read, and $<a href="../man2/prompt.2.html">prompt</a>(2)0 is printed when input is expected to continue
              on the next line.  <u>rc</u> sets $prompt0 to ('; ' '')0 by default.  The reason  for  this  is  that  it
              enables  an  <u>rc</u> user to grab commands from previous lines using a mouse, and to present them to <u>rc</u>
              for re-interpretation; the semicolon prompt is simply ignored by <u>rc</u>.  The  null  $<a href="../man2/prompt.2.html">prompt</a>(2)0  also
              has its justification: an <u>rc</u> script, when typed interactively, will not leave $<a href="../man2/prompt.2.html">prompt</a>(2)'s0 on the
              screen, and can therefore be grabbed by a mouse and placed directly into a file for use as a shell
              script, without further editing being necessary.

       prompt (function)0
              If this function is defined, then it gets executed every time <u>rc</u> is about to print $<a href="../man1/prompt.1.html">prompt</a>(1).0

       status (no-export read-only)0
              The  exit  status of the last command.  If the command exited with a numeric value, that number is
              the status.  If the command died with a signal, the status is the name of that signal; if  a  core
              file  was  created,  the  string  “+core”0 is appended.  The value of $status0 for a pipeline is a
              list, with one entry, as above, for each process in the pipeline.  For example, the command

                   ls | wc0

              usually sets $status0 to (0 0).0

       tab (default)0
              Contains the tab character (see <b>Backquote</b> <b>substitution</b> above).

       version (default)0
              On startup, the first element of this list variable is initialized to a  string  which  identifies
              this  version of <u>rc</u>.  The second element is initialized to a string which can be found by <u><a href="../man1/ident.1.html">ident</a></u>(1)
              and the <u>what</u> command of <u><a href="../man1/sccs.1.html">sccs</a></u>(1).

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <u>rc</u> functions are identical to <u>rc</u> scripts, except that they are stored in  memory  and  are  automatically
       exported into the environment.  A shell function is declared as:

            fn name { commands }0

       <u>rc</u> scans the definition until the close-brace, so the function can span more than one line.  The function
       definition may be removed by typing

            fn name0

       (One  or  more  names  may  be  specified.   With  an accompanying definition, all names receive the same
       definition.  This is sometimes useful for assigning the same signal handler to many signals.   Without  a
       definition,  all  named functions are deleted.)  When a function is executed, $*0 is set to the arguments
       to that function for the duration of the command.  Thus a reasonable definition for l,0 a  shorthand  for
       <u><a href="../man1/ls.1.html">ls</a></u>(1), could be:

            fn l { ls -FC $* }0

       but not

            fn l { ls -FC } # WRONG0

</pre><h4><b>INTERRUPTS</b> <b>AND</b> <b>SIGNALS</b></h4><pre>
       <u>rc</u>  recognizes  a  number  of  signals, and allows the user to define shell functions which act as signal
       handlers.  <u>rc</u> by default traps SIGINT0 when it  is  in  interactive  mode.   SIGQUIT0  and  SIGTERM0  are
       ignored,  unless  <u>rc</u>  has  been  invoked with the -d0 flag.  However, user-defined signal handlers may be
       written for these and all other signals.  The way to define a signal handler is to write  a  function  by
       the name of the signal in lower case.  Thus:

            fn sighup { echo hangup; rm /tmp/rc$pid.*; exit }0

       In  addition to Unix signals, <u>rc</u> recognizes the artificial signal SIGEXIT0 which occurs as <u>rc</u> is about to
       exit.

       In order to remove a signal handler's definition, remove it as though it were a  regular  function.   For
       example:

            fn sigint0

       returns  the  handler  of  SIGINT0  to  the  default  value.  In order to ignore a signal, set the signal
       handler's value to {}.0 Thus:

            fn sigint {}0

       causes SIGINT0 to be ignored by the shell.  Only signals that are being ignored are passed on to programs
       run by <u>rc</u>; signal functions are not exported.

       On System V-based Unix systems, <u>rc</u> will not allow you to trap SIGCLD.0

</pre><h4><b>BUILTIN</b> <b>COMMANDS</b></h4><pre>
       Builtin commands execute in the context of the shell, but otherwise behave exactly like  other  commands.
       Although <b>!</b>, <b>~</b> and <b>@</b> are not strictly speaking builtin commands, they can usually be used as such.

       <b>.</b> [<b>-i</b>] <u>file</u> [<u>arg</u> <u>...</u>]
              Reads <u>file</u> as input to <u>rc</u> and executes its contents.  With a -i0 flag, input is interactive.  Thus
              from within a shell script,

                   . -i /dev/tty0

              does the “right thing”.

       <b>break</b>  Breaks  from  the  innermost for0 or while,0 as in C.  It is an error to invoke <b>break</b> outside of a
              loop.  (Note that there is no <b>break</b> keyword between commands in switch0 statements, unlike C.)

       <b>builtin</b> <u>command</u> [<u>arg</u> <u>...</u>]
              Executes the command ignoring any function definition of the same name.  This command  is  present
              to  allow  functions with the same names as builtins to use the underlying builtin or binary.  For
              example:

                   fn ls { builtin ls -FC $* }0

              is a reasonable way to pass a default set of arguments to <a href="../man1/ls.1.html">ls</a>(1),0 whereas

                   fn ls { ls -FC $* } # WRONG0

              is a non-terminating recursion, which will cause rc0 to exhaust its stack space  and  (eventually)
              terminate if it is executed.

       <b>cd</b> [<u>directory</u>]
              Changes  the  current  directory  to  <u>directory</u>.   The  variable $cdpath0 is searched for possible
              locations of <u>directory</u>, analogous to the searching  of  $path0  for  executable  files.   With  no
              argument, <b>cd</b> changes the current directory to $home.0

       <b>continue</b>
              Continues  the  innermost for0 or while0 loop, as in C.  It is an error to invoke <b>continue</b> outside
              of a loop.

       <b>echo</b> [<b>-n</b>] [<b>--</b>] [<u>arg</u> <u>...</u>]
              Prints its arguments to standard output, terminated by a  newline.   Arguments  are  separated  by
              spaces.   If the first argument is -n0 no final newline is printed.  If the first argument is --,0
              then all other arguments are echoed literally.  This is used for echoing a literal -n.0

       <b>eval</b> [<u>list</u>]
              Concatenates the elements of <u>list</u> with spaces and  feeds  the  resulting  string  to  <u>rc</u>  for  re-
              scanning.  This is the only time input is rescanned in <u>rc</u>.

       <b>exec</b> [<u>arg</u> <u>...</u>]
              Replaces  <u>rc</u>  with  the  given  command.   If  the  exec  contains  only  redirections, then these
              redirections apply to the current shell and the shell does not exit.  For example,

                   exec &gt;[2] err.out0

              places further output to standard error in the file <u>err.out</u>.

       <b>exit</b> [<u>status</u>]
              Cause the current shell to exit with the given exit <u>status</u>.  If no argument is given, the  current
              value of $status0 is used.

       <b>flag</b> <u>f</u> [ <b>+</b> | <b>-</b> ]
              Test,  set  (<b>+</b>),  or reset (<b>-</b>) command-line flag <u>f</u>.  For example, a script that requires ``exit if
              command fails'' semantics can say

                   flag e +0

              Some flags cannot be set or reset using <b>flag</b>, but they can still be tested. These are <b>c</b>, <b>d</b>, <b>l</b>,  <b>o</b>,
              <b>p</b>,  and  <b>s</b>.  As a special case, flag i0 operates on <b>rc</b>'s internal <u>interactive</u> flag, which may have
              been set by -i0 on the command line, or if standard input was a terminal; there is no flag I.0

       <b>limit</b> [<b>-h</b>] [<u>resource</u> [<u>value</u>]]
              Similar to the <u><a href="../man1/csh.1.html">csh</a></u>(1) <b>limit</b> builtin, this command operates upon the BSD-style resource limits of a
              process.  The -h0 flag displays/alters the hard limits.  The  resources  which  can  be  shown  or
              altered are <b>cputime</b>, <b>filesize</b>, <b>datasize</b>, <b>stacksize</b>, <b>coredumpsize</b>, <b>memoryuse</b>, and, where supported,
              <b>descriptors</b>, <b>memoryuse</b>, <b>memoryrss</b>, <b>maxproc</b>, <b>memorylocked</b>, and <b>filelocks</b>.  For example:

                   limit coredumpsize 00

              disables core dumps.  To set a soft limit equal to the hard limit:

                   limit `{limit -h datasize}0

       <b>newpgrp</b>
              Puts  <u>rc</u> into a new process group.  This builtin is useful for making <u>rc</u> behave like a job-control
              shell in a hostile environment.  One example  is  the  NeXT  Terminal  program,  which  implicitly
              assumes that each shell it forks will put itself into a new process group.

       <b>return</b> [<u>n</u>]
              Returns  from  the  current  function, with status <u>n</u>, where <u>n</u> is a valid exit status, or a list of
              them.  Thus it is legal to have

                   return (sigpipe 1 2 3)0

              (This is commonly used to allow a function to return with the exit status of a previously executed
              pipeline of commands.)  If <u>n</u> is omitted, then $status0 is left  unchanged.   It  is  an  error  to
              invoke <b>return</b> when not inside a function.

       <b>shift</b> [<u>n</u>]
              Deletes  <u>n</u> elements from the beginning of $*0 and shifts the other elements down by <u>n</u>.  <u>n</u> defaults
              to 1.

       <b>umask</b> [<u>mask</u>]
              Sets the current umask (see <u><a href="../man2/umask.2.html">umask</a></u>(2)) to the octal <u>mask</u>.  If no argument is present,  the  current
              mask value is printed.

       <b>wait</b> [<u>pid</u>]
              Waits  for process with the specified <u>pid</u>, which must have been started by <u>rc</u>, to exit.  If no <u>pid</u>
              is specified, <u>rc</u> waits for all its child processes to exit.

       <b>whatis</b> [<b>-b</b>] [<b>-f</b>] [<b>-p</b>] [<b>-s</b>] [<b>-v</b>] [<b>--</b>] [<u>name</u> <u>...</u>]
              Prints a definition of the named objects.  For builtins, builtin0 <u>foo</u> is printed;  for  functions,
              including  signal  handlers,  their  definitions are printed; for executable files, path names are
              printed; and for variables, their values are printed.  The  flags  restrict  output  to  builtins,
              functions,  executable  programs,  signal  handlers, and variables, respectively.  If no <u>name</u>s are
              specified, <u>rc</u> lists all objects of that type.  (This is not permitted for -p.)0 Without arguments,
              whatis0 is equivalent to whatis -fv,0 and prints the values of all shell variables and functions.

              Note that <b>whatis</b> output is suitable for input to <u>rc</u>; by saving the output of <b>whatis</b> in a file,  it
              should  be  possible to recreate the state of <u>rc</u> by sourcing this file with a .0 command.  Another
              note: whatis -s &gt; file0 cannot be used to store the state of  <u>rc</u>'s  signal  handlers  in  a  file,
              because  builtins  with redirections are run in a subshell, and <u>rc</u> always restores signal handlers
              to their default value after a fork().0

              Since <b>whatis</b> uses <u><a href="../man3/getopt.3.html">getopt</a></u>(3) to parse its arguments, you  can  use  the  special  argument  --0  to
              terminate  its  flags.  This allows you to use names beginning with a dash, such as the <u><a href="../man1/history.1.html">history</a></u>(1)
              commands.  For example,

                   whatis -- -p0

</pre><h4><b>EXAMPLES</b></h4><pre>
       The <b>shift</b> builtin only shifts $*.0 This function can shift any variable (except $_lshift).0

            fn lshift { _lshift=$* *=$$1 { shift $<a href="../man2/_lshift.2.html">_lshift</a>(2); $<a href="../man1/_lshift.1.html">_lshift</a>(1)=$* } }0

       With this definition in place,

            walrus = (shoes ships sealing-wax cabbages kings)0
            lshift walrus 30
            whatis walrus0

       prints

            walrus=(cabbages kings)0

       The $^var0 operator flattens a list by separating each element with a space.  This  function  allows  the
       separator to be an arbitrary string.

            fn lflat {0
              lflat=$*; *=$$10
              while () {0
                echo -n $1; shift0
                ~ $#* 0 &amp;&amp; break0
                echo -n $<a href="../man2/lflat.2.html">lflat</a>(2)0
              }0
            }0

       With this definition in place,

            hops=(uunet mcvax ukc tlg)0
            lflat hops !0

       prints (with no final newline)

            uunet!mcvax!ukc!tlg0

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The exit status of <u>rc</u> is normally the same as that of the last command executed.  If the last command was
       a pipeline, <u>rc</u> exits 00 if every command in the pipeline did; otherwise it exits 1.0

       <u>rc</u> can be made to exit with a particular status using the <b>exit</b> builtin.

</pre><h4><b>LINE</b> <b>EDITING</b></h4><pre>
       <u>rc</u>  is typically built against a line editing library.  On GNU/Linux systems this will usually be the GNU
       <u>readline</u> library.  On *BSD systems it is more likely to be the BSD <u>editline</u> library.  Please consult  the
       appropriate library documentation for details of how to use and configure line editing.

   <b>Tilde</b> <b>Expansion</b>
       Since  <u>rc</u>  does  not support tilde expansion (converting ~foo0 to the home directory of user foo),0 it is
       sometimes suggested by users as a possible enhancement.  The authors and maintainers of <u>rc</u> have  a  proud
       history  of  resisting  such  feature  requests.  So it is worth noting here that GNU <u>readline</u> can expand
       tildes.  Add this line to the file .inputrc0 in your home directory.

            set expand-tilde on0

       and then use the key sequence M-~0 to perform tilde expansion on the  current  word.   See  the  <u>readline</u>
       documentation for further details.

</pre><h4><b>GRAMMAR</b></h4><pre>
       Here is <u>rc</u>'s grammar, edited to remove semantic actions.

            %term ANDAND BACKBACK BANG CASE COUNT DUP ELSE END FLAT FN FOR IF IN
            %term OROR PIPE REDIR SUB SUBSHELL SWITCH TWIDDLE WHILE WORD HUH

            %left '^' '='
            %left WHILE ')' ELSE
            %left ANDAND OROR '\n'
            %left BANG SUBSHELL
            %left PIPE
            %right '$'
            %left SUB

            %start rc

            %%

            rc: line end
                 | error end

            end: END /* EOF */ | '\n'

            cmdsa: cmd ';' | cmd '&amp;'

            line: cmd | cmdsa line

            body: cmd | cmdsan body

            cmdsan: cmdsa | cmd '\n'

            brace: '{' body '}'

            paren: '(' body ')'

            assign: first optcaret '=' optcaret word

            epilog: /* empty */ | redir epilog

            redir: DUP | REDIR word

            case: CASE words ';' | CASE words '\n'

            cbody: cmd | case cbody | cmdsan cbody

            iftail: cmd    %prec ELSE
                 | brace ELSE optnl cmd

            cmd  : /* empty */  %prec WHILE
                 | simple
                 | brace epilog
                 | IF paren optnl iftail
                 | FOR '(' word IN words ')' optnl cmd
                 | FOR '(' word ')' optnl cmd
                 | WHILE paren optnl cmd
                 | SWITCH '(' word ')' optnl '{' cbody '}'
                 | TWIDDLE optcaret word words
                 | cmd ANDAND optnl cmd
                 | cmd OROR optnl cmd
                 | cmd PIPE optnl cmd
                 | redir cmd    %prec BANG
                 | assign cmd   %prec BANG
                 | BANG optcaret cmd
                 | SUBSHELL optcaret cmd
                 | FN words brace
                 | FN words

            optcaret: /* empty */ %prec '^' | '^'

            simple: first | first args

            args: arg | args arg

            arg: word | redir

            first: comword | first '^' sword

            sword: comword | keyword

            word: sword | word '^' sword

            comword: '$' sword
                 | '$' sword SUB words ')'
                 | COUNT sword
                 | FLAT sword
                 | '`' sword
                 | '`' brace
                 | BACKBACK word     brace | BACKBACK word sword
                 | '(' words ')'
                 | REDIR brace
                 | WORD

            keyword: FOR | IN | WHILE | IF | SWITCH
                 | FN | ELSE | CASE | TWIDDLE | BANG | SUBSHELL | '='

            words: /* empty */ | words word

            optnl: /* empty */ | optnl '\n'

</pre><h4><b>FILES</b></h4><pre>
       $HOME/.rcrc,0 /tmp/rc*,0 /dev/null0

</pre><h4><b>CREDITS</b></h4><pre>
       <u>rc</u>  was  written  by  Byron  Rakitzis,  with  valuable  help  from  Paul Haahr, Hugh Redelmeier and David
       Sanderson.  The design of this shell was copied from the <u>rc</u> that Tom Duff wrote at Bell Labs.

</pre><h4><b>BUGS</b></h4><pre>
       There is a compile-time limit on the number of ;0 separated commands in a line:  usually  500.   This  is
       sometimes a problem for automatically generated scripts: substituting the newline character for ;0 avoids
       the limit.

       On  modern systems that support /dev/fd0 or <a href="file:/proc/self/fd">/proc/self/fd</a>,0 &lt;{foo}0 style redirection is implemented that
       way.  However, on older systems it is implemented with named pipes.  Allegedly, it is sometimes  possible
       to  foil  <u>rc</u> into removing the FIFO it places in /tmp0 prematurely, or it is even possible to cause <u>rc</u> to
       hang.  (The current maintainer has never seen this, but then he doesn't use systems which  lack  /dev/fd0
       any more.  If anybody can reproduce this problem, please let the maintainer know.)

       The  <b>echo</b> command does not need to be a builtin. It is one for reasons of performance and portability (of
       <u>rc</u> scripts).

       There should be a way to avoid exporting a variable.

       Extra parentheses around a ~0 expression or a !0 expression are a  syntax  error.   Thus,  this  code  is
       illegal.

            while ((~ $1 -*) &amp;&amp; (! ~ $1 --)) { ...0

       The redundant inner parentheses must be omitted.

       Variable subscripting cannot be used in here documents.

       The limit0 builtin silently ignores extra arguments.

       Backquote  substitution  never produces empty strings - multiple consecutive occurrences of the separator
       are treated the same as a single occurrence.

            ifs=! { x = `{echo -n a!!b}; whatis x }0
            x=(a b) # NOT x=(a '' b)0

       Bug reports should be mailed to
       &lt;<a href="mailto:toby@paccrat.org">toby@paccrat.org</a>&gt;.0

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       Here is a list of features which distinguish this incarnation of <u>rc</u> from the one described  in  the  Bell
       Labs manual pages:

       The  Tenth  Edition  <u>rc</u>  does not have the <b>else</b> keyword.  Instead, <b>if</b> is optionally followed by an <b>if</b> <b>not</b>
       clause which is executed if the preceding <b>if</b> test does not succeed.

       Backquotes are slightly different in Tenth Edition <u>rc</u>: a backquote must always be  followed  by  a  left-
       brace.  This restriction is not present for single-word commands in this <u>rc</u>.

       For .0 <u>file</u>, the Tenth Edition <u>rc</u> searches $path0 for <u>file</u>.  This <u>rc</u> does not, since it is not considered
       useful.

       The  list  flattening  operator, $^foo,0 is spelt $"foo0 in those versions of the Bell Labs <u>rc</u> which have
       it.

       The following are all new with this version of <u>rc</u>: The -n0 flag, here strings (they facilitate  exporting
       of  functions with here documents into the environment), the <b>return</b> and <b>break</b> keywords, the <b>echo</b> builtin,
       the bqstatus0 and version0 variables, the prompt0 function, support  for  GNU  <u>readline</u>  and  other  line
       editing libraries.  This <u>rc</u> also sets $00 to the name of a function being executed/file being sourced.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       “rc  —  A  Shell  for  Plan 9 and UNIX Systems”, Unix Research System, Tenth Edition, Volume 2. (Saunders
       College Publishing)

       <a href="http://static.tobold.org/rc/rc-duff.html">http://static.tobold.org/rc/rc-duff.html</a>,0 an updated version of the above paper.

       <u><a href="../man1/history.1.html">history</a></u>(1)

                                                   2015-05-13                                              <u><a href="../man1/RC.1.html">RC</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>