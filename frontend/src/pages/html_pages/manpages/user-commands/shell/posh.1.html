<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>posh - Policy-compliant Ordinary SHell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/posh">posh_0.14.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       posh - Policy-compliant Ordinary SHell

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>posh</b> [+-aCefilnuvx] [+-o <u>option</u>] [[-c <u>command-string</u> [<u>command-name</u>] | -s | <u>file</u> ] [<u>argument</u>...]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>posh</b> is a reimplementation of the Bourne shell, a command interpreter for both interactive and script
       use.

   <b>Shell</b> <b>Startup</b>
       The following options can be specified only on the command line:

       <b>-c</b> <u>command-string</u>
           the shell executes the command(s) contained in <u>command-string</u>

       <b>-i</b>
           interactive mode — see below

       <b>-l</b>
           login shell — see below interactive mode — see below

       <b>-s</b>
           the shell reads commands from standard input; all non-option arguments are positional parameters

       In addition to the above, the options described in the <b>set</b> builtin command can also be used on the
       command line.

       If neither the <b>-c</b> nor the <b>-s</b> options are specified, the first non-option argument specifies the name of a
       file the shell reads commands from; if there are no non-option arguments, the shell reads commands from
       standard input. The name of the shell (<u>i.e.</u>, the contents of the <b>$0</b>) parameter is determined as follows:
       if the <b>-c</b> option is used and there is a non-option argument, it is used as the name; if commands are
       being read from a file, the file is used as the name; otherwise the name the shell was called with (<u>i.e.</u>,
       argv[0]) is used.

       A shell is <b>interactive</b> if the <b>-i</b> option is used or if both standard input and standard error are attached
       to a tty. An interactive shell has job control enabled (if available), ignores the INT, QUIT and TERM
       signals, and prints prompts before reading input (see <b>PS1</b> and <b>PS2</b> parameters).

       A shell is <b>privileged</b> if the <b>-p</b> option is used or if the real user-id or group-id does not match the
       effective user-id or group-id (see <b><a href="../man2/getuid.2.html">getuid</a></b>(2), <b><a href="../man2/getgid.2.html">getgid</a></b>(2)). A privileged shell does not process
       $HOME/.profile. Instead the file /etc/suid_profile is processed. Clearing the privileged option causes
       the shell to set its effective user-id (group-id) to its real user-id (group-id).

       If the basename of the name the shell is called with (<u>i.e.</u>, argv[0]) starts with <b>-</b> or if the <b>-l</b> option is
       used, the shell is assumed to be a login shell and the shell reads and executes the contents of
       <a href="file:/etc/profile">/etc/profile</a> and $HOME/.profile if they exist and are readable.

       The exit status of the shell is 127 if the command file specified on the command line could not be
       opened, or non-zero if a fatal syntax error occurred during the execution of a script. In the absence of
       fatal errors, the exit status is that of the last command executed, or zero, if no command is executed.

   <b>Command</b> <b>Syntax</b>
       The shell begins parsing its input by breaking it into words. Words, which are sequences of characters,
       are delimited by unquoted white-space characters (space, tab and newline) or meta-characters (&lt;, &gt;, |, ;,
       &amp;, ( and )). Aside from delimiting words, spaces and tabs are ignored, while newlines usually delimit
       commands. The meta-characters are used in building the following tokens: &lt;, &lt;&amp;, &lt;&lt;, &gt;, &gt;&amp;, &gt;&gt;, etc. are
       used to specify redirections (see Input/Output Redirection below); | is used to create pipelines; ; is
       used to separate commands; &amp; is used to create asynchronous pipelines; &amp;&amp; and || are used to specify
       conditional execution; ;; is used in case statements; and lastly, ( ...  ) are used to create subshells.

       White-space and meta-characters can be quoted individually using backslash (<b>\</b>), or in groups using double
       (<b>"</b>) or single (<b>'</b>) quotes. Note that the following characters are also treated specially by the shell and
       must be quoted if they are to represent themselves: <b>\</b>, <b>"</b>, <b>'</b>, <b>#</b>, <b>$</b>, <b>`</b>, <b>~</b>, <b>{</b>, <b>}</b>, <b>*</b>, <b>?</b>  and <b>[</b>. The first
       three of these are the above mentioned quoting characters (see Quoting below); <b>#</b>, if used at the
       beginning of a word, introduces a comment — everything after the <b>#</b> up to the nearest newline is ignored;
       <b>$</b> is used to introduce parameter, command and arithmetic substitutions (see Substitution below); <b>`</b>
       introduces an old-style command substitution (see Substitution below); <b>~</b> begins a directory expansion
       (see Tilde Expansion below); <b>{</b> and <b>}</b> delimit <b><a href="../man1/csh.1.html">csh</a></b>(1) style alternations (see Brace Expansion below); and,
       finally, <b>*</b>, <b>?</b>  and <b>[</b> are used in file name generation (see File Name Patterns below).

       As words and tokens are parsed, the shell builds commands, of which there are two basic types:
       <u>simple-commands</u>, typically programs that are executed, and <u>compound-commands</u>, such as <b>for</b> and <b>if</b>
       statements, grouping constructs and function definitions.

       A simple-command consists of some combination of parameter assignments (see Parameters below),
       input/output redirections (see Input/Output Redirections below), and command words; the only restriction
       is that parameter assignments come before any command words. The command words, if any, define the
       command that is to be executed and its arguments. The command may be a shell built-in command, a function
       or an <u>external</u> <u>command</u>, <u>i.e.</u>, a separate executable file that is located using the <b>PATH</b> parameter (see
       Command Execution below). Note that all command constructs have an <u>exit</u> <u>status</u>: for external commands,
       this is related to the status returned by <b><a href="../man2/wait.2.html">wait</a></b>(2) (if the command could not be found, the exit status is
       127, if it could not be executed, the exit status is 126); the exit status of other command constructs
       (built-in commands, functions, compound-commands, pipelines, lists, <u>etc.</u>) are all well defined and are
       described where the construct is described. The exit status of a command consisting only of parameter
       assignments is that of the last command substitution performed during the parameter assignment or zero if
       there were no command substitutions.

       Commands can be chained together using the <b>|</b> token to form <u>pipelines</u>, in which the standard output of
       each command but the last is piped (see <b><a href="../man2/pipe.2.html">pipe</a></b>(2)) to the standard input of the following command. The exit
       status of a pipeline is that of its last command. A pipeline may be prefixed by the <b>!</b>  reserved word
       which causes the exit status of the pipeline to be logically complemented: if the original status was 0
       the complemented status will be 1, and if the original status was not 0, then the complemented status
       will be 0.

       <u>Lists</u> of commands can be created by separating pipelines by any of the following tokens: <b>&amp;&amp;</b>, <b>||</b>, <b>&amp;</b>, <b>|&amp;</b>
       and <b>;</b>. The first two are for conditional execution: <u>cmd1</u> <b>&amp;&amp;</b> <u>cmd2</u> executes <u>cmd2</u> only if the exit status of
       <u>cmd1</u> is zero; <b>||</b> is the opposite — <u>cmd2</u> is executed only if the exit status of <u>cmd1</u> is non-zero.  <b>&amp;&amp;</b> and
       <b>||</b> have equal precedence which is higher than that of <b>&amp;</b>, <b>|&amp;</b> and <b>;</b>, which also have equal precedence. The
       <b>&amp;</b> token causes the preceding command to be executed asynchronously, that is, the shell starts the
       command, but does not wait for it to complete (the shell does keep track of the status of asynchronous
       commands — see Job Control below). When an asynchronous command is started when job control is disabled
       (<u>i.e.</u>, in most scripts), the command is started with signals INT and QUIT ignored and with input
       redirected from /dev/null (however, redirections specified in the asynchronous command have precedence).
       Note that a command must follow the <b>&amp;&amp;</b> and <b>||</b> operators, while a command need not follow <b>&amp;</b>, <b>|&amp;</b> and <b>;</b>. The
       exit status of a list is that of the last command executed, with the exception of asynchronous lists, for
       which the exit status is 0.

       Compound commands are created using the following reserved words — these words are only recognized if
       they are unquoted and if they are used as the first word of a command (<u>i.e.</u>, they can't be preceded by
       parameter assignments or redirections):
                                           <b>case</b>   <b>else</b>
                                           do     esac   if       time    [[
                                           done   fi     in       until   {
                                           elif   for    select   while   }

       <b>Note:</b> Some shells (but not this one) execute control structure commands in a subshell when one or more of
       their file descriptors are redirected, so any environment changes inside them may fail. To be portable,
       the <b>exec</b> statement should be used instead to redirect file descriptors before the control structure.

       In the following compound command descriptions, command lists (denoted as <u>list</u>) that are followed by
       reserved words must end with a semi-colon, a newline or a (syntactically correct) reserved word. For
       example,

       <b>{</b> <b>echo</b> <b>foo;</b> <b>echo</b> <b>bar;</b> <b>}</b>

       <b>{</b> <b>echo</b> <b>foo;</b> <b>echo</b> <b>bar&lt;newline&gt;}</b>

       <b>{</b> <b>{</b> <b>echo</b> <b>foo;</b> <b>echo</b> <b>bar;</b> <b>}</b> <b>}</b> are all valid, but

       <b>{</b> <b>echo</b> <b>foo;</b> <b>echo</b> <b>bar</b> <b>}</b> is not.

       <b>(</b> <u>list</u> <b>)</b>
           Execute <u>list</u> in a subshell. There is no implicit way to pass environment changes from a subshell back
           to its parent.

       <b>{</b> <u>list</u> <b>}</b>
           Compound construct; <u>list</u> is executed, but not in a subshell. Note that <b>{</b> and <b>}</b> are reserved words,
           not meta-characters.

       <b>case</b> <u>word</u> <b>in</b> [ [<b>(</b>] <u>pattern</u> [<b>|</b> <u>pattern</u>] ... <b>)</b> <u>list</u> <b>;;</b> ] ... <b>esac</b>
           The <b>case</b> statement attempts to match <u>word</u> against the specified <u>pattern</u>s; the <u>list</u> associated with
           the first successfully matched pattern is executed. Patterns used in <b>case</b> statements are the same as
           those used for file name patterns except that the restrictions regarding <b>.</b>  and <b>/</b> are dropped. Note
           that any unquoted space before and after a pattern is stripped; any space with a pattern must be
           quoted. Both the word and the patterns are subject to parameter, command, and arithmetic substitution
           as well as tilde substitution. For historical reasons, open and close braces may be used instead of
           <b>in</b> and <b>esac</b> (<u>e.g.</u>, <b>case</b> <b>$foo</b> <b>{</b> <b>*)</b> <b>echo</b> <b>bar;</b> <b>}</b>). The exit status of a <b>case</b> statement is that of the
           executed <u>list</u>; if no <u>list</u> is executed, the exit status is zero.

       <b>for</b> <u>name</u> [ <b>in</b> <u>word</u> ... <u>term</u> ] <b>do</b> <u>list</u> <b>done</b>
           where <u>term</u> is either a newline or a <b>;</b>. For each <u>word</u> in the specified word list, the parameter <u>name</u>
           is set to the word and <u>list</u> is executed. If <b>in</b> is not used to specify a word list, the positional
           parameters (<b>"$1"</b>, <b>"$2"</b>, <u>etc.</u>) are used instead. For historical reasons, open and close braces may be
           used instead of <b>do</b> and <b>done</b> (<u>e.g.</u>, <b>for</b> <b>i;</b> <b>{</b> <b>echo</b> <b>$i;</b> <b>}</b>). The exit status of a <b>for</b> statement is the
           last exit status of <u>list</u>; if <u>list</u> is never executed, the exit status is zero.

       <b>if</b> <u>list</u> <b>then</b> <u>list</u> [<b>elif</b> <u>list</u> <b>then</b> <u>list</u>] ... [<b>else</b> <u>list</u>] <b>fi</b>
           If the exit status of the first <u>list</u> is zero, the second <u>list</u> is executed; otherwise the <u>list</u>
           following the <b>elif</b>, if any, is executed with similar consequences. If all the lists following the <b>if</b>
           and <b>elif</b>s fail (<u>i.e.</u>, exit with non-zero status), the <u>list</u> following the <b>else</b> is executed. The exit
           status of an <b>if</b> statement is that of non-conditional <u>list</u> that is executed; if no non-conditional
           <u>list</u> is executed, the exit status is zero.

       <b>until</b> <u>list</u> <b>do</b> <u>list</u> <b>done</b>
           This works like <b>while</b>, except that the body is executed only while the exit status of the first <u>list</u>
           is non-zero.

       <b>while</b> <u>list</u> <b>do</b> <u>list</u> <b>done</b>
           A <b>while</b> is a prechecked loop. Its body is executed as often as the exit status of the first <u>list</u> is
           zero. The exit status of a <b>while</b> statement is the last exit status of the <u>list</u> in the body of the
           loop; if the body is not executed, the exit status is zero.

       <u>name</u> <b>()</b> <u>command</u>
           Defines the function <u>name</u>. See Functions below. Note that redirections specified after a function
           definition are performed whenever the function is executed, not when the function definition is
           executed.

       <b>time</b> [ <b>-p</b> ] [ <u>pipeline</u> ]
           The <b>time</b> reserved word is described in the Command Execution section.

   <b>Quoting</b>
       Quoting is used to prevent the shell from treating characters or words specially. There are three methods
       of quoting: First, <b>\</b> quotes the following character, unless it is at the end of a line, in which case
       both the <b>\</b> and the newline are stripped. Second, a single quote (<b>'</b>) quotes everything up to the next
       single quote (this may span lines). Third, a double quote (<b>"</b>) quotes all characters, except <b>$</b>, <b>`</b> and <b>\</b>,
       up to the next unquoted double quote.  <b>$</b> and <b>`</b> inside double quotes have their usual meaning (<u>i.e.</u>,
       parameter, command or arithmetic substitution) except no field splitting is carried out on the results of
       double-quoted substitutions. If a <b>\</b> inside a double-quoted string is followed by <b>\</b>, <b>$</b>, <b>`</b> or <b>"</b>, it is
       replaced by the second character; if it is followed by a newline, both the <b>\</b> and the newline are
       stripped; otherwise, both the <b>\</b> and the character following are unchanged.

       Note: see POSIX Mode below for a special rule regarding sequences of the form <b>"</b>...<b>`</b>...<b>\"</b>...<b>`</b>..<b>"</b>.

   <b>Substitution</b>
       The first step the shell takes in executing a simple-command is to perform substitutions on the words of
       the command. There are three kinds of substitution: parameter, command and arithmetic. Parameter
       substitutions, which are described in detail in the next section, take the form <b>$name</b> or <b>${</b>...<b>}</b>; command
       substitutions take the form <b>$(</b><u>command</u><b>)</b> or <b>`</b><u>command</u><b>`</b>; and arithmetic substitutions take the form
       <b>$((</b><u>expression</u><b>))</b>.

       If a substitution appears outside of double quotes, the results of the substitution are generally subject
       to word or field splitting according to the current value of the <b>IFS</b> parameter. The <b>IFS</b> parameter
       specifies a list of characters which are used to break a string up into several words; any characters
       from the set space, tab and newline that appear in the IFS characters are called <u>IFS</u> <u>white</u> <u>space</u>.
       Sequences of one or more IFS white space characters, in combination with zero or one non-IFS white space
       characters delimit a field. As a special case, leading and trailing IFS white space is stripped (<u>i.e.</u>, no
       leading or trailing empty field is created by it); leading or trailing non-IFS white space does create an
       empty field. Example: if <b>IFS</b> is set to `&lt;space&gt;:', the sequence of characters
       `&lt;space&gt;A&lt;space&gt;:&lt;space&gt;&lt;space&gt;B::D' contains four fields: `A', `B', `' and `D'. Note that if the <b>IFS</b>
       parameter is set to the null string, no field splitting is done; if the parameter is unset, the default
       value of space, tab and newline is used.

       The results of substitution are, unless otherwise specified, also subject to brace expansion and file
       name expansion (see the relevant sections below).

       A command substitution is replaced by the output generated by the specified command, which is run in a
       subshell. For <b>$(</b><u>command</u><b>)</b> substitutions, normal quoting rules are used when <u>command</u> is parsed, however,
       for the <b>`</b><u>command</u><b>`</b> form, a <b>\</b> followed by any of <b>$</b>, <b>`</b> or <b>\</b> is stripped (a <b>\</b> followed by any other character
       is unchanged). As a special case in command substitutions, a command of the form <b>&lt;</b> <u>file</u> is interpreted to
       mean substitute the contents of <u>file</u> ($(&lt; foo) has the same effect as $(cat foo), but it is carried out
       more efficiently because no process is started).

       NOTE: <b>$(</b><u>command</u><b>)</b> expressions are currently parsed by finding the matching parenthesis, regardless of
       quoting. This will hopefully be fixed soon.

       Arithmetic substitutions are replaced by the value of the specified expression. For example, the command
       <b>echo</b> <b>$((2+3*4))</b> prints 14. See Arithmetic Expressions for a description of an <u>expression</u>.

   <b>Parameters</b>
       Parameters are shell variables; they can be assigned values and their values can be accessed using a
       parameter substitution. A parameter name is either one of the special single punctuation or digit
       character parameters described below, or a letter followed by zero or more letters or digits (`_' counts
       as a letter). The later form can be treated as arrays by appending an array index of the form: <b>[</b><u>expr</u><b>]</b>
       where <u>expr</u> is an arithmetic expression. Array indices are currently limited to the range 0 through 1023,
       inclusive. Parameter substitutions take the form <b>$</b><u>name</u>, <b>${</b><u>name</u><b>}</b> or <b>${</b><u>name</u><b>[</b><u>expr</u><b>]}</b>, where <u>name</u> is a
       parameter name. If substitution is performed on a parameter (or an array parameter element) that is not
       set, a null string is substituted unless the <b>nounset</b> option (<b>set</b> <b>-o</b> <b>nounset</b> or <b>set</b> <b>-u</b>) is set, in which
       case an error occurs.

       Parameters can be assigned values in a number of ways. First, the shell implicitly sets some parameters
       like <b>#</b>, <b>PWD</b>, etc.; this is the only way the special single character parameters are set. Second,
       parameters are imported from the shell's environment at startup. Third, parameters can be assigned values
       on the command line, for example, `<b>FOO=bar</b>' sets the parameter FOO to bar; multiple parameter assignments
       can be given on a single command line and they can be followed by a simple-command, in which case the
       assignments are in effect only for the duration of the command (such assignments are also exported, see
       below for implications of this). Note that both the parameter name and the <b>=</b> must be unquoted for the
       shell to recognize a parameter assignment. The fourth way of setting a parameter is with the <b>export</b> and
       <b>readonly</b> commands; see their descriptions in the Command Execution section. Fifth, <b>for</b> and <b>select</b> loops
       set parameters as well as the <b>getopts</b>, <b>read</b> and <b>set</b> <b>-A</b> commands. Lastly, parameters can be assigned
       values using assignment operators inside arithmetic expressions (see Arithmetic Expressions below) or
       using the <b>${</b><u>name</u><b>=</b><u>value</u><b>}</b> form of parameter substitution (see below).

       Parameters with the export attribute (set using the <b>export</b> command, or by parameter assignments followed
       by simple commands) are put in the environment (see <b><a href="../man5/environ.5.html">environ</a></b>(5)) of commands run by the shell as
       <u>name</u><b>=</b><u>value</u> pairs. The order in which parameters appear in the environment of a command is unspecified.
       When the shell starts up, it extracts parameters and their values from its environment and automatically
       sets the export attribute for those parameters.

       Modifiers can be applied to the <b>${</b><u>name</u><b>}</b> form of parameter substitution:

       <b>${</b><u>name</u><b>:-</b><u>word</u><b>}</b>
           if <u>name</u> is set and not null, it is substituted, otherwise <u>word</u> is substituted.

       <b>${</b><u>name</u><b>:+</b><u>word</u><b>}</b>
           if <u>name</u> is set and not null, <u>word</u> is substituted, otherwise nothing is substituted.

       <b>${</b><u>name</u><b>:=</b><u>word</u><b>}</b>
           if <u>name</u> is set and not null, it is substituted, otherwise it is assigned <u>word</u> and the resulting value
           of <u>name</u> is substituted.

       <b>${</b><u>name</u><b>:?</b><u>word</u><b>}</b>
           if <u>name</u> is set and not null, it is substituted, otherwise <u>word</u> is printed on standard error (preceded
           by <u>name</u>:) and an error occurs (normally causing termination of a shell script, function or .-script).
           If word is omitted the string `parameter null or not set' is used instead.

       In the above modifiers, the <b>:</b> can be omitted, in which case the conditions only depend on <u>name</u> being set
       (as opposed to set and not null). If <u>word</u> is needed, parameter, command, arithmetic and tilde
       substitution are performed on it; if <u>word</u> is not needed, it is not evaluated.

       The following forms of parameter substitution can also be used:

       <b>${#</b><u>name</u><b>}</b>
           The number of positional parameters if <u>name</u> is <b>*</b>, <b>@</b> or is not specified, or the length of the string
           value of parameter <u>name</u>.

       <b>${#</b><u>name</u><b>[*]}</b>, <b>${#</b><u>name</u><b>[@]}</b>
           The number of elements in the array <u>name</u>.

       <b>${</b><u>name</u><b>#</b><u>pattern</u><b>}</b>, <b>${</b><u>name</u><b>##</b><u>pattern</u><b>}</b>
           If <u>pattern</u> matches the beginning of the value of parameter <u>name</u>, the matched text is deleted from the
           result of substitution. A single <b>#</b> results in the shortest match, two <b>#</b>'s results in the longest
           match.

       <b>${</b><u>name</u><b>%</b><u>pattern</u><b>}</b>, <b>${</b><u>name</u><b>%%</b><u>pattern</u><b>}</b>
           Like <b>${</b>..<b>#</b>..<b>}</b> substitution, but it deletes from the end of the value.

       The following special parameters are implicitly set by the shell and cannot be set directly using
       assignments:

       <b>!</b>
           Process id of the last background process started. If no background processes have been started, the
           parameter is not set.

       <b>#</b>
           The number of positional parameters (<u>i.e.</u>, <b>$1</b>, <b>$2</b>, <u>etc.</u>).

       <b>$</b>
           The process ID of the shell, or the PID of the original shell if it is a subshell.

       <b>-</b>
           The concatenation of the current single letter options (see <b>set</b> command below for list of options).

       <b>?</b>
           The exit status of the last non-asynchronous command executed. If the last command was killed by a
           signal, <b>$?</b>  is set to 128 plus the signal number.

       <u>0</u>
           The name the shell was invoked with (that is, <u>argv[0]</u>), or the <u>command-name</u> if it was invoked with
           the <b>-c</b> option and the <u>command-name</u> was supplied, or the <u>file</u> argument, if it was supplied. If the
           <b>posix</b> option is not set, <b>$0</b> is the name of the current function or script.

       <u>1</u> ... <u>9</u>
           The first nine positional parameters that were supplied to the shell, function or <b>.</b>-script. Further
           positional parameters may be accessed using <u>${number}</u>.

       <u>*</u>
           All positional parameters (except parameter 0), <u>i.e.</u>, <b>$1</b> <b>$2</b> <b>$3</b>.... If used outside of double quotes,
           parameters are separate words (which are subjected to word splitting); if used within double quotes,
           parameters are separated by the first character of the <b>IFS</b> parameter (or the empty string if <b>IFS</b> is
           null).

       <u>@</u>
           Same as <b>$*</b>, unless it is used inside double quotes, in which case a separate word is generated for
           each positional parameter - if there are no positional parameters, no word is generated ("$@" can be
           used to access arguments, verbatim, without loosing null arguments or splitting arguments with
           spaces).

       The following parameters are set and/or used by the shell:

       "<b>CDPATH</b>"
           Search path for the <b>cd</b> built-in command. Works the same way as <b>PATH</b> for those directories not
           beginning with <b>/</b> in <b>cd</b> commands. Note that if CDPATH is set and does not contain .  nor an empty
           path, the current directory is not searched.

       <b>COLUMNS</b>
           Set to the number of columns on the terminal or window. Currently set to the <b>cols</b> value as reported
           by <b><a href="../man1/stty.1.html">stty</a></b>(1) if that value is non-zero. This parameter is used by the interactive line editing modes,
           and by <b>select</b>, <b>set</b> <b>-o</b> and <b>kill</b> <b>-l</b> commands to format information in columns.

       <b>ERRNO</b>
           Integer value of the shell's errno variable — indicates the reason the last system call failed.

           Not implemented yet.

       <b>EXECSHELL</b>
           If set, this parameter is assumed to contain the shell that is to be used to execute commands that
           <b><a href="../man2/execve.2.html">execve</a></b>(2) fails to execute and which do not start with a `<b>#!</b>  <u>shell</u>' sequence.

       <b>FCEDIT</b>
           The editor used by the <b>fc</b> command (see below).

       <b>FPATH</b>
           Like <b>PATH</b>, but used when an undefined function is executed to locate the file defining the function.
           It is also searched when a command can't be found using <b>PATH</b>. See Functions below for more
           information.

       <b>HOME</b>
           The default directory for the <b>cd</b> command and the value substituted for an unqualified <b>~</b> (see Tilde
           Expansion below).

       <b>IFS</b>
           Internal field separator, used during substitution and by the <b>read</b> command, to split values into
           distinct arguments; normally set to space, tab and newline. See Substitution above for details.

           <b>Note:</b> this parameter is not imported from the environment when the shell is started.

       <b>POSH_VERSION</b>
           The version of posh (readonly).

       <b>LINENO</b>
           The line number of the function or shell script that is currently being executed.

       <b>LINES</b>
           Set to the number of lines on the terminal or window.

           Not implemented yet.

       <b>OLDPWD</b>
           The previous working directory. Unset if <b>cd</b> has not successfully changed directories since the shell
           started, or if the shell doesn't know where it is.

       <b>OPTARG</b>
           When using <b>getopts</b>, it contains the argument for a parsed option, if it requires one.

       <b>OPTIND</b>
           The index of the last argument processed when using <b>getopts</b>. Assigning 1 to this parameter causes
           <b>getopts</b> to process arguments from the beginning the next time it is invoked.

       <b>PATH</b>
           A colon separated list of directories that are searched when looking for commands and .'d files. An
           empty string resulting from a leading or trailing colon, or two adjacent colons is treated as a `.',
           the current directory.

       <b>PPID</b>
           The process ID of the shell's parent (readonly).

       <b>PS1</b>
           The primary prompt for interactive shells. The prompt is printed verbatim (<u>i.e.</u>, no substitutions are
           done). Default is ‘$ ’ for non-root users, `<b>#</b> ' for root..

       <b>PS2</b>
           Secondary prompt string, by default `<b>&gt;</b> ', used when more input is needed to complete a command.

       <b>PS4</b>
           Used to prefix commands that are printed during execution tracing (see <b>set</b> <b>-x</b> command below). The
           prompt is printed verbatim (<u>i.e.</u>, no substitutions are done). Default is `<b>+</b> '.

       <b>PWD</b>
           The current working directory. Maybe unset or null if shell doesn't know where it is.

       <b>REPLY</b>
           Default parameter for the <b>read</b> command if no names are given. Also used in <b>select</b> loops to store the
           value that is read from standard input.

       <b>TMPDIR</b>
           The directory shell temporary files are created in. If this parameter is not set, or does not contain
           the absolute path of a writable directory, temporary files are created in /tmp.

   <b>Tilde</b> <b>Expansion</b>
       Tilde expansion, which is done in parallel with parameter substitution, is done on words starting with an
       unquoted <b>~</b>. The characters following the tilde, up to the first <b>/</b>, if any, are assumed to be a login
       name. If the login name is empty, <b>+</b> or <b>-</b>, the value of the <b>HOME</b>, <b>PWD</b>, or <b>OLDPWD</b> parameter is substituted,
       respectively. Otherwise, the password file is searched for the login name, and the tilde expression is
       substituted with the user's home directory. If the login name is not found in the password file or if any
       quoting or parameter substitution occurs in the login name, no substitution is performed.

       In parameter assignments (those preceding a simple-command or those occurring in the arguments of <b>alias</b>,
       <b>export</b>, and <b>readonly</b>, tilde expansion is done after any unquoted colon (<b>:</b>), and login names are also
       delimited by colons.

       The home directory of previously expanded login names are cached and re-used. The <b>alias</b> <b>-d</b> command may be
       used to list, change and add to this cache (<u>e.g.</u>, `alias -d fac=/usr/local/facilities; cd ~fac/bin').

   <b>File</b> <b>Name</b> <b>Patterns</b>
       A file name pattern is a word containing one or more unquoted <b>?</b>  or <b>*</b> characters or <b>[</b>..<b>]</b>  sequences. Once
       brace expansion has been performed, the shell replaces file name patterns with the sorted names of all
       the files that match the pattern (if no files match, the word is left unchanged). The pattern elements
       have the following meaning:

       "<b>?</b>"
           matches any single character.

       <b>*</b>
           matches any sequence of characters.

       <b>[</b>..<b>]</b>
           matches any of the characters inside the brackets. Ranges of characters can be specified by
           separating two characters by a <b>-</b>, <u>e.g.</u>, <b>[a0-9]</b> matches the letter <b>a</b> or any digit. In order to
           represent itself, a <b>-</b> must either be quoted or the first or last character in the character list.
           Similarly, a <b>]</b> must be quoted or the first character in the list if it is represent itself instead of
           the end of the list. Also, a <b>!</b>  appearing at the start of the list has special meaning (see below),
           so to represent itself it must be quoted or appear later in the list.

       <b>[!</b>..<b>]</b>
           like <b>[</b>..<b>]</b>, except it matches any character not inside the brackets.

       Note that posh currently never matches .  and .., but the original ksh, Bourne sh and bash do, so this
       may have to change (too bad).

       Note that none of the above pattern elements match either a period (.) at the start of a file name or a
       slash (<b>/</b>), even if they are explicitly used in a <b>[</b>..<b>]</b>  sequence; also, the names .  and ..  are never
       matched, even by the pattern <b>.*</b>.

       The POSIX character classes (<u>i.e.</u>, <b>[:</b><u>class-name</u><b>:]</b> inside a <b>[</b>..<b>]</b>  expression) are not yet implemented.

   <b>Input/Output</b> <b>Redirection</b>
       When a command is executed, its standard input, standard output and standard error (file descriptors 0, 1
       and 2, respectively) are normally inherited from the shell. Three exceptions to this are commands in
       pipelines, for which standard input and/or standard output are those set up by the pipeline, asynchronous
       commands created when job control is disabled, for which standard input is initially set to be from
       /dev/null, and commands for which any of the following redirections have been specified:

       "<b>&gt;</b> <u>file</u>"
           standard output is redirected to <u>file</u>. If <u>file</u> does not exist, it is created; if it does exist, is a
           regular file and the <b>noclobber</b> option is set, an error occurs, otherwise the file is truncated. Note
           that this means the command <u>cmd</u> <u>&lt;</u> <u>foo</u> <u>&gt;</u> <u>foo</u> will open <u>foo</u> for reading and then truncate it when it
           opens it for writing, before <u>cmd</u> gets a chance to actually read <u>foo</u>.

       "<b>&gt;|</b> <u>file</u>"
           same as <b>&gt;</b>, except the file is truncated, even if the <b>noclobber</b> option is set.

       "<b>&gt;&gt;</b> <u>file</u>"
           same as <b>&gt;</b>, except the file an existing file is appended to instead of being truncated. Also, the file
           is opened in append mode, so writes always go to the end of the file (see <b><a href="../man2/open.2.html">open</a></b>(2)).

       "<b>&lt;</b> <u>file</u>"
           standard input is redirected from <u>file</u>, which is opened for reading.

       "<b>&lt;&gt;</b> <u>file</u>"
           same as <b>&lt;</b>, except the file is opened for reading and writing.

       "<b>&lt;&lt;</b> <u>marker</u>"
           after reading the command line containing this kind of redirection (called a here document), the
           shell copies lines from the command source into a temporary file until a line matching <u>marker</u> is
           read. When the command is executed, standard input is redirected from the temporary file. If <u>marker</u>
           contains no quoted characters, the contents of the temporary file are processed as if enclosed in
           double quotes each time the command is executed, so parameter, command and arithmetic substitutions
           are performed, along with backslash (<b>\</b>) escapes for <b>$</b>, <b>`</b>, <b>\</b> and <b>\newline</b>. If multiple here documents
           are used on the same command line, they are saved in order.

       "<b>&lt;&lt;-</b> <u>marker</u>"
           same as <b>&lt;&lt;</b>, except leading tabs are stripped from lines in the here document.

       "<b>&lt;&amp;</b> <u>fd</u>"
           standard input is duplicated from file descriptor <u>fd</u>.  <u>fd</u> can be a single digit, indicating the
           number of an existing file descriptor, the letter <b>p</b>, indicating the file descriptor associated with
           the output of the current co-process, or the character <b>-</b>, indicating standard input is to be closed.

       "<b>&gt;&amp;</b> <u>fd</u>"
           same as <b>&lt;&amp;</b>, except the operation is done on standard output.

       In any of the above redirections, the file descriptor that is redirected (<u>i.e.</u>, standard input or
       standard output) can be explicitly given by preceding the redirection with a single digit. Parameter,
       command and arithmetic substitutions, tilde substitutions and (if the shell is interactive) file name
       generation are all performed on the <u>file</u>, <u>marker</u> and <u>fd</u> arguments of redirections. Note however, that the
       results of any file name generation are only used if a single file is matched; if multiple files match,
       the word with the unexpanded file name generation characters is used.

       For simple-commands, redirections may appear anywhere in the command, for compound-commands (<b>if</b>
       statements, <u>etc.</u>), any redirections must appear at the end. Redirections are processed after pipelines
       are created and in the order they are given, so

       <b>cat</b> <b>/foo/bar</b> <b>2&gt;&amp;1</b> <b>&gt;</b> <b>/dev/null</b> <b>|</b> <b>cat</b> <b>-n</b> will print an error with a line number prepended to it.

   <b>Arithmetic</b> <b>Expressions</b>
       Integer arithmetic expressions can be used inside <b>$((</b>..<b>))</b>  expressions, inside array references (<u>e.g.</u>,
       <u>name</u><b>[</b><u>expr</u><b>]</b>), as numeric arguments to the <b>test</b> command, and as the value of an assignment to an integer
       parameter.

       Expression may contain alpha-numeric parameter identifiers, array references, and integer constants and
       may be combined with the following C operators (listed and grouped in increasing order of precedence).

       Unary operators:
           <b>+</b> <b>-</b> <b>!</b> <b>~</b> <b>++</b> <b>--</b>

       Binary operators:
           <b>,</b>

           <b>=</b> <b>*=</b> <b>/=</b> <b>%=</b> <b>+=</b> <b>-=</b> <b>&lt;&lt;=</b> <b>&gt;&gt;=</b> <b>&amp;=</b> <b>^=</b> <b>|=</b>

           <b>||</b>

           <b>&amp;&amp;</b>

           <b>|</b>

           <b>^</b>

           <b>&amp;</b>

           <b>==</b> <b>!=</b>

           <b>&lt;</b> <b>&lt;=</b> <b>&gt;=</b> <b>&gt;</b>

           <b>&lt;&lt;</b> <b>&gt;&gt;</b>

           <b>+</b> <b>-</b>

           <b>*</b> <b>/</b> <b>%</b>

       Ternary operator:
           <b>?:</b> (precedence is immediately higher than assignment)

       Grouping operators:
           <b>(</b> <b>)</b>

       Integer constants may be specified with arbitrary bases using the notation <u>base</u><b>#</b><u>number</u>, where <u>base</u> is a
       decimal integer specifying the base, and <u>number</u> is a number in the specified base.

       The operators are evaluated as follows:

       "unary <b>+</b>"
           result is the argument (included for completeness).

       "unary <b>-</b>"
           negation.

       "<b>!</b>"
           logical not; the result is 1 if argument is zero, 0 if not.

       "<b>~</b>"
           arithmetic (bit-wise) not.

       "<b>++</b>"
           increment; must be applied to a parameter (not a literal or other expression) - the parameter is
           incremented by 1. When used as a prefix operator, the result is the incremented value of the
           parameter, when used as a postfix operator, the result is the original value of the parameter.

       "<b>++</b>"
           similar to <b>++</b>, except the parameter is decremented by 1.

       "<b>,</b>"
           separates two arithmetic expressions; the left hand side is evaluated first, then the right. The
           result is value of the expression on the right hand side.

       "<b>=</b>"
           assignment; variable on the left is set to the value on the right.

       "<b>*=</b> <b>/=</b> <b>%=</b> <b>+=</b> <b>-=</b> <b>&lt;&lt;=</b> <b>&gt;&gt;=</b> <b>&amp;=</b> <b>^=</b> <b>|=</b>"
           assignment operators; <u>&lt;var&gt;</u> <u>&lt;op&gt;</u><b>=</b> <u>&lt;expr&gt;</u> is the same as <u>&lt;var&gt;</u> <b>=</b> <u>&lt;var&gt;</u> <u>&lt;op&gt;</u> <b>(</b> <u>&lt;expr&gt;</u> <b>)</b>.

       "<b>||</b>"
           logical or; the result is 1 if either argument is non-zero, 0 if not. The right argument is evaluated
           only if the left argument is zero.

       "<b>&amp;&amp;</b>"
           logical and; the result is 1 if both arguments are non-zero, 0 if not. The right argument is
           evaluated only if the left argument is non-zero.

       "<b>|</b>"
           arithmetic (bit-wise) or.

       "<b>^</b>"
           arithmetic (bit-wise) exclusive-or.

       "<b>&amp;</b>"
           arithmetic (bit-wise) and.

       "<b>==</b>"
           equal; the result is 1 if both arguments are equal, 0 if not.

       "<b>!=</b>"
           not equal; the result is 0 if both arguments are equal, 1 if not.

       "<b>&lt;</b>"
           less than; the result is 1 if the left argument is less than the right, 0 if not.

       "<b>&lt;=</b> <b>&gt;=</b> <b>&gt;</b>"
           less than or equal, greater than or equal, greater than. See &lt;.

       "<b>&lt;&lt;</b> <b>&gt;&gt;</b>"
           shift left (right); the result is the left argument with its bits shifted left (right) by the amount
           given in the right argument.

       "<b>+</b> <b>-</b> <b>*</b> <b>/</b>"
           addition, subtraction, multiplication, and division.

       "<b>%</b>"
           remainder; the result is the remainder of the division of the left argument by the right. The sign of
           the result is unspecified if either argument is negative.

       "<u>&lt;arg1&gt;</u> <b>?</b> <u>&lt;arg2&gt;</u> <b>:</b> <u>&lt;arg3&gt;</u>"
           if <u>&lt;arg1&gt;</u> is non-zero, the result is <u>&lt;arg2&gt;</u>, otherwise <u>&lt;arg3&gt;</u>.

   <b>Functions</b>
       Functions are defined using the Bourne/POSIX shell <u>name</u><b>()</b> syntax. Functions are like .-scripts in that
       they are executed in the current environment, however, unlike .-scripts, shell arguments (<u>i.e.</u>,
       positional parameters, <b>$1</b>, <u>etc.</u>) are never visible inside them. When the shell is determining the
       location of a command, functions are searched after special built-in commands, and before regular and
       non-regular built-ins, and before the <b>PATH</b> is searched.

       An existing function may be deleted using <b>unset</b> <b>-f</b> <u>function-name</u>.

       Since functions are executed in the current shell environment, parameter assignments made inside
       functions are visible after the function completes.

       The exit status of a function is that of the last command executed in the function. A function can be
       made to finish immediately using the <b>return</b> command; this may also be used to explicitly specify the exit
       status.

   <b>Command</b> <b>Execution</b>
       After evaluation of command line arguments, redirections and parameter assignments, the type of command
       is determined: a special built-in, a function, a regular built-in or the name of a file to execute found
       using the <b>PATH</b> parameter. The checks are made in the above order. Special built-in commands differ from
       other commands in that the <b>PATH</b> parameter is not used to find them, an error during their execution can
       cause a non-interactive shell to exit and parameter assignments that are specified before the command are
       kept after the command completes. Just to confuse things, if the posix option is turned off (see <b>set</b>
       command below) some special commands are very special in that no field splitting, file globbing, brace
       expansion nor tilde expansion is performed on arguments that look like assignments. Regular built-in
       commands are different only in that the <b>PATH</b> parameter is not used to find them.

   <b>Job</b> <b>Control</b>
       Job control refers to the shell's ability to monitor and control <b>jobs</b>, which are processes or groups of
       processes created for commands or pipelines. At a minimum, the shell keeps track of the status of the
       background (<u>i.e.</u>, asynchronous) jobs that currently exist; this information can be displayed using the
       <b>jobs</b> command. If job control is fully enabled (using <b>set</b> <b>-m</b> or <b>set</b> <b>-o</b> <b>monitor</b>), as it is for interactive
       shells, the processes of a job are placed in their own process group, foreground jobs can be stopped by
       typing the suspend character from the terminal (normally ^Z), jobs can be restarted in either the
       foreground or background, using the <b>fg</b> and <b>bg</b> commands, respectively, and the state of the terminal is
       saved or restored when a foreground job is stopped or restarted, respectively.

       Note that only commands that create processes (<u>e.g.</u>, asynchronous commands, subshell commands, and
       non-built-in, non-function commands) can be stopped; commands like <b>read</b> cannot be.

       When a job is created, it is assigned a job-number. For interactive shells, this number is printed inside
       <b>[</b>..<b>]</b>, followed by the process-ids of the processes in the job when an asynchronous command is run. A job
       may be referred to in <b>bg</b>, <b>fg</b>, <b>jobs</b>, <b>kill</b> and <b>wait</b> commands either by the process id of the last process
       in the command pipeline (as stored in the <b>$!</b>  parameter) or by prefixing the job-number with a percent
       sign (<b>%</b>). Other percent sequences can also be used to refer to jobs:
                              <b>%+</b>            <b>%+</b>   <b>The</b> <b>most</b> <b>recently</b> <b>stopped</b> <b>job,</b> <b>or,</b> <b>if</b> <b>there</b>
                                                 <b>are</b> <b>no</b> <b>stopped</b> <b>jobs,</b> <b>the</b> <b>oldest</b>
                                                                     <b>running</b> <b>job.</b>
                            %%, <u>%</u>     %%, <u>%</u>      Same as <b>%+</b>.
                              %-      %-         The job that would be
                                                 the <b>%+</b> job, if the
                                                 later did not exist.
                              %<u>n</u>      %<u>n</u>         The job with
                                                 job-number <u>n</u>.
                           %?<u>string</u>   %?<u>string</u>   The job containing the
                                                 string <u>string</u> (an
                                                 error occurs if
                                                 multiple jobs
                                                                     are
                                                 matched).
                           %<u>string</u>    %<u>string</u>    The job starting with
                                                 string <u>string</u> (an error
                                                 occurs if multiple jobs
                                                                     are
                                                 matched).

       When a job changes state (<u>e.g.</u>, a background job finishes or foreground job is stopped), the shell prints
       the following status information: <b>[</b><u>number</u><b>]</b> <u>flag</u> <u>status</u> <u>command</u> where

       " <u>number</u>"
           is the job-number of the job.

       " <u>flag</u>"
           is <b>+</b> or <b>-</b> if the job is the <b>%+</b> or <b>%-</b> job, respectively, or space if it is neither.

       " <u>status</u>"
           indicates the current state of the job and can be

       "<b>Running</b>"
           the job has neither stopped or exited (note that running does not necessarily mean consuming CPU time
           — the process could be blocked waiting for some event).

       "<b>Done</b> [<b>(</b><u>number</u><b>)</b>]"
           the job exited.  <u>number</u> is the exit status of the job, which is omitted if the status is zero.

       "<b>Stopped</b> [<b>(</b><u>signal</u><b>)</b>]"
           the job was stopped by the indicated <u>signal</u> (if no signal is given, the job was stopped by SIGTSTP).

       "<u>signal-description</u> [<b>(core</b> <b>dumped)</b>]"
           the job was killed by a signal (<u>e.g.</u>, Memory fault, Hangup, <u>etc.</u>  — use <b>kill</b> <b>-l</b> for a list of signal
           descriptions). The <b>(core</b> <b>dumped)</b> message indicates the process created a core file.

       " <u>command</u>"
           is the command that created the process. If there are multiple processes in the job, then each
           process will have a line showing its <u>command</u> and possibly its <u>status</u>, if it is different from the
           status of the previous process.

       When an attempt is made to exit the shell while there are jobs in the stopped state, the shell warns the
       user that there are stopped jobs and does not exit. If another attempt is immediately made to exit the
       shell, the stopped jobs are sent a <b>HUP</b> signal and the shell exits. Similarly, if the <b>nohup</b> option is not
       set and there are running jobs when an attempt is made to exit a login shell, the shell warns the user
       and does not exit. If another attempt is immediately made to exit the shell, the running jobs are sent a
       <b>HUP</b> signal and the shell exits.

</pre><h4><b>BUILTIN</b> <b>UTILITIES</b></h4><pre>
       posh implements the following builtin utilities:

       •   .

       •   :

       •   [

       •   break

       •   builtin

       •   continue

       •   eval

       •   exec

       •   exit

       •   false

       •   return

       •   set

       •   shift

       •   times

       •   trap

       •   wait

       •   read

       •   test

       •   true

       •   umask

       •   unset

       •   cd

       •   command

       •   echo

       •   export

       •   getopts

       •   kill

       •   local

       •   pwd

       •   readonly

</pre><h4><b>FILES</b></h4><pre>
       <a href="file:~/.profile">~/.profile</a> <a href="file:/etc/profile">/etc/profile</a> /etc/suid_profile

</pre><h4><b>BUGS</b></h4><pre>
       Any bugs in posh should be reported via the Debian BTS. Legitimate bugs are inconsistencies between
       manpage and behavior, and inconsistencies between behavior and Debian policy (currently SUSv3 compliance
       with the following exceptions: echo -n, binary -a and -o to test, local scoping).

</pre><h4><b>VERSION</b></h4><pre>
       This page documents the Policy-compliant Ordinary SHell.

</pre><h4><b>AUTHORS</b></h4><pre>
       This shell is based on pdksh.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/awk.1.html">awk</a></b>(1), <b><a href="../man1/ksh.1.html">ksh</a></b>(1), <b><a href="../man1/dash.1.html">dash</a></b>(1), <b><a href="../man1/ed.1.html">ed</a></b>(1), <b><a href="../man1/getconf.1.html">getconf</a></b>(1), <b><a href="../man1/getopt.1.html">getopt</a></b>(1), <b><a href="../man1/sed.1.html">sed</a></b>(1), <b><a href="../man1/stty.1.html">stty</a></b>(1), <b><a href="../man1/vi.1.html">vi</a></b>(1), <b><a href="../man2/dup.2.html">dup</a></b>(2), <b><a href="../man2/execve.2.html">execve</a></b>(2),
       <b><a href="../man2/getgid.2.html">getgid</a></b>(2), <b><a href="../man2/getuid.2.html">getuid</a></b>(2), <b><a href="../man2/open.2.html">open</a></b>(2), <b><a href="../man2/pipe.2.html">pipe</a></b>(2), <b><a href="../man2/wait.2.html">wait</a></b>(2), <b><a href="../man3/getopt.3.html">getopt</a></b>(3), <b><a href="../man3/rand.3.html">rand</a></b>(3), <b><a href="../man3/signal.3.html">signal</a></b>(3), <b><a href="../man3/system.3.html">system</a></b>(3), <b><a href="../man5/environ.5.html">environ</a></b>(5)

User commands                                      01/24/2011                                            <u><a href="../man1/POSH.1.html">POSH</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>