<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jirb1.3 - interactive JRuby</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/jruby">jruby_9.4.8.0+ds-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jirb1.3 - interactive JRuby

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>jirb</b> [<u>options</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       irb  stands  for  `interactive JRuby'. irb is a tool to execute interactively JRuby expressions read from
       stdin.  Use of jirb is easy if you know JRuby.  Executing jirb, prompts are displayed as  follows.  Then,
       enter expression of ruby. Input is executed when it is syntacticaly completed.

           $ jirb1.3
           <a href="../manmain/irb.main.html">irb</a>(main):001:0&gt; 1+2
           3
           <a href="../manmain/irb.main.html">irb</a>(main):002:0&gt; class Foo
           <a href="../manmain/irb.main.html">irb</a>(main):003:1&gt;  def foo
           <a href="../manmain/irb.main.html">irb</a>(main):004:2&gt;    print 1
           <a href="../manmain/irb.main.html">irb</a>(main):005:2&gt;  end
           <a href="../manmain/irb.main.html">irb</a>(main):006:1&gt; end
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):007:0&gt;

       And,  Readline  extension  module  can be used with irb. Using Readline is the standard default action if
       Readline is installed.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-f</b>     suppress read <a href="file:~/.irbrc">~/.irbrc</a>

       <b>-m</b>     bc mode (fraction or matrix are available)

       <b>-d</b>     set $DEBUG  to true (same as `ruby -d')

       <b>-r</b> <b>load-module</b>
              same as `ruby -r'

       <b>--inspect</b>
              uses `inspect' for output (the default except bc mode)

       <b>--noinspect</b>
              doesn't uses inspect for output

       <b>--readline</b>
              uses Readline extension module

       <b>--noreadline</b>
              doesn't use Readline extension module

       <b>--prompt</b> <b>prompt-mode</b>

       <b>--prompt-mode</b> <b>prompt-mode</b>
              switches prompt mode. Pre-defined prompt modes are `default', `simple', `xmp' and `inf-ruby'

       <b>--inf-ruby-mode</b>
              uses prompt appreciate for inf-ruby-mode on emacs.  Suppresses --readline.

       <b>--simple-prompt</b>
              simple prompt mode

       <b>--noprompt</b>
              no prompt

       <b>--tracer</b>
              display trace for each execution of commands.

       <b>--back-trace-limit</b> <b>n</b>
              displays backtrace top n and tail n. The default value is 16.

       <b>--irb_debug</b> <b>n</b>
              sets internal debug level to n (It shouldn't be used)

       <b>-v,</b> <b>--version</b>
              prints the version of irb

</pre><h4><b>CONFIGURATIONS</b></h4><pre>
       jirb reads `<a href="file:~/.irbrc">~/.irbrc</a>' when it is invoked. If `<a href="file:~/.irbrc">~/.irbrc</a>' doesn't exist jirb  try  to  read  in  the  order
       `.irbrc',  `irb.rc', `_irbrc' then `$irbrc'.  The following is alternative to the command line option. To
       use them type as follows in a jirb session.

           IRB.conf[:IRB_NAME]="irb"
           IRB.conf[:MATH_MODE]=false
           IRB.conf[:USE_TRACER]=false
           IRB.conf[:USE_LOADER]=false
           IRB.conf[:IGNORE_SIGINT]=true
           IRB.conf[:IGNORE_EOF]=false
           IRB.conf[:INSPECT_MODE]=nil
           IRB.conf[:IRB_RC] = nil
           IRB.conf[:BACK_TRACE_LIMIT]=16
           IRB.conf[:USE_LOADER] = false
           IRB.conf[:USE_READLINE] = nil
           IRB.conf[:USE_TRACER] = false
           IRB.conf[:IGNORE_SIGINT] = true
           IRB.conf[:IGNORE_EOF] = false
           IRB.conf[:PROMPT_MODE] = :DEFALUT
           IRB.conf[:PROMPT] = {...}
           IRB.conf[:DEBUG_LEVEL]=0
           IRB.conf[:VERBOSE]=true

</pre><h4><b>Customizing</b> <b>prompt</b></h4><pre>
       To customize the prompt you set a variable

           IRB.conf[:PROMPT]

       For example, describe as follows in `.irbrc'.

           IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode
             :PROMPT_I =&gt; nil,         # normal prompt
             :PROMPT_S =&gt; nil,         # prompt for continuated strings
             :PROMPT_C =&gt; nil,         # prompt for continuated statement
             :RETURN =&gt; "    ==&gt;%s\n"       # format to return value
           }

       Then, invoke irb with the above prompt mode by

           $ jirb1.3 --prompt my-prompt

       Or add the following in `.irbrc'.

           IRB.conf[:PROMPT_MODE] = :MY_PROMPT

       Constants PROMPT_I, PROMPT_S and PROMPT_C specifies  the  format.   In  the  prompt  specification,  some
       special strings are available.

           %N    command name which is running
           %m    to_s of main object (self)
           %M    inspect of main object (self)
           %l    type of string(", ', /, ]), `]' is inner %w[...]
           %NNi  indent level. NN is degits and means as same as printf("%NNd").
                 It can be omitted
           %NNn  line number.
           %%    %
       For instance, the default prompt mode is defined as follows: IRB.conf[:PROMPT_MODE][:DEFAULT] = {

       <b>PROMPT_I</b> <b>=&gt;</b> <b>"%N(%m):%03n:%i&gt;</b> <b>",</b>

       <b>PROMPT_S</b> <b>=&gt;</b> <b>"%N(%m):%03n:%i%l</b> <b>",</b>

       <b>PROMPT_C</b> <b>=&gt;</b> <b>"%N(%m):%03n:%i*</b> <b>",</b>

       <b>RETURN</b> <b>=&gt;</b> <b>"%s\n"}</b>
              RETURN is used to printf.

</pre><h4><b>Configuring</b> <b>subirb</b></h4><pre>
       The  command  line  option  or IRB.conf specify the default behavior of (sub)irb. On the other hand, each
       conf of in the next sction `6. Command' is used to individually configure (sub)irb.  If proc  is  set  to
       IRB.conf[:IRB_RC],  its  subirb  will be invoked after execution of that proc under giving the context of
       irb as its argument. By this mechanism each subirb can be configured.

</pre><h4><b>Command</b></h4><pre>
       For irb commands, both simple name and `irb_'-prefixed name are prepared.

       <b>exit,</b> <b>quit,</b> <b>irb_exit</b>
              Quits (sub)irb.  if you've done cb (see below), exit from the binding mode.

       <b>conf,</b> <b>irb_context</b>
              Displays current configuration. Modifying the configuration is  achieved  by  sending  message  to
              `conf'.

       <b>conf.back_trace_limit</b>
              Sets display lines of backtrace as top n and tail n.  The default value is 16.

       <b>conf.debug_level</b> <b>=</b> <b>N</b>
              Sets debug level of irb.

       <b>conf.ignore_eof</b> <b>=</b> <b>true/false</b>
              Whether ^D (control-d) will be ignored or not.  If false is set, ^D means quit.

       <b>conf.ignore_sigint=</b> <b>true/false</b>
              Whether ^C (control-c) will be ignored or not.  If false is set, ^D means quit.  If true,
                  during input:   cancel inputing then return to top level.
                  during execute: abondon current execution.

       <b>conf.inf_ruby_mode</b> <b>=</b> <b>true/false</b>
              Whether inf-ruby-mode or not. The default value is false.

       <b>conf.inspect_mode</b> <b>=</b> <b>true/false/nil</b>
              Specifies  inspect  mode.   true:   display inspect false: display to_s nil:   inspect mode in non
              math mode,
                  non inspect mode in math mode.

       <b>conf.irb_level</b>
              The level of cb.

       <b>conf.math_mode</b>
              Whether bc mode or not.

       <b>conf.use_loader</b> <b>=</b> <b>true/false</b>
              Whether irb's own file reader method is used when load/require  or  not.   This  mode  is  globaly
              affected (irb wide).

       <b>conf.prompt_c</b>
              prompt for a continuating statement (e.g, immediately after of `if')

       <b>conf.prompt_i</b>
              standard prompt

       <b>conf.prompt_s</b>
              prompt for a continuating string

       <b>conf.rc</b>
              Whether <a href="file:~/.irbrc">~/.irbrc</a> is read or not.

       <b>conf.use_prompt</b> <b>=</b> <b>true/false</b>
              Prompting or not.

       <b>conf.use_readline</b> <b>=</b> <b>true/false/nil</b>
              Whether  readline  is  used  or  not.   true: uses false: doesn't use nil: intends to use readline
              except for inf-reuby-mode (default)

       <b>conf.verbose=T/F</b>
              Whether verbose messages are display or not.

       <b>cb,</b> <b>irb_change_binding</b> <b>[obj]</b>
              Enter new binding which has a distinct scope of local variables.  If obj is  given,  obj  will  be
              self.

       <b>irb</b> <b>[obj]</b>
              Invoke subirb. If obj is given, obj will be self.

       <b>jobs,</b> <b>irb_jobs</b>
              List of subirb

       <b>fg</b> <b>n,</b> <b>irb_fg</b> <b>n</b>
              Switch into specified subirb. The following is candidates of n:
                  irb number
                  thhread
                  irb object
                  self(obj which is specified of irb obj)

       <b>kill</b> <b>n,</b> <b>irb_kill</b> <b>n</b>
              Kill subirb. The means of n is as same as the case of irb_fg.

</pre><h4><b>System</b> <b>variable</b></h4><pre>
       <b>_</b>      The latest value of evaluation (it is local)

</pre><h4><b>Session</b> <b>Example</b></h4><pre>
           $ jirb1.3
           <a href="../manmain/irb.main.html">irb</a>(main):001:0&gt; irb                        # invoke subirb
           irb#<a href="../manmain/1.main.html">1</a>(main):001:0&gt; jobs                     # list of subirbs
           #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)
           #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : running)
           nil
           irb#<a href="../manmain/1.main.html">1</a>(main):002:0&gt; fg 0                     # switch job
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):002:0&gt; class Foo;end
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):003:0&gt; irb Foo                    # invoke subirb which has the
           #              context of Foo
           irb#2(Foo):001:0&gt; def foo                   # define Foo#foo
           irb#2(Foo):002:1&gt;   print 1
           irb#2(Foo):003:1&gt; end
           nil
           irb#2(Foo):004:0&gt; fg 0                      # switch job
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):004:0&gt; jobs                       # list of job
           #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
           #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
           #2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):005:0&gt; Foo.instance_methods       # Foo#foo is defined asurely
           ["foo"]
           <a href="../manmain/irb.main.html">irb</a>(main):006:0&gt; fg 2                       # switch job
           nil
           irb#2(Foo):005:0&gt; def bar                   # define Foo#bar
           irb#2(Foo):006:1&gt;  print "bar"
           irb#2(Foo):007:1&gt; end
           nil
           irb#2(Foo):010:0&gt;  Foo.instance_methods
           ["bar", "foo"]
           irb#2(Foo):011:0&gt; fg 0
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):007:0&gt; f = Foo.new
           #&lt;Foo:0x4010af3c&gt;
           <a href="../manmain/irb.main.html">irb</a>(main):008:0&gt; irb f                      # invoke subirb which has the
           #  context of f (instance of Foo)
           irb#3(#&lt;Foo:0x4010af3c&gt;):001:0&gt; jobs
           #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)
           #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
           #2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)
           #3-&gt;irb#3 on #&lt;Foo:0x4010af3c&gt; (#&lt;Thread:0x4010a1e0&gt; : running)
           nil
           irb#3(#&lt;Foo:0x4010af3c&gt;):002:0&gt; foo         # evaluate f.foo
           1nil
           irb#3(#&lt;Foo:0x4010af3c&gt;):003:0&gt; bar         # evaluate f.bar
           barnil
           irb#3(#&lt;Foo:0x4010af3c&gt;):004:0&gt; kill 1, 2, 3# kill job
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):009:0&gt; jobs
           #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
           nil
           <a href="../manmain/irb.main.html">irb</a>(main):010:0&gt; exit                       # exit

</pre><h4><b>Restrictions</b></h4><pre>
       Because irb evaluates the inputs immediately after the input is syntactically completed, irb gives slight
       different results than directly using ruby. Known differences are pointed out here.

</pre><h4><b>Declaration</b> <b>of</b> <b>the</b> <b>local</b> <b>variable</b></h4><pre>
       The following causes an error in ruby:

           eval "foo = 0"
           foo
           --
           -:2: undefined local variable or method `foo' for #&lt;Object:0x40283118&gt; (NameError)
           ---
           NameError

       Though, the above will successfully done by irb.

           &gt;&gt; eval "foo = 0"
           =&gt; 0
           &gt;&gt; foo
           =&gt; 0

       Ruby  evaluates a code after reading entire of code and determination of the scope of local variables. On
       the other hand, irb do immediately. More precisely, irb evaluate at first

           evel "foo = 0"

       then foo is defined on this timing. It is because of this incompatibility.  If you'd like to detect those
       differences, begin...end can be used:

           &gt;&gt; begin
           ?&gt;   eval "foo = 0"
           &gt;&gt;   foo
           &gt;&gt; end
           NameError: undefined local variable or method `foo' for #&lt;Object:0x4013d0f0&gt;
           (irb):3
           (irb_local_binding):1:in `eval'

</pre><h4><b>Here-document</b></h4><pre>
       Implementation of Here-document is incomplete.

</pre><h4><b>Symbol</b></h4><pre>
       Irb can not always recognize a symbol as to be Symbol. Concretely, an expression have completed,  however
       Irb regard it as continuation line.

                                                   April 2007                                         <u><a href="../man1/JIRB1.3.1.html">JIRB1.3</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>