<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sql-split - SQL splitting command line utility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libsql-splitstatement-perl">libsql-splitstatement-perl_1.00023-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sql-split - SQL splitting command line utility

</pre><h4><b>SYNOPSIS</b></h4><pre>
           sql-split [ OPTIONS ] [ FILE(S) ]
           sql-split --man

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This program tries to split any SQL code (even containing non-standard and/or procedural extensions, at
       least the ones from the most popular DBMSs) into the atomic statements it is composed of.

       The given FILES are read and split one by one, and the resulting statements are printed to the standard
       output, separated by a customizable string (see below).  Each given file must contain only full SQL
       statements, that is, no single atomic statement can span multiple files.

       If no file is given, or if one of the file names is a "-" (dash), the SQL code is read from STDIN, so
       that this program can be used as a <u>filter</u> or even interactively.

       Consider however that this is by no means a validating parser, so that errors in SQL code will not be
       detected (and can even lead to incorrect splitting).

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>-t,</b> <b>--terminators</b>
       It causes the trailing terminator tokens to be kept in the returned atomic statements (by default they
       are discarded instead).

       The strings currently recognized as terminators (depending on the context) are:

       •   ";" (the <u>semicolon</u> character);

       •   any string defined by the MySQL "DELIMITER" command;

       •   an ";" followed by an "/" (<u>forward-slash</u> character) on its own line;

       •   an ";" followed by an "." (<u>dot</u> character) on its own line, followed by an "/" on its own line;

       •   an "/" on its own line regardless of the preceding characters (only if the "slash_terminates" option,
           explained below, is set).

       The  multi-line  terminators  above  are always treated as a single token, that is they are discarded (or
       returned) as a whole (regardless of the "--no-slash-terminates" option value).

   <b>-x,</b> <b>--spaces,</b> <b>--extra-spaces</b>
       It causes the space characters around the  statements,  if  any,  to  be  kept  in  the  returned  atomic
       statements (by default they are trimmed instead). A mnemonic for the short version is "X-tra spaces".

   <b>-c,</b> <b>--comments</b>
       It  causes  the comments, if any, to be kept in the returned atomic statements (by default any comment is
       discarded instead).

       Both SQL and multi-line C-style comments are recognized.

   <b>-m,</b> <b>--empty,</b> <b>--empty-statements</b>
       It causes the empty statements to be returned (by default, they are discarded instead).

       A statement is considered empty when it contains no  characters  other  than  the  terminator  and  space
       characters.  A  statement  composed  solely  of  comments  is not recognized as empty and it is therefore
       returned, if the "--comments" option is used. Note instead that an empty statement is recognized as  such
       regardless of the use of the "--terminators" and "--extra-spaces" options.

       A mnemonic for this option is keep "M-ty" statements.

   <b>--no-slash,</b> <b>--no-slash-terminates</b>
       By  default  a  "/" (<u>forward-slash</u>) on its own line, even without a preceding semicolon, is admitted as a
       candidate terminator.

       When this option is used instead, a forward-slash on its own line is treated as  a  statement  terminator
       only if preceded by a semicolon or by a dot and a semicolon.

       If  you  are  dealing  with Oracle's SQL, you should not use this option, since a slash (alone, without a
       preceding semicolon) is often used as a  terminator,  as  it  is  permitted  by  SQL*Plus  (on  non-<u>block</u>
       statements).

       With  SQL dialects other than Oracle, there is the (theoretical) possibility that a slash on its own line
       could pass the additional checks and be considered a terminator (while it shouldn't). This chance  should
       be  really  tiny  (it  has never been observed in real world code indeed). Though negligible, this option
       will anyway rule out that risk.

   <b>-s,</b> <b>--oss,</b> <b>--output-statement-separator</b> <u><b>string</b></u>
       The string which will be printed between every pair of returned atomic statements. By default,  it  is  a
       "--" (<u>double</u> <u>dash</u>) on its own line.

       To  use  special  characters  (such as newlines) when passing such string, please consult your shell docs
       (for example, in Bash the above mentioned default separator could be defined as "$'\n--\n'").

       Note that the last returned statement (for each processed file) will not be followed by such separator.

   <b>-f,</b> <b>--ofs,</b> <b>--output-file-separator</b> <u><b>string</b></u>
       The string which will be printed between the groups of statements coming from different files. By default
       it is the "-- &gt;&gt;&gt;*&lt;&lt;&lt; --" string on its own line.

       Similarly to the statement separator, the file separator will not be printed after the last file.

   <b>-e,</b> <b>--error,</b> <b>--on-error</b> <u><b>value</b></u>
       It controls the program behavior in case one of the given files is not accessible.

       It can take the following values:

       •   "stop" or 0, which causes the program to die at the first file which can not be opened, but it prints
           all the statements split that far (this is the default);

       •   "continue" or 1, which causes the program, when it encounters a file error, to just  emit  a  warning
           (on STDERR) and continue with the next file;

       •   "no-output"  or 2, which, just like "stop", causes the program to die at the first file error, but in
           this case it does not print any statement, not even those coming from  the  previous  (already  read)
           files; in other words, the statements are printed out only if (and after) all of the given files have
           been successfully read.

       The above listed string values are case-insensitive.

   <b>-h,</b> <b>-?,</b> <b>--help</b>
       It prints a brief help message and exits.

   <b>--man</b>
       It shows the full man page.

   <b>--version</b>
       It prints the program version and exits.

</pre><h4><b>SUPPORTED</b> <b>DBMSs</b></h4><pre>
       sql-split  aims  to  cover  the  widest  possible  range  of  DBMSs,  SQL  dialects  and extensions (even
       proprietary), in a (nearly) fully transparent way for the user.

       Currently it has been tested mainly on SQLite, PostgreSQL, MySQL and Oracle.

   <b>Procedural</b> <b>Extensions</b>
       Procedural code is by far the most complex to handle.

       Currently any block of code which start with "FUNCTION", "PROCEDURE", "DECLARE", "CREATE"  or  "CALL"  is
       correctly  recognized,  as  well  as  <u>anonymous</u>  "BEGIN  ... END" blocks, <u>dollar</u> <u>quoted</u> blocks and blocks
       delimited by a "DELIMITER"-defined <u>custom</u> <u>terminator</u>, therefore a wide  range  of  procedural  extensions
       should be handled correctly. However, only PL/SQL, PL/PgSQL and MySQL code has been tested so far.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       None  currently  known  (other  than  the lack of tests on SQL dialects different from the ones described
       above).

   <b>Non-limitations</b>
       To be split correctly, the given input must, in general, be syntactically  valid  SQL.  For  example,  an
       unbalanced  "BEGIN"  or  a  misspelled keyword could, under certain circumstances, confuse the parser and
       make it trip over the next statement terminator, thus returning non-split statements. This should not  be
       a  problem though, as the original (invalid) SQL code would have been unusable anyway (remember that this
       is NOT a validating parser!)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   SQL::SplitStatement (perldoc SQL::SplitStatement)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2011 <u>Emanuele</u> <u>Zeppieri</u> &lt;<a href="mailto:emazep@cpan.org">emazep@cpan.org</a>&gt;.

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       See &lt;<a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>&gt;

</pre><h4><b>NO</b> <b>WARRANTY</b></h4><pre>
       This  program  comes  with  NO  WARRANTIES  of  any kind. It not only may cause loss of data and hardware
       damaging, but it may also cause several bad diseases to nearby people, including,  but  not  limited  to,
       diarrhoea, gonorrhea and dysmenorrhea.  Don't say you haven't been warned.

perl v5.36.0                                       2022-10-16                                      <u><a href="../man1p/SQL-SPLIT.1p.html">SQL-SPLIT</a></u>(1p)
</pre>
 </div>
</div></section>
</div>
</body>
</html>