<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ecm - integer factorization using ECM, P-1 or P+1</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/gmp-ecm">gmp-ecm_7.0.6+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ecm - integer factorization using ECM, P-1 or P+1

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>ecm</b> [<b>options</b>] <u>B1</u> [<u>B2min</u>-<u>B2max</u> | <u>B2</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       ecm is an integer factoring program using the Elliptic Curve Method (ECM), the P-1 method, or the P+1
       method. The following sections describe parameters relevant to these algorithms.

</pre><h4><b>STEP</b> <b>1</b> <b>AND</b> <b>STEP</b> <b>2</b> <b>BOUND</b> <b>PARAMETERS</b></h4><pre>
       <u>B1</u>
           <u>B1</u> is the step 1 bound. It is a mandatory parameter. It can be given either in integer format (for
           example 3000000) or in floating-point format (3000000.0 or 3e6). The largest possible <u>B1</u> value is
           9007199254740996 for P-1, and ULONG_MAX or 9007199254740996 (whichever is smaller) for ECM and P+1.
           All primes 2 &lt;= p &lt;= <u>B1</u> are processed in step 1.

       <u>B2</u>
           <u>B2</u> is the step 2 bound. It is optional: if omitted, a default value is computed from <u>B1</u>, which should
           be close to optimal. Like <u>B1</u>, it can be given either in integer or in floating-point format. The
           largest possible value of <u>B2</u> is approximately 9e23, but depends on the number of blocks <u>k</u> if you
           specify the <b>-k</b> option. All primes <u>B1</u> &lt;= p &lt;= <u>B2</u> are processed in step 2. If <u>B2</u> &lt; <u>B1</u>, no step 2 is
           performed.

       <u>B2min</u><b>-</b><u>B2max</u>
           alternatively one may use the <u>B2min</u>-<u>B2max</u> form, which means that all primes <u>B2min</u> &lt;= p &lt;= <u>B2max</u>
           should be processed. Thus specifying <u>B2</u> only corresponds to <u>B1</u>-<u>B2</u>. The values of <u>B2min</u> and <u>B2max</u> may
           be arbitrarily large, but their difference must not exceed approximately 9e23, subject to the number
           of blocks <u>k</u>.

</pre><h4><b>FACTORING</b> <b>METHOD</b></h4><pre>
       <b>-pm1</b>
           Perform P-1 instead of the default method (ECM).

       <b>-pp1</b>
           Perform P+1 instead of the default method (ECM).

</pre><h4><b>GROUP</b> <b>AND</b> <b>INITIAL</b> <b>POINT</b> <b>PARAMETERS</b></h4><pre>
       <b>-x0</b> <u>x</u>
           [ECM, P-1, P+1] Use <u>x</u> (arbitrary-precision integer or rational) as initial point. For example, <b>-x0</b>
           <b>1/3</b> is valid. If not given, <u>x</u> is generated from the sigma value for ECM, or at random for P-1 and
           P+1.

       <b>-sigma</b> <u>s</u>
           [ECM] Use <u>s</u> (arbitrary-precision integer) as curve generator. If omitted, <u>s</u> is generated at random.

       <b>-A</b> <u>a</u>
           [ECM] Use <u>a</u> (arbitrary-precision integer) as curve parameter. If omitted, is it generated from the
           sigma value.

       <b>-go</b> <u>val</u>
           [ECM, P-1, P+1] Multiply the initial point by <u>val</u>, which can any valid expression, possibly
           containing the special character N as place holder for the current input number. Example:

               ecm -pp1 -go "N^2-1" 1e6 &lt; composite2000

</pre><h4><b>STEP</b> <b>2</b> <b>PARAMETERS</b></h4><pre>
       <b>-k</b> <u>k</u>
           [ECM, P-1, P+1] Perform <u>k</u> blocks in step 2. For a given <u>B2</u> value, increasing <u>k</u> decreases the memory
           usage of step 2, at the expense of more cpu time.

       <b>-treefile</b> <u>file</u>
           Stores some tables of data in disk files to reduce the amount of memory occupied in step 2, at the
           expense of disk I/O. Data will be written to files <u>file</u>.1, <u>file</u>.2 etc. Does not work with fast stage
           2 for P+1 and P-1.

       <b>-power</b> <u>n</u>
           [ECM] Use x^<u>n</u> for Brent-Suyama's extension (<b>-power</b> <b>1</b> disables Brent-Suyama's extension). The default
           polynomial is chosen depending on the method and B2.

       <b>-dickson</b> <u>n</u>
           [ECM] Use degree-<u>n</u> Dickson's polynomial for Brent-Suyama's extension.

       <b>-maxmem</b> <u>n</u>
           Use at most <u>n</u> megabytes of memory in stage 2.

       <b>-ntt</b>, <b>-no-ntt</b>
           Enable or disable the Number-Theoretic Transform code for polynomial arithmetic in stage 2. With NTT,
           dF is chosen to be a power of 2, and is limited by the number suitable primes that fit in a machine
           word (which is a limitation only on 32 bit systems). The -no-ntt variant uses more memory, but is
           faster than NTT with large input numbers. By default, NTT is used for P-1, P+1 and for ECM on numbers
           of size at most 30 machine words.

</pre><h4><b>OUTPUT</b></h4><pre>
       <b>-q</b>
           Quiet mode. Found factorizations are printed on standard output, with factors separated by white
           spaces, one line per input number (if no factor was found, the input number is simply copied).

       <b>-v</b>
           Verbose mode. More information is printed, more <b>-v</b> options increase verbosity. With one <b>-v</b>, the kind
           of modular multiplication used, initial x0 value, step 2 parameters and progress, and expected curves
           and time to find factors of different sizes for ECM are printed. With <b>-v</b> <b>-v</b>, the A value for ECM and
           residues at the end of step 1 and step 2 are printed. More <b>-v</b> print internal data for debugging.

       <b>-timestamp</b>
           Print a time stamp whenever a new ECM curve or P+1 or P-1 run is processed.

</pre><h4><b>MODULAR</b> <b>ARITHMETIC</b> <b>OPTIONS</b></h4><pre>
       Several algorithms are available for modular multiplication. The program tries to find the best one for
       each input; one can force a given method with the following options.

       <b>-mpzmod</b>
           Use GMP's mpz_mod function (sub-quadratic for large inputs, but induces some overhead for small
           ones).

       <b>-modmuln</b>
           Use Montgomery's multiplication (quadratic version). Usually best method for small input.

       <b>-redc</b>
           Use Montgomery's multiplication (sub-quadratic version). Theoretically optimal for large input.

       <b>-nobase2</b>
           Disable special base-2 code (which is used when the input number is a large factor of 2^n+1 or 2^n-1,
           see <b>-v</b>).

       <b>-base2</b> <u>n</u>
           Force use of special base-2 code, input number must divide 2^<u>n</u>+1 if <u>n</u> &gt; 0, or 2^|<u>n</u>|-1 if <u>n</u> &lt; 0.

</pre><h4><b>FILE</b> <b>I/O</b></h4><pre>
       The following options enable one to perform step 1 and step 2 separately, either on different machines,
       at different times, or using different software (in particular, George Woltman's Prime95/mprime program
       can produce step 1 output suitable for resuming with GMP-ECM). It can also be useful to split step 2 into
       several runs, using the <u>B2min-B2max</u> option.

       <b>-inp</b> <u>file</u>
           Take input from file <u>file</u> instead of from standard input.

       <b>-save</b> <u>file</u>
           Save result of step 1 in <u>file</u>. If <u>file</u> exists, an error is raised. Example: to perform only step 1
           with <u>B1</u>=1000000 on the composite number in the file "c155" and save its result in file "foo", use

               ecm -save foo 1e6 1 &lt; c155

       <b>-savea</b> <u>file</u>
           Like <b>-save</b>, but appends to existing files.

       <b>-resume</b> <u>file</u>
           Resume residues from <u>file</u>, reads from standard input if <u>file</u> is "-". Example: to perform step 2
           following the above step 1 computation, use

               ecm -resume foo 1e6

       <b>-chkpoint</b> <u>file</u>
           Periodically write the current residue in stage 1 to <u>file</u>. In case of a power failure, etc., the
           computation can be continued with the <b>-resume</b> option.

               ecm -chkpnt foo -pm1 1e10 &lt; largenumber.txt

</pre><h4><b>LOOP</b> <b>MODE</b></h4><pre>
       The “loop mode” (option <b>-c</b> <u>n</u>) enables one to run several curves on each input number. The following
       options control its behavior.

       <b>-c</b> <u>n</u>
           Perform <u>n</u> runs on each input number (default is one). This option is mainly useful for P+1 (for
           example with <u>n</u>=3) or for ECM, where <u>n</u> could be set to the expected number of curves to find a d-digit
           factor with a given step 1 bound. This option is incompatible with <b>-resume,</b> <b>-sigma,</b> <b>-x0</b>. Giving <b>-c</b> <b>0</b>
           produces an infinite loop until a factor is found.

       <b>-one</b>
           In loop mode, stop when a factor is found; the default is to continue until the cofactor is prime or
           the specified number of runs are done.

       <b>-b</b>
           Breadth-first processing: in loop mode, run one curve for each input number, then a second curve for
           each one, and so on. This is the default mode with <b>-inp</b>.

       <b>-d</b>
           Depth-first processing: in loop mode, run <u>n</u> curves for the first number, then <u>n</u> curves for the second
           one and so on. This is the default mode with standard input.

       <b>-ve</b> <u>n</u>
           In loop mode, in the second and following runs, output only expressions that have at most <u>n</u>
           characters. Default is <b>-ve</b> <b>0</b>.

       <b>-i</b> <u>n</u>
           In loop mode, increment <u>B1</u> by <u>n</u> after each curve.

</pre><h4><b>SHELL</b> <b>COMMAND</b> <b>EXECUTION</b></h4><pre>
       These optins allow for executing shell commands to supplement functionality to GMP-ECM.

       <b>-prpcmd</b> <u>cmd</u>
           Execute command <u>cmd</u> to test primality if factors and cofactors instead of GMP-ECM's own functions.
           The number to test is passed via stdin. An exit code of 0 is interpreted as “probably prime”, a
           non-zero exit code as “composite”.

       <b>-faccmd</b> <u>cmd</u>
           Executes command <u>cmd</u> whenever a factor is found by P-1, P+1 or ECM. The input number, factor and
           cofactor are passed via stdin, each on a line. This could be used i.e. to mail new factors
           automatically:

               ecm -faccmd 'mail -s “$HOSTNAME found a factor”
                               <a href="mailto:me@myaddress.com">me@myaddress.com</a>' 11e6 &lt; cunningham.in

       <b>-idlecmd</b> <u>cmd</u>
           Executes command <u>cmd</u> before each ECM curve, P-1 or P+1 attempt on a number is started. If the exit
           status of <u>cmd</u> is non-zero, GMP-ECM terminates immediately, otherwise it continues normally. GMP-ECM
           is stopped while <u>cmd</u> runs, offering a way for letting GMP-ECM sleep for example while the system is
           otherwise busy.

</pre><h4><b>MISCELLANEOUS</b></h4><pre>
       <b>-n</b>
           Run the program in “nice” mode (below normal priority).

       <b>-nn</b>
           Run the program in “very nice” mode (idle priority).

       <b>-B2scale</b> <u>f</u>
           Multiply the default step 2 bound <u>B2</u> by the floating-point value <u>f</u>. Example: <b>-B2scale</b> <b>0.5</b> divides the
           default <u>B2</u> by 2.

       <b>-stage1time</b> <u>n</u>
           Add <u>n</u> seconds to stage 1 time. This is useful to get correct expected time with <u>-v</u> if part of stage 1
           was done in another run.

       <b>-cofdec</b>
           Force cofactor output in decimal (even if expressions are used).

       <b>-h</b>, <b>--help</b>
           Display a short description of ecm usage, parameters and command line options.

       <b>-printconfig</b>
           Prints configuration parameters used for the compilation and exits.

</pre><h4><b>INPUT</b> <b>SYNTAX</b></h4><pre>
       The input numbers can have several forms:

       Raw decimal numbers like 123456789.

       Comments can be placed in the file: everything after “//” is ignored, up to the end of line.

       Line continuation. If a line ends with a backslash character “\”, it is considered to continue on the
       next line.

       Common arithmetic expressions can be used. Example: <u>3*5+(2+7)^10</u>.

       Factorial: example <u>53!</u>.

       Multi-factorial: example <u>15!3</u> means 15*12*9*6*3.

       Primorial: example <u>11#</u> means 2*3*5*7*11.

       Reduced primorial: example <u>17#5</u> means 5*7*11*13*17.

       Functions:

       GCD(a,b): Greatest common divisor
           example GCD(120,28) = 4

       Phi(n,x): n-th Cyclotomic Polynomial evaluated at x
           example Phi(3,5) = 1 + x + x^2 = 31

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The exit status reflects the result of the last ECM curve or P-1/P+1 attempt the program performed.
       Individual bits signify particular events, specifically:

       Bit 0
           0 if normal program termination, 1 if error occurred

       Bit 1
           0 if no proper factor was found, 1 otherwise

       Bit 2
           0 if factor is composite, 1 if factor is a probable prime

       Bit 3
           0 if cofactor is composite, 1 if cofactor is a probable prime

       Thus, the following exit status values may occur:

       0
           Normal program termination, no factor found

       1
           Error

       2
           Composite factor found, cofactor is composite

       6
           Probable prime factor found, cofactor is composite

       8
           Input number found

       10
           Composite factor found, cofactor is a probable prime

       14
           Probable prime factor found, cofactor is a probable prime

</pre><h4><b>BUGS</b></h4><pre>
       Report bugs on &lt;https://gitlab.inria.fr/zimmerma/ecm/&gt;.

</pre><h4><b>AUTHORS</b></h4><pre>
       Pierrick Gaudry &lt;gaudry at lix dot polytechnique dot fr&gt; contributed efficient assembly code for combined
       mul/redc;

       Jim Fougeron &lt;jfoug at cox dot net&gt; contributed the expression parser and several command-line options;

       Laurent Fousse &lt;laurent at komite dot net&gt; contributed the middle product code, the autoconf/automake
       tools, and is the maintainer of the Debian package;

       Alexander Kruppa &lt;(lastname)<a href="mailto:al@loria.fr">al@loria.fr</a>&gt; contributed estimates for probability of success for ECM, the
       new P+1 and P-1 stage 2 (with P.-L. Montgomery), new AMD64 asm mulredc code, and some other things;

       Dave Newman &lt;david.(lastname)@jesus.ox.ac.uk&gt; contributed the Kronecker-Schoenhage and NTT multiplication
       code;

       Jason S. Papadopoulos contributed a speedup of the NTT code

       Paul Zimmermann &lt;zimmerma at loria dot fr&gt; is the author of the first version of the program and chief
       maintainer of GMP-ECM.

       Note: email addresses have been obscured, the required substitutions should be obvious.

April 22, 2003                                     09/01/2024                                             <u><a href="../man1/ECM.1.html">ECM</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>