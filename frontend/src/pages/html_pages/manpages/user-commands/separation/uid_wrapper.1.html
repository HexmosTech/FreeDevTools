<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uid_wrapper - A wrapper to fake privilege separation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libuid-wrapper">libuid-wrapper_1.3.1-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       uid_wrapper - A wrapper to fake privilege separation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       LD_PRELOAD=libuid_wrapper.so UID_WRAPPER=1 UID_WRAPPER_ROOT=1 <b>./myapplication</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       •   Allows uid switching as a normal user.

       •   Start any application making it believe it is running as root.

       •   Support for user/group changing in the local thread using the syscalls (like glibc).

       •   More precisely this library intercepts seteuid and related calls, and simulates them in a manner
           similar to the nss_wrapper and socket_wrapper libraries.

       Some projects like a file server need privilege separation to be able to switch to the connection user
       and do file operations. uid_wrapper convincingly lies to the application letting it believe it is
       operating as root and even switching between UIDs and GIDs as needed.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       <b>UID_WRAPPER</b>
           If you load the uid_wrapper and enable it with setting UID_WRAPPER=1 all setuid and setgid will work,
           even as a normal user.

       <b>UID_WRAPPER_ROOT</b>
           It is possible to start your application as fake root with setting UID_WRAPPER_ROOT=1.

       <b>UID_WRAPPER_DEBUGLEVEL</b>
           If you need to see what is going on in uid_wrapper itself or try to find a bug, you can enable
           logging support in uid_wrapper if you built it with debug symbols.

           •   0 = ERROR

           •   1 = WARNING

           •   2 = DEBUG

           •   3 = TRACE

       <b>UID_WRAPPER_MYUID</b>
           This environment variable can be used to tell uid_wrapper to let geteuid() return the real (instead
           of the faked) UID of the user who started the process with uid_wrapper.

           uid_t uid;

           setenv("UID_WRAPPER_MYUID", "1", 1);
           uid = geteuid();
           unsetenv("UID_WRAPPER_MYUID");

       <b>UID_WRAPPER_DISABLE_DEEPBIND</b>
           This allows you to disable deep binding in uid_wrapper. This is useful for running valgrind tools or
           sanitizers like (address, undefined, thread).

</pre><h4><b>EXAMPLE</b></h4><pre>
           $ LD_PRELOAD=libuid_wrapper.so UID_WRAPPER=1 UID_WRAPPER_ROOT=1 id
           uid=0(root) gid=0(root) 0(root)

</pre><h4><b>WORKAROUNDS</b></h4><pre>
       If you need to write code that behaves differently depending on whether uid_wrapper is enabled or not,
       for example in cases where you have to file permissions, you can predefine the uid_wrapper_enabled()
       function in your project as follows:

           bool uid_wrapper_enabled(void)
           {
               return false;
           }

       Since uid_wrapper overloads this function if enabled, you can use it in your code to detect uid_wrapper.

                                                   2015-11-03                                     <u><a href="../man1/UID_WRAPPER.1.html">UID_WRAPPER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>