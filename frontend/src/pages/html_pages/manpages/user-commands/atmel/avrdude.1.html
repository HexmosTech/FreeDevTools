<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avrdude — driver program for ``simple'' Atmel AVR MCU programmer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/avrdude">avrdude_7.1+dfsg-3build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avrdude — driver program for ``simple'' Atmel AVR MCU programmer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>avrdude</b>  <b>-p</b>  <u>partno</u>  [<b>-b</b>  <u>baudrate</u>]  [<b>-B</b> <u>bitclock</u>] [<b>-c</b> <u>programmer-id</u>] [<b>-C</b> <u>config-file</u>] [<b>-A</b>] [<b>-D</b>] [<b>-e</b>] [<b>-E</b>
               <u>exitspec</u>[,<u>exitspec</u>]]  [<b>-F</b>]  [<b>-i</b>  <u>delay</u>]  [<b>-l</b>   <u>logfile</u>]   [<b>-n</b>]   [<b>-O</b>]   [<b>-P</b>   <u>port</u>]   [<b>-q</b>]   [<b>-t</b>]
               [<b>-U</b> <u>memtype:op:filename:filefmt</u>] [<b>-v</b>] [<b>-x</b> <u>extended_param</u>] [<b>-V</b>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Avrdude</b>  is  a  program  for  downloading  code and data to Atmel AVR microcontrollers.  <b>Avrdude</b> supports
       Atmel's STK500 programmer, Atmel's AVRISP and AVRISP mkII devices, Atmel's STK600, Atmel's JTAG ICE (mkI,
       mkII and 3, the latter two also in  ISP  mode),  programmers  complying  to  AppNote  AVR910  and  AVR109
       (including  the  Butterfly),  as well as a simple hard-wired programmer connected directly to a <u><a href="../man4/ppi.4.html">ppi</a></u>(4) or
       <u><a href="../man4/parport.4.html">parport</a></u>(4) parallel port, or to a standard serial port.  In the simplest case, the hardware consists just
       of a cable connecting the respective AVR signal lines to the parallel port.

       The MCU is programmed in <u>serial</u> <u>programming</u> <u>mode</u>, so, for the <u><a href="../man4/ppi.4.html">ppi</a></u>(4) based programmer,  the  MCU  signals
       ‘/RESET’,  ‘SCK’,  ‘SDI’  and ‘SDO’ of the AVR's SPI interface need to be connected to the parallel port;
       older boards might use the labels MOSI for SDO or MISO for SDI.  Optionally, some otherwise unused output
       pins of the parallel port can be used to supply power for the  MCU  part,  so  it  is  also  possible  to
       construct  a  passive  stand-alone programming device.  Some status LEDs indicating the current operating
       state of the programmer can be connected, and a signal is available to control a buffer/driver IC 74LS367
       (or 74HCT367).  The latter can be useful to decouple the  parallel  port  from  the  MCU  when  in-system
       programming is used.

       A  number  of equally simple bit-bang programming adapters that connect to a serial port are supported as
       well, among them the popular Ponyprog serial adapter, and the DASA and DASA3 adapters  that  used  to  be
       supported  by  <a href="../man1/uisp.1.html">uisp</a>(1).   Note  that  these  adapters are meant to be attached to a physical serial port.
       Connecting to a serial port emulated on top of USB is likely to not work at all,  or  to  work  abysmally
       slow.

       If  you  happen to have a Linux system with at least 4 hardware GPIOs available (like almost all embedded
       Linux boards) you can do without any additional hardware - just connect them to the SDO, SDI,  RESET  and
       SCK  pins  on  the AVR and use the linuxgpio programmer type. It bitbangs the lines using the Linux sysfs
       GPIO interface. Of course, care should be taken about voltage level  compatibility.  Also,  although  not
       strictly  required, it is strongly advisable to protect the GPIO pins from overcurrent situations in some
       way. The simplest would be to just put some resistors in series or better yet use a 3-state buffer driver
       like the 74HC244. Have a look at <a href="http://kolev.info/blog/2013/01/06/avrdude-linuxgpio/">http://kolev.info/blog/2013/01/06/avrdude-linuxgpio/</a> for a more detailed
       tutorial about using this programmer type.

       Under a Linux installation with direct access to the SPI bus and GPIO pins, such as would be found  on  a
       Raspberry  Pi,  the  ``linuxspi''  programmer  type can be used to directly connect to and program a chip
       using the built in interfaces on the computer. The  requirements  to  use  this  type  are  that  an  SPI
       interface  is  exposed  along  with one GPIO pin. The GPIO serves as the reset output since the Linux SPI
       drivers do not hold chip select down when a transfer is not occurring and thus it cannot be used  as  the
       reset  pin.  A  readily  available level translator should be used between the SPI bus/reset GPIO and the
       chip to avoid potentially damaging the computer's SPI controller in the event that the chip is running at
       5V and the SPI runs at 3.3V. The GPIO chosen for reset can be configured  in  the  avrdude  configuration
       file  using  the  <b>reset</b>  entry  under  the linuxspi programmer, or directly in the port specification. An
       external pull-up resistor should be connected between the AVR's reset pin and Vcc. If Vcc is not the same
       as the SPI voltage, this should be done on the AVR side of the level translator to protect  the  hardware
       from damage.

       The <b>-P</b> <u>portname</u> option for this programmer defaults to <b>/dev/spidev0.0:/dev/gpiochip0</b>.

       Atmel's  STK500  programmer is also supported and connects to a serial port.  Both, firmware versions 1.x
       and 2.x can be handled, but require a different programmer type specification (by now).   Using  firmware
       version  2,  high-voltage  programming  is  also  supported,  both  parallel and serial (programmer types
       stk500pp and stk500hvsp).

       Wiring boards (e.g. Arduino Mega 2560 Rev3) are supported, utilizing STK500 V2.x protocol, but  a  simple
       DTR/RTS toggle is used to set the boards into programming mode.  The programmer type is ``wiring''.  Note
       that  the -D option will likely be required in this case, because the bootloader will rewrite the program
       memory, but no true chip erase can be performed.

       Serial bootloaders that run a skeleton of the STK500 1.x protocol are supported via their own  programmer
       type  ``arduino''.   This  programmer  works  for  the Arduino Uno Rev3 or any AVR that runs the Optiboot
       bootloader.

       Urprotocol is a leaner version of the STK500 1.x protocol that is designed  to  be  backwards  compatible
       with  STK500  v1.x, and allows bootloaders to be much smaller, e.g., as implemented in the urboot project
       https://github.com/stefanrueger/urboot.  The  programmer  type  ``urclock''  caters  for   these   urboot
       programmers.  Owing  to  its  backward  compatibility,  bootloaders  that  can  be  served by the arduino
       programmer can normally also be served by the urclock programmer. This may require specifying the size of
       (to avrdude) unknown bootloaders in bytes using the <b>-x</b> <u>bootsize=&lt;n&gt;</u> option, which is  necessary  for  the
       urclock  programmer  to  enable  it  to  protect  the  bootloader  from  being overwritten. If an unknown
       bootloader has EEPROM read/write capability then the option -x eepromrw informs  avrdude  -c  urclock  of
       that capability.

       The  BusPirate is a versatile tool that can also be used as an AVR programmer.  A single BusPirate can be
       connected to up to 3 independent AVRs. See the section on <u>extended</u> <u>parameters</u> below for details.

       Atmel's STK600 programmer is supported in ISP and high-voltage programming modes,  and  connects  through
       the  USB.   For  ATxmega  devices,  the STK600 is supported in PDI mode.  For ATtiny4/5/9/10 devices, the
       STK600 and AVRISP mkII are supported in TPI mode.

       The simple serial programmer described in Atmel's application note AVR910, and the  bootloader  described
       in  Atmel's  application  note  AVR109  (which  is  also used by the AVR Butterfly evaluation board), are
       supported on a serial port.

       Atmel's JTAG ICE (mkI, mkII, and 3) is supported as well to up- or download memory areas from/to  an  AVR
       target  (no  support  for  on-chip  debugging).   For the JTAG ICE mkII, JTAG, debugWire and ISP mode are
       supported, provided it has a firmware revision of at least 4.14 (decimal).  JTAGICE3 also supports all of
       JTAG, debugWIRE, and ISP mode.  See below for the limitations of debugWire.   For  ATxmega  devices,  the
       JTAG  ICE mkII is supported in PDI mode, provided it has a revision 1 hardware and firmware version of at
       least 5.37 (decimal).  For ATxmega devices, the JTAGICE3 is supported in PDI mode.

       Atmel-ICE (ARM/AVR) is supported in all modes (JTAG, PDI for Xmega, debugWIRE, ISP, UPDI).

       Atmel's XplainedPro boards, using the EDBG protocol  (CMSIS-DAP  compatible),  are  supported  using  the
       "jtag3" programmer type.

       Atmel's  XplainedMini  boards,  using the mEDBG protocol, are also supported using the "jtag3" programmer
       type.

       The AVR Dragon is supported in all modes (ISP, JTAG,  HVSP,  PP,  debugWire).   When  used  in  JTAG  and
       debugWire  mode,  the  AVR Dragon behaves similar to a JTAG ICE mkII, so all device-specific comments for
       that device will apply as well.  When used in ISP mode, the AVR Dragon behaves similar to an AVRISP  mkII
       (or  JTAG  ICE  mkII  in ISP mode), so all device-specific comments will apply there.  In particular, the
       Dragon starts out with a rather fast ISP clock frequency, so the <b>-B</b> <u>bitclock</u> option might be required  to
       achieve  a  stable  ISP  communication.   For  ATxmega  devices, the AVR Dragon is supported in PDI mode,
       provided it has a firmware version of at least 6.11 (decimal).

       The avrftdi, USBasp ISP and USBtinyISP adapters are also supported, provided <b>avrdude</b>  has  been  compiled
       with  libusb  support.   USBasp ISP and USBtinyISP both feature simple firmware-only USB implementations,
       running on an ATmega8 (or ATmega88), or ATtiny2313, respectively. If libftdi has  has  been  compiled  in
       <b>avrdude</b>,  the  avrftdi  device  adds  support for many programmers using FTDI's 2232C/D/H and 4232H parts
       running in MPSSE mode, which hard-codes (in the chip) SCK to bit 1, SDO to bit 2, and SDI to bit 3. Reset
       is usually bit 4.

       The Atmel DFU bootloader is supported in both, FLIP protocol version 1 (AT90USB* and ATmega*U*  devices),
       as well as version 2 (Xmega devices).  See below for some hints about FLIP version 1 protocol behaviour.

       The  MPLAB(R)  PICkit  4  and  MPLAB(R)  SNAP,  are  supported in JTAG, TPI, ISP, PDI and UPDI mode.  The
       Curiosity Nano board is supported in UPDI mode. It is dubbed “PICkit on Board”, thus the name <u>pkobn_updi</u>.

       SerialUPDI      programmer      implementation      is      based      on      Microchip's      <u>pymcuprog</u>
       <b>https://github.com/microchip-pic-avr-tools/pymcuprog</b>  utility,  but  it  also  contains  some performance
       improvements included in Spence Konde's <u>DxCore</u> Arduino core <b>https://github.com/SpenceKonde/DxCore</b>.  In  a
       nutshell,  this  programmer  consists of simple USB-&gt;UART adapter, diode and couple of resistors. It uses
       serial connection to provide UPDI interface.  See the texinfo documentation for more  details  and  known
       issues.

       The  jtag2updi  programmer is supported, and can program AVRs with a UPDI interface.  Jtag2updi is just a
       firmware that can be uploaded to an AVR, which enables it to interface with  avrdude  using  the  jtagice
       mkii protocol via a serial link.  <b>https://github.com/ElTangas/jtag2updi</b>

       The  Micronucleus bootloader is supported for both protocol version V1 and V2. As the bootloader does not
       support reading from flash memory, use the <b>-V</b> option to prevent AVRDUDE from verifying the flash  memory.
       See the section on <u>extended</u> <u>parameters</u> for Micronucleus specific options.

       The  Teensy  bootloader is supported for all AVR boards.  As the bootloader does not support reading from
       flash memory, use the <b>-V</b> option to prevent AVRDUDE from verifying the flash memory.  See the  section  on
       <u>extended</u> <u>parameters</u> for Teensy specific options.

       Input  files  can  be  provided,  and  output files can be written in different file formats, such as raw
       binary files containing the data to download to the chip, Intel hex format, or Motorola S-record  format.
       There  are  a number of tools available to produce those files, like <u><a href="../man1/asl.1.html">asl</a></u>(1) as a standalone assembler, or
       <u><a href="../man1/avr-objcopy.1.html">avr-objcopy</a></u>(1) for the final stage of the GNU toolchain for the AVR microcontroller.

       Provided <u><a href="../man3/libelf.3.html">libelf</a></u>(3) was present when compiling <b>avrdude</b>, the input file can also be the final ELF  file  as
       produced by the linker.  The appropriate ELF section(s) will be examined, according to the memory area to
       write to.

       <b>Avrdude</b> can program the EEPROM and flash ROM memory cells of supported AVR parts.  Where supported by the
       serial  instruction set, fuse bits and lock bits can be programmed as well.  These are implemented within
       <b>avrdude</b> as separate memory types and can be programmed using data from a file (see the <b>-U</b> option) or from
       terminal mode (see the <u>dump</u> and <u>write</u> commands).  It is also possible to read the chip (provided  it  has
       not  been  code-protected  previously,  of course) and store the data in a file.  Finally, a ``terminal''
       mode is available that allows one to interactively communicate with the MCU, and to  display  or  program
       individual  memory  cells.   On  the STK500 and STK600 programmer, several operational parameters (target
       supply voltage, target Aref voltage, programming clock) can be examined and changed from within  terminal
       mode as well.

   <b>Options</b>
       In  order  to  control  all  the  different  operation  modi, a number of options need to be specified to
       <b>avrdude</b>.

             <b>-p</b> <u>partno</u>
                     This option specifies the MCU connected to the programmer. The MCU  descriptions  are  read
                     from the config file. For currently supported MCUs use ? as partno, which will print a list
                     of  partno  ids  and  official part names.  Both can be used with the -p option. If -p ? is
                     specified with a specific programmer, see -c below, then only those parts are  output  that
                     the  programmer  expects  to  be able to handle, together with the programming interface(s)
                     that can be used in that combination. In reality there can be deviations  from  this  list,
                     particularly if programming is directly via a bootloader.

                     Following parts need special attention:

                     AT90S1200   The  ISP programming protocol of the AT90S1200 differs in subtle ways from that
                                 of other AVRs.  Thus, not all programmers support this device.  Known  to  work
                                 are  all  direct  bitbang programmers, and all programmers talking the STK500v2
                                 protocol.

                     AT90S2343   The AT90S2323 and ATtiny22 use the same algorithm.

                     ATmega2560, ATmega2561
                                 Flash addressing above 128 KB is not supported  by  all  programming  hardware.
                                 Known to work are jtag2, stk500v2, and bit-bang programmers.

                     ATtiny11    The ATtiny11 can only be programmed in high-voltage serial mode.

             <b>-p</b> <u>wildcard/flags</u>
                     Run  developer  options for MCUs that are matched by wildcard. Whilst their main use is for
                     developers some flags can be of  utility  for  users,  e.g.,  avrdude  -p  m328p/S  outputs
                     AVRDUDE's  understanding  of ATmega328P MCU properties; for more information run avrdude -p
                     x/h.

             <b>-b</b> <u>baudrate</u>
                     Override the RS-232 connection baud rate specified in the respective programmer's entry  of
                     the configuration file.

             <b>-B</b> <u>bitclock</u>
                     Specify the bit clock period for the JTAG, PDI, TPI, UPDI, or ISP interface. The value is a
                     floating-point  number  in  microseconds.   Alternatively, the value might be suffixed with
                     "Hz", "kHz" or "MHz" in order to specify the bit clock frequency rather than a period. Some
                     programmers default their bit clock value to a 1 microsecond bit clock period, suitable for
                     target MCUs running at 4 MHz clock and above. Slower MCUs need a correspondingly higher bit
                     clock period. Some programmers reset their bit clock value to the default  value  when  the
                     programming  software  signs  off, whilst others store the last used bit clock value. It is
                     recommended to always specify the bit clock if read/write speed is important.  You can  use
                     the    'default_bitclock'    keyword    in   your   <u>${HOME}/.config/avrdude/avrdude.rc</u>   or
                     <u>${HOME}/.avrduderc</u> file to assign a default value to  keep  from  having  to  specify  this
                     option on every invocation.

             <b>-c</b> <u>programmer-id</u>
                     Use the programmer specified by the argument.  Programmers and their pin configurations are
                     read  from the config file (see the <b>-C</b> option).  New pin configurations can be easily added
                     or modified through the  use  of  a  config  file  to  make  <b>avrdude</b>  work  with  different
                     programmers  as  long  as the programmer supports the Atmel AVR serial program method.  You
                     can use the 'default_programmer'  keyword  in  your  <u>${HOME}/.config/avrdude/avrdude.rc</u>  or
                     <u>${HOME}/.avrduderc</u>  file to assign a default programmer to keep from having to specify this
                     option on every invocation.  A full list of all supported  programmers  is  output  to  the
                     terminal  by  using  ? as programmer-id.  If -c ? is specified with a specific part, see -p
                     above, then only those programmers are output that expect to be able to handle  this  part,
                     together with the programming interface(s) that can be used in that combination. In reality
                     there  can  be  deviations  from  this  list, particularly if programming is directly via a
                     bootloader.

             <b>-c</b> <u>wildcard/flags</u>
                     Run developer options for programmers that are matched by wildcard. Whilst their  main  use
                     is  for developers some flags can be of utility for users, e.g., avrdude -c usbtiny/S shows
                     AVRDUDE's understanding of usbtiny's properties; for more information run avrdude -c x/h.

             <b>-C</b> <u>config-file</u>
                     Use the specified  config  file  to  load  configuration  data.   This  file  contains  all
                     programmer  and part definitions that <b>avrdude</b> knows about.  See the config file, located at
                     <u>/etc/avrdude.conf</u>, which contains a description of the format.

                     If <u>config-file</u> is written as <u>+filename</u> then this file is read after  the  system  wide  and
                     user  configuration  files.  This  can  be used to add entries to the configuration without
                     patching your system wide configuration file. It can be used several times, the  files  are
                     read in same order as given on the command line.

             <b>-A</b>      Disable  the  automatic  removal  of  trailing-0xFF  sequences  in file input that is to be
                     programmed to flash and in AVR reads from flash memory. Normally,  trailing  0xFFs  can  be
                     discarded,  as  flash  programming  requires  the  memory be erased to 0xFF beforehand.  <b>-A</b>
                     should be used when the programmer hardware, or bootloader software for that  matter,  does
                     not  carry  out  chip  erase  and instead handles the memory erase on a page level. Popular
                     Arduino bootloaders exhibit this behaviour; for this reason <b>-A</b> is engaged by  default  when
                     specifying <b>-c</b> arduino.

             <b>-D</b>      Disable  auto  erase for flash.  When the <b>-U</b> option with flash memory is specified, <b>avrdude</b>
                     will perform a chip erase before starting any  of  the  programming  operations,  since  it
                     generally is a mistake to program the flash without performing an erase first.  This option
                     disables  that.   Auto  erase is not used for ATxmega devices as these devices can use page
                     erase before writing each page so no explicit chip erase is required.   Note  however  that
                     any  page not affected by the current operation will retain its previous contents.  Setting
                     <b>-D</b> implies <b>-A.</b>

             <b>-e</b>      Causes a chip erase to be executed.  This will reset the contents  of  the  flash  ROM  and
                     EEPROM  to the value ‘0xff’, and clear all lock bits.  Except for ATxmega devices which can
                     use page erase, it is basically  a  prerequisite  command  before  the  flash  ROM  can  be
                     reprogrammed  again.   The  only  exception  would be if the new contents would exclusively
                     cause bits to be programmed from the value ‘1’ to ‘0’.  Note that  in  order  to  reprogram
                     EEPROM cells, no explicit prior chip erase is required since the MCU provides an auto-erase
                     cycle in that case before programming the cell.

             <b>-E</b> <u>exitspec</u>[,<u>exitspec</u>]
                     By default, <b>avrdude</b> leaves the parallel port in the same state at exit as it has been found
                     at  startup.   This  option modifies the state of the ‘/RESET’ and ‘Vcc’ lines the parallel
                     port is left at, according to the <u>exitspec</u> arguments provided, as follows:

                     <u>reset</u>    The ‘/RESET’ signal will be left activated at program exit, that  is  it  will  be
                              held  <u>low</u>, in order to keep the MCU in reset state afterwards.  Note in particular
                              that the programming algorithm for the AT90S1200 device mandates that the ‘/RESET’
                              signal is active <u>before</u> powering up the MCU, so in case an external  power  supply
                              is  used  for  this  MCU  type,  a previous invocation of <b>avrdude</b> with this option
                              specified is one of the possible ways  to  guarantee  this  condition.   <u>reset</u>  is
                              supported  by  the  linuxspi and flip2 programmer options, as well as all parallel
                              port based programmers.

                     <u>noreset</u>  The ‘/RESET’ line will be deactivated at  program  exit,  thus  allowing  the  MCU
                              target  program  to run while the programming hardware remains connected.  <u>noreset</u>
                              is supported by the linuxspi and flip2 programmer options, as well as all parallel
                              port based programmers.

                     <u>vcc</u>      This option will leave those parallel port pins active (i. e. <u>high</u>)  that  can  be
                              used to supply ‘Vcc’ power to the MCU.

                     <u>novcc</u>    This option will pull the ‘Vcc’ pins of the parallel port down at program exit.

                     <u>d_high</u>   This option will leave the 8 data pins on the parallel port active.  (i. e. <u>high</u>)

                     <u>d_low</u>    This option will leave the 8 data pins on the parallel port inactive.  (i. e. <u>low</u>)

                     Multiple <u>exitspec</u> arguments can be separated with commas.

             <b>-F</b>      Normally,  <b>avrdude</b>  tries  to  verify  that  the  device  signature  read  from the part is
                     reasonable before continuing.  Since it can happen from time to time that a  device  has  a
                     broken  (erased  or overwritten) device signature but is otherwise operating normally, this
                     options is provided to override the check.  Also, for programmers like the Atmel STK500 and
                     STK600 which can adjust parameters local to the programming tool (independent of an  actual
                     connection to a target controller), this option can be used together with <b>-t</b> to continue in
                     terminal  mode.   Moreover,  the option allows to continue despite failed initialization of
                     connection between a programmer and a target.

             <b>-i</b> <u>delay</u>
                     For bitbang-type programmers, delay for approximately <u>delay</u> microseconds between  each  bit
                     state change.  If the host system is very fast, or the target runs off a slow clock (like a
                     32  kHz  crystal,  or  the  128  kHz  internal RC oscillator), this can become necessary to
                     satisfy the requirement that the ISP clock frequency must not be higher than 1/4 of the CPU
                     clock frequency.  This is implemented as a spin-loop delay to allow  even  for  very  short
                     delays.   On  Unix-style operating systems, the spin loop is initially calibrated against a
                     system timer, so the number of microseconds might be rather realistic, assuming a  constant
                     system  load  while <b>avrdude</b> is running.  On Win32 operating systems, a preconfigured number
                     of cycles per microsecond is assumed that might be off a bit for very  fast  or  very  slow
                     machines.

             <b>-l</b> <u>logfile</u>
                     Use  <u>logfile</u>  rather  than  <u>stderr</u>  for  diagnostics  output.  Note that initial diagnostic
                     messages (during option parsing) are still written to <u>stderr</u> anyway.

             <b>-n</b>      No-write - disables actually writing data to the MCU (useful for debugging <b>avrdude</b> ).

             <b>-O</b>      Perform a RC oscillator run-time calibration according to Atmel  application  note  AVR053.
                     This is only supported on the STK500v2, AVRISP mkII, and JTAG ICE mkII hardware.  Note that
                     the result will be stored in the EEPROM cell at address 0.

             <b>-P</b> <u>port</u>
                     Use  <u>port</u>  to  identify  the  device  to  which the programmer is attached.  By default the
                     <u>/dev/ppi0</u> port is used, but if the programmer type normally connects to  the  serial  port,
                     the  <u>/dev/cuaa0</u>  port  is  the  default.  If you need to use a different parallel or serial
                     port, use this option to specify the alternate port name.

                     On Win32 operating systems, the parallel ports  are  referred  to  as  lpt1  through  lpt3,
                     referring to the addresses 0x378, 0x278, and 0x3BC, respectively.  If the parallel port can
                     be  accessed through a different address, this address can be specified directly, using the
                     common C language notation (i. e., hexadecimal values are prefixed by ‘0x’ ).

                     For the JTAG ICE mkII and JTAGICE3, if <b>avrdude</b> has been  configured  with  libusb  support,
                     <u>port</u>  can  alternatively be specified as <u>usb</u>[:<u>serialno</u>].  This will cause <b>avrdude</b> to search
                     the programmer on USB.  If <u>serialno</u> is also specified,  it  will  be  matched  against  the
                     serial  number read from any JTAG ICE mkII found on USB.  The match is done after stripping
                     any existing colons from the given serial number, and  right-to-left,  so  only  the  least
                     significant bytes from the serial number need to be given.

                     As  the  AVRISP  mkII  device  can  only  be  talked  to  over USB, the very same method of
                     specifying the port is required there.

                     For the USB programmer "AVR-Doper" running in HID mode,  the  port  must  be  specified  as
                     <u>avrdoper.</u>  Libhidapi  support  is  required on Unix and Mac OS but not on Windows. For more
                     information about AVR-Doper see <a href="http://www.obdev.at/avrusb/avrdoper.html">http://www.obdev.at/avrusb/avrdoper.html</a>.

                     For the USBtinyISP, which is a simplistic device not implementing serial numbers,  multiple
                     devices  can  be  distinguished by their location in the USB hierarchy.  See the respective
                     <u>Troubleshooting</u> entry in the detailed documentation for examples.

                     For the XBee programmer the target MCU is to be programmed wirelessly over  a  ZigBee  mesh
                     using  the  XBeeBoot  bootloader.   The ZigBee 64-bit address for the target MCU's own XBee
                     device must be supplied as a 16-character hexadecimal value as a <u>port</u> prefix,  followed  by
                     the  ‘@’  character, and the serial device to connect to a second directly contactable XBee
                     device associated with the same mesh (with a default baud rate of  9600).   This  may  look
                     similar to: <u>0013a20000000001@/dev/tty.serial</u>.

                     For  diagnostic  purposes,  if  the  target  MCU  with  an XBeeBoot bootloader is connected
                     directly to the serial port, the 64-bit address field can be omitted.   In  this  mode  the
                     default baud rate will be 19200.

                     For  programmers  that attach to a serial port using some kind of higher level protocol (as
                     opposed to bit-bang style programmers), <u>port</u> can be specified as  <u>net</u>:<u>host</u>:<u>port</u>.   In  this
                     case,  instead  of trying to open a local device, a TCP network connection to (TCP) <u>port</u> on
                     <u>host</u> is established.  Square brackets may be placed around <u>host</u> to improve readability, for
                     numeric IPv6 addresses (e.g.  <b>net:[2001:db8::42]:1337</b>).  The remote endpoint is assumed  to
                     be  a  terminal  or  console server that connects the network stream to a local serial port
                     where the actual programmer has been attached to.  The  port  is  assumed  to  be  properly
                     configured,  for example using a transparent 8-bit data connection without parity at 115200
                     Baud for a STK500.

                     Note: The ability to handle IPv6 hostnames and addresses is limited to  Posix  systems  (by
                     now).

             <b>-q</b>      Disable  (or  quell)  output  of  the  progress bar while reading or writing to the device.
                     Specify it more often for even quieter operations.

             <b>-s,</b> <b>-u</b>  These options used to control the obsolete "safemode" feature which is no  longer  present.
                     They are silently ignored for backwards compatibility.

             <b>-t</b>      Tells  <b>avrdude</b>  to  enter  the  interactive ``terminal'' mode instead of up- or downloading
                     files.  See below for a detailed description of the terminal mode.

             <b>-U</b> <u>memtype:op:filename</u>[:<u>format</u>]
                     Perform a memory operation as indicated.  The <u>memtype</u> field specifies the  memory  type  to
                     operate  on.  The available memory types are device-dependent, the actual configuration can
                     be  viewed  with  the  <b>part</b>  command  in  terminal  mode.   Typically,  a  device's  memory
                     configuration  at  least  contains  the  memory  types  <u>flash</u> and <u>eeprom</u>.  All memory types
                     currently known are:
                     calibration  One or more bytes of RC oscillator calibration data.
                     eeprom       The EEPROM of the device.
                     efuse        The extended fuse byte.
                     flash        The flash ROM of the device.
                     fuse         The fuse byte in devices that have only a single fuse byte.
                     hfuse        The high fuse byte.
                     lfuse        The low fuse byte.
                     lock         The lock byte.
                     signature    The three device signature bytes (device ID).
                     fuse<u>N</u>        The fuse bytes of ATxmega devices, <u>N</u>  is  an  integer  number  for  each  fuse
                                  supported by the device.
                     application  The application flash area of ATxmega devices.
                     apptable     The application table flash area of ATxmega devices.
                     boot         The boot flash area of ATxmega devices.
                     prodsig      The production signature (calibration) area of ATxmega devices.
                     usersig      The user signature area of ATxmega devices.

                     The <u>op</u> field specifies what operation to perform:

                     <u>r</u>        read device memory and write to the specified file

                     <u>w</u>        read data from the specified file and write to the device memory

                     <u>v</u>        read data from both the device and the specified file and perform a verify

                     The  <u>filename</u>  field  indicates the name of the file to read or write.  The <u>format</u> field is
                     optional and contains the format of the file to read or write.  <u>Format</u> can be one of:

                     <u>i</u>    Intel Hex

                     <u>I</u>    Intel Hex with comments on download and tolerance of checksum errors on upload

                     <u>s</u>    Motorola S-record

                     <u>r</u>    raw binary; little-endian byte order, in the case of the flash ROM data

                     <u>e</u>    ELF (Executable and Linkable Format)

                     <u>m</u>    immediate; actual byte values specified on the command line, separated  by  commas  or
                          spaces.   This  is  good for programming fuse bytes without having to create a single-
                          byte file or enter terminal mode.

                     <u>a</u>    auto detect; valid for input only, and only if the input is not provided at <u>stdin</u>.

                     <u>d</u>    decimal; this and the following formats are only valid on output.  They  generate  one
                          line  of  output  for the respective memory section, forming a comma-separated list of
                          the values.  This can be particularly useful for subsequent processing, like for  fuse
                          bit settings.

                     <u>h</u>    hexadecimal; each value will get the string <u>0x</u> prepended.  Only valid on output.

                     <u>o</u>    octal;  each  value  will  get a <u>0</u> prepended unless it is less than 8 in which case it
                          gets no prefix.  Only valid on output.

                     <u>b</u>    binary; each value will get the string <u>0b</u> prepended.  Only valid on output.

                     The default is to use auto detection for input files, and  raw  binary  format  for  output
                     files.   Note  that  if  <u>filename</u>  contains a colon, the <u>format</u> field is no longer optional
                     since the filename part following the colon would otherwise be misinterpreted as <u>format</u>.

                     When reading any kind of flash memory  area  (including  the  various  sub-areas  in  Xmega
                     devices),  the  resulting  output file will be truncated to not contain trailing 0xFF bytes
                     which indicate unprogrammed (erased) memory.  Thus, if the entire memory  is  unprogrammed,
                     this will result in an output file that has no contents at all.

                     As an abbreviation, the form <b>-U</b> <u>filename</u> is equivalent to specifying <b>-U</b> <u>flash:w:filename</u>:a.
                     This will only work if <u>filename</u> does not have a colon in it.

             <b>-v</b>      Enable verbose output.  More <b>-v</b> options increase verbosity level.

             <b>-V</b>      Disable automatic verify check when uploading data.

             <b>-x</b> <u>extended_param</u>
                     Pass  <u>extended_param</u> to the chosen programmer implementation as an extended parameter.  The
                     interpretation of the extended parameter depends on the programmer itself.  See below for a
                     list of programmers accepting extended parameters.

   <b>Terminal</b> <b>mode</b>
       In this mode, <b>avrdude</b> only initializes communication with the MCU,  and  then  awaits  user  commands  on
       standard  input.   Commands and parameters may be abbreviated to the shortest unambiguous form.  Terminal
       mode provides a command history using <u><a href="../man3/readline.3.html">readline</a></u>(3), so previously entered command lines  can  be  recalled
       and edited.  The following commands are currently implemented for all programmers:

             <u>dump</u> <u>memory</u> <u>addr</u> <u>len</u>
                     Read  <u>len</u>  bytes  from the specified memory area, and display them in the usual hexadecimal
                     and ASCII form.

             <u>dump</u> <u>memory</u> <u>addr</u> <u>...</u>
                     Read all bytes from the specified memory starting at address <u>addr,</u> and display them.

             <u>dump</u> <u>memory</u> <u>addr</u>
                     Read 256 bytes from the specified memory area, and display them.

             <u>dump</u> <u>memory</u> <u>...</u>
                     Read all bytes from the specified memory, and display them.

             <u>dump</u> <u>memory</u>
                     Continue dumping the memory contents for another <u>256</u> bytes where the previous <u>dump</u>  command
                     left off.

             <u>read</u>    can be used as an alias for dump

             <u>write</u> <u>memory</u> <u>addr</u> <u>data[,]</u> <u>{data[,]}</u>
                     Manually  program  the  respective  memory  cells, starting at address <u>addr</u>, using the data
                     items provided.  The terminal implements reading from and writing to flash and EEPROM  type
                     memories  normally  through  a  cache  and  paged  access functions. All other memories are
                     directly written to without use of a cache. Some older parts without paged access will also
                     have flash and EEPROM directly accessed without cache.

                     <u>data</u> can be hexadecimal, octal or decimal  integers,  floating  point  numbers  or  C-style
                     strings  and  characters.  For  integers, an optional case-insensitive suffix specifies the
                     data size: HH 8 bit, H/S 16 bit, L 32 bit, LL 64 bit.  Suffix D indicates a 64-bit  double,
                     F  a  32-bit float, whilst a floating point number without suffix defaults to 32-bit float.
                     Hexadecimal floating point notation is  supported.  An  ambiguous  trailing  suffix,  e.g.,
                     0x1.8D,  is  read  as  no-suffix float where D is part of the mantissa; use a zero exponent
                     0x1.8p0D to clarify.

                     An optional U suffix makes integers unsigned. Ordinary 0x hex integers are  always  treated
                     as  unsigned.  +0x  or  -0x  hex numbers are treated as signed unless they have a U suffix.
                     Unsigned integers cannot be larger than 2^64-1.  If n is an unsigned  integer  then  -n  is
                     also  a valid unsigned integer as in C.  Signed integers must fall into the [-2^63, 2^63-1]
                     range or a correspondingly smaller range when a suffix specifies a smaller type.

                     Ordinary 0x hex integers with n hex digits (counting leading zeros) use the  smallest  size
                     of  one,  two,  four  and  eight  bytes that can accommodate any n-digit hex integer. If an
                     integer suffix specifies a size explicitly the corresponding number  of  least  significant
                     bytes  are  written,  and  a  warning  shown  if  the  number does not fit into the desired
                     representation. Otherwise, unsigned integers occupy the smallest of one, two, four or eight
                     bytes needed. Signed numbers are allowed to  fit  into  the  smallest  signed  or  smallest
                     unsigned  representation:  For  example, 255 is stored as one byte as 255U would fit in one
                     byte, though as a signed number it would not fit into a one-byte interval [-128, 127].  The
                     number  -1  is  stored  in  one  byte  whilst  -1U  needs  eight bytes as it is the same as
                     0xFFFFffffFFFFffffU.

                     One trailing comma at the end of <u>data</u> items is ignored to facilitate copy &amp; paste of lists.

             <u>write</u> <u>memory</u> <u>addr</u> <u>len</u> <u>data[,]</u> <u>{data[,]}</u> <u>...</u>
                     The ellipsis ... form writes &lt;len&gt; bytes padded by repeating the last <u>data</u> item.

             <u>flush</u>   Synchronise with the device all pending cached  writes  to  EEPROM  or  flash.   With  some
                     programmer  and  part  combinations,  flash  (and  sometimes  EEPROM, too) looks like a NOR
                     memory, ie, one can only write 0 bits, not 1 bits.  When  this  is  detected,  either  page
                     erase  is  deployed  (e.g.,  with  parts  that have PDI/UPDI interfaces), or if that is not
                     available, both EEPROM and flash caches are fully read in, a chip erase command  is  issued
                     and  both  EEPROM  and  flash are written back to the device. Hence, it can take minutes to
                     ensure that a single previously cleared bit is set and, therefore, this command  should  be
                     used sparingly.

             <u>abort</u>   Normally, caches are only ever actually written to the device when using the <u>flush</u> command,
                     at the end of the terminal session after typing <u>quit</u>, or after EOF on input is encountered.
                     The  abort  command resets the cache discarding all previous writes to the flash and EEPROM
                     cache.

             <u>erase</u>   Perform a chip erase and discard all pending writes to EEPROM and flash.

             <u>sig</u>     Display the device signature bytes.

             <u>part</u>    Display the current part settings  and  parameters.   Includes  chip  specific  information
                     including all memory types supported by the device, read/write timing, etc.

             <u>verbose</u> [<u>level</u>]
                     Change  (when  <u>level</u>  is  provided), or display the verbosity level.  The initial verbosity
                     level is controlled by the number of <b>-v</b> options given on the commandline.

             <u>quell</u> [<u>level</u>]
                     Change (when <u>level</u> is provided), or display the quell level. 1 is used to suppress progress
                     reports.  2 or higher yields in progressively quieter operations.  The initial quell  level
                     is controlled by the number of <b>-q</b> options given on the commandline.

             <u>?</u>

             <u>help</u>    Give a short on-line summary of the available commands.

             <u>quit</u>    Leave terminal mode and thus <b>avrdude</b>.

       The  terminal  commands below may only be implemented on some specific programmers, and may therefore not
       be available in the help menu.

             pgerase memory addr
                     Erase one page of the memory specified.

             <u>send</u> <u>b1</u> <u>b2</u> <u>b3</u> <u>b4</u>
                     Send raw instruction codes to the AVR device.  If you need access to a feature  of  an  AVR
                     part  that  is  not  directly supported by <b>avrdude</b>, this command allows you to use it, even
                     though <b>avrdude</b> does not implement the command. When using direct SPI mode, up  to  3  bytes
                     can be omitted.

             <u>spi</u>     Enter  direct SPI mode.  The <u>pgmled</u> pin acts as chip select.  <u>Supported</u> <u>on</u> <u>parallel</u> <u>bitbang</u>
                     <u>programmers,</u> <u>and</u> <u>partially</u> <u>by</u> <u>USBtiny.</u>

             <u>pgm</u>     Return to programming mode (from direct SPI mode).

             <u>vtarg</u> <u>voltage</u>
                     Set the target's supply voltage to <u>voltage</u> Volts.   <u>Supported</u>  <u>on</u>  <u>the</u>  <u>STK500</u>  <u>and</u>  <u>STK600</u>
                     <u>programmer.</u>

             <u>varef</u> [<u>channel</u>] <u>voltage</u>
                     Set the adjustable voltage source to <u>voltage</u> Volts.  This voltage is normally used to drive
                     the  target's  <u>Aref</u>  input  on the STK500.  On the Atmel STK600, two reference voltages are
                     available, which can be selected  by  the  optional  <u>channel</u>  argument  (either  0  or  1).
                     <u>Supported</u> <u>on</u> <u>the</u> <u>STK500</u> <u>and</u> <u>STK600</u> <u>programmer.</u>

             <u>fosc</u> <u>freq</u>[M|k]
                     Set  the  programming  oscillator  to <u>freq</u> Hz.  An optional trailing letter <u>M</u> multiplies by
                     1E6, a trailing letter <u>k</u> by 1E3.  <u>Supported</u> <u>on</u> <u>the</u> <u>STK500</u> <u>and</u> <u>STK600</u> <u>programmer.</u>

             <u>fosc</u> <u>off</u>
                     Turn the programming oscillator off.  <u>Supported</u> <u>on</u> <u>the</u> <u>STK500</u> <u>and</u> <u>STK600</u> <u>programmer.</u>

             <u>sck</u> <u>period</u>
                     <u>STK500</u> <u>and</u> <u>STK600</u> <u>programmer:</u> Set the SCK clock period to <u>period</u> microseconds.   <u>JTAG</u>  <u>ICE:</u>
                     Set  the  JTAG  ICE  bit  clock  period  to  <u>period</u>  microseconds.  Note that unlike STK500
                     settings, this setting will be reverted to its default value (approximately 1  microsecond)
                     when the programming software signs off from the JTAG ICE.  This parameter can also be used
                     on  the  JTAG  ICE  mkII,  JTAGICE3,  and  Atmel-ICE  to  specify the ISP clock period when
                     operating the ICE in ISP mode.

             <u>parms</u>   <u>STK500</u> <u>and</u> <u>STK600</u> <u>programmer:</u>  Display  the  current  voltage  and  programming  oscillator
                     parameters.   <u>JTAG</u>  <u>ICE:</u>  Display  the  current  target  supply  voltage and JTAG bit clock
                     rate/period.  <u>Other</u> <u>programmers:</u> Display the programmer specific parameters.

   <b>Default</b> <b>Parallel</b> <b>port</b> <b>pin</b> <b>connections</b>
       (these can be changed, see the <b>-c</b> option)
       <b>Pin</b> <b>number</b>   <b>Function</b>
       2-5          Vcc (optional power supply to MCU)
       7            /RESET (to MCU)
       8            SCK (to MCU)
       9            SDO (to MCU)
       10           SDI (from MCU)
       18-25        GND

   <b>debugWire</b> <b>limitations</b>
       The debugWire protocol is Atmel's proprietary one-wire (plus ground)  protocol  to  allow  an  in-circuit
       emulation of the smaller AVR devices, using the ‘/RESET’ line.  DebugWire mode is initiated by activating
       the  ‘DWEN’  fuse,  and  then  power-cycling  the  target.   While  this  mode  is  mainly  intended  for
       debugging/emulation, it also offers limited programming capabilities.  Effectively, the only memory areas
       that can be read or programmed in this mode are flash ROM and EEPROM.  It is also possible  to  read  out
       the  signature.   All  other  memory  areas  cannot be accessed.  There is no <u>chip</u> <u>erase</u> functionality in
       debugWire mode; instead, while reprogramming the flash ROM, each flash ROM page is  erased  right  before
       updating  it.   This  is done transparently by the JTAG ICE mkII (or AVR Dragon).  The only way back from
       debugWire mode is to initiate a special sequence of commands to the JTAG ICE mkII (or AVR Dragon), so the
       debugWire mode will be temporarily disabled, and the target can be accessed using normal ISP programming.
       This sequence is automatically initiated by using the JTAG ICE mkII or AVR Dragon in ISP mode, when  they
       detect that ISP mode cannot be entered.

   <b>FLIP</b> <b>version</b> <b>1</b> <b>idiosyncrasies</b>
       Bootloaders using the FLIP protocol version 1 experience some very specific behaviour.

       These bootloaders have no option to access memory areas other than Flash and EEPROM.

       When  the  bootloader  is started, it enters a <u>security</u> <u>mode</u> where the only acceptable access is to query
       the device configuration parameters (which are used for the signature on AVR devices).  The only  way  to
       leave this mode is a <u>chip</u> <u>erase</u>.  As a chip erase is normally implied by the <b>-U</b> option when reprogramming
       the flash, this peculiarity might not be very obvious immediately.

       Sometimes,  a  bootloader  with  security  mode already disabled seems to no longer respond with sensible
       configuration data, but only 0xFF for all queries.  As these queries are used to obtain the equivalent of
       a signature, <b>avrdude</b> can only continue in that situation by forcing the signature check to be  overridden
       with the <b>-F</b> option.

       A <u>chip</u> <u>erase</u> might leave the EEPROM unerased, at least on some versions of the bootloader.

   <b>Programmers</b> <b>accepting</b> <b>extended</b> <b>parameters</b>
             <u>JTAG</u> <u>ICE</u> <u>mkII</u>

             <u>JTAGICE3</u>

             <u>Atmel-ICE</u>

             <u>Power</u> <u>Debugger</u>

             <u>PICkit</u> <u>4</u>

             <u>MPLAB</u> <u>SNAP</u>

             <u>AVR</u> <u>Dragon</u>
                     When  using the JTAG ICE mkII, JTAGICE3, Atmel-ICE, PICkit 4, MPLAB SNAP, Power Debugger or
                     AVR Dragon in JTAG mode, the following extended parameter is accepted:

                           <u>jtagchain=UB,UA,BB,BA</u>
                                   Setup the JTAG scan chain for <u>UB</u>  units  before,  <u>UA</u>  units  after,  <u>BB</u>  bits
                                   before, and <u>BA</u> bits after the target AVR, respectively.  Each AVR unit within
                                   the  chain  shifts by 4 bits.  Other JTAG units might require a different bit
                                   shift count.

                     The PICkit 4 and the Power Debugger also supports high-voltage UPDI programming.   This  is
                     used  to enable a UPDI pin that has previously been set to RESET or GPIO mode. High-voltage
                     UPDI can be utilized by using an extended parameter:

                           <u>hvupdi</u>  Enable high-voltage UPDI initialization for targets that supports this.

             <u>AVR910</u>

                           <u>devcode=VALUE</u>
                                   Override the device code selection by using <u>VALUE</u> as the  device  code.   The
                                   programmer  is  not  queried  for the list of supported device codes, and the
                                   specified <u>VALUE</u> is not verified but used directly within the ‘T’ command sent
                                   to the programmer.  <u>VALUE</u> can be  specified  using  the  conventional  number
                                   notation of the C programming language.

                           <u>no_blockmode</u>
                                   Disables   the   default   checking   for  block  transfer  capability.   Use
                                   <u>no_blockmode</u> only if your <u>AVR910</u> programmer  creates  errors  during  initial
                                   sequence.

             <u>Arduino</u>

                           <u>attemps[=&lt;1..99&gt;]</u>
                                   Specify  how  many  connection  retry  attemps  to  perform  before  exiting.
                                   Defaults to 10 if not specified.

             <u>Urclock</u>

                           <u>showall</u>
                                   Show all info for the connected part, then exit. The -xshow... options  below
                                   can  be  used  to assemble a bespoke response consisting of a subset (or only
                                   one item) of all available relevant information about the connected part  and
                                   bootloader.

                           <u>showid</u>  Show  a  unique  Urclock ID stored in either flash or EEPROM of the MCU, then
                                   exit.

                           <u>id=&lt;E|F&gt;.&lt;addr&gt;.&lt;len&gt;</u>
                                   Historically, the Urclock ID  was  a  six-byte  unique  little-endian  number
                                   stored  in  Urclock boards at EEPROM address 257. The location of this number
                                   can be set by the -xid=&lt;E|F&gt;.&lt;addr&gt;.&lt;len&gt; extended parameter.  E  stands  for
                                   EEPROM and F stands for flash. A negative address addr counts from the end of
                                   EEPROM  and  flash,  respectively.  The  length  len of the Urclock ID can be
                                   between 1 and 8 bytes.

                           <u>showdate</u>
                                   Show the last-modified date of the input file for the flash application, then
                                   exit. If the input file was stdin, the date will be that of the  programming.
                                   Date and filename are part of the metadata that the urclock programmer stores
                                   by default in high flash just under the bootloader; see also -xnometadata.

                           <u>showfilename</u>
                                   Show  the  input  filename (or title) of the last flash writing session, then
                                   exit.

                           <u>title=&lt;string&gt;</u>
                                   When set, &lt;string&gt; will be used in lieu of the input  filename.  The  maximum
                                   string length for the title/filename field is 254 bytes including terminating
                                   nul.

                           <u>showapp</u>
                                   Show the size of the programmed application, then exit.

                           <u>showstore</u>
                                   Show  the size of the unused flash between the application and metadata, then
                                   exit.

                           <u>showmeta</u>
                                   Show the size of the metadata just below the bootloader, then exit.

                           <u>showboot</u>
                                   Show the size of the bootloader, then exit.

                           <u>showversion</u>
                                   Show bootloader version and capabilities, then exit.

                           <u>showvector</u>
                                   Show the vector number and name of the interrupt table  vector  used  by  the
                                   bootloader  for  starting  the application, then exit. For hardware-supported
                                   bootloaders this will be vector 0 (Reset), and for  vector  bootloaders  this
                                   will  be  any  other  vector number of the interrupt vector table or the slot
                                   just behind the vector table with the name VBL_ADDITIONAL_VECTOR.

                           <u>showpart</u>
                                   Show the part for which the bootloader was compiled, then exit.

                           <u>bootsize=&lt;size&gt;</u>
                                   Manual override for bootloader size. Urboot bootloaders  put  the  number  of
                                   used  bootloader pages into a table at the top of the bootloader section, ie,
                                   typically top of flash, so the urclock programmer can look up the  bootloader
                                   size  itself.  In  backward-compatibility  mode,  when  programming via other
                                   bootloaders, this option can be used to tell the  programmer  the  size,  and
                                   therefore the location, of the bootloader.

                           <u>vectornum=&lt;arg&gt;</u>
                                   Manual  override  for vector number. Urboot bootloaders put the vector number
                                   used by a vector bootloader into a table at the top of flash, so this  option
                                   is  normally  not  needed  for  urboot  bootloaders. However, it is useful in
                                   backward-compatibility mode (or when the urboot  bootloader  does  not  offer
                                   flash  read).  Specifying  a  vector  number in these circumstances implies a
                                   vector bootloader whilst the default assumption would be a hardware-supported
                                   bootloader.

                           <u>eepromrw</u>
                                   Manual override for asserting  EEPROM  read/write  capability.  Not  normally
                                   needed  for urboot bootloaders, but useful for in backward-compatibility mode
                                   if the bootloader offers EEPROM read/write.

                           <u>emulate_ce</u>
                                   If an urboot bootloader does not offer a chip erase command it will tell  the
                                   urclock  programmer  so during handshake. In this case the urclock programmer
                                   emulates a chip erase, if warranted by user command line options, by  filling
                                   the  remainder of unused flash below the bootloader with 0xff. If this option
                                   is specified, the urclock programmer will assume that the  bootloader  cannot
                                   erase  the  chip  itself.  The  option  is  useful  for  backwards-compatible
                                   bootloaders that do not implement chip erase.

                           <u>restore</u>
                                   Upload unchanged flash input files and trim below the bootloader  if  needed.
                                   This is most useful when one has a backup of the full flash and wants to play
                                   that back onto the device. No metadata are written in this case and no vector
                                   patching  happens  either  if it is a vector bootloader.  However, for vector
                                   bootloaders, even under the option  -xrestore  an  input  file  will  not  be
                                   uploaded  for which the reset vector does not point to the vector bootloader.
                                   This is to avoid writing an input file to the device that  would  render  the
                                   vector bootloader not functional as it would not be reached after reset.

                           <u>initstore</u>
                                   On  writing  to  flash fill the store space between the flash application and
                                   the metadata section with 0xff.

                           <u>nofilename</u>
                                   On writing to flash do not  store  the  application  input  filename  (nor  a
                                   title).

                           <u>nodate</u>  On writing to flash do not store the application input filename (nor a title)
                                   and no date either.

                           <u>nometadata</u>
                                   On  writing  to  flash  do  not  store any metadata. The full flash below the
                                   bootloader is available for the application. In  particular,  no  data  store
                                   frame is programmed.

                           <u>delay=&lt;n&gt;</u>
                                   Add  a  &lt;n&gt;  ms  delay  after  reset.  This  can be useful if a board takes a
                                   particularly long time to exit from external reset. &lt;n&gt; can be  negative,  in
                                   which  case  the  default  120 ms delay after issuing reset will be shortened
                                   accordingly.

                           <u>strict</u>  Urclock has a faster, but slightly different  strategy  than  -c  arduino  to
                                   synchronise  with  the bootloader; some stk500v1 bootloaders cannot cope with
                                   this, and they need the -xstrict option.

                           <u>help</u>    Show this help menu and exit

             <u>buspirate</u>

                           <u>reset={cs,aux,aux2}</u>
                                   The default setup assumes the BusPirate's CS  output  pin  connected  to  the
                                   RESET pin on AVR side. It is however possible to have multiple AVRs connected
                                   to the same BP with SDI, SDO and SCK lines common for all of them.  In such a
                                   case  one  AVR  should have its RESET connected to BusPirate's <u>CS</u> pin, second
                                   AVR's RESET connected to BusPirate's <u>AUX</u> pin and if  your  BusPirate  has  an
                                   <u>AUX2</u> pin (only available on BusPirate version v1a with firmware 3.0 or newer)
                                   use that to activate RESET on the third AVR.

                                   It  may be a good idea to decouple the BusPirate and the AVR's SPI buses from
                                   each other using a 3-state bus buffer. For example  74HC125  or  74HC244  are
                                   some  good  candidates  with  the latches driven by the appropriate reset pin
                                   (cs, aux or aux2). Otherwise the  SPI  traffic  in  one  active  circuit  may
                                   interfere with programming the AVR in the other design.

                           <u>spifreq=&lt;0..7&gt;</u>
                                   The SPI speed for the Bus Pirate's binary SPI mode:

                                   0 ..  30 kHz   (default)
                                   1 .. 125 kHz
                                   2 .. 250 kHz
                                   3 ..   1 MHz
                                   4 ..   2 MHz
                                   5 ..   2.6 MHz
                                   6 ..   4 MHz
                                   7 ..   8 MHz

                           <u>rawfreq=&lt;0..3&gt;</u>
                                   Sets the SPI speed and uses the Bus Pirate's binary "raw-wire" mode:

                                   0 ..   5 kHz
                                   1 ..  50 kHz
                                   2 .. 100 kHz   (Firmware v4.2+ only)
                                   3 .. 400 kHz   (v4.2+)

                                   The  only  advantage  of the "raw-wire" mode is the different SPI frequencies
                                   available. Paged writing is not implemented in this mode.

                           <u>ascii</u>   Attempt to use ASCII mode even when the  firmware  supports  BinMode  (binary
                                   mode).   BinMode  is  supported  in firmware 2.7 and newer, older FW's either
                                   don't have BinMode or their BinMode is buggy. ASCII mode is slower and  makes
                                   the above <u>reset=</u>, <u>spifreq=</u> and <u>rawfreq=</u> parameters unavailable. Be aware that
                                   ASCII  mode  is  not  guaranteed to work with newer firmware versions, and is
                                   retained only to maintain compatibility with older firmware versions.

                           <u>nopagedwrite</u>
                                   Firmware versions 5.10 and newer support  a  binary  mode  SPI  command  that
                                   enables whole pages to be written to AVR flash memory at once, resulting in a
                                   significant  write  speed  increase. If use of this mode is not desirable for
                                   some reason, this option disables it.

                           <u>nopagedread</u>
                                   Newer firmware versions support in binary mode SPI command some AVR  Extended
                                   Commands.  Using  the  "Bulk Memory Read from Flash" results in a significant
                                   read speed increase. If use of this mode is not desirable  for  some  reason,
                                   this option disables it.

                           <u>cpufreq=&lt;125..4000&gt;</u>
                                   This  sets the AUX pin to output a frequency of <u>n</u> kHz. Connecting the AUX pin
                                   to the XTAL1 pin of your MCU, you can provide it a clock, for example when it
                                   needs an external clock because of wrong fuses settings.  Make sure  the  CPU
                                   frequency is at least four times the SPI frequency.

                           <u>serial_recv_timeout=&lt;1...&gt;</u>
                                   This sets the serial receive timeout to the given value.  The timeout happens
                                   every  time avrdude waits for the BusPirate prompt.  Especially in ascii mode
                                   this happens very often, so setting a smaller value can speed up  programming
                                   a lot.  The default value is 100ms. Using 10ms might work in most cases.

             <u>Micronucleus</u> <u>bootloader</u>

                           <u>wait[=&lt;timeout&gt;]</u>
                                   If  the  device  is not connected, wait for the device to be plugged in.  The
                                   optional <u>timeout</u> specifies the connection time-out in seconds.  If  no  time-
                                   out  is specified, AVRDUDE will wait indefinitely until the device is plugged
                                   in.

             <u>Teensy</u> <u>bootloader</u>

                           <u>wait[=&lt;timeout&gt;]</u>
                                   If the device is not connected, wait for the device to be  plugged  in.   The
                                   optional  <u>timeout</u>  specifies the connection time-out in seconds.  If no time-
                                   out is specified, AVRDUDE will wait indefinitely until the device is  plugged
                                   in.

             <u>Wiring</u>  When  using  the  Wiring  programmer  type,  the  following  optional extended parameter is
                     accepted:

                           <u>snooze=&lt;0..32767&gt;</u>
                                   After performing the port open phase, AVRDUDE  will  wait/snooze  for  <u>snooze</u>
                                   milliseconds  before  continuing  to the protocol sync phase.  No toggling of
                                   DTR/RTS is performed if <u>snooze</u> is greater than 0.

             <u>PICkit2</u>
                     Connection to the PICkit2 programmer:

                     (AVR)    (PICkit2)
                     RST  -   VPP/MCLR (1)
                     VDD  -   VDD Target (2) -- possibly optional if AVR self powered
                     GND  -   GND (3)
                     SDI  -   PGD (4)
                     SCLK -   PDC (5)
                     SDO  -   AUX (6)

                     Extended commandline parameters:

                           <u>clockrate=&lt;rate&gt;</u>
                                   Sets the SPI clocking rate in Hz (default is 100kHz). Alternately the  -B  or
                                   -i options can be used to set the period.

                           <u>timeout=&lt;usb-transaction-timeout&gt;</u>
                                   Sets  the  timeout  for USB reads and writes in milliseconds (default is 1500
                                   ms).

             <u>USBasp</u>  Extended parameters:

                           <u>section_config</u>
                                   Programmer will erase configuration section  with  option  <b>-e</b>  (chip  erase),
                                   rather   than   entire   chip.    Only  applicable  to  TPI  devices  (ATtiny
                                   4/5/9/10/20/40).

             <u>xbee</u>    Extended parameters:

                           <u>xbeeresetpin=&lt;1..7&gt;</u>
                                   Select the XBee pin DIO&lt;1..7&gt; that is connected to the MCU's  ‘/RESET’  line.
                                   The  programmer  needs  to  know  which  DIO  pin  to  use  to reset into the
                                   bootloader.  The default (3)  is  the  DIO3  pin  (XBee  pin  17),  but  some
                                   commercial products use a different XBee pin.

                                   The  remaining two necessary XBee-to-MCU connections are not selectable - the
                                   XBee DOUT pin (pin 2) must be connected to the MCU's ‘RXD’ line, and the XBee
                                   DIN pin (pin 3) must be connected to the MCU's ‘TXD’ line.

             <u>STK500</u>

                           <u>attemps[=&lt;1..99&gt;]</u>
                                   Specify  how  many  connection  retry  attemps  to  perform  before  exiting.
                                   Defaults to 10 if not specified.

             <u>serialupdi</u>
                     Extended parameters:

                           <u>rtsdtr=low|high</u>
                                   Forces RTS/DTR lines to assume low or high state during the whole programming
                                   session.  Some programmers might use this signal to indicate UPDI programming
                                   state, but this is strictly hardware specific.

                                   When not provided, driver/OS default value will be used.

             <u>linuxspi</u>
                     Extended parameter:

                           <u>disable_no_cs</u>
                                   Ensures the programmer does not use the SPI_NO_CS bit  for  the  SPI  driver.
                                   This  parameter  is  useful for kernels that do not support the CS line being
                                   managed outside the application.

</pre><h4><b>FILES</b></h4><pre>
             <u>/dev/ppi0</u>     Default device to be used for communication with the programming hardware

             <u>avrdude.conf</u>  Programmer and parts configuration file

                           On Windows systems, this file is looked up in the same directory  as  the  executable
                           file.   On all other systems, the file is first looked up in <u>..<a href="file:/etc/">/etc/</a></u>, relative to the
                           path of the executable, then in the same directory  as  the  executable  itself,  and
                           finally in the system default location <u>/etc/avrdude.conf</u>.

             <u>${XDG_CONFIG_HOME}/avrdude/avrdude.rc</u>
                           Local  programmer  and  parts configuration file (per-user overrides); it follows the
                           same syntax as <u>avrdude.conf</u>; if the <u>${XDG_CONFIG_HOME}</u> environment  variable  is  not
                           set or empty, the directory <u>${HOME}/.config/</u> is used instead.

             <u>${HOME}/.avrduderc</u>
                           Alternative location of the per-user configuration file if above file does not exist

             <u><a href="file:~/.inputrc">~/.inputrc</a></u>    Initialization file for the <u><a href="../man3/readline.3.html">readline</a></u>(3) library

             <u>/usr/share/doc/avrdude/avrdude.pdf.gz</u>
                           User manual

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       avrdude: jtagmkII_setparm(): bad response to set parameter command: RSP_FAILED
       avrdude: jtagmkII_getsync(): ISP activation failed, trying debugWire
       avrdude: Target prepared for ISP, signed off.
       avrdude: Please restart avrdude without power-cycling the target.

       If  the  target  AVR  has  been set up for debugWire mode (i. e. the <u>DWEN</u> fuse is programmed), normal ISP
       connection attempts will fail as the <u>/RESET</u> pin is not available.  When using the JTAG ICE  mkII  in  ISP
       mode,  the  message  shown  indicates  that  <b>avrdude</b>  has guessed this condition, and tried to initiate a
       debugWire reset to the target.  When successful, this will leave the target AVR in a state where  it  can
       respond  to  normal ISP communication again (until the next power cycle).  Typically, the same command is
       going to be retried again immediately afterwards, and will then succeed connecting to  the  target  using
       normal ISP communication.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/avr-objcopy.1.html">avr-objcopy</a></u>(1), <u><a href="../man4/ppi.4.html">ppi</a></u>(4), <u>libelf</u>(3,) <u><a href="../man3/readline.3.html">readline</a></u>(3)

       The AVR microcontroller product description can be found at

             <b><a href="http://www.atmel.com/products/AVR/">http://www.atmel.com/products/AVR/</a></b>

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>Avrdude</b> was written by Brian S. Dean &lt;<a href="mailto:bsd@bsdhome.com">bsd@bsdhome.com</a>&gt;.

       This man page by Joerg Wunsch.

</pre><h4><b>BUGS</b></h4><pre>
       Please report bugs via
             <b>https://github.com/avrdudes/avrdude/issues</b>

       The  JTAG  ICE  programmers currently cannot write to the flash ROM one byte at a time.  For that reason,
       updating the flash ROM from terminal mode does not work.

       Page-mode programming the EEPROM through JTAG (i.e. through an <b>-U</b> option) requires a  prior  chip  erase.
       This  is  an  inherent feature of the way JTAG EEPROM programming works.  This also applies to the STK500
       and STK600 in parallel programming mode.

       The USBasp and USBtinyISP drivers do not offer any  option  to  distinguish  multiple  devices  connected
       simultaneously, so effectively only a single device is supported.

       Chip Select must be externally held low for direct SPI when using USBtinyISP, and send must be a multiple
       of four bytes.

       The  avrftdi  driver allows one to select specific devices using any combination of vid,pid serial number
       (usbsn) vendor description (usbvendoror part description (usbproduct) as seen with lsusb or whatever tool
       used to view USB device information. Multiple devices can be on the bus at  the  same  time.  For  the  H
       parts,  which  have  multiple  MPSSE  interfaces,  the  interface  can  also be selected.  It defaults to
       interface 'A'.

Debian                                            July 12, 2022                                       <u><a href="../man1/AVRDUDE.1.html">AVRDUDE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>