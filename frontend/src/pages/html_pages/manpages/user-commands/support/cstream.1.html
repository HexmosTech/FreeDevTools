<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cstream  —  direct data streams, with bandwidth limiting, FIFO, audio, duplication and extended reporting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/cstream">cstream_4.0.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cstream  —  direct data streams, with bandwidth limiting, FIFO, audio, duplication and extended reporting
       support.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>cstream</b> [<b>-b</b> <u>num</u>] [<b>-B</b> <u>num</u>] [<b>-i</b> <u>filename</u>] [<b>-I</b> <u>string</u>] [<b>-l</b>] [<b>-n</b> <u>num</u>] [<b>-o</b> <u>filename</u>] [<b>-O</b> <u>string</u>] [<b>-p</b> <u>filename</u>]
               [<b>-t</b> <u>num</u>] [<b>-T</b> <u>num</u>] [<b>-v</b> <u>num</u>] [<b>-V</b>] [<u>filename</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Cstream</b> filters data streams, much like the UNIX tool <u><a href="../man1/dd.1.html">dd</a></u>(1).   It  has  a  more  traditional  commandline
       syntax,  support  for  precise  bandwidth  limiting  and reporting and support for FIFOs. Data limits and
       throughput rate calculation will work for files &gt; 4 GB.

       <b>Cstream</b> reads from the standard input and writes to the standard output, if no filenames  are  given.  It
       will also 'generate' or 'sink' data if desired.

       Options:

       <b>-b</b> <u>num</u>    Set the block size used for read/write to <u>num</u>.  The default is 8192 bytes.

       <b>-B</b> <u>num</u>    Buffer  input  up  to <u>num</u> bytes before writing. The default is the blocksize. It is an error to
                 set this to anything below the blocksize. Useful when writing tapes and similar that prefer few
                 large writes of many small.

       <b>-c</b> <u>num</u>    Concurrent operation. Use  a  separate  process  for  output.  This  is  especially  useful  in
                 combination with the -B option.
                 0 = use one process only (default)
                 1 = read process will buffer
                 2 = write process will buffer
                 3 = both processes will buffer.
                     In  combination  with  a  large buffer size this will often load your memory heavily, every
                     time the reader transfers the buffer it collected to the writer. If you use -c 3 and have a
                     buffer size of 128 Megabytes 256 MB of memory will be touched at once.

       <b>-i</b> <u>num</u>

       <b>-o</b> <u>num</u>    Set the file names to use for input or output, respectively. If the output file  name  is  "-",
                 data  will just be discarded. If the input file name is "-", data will be generated 'out of the
                 void'. If these options aren't given, stdin/stout will be used. If you need to give  <b>-o</b>  or  <b>-i</b>
                 options and want stdin/stdout, specify the empty string, like this:

                 cstream -i''

                 If  TCP  support has been compiled in (default), hostname:portnumber will try to connect to the
                 specified host at the specified port and :portnumber will  open  a  TCP  socket  on  the  local
                 machine  and  wait  for a connection to arrive. SECURITY NOTE: cstream includes no mechanism to
                 restrict the hosts that may connect to  this  port.  Unless  your  machine  has  other  network
                 filters, anyone will be able to connect.

       <b>-I</b> <u>string</u>

       <b>-O</b> <u>string</u>
                 Specify the type of input and output file, respectively.
                 If string
                     includes 'f', a fifo will be created.
                 If string
                     includes 'F', a <a href="../man2/rsync.2.html">rsync</a>(2) will be issued before closing the output file.
                 If string
                     includes  'a',  the file will be assumed to be a opensound-compatible audio device and will
                     be switched to CD-like settings.
                 If string
                     includes 't', a copy of the stream will be sent to file descriptor 3.
                 If string
                     includes 'N', TCP will not be used for that file even if the name has a ":".

       <b>-l</b>        Include line count in statistics.

       <b>-n</b> <u>num</u>    Limit the total amount of data to <u>num</u>.  If there is more input available, it will be discarded,
                 <b>cstream</b> will exit after the limit has been reached. If there is less input, the limit will  not
                 be reached and no error will be signaled.

                 <u>num</u>  may  have  a trailing 'k', 'm' or 'g' which means Kilobytes, Megabytes or Gigabytes (where
                 Kilo = 1024). This applies to all numeric options.

       <b>-p</b> <u>filename</u>
                 Write the process id of cstream to <u>filename</u>.  If cstream uses a separate writer process (option
                 -c), this is the pid of the parent (reader) process.

       <b>-t</b> <u>num</u>    Limit the throughput of the data stream to <u>num</u> bytes/second. Limiting  is  done  at  the  input
                 side,  you  can  rely  on  cstream not accepting more than this rate. If the number you give is
                 positive, cstream accumulates errors and tries to keep the overall rate at the specified value,
                 for the whole session. If you give a negative number, it is an upper limit for each  read/write
                 system  call  pair.  In  other  words:  the  negative  number will never exceed that limit, the
                 positive number will exceed it to make good for previous underutilization.

       <b>-T</b> <u>num</u>    Report throughput every num seconds.

       <b>-v</b> <u>num</u>    Set verbose level to <u>num</u>.  By default, it is set to 0, which means no messages are displayed as
                 long as no errors occur. A value of 1 means that total amount of data and  throughput  will  be
                 displayed  at the end of program run. A value of 2 means the transfer rate since the end of the
                 first read/write pair will also be reported (useful when there is an initial delay). A value of
                 3 means there will also be separate measurements for read and write. This option  is  resource-
                 consuming  and  currently  isn't implemented. A value of 4 means that notices about each single
                 read/write will be displayed. High values include all message types of lower values.

       <b>-V</b>        Print version number to stdout and exit with 0.

       <u>filename</u>  A single filename as the last argument without an option switch will be used as input  file  if
                 -i has not been used.

       <b>SIGUSR1</b>

       <b>SIGINFO</b>   Sending  SIGUSR1  (or SIGINFO, which is usually mapped to Control-T on you keyboard) to cstream
                 causes it to display throughput rates to  stderr.  The  stream  will  continue  as  if  nothing
                 happened.

       <b>SIGUSR2</b>   Exit and report throughput rates, if requested.

       <b>SIGHUP</b>    I found myself sending SIGHUP accidentally too often. But ignoring or misusing SIGHUP is not an
                 option  for  me. Thus, when <b>cstream</b> received SIGHUP, it will wait 5 seconds for another SIGHUP,
                 to give users a chance to correct a possible mistake. If  no  additional  SIGHUP  is  received,
                 <b>cstream</b> kills itself with SIGHUP.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>cstream</b> <b>-o</b> <b>tmpfile</b> <b>-v</b> <b>1</b> <b>-n</b> <b>384m</b> <b>-i</b> <b>-</b>
               Writes  384  Megabytes  of  unspecified data to file <u>tmpfile</u> and display verbose throughput rate.
               Makes a good benchmark, the speed of <u>/dev/null</u> varies too much from system to system.

       <b>cstream</b> <b>-i</b> <b>tmpfile</b> <b>-v</b> <b>1</b> <b>-n</b> <b>384m</b> <b>-o</b> <b>-</b>
               Read the same file back in and discard data.

       <b>cstream</b> <b>-b</b> <b>2000</b>  <b>-t</b> <b>10000</b> <b>/var/log/messages</b>
               Will display the file in a more or less watchable speed.

       <b>dump</b> <b>0sf</b> <b>400000</b> <b>-</b> <b>/</b> <b>|</b> <b>cstream</b> <b>-v</b> <b>1</b> <b>-b</b> <b>32768</b> <b>-o</b> <b>/dev/rst0</b> <b>-p</b> <b>pidfile</b>

       <b>kill</b> <b>-USR1</b> <b>`cat</b> <b>pidfile`</b>
               Write the output from <a href="../man1/dump.1.html">dump</a>(1) to tape. Each time the signal is sent, the throughput and data rate
               so far will be displayed.

       <b>cstream</b> <b>-t</b> <b>176400</b> <b>-i</b> <b>/dev/dsp0</b> <b>-I</b> <b>f</b> <b>-o</b> <b>-</b>
               Makes kind of a soundcard emulator which may  be  used  to  test  audio  applications  that  need
               something  to write to that limits the data rate as a real soundcard does. This obviously doesn't
               work when the application tries to write data using <a href="../man2/mmap.2.html">mmap</a>(2) and the  application  has  to  ignore
               errors when it tries to set soundcard parameters using <a href="../man2/ioctl.2.html">ioctl</a>(2).

       <b>cstream</b> <b>-t</b> <b>176400</b> <b>-i</b> <b>/dev/dsp0</b> <b>-I</b> <b>f</b> <b>-o</b> <b>/dev/dsp1</b> <b>-O</b> <b>f</b>
               Similar soundcard emulator, except that it allows you to grab the data your applications sends to
               it from the other fifo, while still having precise timing.

       <b>cstream</b> <b>-Oa</b> <b>-o</b> <b>/dev/dsp0</b> <b>myhost.mydomain.com:17324</b>
               Connects  port  3333 on host myhost.mydomain.com and whatever data it finds there will be sent to
               the soundcard, with appropriate settings for CD quality stereo play.

       <b>cstream</b> <b>-i</b> <b>myaudiofile.raw</b> <b>-o</b> <b>:17324</b>
               This will open a TCP server on port 17324 and waits until  someone  connects  (for  example,  the
               commandline  from  the  previous example). Then it will send the contents of myaudiofile.raw down
               the TCP stream (for the previous audio example, typically a CD audio track like you get from  the
               tosha or cdparanoia utilities).

       <b>cstream</b> <b>-OD</b> <b>-o</b> <b>myfile</b>
               Write to file myfile with O_DIRECT.  That usually means that the filesystem buffer cache will not
               try  to  cache this file.  You can use that to prevent copying operations from eating up physical
               memory.  Note that when cstream encounters a write error it will  switch  the  output  file  from
               O_DIRECT  to  a  normal  file  and  write  all  further blocks without O_DIRECT if writes without
               O_DIRECT succeed.  In practice that usually means that your last block, if not a multiple of  the
               filesystem  block  size,  will still be written into the file (the maximum amount of data written
               without O_DIRECT is your blocksize minus one).  That way cstream ensures that the output file has
               the length of the input, however odd the length was and  no  matter  what  restrictions  your  OS
               places  on  O_DIRECT output.  Again, cstream will *not* pad the output to the block size, you get
               the same file and file size as if not using O_DIRECT, at the cost of  switching  to  non-O_DIRECT
               whenever a block is not the right size.

       <b>cstream</b> <b>-i</b> <b>:3333</b> | <b>dd</b> <b>obs=8192</b> | <b>./cstream</b> <b>-omyfile</b> <b>-v7</b> <b>-OD</b>
               This  is  what  you need to do to buffer TCP input, so that the last cstream will not switch away
               from O_DIRECT prematurely because of short reads.  If your input can do short  reads  (e.g.  from
               TCP),  and  you  want  to ensure that O_DIRECT stays in effect, you need a buffer between the TCP
               stream and the O_DIRECT stream.  Since cstream does not yet support different  input  and  output
               block  sizes, dd is suitable here.  Note that this is only necessary if the OS requires multiples
               of the filesystem block size for O_DIRECT.  At the time of this writing this construct is  needed
               on Linux for using TCP streams with O_DIRECT, but it is not needed on FreeBSD.

       <b>cstream</b> <b>-OS</b> <b>-o</b> <b>myfile</b>
               Writes  to  file  myfile with O_SYNC.  This means by the time the system call returns the data is
               known to be on disk.  This is not the same thing as O_DIRECT.  O_DIRECT can do its own buffering,
               with O_SYNC there is no buffering at all.  At the time of this writing, O_SYNC on both Linux  and
               FreeBSD  is very slow (1/5th to 1/10th of normal write) and O_DIRECT is reasonably fast (1/4th to
               1/2 of normal write).  You can combined O_SYNC and O_DIRECT.

</pre><h4><b>ERRORS</b></h4><pre>
       Exit code 0 means success.

       Exit code 1 means a commandline syntax usage error.

       Exit code 2 means other errors, especially system errors.

</pre><h4><b>Bugs</b></h4><pre>
       There should be an option to begin writing directly after the first read ended and then fill  the  buffer
       with  reads  in the background.  Right now writing will not begin before the reader has filled the buffer
       completely for the first time.

       Not a bug: the code to do O_DIRECT is reasonably sophisticated.  It will  fall  back  to  normal  I/O  on
       errors.   But  before  doing that it knows about both filesystem blocksize requirements (will default I/O
       blocksize to whatever the filesystem of the output file is in) and page alignment requirements (I/O  will
       happen  from a page-aligned buffer).  However, the combination of concurrent read/writes (-c options) and
       O_DIRECT has not been tested beyond basic verification that it gets some tests right.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/dd.1.html">dd</a></u>(1), <u><a href="../man2/mkfifo.2.html">mkfifo</a></u>(2)

</pre><h4><b>HISTORY</b></h4><pre>
       <b>cstream</b> was initially written by  Martin  Cracauer  in  1998.   For  updates  and  more  information  see
       <a href="http://www.cons.org/cracauer/cstream.html">http://www.cons.org/cracauer/cstream.html</a>

Debian                                           March, 30, 1999                                      <u><a href="../man1/cstream.1.html">cstream</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>