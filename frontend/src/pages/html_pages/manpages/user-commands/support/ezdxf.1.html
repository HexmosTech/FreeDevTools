<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ezdxf - ezdxf Documentation [image]</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-ezdxf">python3-ezdxf_1.1.3-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ezdxf - ezdxf Documentation [image]

       Welcome! This is the documentation for ezdxf release 1.1.3, last updated Nov 25, 2023.

       • <u>ezdxf</u> is a Python package to create new DXF documents and read/modify/write existing DXF documents

       • MIT-License

       • the intended audience are programmers

       • requires at least Python 3.8

       • OS independent

       • tested with CPython and pypy3

       • has type annotations and passes <b>mypy</b> <b>--ignore-missing-imports</b> <b>-p</b> <b>ezdxf</b> successful

       • additional required packages for the core package without add-ons: <u>typing_extensions</u>, <u>pyparsing</u>, <u>numpy</u>,
         <u>fontTools</u>

       • read/write/new support for DXF versions: R12, R2000, R2004, R2007, R2010, R2013 and R2018

       • additional read-only support for DXF versions R13/R14 (upgraded to R2000)

       • additional read-only support for older DXF versions than R12 (upgraded to R12)

       • read/write support for ASCII DXF and Binary DXF

       • retains third-party DXF content

       • optional  C-extensions  for  CPython  are included in the binary wheels, available on <u>PyPI</u> for Windows,
         Linux and macOS

</pre><h4><b>INCLUDED</b> <b>EXTENSIONS</b></h4><pre>
       Additional packages required for these add-ons are not automatically installed during  the  <u>basic</u>  setup,
       for more information about the setup &amp; dependencies visit the <u>documentation</u>.

       • <u>drawing</u> add-on to visualise and convert DXF files to images which can be saved as PNG, PDF or SVG files

       • <u>r12writer</u> add-on to write basic DXF entities direct and fast into a DXF R12 file or stream

       • <u>iterdxf</u>  add-on to iterate over DXF entities from the modelspace of huge DXF files (&gt; 5GB) which do not
         fit into memory

       • <u>importer</u> add-on to import entities, blocks and table entries from another DXF document

       • <u>dxf2code</u> add-on to generate Python code for DXF structures loaded from DXF documents as starting  point
         for parametric DXF entity creation

       • <u>acadctb</u> add-on to read/write <u>Plot</u> <u>Style</u> <u>Files</u> <u>(CTB/STB)</u>

       • <u>pycsg</u> add-on for Constructive Solid Geometry (CSG) modeling technique

       • <u>MTextExplode</u> add-on for exploding MTEXT entities into single-line TEXT entities

       • <u>text2path</u> add-on to convert text into outline paths

       • <u>geo</u> add-on to support the <b>__</b><u>geo_interface</u><b>__</b>

       • <u>meshex</u> add-on for exchanging meshes with other tools as STL, OFF or OBJ files

       • <u>openscad</u>  add-on, an interface to <u>OpenSCAD</u>

       • <u>odafc</u> add-on, an interface to the <u>ODA</u> <u>File</u> <u>Converter</u> to read and write DWG files

       • <b>hpgl2</b> add-on for converting <u>HPGL/2</u> plot files to DXF, SVG and PDF

</pre><h4><b>WEBSITE</b></h4><pre>
       <u>https://ezdxf.mozman.at/</u>

</pre><h4><b>DOCUMENTATION</b></h4><pre>
       Documentation of development version at <u>https://ezdxf.mozman.at/docs</u>

       Documentation of latest release at <u><a href="http://ezdxf.readthedocs.io/">http://ezdxf.readthedocs.io/</a></u>

</pre><h4><b>KNOWLEDGE</b> <b>GRAPH</b></h4><pre>
       The  <u>Knowledge</u>  <u>Graph</u>  contains additional information beyond the documentation and is managed by <u>logseq</u>.
       The source data is included in the repository in the folder <b>ezdxf/notes</b>.  There is also a <u>HTML</u> <u>export</u>  on
       the website which gets regular updates.

</pre><h4><b>RELEASE</b> <b>NOTES</b></h4><pre>
       The <u>release</u> <u>notes</u> are included in the <u>Knowledge</u> <u>Graph</u>.

</pre><h4><b>CHANGELOG</b></h4><pre>
       The <u>changelog</u> is included in the <u>Knowledge</u> <u>Graph</u>.

</pre><h4><b>SOURCE</b> <b>CODE</b> <b>&amp;</b> <b>FEEDBACK</b></h4><pre>
       Source Code: <u><a href="http://github.com/mozman/ezdxf.git">http://github.com/mozman/ezdxf.git</a></u>

       Issue Tracker: <u><a href="http://github.com/mozman/ezdxf/issues">http://github.com/mozman/ezdxf/issues</a></u>

       Forum: <u>https://github.com/mozman/ezdxf/discussions</u>

</pre><h4><b>QUESTIONS</b> <b>AND</b> <b>ANSWERS</b></h4><pre>
       Please post questions at the <u>forum</u> or <u>stack</u> <u>overflow</u> to make answers available to other users as well.

</pre><h4><b>INTRODUCTION</b></h4><pre>
   <b>What</b> <b>is</b> <b>ezdxf</b>
       <u>Ezdxf</u>   is  a  <u>Python</u> interface to the <u>DXF</u> (drawing interchange file) format developed by <u>Autodesk</u>, <u>ezdxf</u>
       allows developers to read and modify existing DXF documents or create new DXF documents.

       The main objective in the development of <u>ezdxf</u> was to hide complex DXF details from  the  programmer  but
       still  support most capabilities of the <u>DXF</u> format. Nevertheless, a basic understanding of the DXF format
       is required, also to understand which tasks and goals are possible to accomplish by using the DXF format.

       Not all DXF features are supported yet, but additional features will be added in the future gradually.

       <u>Ezdxf</u> is also a replacement for the outdated <u>dxfwrite</u> and <u>dxfgrabber</u> packages but  with  different  APIs,
       for more information see also: <u>What</u> <u>is</u> <u>the</u> <u>Relationship</u> <u>between</u> <u>ezdxf,</u> <u>dxfwrite</u> <u>and</u> <u>dxfgrabber?</u>

   <b>What</b> <b>ezdxf</b> <b>can’t</b> <b>do</b>
       • <u>ezdxf</u>  is not a DXF converter: <u>ezdxf</u> can not convert between different DXF versions, if you are looking
         for an appropriate application, try the free <u>ODAFileConverter</u> from  the  <u>Open</u>  <u>Design</u>  <u>Alliance</u>,  which
         converts between different DXF version and also between the DXF and the DWG file format.

       • <u>ezdxf</u>  is not a CAD file format converter: <u>ezdxf</u> can not convert DXF files to other CAD formats such as
         DWG

       • <u>ezdxf</u> is not a CAD kernel and does not provide high level functionality for construction  work,  it  is
         just  an  interface  to  the DXF file format. If you are looking for a CAD kernel with <u>Python</u> scripting
         support, look at <u>FreeCAD</u>.

   <b>Supported</b> <b>Python</b> <b>Versions</b>
       <u>Ezdxf</u> requires at least Python 3.8 (determined by <u>numpy</u>) and  will  be  tested  with  the  latest  stable
       CPython version and the latest stable release of pypy3 during development.

       <u>Ezdxf</u>  is  written in pure Python with optional Cython implementations of some low level math classes and
       requires <u>pyparsing</u>, <u>numpy</u>, <u>fontTools</u> and  <u>typing_extensions</u>  as  additional  library  beside  the  Python
       Standard  Library.   <u>Pytest</u> is required to run the unit and integration tests. Data to run the stress and
       audit test can not be provided, because I don’t have the rights for publishing these DXF files.

   <b>Supported</b> <b>Operating</b> <b>Systems</b>
       <u>Ezdxf</u> is OS independent and runs on  all  platforms  which  provide  an  appropriate  Python  interpreter
       (&gt;=3.8).

   <b>Supported</b> <b>DXF</b> <b>Versions</b>
                                          ──────────────────────────────────
                                            Version   AutoCAD Release
                                          ──────────────────────────────────
                                            AC1009    AutoCAD R12
                                          ──────────────────────────────────
                                            AC1012    AutoCAD R13 -&gt; R2000
                                          ──────────────────────────────────
                                            AC1014    AutoCAD R14 -&gt; R2000
                                          ──────────────────────────────────
                                            AC1015    AutoCAD R2000
                                          ──────────────────────────────────
                                            AC1018    AutoCAD R2004
                                          ──────────────────────────────────
                                            AC1021    AutoCAD R2007
                                          ──────────────────────────────────
                                            AC1024    AutoCAD R2010
                                          ──────────────────────────────────
                                            AC1027    AutoCAD R2013
                                          ──────────────────────────────────
                                            AC1032    AutoCAD R2018
                                          ┌─────────┬──────────────────────┐
                                          │         │                      │
       <u>Ezdxf</u> also reads older DXF versions│but saves│it as DXF R12.        │
                                          │         │                      │
--
<b>SETUP</b> <b>&amp;</b> <b>DEPENDENCIES</b>                      │         │                      │
--
</pre><h4><b>USAGE</b> <b>FOR</b> <b>BEGINNERS</b></h4><pre>
       This  section shows the intended usage of the <u>ezdxf</u> package.  This is just a brief overview for new <u>ezdxf</u>
       users, follow the provided links for more detailed information.

       First import the package:

          import ezdxf

   <b>Loading</b> <b>DXF</b> <b>Files</b>
       <u>ezdxf</u> supports loading ASCII and binary DXF documents from a file:

          doc = ezdxf.readfile(filename)

       or from a zip-file:

          doc = ezdxf.readzip(zipfilename[, filename])

       Which loads the DXF document <u>filename</u> from the zip-file <u>zipfilename</u> or the first DXF file in the zip-file
       if <u>filename</u> is absent.

       It is also possible to read a DXF document from a stream by the <u>ezdxf.read()</u> function, but this is a more
       advanced feature, because this requires detection of the file encoding in advance.

       This works well with DXF documents from trusted sources  like  AutoCAD  or  BricsCAD.   For  loading  DXF
       documents with minor or major flaws use the <u>ezdxf.recover</u> module.

       <b>SEE</b> <b>ALSO:</b>
          Documentation  for <u>ezdxf.readfile()</u>, <u>ezdxf.readzip()</u> and <u>ezdxf.read()</u>, for more information about file
          management go to the <u>Document</u> <u>Management</u> section. For loading DXF  documents  with  structural  errors
          look at the <u>ezdxf.recover</u> module.

   <b>Layouts</b> <b>and</b> <b>Blocks</b>
       Layouts  are containers for DXF entities like LINE or CIRCLE. The most important layout is the modelspace
       labeled as “Model” in CAD applications which  represents  the  “world”  work  space.  Paperspace  layouts
       represents plottable sheets which contains often the framing and the tile block of a drawing and VIEWPORT
       entities as scaled and clipped “windows” into the modelspace.

       The  modelspace is always present and can not be deleted. The active paperspace is also always present in
       a new DXF document but can be deleted, in that  case  another  paperspace  layout  gets  the  new  active
       paperspace, but you can not delete the last paperspace layout.

       Getting the modelspace of a DXF document:

          msp = doc.modelspace()

       Getting a paperspace layout by the name as shown in the tab of a CAD application:

          psp = doc.paperspace("Layout1")

       A block is just another kind of entity space, which can be inserted multiple times into other layouts and
       blocks  by  the  INSERT  entity  also  called  block references, this is a very powerful and an important
       concept of the DXF format.

       Getting a block layout by the block name:

          blk = doc.blocks.get("NAME")

       All these layouts have factory functions to create graphical DXF entities for  their  entity  space,  for
       more information about creating entities see section: <u>Create</u> <u>new</u> <u>DXF</u> <u>Entities</u>

   <b>Query</b> <b>DXF</b> <b>Entities</b>
       As  said  in  the <u>Layouts</u> <u>and</u> <u>Blocks</u> section, all graphical DXF entities are stored in layouts, all these
       layouts can be iterated and do support the index operator e.g. <b>layout[-1]</b> returns the last entity.

       The main difference between iteration and index access is, that iteration filters destroyed entities, but
       the index operator returns also destroyed entities until these entities  are  purged  by  <b>layout.purge()</b>,
       more about this topic in section: <u>Delete</u> <u>Entities</u>.

       There are two advanced query methods: <u>query()</u> and <u>groupby()</u>.

       Get all lines of layer <b>"MyLayer"</b>:

          lines = msp.query('LINE[layer=="MyLayer"]')

       This returns an <u>EntityQuery</u> container, which also provides the same <b>query()</b> and <b>groupby()</b> methods.

       Get all lines categorized by a DXF attribute like color:

          all_lines_by_color = msp.query("LINE").groupby("color")
          lines_with_color_1 = all_lines_by_color.get(1, [])

       The  <b>groupby()</b>  method  returns  a  regular  Python  <b>dict</b> with colors as key and a regular Python <b>list</b> of
       entities as values (not an <u>EntityQuery</u> container).

       <b>SEE</b> <b>ALSO:</b>
          For more information go to the <u>Tutorial</u> <u>for</u> <u>Getting</u> <u>Data</u> <u>from</u> <u>DXF</u> <u>Files</u>

   <b>Examine</b> <b>DXF</b> <b>Entities</b>
       Each DXF entity has a <b>dxf</b> namespace attribute,  which  stores  the  named  DXF  attributes,  some  entity
       attributes and assets are only available from Python properties or methods outside the <b>dxf</b> namespace like
       the vertices of the LWPOLYLINE entity. More information about the DXF attributes of each entity can found
       in the documentation of the <u>ezdxf.entities</u> module.

       Get some basic DXF attributes:

          layer = entity.dxf.layer  # default is "0"
          color = entity.dxf.color  # default is 256 = BYLAYER

       Most DXF attributes have a default value, which will be returned if the DXF attribute is not present, for
       DXF attributes without a default value you can check if the attribute really exist:

          entity.dxf.hasattr("true_color")

       or use the <b>get()</b> method and provide a default value:

          entity.dxf.get("true_color", 0)

       <b>SEE</b> <b>ALSO:</b>

          • <u>Common</u> <u>graphical</u> <u>DXF</u> <u>attributes</u>

          • Helper class <u>ezdxf.gfxattribs.GfxAttribs</u> for building DXF attribute dictionaries.

   <b>Create</b> <b>a</b> <b>New</b> <b>DXF</b> <b>File</b>
       Create new document for the latest supported DXF version:

          doc = ezdxf.new()

       Create a new DXF document for a specific DXF version, e.g. for DXF R12:

          doc = ezdxf.new("R12")

       The  <u>ezdxf.new()</u>  function  can  create  some  standard  resources, such as linetypes and text styles, by
       setting the argument <u>setup</u> to <b>True</b>:

          doc = ezdxf.new(setup=True)

       <b>SEE</b> <b>ALSO:</b>

          • <u>Tutorial</u> <u>for</u> <u>Creating</u> <u>DXF</u> <u>Drawings</u>

          • Documentation for <u>ezdxf.new()</u>, for more  information  about  file  management  go  to  the  <u>Document</u>
            <u>Management</u> section.

   <b>Create</b> <b>New</b> <b>DXF</b> <b>Entities</b>
       The factory methods for creating new graphical DXF entities are located in the <u>BaseLayout</u> class and these
       factory methods are available for all entity containers:

          • <u>Modelspace</u>

          • <u>Paperspace</u>

          • <u>BlockLayout</u>

       The usage is simple:

          msp = doc.modelspace()
          msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "MyLayer"})

       A few important/required DXF attributes are explicit method arguments, most additional DXF attributes are
       gives  as  a  regular  Python  <b>dict</b>  object  by  the keyword only argument <b>dxfattribs</b>.  The supported DXF
       attributes can be found in the documentation of the <u>ezdxf.entities</u> module.

       <b>WARNING:</b>
          Do not instantiate DXF entities by yourself and add them to layouts, always use the  provided  factory
          methods to create new graphical entities, this is the intended way to use <u>ezdxf</u>.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Thematic</u> <u>Index</u> <u>of</u> <u>Layout</u> <u>Factory</u> <u>Methods</u>

          • <u>Tutorial</u> <u>for</u> <u>Creating</u> <u>DXF</u> <u>Drawings</u>

          • <u>Tutorial</u> <u>for</u> <u>Simple</u> <u>DXF</u> <u>Entities</u>

          • <u>Tutorial</u> <u>for</u> <u>LWPolyline</u>

          • <u>Tutorial</u> <u>for</u> <u>Text</u>

          • <u>Tutorial</u> <u>for</u> <u>MText</u> <u>and</u> <u>MTextEditor</u>

          • <u>Tutorial</u> <u>for</u> <u>Hatch</u>

   <b>Saving</b> <b>DXF</b> <b>Files</b>
       Save the DXF document with a new name:

          doc.saveas("new_name.dxf")

       or with the same name as loaded:

          doc.save()

       <b>SEE</b> <b>ALSO:</b>
          Documentation   for   <u>ezdxf.document.Drawing.save()</u>   and  <u>ezdxf.document.Drawing.saveas()</u>,  for  more
          information about file management go to the <u>Document</u> <u>Management</u> section.

   <b>Create</b> <b>New</b> <b>Blocks</b>
       The block definitions of a DXF document are managed by the <u>BlocksSection</u> object:

          my_block = doc.blocks.new("MyBlock")

       <b>SEE</b> <b>ALSO:</b>
          <u>Tutorial</u> <u>for</u> <u>Blocks</u>

   <b>Create</b> <b>Block</b> <b>References</b>
       A block reference is just another DXF entity called INSERT.  The <u>Insert</u> entity is created by the  factory
       method: <u>add_blockref()</u>:

          msp.add_blockref("MyBlock", (0, 0))

       <b>SEE</b> <b>ALSO:</b>
          See <u>Tutorial</u> <u>for</u> <u>Blocks</u> for more advanced features like using <u>Attrib</u> entities.

   <b>Create</b> <b>New</b> <b>Layers</b>
       A  layer  is  not an entity container, a layer is just another DXF attribute stored in the entity and the
       entity can inherit some properties from this <u>Layer</u> object.  Layer objects are stored in the  layer  table
       which is available as attribute <b>doc.layers</b>.

       You can create your own layers:

          my_layer = doc.layers.add("MyLayer")

       The  layer  object also controls the visibility of entities which references this layer, the on/off state
       of the layer is unfortunately stored as positive or negative color value which make the raw DXF attribute
       of layers useless, to change the color of a layer use the property <b>Layer.color</b>

          my_layer.color = 1

       To change the state of a layer use the provided methods of the <u>Layer</u> object, like <u>on()</u>,  <u>off()</u>,  <u>freeze()</u>
       or <u>thaw()</u>:

          my_layer.off()

       <b>SEE</b> <b>ALSO:</b>
          <u>Layers</u>

   <b>Delete</b> <b>Entities</b>
       The safest way to delete entities is to delete the entity from the layout containing that entity:

          line = msp.add_line((0, 0), (1, 0))
          msp.delete_entity(line)

       This  removes  the  entity  immediately  from  the layout and destroys the entity.  The property <u>is_alive</u>
       returns <b>False</b> for a destroyed entity and all Python attributes are deleted, so <b>line.dxf.color</b> will  raise
       an <b>AttributeError</b> exception, because <b>line</b> does not have a <u>dxf</u> attribute anymore.

       <u>Ezdxf</u> also supports manually destruction of entities by calling the method <b>destroy()</b>:

          line.destroy()

       Manually  destroyed  entities  are  not  removed  immediately from entities containers like <b>Modelspace</b> or
       <b>EntityQuery</b>, but iterating such a container will filter destroyed entities automatically, so a <b>for</b>  <b>e</b>  <b>in</b>
       <b>msp:</b>  <b>...</b>  loop  will  never  yield  destroyed entities. The index operator and the <b>len()</b> function do <b>not</b>
       filter deleted entities, to avoid getting deleted entities call  the  <b>purge()</b>  method  of  the  container
       manually to remove deleted entities.

   <b>Further</b> <b>Information</b>
       • <u>Reference</u>

</pre><h4><b>BASIC</b> <b>CONCEPTS</b></h4><pre>
       The  Basic  Concepts section teach the intended meaning of DXF attributes and structures without teaching
       the application of this information or the specific implementation by <u>ezdxf</u>, if you are looking for  more
       information  about  the  <u>ezdxf</u> internals look at the <u>Reference</u> section or if you want to learn how to use
       <u>ezdxf</u> go to the <u>Tutorials</u> section and for the solution of specific problems go to the <u>Howto</u> section.

   <b>What</b> <b>is</b> <b>DXF?</b>
       The common assumption is also the cite of <u>Wikipedia</u>:
          AutoCAD DXF (Drawing eXchange Format) is a CAD data file format developed  by  Autodesk  for  enabling
          data interoperability between AutoCAD and <b>other</b> applications.

          DXF  was originally introduced in December 1982 as part of AutoCAD 1.0, and was intended to provide an
          exact representation of the data in the AutoCAD native file format,  DWG  (Drawing).  For  many  years
          Autodesk  did  not  publish specifications making correct imports of DXF files difficult. Autodesk now
          publishes the DXF specifications online.

       The more precise cite from the <u>DXF</u> <u>reference</u> itself:
          The DXF™ format is a tagged data representation of  all  the  information  contained  in  an  AutoCAD®
          drawing  file.  Tagged  data means that each data element in the file is preceded by an integer number
          that is called a group code. A group code’s value indicates what type of data  element  follows.  This
          value also indicates the meaning of a data element for a given object (or record) type.  Virtually all
          user-specified information in a drawing file can be represented in DXF format.

       No mention of interoperability between AutoCAD and <b>other</b> applications.

       In  reality  the DXF format was designed to ensure AutoCAD cross-platform compatibility in the early days
       when different hardware platforms with different binary data formats were used.  The  name  DXF  (Drawing
       eXchange  Format)  may  suggest  an  universal  exchange  format,  but  it  is  not.  It  is based on the
       infrastructure installed by Autodesk products (fonts) and the implementation details of  AutoCAD  (MTEXT)
       or on licensed third party technologies (embedded ACIS entities).

       For  more  information  about  the AutoCAD history see the document: <u>The</u> <u>Autodesk</u> <u>File</u> - Bits of History,
       Words of Experience by <u>John</u> <u>Walker</u>, founder of <u>Autodesk,</u> <u>Inc.</u> and co-author of <u>AutoCAD</u>.

   <b>DXF</b> <b>Reference</b> <b>Quality</b>
       The <u>DXF</u> <u>reference</u> is by far no specification nor a standard like the W3C standard  for  <u>SVG</u>  or  the  ISO
       standard for <u>PDF</u>.

       The  reference  describes many but not all DXF entities and some basic concepts like the tag structure or
       the arbitrary axis algorithm.  But the  existing  documentation  (reference)  is  incomplete  and  partly
       misleading  or  wrong.  Also  missing  from  the  reference  are  some  important  parts like the complex
       relationship between the entities to create higher  order  structures  like  block  definitions,  layouts
       (model space &amp; paper space) or dynamic blocks to name a few.

   <b>Reliable</b> <b>CAD</b> <b>Applications</b>
       Because of the suboptimal quality of the DXF reference not all DXF viewers, creators or processors are of
       equal  quality.  I  consider a CAD application as a <u>reliable</u> <u>CAD</u> <u>application</u> when the application creates
       valid DXF documents in the meaning and interpretation of <u>Autodesk</u> and a  reliable  DXF  viewer  when  the
       result matches in most parts the result of the free <u>Trueview</u> viewer provided by <u>Autodesk</u>.

       These are some applications which do fit the criteria of a reliable CAD application:

       • <u>AutoCAD</u> and <u>Trueview</u>

       • CAD applications based on the <u>OpenDesignAlliance</u> (ODA) SDK, see also <u>ODA</u> <u>on</u> <u>wikipedia</u>, even <u>Autodesk</u> is
         a  corporate member, see their blog post from <u>22</u> <u>Sep</u> <u>2020</u> at <u>adsknews</u> but only to use the ODA IFC tools
         and not to improve the DWG/DXF compatibility

       • <u>BricsCAD</u> (ODA based)

       • <u>GstarCAD</u> (ODA based)

       • <u>ZWCAD</u> (ODA based)

       Unfortunately, I cannot recommend any open source  applications  because  everyone  I  know  has  serious
       shortcomings,  at least as a DXF viewer, and I don’t trust them as a DXF creator either. To be clear, not
       even <u>ezdxf</u> (which is not a CAD application) is a <u>reliable</u> library in this sense - it just  keeps  getting
       better, but is far from <u>reliable</u>.

       <b>HINT:</b>
          Please  do  not  submit bug reports based on the use of <u>LibreCAD</u> or <u>QCAD</u>, these applications are in no
          way reliable regarding the DXF format and I will not waste my time on them.

   <b>DXF</b> <b>Entities</b> <b>and</b> <b>Objects</b>
       DXF entities are objects that make up the design data stored in a DXF file.

   <b>Graphical</b> <b>Entities</b>
       Graphical entities are visible  objects  stored  in  blocks,  modelspace-  or  paperspace  layouts.  They
       represent the various shapes, lines, and other elements that make up a 2D or 3D design.

       Some common types of DXF entities include:

       • LINE  and  POLYLINE:  These  are  the  basic building blocks of a DXF file. They represent straight and
         curved lines.

       • CIRCLE and ARC: These entities represent circles and portions of circles, respectively.

       • TEXT and MTEXT: DXF files can also contain text entities, which can be  used  to  label  parts  of  the
         design or provide other information.

       • HATCH:  DXF  files  can  also  include  hatch patterns, which are used to fill in areas with a specific
         pattern or texture.

       • DIMENSION: DXF files can also contain dimension entities, which provide  precise  measurements  of  the
         various elements in a design.

       • INSERT:  A block is a group of entities that can be inserted into a design multiple times by the INSERT
         entity, making it a useful way to reuse elements of a design.

       These entities are defined using specific codes and values in the  DXF  file  format,  and  they  can  be
       created and manipulated by <u>ezdxf</u>.

   <b>Objects</b>
       DXF objects are non-graphical entities and have no visual representation, they store administrative data,
       paperspace  layout definitions, style definitions for multiple entity types, custom data and objects. The
       OBJECTS section in DXF files serves as a container for these non-graphical objects.

       Some common DXF types of DXF objects include:

       • DICTIONARY: A dictionary object consists of a series of name-value pairs, where the name  is  a  string
         that  identifies  a specific object within the dictionary, and the value is a reference to that object.
         The objects themselves can be any type of DXF entity or custom object defined in the DXF file.

       • XRECORD entities are used to store custom application data in a DXF file.

       • the LAYOUT entity is a DXF entity that represents a single paper space layout  in  a  DXF  file.  Paper
         space  is the area in a CAD drawing that represents the sheet of paper or other physical media on which
         the design will be plotted or printed.

       • MATERIAL, MLINESTYLE, MLEADERSTYLE definitions stored in certain DICTIONARY objects.

       • A GROUP entity contains a list of handles that refer to other DXF entities in the drawing. The entities
         in the group can be of any type, including entities from the model space or paper space layouts.

   <b>TagStorage</b>
       The <u>ezdxf</u> package supports many but not all entity types, all  these  unsupported  types  are  stored  as
       <b>TagStorage</b> instances to preserve their data when exporting the edited DXF content by <u>ezdxf</u>.

   <b>Access</b> <b>Entity</b> <b>Attributes</b>
       All DXF attributes are stored in the entity namespace attribute <b>dxf</b>.

          print(entity.dxf.layer)

       Some  attributes  are mandatory others are optional in most cases a reasonable values will be returned as
       default value if the attribute is missing.

       <b>SEE</b> <b>ALSO:</b>
          <u>Tutorial</u> <u>for</u> <u>Getting</u> <u>Data</u> <u>from</u> <u>DXF</u> <u>Files</u>

   <b>Where</b> <b>to</b> <b>Look</b> <b>for</b> <b>Entities</b>
       The DXF document has an entity database where all entities which have a handle  are  stored  in  a  (key,
       value) storage. The <b>query()</b> method is often the easiest way to request data:

          for text in doc.entitydb.query("TEXT"):
              print(text.dxf.text)

       <b>SEE</b> <b>ALSO:</b>

          • <u>ezdxf.query</u> module

          • <u>ezdxf.entitydb</u> module

       Graphical entities are stored in blocks, the modelspace or paperspace layouts.

       • The <b>doc.modelspace()</b> function returns the <u>Modelspace</u> instance

       • The <b>doc.paperspace()</b> returns a <u>Paperspace</u> instance

       • The <b>doc.blocks</b> attribute provides access to the <u>BlocksSection</u>

       The  <u>query()</u> method of the <u>Drawing</u> class which represents the DXF document, runs the query on all layouts
       and block definitions.

       Non-graphical entities are stored in the OBJECTS section:

       • The <b>doc.objects</b> attribute provides access to the <u>ObjectsSection</u>.

       Resource definitions like <u>Layer</u>, <u>Linetype</u> or <u>Textstyle</u> are stored in resource tables:

       • <b>doc.layers</b>: the <u>LayerTable</u>

       • <b>doc.linetypes</b>: the <u>LinetypeTable</u>

       • <b>doc.styles</b>: the <u>TextstyleTable</u>

       • <b>doc.dimstyles</b>: the <u>DimStyleTable</u>

       <b>IMPORTANT:</b>
          A layer assignment is just an attribute of a DXF entity, it’s not an entity container!

       <b>SEE</b> <b>ALSO:</b>

          • Basic concept of the <u>Modelspace</u>

          • Basic concept of <u>Paperspace</u> layouts

          • Basic concept of <u>Blocks</u>

          • <u>Tutorial</u> <u>for</u> <u>Getting</u> <u>Data</u> <u>from</u> <u>DXF</u> <u>Files</u>

   <b>How</b> <b>to</b> <b>Create</b> <b>Entities</b>
       The recommended way to create new DXF entities is to use the factory methods of  layouts  and  blocks  to
       create entities and add them to the entity space automatically.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Thematic</u> <u>Index</u> <u>of</u> <u>Layout</u> <u>Factory</u> <u>Methods</u>

          • Reference of the <u>BaseLayout</u> class

          • <u>Tutorial</u> <u>for</u> <u>Simple</u> <u>DXF</u> <u>Entities</u>

   <b>AutoCAD</b> <b>Color</b> <b>Index</b> <b>(ACI)</b>
       The  <u>color</u>  attribute  represents  an  <u>ACI</u> (AutoCAD Color Index).  AutoCAD and many other <u>CAD</u> application
       provides a default color table, but pen table would be the more correct term.  Each ACI entry defines the
       color value, the line weight and some other attributes to use for the pen. This pen table can  be  edited
       by  the  user  or  loaded  from an <u>CTB</u> or <u>STB</u> file.  <u>Ezdxf</u> provides functions to create (<b>new()</b>) or modify
       (<b>ezdxf.acadctb.load()</b>) plot styles files.

       DXF R12 and prior do not preserve the layout of a drawing very well, because of the lack  of  a  standard
       color  table  and  missing  DXF  structures  to define these color tables in the DXF file.  If a CAD user
       redefines an ACI color entry in a CAD application and does not provide this <u>CTB</u> or <u>STB</u> file, you can  not
       know  what  color  or  lineweight  was  used  intentionally.   This  got  better in later DXF versions by
       supporting additional DXF attributes like <u>lineweight</u> and <u>true_color</u> which can define these attributes  by
       distinct values.  [image]

       <b>SEE</b> <b>ALSO:</b>

          • <u>Plot</u> <u>Style</u> <u>Files</u> <u>(CTB/STB)</u>

          • <u>ezdxf.colors</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • Autodesk Knowledge Network: <u>About</u> <u>Setting</u> <u>the</u> <u>Color</u> <u>of</u> <u>Objects</u>

          • BricsCAD Help Center: <u>Entity</u> <u>Color</u>

   <b>True</b> <b>Color</b>
       The  support for true color was added to the DXF file format in revision R2004.  The true color value has
       three components red, green and blue in the range from 0 to 255 and is stored as a 24-bit  value  in  the
       DXF  namespace  as <b>true_color</b> attribute and looks like this <b>0xRRGGBB</b> as hex value.  For a more easy usage
       all graphical entities support the <u>rgb</u> property to get and set the true color as (r, g, b)  tuples  where
       the components must be in the range from 0 to 255.

          import ezdxf

          doc = ezdxf.new()
          msp = doc.modelspace()
          line = msp.add_line((0, 0), (10, 0))
          line.rgb = (255, 128, 32)

       The  true  color  value has higher precedence than the <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> value, if the attributes
       <b>color</b> and the <b>true_color</b> are present the entity will be rendered with the true color value.

       The true color value has the advantage that  it  defines  the  color  absolutely  and  unambiguously,  no
       unexpected  overwriting  is  possible.   The representation of the color is fixed and only depends on the
       calibration of the output medium: [image]

       <b>SEE</b> <b>ALSO:</b>

          • <u>ezdxf.colors</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • Autodesk Knowledge Network: <u>About</u> <u>Setting</u> <u>the</u> <u>Color</u> <u>of</u> <u>Objects</u>

          • BricsCAD Help Center: <u>Entity</u> <u>Color</u>

   <b>Transparency</b>
       The support for transparency was added to the DXF file format in revision R2004.   The  raw  transparency
       value  stored  as  32 bit value in the DXF namespace as <b>transparency</b> attribute, has a range from 0 to 255
       where 0 is fully transparent and 255 if opaque and has the top byte set to <b>0x02</b>.  For a more  easy  usage
       all  graphical  entities support the <u>transparency</u> property to get and set the transparency as float value
       in the range frem 0.0 to 1.0 where 0.0 is opaque and 1.0 is fully transparent. The transparency value can
       be set explicit in the entity, by layer or by block.

          import ezdxf

          doc = ezdxf.new()
          msp = doc.modelspace()
          line = msp.add_line((0, 0), (10, 0))
          line.transparency = 0.5

       <b>SEE</b> <b>ALSO:</b>

          • <u>ezdxf.colors</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • Autodesk Knowledge Network: <u>About</u> <u>Making</u> <u>Objects</u> <u>Transparent</u>

          • BricsCAD Help Center: <u>Entity</u> <u>Transparency</u>

   <b>Layers</b>
       Every object has a layer as one of its properties. You may be familiar with layers - independent  drawing
       spaces that stack on top of each other to create an overall image - from using drawing programs. Most CAD
       programs  use  layers  as  the  primary  organizing principle for all the objects that you draw.  You use
       layers to organize objects into logical groups of  things  that  belong  together;  for  example,  walls,
       furniture, and text notes usually belong on three separate layers, for a couple of reasons:

       • Layers give you a way to turn groups of objects on and off - both on the screen and on the plot.

       • Layers provide the most efficient way of controlling object color and linetype

       Create  a  layer table entry <u>Layer</u> by <b>Drawing.layers.add()</b>, assign the layer properties such as color and
       linetype. Then assign those layers to other DXF entities by setting the DXF attribute <u>layer</u> to the  layer
       name as string.

       The  DXF  format  do not require a layer table entry for a layer. A layer without a layer table entry has
       the default linetype <b>'Continuous'</b>, a default color of <b>7</b> and a  lineweight  of  <b>-3</b>  which  represents  the
       default lineweight of 0.25mm in most circumstances.

   <b>Layer</b> <b>Properties</b>
       The  advantage  of  assigning properties to a layer is that entities can inherit this properties from the
       layer by using the string <b>'BYLAYER'</b> as linetype string, <b>256</b> as color  or  <b>-1</b>  as  lineweight,  all  these
       values  are  the  default  values  for  new entities. DXF version R2004 and later also support inheriting
       <u>true_color</u> and <u>transparency</u> attributes from a layer.

   <b>Layer</b> <b>Status</b>
       The layer status is important for the visibility and the ability to select and edit DXF entities on  that
       layer in CAD applications.  <u>Ezdxf</u> does not care about the visual representation and works at the level of
       entity  spaces and the entity database and therefore all the layer states documented below are ignored by
       <u>ezdxf</u>.  This means if you iterate an entity space like the modelspace or the entity database you will get
       all entities from that entity space regardless the layer status.

       • ON: the layer is visible, entities on that layer are visible, selectable and editable

       • OFF: the layer is not visible, entities on that layer are not visible, not selectable and not editable

       • FROZEN: the layer is not visible, entities on that layer  are  not  visible,  not  selectable  and  not
         editable,  very  similar  to  the  OFF  status  but  layers can be frozen individually in VIEWPORTS and
         freezing layers may speed up some commands in CAD applications like ZOOM, PAN or REGEN.

       • LOCKED: the layer is visible, entities on that layer are visible but not selectable and not editable

   <b>Deleting</b> <b>Layers</b>
       Deleting a layer is not as simple as it might seem, especially if you are used to use a  CAD  application
       like  AutoCAD.  There  is no directory of locations where layers can be used and references to layers can
       occur even in third-party data.  Deleting the layer table entry removes only the  default  attributes  of
       that  layer and does not delete any layer references automatically. And because a layer can exist without
       a layer table entry, the layer exist as long as at least one layer reference to the layer exist.

   <b>Renaming</b> <b>Layers</b>
       Renaming a layer is also problematic because the DXF format stores the layer references in most cases  as
       text  strings,  so  renaming  the layer table entry just creates a new layer and all entities which still
       have a reference to the old layer now inherit their attributes from an undefined layer table  entry  with
       default settings.

   <b>Viewport</b> <b>Overrides</b>
       Most  of  the  layer properties can be overriden for each <u>Viewport</u> entity individually and this overrides
       are stored in layer table entry referenced by the handle of the VIEWPORT entity.  In contrast the  frozen
       status of layers is store in the VIEWPORT entity.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Tutorial</u> <u>for</u> <u>Layers</u>

          • <u>Tutorial</u> <u>for</u> <u>Viewports</u> <u>in</u> <u>Paperspace</u>

          • Autodesk Knowledge Network: <u>About</u> <u>Layers</u>

          • BricsCAD Help Center: <u>Working</u> <u>with</u> <u>Layers</u>

   <b>Linetypes</b>
       The <u>linetype</u> defines the rendering pattern of linear graphical entities like LINE, ARC, CIRCLE and so on.
       The  linetype  of an entity can be specified by the DXF attribute <b>linetype</b>, this can be an explicit named
       linetype or the entity can inherit its linetype from the assigned layer by setting <b>linetype</b> to <b>'BYLAYER'</b>,
       which is also the default value. <b>CONTINUOUS</b> is the  default  linetype  for  layers  with  an  unspecified
       linetype.

       <u>Ezdxf</u>  creates  several standard linetypes, if the argument <u>setup</u> is <b>True</b> when calling <u>new()</u>, this simple
       linetypes are supported by all DXF versions:

          doc = ezdxf.new('R2007', setup=True)
       [image]

       In DXF R13 Autodesk introduced complex linetypes which can contain text or shapes.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • <u>Tutorial</u> <u>for</u> <u>Creating</u> <u>Linetype</u> <u>Pattern</u>

          • Autodesk Knowledge Network: <u>About</u> <u>Linetypes</u>

          • BricsCAD Help Center: <u>Entity</u> <u>Linetype</u>

   <b>Linetype</b> <b>Scaling</b>
       Global linetype scaling can be changed by setting the header variable <b>doc.header['$LTSCALE']</b> <b>=</b>  <b>2</b>,  which
       stretches the line pattern by factor 2.

       The  linetype  scaling  for  a  single entity can be set by the DXF attribute <u>ltscale</u>, which is supported
       since DXF R2000.

   <b>Lineweights</b>
       The <u>lineweight</u> attribute represents the lineweight as integer value in millimeters * 100, e.g.  0.25mm  =
       25,  independently  from the unit system used in the DXF document.  The <b>lineweight</b> attribute is supported
       by DXF R2000 and newer.

       Only certain values are valid, they are stored in <b>ezdxf.lldxf.const.VALID_DXF_LINEWEIGHTS</b>: 0, 5,  9,  13,
       15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.

       Values &lt; 0 have a special meaning and can be imported as constants from <u>ezdxf.lldxf.const</u>
                                             ┌────┬────────────────────┐
                                             │ -1 │ LINEWEIGHT_BYLAYER │
                                             ├────┼────────────────────┤
                                             │ -2 │ LINEWEIGHT_BYBLOCK │
                                             ├────┼────────────────────┤
                                             │ -3 │ LINEWEIGHT_DEFAULT │
                                             └────┴────────────────────┘

       The  validator  function:  <b>ezdxf.lldxf.validator.is_valid_lineweight()</b>  returns <b>True</b> for valid lineweight
       values otherwise <b>False</b>.

       Sample script which shows all valid lineweights: <u>valid_lineweights.dxf</u>

       You have to enable the option to show lineweights in your CAD application or viewer to see the effect  on
       screen,  which  is  disabled  by  default, the same has to be done in the page setup options for plotting
       lineweights.

       Setting the HEADER variable <b>$LWDISPLAY</b> to 1, activates support for displaying lineweights on screen:

          # activate on screen lineweight display
          doc.header["$LWDISPLAY"] = 1
       [image]

       The lineweight value can be overridden by <u>CTB</u> or <u>STB</u> files.

       <b>SEE</b> <b>ALSO:</b>

          • Autodesk Knowledge Network: <u>About</u> <u>Lineweights</u>

          • BricsCAD Help Center: <u>Entity</u> <u>Lineweight</u>

   <b>Coordinate</b> <b>Systems</b>
       <u>AutoLISP</u> <u>Reference</u> <u>to</u> <u>Coordinate</u> <u>Systems</u> provided by Autodesk.

       To brush up you knowledge about vectors, watch the YouTube tutorials of <u>3Blue1Brown</u> about <u>Linear</u> <u>Algebra</u>.

   <b>WCS</b>
       World coordinate system - the reference coordinate system.  All  other  coordinate  systems  are  defined
       relative  to  the WCS, which never changes. Values measured relative to the WCS are stable across changes
       to other coordinate systems.

   <b>UCS</b>
       User coordinate system - the working coordinate system defined by the user to make drawing tasks  easier.
       All  points  passed  to  AutoCAD  commands,  including those returned from AutoLISP routines and external
       functions, are points in the current UCS. As far as I know, all  coordinates  stored  in  DXF  files  are
       always WCS or OCS never UCS.

       User  defined  coordinate  systems  are  not just helpful for interactive CAD, therefore <u>ezdxf</u> provides a
       converter class <u>UCS</u> to translate coordinates from UCS into WCS and vice versa, but always remember: store
       only WCS or OCS coordinates in DXF files, because there is no method to determine which UCS was active or
       used to create UCS coordinates.

       <b>SEE</b> <b>ALSO:</b>

          • Table entry <b>UCS</b>

          • <u>ezdxf.math.UCS</u> - converter between WCS and UCS

   <b>OCS</b>
       Object coordinate system  are coordinates relative to the object itself.  The main  goal  of  OCS  is  to
       place  2D elements in 3D space and the OCS is defined by the extrusion vector of the entity.  As long the
       extrusion vector is (0, 0, 1) (the WCS z-axis) the OCS is coincident to the  WCS,  which  means  the  OCS
       coordinates are equal to the WCS coordinates, most of the time this is true for 2D entities.

       OCS entities: ARC, CIRCLE, TEXT, LWPOLYLINE, HATCH, SOLID, TRACE, INSERT, IMAGE

       Because  <u>ezdxf</u>  is  just an interface to DXF, it does not automatically convert OCS into WCS, this is the
       domain of the user/application. These lines convert the center of a 3D circle from OCS to WCS:

          ocs = circle.ocs()
          wcs_center = ocs.to_wcs(circle.dxf.center)

       <b>SEE</b> <b>ALSO:</b>

          • <u>Object</u> <u>Coordinate</u> <u>System</u> <u>(OCS)</u> - deeper insights into OCS

          • <u>ezdxf.math.OCS</u> - converter between WCS and OCS

   <b>DCS</b>
       Display coordinate system - the coordinate system into which objects  are  transformed  before  they  are
       displayed.  The  origin  of  the  DCS  is the point stored in the AutoCAD system variable TARGET, and its
       z-axis is the viewing direction. In other words, a viewport is always a  plan  view  of  its  DCS.  These
       coordinates  can  be  used to determine where something will be displayed to the AutoCAD user. <u>Ezdxf</u> does
       not use or support DCS in any way.

   <b>Object</b> <b>Coordinate</b> <b>System</b> <b>(OCS)</b>
       • <u>DXF</u> <u>Reference</u> <u>for</u> <u>OCS</u> provided by Autodesk.

       The points associated with each entity are expressed in terms  of  the  entity’s  own  object  coordinate
       system (OCS). The OCS was referred to as ECS in previous releases of AutoCAD.

       With  OCS, the only additional information needed to describe the entity’s position in 3D space is the 3D
       vector describing the z-axis of the OCS (often referenced as extrusion vector), and the elevation  value,
       which is the distance of the entity xy-plane to the WCS/OCS origin.

       For  a given z-axis (extrusion) direction, there are an infinite number of coordinate systems, defined by
       translating the origin in 3D space and by rotating the x- and y-axis around the z-axis. However, for  the
       same z-axis direction, there is only one OCS. It has the following properties:

       • Its origin coincides with the WCS origin.

       • The  orientation of the x- and y-axis within the xy-plane are calculated in an arbitrary but consistent
         manner. AutoCAD performs this calculation using the arbitrary axis algorithm (see below).

       • Because of the <u>Arbitrary</u> <u>Axis</u> <u>Algorithm</u> the OCS can only represent a <b>right-handed</b> coordinate system!

       The following entities do not lie in a particular plane. All points are expressed in  world  coordinates.
       Of  these  entities, only lines and points can be extruded. Their extrusion direction can differ from the
       world z-axis.

       • <u>Line</u>

       • <u>Point</u>

       • <b>3DFace</b>

       • <u>Polyline</u> (3D)

       • <u>Vertex</u> (3D)

       • <u>Polymesh</u>

       • <u>Polyface</u>

       • <u>Viewport</u>

       These entities are planar in nature. All points  are  expressed  in  object  coordinates.  All  of  these
       entities can be extruded. Their extrusion direction can differ from the world z-axis.

       • <u>Circle</u>

       • <u>Arc</u>

       • <u>Solid</u>

       • <u>Trace</u>

       • <u>Text</u>

       • <u>Attrib</u>

       • <b>Attdef</b>

       • <u>Shape</u>

       • <u>Insert</u>

       • <u>Polyline</u> (2D)

       • <u>Vertex</u> (2D)

       • <u>LWPolyline</u>

       • <u>Hatch</u>

       • <u>Image</u>

       Some of a <u>Dimension</u>’s points are expressed in WCS and some in OCS.

   <b>Elevation</b>
       Elevation group code 38:

       Exists  only  in output from versions prior to R11. Otherwise, Z coordinates are supplied as part of each
       of the entity’s defining points.

   <b>Arbitrary</b> <b>Axis</b> <b>Algorithm</b>
       • <u>DXF</u> <u>Reference</u> <u>for</u> <u>Arbitrary</u> <u>Axis</u> <u>Algorithm</u> provided by Autodesk.

       The arbitrary axis algorithm is used by AutoCAD internally to  implement  the  arbitrary  but  consistent
       generation of object coordinate systems for all entities that use object coordinates.

       Given  a unit-length vector to be used as the z-axis of a coordinate system, the arbitrary axis algorithm
       generates a corresponding x-axis for the coordinate system. The y-axis  follows  by  application  of  the
       <b>right-hand</b> rule.

       We are looking for the arbitrary x- and y-axis to go with the normal Az (the arbitrary z-axis). They will
       be called Ax and Ay (using <u>Vec3</u>):

          Az = Vec3(entity.dxf.extrusion).normalize()  # normal (extrusion) vector
          if (abs(Az.x) &lt; 1/64.) and (abs(Az.y) &lt; 1/64.):
               Ax = Vec3(0, 1, 0).cross(Az).normalize()  # the cross-product operator
          else:
               Ax = Vec3(0, 0, 1).cross(Az).normalize()  # the cross-product operator
          Ay = Az.cross(Ax).normalize()

   <b>WCS</b> <b>to</b> <b>OCS</b>
          def wcs_to_ocs(point):
              px, py, pz = Vec3(point)  # point in WCS
              x = px * Ax.x + py * Ax.y + pz * Ax.z
              y = px * Ay.x + py * Ay.y + pz * Ay.z
              z = px * Az.x + py * Az.y + pz * Az.z
              return Vec3(x, y, z)

   <b>OCS</b> <b>to</b> <b>WCS</b>
          Wx = wcs_to_ocs((1, 0, 0))
          Wy = wcs_to_ocs((0, 1, 0))
          Wz = wcs_to_ocs((0, 0, 1))

          def ocs_to_wcs(point):
              px, py, pz = Vec3(point)  # point in OCS
              x = px * Wx.x + py * Wx.y + pz * Wx.z
              y = px * Wy.x + py * Wy.y + pz * Wy.z
              z = px * Wz.x + py * Wz.y + pz * Wz.z
              return Vec3(x, y, z)

   <b>DXF</b> <b>Units</b>
       The <u>DXF</u> <u>reference</u> has no explicit information how to handle units in DXF, any information in this section
       is  based  on experiments with BricsCAD and may differ in other CAD applications, BricsCAD tries to be as
       compatible with AutoCAD as possible. Therefore, this information should also apply to AutoCAD.

       Please open an issue on <u>github</u> if you have any corrections or additional information about this topic.

   <b>Length</b> <b>Units</b>
       Any length or coordinate value in DXF is unitless in the  first  place,  there  is  no  unit  information
       attached  to  the  value.  The  unit  information  comes from the context where a DXF entity is used. The
       document/modelspace get the unit information from the header variable  $INSUNITS,  paperspace  and  block
       layouts  get  their  unit  information  from the attribute <u>units</u>.  The modelspace object has also a <b>units</b>
       property, but this value do not represent the modelspace units, this value is always set to 0 “unitless”.

       Get and set  document/modelspace units as enum by the <u>Drawing</u> property <b>units</b>:

          import ezdxf
          from ezdxf import units

          doc = ezdxf.new()
          # Set centimeter as document/modelspace units
          doc.units = units.CM
          # which is a shortcut (including validation) for
          doc.header['$INSUNITS'] = units.CM

   <b>Block</b> <b>Units</b>
       As said each block definition can have independent units,  but  there  is  no  implicit  unit  conversion
       applied, not in CAD applications and not in <u>ezdxf</u>.

       When  inserting  a  block  reference  (INSERT) into the modelspace or another block layout with different
       units, the scaling factor between these units <b>must</b> be applied explicit as DXF attributes (<b>xscale</b>,  …)  of
       the  <u>Insert</u>  entity,  e.g.  modelspace in meters and block in centimeters, x-, y- and z-scaling has to be
       0.01:

          doc.units = units.M
          my_block = doc.blocks.new('MYBLOCK')
          my_block.units = units.CM
          block_ref = msp.add_block_ref('MYBLOCK')
          # Set uniform scaling for x-, y- and z-axis
          block_ref.set_scale(0.01)

       Use helper function <u>conversion_factor()</u> to calculate the scaling factor between units:

          factor = units.conversion_factor(doc.units, my_block.units)
          # factor = 100 for 1m is 100cm
          # scaling factor = 1 / factor
          block_ref.set_scale(1.0/factor)

       <b>HINT:</b>
          It is never a good idea to use different measurement system in one project, ask the NASA  about  their
          Mars  Climate  Orbiter from 1999.  The same applies for units of the same measurement system, just use
          one unit like meters or inches.

   <b>Angle</b> <b>Units</b>
       Angles are always in degrees (360 deg = full circle)  in  counter-clockwise  orientation,  unless  stated
       explicit otherwise.

   <b>Display</b> <b>Format</b>
       How  values  are shown in the CAD GUI is controlled by the header variables $LUNITS and $AUNITS, but this
       has no meaning for values stored in DXF files.

   <b>$INSUNITS</b>
       The most important setting is the header variable $INSUNITS, this variable defines the drawing units  for
       the modelspace and therefore for the DXF document if no further settings are applied.

       The  modelspace  LAYOUT  entity  has  a  property <u>units</u> as any layout like object, but it seem to have no
       meaning for the modelspace, BricsCAD set this property always to 0, which means unitless.

       The most common units are 6 for meters and 1 for inches.

          doc.header['$INSUNITS'] = 6
                                            ┌────┬───────────────────────┐
                                            │ 0  │ Unitless              │
                                            ├────┼───────────────────────┤
                                            │ 1  │ Inches, <b>units.IN</b>      │
                                            ├────┼───────────────────────┤
                                            │ 2  │ Feet, <b>units.FT</b>        │
                                            ├────┼───────────────────────┤
                                            │ 3  │ Miles, <b>units.MI</b>       │
                                            ├────┼───────────────────────┤
                                            │ 4  │ Millimeters, <b>units.MM</b> │
                                            ├────┼───────────────────────┤
                                            │ 5  │ Centimeters, <b>units.CM</b> │
                                            ├────┼───────────────────────┤
                                            │ 6  │ Meters, <b>units.M</b>       │
                                            ├────┼───────────────────────┤
                                            │ 7  │ Kilometers, <b>units.KM</b>  │
                                            ├────┼───────────────────────┤
                                            │ 8  │ Microinches           │
                                            ├────┼───────────────────────┤
                                            │ 9  │ Mils                  │
                                            ├────┼───────────────────────┤
                                            │ 10 │ Yards, <b>units.YD</b>       │
                                            ├────┼───────────────────────┤
                                            │ 11 │ Angstroms             │
                                            ├────┼───────────────────────┤
                                            │ 12 │ Nanometers            │
                                            ├────┼───────────────────────┤
                                            │ 13 │ Microns               │
                                            ├────┼───────────────────────┤
                                            │ 14 │ Decimeters, <b>units.DM</b>  │
                                            ├────┼───────────────────────┤
                                            │ 15 │ Decameters            │
                                            ├────┼───────────────────────┤
                                            │ 16 │ Hectometers           │
                                            ├────┼───────────────────────┤
                                            │ 17 │ Gigameters            │
                                            ├────┼───────────────────────┤
                                            │ 18 │ Astronomical units    │
                                            ├────┼───────────────────────┤
                                            │ 19 │ Light years           │
                                            ├────┼───────────────────────┤
                                            │ 20 │ Parsecs               │
                                            ├────┼───────────────────────┤
                                            │ 21 │ US Survey Feet        │
                                            ├────┼───────────────────────┤
                                            │ 22 │ US Survey Inch        │
                                            ├────┼───────────────────────┤
                                            │ 23 │ US Survey Yard        │
                                            ├────┼───────────────────────┤
                                            │ 24 │ US Survey Mile        │
                                            └────┴───────────────────────┘

       See also enumeration <u>ezdxf.enums.InsertUnits</u>.

   <b>$MEASUREMENT</b>
       The header variable $MEASUREMENT controls whether the current  drawing  uses  imperial  or  metric  hatch
       pattern and linetype files:

       This  setting  is  independent  from  $INSUNITS,  it is possible to set the drawing units to inch and use
       metric linetypes and hatch pattern.

       In BricsCAD the base scaling of linetypes and hatch pattern is defined by  the  $MEASUREMENT  value,  the
       value of $INSUNITS is ignored.

          doc.header['$MEASUREMENT'] = 1
                                                   ┌───┬─────────┐
                                                   │ 0 │ English │
                                                   ├───┼─────────┤
                                                   │ 1 │ Metric  │
                                                   └───┴─────────┘

       See also enumeration <u>ezdxf.enums.Measurement</u>

   <b>$LUNITS</b>
       The  header  variable  $LUNITS  defines  how CAD applications display linear values in the GUI and has no
       meaning for <u>ezdxf</u>:

          doc.header['$LUNITS'] = 2
                                              ┌───┬───────────────────┐
                                              │ 1 │ Scientific        │
                                              ├───┼───────────────────┤
                                              │ 2 │ Decimal (default) │
                                              ├───┼───────────────────┤
                                              │ 3 │ Engineering       │
                                              ├───┼───────────────────┤
                                              │ 4 │ Architectural     │
                                              ├───┼───────────────────┤
                                              │ 5 │ Fractional        │
                                              └───┴───────────────────┘

       See also enumeration <u>ezdxf.enums.LengthUnits</u>

   <b>$AUNITS</b>
       The header variable $AUNITS defines how CAD applications display angular values in the  GUI  and  has  no
       meaning  for  <u>ezdxf</u>,  DXF  angles  are  always stored as degrees in counter-clockwise orientation, unless
       stated explicit otherwise:

          doc.header['$AUNITS'] = 0
                                           ───────────────────────────────
                                             0   Decimal degrees
                                           ───────────────────────────────
                                             1   Degrees/minutes/seconds
                                           ───────────────────────────────
                                             2   Grad
                                           ───────────────────────────────
                                             3   Radians
                                           ┌───┬─────────────────────────┐
                                           │   │                         │
--
</pre><h4><b>TUTORIALS</b></h4><pre>
   <b>Tutorial</b> <b>for</b> <b>Getting</b> <b>Data</b> <b>from</b> <b>DXF</b> <b>Files</b>
       This tutorial shows how to get data from an existing DXF document.  If you are a new user of <u>ezdxf</u>,  read
       also the tutorial <u>Usage</u> <u>for</u> <u>Beginners</u>.

       Loading the DXF file:

          import sys
          import ezdxf

          try:
              doc = ezdxf.readfile("your_dxf_file.dxf")
          except IOError:
              print(f"Not a DXF file or a generic I/O error.")
              <a href="../man1/sys.exit.1.html">sys.exit</a>(1)
          except ezdxf.DXFStructureError:
              print(f"Invalid or corrupted DXF file.")
              <a href="../man2/sys.exit.2.html">sys.exit</a>(2)

       This  works  well for DXF files from trusted sources like AutoCAD or BricsCAD, for loading DXF files with
       minor or major flaws look at the <u>ezdxf.recover</u> module.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Document</u> <u>Management</u>

          • <u>Usage</u> <u>for</u> <u>Beginners</u>

   <b>Layouts</b>
       The term layout is used as a synonym for an arbitrary entity space which can contain  DXF  entities  like
       LINE, CIRCLE, TEXT and so on. Each DXF entity can only reside in exact one layout.

       There are three different layout types:

       • <u>Modelspace</u>: the common construction space

       • <u>Paperspace</u>: used to to create print layouts

       • <u>BlockLayout</u>: reusable elements, every block has its own entity space

       A DXF document consist of exact one modelspace and at least one paperspace.  DXF R12 has only one unnamed
       paperspace the later DXF versions support more than one paperspace and each paperspace has a name.

   <b>Getting</b> <b>the</b> <b>modelspace</b> <b>layout</b>
       The  modelspace contains the “real” world representation of the drawing subjects in real world units. The
       modelspace has the fixed name “Model” and the DXF document has a special getter method <u>modelspace()</u>.

          msp = doc.modelspace()

   <b>Iterate</b> <b>over</b> <b>DXF</b> <b>entities</b> <b>of</b> <b>a</b> <b>layout</b>
       This code shows how to iterate over all DXF entities in modelspace:

          # helper function
          def print_entity(e):
              print("LINE on layer: %s\n" % e.dxf.layer)
              print("start point: %s\n" % e.dxf.start)
              print("end point: %s\n" % e.dxf.end)

          # iterate over all entities in modelspace
          msp = doc.modelspace()
          for e in msp:
              if e.dxftype() == "LINE":
                  print_entity(e)

          # entity query for all LINE entities in modelspace
          for e in msp.query("LINE"):
              print_entity(e)

       All layout objects supports the standard Python iterator protocol and the <b>in</b> operator.

   <b>Access</b> <b>DXF</b> <b>attributes</b> <b>of</b> <b>an</b> <b>entity</b>
       The <b>e.dxftype()</b> method returns the DXF type, the DXF type is always an uppercase string like <b>"LINE"</b>.  All
       DXF attributes of an entity are grouped in the namespace attribute <b>dxf</b>:

          e.dxf.layer  # layer of the entity as string
          e.dxf.color  # color of the entity as integer

       See <u>Common</u> <u>graphical</u> <u>DXF</u> <u>attributes</u>

       If  a  DXF  attribute  is not set (the DXF attribute does not exist), a <b>DXFValueError</b> will be raised. The
       <b>get()</b> method returns a default value in this case or <b>None</b> if no default value is specified:

          # If DXF attribute 'paperspace' does not exist, the entity defaults
          # to modelspace:
          p = e.dxf.get("paperspace", 0)

       or check beforehand if the attribute exist:

          if e.dxf.hasattr("paperspace"):
              ...

       An unsupported DXF attribute raises a <b>DXFAttributeError</b>, to check if an  attribute  is  supported  by  an
       entity use:

          if e.dxf.is_supported("paperspace"):
              ...

   <b>Getting</b> <b>a</b> <b>paperspace</b> <b>layout</b>
          paperspace = doc.paperspace("layout0")

       The  code above retrieves the paperspace named <b>layout0</b>, the usage of the <u>Paperspace</u> object is the same as
       of the modelspace object.  DXF R12 provides only one paperspace, therefore the  paperspace  name  in  the
       method  call <b>doc.paperspace("layout0")</b> is ignored or can be left off.  For newer DXF versions you can get
       a list of the available layout names by the methods <u>layout_names()</u> and <u>layout_names_in_taborder()</u>.

   <b>Retrieve</b> <b>entities</b> <b>by</b> <b>query</b> <b>language</b>
       <u>Ezdxf</u> provides a flexible query language for DXF entities.  All layout types have  a  <u>query()</u>  method  to
       start an entity query or use the <u>ezdxf.query.new()</u> function.

       The  query  string  is  the  combination  of  two queries, first the required entity query and second the
       optional attribute query, enclosed in square brackets: <b>"EntityQuery[AttributeQuery]"</b>

       The entity query is a whitespace separated list of DXF entity names or the special name <b>*</b>. Where <b>*</b>  means
       all DXF entities, all DXF names have to be uppercase. The <b>*</b> search can exclude entity types by adding the
       entity name with a preceding <b>!</b> (e.g. <b>*</b> <b>!LINE</b>, search all entities except lines).

       The  attribute  query  is  used  to  select DXF entities by its DXF attributes. The attribute query is an
       addition to the entity query and matches only if the entity already match the entity query. The attribute
       query is a boolean expression, supported operators: <b>and</b>, <b>or</b>, <b>!</b>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Entity</u> <u>Query</u> <u>String</u>

       Get all LINE entities from the modelspace:

          msp = doc.modelspace()
          lines = msp.query("LINE")

       The result container <u>EntityQuery</u> also provides the <b>query()</b> method to further refine the  query,  such  as
       retrieving all LINE entities at layer <b>construction</b>:

          construction_lines = lines.query('*[layer=="construction"]')

       The  <b>*</b>  is  a wildcard for all DXF types, in this case you could also use <b>LINE</b> instead of <b>*</b>, <b>*</b> works here
       because the source just contains LINE entities.

       This could be executed as a single query:

          lines = msp.query('LINE[layer=="construction"]')

       An advanced query for getting all modelspace entities at layer <b>construction</b>, but excluding entities  with
       linetype <b>DASHED</b>:

          not_dashed_entities = msp.query('*[layer=="construction" and linetype!="DASHED"]')

   <b>Extended</b> <b>EntityQuery</b> <b>Features</b>
       The  <u>EntityQuery</u>  class  has  properties  and  overloaded  operators  to build extended queries by Python
       features instead of a query string.

       Same task as in the previous section but using features of the <u>EntityQuery</u> container:

          # The overloaded rational operators return an EntityQuery object and not a bool value!
          lines = msp.query("LINES").layer == "construction"
          not_dashed_lines = lines.linetype != "DASHED"

       <b>SEE</b> <b>ALSO:</b>
          <u>Extended</u> <u>EntityQuery</u> <u>Features</u>

   <b>Retrieve</b> <b>entities</b> <b>by</b> <b>groupby()</b> <b>function</b>
       The <u>groupby()</u> function searches and group entities by a user defined criteria.  As an example let’s group
       all entities from modelspace by layer, the result will be a <u>dict</u> with layer names as dict-key and a  list
       of all entities from the modelspace matching this layer as dict-value:

          from ezdxf.groupby import groupby
          group = groupby(entities=msp, dxfattrib="layer")

       The <u>entities</u> argument can be any container or generator which yields DXF entities:

          group = msp.groupby(dxfattrib="layer")

          for layer, entities in group.items():
              print(f'Layer "{layer}" contains following entities:')
              for entity in entities:
                  print(f"    {entity}")
              print("-"*40)

       The  previous  example  shows how to group entities by a single DXF attribute.  For a more advanced query
       create a custom key function, which accepts a DXF entity as argument and  returns  a  hashable  value  as
       dict-key or <b>None</b> to exclude the entity.

       The  following  example  shows how to group entities by layer and color, the dict-key is a <b>(layer,</b> <b>color)</b>
       tuple and the dict-value is a list of entities with matching DXF attributes:

          def layer_and_color_key(entity):
              # return None to exclude entities from the result container
              if entity.dxf.layer == "0":  # exclude entities from default layer "0"
                  return None
              else:
                  return entity.dxf.layer, entity.dxf.color

          group = msp.groupby(key=layer_and_color_key)
          for key, entities in group.items():
              print(f'Grouping criteria "{key}" matches following entities:')
              for entity in entities:
                  print(f"    {entity}")
              print("-"*40)

       The <u>groupby()</u> function catches <b>DXFAttributeError</b> exceptions while processing entities and  excludes  this
       entities  from  the  result.   There  is no need to worry about DXF entities which do not support certain
       attributes, they will be excluded automatically.

       <b>SEE</b> <b>ALSO:</b>
          <u>groupby()</u> documentation

   <b>Tutorial</b> <b>for</b> <b>Creating</b> <b>DXF</b> <b>Drawings</b>
       Create a new DXF document by the <u>ezdxf.new()</u> function:

          import ezdxf

          # create a new DXF R2010 document
          doc = ezdxf.new("R2010")

          # add new entities to the modelspace
          msp = doc.modelspace()
          # add a LINE entity
          msp.add_line((0, 0), (10, 0))
          # save the DXF document
          doc.saveas("line.dxf")

       New entities are always added to layouts, a layout can be the modelspace, a paperspace layout or a  block
       layout.

       <b>SEE</b> <b>ALSO:</b>
          <u>Thematic</u> <u>Index</u> <u>of</u> <u>Layout</u> <u>Factory</u> <u>Methods</u>

   <b>Predefined</b> <b>Resources</b>
       <u>Ezdxf</u>  creates  new  DXF documents with as little content as possible, this means only the resources that
       are absolutely necessary are created.  The <u>ezdxf.new()</u> function can create some standard resources,  such
       as linetypes and text styles, by setting the argument <u>setup</u> to <b>True</b>.

          import ezdxf

          doc = ezdxf.new("R2010", setup=True)
          msp = doc.modelspace()
          msp.add_line((0, 0), (10, 0), dxfattribs={"linetype": "DASHED"})

       The  defined  standard  linetypes  are shown in the basic concept section for <u>Linetypes</u> and the available
       text styles are shown in the <u>Tutorial</u> <u>for</u> <u>Text</u>.

       <b>IMPORTANT:</b>
          To see the defined text styles in a DXF viewer or CAD application, the applications have to know where
          the referenced TTF fonts can be found.  This configuration is not possible by <u>ezdxf</u> and has to be done
          for each application as described in their documentation.

          See also: <u>Font</u> <u>Resources</u>

   <b>Simple</b> <b>DXF</b> <b>R12</b> <b>drawings</b>
       The <u>r12writer</u> add-on creates simple DXF R12 drawings with a restricted set of DXF  types:  LINE,  CIRCLE,
       ARC, TEXT, POINT, SOLID, 3DFACE and POLYLINE.

       The  advantage  of  the  <u>r12writer</u>  is the speed and the small memory footprint, all entities are written
       directly to a file or stream without creating a document structure in memory.

       <b>SEE</b> <b>ALSO:</b>
          <u>r12writer</u>

   <b>Tutorial</b> <b>for</b> <b>Common</b> <b>Graphical</b> <b>Attributes</b>
       The graphical attributes <b>color</b>, <b>linetype</b>, <b>lineweight</b>, <b>true_color</b>, <b>transparency</b>, <b>ltscale</b> and <b>invisible</b> are
       available for all graphical DXF entities and are located in the DXF namespace attribute <b>dxf</b>  of  the  DXF
       entities.   All  these  attributes  are  optional  and  all except for <b>true_color</b> and <b>transparency</b> have a
       default value.

       Not all of these attributes are supported by all DXF versions. This table shows the minimum required  DXF
       version for each attribute:
                                      ┌───────┬────────────────────────────────┐
                                      │ R12   │ <b>color</b>, <b>linetype</b>                │
                                      ├───────┼────────────────────────────────┤
                                      │ R2000 │ <b>lineweight</b>, <b>ltscale</b>, <b>invisible</b> │
                                      ├───────┼────────────────────────────────┤
                                      │ R2004 │ <b>true_color</b>, <b>transparency</b>       │
                                      └───────┴────────────────────────────────┘

   <b>Color</b>
       Please read the section about the <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> to understand the basics.

       The usage of the <u>color</u> attribute is very straight forward. Setting the value is:

          entity.dxf.color = 1

       and getting the value looks like this:

          value = entity.dxf.color

       The  <b>color</b>  attribute  has  a  default  value  of  256,  which  means take the color defined by the layer
       associated to the entity. The <u>ezdxf.colors</u> module defines some constants for often used color values:

          entity.dxf.color = ezdxf.colors.RED

       The <u>ezdxf.colors.aci2rgb()</u> function converts the ACI value to the RGB value  of  the  default  modelspace
       palette.

       <b>SEE</b> <b>ALSO:</b>

          • Basics about <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>

          • <u>ezdxf.colors</u> module

   <b>True</b> <b>Color</b>
       Please read the section about <u>True</u> <u>Color</u> to understand the basics.

       The easiest way is to use the <b>rgb</b> property to set and get the true color values as RGB tuples:

          entity.rgb = (255, 128, 16)

       The <b>rgb</b> property return <b>None</b> if the <b>true_color</b> attribute is not present:

          rgb = entity.rgb
          if rgb is not None:
              r, g, b = rgb

       Setting  and  getting  the  <b>true_color</b> DXF attribute directly is possible and the <u>ezdxf.colors</u> module has
       helper function to convert RGB tuples to 24-bit value and back:

          entity.dxf.true_color = ezdxf.colors.rgb2int(255, 128, 16)

       The <b>true_color</b> attribute is optional does not have a default value and therefore it is not  safe  to  use
       the attribute directly, check if the attribute exists beforehand:

          if entity.dxf.hasattr("true_color"):
              r, g, b = ezdxf.colors.int2rgb(entity.dxf.true_color)

       or  use  the <b>get()</b> method of the <b>dxf</b> namespace attribute to get a default value if the attribute does not
       exist:

          r, g, b = ezdxf.colors.int2rgb(entity.dxf.get("true_color", 0)

       <b>SEE</b> <b>ALSO:</b>

          • Basics about <u>True</u> <u>Color</u>

          • <u>ezdxf.colors</u> module

   <b>Transparency</b>
       Please read the section about <u>Transparency</u> to understand the basics.

       It’s recommended to use the <u>transparency</u>  property  of  the  <u>DXFGraphic</u>  base  class.   The  <b>transparency</b>
       property is a float value in the range from 0.0 to 1.0 where 0.0 is opaque and 1.0 if fully transparent:

          entity.transparency = 0.5

       or set the values of the DXF attribute by constants defined in the <u>ezdxf.colors</u> module:

          entity.dxf.transparency = ezdxf.colors.TRANSPARENCY_50

       The  default  setting  for  <b>transparency</b>  in  CAD  applications  is always transparency by layer, but the
       <b>transparency</b> property in <u>ezdxf</u> has a default value of  0.0  (opaque),  so  there  are  additional  entity
       properties  to  check  if the transparency value should be taken from the associated entity layer or from
       the parent block:

          if entity.is_transparency_by_layer:
              ...
          elif entity.is_transparency_by_block:
              ...
          else:
              ...

       The top level entity attribute <b>transparency</b> does not support setting transparency by layer or block:

          from ezdxf import colors

          ...

          # set transparency by layer by removing the DXF attribute "transparency":
          entity.dxf.discard("transparency")

          # set transparency by block:
          entity.dxf.transparency = colors.TRANSPARENCY_BYBLOCK

          # there are also some handy constants in the colors module:
          # TRANSPARENCY_10 upto TRANSPARENCY_90 in steps of 10
          entity.dxf.transparency = colors.TRANSPARENCY_30  # set 30% transparency
          entity.dxf.transparency = colors.OPAQUE

       <b>SEE</b> <b>ALSO:</b>

          • Basics about <u>Transparency</u>

          • <u>ezdxf.colors</u> module

   <b>Linetype</b>
       Please read the section about <u>Linetypes</u> to understand the basics.

       The <b>linetype</b> attribute contains the name of the linetype as string and can be set by  the  <b>dxf</b>  namespace
       attribute directly:

          entity.dxf.linetype = "DASHED"  # linetype DASHED must exist!

       The  <b>linetype</b>  attribute is optional and has a default value of “BYLAYER”, so the attribute can always be
       used without any concerns:

          name = entity.dxf.linetype

       <b>WARNING:</b>
          Make sure the linetype you assign to an entity is really  defined  in  the  linetype  table  otherwise
          AutoCAD  will  not  open the DXF file. There are no implicit checks for that by <u>ezdxf</u> but you can call
          the <u>audit()</u> method of the DXF document explicitly to validate the document before exporting.

       <u>Ezdxf</u> creates new DXF documents with as little content as possible, this means only  the  resources  that
       are  absolutely  necessary  are  created.  The <u>ezdxf.new()</u> function can create some standard linetypes by
       setting the argument <u>setup</u> to <b>True</b>:

          doc = ezdxf.new("R2010", setup=True)

       <b>SEE</b> <b>ALSO:</b>

          • Basics about <u>Linetypes</u>

          • <u>Tutorial</u> <u>for</u> <u>Creating</u> <u>Linetype</u> <u>Pattern</u>

   <b>Lineweight</b>
       Please read the section about <u>Lineweights</u> to understand the basics.

       The <b>lineweight</b> attribute contains the lineweight as an integer value and can be set by the <b>dxf</b>  namespace
       attribute directly:

          entity.dxf.lineweight = 25

       The  <b>lineweight</b>  value  is  the  line  width in millimeters times 100 e.g.  0.25mm = 25, but only certain
       values are valid for more information go to section: <u>Lineweights</u>.

       Values &lt; 0 have a special meaning and can be imported as constants from <u>ezdxf.lldxf.const</u>
                                             ┌────┬────────────────────┐
                                             │ -1 │ LINEWEIGHT_BYLAYER │
                                             ├────┼────────────────────┤
                                             │ -2 │ LINEWEIGHT_BYBLOCK │
                                             ├────┼────────────────────┤
                                             │ -3 │ LINEWEIGHT_DEFAULT │
                                             └────┴────────────────────┘

       The <b>lineweight</b> attribute is optional and has a default value of -1, so the attribute can always  be  used
       without any concerns:

          lineweight = entity.dxf.lineweight

       <b>IMPORTANT:</b>
          You  have to enable the option to show lineweights in your CAD application or viewer to see the effect
          on screen, which is disabled by default, the same has to  be  done  in  the  page  setup  options  for
          plotting lineweights.

          # activate on screen lineweight display
          doc.header["$LWDISPLAY"] = 1

       <b>SEE</b> <b>ALSO:</b>

          • Basics about <u>Lineweights</u>

   <b>Linetype</b> <b>Scale</b>
       The  <b>ltscale</b>  attribute  scales the linetype pattern by a float value and can be set by the <b>dxf</b> namespace
       attribute directly:

          entity.dxf.ltscale = 2.0

       The <b>ltscale</b> attribute is optional and has a default value of 1.0, so the attribute  can  always  be  used
       without any concerns:

          scale = entity.dxf.ltscale

       <b>SEE</b> <b>ALSO:</b>

          • Basics about <u>Linetypes</u>

   <b>Invisible</b>
       The <b>invisible</b> attribute an boolean value (0/1) which defines if an entity is invisible or visible and can
       be set by the <b>dxf</b> namespace attribute directly:

          entity.dxf.invisible = 1

       The  <b>invisible</b>  attribute  is  optional and has a default value of 0, so the attribute can always be used
       without any concerns:

          is_invisible = bool(entity.dxf.invisible)

   <b>GfxAttribs</b>
       When adding new entities to an entity space like the  modelspace  or  a  block  definition,  the  factory
       methods  expect the graphical DXF attributes by the argument <u>dxfattribs</u>. This object can be a Python <b>dict</b>
       where the key is the DXF attribute name and  the  value  is  the  attribute  value,  or  better  use  the
       <u>GfxAttribs</u> object which has some additional validation checks and support for code completions by IDEs:

          import ezdxf
          from ezdxf.gfxattribs import GfxAttribs

          doc = ezdxf.new()
          msp = doc.modelspace()

          line = msp.add_line(
              (0, 0), (10, 10), dxfattribs=GfxAttribs(layer="0", rgb=(25, 128, 16))
          )

       <b>SEE</b> <b>ALSO:</b>

          • <u>ezdxf.gfxattribs</u> module

   <b>Tutorial</b> <b>for</b> <b>Layers</b>
       If you are not familiar with the concept of layers, please read this first: Concept of <u>Layers</u>

       Reminder: a layer definition is not required for using a layer!

   <b>Create</b> <b>a</b> <b>Layer</b> <b>Definition</b>
          import ezdxf

          doc = ezdxf.new(setup=True)  # setup required line types
          msp = doc.modelspace()
          doc.layers.add(name="MyLines", color=7, linetype="DASHED")

       The  advantage  of assigning a linetype and a color to a layer is that entities on this layer can inherit
       this properties by using <b>"BYLAYER"</b> as linetype string and <b>256</b> as color, both values  are  default  values
       for new entities so you can leave off these assignments:

          msp.add_line((0, 0), (10, 0), dxfattribs={"layer": "MyLines"})

       The new created line will be drawn with color <b>7</b> and linetype <b>"DASHED"</b>.

   <b>Moving</b> <b>an</b> <b>Entity</b> <b>to</b> <b>a</b> <b>Different</b> <b>Layer</b>
       Moving an entity to a different layer is a simple assignment of the new layer name to the <b>layer</b> attribute
       of the entity.

          line = msp.add_line((0, 0), (10, 0), dxfattribs={"layer": "MyLines"})
          # move the entity to layer "OtherLayer"
          line.dxf.layer = "OtherLayer"

   <b>Changing</b> <b>Layer</b> <b>State</b>
       Get the layer definition object from the layer table:

          my_lines = doc.layers.get('MyLines')

       Check the state of the layer:

          my_lines.is_off()  # True if layer is off
          my_lines.is_on()   # True if layer is on
          my_lines.is_locked()  # True if layer is locked
          layer_name = my_lines.dxf.name  # get the layer name

       Change the state of the layer:

          # switch layer off, entities at this layer will not shown in CAD applications/viewers
          my_lines.off()

          # lock layer, entities at this layer are not editable in CAD applications
          my_lines.lock()

       Get/set  the  color  of  a  layer  by  property <b>Layer.color</b>, because the DXF attribute <b>Layer.dxf.color</b> is
       misused for switching the layer on and off, the layer is off if the color value is negative.

       Changing the layer properties:

          my_lines.dxf.linetype = "DOTTED"
          my_lines.color = 13  # preserves on/off state of layer

       <b>SEE</b> <b>ALSO:</b>
          For all methods and attributes see class <u>Layer</u>.

   <b>Check</b> <b>Available</b> <b>Layers</b>
       The <u>LayerTable</u> object supports some standard Python protocols:

          # iteration
          for layer in doc.layers:
              if layer.dxf.name != "0":
                  layer.off()  # switch all layers off except layer "0"

          # check for existing layer definition
          if "MyLines" in doc.layers:
              layer = doc.layers.get("MyLines")

          layer_count = len(doc.layers) # total count of layer definitions

   <b>Renaming</b> <b>a</b> <b>Layer</b>
       The <u>Layer</u> class has a method for renaming the layer, but has same limitations, not all places where layer
       references can occur are documented, third-party entities are black-boxes with unknown content and  layer
       references could be stored in the extended data section of any DXF entity or in a XRECORD entity, so some
       references  may  reference  a non-existing layer definition after the renaming, at least these references
       are still valid, because a layer definition is not required for using a layer.

          my_lines = doc.layers.get("MyLines")
          my_lines.rename("YourLines")

   <b>Deleting</b> <b>a</b> <b>Layer</b> <b>Definition</b>
       Delete a layer definition:

          doc.layers.remove("MyLines")

       This just deletes the layer definition, all DXF entities referencing this  layer  still  exist,  if  they
       inherit any properties from the deleted layer they will now get the default layer properties.

       <b>WARNING:</b>
          The behavior of entities referencing the layer by handle is unknown and may break the DXF document.

   <b>Deleting</b> <b>All</b> <b>Entities</b> <b>From</b> <b>a</b> <b>Layer</b>
       Because  of  all  these  uncertainties  about  layer  references  mentioned  above, deleting all entities
       referencing a certain layer from a DXF document is not implemented as an API call!

       Nonetheless deleting all graphical entities from the DXF document which do reference a certain  layer  by
       the <b>layer</b> attribute is a safe procedure:

          key_func = doc.layers.key
          layer_key = key_func("MyLines")
          # The trashcan context-manager is a safe way to delete entities from the
          # entities database while iterating.
          with doc.entitydb.trashcan() as trash:
              for entity in doc.entitydb.values():
                  if not entity.dxf.hasattr("layer"):
                      continue
                  if layer_key == key_func(entity.dxf.layer):
                      # safe destruction while iterating
                      trash.add(entity.dxf.handle)

   <b>Tutorial</b> <b>for</b> <b>Creating</b> <b>Linetype</b> <b>Pattern</b>
       Simple line type example: [image]

       You  can  define  your  own  linetypes.  A linetype definition has a name, a description and line pattern
       elements:

          elements = [total_pattern_length, elem1, elem2, ...]

       <b>total_pattern_length</b>
              Sum of all linetype elements (absolute values)

       <b>elem</b>   if elem &gt; 0 it is a line, if elem &lt; 0 it is gap, if elem == 0.0 it is a dot

       Create a new linetype definition:

          import ezdxf
          from ezdxf.tools.standards import linetypes  # some predefined linetypes

          doc = ezdxf.new()
          msp = doc.modelspace()

          my_line_types = [
              (
                  "DOTTED",
                  "Dotted .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .",
                  [0.2, 0.0, -0.2],
              ),
              (
                  "DOTTEDX2",
                  "Dotted (2x) .    .    .    .    .    .    .    . ",
                  [0.4, 0.0, -0.4],
              ),
              (
                  "DOTTED2",
                  "Dotted (.5) . . . . . . . . . . . . . . . . . . . ",
                  [0.1, 0.0, -0.1],
              ),
          ]
          for name, desc, pattern in my_line_types:
              if name not in doc.linetypes:
                  doc.linetypes.add(
                      name=name,
                      pattern=pattern,
                      description=desc,
                  )

       Setup some predefined linetypes:

          for name, desc, pattern in linetypes():
              if name not in doc.linetypes:
                  doc.linetypes.add(
                      name=name,
                      pattern= pattern,
                      description=desc,
                  )

   <b>Check</b> <b>Available</b> <b>Linetypes</b>
       The linetypes object supports some standard Python protocols:

          # iteration
          print("available linetypes:")
          for lt in doc.linetypes:
              print(f"{lt.dxf.name}: {lt.dxf.description}")

          # check for existing linetype
          if "DOTTED" in doc.linetypes:
              pass

          count = len(doc.linetypes) # total count of linetypes

   <b>Removing</b> <b>Linetypes</b>
       <b>WARNING:</b>
          Ezdxf does not check if a linetype is still in use and deleting a  linetype  which  is  still  in  use
          generates  an  <b>invalid</b>  DXF  file.  The  audit  process  <u>audit()</u>  of the DXF document removes <b>linetype</b>
          attributes referencing non existing linetypes.

       You can delete a linetype:

          doc.layers.remove("DASHED")

       This just removes the linetype definition, the <b>linetype</b> attribute of DXF entities  may  still  refer  the
       removed linetype definition “DASHED” and AutoCAD will not open DXF files including undefined linetypes.

   <b>Tutorial</b> <b>for</b> <b>Creating</b> <b>Complex</b> <b>Linetype</b> <b>Pattern</b>
       In DXF R13 Autodesk introduced complex linetypes, containing TEXT or SHAPES in line types.

       Complex linetype example with text: [image]

       Complex line type example with shapes: [image]

       For  easy  usage  the  pattern  string  for  complex  line types is mostly the same string as the pattern
       definition strings in AutoCAD “.lin” files.

       Example for complex line type TEXT:

          doc = ezdxf.new("R2018")  # DXF R13 or later is required

          doc.linetypes.add(
              name="GASLEITUNG2",
              # linetype definition string from acad.lin:
              pattern='A,.5,-.2,["GAS",STANDARD,S=.1,U=0.0,X=-0.1,Y=-.05],-.25',
              description= "Gasleitung2 ----GAS----GAS----GAS----GAS----GAS----",
              length=1,  # required for complex line types
          })

       The pattern always starts with an “A”, the following float values have the same  meaning  as  for  simple
       linetypes,  a  value  &gt; 0 is a line, a value &lt; 0 is a gap, and a 0 is a point, the opening square bracket
       “[” starts the complex part of the linetype pattern.

       The text after the “[” defines the complex linetype:

       • A text in quotes (e.g. “GAS”) defines a <u>complex</u> <u>TEXT</u> <u>linetype</u> and represents the pattern text itself.

       • A text without quotes is a SHAPE name (in “.lin” files) and defines a <u>complex</u> <u>SHAPE</u> <u>linetype.</u> <u>Ezdxf</u> <u>can</u>
         <u>not</u> <u>translate</u> <u>this</u> <u>SHAPE</u> <u>name</u> <u>from</u> <u>the</u> <u>“.lin”</u> <u>file</u> <u>into</u> <u>the</u> <u>required</u> <u>shape</u> <u>file</u> <u>index,</u> <u>so</u> <u>*YOU</u> have  to
         translate  this  SHAPE  name  into  the  shape file index, e.g. saving the file with AutoCAD as DXF and
         searching for the DXF linetype definition, see example below and the DXF Internals: <u>LTYPE</u> <u>Table</u>.

       For <u>complex</u> <u>TEXT</u> <u>linetypes</u> the second parameter is the text style, for <u>complex</u> <u>SHAPE</u> <u>linetypes</u> the second
       parameter is the shape file name, the shape file has to be in the same directory as the DXF  file  or  in
       one of the CAD application support paths.

       The meaning of the following comple linetype parameters are shown in the table below:
                                  ┌────────┬───────────────────────────────────────┐
                                  │ S      │ scaling  factor,  always  &gt; 0, if S=0 │
                                  │        │ the TEXT or SHAPE is not visible      │
                                  ├────────┼───────────────────────────────────────┤
                                  │ R or U │ rotation   relative   to   the   line │
                                  │        │ direction                             │
                                  ├────────┼───────────────────────────────────────┤
                                  │ X      │ x-direction offset (along the line)   │
                                  ├────────┼───────────────────────────────────────┤
                                  │ Y      │ y-direction  offset (perpendicular to │
                                  │        │ the line)                             │
                                  └────────┴───────────────────────────────────────┘

       These parameters are case insensitive and the closing square bracket “]” ends the  complex  part  of  the
       linetype pattern.

       The  fine  tuning  of  this  parameters is a try an error process, for <u>complex</u> <u>TEXT</u> <u>linetypes</u> the scaling
       factor (e.g. the STANDARD text style) sets the text height (e.g. “S=0.1” sets  the  text  height  to  0.1
       units),  by shifting in y-direction by half of the scaling factor, the text is vertically centered to the
       line. For the x-direction it seems to be a good practice to place a gap in front of the  text  and  after
       the text, find x shifting value and gap sizes by try and error. The overall length is at least the sum of
       all line and gap definitions (absolute values).

       Example for complex line type SHAPE:

          doc.linetypes.add("GRENZE2",
              # linetype definition in acad.lin:
              # A,.25,-.1,[BOX,ltypeshp.shx,x=-.1,s=.1],-.1,1
              # replacing BOX by shape index 132 (got index from an AutoCAD file),
              # ezdxf can't get shape index from ltypeshp.shx
              pattern="A,.25,-.1,[132,ltypeshp.shx,x=-.1,s=.1],-.1,1",
              description="Grenze eckig ----[]-----[]----[]-----[]----[]--",
              length= 1.45,  # required for complex line types
          })

       Complex  line  types with shapes only work if the associated shape file (e. g.  ltypeshp.shx) and the DXF
       file are in the same directory or the shape file is placed in one of the CAD application support folders.

   <b>Tutorial</b> <b>for</b> <b>Simple</b> <b>DXF</b> <b>Entities</b>
       These are basic graphical entities located in an entity space like the modelspace or a  block  definition
       and only support the common graphical attributes.

       The  entities  in  the following examples are always placed in the xy-plane of the <u>WCS</u> aka the 2D drawing
       space.  Some of these entities can only be placed outside the xy-plane in 3D space by utilizing the  <u>OCS</u>,
       but  this  feature  is beyond the scope of this tutorial, for more information about that go to: <u>Tutorial</u>
       <u>for</u> <u>OCS/UCS</u> <u>Usage</u>.

       Prelude to all following examples:

          import ezdxf
          from ezdxf.gfxattribs import GfxAttribs

          doc = ezdxf.new()
          doc.layers.new("ENTITY", color=1)
          msp = doc.modelspace()
          attribs = GfxAttribs(layer="ENTITY")

       <b>SEE</b> <b>ALSO:</b>

          • <u>Tutorial</u> <u>for</u> <u>Creating</u> <u>DXF</u> <u>Drawings</u>

          • <u>Tutorial</u> <u>for</u> <u>Layers</u>

          • <u>ezdxf.gfxattribs</u> module

   <b>Point</b>
       The <u>Point</u> entity marks a 3D point in the <u>WCS</u>:

          point = msp.add_point((10, 10), dxfattribs=attribs)

       All <u>Point</u> entities have the same styling stored in the header variable $PDMODE, for more information read
       the reference of class <u>Point</u>.

       <b>SEE</b> <b>ALSO:</b>

          • Reference of class <u>Point</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

   <b>Line</b>
       The <u>Line</u> entity is a 3D line with a start- and an end point in the <u>WCS</u>:

          line = msp.add_line((0, 0), (10, 10), dxfattribs=attribs)

       <b>SEE</b> <b>ALSO:</b>

          • Reference of class <u>Line</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • <u>ezdxf.math.ConstructionLine</u>

   <b>Circle</b>
       The <u>Circle</u> entity is an <u>OCS</u> entity defined by a center point and a radius:

          circle = msp.add_circle((10, 10), radius=3, dxfattribs=attribs)

       <b>SEE</b> <b>ALSO:</b>

          • Reference of class <u>Circle</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • <u>ezdxf.math.ConstructionCircle</u>

   <b>Arc</b>
       The <u>Arc</u> entity is an <u>OCS</u> entity defined by a center point, a  radius  a  start-   and  an  end  angle  in
       degrees:

          arc = msp.add_arc((10, 10), radius=3, start_angle=30, end_angle=120, dxfattribs=attribs)

       The  arc  goes  always  in  counter-clockwise  orientation around the z-axis more precisely the extrusion
       vector of <u>OCS</u>, but this is beyond the scope of this tutorial.

       The  helper  class  <u>ezdxf.math.ConstructionArc</u>  provides  constructors  to  create  arcs  from  different
       scenarios:

       • <u>from_2p_angle</u>: arc from 2 points and an angle

       • <u>from_2p_radius</u>: arc from 2 points and a radius

       • <u>from_3p</u>: arc from 3 points

       This example creates an arc from point (10, 0) to point (0, 0) passing the point (5, 3):

          from ezdxf.math import ConstructionArc


          # -x-x-x- snip -x-x-x-
          arc = ConstructionArc.from_3p(
              start_point=(10, 0), end_point=(0, 0), def_point=(5, 3)
          )
          arc.add_to_layout(msp, dxfattribs=attribs)

       <b>SEE</b> <b>ALSO:</b>

          • Reference of class <u>Arc</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • <u>ezdxf.math.ConstructionArc</u>

   <b>Ellipse</b>
       The  <u>Ellipse</u>  entity  requires  DXF  R2000 or newer and is a true <u>WCS</u> entity. The ellipse is defined by a
       center point, a vector for the major axis, the ratio between major- and minor axis and the start- and end
       parameter in radians:

          ellipse = msp.add_ellipse(
              (10, 10), major_axis=(5, 0), ratio=0.5, start_param=0, end_param=math.pi, dxfattribs=attribs
          )

       When placed in 3D space the extrusion vector defines the normal vector of the ellipse plane and the minor
       axis is the extrusion vector <b>cross</b> the major axis.

       <b>SEE</b> <b>ALSO:</b>

          • Reference of class <u>Ellipse</u>

          • <u>Tutorial</u> <u>for</u> <u>Common</u> <u>Graphical</u> <u>Attributes</u>

          • <u>ezdxf.math.ConstructionEllipse</u>

   <b>Further</b> <b>Tutorials</b>
       • <u>Tutorial</u> <u>for</u> <u>LWPolyline</u>

       • <u>Tutorial</u> <u>for</u> <u>Spline</u>

       • <u>Tutorial</u> <u>for</u> <u>Text</u>

       • <u>Tutorial</u> <u>for</u> <u>MText</u> <u>and</u> <u>MTextEditor</u>

       • <u>Tutorial</u> <u>for</u> <u>Hatch</u>

       • <u>Tutorial</u> <u>for</u> <u>MultiLeader</u>

       • <u>Tutorial</u> <u>for</u> <u>Mesh</u>

   <b>Tutorial</b> <b>for</b> <b>Blocks</b>
       If you are not familiar with the concept of blocks, please read this first: Concept of <u>Blocks</u>

   <b>Create</b> <b>a</b> <b>Block</b>
       Blocks are managed as <u>BlockLayout</u> objects by the <u>BlocksSection</u> object, every drawing has only one  blocks
       section referenced by attribute <b>Drawing.blocks</b>.

          import ezdxf
          import random  # needed for random placing points

          def get_random_point():
              """Returns random x, y coordinates."""
              x = random.randint(-100, 100)
              y = random.randint(-100, 100)
              return x, y

          # Create a new drawing in the DXF format of AutoCAD 2010
          doc = ezdxf.new('R2010')

          # Create a block with the name 'FLAG'
          flag = doc.blocks.new(name='FLAG')

          # Add DXF entities to the block 'FLAG'.
          # The default base point (= insertion point) of the block is (0, 0).
          flag.add_lwpolyline([(0, 0), (0, 5), (4, 3), (0, 3)])  # the flag symbol as 2D polyline
          flag.add_circle((0, 0), .4, dxfattribs={'color': 2})  # mark the base point with a circle

   <b>Block</b> <b>References</b> <b>(Insert)</b>
       A block reference can be created by adding an <u>Insert</u> entity to any of these layout types:

          • <u>Modelspace</u>

          • <u>Paperspace</u>

          • <u>BlockLayout</u>

       A block reference can be scaled and rotated individually.  Lets add some random flags to the modelspace:

          # Get the modelspace of the drawing.
          msp = doc.modelspace()

          # Get 50 random placing points.
          placing_points = [get_random_point() for _ in <a href="../man50/range.50.html">range</a>(50)]

          for point in placing_points:
              # Every flag has a different scaling and a rotation of -15 deg.
              random_scale = 0.5 + random.random() * 2.0
              # Add a block reference to the block named 'FLAG' at the coordinates 'point'.
              msp.add_blockref('FLAG', point, dxfattribs={
                  'xscale': random_scale,
                  'yscale': random_scale,
                  'rotation': -15
              })

          # Save the drawing.
          doc.saveas("blockref_tutorial.dxf")

       Query all block references of block <b>FLAG</b>:

          for flag_ref in msp.query('INSERT[name=="FLAG"]'):
              print(str(flag_ref))

       When  adding  a  block reference to a layout with different units, the scaling factor between these units
       should be applied as scaling attributes (<b>xscale</b>, …) e.g. modelspace in meters and block  in  centimeters,
       <b>xscale</b> has to be 0.01.

   <b>Block</b> <b>Attributes</b>
       A  block  attribute  (<u>Attrib</u>)  is a text annotation attached to a block reference with an associated tag.
       Attributes are often used to add information to blocks  which  can  be  evaluated  and  exported  by  CAD
       applications.   An  attribute  can  be  added to a block reference by the <b>Insert.add_attrib()</b> method, the
       ATTRIB entity is geometrically not related to the block  reference,  so  insertion  point,  rotation  and
       scaling of the attribute have to be calculated by the user, but helper tools for that do exist.

   <b>Using</b> <b>Attribute</b> <b>Definitions</b>
       Another way to add attributes to block references is using attribute templates (<u>AttDef</u>). First create the
       attribute  definition  in the block definition, then add the block reference by <b>add_blockref()</b> and attach
       and fill attributes automatically by the <u>add_auto_attribs()</u> method to the block  reference.  This  method
       has  the advantage that all attributes are placed relative to the block base point with the same rotation
       and scaling as the block reference, but non-uniform scaling is not handled very well.

       The <u>add_auto_blockref()</u> method handles non-uniform scaling better by wrapping the block reference and its
       attributes into an anonymous block and let the CAD application do the transformation work.   This  method
       has the disadvantage of a more complex evaluation of attached attributes

       Using attribute definitions (<u>AttDef</u> templates):

          # Define some attributes for the block 'FLAG', placed relative
          # to the base point, (0, 0) in this case.
          flag.add_attdef('NAME', (0.5, -0.5), dxfattribs={'height': 0.5, 'color': 3})
          flag.add_attdef('XPOS', (0.5, -1.0), dxfattribs={'height': 0.25, 'color': 4})
          flag.add_attdef('YPOS', (0.5, -1.5), dxfattribs={'height': 0.25, 'color': 4})

          # Get another 50 random placing points.
          placing_points = [get_random_point() for _ in <a href="../man50/range.50.html">range</a>(50)]

          for number, point in enumerate(placing_points):
              # values is a dict with the attribute tag as item-key and
              # the attribute text content as item-value.
              values = {
                  'NAME': "P(%d)" % (number + 1),
                  'XPOS': "x = %.3f" % point[0],
                  'YPOS': "y = %.3f" % point[1]
              }

              # Every flag has a different scaling and a rotation of +15 deg.
              random_scale = 0.5 + random.random() * 2.0
              blockref = msp.add_blockref('FLAG', point, dxfattribs={
                  'rotation': 15
              }).set_scale(random_scale)
              blockref.add_auto_attribs(values)

          # Save the drawing.
          doc.saveas("auto_blockref_tutorial.dxf")

   <b>Get/Set</b> <b>Attributes</b> <b>of</b> <b>Existing</b> <b>Block</b> <b>References</b>
       See the howto: <u>Get/Set</u> <u>Block</u> <u>Reference</u> <u>Attributes</u>

   <b>Evaluate</b> <b>Wrapped</b> <b>Block</b> <b>References</b>
       As mentioned above the evaluation of block references wrapped into anonymous blocks is complex:

          # Collect all anonymous block references starting with '*U'
          anonymous_block_refs = modelspace.query('INSERT[name ? "^\*U.+"]')

          # Collect the references of the 'FLAG' block
          flag_refs = []
          for block_ref in anonymous_block_refs:
              # Get the block layout of the anonymous block
              block = doc.blocks.get(block_ref.dxf.name)
              # Find all block references to 'FLAG' in the anonymous block
              flag_refs.extend(block.query('INSERT[name=="FLAG"]'))

          # Evaluation example: collect all flag names.
          flag_numbers = [
              flag.get_attrib_text("NAME")
              for flag in flag_refs
              if flag.has_attrib("NAME")
          ]

          print(flag_numbers)

   <b>Exploding</b> <b>Block</b> <b>References</b>
       This  is an advanced feature and the results may not be perfect.  A <b>non-uniform</b> <b>scaling</b> lead to incorrect
       results for text entities (TEXT, MTEXT, ATTRIB) and some other entities  like  HATCH  with  circular-  or
       elliptic  path  segments.  The “exploded” entities are added to the same layout as the block reference by
       default.

          for flag_ref in msp.query('INSERT[name=="FLAG"]'):
              flag_ref.explode()

   <b>Examine</b> <b>Entities</b> <b>of</b> <b>Block</b> <b>References</b>
       To just examine the content entities of a  block  reference  use  the  <u>virtual_entities()</u>  method.   This
       methods  yields  “virtual”  entities  with  properties  identical to “exploded” entities but they are not
       stored in the entity database, have no handle and are not assigned to any layout.

          for flag_ref in msp.query('INSERT[name=="FLAG"]'):
              for entity in flag_ref.virtual_entities():
                  if entity.dxftype() == "LWPOLYLINE":
                      print(f"Found {str(entity)}.")

   <b>Tutorial</b> <b>for</b> <b>LWPolyline</b>
       The <u>LWPolyline</u> (lightweight polyline) was introduced in DXF R13/14 and it is defined as a single  graphic
       entity, which differs from the old-style <u>Polyline</u> entity, which is defined as a group of sub-entities. It
       is  recommended  to  prefer  the LWPOLYLINE over the 2D POLYLINE entity because it requires less space in
       memory and in DXF files and displays faster in AutoCAD.

       <b>IMPORTANT:</b>
          The LWPOLYLINE is a planar element, therefore the (x, y) point coordinates are located in the <u>OCS</u>  and
          the  z-axis  is  stored in the <b>LWPolyline.dxf.elevation</b> attribute.  The method <u>vertices_in_wcs</u> returns
          the polyline vertices as WCS coordinates.

       Create a simple polyline:

          import ezdxf

          doc = ezdxf.new("R2000")
          msp = doc.modelspace()

          points = [(0, 0), (3, 0), (6, 3), (6, 6)]
          msp.add_lwpolyline(points)

          doc.saveas("lwpolyline1.dxf")

       Append multiple points to a polyline:

          doc = ezdxf.readfile("lwpolyline1.dxf")
          msp = doc.modelspace()

          line = msp.query("LWPOLYLINE").first
          if line is not None:
              line.append_points([(8, 7), (10, 7)])

          doc.saveas("lwpolyline2.dxf")

       The index operator <b>[]</b> always returns polyline points as 5-tuple (x, y,  start_width,  end_width,  bulge),
       the start_width, end_width and bulge values are 0 if not present:

          first_point = line[0]
          x, y, start_width, end_width, bulge = first_point

       The  context  manager  <u>points()</u>  can  be used to edit polyline points, this method was introduced because
       accessing individual points was very slow in early versions of <u>ezdxf</u>, in current versions  of  <u>ezdxf</u>  the
       direct  access  by  the  index  operator  <b>[]</b>  is  very fast and using the context manager is not required
       anymore, but the context manager still exist and has the advantage of supporting an  user  defined  point
       format:

          doc = ezdxf.readfile("lwpolyline2.dxf")
          msp = doc.modelspace()

          line = msp.query("LWPOLYLINE").first

          with line.points("xyseb") as points:
              # points is a standard Python list
              # existing points are 5-tuples, but new points can be
              # set as (x, y, [start_width, [end_width, [bulge]]]) tuple
              # set start_width, end_width to 0 to be ignored (x, y, 0, 0, bulge).

              # delete last 2 points
              del points[-2:]
              # adding two points
              points.extend([(4, 7), (0, 7)])

          doc.saveas("lwpolyline3.dxf")

       Each line segment can have a different start- and end width, if omitted start- and end width is 0:

          doc = ezdxf.new("R2000")
          msp = doc.modelspace()

          # point format = (x, y, [start_width, [end_width, [bulge]]])
          # set start_width, end_width to 0 to be ignored (x, y, 0, 0, bulge).

          points = [(0, 0, .1, .15), (3, 0, .2, .25), (6, 3, .3, .35), (6, 6)]
          msp.add_lwpolyline(points)

          doc.saveas("lwpolyline4.dxf")

       The  first  point  carries  the start- and end-width of the first segment, the second point of the second
       segment and so on, the start- and end width value of the last point is used for the  closing  segment  if
       the  polyline  is  closed  else  these  values  are  ignored.  Start- and end width only works if the DXF
       attribute <b>dxf.const_width</b> is unset, delete it to be sure it’s unset:

          # no exception will be raised if const_width is already unset:
          del line.dxf.const_width

       <b>LWPolyline</b> can also have curved elements, they are defined by the <u>Bulge</u> <u>value</u>:

          doc = ezdxf.new("R2000")
          msp = doc.modelspace()

          # point format = (x, y, [start_width, [end_width, [bulge]]])
          # set start_width, end_width to 0 to be ignored (x, y, 0, 0, bulge).

          points = [(0, 0, 0, .05), (3, 0, .1, .2, -.5), (6, 0, .1, .05), (9, 0)]
          msp.add_lwpolyline(points)

          doc.saveas("lwpolyline5.dxf")
       [image]

       The curved segment is drawn from the point which defines the <u>bulge</u> value  to  the  following  point,  the
       curved  segment is always an arc. The bulge value defines the ratio of the arc sagitta (segment height <u>h</u>)
       to half line segment length (point distance), a bulge value of 1 defines a semicircle.  The curve  is  on
       the right side of the line for a bulge value &gt; 0, and on the left side of the line for a bulge value &lt; 0.

       Helper functions to handle bulge values: <u>Bulge</u> <u>Related</u> <u>Functions</u>

       The user defined point format, default is <b>xyseb</b>:

          • <b>x</b> = x coordinate

          • <b>y</b> = y coordinate

          • <b>s</b> = start width

          • <b>e</b> = end width

          • <b>b</b> = bulge value

          • <b>v</b> = (x, y) as tuple

          msp.add_lwpolyline([(0, 0, 0), (10, 0, 1), (20, 0, 0)], format="xyb")
          msp.add_lwpolyline([(0, 10, 0), (10, 10, .5), (20, 10, 0)], format="xyb")
       [image]

   <b>Tutorial</b> <b>for</b> <b>Text</b>
       Add a simple one line text entity by factory function <u>add_text()</u>.

          import ezdxf
          from ezdxf.enums import TextEntityAlignment

          # The TEXT entity is a DXF primitive and is supported in all DXF versions.
          # The argument setup=True creates standard linetypes and text styles in the
          # new DXF document.
          doc = ezdxf.new("R12", setup=True)
          msp = doc.modelspace()

          # Use method set_placement() to define the TEXT alignment, because the
          # relations between the DXF attributes 'halign', 'valign', 'insert' and
          # 'align_point' are tricky.
          msp.add_text("A Simple Text").set_placement(
              (2, 3),
              align=TextEntityAlignment.MIDDLE_RIGHT
          )

          # Using a predefined text style:
          msp.add_text(
              "Text Style Example: Liberation Serif",
              height=0.35,
              dxfattribs={"style": "LiberationSerif"}
          ).set_placement((2, 6), align=TextEntityAlignment.LEFT)

          doc.saveas("simple_text.dxf")

       Alignments defined by the enum <u>TextEntityAlignment</u>:
                             ┌────────────┬─────────────┬───────────────┬──────────────┐
                             │ Vert/Horiz │ Left        │ Center        │ Right        │
                             ├────────────┼─────────────┼───────────────┼──────────────┤
                             │ Top        │ <b>TOP_LEFT</b>    │ <b>TOP_CENTER</b>    │ <b>TOP_RIGHT</b>    │
                             ├────────────┼─────────────┼───────────────┼──────────────┤
                             │ Middle     │ <b>MIDDLE_LEFT</b> │ <b>MIDDLE_CENTER</b> │ <b>MIDDLE_RIGHT</b> │
                             ├────────────┼─────────────┼───────────────┼──────────────┤
                             │ Bottom     │ <b>BOTTOM_LEFT</b> │ <b>BOTTOM_CENTER</b> │ <b>BOTTOM_RIGHT</b> │
                             ├────────────┼─────────────┼───────────────┼──────────────┤
                             │ Baseline   │ <b>LEFT</b>        │ <b>CENTER</b>        │ <b>RIGHT</b>        │
                             └────────────┴─────────────┴───────────────┴──────────────┘

       Special alignments are <b>ALIGNED</b> and <b>FIT</b>, they require a second alignment point, the text is justified with
       the vertical alignment <u>Baseline</u> on the virtual line between these two points.
                                ┌───────────┬───────────────────────────────────────┐
                                │ Alignment │ Description                           │
                                ├───────────┼───────────────────────────────────────┤
                                │ <b>ALIGNED</b>   │ Text  is  stretched  or compressed to │
                                │           │ fit exactly between <u>p1</u> and <u>p2</u> and the │
                                │           │ text  height  is  also  adjusted   to │
                                │           │ preserve height/width ratio.          │
                                ├───────────┼───────────────────────────────────────┤
                                │ <b>FIT</b>       │ Text  is  stretched  or compressed to │
                                │           │ fit exactly between  <u>p1</u>  and  <u>p2</u>  but │
                                │           │ only  the text width is adjusted, the │
                                │           │ text height is fixed  by  the  <u>height</u> │
                                │           │ attribute.                            │
                                ├───────────┼───────────────────────────────────────┤
                                │ <b>MIDDLE</b>    │ also  a  <u>special</u>  adjustment, but the │
                                │           │ result   is   the   same    as    for │
                                │           │ <b>MIDDLE_CENTER</b>.                        │
                                └───────────┴───────────────────────────────────────┘

   <b>Standard</b> <b>Text</b> <b>Styles</b>
       Setup some standard text styles and linetypes by argument <b>setup=True</b>:

          doc = ezdxf.new('R12', setup=True)

       Replaced all proprietary font declarations in <b>setup_styles()</b> (ARIAL, ARIAL_NARROW, ISOCPEUR and TIMES) by
       open source fonts, this is also the style name (e.g. <b>{'style':</b> <b>'OpenSans-Italic'}</b>): [image]

       <b>IMPORTANT:</b>
          To see the defined text styles in a DXF viewer or CAD application, the applications have to know where
          the referenced TTF fonts can be found.  This configuration is not possible by <u>ezdxf</u> and has to be done
          for each application as described in their documentation.

          See also: <u>Font</u> <u>Resources</u>

   <b>New</b> <b>Text</b> <b>Style</b>
       Creating a new text style is simple:

          doc.styles.new("myStandard", dxfattribs={"font" : "OpenSans-Regular.ttf"})

       Getting  the  correct font name is often not that simple, especially on Windows.  This shows the required
       steps to get the font name for <u>Open</u> <u>Sans</u>:

          • open font folder <u>c:\windows\fonts</u>

          • select and open the font-family <u>Open</u> <u>Sans</u>

          • right-click on <u>Open</u> <u>Sans</u> <u>Standard</u> and select <u>Properties</u>

          • on top of the first tab you see the font name: <b>'OpenSans-Regular.ttf'</b>

       The style name has to be unique in the DXF document, otherwise <u>ezdxf</u>  will  raise  an  <b>DXFTableEntryError</b>
       exception.  To  replace  an existing entry, delete the existing entry by <b>doc.styles.remove(name)</b>, and add
       the replacement entry.

   <b>3D</b> <b>Text</b>
       It is possible to place the 2D <u>Text</u> entity into 3D space by using the <u>OCS</u>, for further  information  see:
       <u>Tutorial</u> <u>for</u> <u>OCS/UCS</u> <u>Usage</u> and <u>Tutorial</u> <u>for</u> <u>UCS</u> <u>Based</u> <u>Transformations</u>.

   <b>Tutorial</b> <b>for</b> <b>MText</b> <b>and</b> <b>MTextEditor</b>
       The  <u>MText</u> entity is a multi line entity with extended formatting possibilities and requires at least DXF
       version R2000, to use all features (e.g. background fill) DXF R2007 is required.

       <b>IMPORTANT:</b>
          The rendering result of the MTEXT entity depends on the DXF viewer or CAD application and  can  differ
          between different applications. These differences have the greatest impact on line wrapping, which can
          cause columns of text to have different heights in different applications!

          In  order  for  the  text to look similar in different programs, the formatting should be as simple as
          possible or omitted altogether.

       Prolog code:

          import ezdxf

          doc = ezdxf.new("R2007", setup=True)
          msp = doc.modelspace()

          lorem_ipsum = """
          Lorem ipsum dolor sit amet, consectetur adipiscing elit,
          sed do eiusmod tempor incididunt ut labore et dolore magna
          aliqua. Ut enim ad minim veniam, quis nostrud exercitation
          ullamco laboris nisi ut aliquip ex ea commodo consequat.
          Duis aute irure dolor in reprehenderit in voluptate velit
          esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
          occaecat cupidatat non proident, sunt in culpa qui officia
          deserunt mollit anim id est laborum.
          """

   <b>Adding</b> <b>a</b> <b>MTEXT</b> <b>entity</b>
       The MTEXT entity can be added to  any  layout  (modelspace,  paperspace  or  block)  by  the  <u>add_mtext()</u>
       function.

          # store MTEXT entity for additional manipulations
          mtext = msp.add_mtext(lorem_ipsum, dxfattribs={"style": "OpenSans"})

       This  adds  a  MTEXT  entity  with  text style “OpenSans”.  The MTEXT content can be accessed by the <b>text</b>
       attribute, this attribute can be edited like any Python string:

          mtext.text += "Append additional text to the MTEXT entity."
          # even shorter with __iadd__() support:
          mtext += "Append additional text to the MTEXT entity."
       [image]

       The <b>MText</b> entity has an alias <b>MText.dxf.text</b> for the <b>MText.text</b> attribute for compatibility to  the  <b>Text</b>
       entity.

       <b>IMPORTANT:</b>
          Line  endings  “\n”  will be replaced by the MTEXT line endings “\P” at DXF export, but <b>not</b> vice versa
          “\P” by “\n” at DXF file loading.

   <b>Text</b> <b>placement</b>
       The location of the MTEXT entity is defined by the <b>MText.dxf.insert</b>  and  the  <b>MText.dxf.attachment_point</b>
       attributes  in  <u>WCS</u>  coordinates.  The <b>attachment_point</b> defines the text alignment relative to the <b>insert</b>
       location, default value is 1.

       Attachment point constants defined in <u>ezdxf.lldxf.const</u>:
                                        ┌────────────────────────────┬───────┐
                                        │ MText.dxf.attachment_point │ Value │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_TOP_LEFT             │ 1     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_TOP_CENTER           │ 2     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_TOP_RIGHT            │ 3     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_MIDDLE_LEFT          │ 4     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_MIDDLE_CENTER        │ 5     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_MIDDLE_RIGHT         │ 6     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_BOTTOM_LEFT          │ 7     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_BOTTOM_CENTER        │ 8     │
                                        ├────────────────────────────┼───────┤
                                        │ MTEXT_BOTTOM_RIGHT         │ 9     │
                                        └────────────────────────────┴───────┘

       The MTEXT entity has a method for setting <b>insert</b>, <b>attachment_point</b> and <b>rotation</b> attributes by  one  call:
       <u>set_location()</u>

   <b>Character</b> <b>height</b>
       The  character  height  is defined by the DXF attribute <b>MText.dxf.char_height</b> in drawing units, which has
       also consequences for the line spacing of the MTEXT entity:

          mtext.dxf.char_height = 0.5

       The character height can be changed inline, see also <u>MTEXT</u> <u>formatting</u> and <u>MText</u> <u>Inline</u> <u>Codes</u>.

   <b>Text</b> <b>rotation</b> <b>(direction)</b>
       The <b>MText.dxf.rotation</b> attribute defines the text rotation as angle between the x-axis and the horizontal
       direction of the  text  in  degrees.   The  <b>MText.dxf.text_direction</b>  attribute  defines  the  horizontal
       direction of MTEXT as vector in WCS.  Both attributes can be present at the same entity, in this case the
       <b>MText.dxf.text_direction</b> attribute has the higher priority.

       The  MTEXT  entity  has  two  methods  to  get/set rotation: <u>get_rotation()</u> returns the rotation angle in
       degrees independent from definition as angle or direction, and <u>set_rotation()</u> set the <b>rotation</b>  attribute
       and removes the <b>text_direction</b> attribute if present.

   <b>Defining</b> <b>a</b> <b>wrapping</b> <b>border</b>
       The  wrapping  border  limits the text width and forces a line break for text beyond this border. Without
       attribute <b>dxf.width</b> (or setting 0) the lines are wrapped only at the regular line endings “ \P” or  “\n”,
       setting  the reference column width forces additional line wrappings at the given width.  The text height
       can not be limited, the text always occupies as much space as needed.

          mtext.dxf.width = 60
       [image]

   <b>MTEXT</b> <b>formatting</b>
       MTEXT supports inline formatting by special codes: <u>MText</u> <u>Inline</u> <u>Codes</u>

          mtext.text = "{\\C1;red text} - {\\C3;green text} - {\\C5;blue text}"
       [image]

       See also the support class <u>MTextEditor</u>.

   <b>Stacked</b> <b>text</b>
       MTEXT supports stacked text:

          # the space ' ' in front of 'Lower' and the ';' behind 'Lower' are necessary
          # combined with vertical center alignment
          mtext.text = "\\A1;\\SUpper^ Lower; - \\SUpper/ Lower;} - \\SUpper# Lower;"
       [image]

       See also the support class <u>MTextEditor</u>.

   <b>Background</b> <b>color</b> <b>(filling)</b>
       The MTEXT entity can have a background filling:

       • <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>

       • true color value as <b>(r,</b> <b>g,</b> <b>b)</b> tuple

       • color name as string, use special name <b>'canvas'</b> to use the canvas background color

       Because of the complex dependencies <u>ezdxf</u> provides a method to set all required DXF attributes at once:

          mtext.set_bg_color(2, scale=1.5)

       The parameter <u>scale</u> determines how much border there is around the text, the value is based on  the  text
       height, and should be in the range of 1 - 5, where 1 fits exact the MTEXT entity.  [image]

   <b>MTextEditor</b>
       <b>WARNING:</b>
          The  <b>MTextEditor</b> assembles just the inline code, which has to be parsed and rendered by the target CAD
          application, <u>ezdxf</u> has no influence to that result.

          Keep inline formatting as simple as possible, don’t test the limits of its capabilities, this will not
          work across different CAD applications and keep the formatting in a logic manner like, do  not  change
          paragraph properties in the middle of a paragraph.

          <b>There</b> <b>is</b> <b>no</b> <b>official</b> <b>documentation</b> <b>for</b> <b>the</b> <b>inline</b> <b>codes!</b>

       The <u>MTextEditor</u> class provides a floating interface to build <b>MText</b> content in an easy way.

       This  example  only  shows  the  connection  between  <b>MText</b>  and the <b>MTextEditor</b>, and shows no additional
       features to the first example of this tutorial:

   <b>Init</b> <b>Editor</b>
          import ezdxf
          from ezdxf.tools.text import MTextEditor

          doc = ezdxf.new("R2007", setup=True)
          msp = doc.modelspace()

          lorem_ipsum = """
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, ... see prolog code
          """

          # create a new editor object with an initial text:
          editor = MTextEditor(lorem_ipsum)

          # get the MTEXT content string from the editor by the str() function:
          mtext = msp.add_mtext(str(editor), dxfattribs={"style": "OpenSans"})

       Tutorial Prolog:

          # use constants defined in MTextEditor:
          NP = MTextEditor.NEW_PARAGRAPH

          ATTRIBS = {
              "char_height": 0.7,
              "style": "OpenSans",
              "width": 10,
          }
          editor = MTextEditor("using colors:" + NP)

   <b>Set</b> <b>Text</b> <b>Color</b>
       There are three ways to change the color inline:

       • by color name “red”, “green”, “blue”, “yellow”, “cyan”, “magenta”, “white”

       • by <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>

       • by RGB values

          # RED: set color by name - red, green, blue, yellow, cyan, magenta, white
          editor.color("red").append("RED" + NP)
          # RED: the color stays the same until the next change
          editor.append("also RED" + NP)

          # GREEN: change color by ACI (AutoCAD Color Index)
          <a href="../man3/editor.aci.3.html">editor.aci</a>(3).append("GREEN" + NP)

          # BLUE: change color by RGB tuples
          editor.rgb((0, 0, 255)).append("BLUE" + NP)

          # add the MTEXT entity to the model space:
          msp.add_mtext(str(editor), attribs)
       [image]

   <b>Changing</b> <b>Text</b> <b>Height</b>
       The <b>MtextEditor.height()</b> method set the text height as absolute value in drawing units (text height = cap
       height):

          attribs = dict(ATTRIBS)
          attribs["width"] = 40.0
          editor = MTextEditor("changing text height absolute: default height is 0.7" + NP)
          # doubling the default height = 1.4
          editor.height(1.4)
          editor.append("text height: 1.4" + NP)
          editor.height(3.5).append("text height: 3.5" + NP)
          editor.height(0.7).append("back to default height: 0.7" + NP)
          msp.add_mtext(str(editor), attribs)
       [image]

       The <b>MtextEditor.scale_height()</b> method set the text height by a relative factor,  the  <b>MtextEditor</b>  object
       does  not  keep track of current text height, you have to do this by yourself. The initial text height is
       <b>MText.dxf.char_height</b>:

          attribs = dict(ATTRIBS)
          attribs["width"] = 40.0
          editor = MTextEditor("changing text height relative: default height is 0.7" + NP)
          # this is the default text height in the beginning:
          current_height = attribs["char_height"]
          # The text height can only be changed by a factor:
          <a href="../man2/editor.scale_height.2.html">editor.scale_height</a>(2)  # scale by 2 = 1.4
          # keep track of the actual height:
          current_height *= 2
          editor.append("text height: 1.4" + NP)
          # to set an absolute height, calculate the required factor:
          desired_height = 3.5
          factor = desired_height / current_height
          editor.scale_height(factor).append("text height: 3.5" + NP)
          current_height = desired_height
          # and back to 0.7
          editor.scale_height(0.7 / current_height).append("back to default height: 0.7" + NP)
          msp.add_mtext(str(editor), attribs).set_location(insert=location)

   <b>Changing</b> <b>Font</b>
       The font name for changing <b>MText</b> fonts inline is the font family name!  The font family name is the  name
       shown  in  font  selection  widgets in desktop applications: “Arial”, “Times New Roman”, “Comic Sans MS”.
       The font has to be installed at the  target  system,  else  then  CAD  default  font  will  be  used,  in
       AutoCAD/BricsCAD is this the font defined for the text style “Standard”.

       <b>IMPORTANT:</b>
          The  DXF/DWG  format  is  not  optimal  for  preserving text layouts across multiple systems, and it’s
          getting really bad across different CAD applications.

          attribs = dict(ATTRIBS)
          attribs["width"] = 15.0
          editor = MTextEditor("changing fonts:" + NP)
          editor.append("Default: Hello World!" + NP)
          editor.append("SimSun: ")
          # change font in a group to revert back to the default font at the end:
          simsun_editor = MTextEditor().font("SimSun").append("你好，世界" + NP)
          # reverts the font back at the end of the group:
          editor.group(str(simsun_editor))
          # back to default font OpenSans:
          editor.append("Times New Roman: ")
          # change font outside of a group until next font change:
          editor.font("Times New Roman").append("Привет мир!" + NP)
          # If the font does not exist, a replacement font will be used:
          editor.font("Does not exist").append("This is the replacement font!")
          msp.add_mtext(str(editor), attribs)
       [image]

   <b>Set</b> <b>Paragraph</b> <b>Properties</b>
       The paragraph properties are set by the  <u>paragraph()</u>  method  and  a  <u>ParagraphProperties</u>  object,  which
       bundles all paragraph properties in a named tuple.

       Each paragraph can have its own properties for:

       • indentation arguments:

            • <b>indent</b> is the left indentation of the first line

            • <b>left</b>  is the left side indentation of the paragraph

            • <b>right</b> is the right side indentation of the paragraph

       • text adjustment: <b>align</b>, by enum <b>MTextParagraphAlignment</b>

            • MTextParagraphAlignment.LEFT

            • MTextParagraphAlignment.RIGHT

            • MTextParagraphAlignment.CENTER

            • MTextParagraphAlignment.JUSTIFIED

            • MTextParagraphAlignment.DISTRIBUTED

       • tabulator stops: <b>tab_stops</b>, a tuple of tabulator stops

       Indentation   and   tabulator   stops   are  multiples  of  the  default  <b>MText</b>  text  height  stored  in
       <b>MText.dxf.char_height</b>. Calculate the drawing units for indentation and tabulator  stops,  by  multiplying
       the indentation value by the <b>char_height</b> value.

       <b>Mtext</b> paragraphs are separated by new paragraph “\P” characters.

          # import support classes:
          from ezdxf.tools.text import ParagraphProperties, MTextParagraphAlignment

          attribs = dict(ATTRIBS)
          attribs["char_height"] = 0.25
          attribs["width"] = 7.5
          editor = MTextEditor("Indent the first line:" + NP)
          props = ParagraphProperties(
              indent=1,  # indent first line = 1x0.25 drawing units
              align=MTextParagraphAlignment.JUSTIFIED
          )
          editor.paragraph(props)
          editor.append(lorem_ipsum)
          msp.add_mtext(str(editor), attribs)
       [image]

       The first line indentation “indent” is relative to the “left” indentation.

          # import support classes:
          from ezdxf.tools.text import ParagraphProperties, MTextParagraphAlignment

          attribs = dict(ATTRIBS)
          attribs["char_height"] = 0.25
          attribs["width"] = 7.5
          editor = MTextEditor("Indent left paragraph side:" + NP)
          indent = 0.7  # 0.7 * 0.25 = 0.175 drawing units
          props = ParagraphProperties(
              # first line indentation is relative to "left", this reverses the
              # left indentation:
              indent=-indent,  # first line
              # indent left paragraph side:
              left=indent,
              align=MTextParagraphAlignment.JUSTIFIED
          )
          editor.paragraph(props)
          editor.append(" ".join(<a href="../man100/lorem_ipsum.100.html">lorem_ipsum</a>(100)))
          msp.add_mtext(str(editor), attribs).set_location(insert=location)
       [image]

   <b>Bullet</b> <b>List</b>
       There  are  no  special  commands  to build bullet list, the list is build of indentation and a tabulator
       stop. Each list item needs a marker  as  an  arbitrary  string.  For  more  information  about  paragraph
       indentation and tabulator stops see also chapter <u>Set</u> <u>Paragraph</u> <u>Properties</u>.

          attribs = dict(ATTRIBS)
          attribs["char_height"] = 0.25
          attribs["width"] = 7.5
          bullet = "•"  # alt + numpad 7
          editor = MTextEditor("Bullet List:" + NP)
          editor.bullet_list(
              indent=1,
              bullets=[bullet] * 3,  # each list item needs a marker
              content=[
                  "First item",
                  "Second item",
                  " ".join(<a href="../man30/lorem_ipsum.30.html">lorem_ipsum</a>(30)),
              ])
          msp.add_mtext(str(editor), attribs)
       [image]

   <b>Numbered</b> <b>List</b>
       There  are  no  special commands to build numbered list, the list is build of indentation and a tabulator
       stop. There is no automatic numbering, but therefore the absolute freedom for using any  string  as  list
       marker.   For  more  information  about  paragraph  indentation  and tabulator stops see also chapter <u>Set</u>
       <u>Paragraph</u> <u>Properties</u>.

          attribs = dict(ATTRIBS)
          attribs["char_height"] = 0.25
          attribs["width"] = 7.5
          editor = MTextEditor("Numbered List:" + NP)
          editor.bullet_list(
              indent=1,
              bullets=["1.", "2.", "3."],
              content=[
                  "First item",
                  "Second item",
                  " ".join(<a href="../man30/lorem_ipsum.30.html">lorem_ipsum</a>(30)),
              ])
          msp.add_mtext(str(editor), attribs)
       [image]

   <b>Stacked</b> <b>Text</b>
       <b>MText</b> supports stacked text (fractions) as a single inline code, which means it is not possible to change
       any property inside the fraction.  This example shows a fraction with scaled down text height, placed  in
       a group to revert the text height afterwards:

          editor = MTextEditor("Stacked text:" + NP)

          stack = MTextEditor().scale_height(0.6).stack("1", "2", "^")
          editor.append("over: ").group(str(stack)).append(NP)

          stack = MTextEditor().scale_height(0.6).stack("1", "2", "/")
          editor.append("fraction: ").group(str(stack)).append(NP)

          stack = MTextEditor().scale_height(0.6).stack("1", "2", "#")
          editor.append("slanted: ").group(str(stack)).append(NP)

          # Additional formatting in numerator and denominator is not supported
          # by AutoCAD or BricsCAD, switching the color inside the stacked text
          # to red does not work:
          numerator = MTextEditor().color("red").append("1")
          stack = MTextEditor().scale_height(0.6).stack(str(numerator), "2", "#")
          editor.append("color red: ").group(str(stack)).append(NP)

          msp.add_mtext(str(editor), attribs)
       [image]

       <b>SEE</b> <b>ALSO:</b>

          • <u>MTextEditor</u> example code on <u>github</u>.

          • Documentation of <u>MTextEditor</u>

   <b>Tutorial</b> <b>for</b> <b>Spline</b>
       Background information about <u>B-spline</u> at Wikipedia.

   <b>Splines</b> <b>from</b> <b>fit</b> <b>points</b>
       Splines can be defined by fit points only, this means the curve passes all given fit points.  AutoCAD and
       BricsCAD generates required control points and knot values by itself, if only fit points are present.

       Create a simple spline:

          doc = ezdxf.new("R2000")

          fit_points = [(0, 0, 0), (750, 500, 0), (1750, 500, 0), (2250, 1250, 0)]
          msp = doc.modelspace()
          spline = msp.add_spline(fit_points)
       [image]

       Append a fit point to a spline:

          # fit_points, control_points, knots and weights are list-like containers:
          spline.fit_points.append((2250, 2500, 0))
       [image]

       You  can  set  additional  <u>control</u> <u>points</u>, but if they do not fit the auto-generated AutoCAD values, they
       will be ignored and don’t mess around with <u>knot</u> values.

          doc = ezdxf.readfile("AutoCAD_generated.dxf")

          msp = doc.modelspace()
          spline = msp.query("SPLINE").first

          # fit_points, control_points, knots and weights are list-like objects:
          spline.fit_points.append((2250, 2500, 0))

       As far as I have tested, this approach works without  complaints  from  AutoCAD,  but  for  the  case  of
       problems remove invalid data from the SPLINE entity:

          # current control points do not match spline defined by fit points
          spline.control_points = []

          # count of knots is not correct:
          # count of knots = count of control points + degree + 1
          spline.knots = []

          # same for weights, count of weights == count of control points
          spline.weights = []

   <b>Splines</b> <b>by</b> <b>control</b> <b>points</b>
       Creating  splines from fit points is the easiest way, but this method is also the least accurate, because
       a spline is defined by control points and knot values, which are generated for the case of  a  definition
       by  fit  points, and the worst fact is that for every given set of fit points exist an infinite number of
       possible splines as solution.

       AutoCAD (and BricsCAD) uses an unknown proprietary algorithm to generate control points and  knot  values
       from  fit points.  Therefore splines generated from fit points by <u>ezdxf</u> do not match splines generated by
       AutoCAD (BricsCAD).

       To ensure the same spline geometry for all CAD applications, the spline has  to  be  defined  by  control
       points.   The method <u>add_spline_control_frame()</u> adds a spline passing the given fit points by calculating
       the control points by the <u>Global</u> <u>Curve</u> <u>Interpolation</u> algorithm.  There  is  also  a  low  level  function
       <u>ezdxf.math.global_bspline_interpolation()</u> which calculates the control points from fit points.

          msp.add_spline_control_frame(fit_points, method='uniform', dxfattribs={'color': 1})
          msp.add_spline_control_frame(fit_points, method='chord', dxfattribs={'color': 3})
          msp.add_spline_control_frame(fit_points, method='centripetal', dxfattribs={'color': 5})

       • black curve: AutoCAD/BricsCAD spline generated from fit points

       • red curve: spline curve interpolation, “uniform” method

       • green curve: spline curve interpolation, “chord” method

       • blue curve: spline curve interpolation, “centripetal” method
       [image]

   <b>Open</b> <b>Spline</b>
       Add  and  open  (clamped)  spline defined by control points with the method <u>add_open_spline()</u>. If no <u>knot</u>
       values are given, an open uniform knot vector will be generated. A clamped B-spline starts at  the  first
       control point and ends at the last control point.

          control_points = [(0, 0, 0), (1250, 1560, 0), (3130, 610, 0), (2250, 1250, 0)]
          msp.add_open_spline(control_points)
       [image]

   <b>Rational</b> <b>Spline</b>
       <u>Rational</u>  <u>B-splines</u>  have a weight for every control point, which can raise or lower the influence of the
       control point, default weight = <b>1</b>, to lower the influence set a weight &lt; <b>1</b> to raise the influence  set  a
       weight &gt; <b>1</b>.  The count of weights has to be always equal to the count of control points.

       Example to raise the influence of the first control point:

          msp.add_closed_rational_spline(control_points, weights=[3, 1, 1, 1])
       [image]

   <b>Spline</b> <b>properties</b>
       Check  if  spline is a <u>closed</u> <u>curve</u> or close/open spline, for a closed spline the last point is connected
       to the first point:

          if spline.closed:
              # this spline is closed
              pass

          # close spline
          spline.closed = True

          # open spline
          spline.closed = False

       Set start- and end tangent for splines defined by fit points:

          spline.dxf.start_tangent = (0, 1, 0)
          spline.dxf.end_tangent = (1, 0, 0)

       Get data count as stored in DXF attributes:

          count = spline.dxf.n_fit_points
          count = spline.dxf.n_control_points
          count = spline.dxf.n_knots

       Get data count from existing data:

          count = spline.fit_point_count
          count = spline.control_point_count
          count = spline.knot_count

   <b>Tutorial</b> <b>for</b> <b>Polyface</b>
       The <u>Polyface</u> entity represents a 3D mesh build of vertices and faces and is  just  an  extended  POLYLINE
       entity  with  a  complex VERTEX structure. The <b>Polyface</b> entity was used in DXF R12 and older DXF versions
       and is still supported by newer DXF versions. The  new  <u>Mesh</u>  entity  stores  the  same  data  much  more
       efficient but requires DXF R2000 or newer. The <b>Polyface</b> entity supports only triangles and quadrilaterals
       as faces, the <b>Mesh</b> entity supports also n-gons.

       Its  recommended  to use the <u>MeshBuilder</u> objects to create 3D meshes and render them as POLYFACE entities
       by the <b>render_polymesh()</b> method into a layout:

          import ezdxf
          from ezdxf import colors
          from ezdxf.gfxattribs import GfxAttribs
          from ezdxf.render import forms

          cube = forms.cube().<a href="../man10/scale_uniform.10.html">scale_uniform</a>(10).<a href="../man2/subdivide.2.html">subdivide</a>(2)
          red = GfxAttribs(color=colors.RED)
          green = GfxAttribs(color=colors.GREEN)
          blue = GfxAttribs(color=colors.BLUE)

          doc = ezdxf.new()
          msp = doc.modelspace()

          # render as MESH entity
          cube.render_mesh(msp, dxfattribs=red)
          <a href="../man20/cube.translate.20.html">cube.translate</a>(20)

          # render as POLYFACE a.k.a. POLYLINE entity
          cube.render_polyface(msp, dxfattribs=green)
          <a href="../man20/cube.translate.20.html">cube.translate</a>(20)

          # render as a bunch of 3DFACE entities
          cube.render_3dfaces(msp, dxfattribs=blue)

          doc.saveas("meshes.dxf")
       [image]

       <b>WARNING:</b>
          If the mesh contains n-gons the render methods for POLYFACE and 3DFACES  subdivides  the  n-gons  into
          triangles, which does <b>not</b> work for concave faces.

       The usage of the <u>MeshBuilder</u> object is also recommended for inspecting <b>Polyface</b> entities:

       • <b>MeshBuilder.vertices</b> is a sequence of 3D points as <u>ezdxf.math.Vec3</u> objects

       • a face in <b>MeshBuilder.faces</b> is a sequence of indices into the <b>MeshBuilder.vertices</b> sequence

          import ezdxf
          from ezdxf.render import MeshBuilder

          def <a href="../manmesh/process.mesh.html">process</a>(mesh):
              # vertices is a sequence of 3D points
              vertices = mses.vertices
              # a face is a sequence of indices into the vertices sequence
              faces = mesh.faces
              ...

          doc = ezdxf.readfile("meshes.dxf")
          msp = doc.modelspace()
          for polyline in msp.query("POLYLINE"):
              if polyline.is_poly_face_mesh:
                  mesh = MeshBuilder.from_polyface(polyline)
                  <a href="../manmesh/process.mesh.html">process</a>(mesh)

       <b>SEE</b> <b>ALSO:</b>
          <u>Tutorial</u> <u>for</u> <u>Mesh</u>

   <b>Tutorial</b> <b>for</b> <b>Mesh</b>
       The <u>Mesh</u> entity is a 3D object in <u>WCS</u> build up from vertices and faces.

       Create a cube mesh by directly accessing the base data structures:

          import ezdxf

          # 8 corner vertices
          cube_vertices = [
              (0, 0, 0),
              (1, 0, 0),
              (1, 1, 0),
              (0, 1, 0),
              (0, 0, 1),
              (1, 0, 1),
              (1, 1, 1),
              (0, 1, 1),
          ]

          # 6 cube faces
          cube_faces = [
              [0, 1, 2, 3],
              [4, 5, 6, 7],
              [0, 1, 5, 4],
              [1, 2, 6, 5],
              [3, 2, 6, 7],
              [0, 3, 7, 4]
          ]

          # MESH requires DXF R2000 or later
          doc = ezdxf.new("R2000")
          msp = doc.modelspace()
          mesh = msp.add_mesh()
          # do not subdivide cube, 0 is the default value
          mesh.dxf.subdivision_levels = 0
          with mesh.edit_data() as mesh_data:
              mesh_data.vertices = cube_vertices
              mesh_data.faces = cube_faces

          doc.saveas("cube_mesh_1.dxf")

       Create a cube mesh by assembling single faces using the <u>edit_data()</u> context manager of the <u>Mesh</u> class and
       the helper class <u>MeshData</u>:

          import ezdxf

          # 8 corner vertices
          p = [
              (0, 0, 0),
              (1, 0, 0),
              (1, 1, 0),
              (0, 1, 0),
              (0, 0, 1),
              (1, 0, 1),
              (1, 1, 1),
              (0, 1, 1),
          ]

          # MESH requires DXF R2000 or later
          doc = ezdxf.new("R2000")
          msp = doc.modelspace()
          mesh = msp.add_mesh()

          with mesh.edit_data() as mesh_data:
              mesh_data.add_face([p[0], p[1], p[2], p[3]])
              mesh_data.add_face([p[4], p[5], p[6], p[7]])
              mesh_data.add_face([p[0], p[1], p[5], p[4]])
              mesh_data.add_face([p[1], p[2], p[6], p[5]])
              mesh_data.add_face([p[3], p[2], p[6], p[7]])
              mesh_data.add_face([p[0], p[3], p[7], p[4]])
              # optional call optimize(): minimizes the vertex count
              mesh_data.optimize()

          doc.saveas("cube_mesh_2.dxf")

       Its  recommended  to  use the <u>MeshBuilder</u> objects to create 3D meshes and render them as MESH entities by
       the <u>render_mesh()</u> method into a layout:

          import ezdxf
          from ezdxf import colors
          from ezdxf.gfxattribs import GfxAttribs
          from ezdxf.render import forms

          cube = forms.cube().<a href="../man10/scale_uniform.10.html">scale_uniform</a>(10).<a href="../man2/subdivide.2.html">subdivide</a>(2)
          red = GfxAttribs(color=colors.RED)
          green = GfxAttribs(color=colors.GREEN)
          blue = GfxAttribs(color=colors.BLUE)

          doc = ezdxf.new()
          msp = doc.modelspace()

          # render as MESH entity
          cube.render_mesh(msp, dxfattribs=red)
          <a href="../man20/cube.translate.20.html">cube.translate</a>(20)

          # render as POLYFACE a.k.a. POLYLINE entity
          cube.render_polyface(msp, dxfattribs=green)
          <a href="../man20/cube.translate.20.html">cube.translate</a>(20)

          # render as a bunch of 3DFACE entities
          cube.render_3dfaces(msp, dxfattribs=blue)

          doc.saveas("meshes.dxf")
       [image]

       There exist some tools to manage meshes:

       • <u>ezdxf.render.MeshBuilder</u>: The <u>MeshBuilder</u> classes are helper tools to manage meshes buildup by vertices
         and faces.

       • <u>ezdxf.render.MeshTransformer</u>: Same functionality as <u>MeshBuilder</u> but supports inplace transformation.

       • <u>ezdxf.render.MeshDiagnose</u>: A diagnose  tool  which  can  be  used  to  analyze  and  detect  errors  of
         <u>MeshBuilder</u> objects like topology errors for closed surfaces.

       • <u>ezdxf.render.FaceOrientationDetector</u>:  A  helper  class  for  face  orientation  and face normal vector
         detection

       The <u>ezdxf.render.forms</u> module provides function to create basic geometries like cube, cone, sphere and so
       on and functions to create meshes from profiles by extrusion, rotation or sweeping.

       This example shows how to sweep a gear profile along a helix:

          import ezdxf
          from ezdxf.render import forms

          doc = ezdxf.new()
          doc.layers.add("MESH", color=ezdxf.colors.YELLOW)
          msp = doc.modelspace()
          # sweeping a gear-profile
          gear = forms.gear(
              8, top_width=0.01, bottom_width=0.02, height=0.02, outside_radius=0.1
          )
          helix = path.helix(radius=2, pitch=1, turns=6)
          # along a helix spine
          sweeping_path = helix.flattening(0.1)
          mesh = forms.sweep(gear, sweeping_path, close=True, caps=True)
          # and render as MESH entity
          mesh.render_mesh(msp, dxfattribs={"layer": "MESH"})
          doc.saveas("gear_along_helix.dxf")
       [image]

   <b>Tutorial</b> <b>for</b> <b>Hatch</b>
   <b>Create</b> <b>hatches</b> <b>with</b> <b>one</b> <b>boundary</b> <b>path</b>
       The simplest form of the <u>Hatch</u> entity has one polyline path with only straight lines as boundary path:

          import ezdxf

          # hatch requires DXF R2000 or later
          doc = ezdxf.new("R2000")
          msp = doc.modelspace()

          # by default a solid fill hatch with fill color=7 (white/black)
          hatch = msp.add_hatch(color=2)

          # every boundary path is a 2D element
          # vertex format for the polyline path is: (x, y[, bulge])
          # there are no bulge values in this example
          hatch.paths.add_polyline_path(
              [(0, 0), (10, 0), (10, 10), (0, 10)], is_closed=True
          )

          doc.saveas("solid_hatch_polyline_path.dxf")

       But like all polyline entities the polyline path can also have bulge values:

          import ezdxf

          # hatch requires the DXF R2000 or later
          doc = ezdxf.new("R2000")
          msp = doc.modelspace()

          # by default a solid fill hatch with fill color=7 (white/black)
          hatch = msp.add_hatch(color=2)

          # every boundary path is a 2D element
          # vertex format for the polyline path is: (x, y[, bulge])
          # bulge value 1 = an arc with diameter=10 (= distance to next vertex * bulge value)
          # bulge value &gt; 0 ... arc is right of line
          # bulge value &lt; 0 ... arc is left of line
          hatch.paths.add_polyline_path(
              [(0, 0, 1), (10, 0), (10, 10, -0.5), (0, 10)], is_closed=True
          )

          doc.saveas("solid_hatch_polyline_path_with_bulge.dxf")

       The most flexible way to define a boundary path is the edge path. An edge path can  have  multiple  edges
       and each edge can be one of the following elements:

          • line <b>EdgePath.add_line()</b>

          • arc <b>EdgePath.add_arc()</b>

          • ellipse <b>EdgePath.add_ellipse()</b>

          • spline <b>EdgePath.add_spline()</b>

       Create a solid hatch with an edge path (ellipse) as boundary path:

          import ezdxf

          # hatch requires the DXF R2000 or later
          doc = ezdxf.new("R2000")
          msp = doc.modelspace()

          # important: major axis &gt;= minor axis (ratio &lt;= 1.)
          # minor axis length = major axis length * ratio
          msp.add_ellipse((0, 0), major_axis=(0, 10), ratio=0.5)

          # by default a solid fill hatch with fill color=7 (white/black)
          hatch = msp.add_hatch(color=2)

          # every boundary path is a 2D element
          edge_path = hatch.paths.add_edge_path()
          # each edge path can contain line, arc, ellipse and spline elements
          # important: major axis &gt;= minor axis (ratio &lt;= 1.)
          edge_path.add_ellipse((0, 0), major_axis=(0, 10), ratio=0.5)

          doc.saveas("solid_hatch_ellipse.dxf")

   <b>Create</b> <b>hatches</b> <b>with</b> <b>multiple</b> <b>boundary</b> <b>paths</b> <b>(islands)</b>
       The DXF attribute <b>hatch_style</b> defines the island detection style:
                                    ┌───┬───────────────────────────────────────┐
                                    │ 0 │ nested - altering filled and unfilled │
                                    │   │ areas                                 │
                                    ├───┼───────────────────────────────────────┤
                                    │ 1 │ outer  -  area  between  <u>external</u> and │
                                    │   │ <u>outermost</u> path is filled              │
                                    ├───┼───────────────────────────────────────┤
                                    │ 2 │ ignore - <u>external</u> path is filled      │
                                    └───┴───────────────────────────────────────┘

          hatch = msp.add_hatch(
              color=1,
              dxfattribs={
                  "hatch_style": ezdxf.const.HATCH_STYLE_NESTED,
                  # 0 = nested: ezdxf.const.HATCH_STYLE_NESTED
                  # 1 = outer: ezdxf.const.HATCH_STYLE_OUTERMOST
                  # 2 = ignore: ezdxf.const.HATCH_STYLE_IGNORE
              },
          )

          # The first path has to set flag: 1 = external
          # flag const.BOUNDARY_PATH_POLYLINE is added (OR) automatically
          hatch.paths.add_polyline_path(
              [(0, 0), (10, 0), (10, 10), (0, 10)],
              is_closed=True,
              flags=ezdxf.const.BOUNDARY_PATH_EXTERNAL,
          )

       This is also the result for all 4 paths and <b>hatch_style</b> set to <b>2</b> (ignore).  [image]

          # The second path has to set flag: 16 = outermost
          hatch.paths.add_polyline_path(
              [(1, 1), (9, 1), (9, 9), (1, 9)],
              is_closed=True,
              flags=ezdxf.const.BOUNDARY_PATH_OUTERMOST,
          )

       This is also the result for all 4 paths and <b>hatch_style</b> set to <b>1</b> (outer).  [image]

          # The third path has to set flag: 0 = default
          hatch.paths.add_polyline_path(
              [(2, 2), (8, 2), (8, 8), (2, 8)],
              is_closed=True,
              flags=ezdxf.const.BOUNDARY_PATH_DEFAULT,
          )

       [image]

          # The forth path has to set flag: 0 = default, and so on
          hatch.paths.add_polyline_path(
              [(3, 3), (7, 3), (7, 7), (3, 7)],
              is_closed=True,
              flags=ezdxf.const.BOUNDARY_PATH_DEFAULT,
          )

          doc.saveas(OUTDIR / "solid_hatch_islands_04.dxf")

       [image]

       The expected result of combinations of various <b>hatch_style</b> values and paths <u>flags</u>,  or  the  handling  of
       overlapping paths is not documented by the DXF reference, so don’t ask me, ask Autodesk or just try it by
       yourself and post your experience in the forum.

   <b>Example</b> <b>for</b> <b>Edge</b> <b>Path</b> <b>Boundary</b>
          hatch = msp.add_hatch(color=1)

          # 1. polyline path
          hatch.paths.add_polyline_path(
              [
                  (240, 210, 0),
                  (0, 210, 0),
                  (0, 0, 0.0),
                  (240, 0, 0),
              ],
              is_closed=1,
              flags=ezdxf.const.BOUNDARY_PATH_EXTERNAL,
          )
          # 2. edge path
          edge_path = hatch.paths.add_edge_path(flags=ezdxf.const.BOUNDARY_PATH_OUTERMOST)
          edge_path.add_spline(
              control_points=[
                  (126.658105895725, 177.0823706957212),
                  (141.5497003747484, 187.8907860433995),
                  (205.8997365206943, 154.7946313459515),
                  (113.0168862297068, 117.8189380884978),
                  (202.9816918983783, 63.17222935389572),
                  (157.363511042264, 26.4621294342132),
                  (144.8204003260554, 28.4383294369643),
              ],
              knot_values=[
                  0.0,
                  0.0,
                  0.0,
                  0.0,
                  55.20174685732758,
                  98.33239645153571,
                  175.1126541251052,
                  213.2061566683142,
                  213.2061566683142,
                  213.2061566683142,
                  213.2061566683142,
              ],
          )
          edge_path.add_arc(
              center=(152.6378550678883, 128.3209356351659),
              radius=100.1880612627354,
              start_angle=94.4752130054052,
              end_angle=177.1345242028005,
          )
          edge_path.add_line(
              (52.57506282464041, 123.3124200796114),
              (126.658105895725, 177.0823706957212),
          )

       [image]

   <b>Associative</b> <b>Boundary</b> <b>Paths</b>
       A HATCH entity can be associative to a base geometry, which means if the base geometry is edited in a CAD
       application  the  HATCH  get  the  same  modification.   Because  <u>ezdxf</u>  is  <b>not</b>  a CAD application, this
       association is <b>not</b> maintained nor verified by <u>ezdxf</u>, so if you modify the base  geometry  afterwards  the
       geometry  of  the  boundary  path  is  not updated and no verification is done to check if the associated
       geometry matches the boundary path, this opens many possibilities to create invalid DXF files:  USE  WITH
       CARE.

       This example associates a LWPOLYLINE entity to the hatch created from the LWPOLYLINE vertices:

          # Create base geometry
          lwpolyline = msp.add_lwpolyline(
              [(0, 0, 0), (10, 0, 0.5), (10, 10, 0), (0, 10, 0)],
              format="xyb",
              close=True,
          )

          hatch = msp.add_hatch(color=1)
          path = hatch.paths.add_polyline_path(
              # get path vertices from associated LWPOLYLINE entity
              lwpolyline.get_points(format="xyb"),
              # get closed state also from associated LWPOLYLINE entity
              is_closed=lwpolyline.closed,
          )

          # Set association between boundary path and LWPOLYLINE
          hatch.associate(path, [lwpolyline])

       An <b>EdgePath</b> needs associations to all geometry entities forming the boundary path.

   <b>Predefined</b> <b>Hatch</b> <b>Pattern</b>
       Use predefined hatch pattern by name:

          hatch.set_pattern_fill("ANSI31", scale=0.5)
       [image]

       <b>SEE</b> <b>ALSO:</b>
          <u>Tutorial</u> <u>for</u> <u>Hatch</u> <u>Pattern</u> <u>Definition</u>

   <b>Tutorial</b> <b>for</b> <b>Hatch</b> <b>Pattern</b> <b>Definition</b>
       A  hatch  pattern  consist of one or more hatch lines. A hatch line defines a set of lines which have the
       same orientation an the same line pattern. All the lines defined by a hatch line are parallel and have  a
       constant  distance  to  each  other.  The  <u>origin</u>  defines the start point of the hatch line and also the
       starting point of the line pattern. The <u>direction</u> defines the angle between the <u>WCS</u> x-axis and the  hatch
       line. The <u>offset</u> is a 2D vector which will be added consecutively the the origin for each new hatch line.
       The  line  pattern  has the same format as as the simple linetype pattern (<u>Tutorial</u> <u>for</u> <u>Creating</u> <u>Linetype</u>
       <u>Pattern</u>).

       <b>IMPORTANT:</b>
          The hatch pattern must be defined for a hatch scaling factor of 1.0 and a hatch rotation  angle  of  0
          degrees!

       The  first  example  creates  a  simple pattern of horizontal solid lines with a vertical distance of 0.5
       drawing units.

          import ezdxf

          doc = ezdxf.new("R2010")
          msp = doc.modelspace()
          hatch = msp.add_hatch()
          hatch.set_pattern_fill(
              "MyPattern",
              color=7,
              angle=0,
              scale=1.0,
              style=0,  # normal hatching style
              pattern_type=0,  # user-defined
              # pattern definition as list of:
              # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
              # line pattern is a solid line
              definition=[[0, (0, 0), (0, 0.5), []]],

          )
          points = [(0, 0), (10, 0), (10, 10), (0, 10)]
          hatch.paths.add_polyline_path(points)
          msp.add_lwpolyline(points, close=True, dxfattribs={"color": 1})
          doc.saveas("user_defined_hatch_pattern.dxf")
       [image]

       The next example shows how the <u>offset</u> value works:

          # -x-x-x- snip -x-x-x-
          hatch = msp.add_hatch()
          hatch.set_pattern_fill(
              "MyPattern",
              color=7,
              angle=0,
              scale=1.0,
              style=0,  # normal hatching style
              pattern_type=0,  # user-defined
              # the line pattern is a dashed line:  - - - -
              # the offset is 1 unit vertical and 0.3 units horizontal
              # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
              definition=[[0, (0, 0), (0.3, 1), [1, -1]]],

          )
          # -x-x-x- snip -x-x-x-
       [image]

       The next example combines two parallel hatch lines, the origin defines how the  hatch  lines  are  offset
       from each other:

          # -x-x-x- snip -x-x-x-
          hatch = msp.add_hatch()
          hatch.set_pattern_fill(
              "MyPattern",
              color=7,
              angle=0,
              scale=1.0,
              style=0,  # normal hatching style
              pattern_type=0,  # user-defined
              # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
              definition=[
                  [0, (0, 0), (0.3, 1), [1, -1]],  # dashed line
                  [0, (0, 0.5), (0, 1), []],  # solid line
              ],
          )
          # -x-x-x- snip -x-x-x-
       [image]

       The  next  example  combines two hatch lines with different angles.  The origins can be the same for this
       example. The <b>Vec2</b> class is used to calculate the offset value for a normal distance of 0.7 drawing  units
       between the slanted lines:

          from ezdxf.math import Vec2

          # -x-x-x- snip -x-x-x-
          hatch = msp.add_hatch()
          # offset vector for a normal distance of 0.7 for a 45 deg slanted hatch line
          offset = Vec2.from_deg_angle(45 + 90, length=0.7)
          hatch.set_pattern_fill(
              "MyPattern",
              color=7,
              angle=0,
              scale=1.0,
              style=0,  # normal hatching style
              pattern_type=0,  # user-defined
              # [angle in degree, origin as 2d vector, offset as 2d vector, line pattern]
              definition=[
                  [0, (0, 0), (0, 1), [1, -1]],  # horizontal dashed line
                  [45, (0, 0), offset, []],  # slanted solid line
              ],
          )
          # -x-x-x- snip -x-x-x-
       [image]

   <b>Tutorial</b> <b>for</b> <b>Image</b> <b>and</b> <b>ImageDef</b>
       This example shows how to use a raster image in a DXF document.  Each IMAGE entity requires an associated
       IMAGEDEF  entity  in  the  objects section, which stores the filename of the linked image and the size in
       pixels.  Multiple IMAGE entities can share the same IMAGEDEF entity.

       <b>IMPORTANT:</b>
          The raster image is NOT embedded in the DXF file!

          import ezdxf

          # The IMAGE entity requires the DXF R2000 format or later.
          doc = ezdxf.new("R2000")

          # The IMAGEDEF entity is like a block definition, it just defines the image.
          my_image_def = doc.add_image_def(
              filename="mycat.jpg", size_in_pixel=(640, 360)
          )

          msp = doc.modelspace()
          # The IMAGE entity is like the INSERT entity, it's just an image reference,
          # and there can be multiple references to the same picture in a DXF document.

          # 1st image reference
          msp.add_image(
              insert=(2, 1),
              size_in_units=(6.4, 3.6),
              image_def=my_image_def,
              rotation=0
          )
          # 2nd image reference
          msp.add_image(
              insert=(4, 5),
              size_in_units=(3.2, 1.8),
              image_def=my_image_def,
              rotation=30
          )

          # Get existing image definitions from the OBJECTS section:
          image_defs = doc.objects.query("IMAGEDEF")

          doc.saveas("dxf_with_cat.dxf")

   <b>Tutorial</b> <b>for</b> <b>Underlay</b> <b>and</b> <b>UnderlayDefinition</b>
       This example shows hot to insert a a PDF, DWF, DWFx or DGN file as drawing underlay. Each UNDERLAY entity
       requires an associated UNDERLAYDEF entity in the objects section, which stores the filename of the linked
       document and the parameters of the underlay. Multiple UNDERLAY entities can share  the  same  UNDERLAYDEF
       entity.

       <b>IMPORTANT:</b>
          The underlay file is NOT embedded into the DXF file:

          import ezdxf

          doc = ezdxf.new('AC1015')  # underlay requires the DXF R2000 format or later
          my_underlay_def = doc.add_underlay_def(filename='my_underlay.pdf', name='1')
          # The (PDF)DEFINITION entity is like a block definition, it just defines the underlay
          # 'name' is misleading, because it defines the page/sheet to be displayed
          # PDF: name is the page number to display
          # DGN: name='default' ???
          # DWF: ????

          msp = doc.modelspace()
          # add first underlay
          msp.add_underlay(my_underlay_def, insert=(2, 1, 0), scale=0.05)
          # The (PDF)UNDERLAY entity is like the INSERT entity, it creates an underlay reference,
          # and there can be multiple references to the same underlay in a drawing.

          msp.add_underlay(my_underlay_def, insert=(4, 5, 0), scale=.5, rotation=30)

          # get existing underlay definitions, Important: UNDERLAYDEFs resides in the objects section
          pdf_defs = doc.objects.query('PDFDEFINITION')  # get all pdf underlay defs in drawing

          doc.saveas("dxf_with_underlay.dxf")

   <b>Tutorial</b> <b>for</b> <b>MultiLeader</b>
       A multileader object typically consists of an arrowhead, a horizontal landing (a.k.a. “dogleg”), a leader
       line or curve, and either a MTEXT object or a BLOCK.

       Factory methods of the <u>BaseLayout</u> class to create new <u>MultiLeader</u> entities:

          • <u>add_multileader_mtext()</u>

          • <u>add_multileader_block()</u>

       Because of the complexity of the MULTILEADER entity, the factory method <u>add_multileader_mtext()</u> returns a
       <u>MultiLeaderMTextBuilder</u>  instance  to  build  a new entity and the factory method <u>add_multileader_block()</u>
       returns a <u>MultiLeaderBlockBuilder</u> instance.

       Due of the lack of good documentation it’s not  possible  to  support  all  combinations  of  MULTILEADER
       properties  with  decent  quality,  so  stick  to  recipes and hints shown in this tutorial to get usable
       results otherwise, you will enter uncharted territory.

       The rendering result of  the  MULTILEADER  entity  is  highly  dependent  on  the  CAD  application.  The
       MULTILEADER  entity  does  not  have  a pre-rendered anonymous block of DXF primitives like all DIMENSION
       entities, so results may vary from CAD application to CAD  application.  The  general  support  for  this
       entity  is  only  good  in  Autodesk  products  other  CAD  applications  often  struggle  when rendering
       MULTILEADERS, even my preferred testing application BricsCAD has rendering issues.

       <b>IMPORTANT:</b>
          MULTILEADER support has flaws in many CAD applications except Autodesk products!

       <b>SEE</b> <b>ALSO:</b>

          • <u>ezdxf.render.MultiLeaderBuilder</u> classes

          • <u>ezdxf.entities.MultiLeader</u> class

          • <u>ezdxf.entities.MLeaderStyle</u> class

          • <u>ezdxf.tools.text.MTextEditor</u> class

          • <u>MULTILEADER</u> <u>Internals</u>

   <b>MTEXT</b> <b>Quick</b> <b>Draw</b>
       Full Python script: <u>mtext_quick_leader.py</u>

       The <b>quick_leader()</b> method of a MTEXT - MULTILEADER entity constructs the geometry parameters  in  reverse
       manner, starting from a given target point:

       DXF document setup:

              doc = ezdxf.new(setup=True)
              # Create a new custom MLEADERSTYLE:
              mleaderstyle = doc.mleader_styles.duplicate_entry("Standard", "EZDXF")
              # The required TEXT style "OpenSans" was created by ezdxf.new() because setup is True:
              mleaderstyle.set_mtext_style("OpenSans")
              msp = doc.modelspace()

       Draw a red circle to mark the target point:

              target_point = Vec2(40, 15)
              msp.add_circle(
                  target_point, radius=0.5, dxfattribs=GfxAttribs(color=colors.RED)
              )

       Create four horizontal placed MULTILEADER entities pointing at the target point, the first segment of the
       leader line is determined by an angle in this example pointing away from the target point:

              for angle in [45, 135, 225, -45]:
                  ml_builder = msp.add_multileader_mtext("EZDXF")
                  ml_builder.quick_leader(
                      f"angle={angle}°\n2nd text line",
                      target=target_point,
                      segment1=Vec2.from_deg_angle(angle, 14),
                  )

       [image]

       The  content  is  automatically  aligned  to  the end of the leader line. The first segment is a relative
       vector to the target point and the optional second segment vector is relative to the  end  of  the  first
       segment.  The default connection type is horizontal but can be changed to vertical:

       A smaller text size is required:

              mleaderstyle = doc.mleader_styles.duplicate_entry("Standard", "EZDXF")
              mleaderstyle.set_mtext_style("OpenSans")
              mleaderstyle.dxf.char_height = 2.0  # set the default char height of MTEXT

       Adding vertical placed MULTILEADER entities:

              for angle in [45, 135, 225, -45]:
                  ml_builder = msp.add_multileader_mtext("EZDXF")
                  ml_builder.quick_leader(
                      f"angle={angle}°\n2nd text line",
                      target=target_point,
                      segment1=Vec2.from_deg_angle(angle, 14),
                      connection_type=mleader.VerticalConnection.center_overline,
                  )

       This  example  already  shows  the  limitation  caused  by  different  text  renderings  in  various  CAD
       applications. The <u>ezdxf</u> text measurement by <u>matplotlib</u> is different  to  AutoCAD  and  BricsCAD  and  the
       result is a misalignment of the overline and the leader line.

       The DXF file shown in BricsCAD: [image]

       The same DXF file shown with the <b>ezdxf</b> <b>view</b> command (drawing add-on): [image]

       My  advice  is to avoid vertical placed MULTILEADER entities at all and for horizontal placed MULTILEADER
       entities avoid styles including an “underline” or an “overline”.

       The <b>quick_leader()</b> method is not very customizable for ease of use,  but  follows  the  settings  of  the
       associated <u>MLeaderStyle</u>.

       The following sections show how to have more control when adding MULTILEADER entities.

   <b>Create</b> <b>MTEXT</b> <b>Content</b>
       Full Python script: <u>mtext_content.py</u>

       This section shows how to create a MULTILEADER entity with MTEXT content the manual way with full control
       over all settings.

       For  good results the MTEXT alignment should match the leader connection side, e.g. if you attach leaders
       to the left side also align the MTEXT to the left side, for leaders attached at the right side, align the
       MTEXT to the right side and if you attach leaders at both sides one side will fit better than  the  other
       or maybe a center aligned MTEXT is a good solution, for further details see section <u>MTEXT</u> <u>Alignment</u>.

       The first example uses the default connection type of the MLEADERSTYLE “Standard” which is “middle of the
       top  line” for left and right attached leaders. The render UCS for this example is the WCS to keep things
       simple.

       Create a new MULTILEADER entity.

              ml_builder = msp.add_multileader_mtext("Standard")

       Set MTEXT content, text style and alignment.

              ml_builder.set_content(
                  "Line1\nLine2",
                  style="OpenSans",
                  alignment=mleader.TextAlignment.left,  # set MTEXT alignment!
              )

       Add the first leader on the left side.  The leader points always  to  the  first  given  vertex  and  all
       vertices are given in render UCS coordinates (= WCS in this example).

              ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(-20, -15)])

       More than one vertex per leader can be used:

              ml_builder.add_leader_line(
                  mleader.ConnectionSide.left,
                  [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
              )

       The insert point of the <b>build()</b> method is the alignment point for the MTEXT content.

              ml_builder.build(insert=Vec2(5, 0))

       The “dogleg” settings are defined by the MLEADERSTYLE “Standard”.  [image]

       This example shows a leader attached to the right side and the MTEXT aligned to the right side.

              ml_builder = msp.add_multileader_mtext("Standard")
              ml_builder.set_content(
                  "Line1\nLine2",
                  style="OpenSans",
                  alignment=mleader.TextAlignment.right,  # set MTEXT alignment!
              )
              ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(40, -15)])
              ml_builder.build(insert=Vec2(15, 0))

       [image]

       This example shows two leaders attached to both sides and the MTEXT aligned to the left side, which shows
       that  the  right  landing gap (space between text and start of vertex) is bigger than the gap on the left
       size. This is due to the different text size calculations  from  AutoCAD/BricsCAD  and  Matplotlib.   The
       longer the text, the greater the error.

              ml_builder = msp.add_multileader_mtext("Standard")
              ml_builder.set_content(
                  "Line1\nLine1",
                  style="OpenSans",
                  alignment=mleader.TextAlignment.left,  # set MTEXT alignment!
              )
              ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(-20, -15)])
              ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(40, -15)])
              ml_builder.build(insert=Vec2(5, 0))

       [image]

       A centered MTEXT alignment gives a more even result.

              ml_builder = msp.add_multileader_mtext("Standard")
              ml_builder.set_content(
                  "First Line\n2. Line",
                  style="OpenSans",
                  alignment=mleader.TextAlignment.center,  # set MTEXT alignment!
              )
              ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(-20, -15)])
              ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(40, -15)])
              ml_builder.build(insert=Vec2(10, 0))

       [image]

       But  even  this  has its disadvantages, the attachment calculation is always based on the bounding box of
       the MTEXT content.  [image]

   <b>MTEXT</b> <b>Connection</b> <b>Types</b>
       There are four connection sides defined by the enum <u>ezdxf.render.ConnectionSide</u>:

          • left

          • right

          • top

          • bottom

       The MultiLeader entity supports as the name says multiple leader lines, but all have to have a horizontal
       (left/right) connection side or a vertical  (top/bottom)  connection  side,  it’s  not  possible  to  mix
       left/right and top/bottom connection sides. This is determined by the DXF format.

       There  are different connection types available for the horizontal and the vertical connection sides. All
       leaders connecting to the same side have the  same  connection  type.  The  horizontal  connection  sides
       support following connection types, defined by the enum <u>ezdxf.render.HorizontalConnection</u>:

          • by_style

          • top_of_top_line

          • middle_of_top_line

          • middle_of_text

          • middle_of_bottom_line

          • bottom_of_bottom_line

          • bottom_of_bottom_line_underline (not recommended)

          • bottom_of_top_line_underline (not recommended)

          • bottom_of_top_line

          • bottom_of_top_line_underline_all (not recommended)

       The   vertical   connection   sides   support   following   connection   types,   defined   by  the  enum
       <u>ezdxf.render.VerticalConnection</u>:

          • by_style

          • center

          • center_overline (not recommended)

       The connection type for each side can be set by the method <u>set_connection_types()</u>, the  default  for  all
       sides is <u>by_style</u>:

              ml_builder.set_connection_types(
                  left=mleader.HorizontalConnection.middle_of_top_line,
                  right=mleader.HorizontalConnection.middle_of_bottom_line,
              )

       [image]

       <b>HINT:</b>
          As  shown  in  the  quick draw section using connection types including underlines or overlines do not
          render well in AutoCAD/BricsCAD because of the different text  measurement  of  <u>matplotlib</u>,  therefore
          it’s not recommended to use any of these connection types when creating MULTILEADERS by <u>ezdxf</u>.

   <b>MTEXT</b> <b>Alignment</b>
       In  contrast  to the standalone MTEXT entity supports the MTEXT content entity only three text alignments
       defined by the enum <u>ezdxf.render.TextAlignment</u>.

          • left

          • center

          • right

       The MTEXT alignment is set as argument <u>alignment</u> of the <b>set_content()</b> method and the alignment  point  is
       the insert point of the <u>build()</u> method.

   <b>Create</b> <b>BLOCK</b> <b>Content</b>
       Full Python script: <u>block_content.py</u>

       This section shows how to create a MULTILEADER entity with BLOCK content the manual way with full control
       over all settings.

       The  BLOCK  content consist of a BLOCK layout and optional ATTDEF entities which defines the location and
       DXF attributes of dynamically created ATTRIB entities.

       Create the BLOCK content, the full <b>create_square_block()</b> function can be found  in  the  <u>block_content.py</u>
       script.

              block = create_square_block(
                  doc, size=8.0, margin=0.25, base_point=base_point
              )

       Create the MULTILEADER and set the content:

              ml_builder = msp.add_multileader_block(style="Standard")
              ml_builder.set_content(
                  name=block.name, alignment=mleader.BlockAlignment.insertion_point
              )

       Set the BLOCK attribute content as text:

              ml_builder.set_attribute("ONE", "Data1")
              ml_builder.set_attribute("TWO", "Data2")

       Add some leader lines to the left and right side of the BLOCK:

       Construction  plane  of the entity is defined by a render UCS.  The leader lines vertices are expected in
       render UCS coordinates, which means relative to the UCS origin and this example  shows  the  simple  case
       where the UCS is the WCS which is also the default setting.

              ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(x2, y1)])
              ml_builder.add_leader_line(mleader.ConnectionSide.right, [Vec2(x2, y2)])
              ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(x1, y1)])
              ml_builder.add_leader_line(mleader.ConnectionSide.left, [Vec2(x1, y2)])

       Last step is to build the final MULTILEADER entity.  This example uses the alignment type <u>insertion_point</u>
       where the insert point of the <b>build()</b> method is the base point of the BLOCK:

              ml_builder.build(insert=Vec2(5, 2), rotation=30)

       [image]

       The  result is shown in BricsCAD as expected, although BricsCAD shows “Center extents” as attachment type
       in the properties dialog instead of the correct attachment type “Insertion point”.

   <b>BLOCK</b> <b>Connection</b> <b>Types</b>
       There are four connection sides defined by the enum <u>ezdxf.render.ConnectionSide</u>:

          • left

          • right

          • top

          • bottom

       The connection point for leader lines is always the center of the side of  the  block  bounding  box  the
       leader is connected to and has the same limitation as for the MTEXT content, it’s not possible to mix the
       connection sides left/right and top/bottom.

       The connection side is set when adding the leader line by the <u>add_leader_line()</u> method.

       Unfortunately  BricsCAD  has  an error in version 22.2.03 and renders all connection types as left/right,
       this is top/bottom connection shown in Autodesk TrueView 2022: [image]

       The top/bottom connection type does not support the “dogleg” feature.

   <b>BLOCK</b> <b>Alignment</b>
       There are two alignments types, defined by the enum <u>ezdxf.render.BlockAlignment</u>

          • center_extents

          • insertion_point

       The alignment is set by the <u>set_content()</u> method.

       The alignment type <u>center_extent</u> inserts the BLOCK with the center of the  bounding  box  at  the  insert
       point of the <u>build()</u> method. The insert point is (5, 2) in this example: [image]

       The same MULTILEADER with alignment type <u>insert_point</u>: [image]

   <b>BLOCK</b> <b>Scaling</b>
       The BLOCK content can be scaled independently from the overall scaling of the MULTILEADER entity:

       The block scaling factor is set by the <u>set_content()</u> method:

          ml_builder.set_content(
              name=block.name, scale=2.0, alignment=mleader.BlockAlignment.center_extents
          )

       This  is  the  first example with a block scaling factor of 2. The BLOCK and the attached ATTRIB entities
       are scaled but not the arrows.  [image]

   <b>BLOCK</b> <b>Rotation</b>
       The rotation around the render UCS z-axis in degrees is applied by the <u>build()</u> method:

          ml_builder.build(insert=Vec2(5, 2), rotation=30)

       This is the first example with a rotation of 30 degrees. The BLOCK, the attached ATTRIB entities and  the
       last connection lines (“dogleg”) are rotated.  [image]

   <b>BLOCK</b> <b>Attributes</b>
       BLOCK  attributes  are  defined  as  ATTDEF  entities  in  the BLOCK layout. This ATTDEF entities will be
       replaced by ATTRIB entities at the rendering process of the CAD application.  Only the text  content  and
       the  text  width  factor  can  be changed for each MULTILEADER entity individually by the <u>set_attribute()</u>
       method. The ATTDEF is addressed by it’s DXF <u>tag</u> attribute:

          ml_builder.set_attribute("ONE", "Data1")
          ml_builder.set_attribute("TWO", "Data2")

   <b>Leader</b> <b>Properties</b>
   <b>“Dogleg”</b> <b>Properties</b>
       The “dogleg” is the last line segment from the last leader vertex to the MULTILEADER content for polyline
       leaders.  [image]

       The length of the dogleg and the landing gap size is set by the <u>set_connection_properties()</u>.

   <b>Polyline</b> <b>Leader</b>
       A polygon leader line has only straight line segments and is added by the <u>add_leader_line()</u>:

          ml_builder.add_leader_line(
              mleader.ConnectionSide.left,
              [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
          )
       [image]

       All leader line vertices have render UCS coordinates and the start- and end-vertex  of  the  “dogleg”  is
       calculated automatically.

   <b>Spline</b> <b>Leader</b>
       A  spline leader line has a single curved line as leader line and is also added by the <u>add_leader_line()</u>.
       This is spline leader has the same vertices as the previous created polyline leader:

          ml_builder.set_leader_properties(leader_type=mleader.LeaderType.splines)
          ml_builder.add_leader_line(
              mleader.ConnectionSide.left,
              [Vec2(-20, 15), Vec2(-10, 15), Vec2(-15, 11), Vec2(-10, 7)],
          )
       [image]

       The spline leader has no “dogleg” and spline leaders and polyline leaders can not be mixed  in  a  single
       MULTILEADER entity.

       The leader type is set by the <u>set_leader_properties()</u> method.

       The <u>LeaderType</u> enum:

          • none

          • straight_lines

          • splines

   <b>Line</b> <b>Styling</b>
       The leader color, linetype and lineweight is set by the <u>set_leader_properties()</u> method:

          ml_builder.set_leader_properties(
              color=colors.MAGENTA,
              linetype="DASHEDX2",
              lineweight=70,
          )
       [image]

       All leader lines have the same properties.

   <b>Arrowheads</b>
       The arrow head is set by the <u>set_arrow_properties()</u> method:

          from ezdxf.render import ARROWS
          ml_builder.set_arrow_properties(name=ARROWS.closed_blank, size=8.0)
       [image]

       All  leader lines have the same arrow head and size.  The available arrow heads are defined in the <u>ARROWS</u>
       object.

   <b>Overall</b> <b>Scaling</b>
       The overall scaling has to be applied by the <u>set_overall_scaling()</u> method and scales the MTEXT  or  BLOCK
       content <b>and</b> the arrows.

   <b>Setup</b> <b>MLEADERSTYLE</b>
       The  <u>MLeaderStyle</u>  stores  many  of the MULTILEADER settings but most of them are copied to the MULTILINE
       entity at initialization.  So changing the MLEADERSTYLE style afterwards has  little  to  no  effect  for
       existing MULTILEADER entities.

       Create a new MLEADERSTYLE called “MY_STYLE” and set the MTEXT style to “OpenSans”:

          my_style = doc.mleader_styles.duplicate_entry("Standard", "MY_STYLE")
          my_style.set_mtext_style("OpenSans")

       The  style  for  a  MULTILEADER is set at the <u>add_multileader_mtext()</u> and <u>add_multileader_block()</u> factory
       methods.

   <b>Tutorial</b> <b>for</b> <b>Viewports</b> <b>in</b> <b>Paperspace</b>
       This tutorial is based on the example script <u>viewports_in_paperspace.py</u>.  The script  creates  DXF  files
       for  the  version  R12  and  for R2000+, but the export for DXF R12 has a wrong papersize in BricsCAD and
       wrong margins in Autodesk DWG Trueview. I don’t know why this happens and I don’t waste my  time  to  fix
       this.

       <b>IMPORTANT:</b>
          If  you  need  paperspace  layouts  use  DXF  version  R2000  or  newer because the export of the page
          dimensions does not work for DXF R12!

       The scripts creates three flat geometries in the xy-plane of the <u>WCS</u> and a 3D  mesh  as  content  of  the
       modelspace: [image]

   <b>Page</b> <b>Setup</b>
       The  paperspace  layout  feature  lacks  documentation  in  the DXF reference, there is no information in
       practice on <b>how</b> it is used, so most of the information here is assumptions  gathered  through  trail  and
       error.

       The  <u>page_setup()</u>  method  defines the properties of the paper sheet itself.  The units of the modelspace
       and the paperspace are not related and can even have different unit systems (imperial,  meters),  but  to
       keep things simple it’s recommended to use the same unit system for both spaces.

          layout.page_setup(size=(24, 18), margins=(1, 1, 1, 1), units="inch")

       The  <u>size</u> argument defines the overall paper size in rotation mode 0, it seems to be the best practice to
       define the paper extents in landscape mode and rotate the paper by the <u>rotate</u> argument afterwards.

       Choices for the <u>rotation</u> argument:
                                          ┌───┬──────────────────────────────┐
                                          │ 0 │ no rotation                  │
                                          ├───┼──────────────────────────────┤
                                          │ 1 │ 90 degrees counter-clockwise │
                                          ├───┼──────────────────────────────┤
                                          │ 2 │ upside-down                  │
                                          ├───┼──────────────────────────────┤
                                          │ 3 │ 90 degrees clockwise         │
                                          └───┴──────────────────────────────┘

       The <u>scale</u> argument reflects the relationship between paper unit and  drawing  unit  in  paperspace.  It’s
       recommended  to let this scale at the default value of 1:1 and draw lines and text in paperspace with the
       same units as you defined the paper size.

       <b>SEE</b> <b>ALSO:</b>

          • AutoCAD: <u>About</u> <u>Plotting</u> and <u>About</u> <u>Setting</u> <u>the</u> <u>Plot</u> <u>Scale</u>

          • BricsCAD: <u>General</u> <u>Procedure</u> <u>for</u> <u>Printing</u>

   <b>Drawing</b> <b>in</b> <b>Paperspace</b>
       You can add DXF entities to the paperspace like to any other layout space.  The coordinate origin (0,  0)
       is in the left bottom corner of the canvas which is the paper size minus the margins. You can draw beyond
       this limits but CAD applications may not print that content.

       <b>HINT:</b>
          By writing this tutorial I noticed that changing the printer/plotter and the paper size does shift the
          layout  content, because all paper sizes are defined without margins. Maybe it’s preferable to set all
          margins to zero.

          I added the helper method <u>page_setup()</u> to the <u>Drawing</u> class and an example <u>simple_page_setup.py</u> how to
          use it.

   <b>Adding</b> <b>Viewports</b>
       The <u>Viewport</u> entity is a window to the modelspace to display the content of the modelspace in  paperspace
       with  an  arbitrary  scaling  and  rotation.   The  VIEWPORT  entity  will be added by the factory method
       <u>add_viewport()</u>, the <u>center</u> argument defines the center and the <u>size</u> argument defines the width and height
       of the of the VIEWPORT in paperspace. The source of the modelspace to display is defined by the arguments
       <u>view_center_point</u> and <u>view_height</u>.  [image]

   <b>Scaling</b> <b>Factor</b>
       The scaling factor of the VIEWPORT is not an explicit value, the factor is defined by the relation of the
       VIEWPORT height of the <u>size</u> argument and the <u>view_height</u> argument.

       If both values are equal the scaling is 1:1

          paperspace.add_viewport(
              center=(14.5, 2.5),
              size=(5, 5),
              view_center_point=(12.5, 7.5),
              view_height=5,
          )

       If the <u>view_height</u> is 5x larger than the VIEWPORT height the scaling is 1:5

          paperspace.add_viewport(
              center=(8.5, 2.5),
              size=(5, 5),
              view_center_point=(10, 5),
              view_height=25,
          )

   <b>View</b> <b>Direction</b>
       The default view direction is the top down view, but can  be  changed  to  any  view  by  the  attributes
       <u>view_target_point</u> and  <u>view_direction_vector</u> of the <b>dxf</b> namespace.

          vp = paperspace.add_viewport(
              center=(16, 10), size=(4, 4), view_center_point=(0, 0), view_height=30
          )
          vp.dxf.view_target_point = (40, 40, 0)
          vp.dxf.view_direction_vector = (-1, -1, 1)

   <b>Viewport</b> <b>Frame</b>
       The  VIEWPORT  frame (borderlines) are shown in paperspace by default.  The VIEWPORT entity does not have
       an attribute to change this.  The visibility of the VIEWPORT frame is controlled by the layer assigned to
       the VIEWPORT entity which is the layer “VIEWPORTS” by default in <u>ezdxf</u>.  Turning off this layer hides the
       frames of the VIEWPORT entities on this layer, to do that the layer “VIEWPORTS” have to be created by the
       library user:

          vp_layer = doc.layers.add("VIEWPORTS")
          vp_layer.off()

   <b>Freeze</b> <b>Layers</b>
       Each VIEWPORT can have individual frozen layers, which means the layers are not visible in this VIEWPORT.
       To freeze layers in a VIEWPORT assign the names of the  frozen  layers  as  a  list-like  object  to  the
       <b>frozen_layers</b> attribute of the VIEWPORT entity:

          vp.frozen_layers = ["Layer0", "Layer1"]

       <b>IMPORTANT:</b>
          AutoCAD  and  BricsCAD  <b>do</b>  <b>not</b> <b>crash</b> if the layer names do not have layer table entries and the layer
          names are case insensitive as all table names.

       <b>SEE</b> <b>ALSO:</b>

          • Basic concept of <u>Layers</u>

          • <u>Layer</u>

   <b>Override</b> <b>Layer</b> <b>Properties</b>
       Each VIEWPORT can override layer properties individually. These overrides are stored in the <u>Layer</u>  entity
       and  referenced  by  the  handle  of  the VIEWPORT. This procedure is a bit more complex and shown in the
       example file <u>viewports_override_layer_attributes.py</u>.

       1. get the <u>Layer</u> object

       2. get the <u>LayerOverrides</u> object from the layer

       3. override the properties of the VIEWPORT

       4. commit changes

          layer = doc.layers.get("Layer0")
          override = layer.get_vp_overrides()
          override.set_linetype(vp.dxf.handle, "DASHED")
          override.commit()

       Supported property overrides:

          • ACI color

          • true color

          • transparency

          • linetype

          • lineweight

       <b>SEE</b> <b>ALSO:</b>

          • Basic concept of <u>Layers</u>

          • Basic concept of <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>

          • Basic concept of <u>True</u> <u>Color</u>

          • Basic concept of <u>Transparency</u>

          • Basic concept of <u>Linetypes</u>

          • Basic concept of <u>Lineweights</u>

          • <u>Layer</u>

          • <u>LayerOverrides</u>

   <b>Tutorial</b> <b>for</b> <b>OCS/UCS</b> <b>Usage</b>
       For OCS/UCS usage is a basic understanding of vector math required, for a brush  up,  watch  the  YouTube
       tutorials of <u>3Blue1Brown</u> about <u>Linear</u> <u>Algebra</u>.

       Second read the <u>Coordinate</u> <u>Systems</u> introduction please.

       <b>SEE</b> <b>ALSO:</b>
          The  free  online  book  <u>3D</u>  <u>Math</u> <u>Primer</u> <u>for</u> <u>Graphics</u> <u>and</u> <u>Game</u> <u>Development</u> is a very good resource for
          learning vector math and other graphic related topics, it is easy to read for beginners and especially
          targeted to programmers.

       For <u>WCS</u> there is not much to say as, it is what it is: the main world coordinate system,  and  a  drawing
       unit  can  have  any  real  world  unit  you  want.   Autodesk added some mechanism to define a scale for
       dimension and text entities, but because I am not an AutoCAD user, I am not familiar with it, and further
       more I think this is more an AutoCAD topic than a DXF topic.

   <b>Object</b> <b>Coordinate</b> <b>System</b> <b>(OCS)</b>
       The <u>OCS</u> is used to place planar 2D entities in 3D space. <b>ALL</b> points of a planar entity lay  in  the  same
       plane,  this  is  also  true  if  the  plane  is located in 3D space by an OCS. There are three basic DXF
       attributes that gives a 2D entity its spatial form.

   <b>Extrusion</b>
       The extrusion vector defines the OCS, it is a normal vector to the base plane of a  planar  entity.  This
       <u>base</u>  <u>plane</u>  is always located in the origin of the <u>WCS</u>.  But there are some entities like <u>Ellipse</u>, which
       have an extrusion vector, but do not establish an OCS.  For this entities the  extrusion  vector  defines
       only  the  extrusion  direction  and  thickness  defines the extrusion distance, but all other points and
       directions in WCS.

   <b>Elevation</b>
       The elevation value defines the z-axis value for all points of a planar entity, this is an OCS value, and
       defines the distance of the entity plane from the <u>base</u> <u>plane</u>.

       This value exists only in output from DXF versions prior to R11 as separated DXF  attribute  (group  code
       38).   In DXF R12 and later, the elevation value is supplied as z-axis value of each point. But as always
       in DXF, this simple rule does not apply to all entities: <u>LWPolyline</u>  and  <u>Hatch</u>  have  an  DXF  attribute
       <b>elevation</b> as a 3D point, where the z-values of this point is the elevation height and the x-value and the
       y-value are 0.

   <b>Thickness</b>
       Defines the extrusion distance for an entity.

       <b>NOTE:</b>
          There  is  a new edition of this tutorial using UCS based transformation, which are available in <u>ezdxf</u>
          v0.11 and later: <u>Tutorial</u> <u>for</u> <u>UCS</u> <u>Based</u> <u>Transformations</u>

          This edition shows the <b>hard</b> <b>way</b> to accomplish the transformations by low level operations.

   <b>Placing</b> <b>2D</b> <b>Circle</b> <b>in</b> <b>3D</b> <b>Space</b>
       The colors of the system axis follow the AutoCAD standard:

          • red is x-axis

          • green is y-axis

          • blue is z-axis

          import ezdxf
          from ezdxf.math import OCS

          doc = ezdxf.new('R2010')
          msp = doc.modelspace()

          # For this example the OCS is rotated around x-axis about 45 degree
          # OCS z-axis: x=0, y=1, z=1
          # extrusion vector must not normalized here
          ocs = OCS((0, 1, 1))
          msp.add_circle(
              # You can place the 2D circle in 3D space
              # but you have to convert WCS into OCS
              center=ocs.from_wcs((0, 2, 2)),
              # center in OCS: (0.0, 0.0, 2.82842712474619)
              radius=1,
              dxfattribs={
                  # here the extrusion vector should be normalized,
                  # which is granted by using the ocs.uz
                  'extrusion': ocs.uz,
                  'color': 1,
              })
          # mark center point of circle in WCS
          msp.add_point((0, 2, 2), dxfattribs={'color': 1})

       The following image shows the 2D circle in 3D space in AutoCAD <u>Left</u> and <u>Front</u> view.  The blue line  shows
       the  OCS  z-axis  (extrusion  direction),  elevation is the distance from the origin to the center of the
       circle in this case 2.828, and you see that the x- and y-axis of the OCS and the  WCS  are  not  aligned.
       [image: circle in ocs as side view] [image] [image: circle in ocs as front view] [image]

   <b>Placing</b> <b>LWPolyline</b> <b>in</b> <b>3D</b> <b>Space</b>
       For simplicity of calculation I use the <u>UCS</u> class in this example to place a 2D pentagon in 3D space.

          # The center of the pentagon should be (0, 2, 2), and the shape is
          # rotated around x-axis about 45 degree, to accomplish this I use an
          # UCS with z-axis (0, 1, 1) and an x-axis parallel to WCS x-axis.
          ucs = UCS(
              origin=(0, 2, 2),  # center of pentagon
              ux=(1, 0, 0),  # x-axis parallel to WCS x-axis
              uz=(0, 1, 1),  # z-axis
          )
          # calculating corner points in local (UCS) coordinates
          points = [Vec3.from_deg_angle((360 / 5) * n) for n in <a href="../man5/range.5.html">range</a>(5)]
          # converting UCS into OCS coordinates
          ocs_points = list(ucs.points_to_ocs(points))

          # LWPOLYLINE accepts only 2D points and has an separated DXF attribute elevation.
          # All points have the same z-axis (elevation) in OCS!
          elevation = ocs_points[0].z

          msp.add_lwpolyline(
              points=ocs_points,
              format='xy',  # ignore z-axis
              close=True,
              dxfattribs={
                  'elevation': elevation,
                  'extrusion': ucs.uz,
                  'color': 1,
              })

       The  following  image  shows  the 2D pentagon in 3D space in AutoCAD <u>Left</u>, <u>Front</u> and <u>Top</u> view.  The three
       lines from the center of the pentagon show the UCS, the three colored lines in the origin show  the  OCS,
       the white lines in the origin show the WCS.

       The z-axis of the UCS and the OCS pointing in the same direction (extrusion direction), and the x-axis of
       the  UCS  and the WCS pointing also in the same direction.  The elevation is the distance from the origin
       to the center of the pentagon and all points of the pentagon have the same elevation, and  you  see  that
       the  y-axis  of  the  UCS,  the  OCS  and the WCS are not aligned.  [image: pentagon in ucs as side view]
       [image] [image: pentagon in ucs as front view] [image]

   <b>Using</b> <b>UCS</b> <b>to</b> <b>Place</b> <b>3D</b> <b>Polyline</b>
       It is much simpler to use a 3D <u>Polyline</u> to create the 3D pentagon.  The  <u>UCS</u>  class  is  handy  for  this
       example and all kind of 3D operations.

          # Using an UCS simplifies 3D operations, but UCS definition can happen later
          # calculating corner points in local (UCS) coordinates without Vec3 class
          angle = math.radians(360 / 5)
          corners_ucs = [(math.cos(angle * n), math.sin(angle * n), 0) for n in <a href="../man5/range.5.html">range</a>(5)]

          # let's do some transformations
          tmatrix = Matrix44.chain(  # creating a transformation matrix
              Matrix44.z_rotate(<a href="../man15/math.radians.15.html">math.radians</a>(15)),  # 1. rotation around z-axis
              Matrix44.translate(0, .333, .333),  # 2. translation
          )
          transformed_corners_ucs = tmatrix.transform_vertices(corners_ucs)

          # transform UCS into WCS
          ucs = UCS(
              origin=(0, 2, 2),  # center of pentagon
              ux=(1, 0, 0),  # x-axis parallel to WCS x-axis
              uz=(0, 1, 1),  # z-axis
          )
          corners_wcs = list(ucs.points_to_wcs(transformed_corners_ucs))

          msp.add_polyline3d(
              points=corners_wcs,
              close=True,
          )

          # add lines from center to corners
          center_wcs = ucs.to_wcs((0, .333, .333))
          for corner in corners_wcs:
              msp.add_line(center_wcs, corner, dxfattribs={'color': 1})

          <a href="../manmsp/ucs.render_axis.msp.html">ucs.render_axis</a>(msp)

       [image: 3d poyline with UCS] [image]

   <b>Placing</b> <b>2D</b> <b>Text</b> <b>in</b> <b>3D</b> <b>Space</b>
       The  problem  of  placing text in 3D space is the text rotation, which is always counter clockwise around
       the OCS z-axis, and <b>0</b> degree is the direction  of  the  positive  OCS  x-axis,  and  the  OCS  x-axis  is
       calculated by the <u>Arbitrary</u> <u>Axis</u> <u>Algorithm</u>.

       Calculate  the  OCS rotation angle by converting the TEXT rotation angle (in UCS or WCS) into a vector or
       begin with text direction as vector, transform this direction vector into OCS and convert the OCS  vector
       back   into   an   angle   in   the   OCS   xy-plane  (see  example),  this  procedure  is  available  as
       <u>UCS.to_ocs_angle_deg()</u> or <b>UCS.to_ocs_angle_rad()</b>.

       AutoCAD supports thickness for the TEXT entity only for <u>.shx</u> fonts and not for true type fonts.

          # Thickness for text works only with shx fonts not with true type fonts
          doc.styles.new('TXT', dxfattribs={'font': 'romans.shx'})

          ucs = UCS(origin=(0, 2, 2), ux=(1, 0, 0), uz=(0, 1, 1))
          # calculation of text direction as angle in OCS:
          # convert text rotation in degree into a vector in UCS
          text_direction = Vec3.from_deg_angle(-45)
          # transform vector into OCS and get angle of vector in xy-plane
          rotation = ucs.to_ocs(text_direction).angle_deg

          text = msp.add_text(
              text="TEXT",
              dxfattribs={
                  # text rotation angle in degrees in OCS
                  'rotation': rotation,
                  'extrusion': ucs.uz,
                  'thickness': .333,
                  'color': 1,
                  'style': 'TXT',
              })
          # set text position in OCS
          text.set_pos(ucs.to_ocs((0, 0, 0)), align='MIDDLE_CENTER')

       [image: text in ucs as top view] [image] [image: text in ucs as front view] [image]

       <b>HINT:</b>
          For calculating OCS angles from an UCS, be aware that 2D  entities,  like  TEXT  or  ARC,  are  placed
          parallel to the xy-plane of the UCS.

   <b>Placing</b> <b>2D</b> <b>Arc</b> <b>in</b> <b>3D</b> <b>Space</b>
       Here  we  have  the  same  problem  as  for placing text, you need the start- and end angle of the arc in
       degrees in the OCS, and this example also shows a shortcut for calculating the OCS angles.

          ucs = UCS(origin=(0, 2, 2), ux=(1, 0, 0), uz=(0, 1, 1))
          msp.add_arc(
              center=ucs.to_ocs((0, 0)),
              radius=1,
              start_angle=<a href="../man45/ucs.to_ocs_angle_deg.45.html">ucs.to_ocs_angle_deg</a>(45),
              end_angle=<a href="../man270/ucs.to_ocs_angle_deg.270.html">ucs.to_ocs_angle_deg</a>(270),
              dxfattribs={
                  'extrusion': ucs.uz,
                  'color': 1,
              })
          center = ucs.to_wcs((0, 0))
          msp.add_line(
              start=center,
              end=ucs.to_wcs(<a href="../man45/Vec3.from_deg_angle.45.html">Vec3.from_deg_angle</a>(45)),
              dxfattribs={'color': 1},
          )
          msp.add_line(
              start=center,
              end=ucs.to_wcs(<a href="../man270/Vec3.from_deg_angle.270.html">Vec3.from_deg_angle</a>(270)),
              dxfattribs={'color': 1},
          )

       [image: arc in ucs as top view] [image] [image: arc in ucs as front view] [image]

   <b>Placing</b> <b>Block</b> <b>References</b> <b>in</b> <b>3D</b> <b>Space</b>
       Despite the fact that block references (<u>Insert</u>) can contain true 3D  entities  like  <u>Line</u>  or  <u>Mesh</u>,  the
       <u>Insert</u> entity uses the same placing principe as <u>Text</u> or <u>Arc</u> shown in the previous chapters.

       Placement  by  OCS  coordinates  and  rotation  about the OCS z-axis, can be achieved the same way as for
       generic 2D entities.  The DXF attribute <b>Insert.dxf.rotation</b> rotates a block reference  around  the  block
       z-axis,  which  is  located  in  the  <b>Block.dxf.base_point</b>.  To rotate the block reference around the WCS
       x-axis, a transformation of the block z-axis into the WCS x-axis is required by rotating the block z-axis
       90 degree counter-clockwise around y-axis by using an UCS:

       This is just an excerpt of the important parts, see the whole code of <u>insert.py</u> at github.

          # rotate UCS around an arbitrary axis:
          def ucs_rotation(ucs: UCS, axis: Vec3, angle: float):
              # new in ezdxf v0.11: UCS.rotate(axis, angle)
              t = Matrix44.axis_rotate(axis, math.radians(angle))
              ux, uy, uz = t.transform_vertices([ucs.ux, ucs.uy, ucs.uz])
              return UCS(origin=ucs.origin, ux=ux, uy=uy, uz=uz)

          doc = ezdxf.new('R2010', setup=True)
          blk = doc.blocks.new('CSYS')
          setup_csys(blk)
          msp = doc.modelspace()

          ucs = ucs_rotation(UCS(), axis=Y_AXIS, angle=90)
          # transform insert location to OCS
          insert = ucs.to_ocs((0, 0, 0))
          # rotation angle about the z-axis (= WCS x-axis)
          rotation = <a href="../man15/ucs.to_ocs_angle_deg.15.html">ucs.to_ocs_angle_deg</a>(15)
          msp.add_blockref('CSYS', insert, dxfattribs={
             'extrusion': ucs.uz,
             'rotation': rotation,
          })

       [image] [image]

       To rotate a block reference around another axis than the block z-axis,  you  have  to  find  the  rotated
       z-axis  (extrusion  vector) of the rotated block reference, following example rotates the block reference
       around the block x-axis by 15 degrees:

          # t is a transformation matrix to rotate 15 degree around the x-axis
          t = Matrix44.axis_rotate(axis=X_AXIS, angle=<a href="../man15/math.radians.15.html">math.radians</a>(15))
          # transform block z-axis into new UCS z-axis (= extrusion vector)
          uz = Vec3(t.transform(Z_AXIS))
          # create new UCS at the insertion point, because we are rotating around the x-axis,
          # ux is the same as the WCS x-axis and uz is the rotated z-axis.
          ucs = UCS(origin=(1, 2, 0), ux=X_AXIS, uz=uz)
          # transform insert location to OCS, block base_point=(0, 0, 0)
          insert = ucs.to_ocs((0, 0, 0))
          # for this case a rotation around the z-axis is not required
          rotation = 0
          blockref = msp.add_blockref('CSYS', insert, dxfattribs={
              'extrusion': ucs.uz,
              'rotation': rotation,
          })

       [image] [image]

       The next example shows how to translate a block references with an already established OCS:

          # translate a block references with an established OCS
          translation = Vec3(-3, -1, 1)
          # get established OCS
          ocs = blockref.ocs()
          # get insert location in WCS
          actual_wcs_location = ocs.to_wcs(blockref.dxf.insert)
          # translate location
          new_wcs_location = actual_wcs_location + translation
          # convert WCS location to OCS location
          blockref.dxf.insert = ocs.from_wcs(new_wcs_location)

       Setting a new insert location is the same procedure without adding a translation vector,  just  transform
       the new insert location into the OCS.  [image] [image]

       The  next  operation  is  to rotate a block reference with an established OCS, rotation axis is the block
       y-axis, rotation angle is -90 degrees. First transform block y-axis  (rotation  axis)  and  block  z-axis
       (extrusion vector) from OCS into WCS:

          # rotate a block references with an established OCS around the block y-axis about 90 degree
          ocs = blockref.ocs()
          # convert block y-axis (= rotation axis) into WCS vector
          rotation_axis = ocs.to_wcs((0, 1, 0))
          # convert local z-axis (=extrusion vector) into WCS vector
          local_z_axis = ocs.to_wcs((0, 0, 1))

       Build transformation matrix and transform extrusion vector and build new UCS:

          # build transformation matrix
          t = Matrix44.axis_rotate(axis=rotation_axis, angle=math.radians(-90))
          uz = t.transform(local_z_axis)
          uy = rotation_axis
          # the block reference origin stays at the same location, no rotation needed
          wcs_insert = ocs.to_wcs(blockref.dxf.insert)
          # build new UCS to convert WCS locations and angles into OCS
          ucs = UCS(origin=wcs_insert, uy=uy, uz=uz)

       Set new OCS attributes, we also have to set the rotation attribute even though we do not rotate the block
       reference  around  the  local  z-axis, the new block x-axis (0 deg) differs from OCS x-axis and has to be
       adjusted:

          # set new OCS
          blockref.dxf.extrusion = ucs.uz
          # set new insert
          blockref.dxf.insert = ucs.to_ocs((0, 0, 0))
          # set new rotation: we do not rotate the block reference around the local z-axis,
          # but the new block x-axis (0 deg) differs from OCS x-axis and has to be adjusted
          blockref.dxf.rotation = <a href="../man0/ucs.to_ocs_angle_deg.0.html">ucs.to_ocs_angle_deg</a>(0)

       [image] [image]

       And here is the point, where my math knowledge ends, for more advanced CAD operation  you  have  to  look
       elsewhere.

   <b>Tutorial</b> <b>for</b> <b>UCS</b> <b>Based</b> <b>Transformations</b>
       The  <u>ezdxf</u>  version  v0.13  introduced a transformation interface for DXF primitives, which makes working
       with OCS/UCS much easier.  This is a new edition of the <u>Tutorial</u> <u>for</u> <u>OCS/UCS</u> <u>Usage</u>.  Please read the  old
       tutorial for the basics about the OCS.

       For  this  tutorial  we  don’t  have  to  worry  about  the  OCS  and  the extrusion vector, this is done
       automatically by the <b>transform()</b> method of each DXF entity.

   <b>Placing</b> <b>2D</b> <b>Circle</b> <b>in</b> <b>3D</b> <b>Space</b>
       To recreate the situation of the old tutorial instantiate a new  UCS  and  rotate  it  around  the  local
       x-axis.   Use UCS coordinates to place the 2D CIRCLE in 3D space and transform the UCS coordinates to the
       WCS.

          import math
          import ezdxf
          from ezdxf.math import UCS

          doc = ezdxf.new('R2010')
          msp = doc.modelspace()

          ucs = UCS()  # New default UCS
          # All rotation angles in radians, and rotation
          # methods always return a new UCS.
          ucs = ucs.rotate_local_x(math.radians(-45))
          circle = msp.add_circle(
              # Use UCS coordinates to place the 2d circle in 3d space
              center=(0, 0, 2),
              radius=1,
              dxfattribs={'color': 1}
          )
          circle.transform(ucs.matrix)

          # mark center point of circle in WCS
          msp.add_point((0, 0, 2), dxfattribs={'color': 1}).transform(ucs.matrix)

       [image: circle in ucs as side view] [image] [image: circle in ucs as front view] [image]

   <b>Placing</b> <b>LWPolyline</b> <b>in</b> <b>3D</b> <b>Space</b>
       Simplified LWPOLYLINE example:

          # The center of the pentagon should be (0, 2, 2), and the shape is
          # rotated around x-axis about -45 degree
          ucs = UCS(origin=(0, 2, 2)).rotate_local_x(math.radians(-45))

          msp.add_lwpolyline(
              # calculating corner points in UCS coordinates
              points=(Vec3.from_deg_angle((360 / 5) * n) for n in <a href="../man5/range.5.html">range</a>(5)),
              format='xy',  # ignore z-axis
              close=True,
              dxfattribs={
                  'color': 1,
              }
          ).transform(ucs.matrix)

       The 2D pentagon in 3D space in BricsCAD <u>Left</u> and <u>Front</u> view.  [image:  pentagon  in  ucs  as  side  view]
       [image] [image: pentagon in ucs as front view] [image]

   <b>Using</b> <b>UCS</b> <b>to</b> <b>Place</b> <b>3D</b> <b>Polyline</b>
       Simplified  POLYLINE  example:  Using a first UCS to transform the POLYLINE and a second UCS to place the
       POLYLINE in 3D space.

          # using an UCS simplifies 3D operations, but UCS definition can happen later
          # calculating corner points in local (UCS) coordinates without Vec3 class
          angle = math.radians(360 / 5)
          corners_ucs = [(math.cos(angle * n), math.sin(angle * n), 0) for n in <a href="../man5/range.5.html">range</a>(5)]

          # let's do some transformations by UCS
          transformation_ucs = UCS().rotate_local_z(<a href="../man15/math.radians.15.html">math.radians</a>(15))  # 1. rotation around z-axis
          transformation_ucs.shift((0, .333, .333))  # 2. translation (inplace)
          corners_ucs = list(transformation_ucs.points_to_wcs(corners_ucs))

          location_ucs = UCS(origin=(0, 2, 2)).rotate_local_x(math.radians(-45))
          msp.add_polyline3d(
              points=corners_ucs,
              close=True,
              dxfattribs={
                  'color': 1,
              }
          ).transform(location_ucs.matrix)

          # Add lines from the center of the POLYLINE to the corners
          center_ucs = transformation_ucs.to_wcs((0, 0, 0))
          for corner in corners_ucs:
              msp.add_line(
                  center_ucs, corner, dxfattribs={'color': 1}
              ).transform(location_ucs.matrix)

       [image: 3d poyline with UCS] [image]

   <b>Placing</b> <b>2D</b> <b>Text</b> <b>in</b> <b>3D</b> <b>Space</b>
       The problem with the text rotation in the old tutorial disappears with the new UCS  based  transformation
       method:

       AutoCAD supports thickness for the TEXT entity only for <u>.shx</u> fonts and not for true type fonts.

          # thickness for text works only with shx fonts not with true type fonts
          doc.styles.new('TXT', dxfattribs={'font': 'romans.shx'})

          ucs = UCS(origin=(0, 2, 2)).rotate_local_x(math.radians(-45))
          text = msp.add_text(
              text="TEXT",
              dxfattribs={
                  # text rotation angle in degrees in UCS
                  'rotation': -45,
                  'thickness': .333,
                  'color': 1,
                  'style': 'TXT',
              }
          )
          # set text position in UCS
          text.set_pos((0, 0, 0), align='MIDDLE_CENTER')
          text.transform(ucs.matrix)

       [image: text in ucs as top view] [image] [image: text in ucs as front view] [image]

   <b>Placing</b> <b>2D</b> <b>Arc</b> <b>in</b> <b>3D</b> <b>Space</b>
       Same as for the text example, OCS angle transformation can be ignored:

          ucs = UCS(origin=(0, 2, 2)).rotate_local_x(math.radians(-45))

          CENTER = (0, 0)
          START_ANGLE = 45
          END_ANGLE = 270

          msp.add_arc(
              center=CENTER,
              radius=1,
              start_angle=START_ANGLE,
              end_angle=END_ANGLE,
              dxfattribs={'color': 6},
          ).transform(ucs.matrix)

          msp.add_line(
              start=CENTER,
              end=Vec3.from_deg_angle(START_ANGLE),
              dxfattribs={'color': 6},
          ).transform(ucs.matrix)

          msp.add_line(
              start=CENTER,
              end=Vec3.from_deg_angle(END_ANGLE),
              dxfattribs={'color': 6},
          ).transform(ucs.matrix)

       [image: arc in ucs as top view] [image] [image: arc in ucs as front view] [image]

   <b>Placing</b> <b>Block</b> <b>References</b> <b>in</b> <b>3D</b> <b>Space</b>
       Despite  the  fact  that  block  references  (INSERT) can contain true 3D entities like LINE or MESH, the
       INSERT entity uses the same placing principe as TEXT or ARC shown in the previous sections.

       To rotate the block reference 15 degrees around the WCS x-axis, we  place  the  block  reference  in  the
       origin  of  the  UCS, and rotate the UCS 90 degrees around its local y-axis, to align the UCS z-axis with
       the WCS x-axis:

       This is just an excerpt of the important parts, see the whole code of <u>insert.py</u> at github.

          doc = ezdxf.new('R2010', setup=True)
          blk = doc.blocks.new('CSYS')
          setup_csys(blk)
          msp = doc.modelspace()

          ucs = UCS().rotate_local_y(angle=<a href="../man90/math.radians.90.html">math.radians</a>(90))
          msp.add_blockref(
              'CSYS',
              insert=(0, 0),
              # rotation around the block z-axis (= WCS x-axis)
              dxfattribs={'rotation': 15},
          ).transform(ucs.matrix)

       [image] [image]

       A more simple approach is to ignore the <b>rotate</b> attribute at all and just rotate the  UCS.   To  rotate  a
       block  reference  around any axis rather than the block z-axis, rotate the UCS into the desired position.
       The following example rotates the block reference around the block x-axis by 15 degrees:

          ucs = UCS(origin=(1, 2, 0)).rotate_local_x(<a href="../man15/math.radians.15.html">math.radians</a>(15))
          blockref = msp.add_blockref('CSYS', insert=(0, 0, 0))
          blockref.transform(ucs.matrix)

       [image] [image]

       The next example shows how to translate a block references with an already established OCS:

          # New UCS at the translated location, axis aligned to the WCS
          ucs = UCS((-3, -1, 1))
          # Transform an already placed block reference, including
          # the transformation of the established OCS.
          blockref.transform(ucs.matrix)

       [image] [image]

       The next operation is to rotate a block reference with an established OCS, rotation  axis  is  the  block
       y-axis,  rotation  angle is -90 degrees. The idea is to create an UCS in the origin of the already placed
       block reference, UCS axis aligned to the block axis and resetting the block reference  parameters  for  a
       new WCS transformation.

          # Get UCS at the block reference insert location, UCS axis aligned
          # to the block axis.
          ucs = blockref.ucs()
          # Rotate UCS around the local y-axis.
          ucs = ucs.rotate_local_y(math.radians(-90))

       Reset  block reference parameters, this places the block reference in the UCS origin and aligns the block
       axis to the UCS axis, now we do a new transformation from UCS to WCS:

          # Reset block reference parameters to place block reference in
          # UCS origin, without any rotation and OCS.
          blockref.reset_transformation()

          # Transform block reference from UCS to WCS
          blockref.transform(ucs.matrix)

       [image] [image]

   <b>Tutorial</b> <b>for</b> <b>Linear</b> <b>Dimensions</b>
       The <u>Dimension</u> entity is the generic entity for all dimension types,  but  unfortunately  AutoCAD  is  <b>not</b>
       <b>willing</b>  to show a dimension line defined only by this dimension entity, it also needs an anonymous block
       which contains the dimension line shape constructed by DXF primitives like LINE and TEXT  entities,  this
       representation is called the dimension line <u>rendering</u> in this documentation, beside the fact that this is
       not  a  real  graphical  rendering.   BricsCAD is a much more friendly CAD application, which do show the
       dimension entity without the graphical rendering as block, which was very  useful  for  testing,  because
       there  is  no documentation how to apply all the dimension style variables (more than 80).  This seems to
       be the reason why dimension lines are rendered so differently by many CAD application.

       Don’t expect to get the same rendering results by <u>ezdxf</u> as you get from AutoCAD. <u>Ezdxf</u>  tries  to  be  as
       close  to  the  results  rendered  by  BricsCAD,  but  it  is  not  possible to implement all the various
       combinations of dimension style parameters, which often affect one another.

       <b>NOTE:</b>
          <u>Ezdxf</u> does not consider all DIMSTYLE variables, so  the  rendering  results  are  different  from  CAD
          applications.

       Text  rendering  is  another  problem, because <u>ezdxf</u> has no real rendering engine.  Some font properties,
       like the real text width, which is only available to <u>ezdxf</u> if the <u>Matplotlib</u>  package  is  installed  and
       this  value  may  also  vary  slightly  for different CAD applications.  Without access to the <u>Matplotlib</u>
       package the text properties in <u>ezdxf</u> are based on  an  abstract  monospaced  font  and  are  bigger  than
       required by true type fonts.

       Not  all  DIMENSION  and DIMSTYLE features are supported by all DXF versions, especially DXF R12 does not
       support many features, but in this case the required  rendering  of  dimension  lines  is  an  advantage,
       because  if the application just shows the rendered block, all features which can be used in DXF R12 will
       be displayed, but these features will disappear  if  the  dimension  line  will  be  edited  in  the  CAD
       application.  <u>Ezdxf</u> writes only the supported DIMVARS of the used DXF version to avoid invalid DXF files.
       So it is not that critical to know all the supported features of a DXF version,  except  for  limits  and
       tolerances,  <u>ezdxf</u>  uses  the  advanced  features of the MTEXT entity to create limits and tolerances and
       therefore they are not supported (displayed) in DXF R12 files.

       <b>SEE</b> <b>ALSO:</b>

          • Graphical reference of many DIMVARS and some advanced information: <u>DIMSTYLE</u> <u>Table</u>

          • Source code file <u>standards.py</u> shows how to create your own DIMSTYLES.

          • The Script <u>dimension_linear.py</u> shows examples for linear dimensions.

   <b>Horizontal</b> <b>Dimension</b>
          import ezdxf

          # Create a DXF R2010 document:
          # Use argument setup=True to setup the default dimension styles.
          doc = ezdxf.new("R2010", setup=True)

          # Add new dimension entities to the modelspace:
          msp = doc.modelspace()

          # Add a LINE entity for visualization, not required to create the DIMENSION
          # entity:
          msp.add_line((0, 0), (3, 0))

          # Add a horizontal linear DIMENSION entity:
          dim = msp.add_linear_dim(
              base=(3, 2),  # location of the dimension line
              p1=(0, 0),  # 1st measurement point
              p2=(3, 0),  # 2nd measurement point
              dimstyle="EZDXF",  # default dimension style
          )

          # Necessary second step to create the BLOCK entity with the dimension geometry.
          # Additional processing of the DIMENSION entity could happen between adding
          # the entity and the rendering call.
          dim.render()
          doc.saveas("dim_linear_horiz.dxf")
       [image]

       The example above creates a horizontal <u>Dimension</u> entity.  The default dimension style “EZDXF” is  defined
       as:

       • 1 drawing unit = 1m

       • measurement text height = 0.25 (drawing scale = 1:100)

       • the length factor <b>dimlfac</b> = 100, which creates a measurement text in cm.

       • arrow is “ARCHTICK”, arrow size <b>dimasz</b> = 0.175

       Every  dimension  style  which  does  not exist will be replaced by the dimension style “Standard” at DXF
       export by <b>save()</b> or <b>saveas()</b> (e.g. dimension style setup was not initiated).

       The <u>base</u> point defines the location of the dimension line, <u>ezdxf</u> accepts any point on the dimension line,
       the point <u>p1</u> defines the start  point  of  the  first  extension  line,  which  also  defines  the  first
       measurement  point  and  the  point  <u>p2</u>  defines the start point of the second extension line, which also
       defines the second measurement point.

       The return value <u>dim</u> is <b>not</b> a dimension entity,  instead  a  <u>DimStyleOverride</u>  object  is  returned,  the
       dimension entity is stored as attribute <b>dim.dimension</b>.

   <b>Vertical</b> <b>and</b> <b>Rotated</b> <b>Dimension</b>
       Argument  <u>angle</u>  defines  the  angle  of  the dimension line in relation to the x-axis of the WCS or UCS,
       measurement is the distance between first and second measurement point in direction of <u>angle</u>.

          # assignment to dim is not necessary, if no additional processing happens
          msp.add_linear_dim(base=(3, 2), p1=(0, 0), p2=(3, 0), angle=-30).render()
          doc.saveas("dim_linear_rotated.dxf")
       [image]

       For a vertical dimension set argument <u>angle</u> to 90 degree, but in this example the vertical distance would
       be 0.

   <b>Aligned</b> <b>Dimension</b>
       An aligned dimension line is parallel to the line defined  by  the  definition  points  <u>p1</u>  and  <u>p2</u>.  The
       placement  of  the  dimension line is defined by the argument <u>distance</u>, which is the distance between the
       definition line and the dimension line. The <u>distance</u> of the dimension line is orthogonal to the base line
       in counter clockwise orientation.

          msp.add_line((0, 2), (3, 0))
          dim = msp.add_aligned_dim(p1=(0, 2), p2=(3, 0), distance=1)
          doc.saveas("dim_linear_aligned.dxf")
       [image]

   <b>Dimension</b> <b>Style</b> <b>Override</b>
       Many dimension styling options are defined by the associated <u>DimStyle</u> entity.  But often you wanna change
       just a few settings without creating a new dimension style, therefore the DXF format has  a  protocol  to
       store  this  changed  settings  in  the dimension entity itself.  This protocol is supported by <u>ezdxf</u> and
       every factory function which creates dimension entities supports the <u>override</u>  argument.   This  <u>override</u>
       argument  is  a  simple  Python  dictionary (e.g.  <b>override</b> <b>=</b> <b>{"dimtad":</b> <b>4}</b>, place measurement text below
       dimension line).

       The overriding protocol is managed by  the  <u>DimStyleOverride</u>  object,  which  is  returned  by  the  most
       dimension factory functions.

   <b>Placing</b> <b>Measurement</b> <b>Text</b>
       The  default location of the measurement text depends on various <u>DimStyle</u> parameters and is applied if no
       user defined text location is defined.

   <b>Default</b> <b>Text</b> <b>Locations</b>
       “Horizontal direction”  means  in  direction  of  the  dimension  line  and  “vertical  direction”  means
       perpendicular to the dimension line direction.

       The <b>“horizontal”</b> location of the measurement text is defined by <u>dimjust</u>:
                                    ┌───┬───────────────────────────────────────┐
                                    │ 0 │ Center of dimension line              │
                                    ├───┼───────────────────────────────────────┤
                                    │ 1 │ Left side of the dimension line, near │
                                    │   │ first extension line                  │
                                    ├───┼───────────────────────────────────────┤
                                    │ 2 │ Right  side  of  the  dimension line, │
                                    │   │ near second extension line            │
                                    ├───┼───────────────────────────────────────┤
                                    │ 3 │ Over first extension line             │
                                    ├───┼───────────────────────────────────────┤
                                    │ 4 │ Over second extension line            │
                                    └───┴───────────────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2), p1=(0, 0), p2=(3, 0), override={"dimjust": 1}
          ).render()
       [image]

       The <b>“vertical”</b> location of the measurement text relative to the dimension line is defined by <u>dimtad</u>:
                                    ┌───┬───────────────────────────────────────┐
                                    │ 0 │ Center, it is possible to adjust  the │
                                    │   │ vertical location by <u>dimtvp</u>           │
                                    ├───┼───────────────────────────────────────┤
                                    │ 1 │ Above                                 │
                                    ├───┼───────────────────────────────────────┤
                                    │ 2 │ Outside, handled like <u>Above</u> by <u>ezdxf</u>  │
                                    ├───┼───────────────────────────────────────┤
                                    │ 3 │ JIS, handled like <u>Above</u> by <u>ezdxf</u>      │
                                    ├───┼───────────────────────────────────────┤
                                    │ 4 │ Below                                 │
                                    └───┴───────────────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2), p1=(0, 0), p2=(3, 0), override={"dimtad": 4}
          ).render()
       [image]

       The distance between text and dimension line is defined by <u>dimgap</u>.

       The  <u>DimStyleOverride</u>  object  has  a method <u>set_text_align()</u> to set the default text location in an easy
       way, this is also the reason for the 2 step creation process of dimension entities:

          dim = msp.add_linear_dim(base=(3, 2), p1=(0, 0), p2=(3, 0))
          dim.set_text_align(halign="left", valign="center")
          dim.render()
                                  ┌────────┬───────────────────────────────────────┐
                                  │ halign │ “left”, “right”, “center”,  “above1”, │
                                  │        │ “above2”                              │
                                  ├────────┼───────────────────────────────────────┤
                                  │ valign │ “above”, “center”, “below”            │
                                  └────────┴───────────────────────────────────────┘

       Run  function <b>example_for_all_text_placings_R2007()</b> in the example script <u>dimension_linear.py</u> to create a
       DXF file with all text placings supported by <u>ezdxf</u>.

   <b>User</b> <b>Defined</b> <b>Text</b> <b>Locations</b>
       Beside the default location, it is possible to locate the measurement text freely.

   <b>Location</b> <b>Relative</b> <b>to</b> <b>Origin</b>
       The user defined text location can be set by the argument <u>location</u> in most  dimension  factory  functions
       and always references the midpoint of the measurement text:

          msp.add_linear_dim(
              base=(3, 2), p1=(3, 0), p2=(6, 0), location=(4, 4)
          ).render()
       [image]

       The <u>location</u> is relative to the origin of the active coordinate system or WCS if no UCS is defined in the
       <u>render()</u> method, the user defined <u>location</u> can also be set by <u>user_location_override()</u>.

   <b>Location</b> <b>Relative</b> <b>to</b> <b>Center</b> <b>of</b> <b>Dimension</b> <b>Line</b>
       The  method  <u>set_location()</u> has additional features for linear dimensions.  Argument <u>leader</u> = <b>True</b> adds a
       simple leader from the measurement text to the center of the dimension line and argument <u>relative</u> =  <b>True</b>
       places the measurement text relative to the center of the dimension line.

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_location(location=(-1, 1), leader=True, relative=True)
          dim.render()
       [image]

   <b>Location</b> <b>Relative</b> <b>to</b> <b>Default</b> <b>Location</b>
       The  method  <u>shift_text()</u>  shifts  the measurement text away from the default text location. The shifting
       directions are aligned to the text direction, which is the direction of the dimension line in most cases,
       <u>dh</u> (for delta horizontal) shifts the text parallel to the text direction, <u>dv</u> (for delta vertical)  shifts
       the text perpendicular to the text direction. This method does not support leaders.

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.shift_text(dh=1, dv=1)
          dim.render()
       [image]

   <b>Overriding</b> <b>Text</b> <b>Rotation</b>
       All  factory  methods  supporting  the argument <u>text_rotation</u> can override the measurement text rotation.
       The user defined rotation is relative to the render UCS x-axis (default is WCS).

   <b>Measurement</b> <b>Text</b> <b>Formatting</b> <b>and</b> <b>Styling</b>
   <b>Text</b> <b>Properties</b>
                                 ┌──────────┬───────────────────────────────────────┐
                                 │ DIMVAR   │ Description                           │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimtxsty</b> │ Specifies  the  text  style  of   the │
                                 │          │ dimension as <u>Textstyle</u> name.          │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimtxt</b>   │ Text height in drawing units.         │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimclrt</b>  │ Measurement  text  color  as  <u>AutoCAD</u> │
                                 │          │ <u>Color</u> <u>Index</u> <u>(ACI)</u>.                    │
                                 └──────────┴───────────────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimtxsty": "Standard",
                  "dimtxt": 0.35,
                  "dimclrt": 1,
              }
          ).render()
       [image]

   <b>Background</b> <b>Filling</b>
       Background fillings are supported since DXF R2007, and <u>ezdxf</u> uses the  MTEXT  entity  to  implement  this
       feature,  so setting background filling in DXF R12 has no effect. The DIMVAR <u>dimtfill</u> defines the kind of
       background filling and the DIMVAR <u>dimtfillclr</u> defines the fill color.
                               ┌─────────────┬───────────────────────────────────────┐
                               │ DIMVAR      │ Description                           │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>dimtfill</b>    │ Enables background filling if  bigger │
                               │             │ than 0                                │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>dimtfillclr</b> │ Fill  color  as  <u>AutoCAD</u>  <u>Color</u> <u>Index</u> │
                               │             │ <u>(ACI)</u>, if <b>dimtfill</b> is 2               │
                               └─────────────┴───────────────────────────────────────┘
                                     ┌──────────┬──────────────────────────────┐
                                     │ <b>dimtfill</b> │ Description                  │
                                     ├──────────┼──────────────────────────────┤
                                     │ 0        │ disabled                     │
                                     ├──────────┼──────────────────────────────┤
                                     │ 1        │ canvas color                 │
                                     ├──────────┼──────────────────────────────┤
                                     │ 2        │ color defined by <b>dimtfillclr</b> │
                                     └──────────┴──────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimtfill": 2,
                  "dimtfillclr": 1,
              }
          ).render()
       [image]

   <b>Text</b> <b>Formatting</b>
       • <b>decimal</b> <b>places</b>: <u>dimdec</u> defines the number of decimal places  displayed  for  the  primary  units  of  a
         dimension. (DXF R2000)

       • <b>decimal</b>  <b>point</b>  <b>character</b>:  <u>dimdsep</u>  defines  the  decimal  point  as ASCII code, get the ASCII code by
         <b>ord('.')</b>

       • <b>rounding</b>: <u>dimrnd</u>, rounds all dimensioning distances to the specified value, for instance, if <b>dimrnd</b>  is
         set to 0.25, all distances round to the nearest 0.25 unit. If <b>dimrnd</b> is set to 1.0, all distances round
         to  the  nearest  integer.  For  more  information look at the documentation of the <u>ezdxf.math.xround()</u>
         function.

       • <b>zero</b> <b>trimming</b>: <u>dimzin</u>, <u>ezdxf</u> supports only a subset of values:

            • 4 to suppress leading zeros

            • 8 to suppress trailing zeros

            • 12 as the combination of both

       • <b>measurement</b> <b>factor</b>: scale measurement by factor <u>dimlfac</u>, e.g. to get the dimensioning text in cm for  a
         DXF file where 1 drawing unit represents 1m, set <b>dimlfac</b> to 100.

       • <b>text</b>  <b>template</b>:  <u>dimpost</u>,  “&lt;&gt;”  represents  the  measurement  text, e.g. “~&lt;&gt;cm” produces “~300cm” for
         measurement in previous example.

       To       set       this       values       the       <u>ezdxf.entities.DimStyle.set_text_format()</u>        and
       <u>ezdxf.entities.DimStyleOverride.set_text_format()</u> methods are very recommended.

   <b>Overriding</b> <b>Measurement</b> <b>Text</b>
       This feature allows overriding the real measurement text by a custom measurement text, the text is stored
       as string in the <u>Dimension</u> entity as attribute <u>text</u>.  Special values of the <b>text</b> attribute are: one space
       “ “ to suppress the measurement text at all, an empty string “”  or “&lt;&gt;” to display the real measurement.

       All  factory  functions  have  an  explicit  <u>text</u>  argument,  which always replaces the <u>text</u> value in the
       <u>dxfattribs</u> dict.

          msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0), text="&gt;1m").render()
       [image]

   <b>Dimension</b> <b>Line</b> <b>Properties</b>
       The <u>dimension</u> <u>line</u> <u>color</u> is defined by the DIMVAR <b>dimclrd</b> as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>, <b>dimclrd</b> and  also
       defines  the  color  of  the  arrows.  The  <u>linetype</u>  is  defined by <b>dimltype</b> and requires DXF R2007. The
       <u>lineweight</u> is defined by <b>dimlwd</b> and requires DXF R2000, see  also  the  <u>lineweight</u>  reference  for  valid
       values.   The  <b>dimdle</b>  is  the extension of the dimension line beyond the extension lines, this dimension
       line extension is not supported for all arrows.
                                 ┌──────────┬───────────────────────────────────────┐
                                 │ DIMVAR   │ Description                           │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimclrd</b>  │ dimension line and  arrows  color  as │
                                 │          │ <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>             │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimltype</b> │ linetype of dimension line            │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimlwd</b>   │ line weight of dimension line         │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimdle</b>   │ extension   of   dimension   line  in │
                                 │          │ drawing units                         │
                                 └──────────┴───────────────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimclrd": 1,  # red
                  "dimdle": 0.25,
                  "dimltype": "DASHED2",
                  "dimlwd": 35,  # 0.35mm line weight
              }
          ).render()
       [image]

       <u>DimStyleOverride()</u> method:

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_dimline_format(
              color=1, linetype="DASHED2", lineweight=35, extension=0.25
          )
          dim.render()

   <b>Extension</b> <b>Line</b> <b>Properties</b>
       The <u>extension</u> <u>line</u> <u>color</u> is defined by the DIMVAR <b>dimclre</b> as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>.  The <u>linetype</u> for
       the first and the second extension line is defined by <b>dimltex1</b> and <b>dimltex2</b> and requires DXF R2007.   The
       <u>lineweight</u>  is  defined  by  <b>dimlwe</b>  and  required DXF R2000, see also the <u>lineweight</u> reference for valid
       values.

       The <b>dimexe</b> is the extension of the extension line beyond the  dimension  line,  and  <b>dimexo</b>  defines  the
       offset of the extension line from the measurement point.
                                 ┌──────────┬───────────────────────────────────────┐
                                 │ DIMVAR   │ Description                           │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimclre</b>  │ extension line color as <u>AutoCAD</u> <u>Color</u> │
                                 │          │ <u>Index</u> <u>(ACI)</u>                           │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimltex1</b> │ linetype of first extension line      │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimltex2</b> │ linetype of second extension line     │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimlwe</b>   │ line weight of extension line         │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimexe</b>   │ extension  beyond  dimension  line in │
                                 │          │ drawing units                         │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimexo</b>   │ offset   of   extension   line   from │
                                 │          │ measurement point                     │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimfxlon</b> │ set  to  1  to  enable  fixed  length │
                                 │          │ extension line                        │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimfxl</b>   │ length of fixed length extension line │
                                 │          │ in drawing units                      │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimse1</b>   │ suppress first extension line if 1    │
                                 ├──────────┼───────────────────────────────────────┤
                                 │ <b>dimse2</b>   │ suppress second extension line if 1   │
                                 └──────────┴───────────────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimclre": 1,   # red
                  "dimltex1": "DASHED2",
                  "dimltex2": "CENTER2",
                  "dimlwe": 35,   # 0.35mm line weight
                  "dimexe": 0.3,  # length above dimension line
                  "dimexo": 0.1,  # offset from measurement point
              }
          ).render()
       [image]

       <u>DimStyleOverride()</u> methods:

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_extline_format(color=1, lineweight=35, extension=0.3, offset=0.1)
          dim.set_extline1(linetype="DASHED2")
          dim.set_extline2(linetype="CENTER2")
          dim.render()

       Fixed length extension lines are supported in DXF R2007, set <b>dimfxlon</b> to 1 and <b>dimfxl</b> defines the  length
       of the extension line starting at the dimension line.

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimfxlon": 1,  # fixed length extension lines
                  "dimexe": 0.2,  # length above dimension line
                  "dimfxl": 0.4,  # length below dimension line
              }
          ).render()
       [image]

       <u>DimStyleOverride()</u> method:

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_extline_format(extension=0.2, fixed_length=0.4)
          dim.render()

       To  suppress  extension  lines  set  <b>dimse1</b>  to 1 to suppress the first extension line and <b>dimse2</b> to 1 to
       suppress the second extension line.

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimse1": 1,  # suppress first extension line
                  "dimse2": 1,  # suppress second extension line
                  "dimblk": ezdxf.ARROWS.closed_filled,  # arrows just looks better
              }
          ).render()
       [image]

       <u>DimStyleOverride()</u> methods:

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_arrows(blk=ezdxf.ARROWS.closed_filled)
          dim.set_extline1(disable=True)
          dim.set_extline2(disable=True)
          dim.render()

   <b>Arrows</b>
       “Arrows” mark then beginning and the end of a dimension line, and most of them do not look like arrows.

       DXF distinguish between the simple tick (a slanted line) and arrows as blocks.

       To use a simple tick as “arrow” set <u>dimtsz</u> to a value greater than 0, this also disables arrow blocks  as
       side effect:

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_tick(size=0.25)
          dim.render()

       <u>Ezdxf</u>  uses  the  “ARCHTICK”  block  at  double size to render the tick (AutoCAD and BricsCad just draw a
       simple line), so there is no advantage of using the tick instead of an arrow.

       Using arrows:

          dim = msp.add_linear_dim(base=(3, 2), p1=(3, 0), p2=(6, 0))
          dim.set_arrow(blk="OPEN_30", size=0.25)
          dim.render()
                                 ┌─────────┬───────────────────────────────────────┐
                                 │ DIMVAR  │ Description                           │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <b>dimtsz</b>  │ tick size in drawing units, set to  0 │
                                 │         │ to use arrows                         │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <b>dimblk</b>  │ set both arrow block names at once    │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <b>dimblk1</b> │ first arrow block name                │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <b>dimblk2</b> │ second arrow block name               │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <b>dimasz</b>  │ arrow size in drawing units           │
                                 └─────────┴───────────────────────────────────────┘

          msp.add_linear_dim(
              base=(3, 2),
              p1=(3, 0),
              p2=(6, 0),
              override={
                  "dimtsz": 0,  # set tick size to 0 to enable arrow usage
                  "dimasz": 0.25,  # arrow size in drawing units
                  "dimblk": "OPEN_30",  # arrow block name
              }
          ).render()

       The dimension line extension (<b>dimdle</b>) works only for a few arrow blocks and the simple tick:

       • “ARCHTICK”

       • “OBLIQUE”

       • “NONE”

       • “SMALL”

       • “DOTSMALL”

       • “INTEGRAL”

   <b>Arrow</b> <b>Shapes</b>
       [image]

   <b>Arrow</b> <b>Names</b>
       The arrow names are stored as attributes in the <b>ezdxf.ARROWS</b> object.
                                    ─────────────────────────────────────────────
                                      closed_filled           “” (empty string)
                                    ─────────────────────────────────────────────
                                      dot                     “DOT”
                                    ─────────────────────────────────────────────
                                      dot_small               “DOTSMALL”
                                    ─────────────────────────────────────────────
                                      dot_blank               “DOTBLANK”
                                    ─────────────────────────────────────────────
                                      origin_indicator        “ORIGIN”
                                    ─────────────────────────────────────────────
                                      origin_indicator_2      “ORIGIN2”
                                    ─────────────────────────────────────────────
                                      open                    “OPEN”
                                    ─────────────────────────────────────────────
                                      right_angle             “OPEN90”
                                    ─────────────────────────────────────────────
                                      open_30                 “OPEN30”
                                    ─────────────────────────────────────────────
                                      closed                  “CLOSED”
                                    ─────────────────────────────────────────────
                                      dot_smallblank          “SMALL”
                                    ─────────────────────────────────────────────
                                      none                    “NONE”
                                    ─────────────────────────────────────────────
                                      oblique                 “OBLIQUE”
                                    ─────────────────────────────────────────────
                                      box_filled              “BOXFILLED”
                                    ─────────────────────────────────────────────
                                      box                     “BOXBLANK”
                                    ─────────────────────────────────────────────
                                      closed_blank            “CLOSEDBLANK”
                                    ─────────────────────────────────────────────
                                      datum_triangle_filled   “DATUMFILLED”
                                    ─────────────────────────────────────────────
                                      datum_triangle          “DATUMBLANK”
                                    ─────────────────────────────────────────────
                                      integral                “INTEGRAL”
                                    ─────────────────────────────────────────────
                                      architectural_tick      “ARCHTICK”
                                    ─────────────────────────────────────────────
                                      ez_arrow                “EZ_ARROW”
                                    ─────────────────────────────────────────────
                                      ez_arrow_blank          “EZ_ARROW_BLANK”
                                    ─────────────────────────────────────────────
                                      ez_arrow_filled         “EZ_ARROW_FILLED”
                                    ┌───────────────────────┬───────────────────┐
                                    │                       │                   │
   <b>Tolerances</b> <b>and</b> <b>Limits</b>            │                       │                   │
--
</pre><h4><b>EXTERNAL</b> <b>REFERENCES</b> <b>(XREF)</b></h4><pre>
       New in version 1.1.

       Attached XREFs are links to the modelspace of a specified drawing file. Changes made  to  the  referenced
       drawing are automatically reflected in the current drawing when it’s opened or if the XREF is reloaded.

       XREFs  can  be nested within other XREFs: that is, you can attach an XREF that contains another XREF. You
       can attach as many copies of an XREF as you want, and each copy can have a different position, scale, and
       rotation.

       You can also overlay an XREF on your drawing. Unlike an attached XREF, an overlaid XREF is  not  included
       when the drawing is itself attached or overlaid as an XREF to another drawing.

   <b>DXF</b> <b>Files</b> <b>as</b> <b>Attached</b> <b>XREFs</b>
       <b>IMPORTANT:</b>
          AutoCAD  can  only  display  DWG  files  as  attached  XREFs  but  <u>ezdxf</u>  can  only  create DXF files.
          Consequently, any DXF file attached as an XREF to a DXF document must be converted to DWG in order  to
          be  viewed  in  AutoCAD.   Fortunately,  other  CAD applications are more cooperative, BricsCAD has no
          problem displaying DXF files as XREFs, although it is not possible to attach a DXF file as an XREF  in
          the BricsCAD application itself.

       The <u>ezdxf.xref</u> module provides an interface for working with XREFs.

          • <u>attach()</u> - attach a DXF/DWG file as XREF

          • <u>detach()</u> - detach a BLOCK definition as XREF

          • <u>embed()</u> - embed an XREF as a BLOCK definition

          • <u>dxf_info()</u> - scans a DXF file for basic settings and properties

       For  loading the content of DWG files is a loading function required, which loads the DWG file as <b>Drawing</b>
       document. The <u>odafc</u> add-on module provides such a function: <u>readfile()</u>

       <b>SEE</b> <b>ALSO:</b>

          • <u>Tutorial</u> <u>for</u> <u>External</u> <u>References</u>

   <b>XREF</b> <b>Structures</b>
       An XREF is a normal block definition located in the BLOCKS section with special flags set and a  filename
       to  the  referenced  DXF/DWG  file  and  without  any content, the block content is the modelspace of the
       referenced file.  An XREF can be referenced (inserted) by one or multiple INSERT entities.

       Find block definitions in the BLOCKS section:

          for block_layout in doc.blocks:
              block = block_layout.block  # the BLOCK entity
              if block.is_xref:
                  handle_xref(block_layout)
              elif block.is_xref_overlay:
                  handle_xref_overlay(block_layout)

       Find XREF references in modelspace:

          for insert in msp.query("INSERT"):
              if insert.is_xref:
                  handle_xref_reference(insert)
                  # ... or get the XREF definition
                  block_layout = insert.block()
                  if block_layout is not None:
                      handle_xref_definition(block_layout)

       Use the helper function <u>define()</u> to create your own XREF definition, the <u>attach()</u> creates this definition
       automatically and raises an exception if the block already exists.

   <b>Supported</b> <b>Entities</b>
       The current implementation supports only copyable and transformable DXF entities,  these  are  all  basic
       entity  types  as  LINE,  CIRCLE,  … and block references and their associated required table entries and
       objects from the OBJECTS section.

       Unsupported are all ACIS based entities, the ACAD_TABLE entity, preserved unknown entities wrapped  in  a
       <b>DXFTagStorage</b>  class,  proxy  entities  and  objects.  Support for these entities may be added in a later
       version of <u>ezdxf</u>.  Unsupported entities are ignored and do not raise exceptions.

       Most document features stored in the HEADER and OBJECTS sections are not supported by  this  module  like
       GROUPS, LAYER_FILTER, GEODATA, SUN.

   <b>Importing</b> <b>Data</b> <b>and</b> <b>Resources</b>
       The <u>ezdxf.xref</u> module replaces the <u>Importer</u> add-on.

       The  basic  functionality  of  the  <u>ezdxf.xref</u> module is loading data from external files including their
       required resources, which is an often requested feature by users for importing data from other DXF  files
       into the current document.

       The  <b>Importer</b>  add-on  was  very limited and removed many resources, where the <u>ezdxf.xref</u> module tries to
       preserve as much information as possible.

          • <u>load_modelspace()</u> - loads the modelspace content from another DXF document

          • <u>load_paperspace()</u> - loads a paperspace layout from another DXF document

          • <u>write_block()</u> - writes entities into the modelspace of a new DXF document

          • <u>Loader</u> - low level loading interface

   <b>High</b> <b>Level</b> <b>Functions</b>
       <b>ezdxf.xref.attach(doc:</b> <u>Drawing</u><b>,</b> <b>*,</b> <b>block_name:</b> <b>str,</b> <b>filename:</b> <b>str,</b> <b>insert:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>0),</b> <b>scale:</b> <b>float</b>
       <b>=</b> <b>1.0,</b> <b>rotation:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>overlay=False)</b> <b>-&gt;</b> <b>Insert</b>
              Attach the file <u>filename</u> to the host document as external reference (XREF) and creates  a  default
              block  reference  for  the  XREF  in  the  modelspace  of  the  document.   The function raises an
              <b>XrefDefinitionError</b> exception if the block definition already exist, but an XREF can  be  inserted
              multiple times by adding additional block references:

                 msp.add_blockref(block_name, insert=another_location)

              <b>IMPORTANT:</b>
                 If  the XREF has different drawing units than the host document, the scale factor between these
                 units must be applied as a uniform scale factor to the block reference!  Unfortunately the XREF
                 drawing units can only be detected by scanning the HEADER section of a document by the function
                 <u>dxf_info()</u> and is therefore not done automatically by this function.  Advice:  always  use  the
                 same units for all drawings of a project!

              <b>Parameters</b>

                     • <b>doc</b> – host DXF document

                     • <b>block_name</b> – name of the XREF definition block

                     • <b>filename</b> – file name of the XREF

                     • <b>insert</b> – location of the default block reference

                     • <b>scale</b> – uniform scaling factor

                     • <b>rotation</b> – rotation angle in degrees

                     • <b>overlay</b> – creates an XREF overlay if <b>True</b> and an XREF attachment otherwise

              <b>Returns</b>
                     default block reference for the XREF

              <b>Return</b> <b>type</b>
                     <u>Insert</u>

              <b>Raises</b> <b>XrefDefinitionError</b> – block with same name exist

              New in version 1.1.

       <b>ezdxf.xref.define(doc:</b> <u>Drawing</u><b>,</b> <b>block_name:</b> <b>str,</b> <b>filename:</b> <b>str,</b> <b>overlay=False)</b> <b>-&gt;</b> <b>None</b>
              Add an external reference (xref) definition to a document.

              XREF attachment types:

              • attached: the XREF that’s inserted into this drawing is also present in a document to which this
                document is inserted as an XREF.

              • overlay:  the XREF that’s inserted into this document is <b>not</b> present in a document to which this
                document is inserted as an XREF.

              <b>Parameters</b>

                     • <b>doc</b> – host document

                     • <b>block_name</b> – name of the xref block

                     • <b>filename</b> – external reference filename

                     • <b>overlay</b> – creates an XREF overlay if <b>True</b> and an XREF attachment otherwise

              <b>Raises</b> <b>XrefDefinitionError</b> – block with same name exist

              New in version 1.1.

       <b>ezdxf.xref.detach(block:</b> <b>BlockLayout,</b> <b>*,</b> <b>xref_filename:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>overlay=False)</b> <b>-&gt;</b> <u>Drawing</u>
              Write the content of <u>block</u> into the modelspace of a new DXF  document  and  convert  <u>block</u>  to  an
              external   reference   (XREF).    The   new  DXF  document  has  to  be  written  by  the  caller:
              <b>xref_doc.saveas(xref_filename)</b>.  This way it is possible to convert the DXF document to DWG by the
              <u>odafc</u> add-on if necessary:

                 xref_doc = xref.detach(my_block, "my_block.dwg")
                 odafc.export_dwg(xref_doc, "my_block.dwg")

              It’s recommended to clean up the entity database of the host document afterwards:

                 doc.entitydb.purge()

              The function does not create any block references. These references should already  exist  and  do
              not need to be changed since references to blocks and XREFs are the same.

              <b>Parameters</b>

                     • <b>block</b> – block definition to detach

                     • <b>xref_filename</b> – name of the external referenced file

                     • <b>overlay</b> – creates an XREF overlay if <b>True</b> and an XREF attachment otherwise

              New in version 1.1.

       <b>ezdxf.xref.dxf_info(filename:</b> <b>str</b> <b>|</b> <b>PathLike)</b> <b>-&gt;</b> <b>DXFInfo</b>
              Scans  the  HEADER  section  of  a  DXF  document  and  returns  a  <b>DXFInfo</b> object, which contains
              information about the DXF version, text encoding, drawing units and insertion base point.

              <b>Raises</b> <b>IOError</b> – not a DXF file or a generic IO error

       <b>ezdxf.xref.embed(xref:</b> <b>BlockLayout,</b> <b>*,</b> <b>load_fn:</b> <b>Callable[[str],</b> <u>Drawing</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>search_paths:</b>
       <b>Iterable[Path</b> <b>|</b> <b>str]</b> <b>=</b> <b>tuple(),</b> <b>conflict_policy=ConflictPolicy.XREF_PREFIX)</b> <b>-&gt;</b> <b>None</b>
              Loads the modelspace of the XREF as content into a block layout.

              The loader function loads the XREF as <u>Drawing</u> object, by default the function <u>ezdxf.readfile()</u>  is
              used  to load DXF files. To load DWG files use the <u>readfile()</u> function from the <u>ezdxf.addons.odafc</u>
              add-on. The <u>ezdxf.recover.readfile()</u> function is very robust for reading DXF files with errors.

              If the XREF path isn’t absolute the XREF is searched in the folder of the host DXF document and in
              the <u>search_path</u> folders.

              <b>Parameters</b>

                     • <b>xref</b> – <b>BlockLayout</b> of the XREF document

                     • <b>load_fn</b> – function to load the content of the XREF as <u>Drawing</u> object

                     • <b>search_paths</b> – list of folders to search for XREFS, default is the  folder  of  the  host
                       document or the current directory if no filepath is set

                     • <b>conflict_policy</b> – how to resolve name conflicts

              <b>Raises</b>

                     • <b>XrefDefinitionError</b> – argument <u>xref</u> is not a XREF definition

                     • <b>FileNotFoundError</b> – XREF file not found

                     • <u>DXFVersionError</u> – cannot load a XREF with a newer DXF version than the host
                           document, try the <u>odafc</u> add-on to downgrade the XREF
                           document or upgrade the host document

              New in version 1.1.

       <b>ezdxf.xref.load_modelspace(sdoc:</b> <u>Drawing</u><b>,</b> <b>tdoc:</b> <u>Drawing</u><b>,</b> <b>filter_fn:</b> <b>Callable[[DXFEntity],</b> <b>bool]</b> <b>|</b> <b>None</b> <b>=</b>
       <b>None,</b> <b>conflict_policy=ConflictPolicy.KEEP)</b> <b>-&gt;</b> <b>None</b>
              Loads  the  modelspace  content of the source document into the modelspace of the target document.
              The filter function <u>filter_fn</u> gets every source entity as input  and  returns  <b>True</b>  to  load  the
              entity or <b>False</b> otherwise.

              <b>Parameters</b>

                     • <b>sdoc</b> – source document

                     • <b>tdoc</b> – target document

                     • <b>filter_fn</b> – optional function to filter entities from the source modelspace

                     • <b>conflict_policy</b> – how to resolve name conflicts

              New in version 1.1.

       <b>ezdxf.xref.load_paperspace(psp:</b> <b>Paperspace,</b> <b>tdoc:</b> <u>Drawing</u><b>,</b> <b>filter_fn:</b> <b>Callable[[DXFEntity],</b> <b>bool]</b> <b>|</b> <b>None</b>
       <b>=</b> <b>None,</b> <b>conflict_policy=ConflictPolicy.KEEP)</b> <b>-&gt;</b> <b>None</b>
              Loads  the  paperspace  layout  <u>psp</u>  into the target document.  The filter function <u>filter_fn</u> gets
              every source entity as input and returns <b>True</b> to load the entity or <b>False</b> otherwise.

              <b>Parameters</b>

                     • <b>psp</b> – paperspace layout to load

                     • <b>tdoc</b> – target document

                     • <b>filter_fn</b> – optional function to filter entities from the source paperspace layout

                     • <b>conflict_policy</b> – how to resolve name conflicts

              New in version 1.1.

       <b>ezdxf.xref.write_block(entities:</b> <b>Sequence[DXFEntity],</b> <b>*,</b> <b>origin:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>0))</b> <b>-&gt;</b> <u>Drawing</u>
              Write <u>entities</u> into the modelspace of a new DXF document.

              This function is called “write_block” because the new DXF document can  be  used  as  an  external
              referenced block.  This function is similar to the WBLOCK command in CAD applications.

              Virtual entities are not supported, because each entity needs a real database- and owner handle.

              <b>Parameters</b>

                     • <b>entities</b> – DXF entities to write

                     • <b>origin</b>  – block origin, defines the point in the modelspace which will be inserted at the
                       insert location of the block reference

              <b>Raises</b> <b>EntityError</b> – virtual entities are not supported

              New in version 1.1.

   <b>Conflict</b> <b>Policy</b>
       <b>class</b> <b>ezdxf.xref.ConflictPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b> <b>start=1,</b>
       <b>boundary=None)</b>
              These conflict policies define how to handle resource name conflicts.

              New in version 1.1.

              <b>KEEP</b>   Keeps the existing resource name of the target document and ignore the  resource  from  the
                     source document.

              <b>XREF_PREFIX</b>
                     This policy handles the resource import like CAD applications by <b>always</b> renaming the loaded
                     resources  to <u>&lt;xref&gt;$0$&lt;name&gt;</u>, where <u>xref</u> is the name of source document, the <u>$0$</u> part is a
                     number to create a unique resource name and <u>&lt;name&gt;</u> is the name of the resource itself.

              <b>NUM_PREFIX</b>
                     This policy renames the loaded resources to <u>$0$&lt;name&gt;</u> only if the resource  <u>&lt;name&gt;</u>  already
                     exists.  The <u>$0$</u> prefix is a number to create a unique resource name and <u>&lt;name&gt;</u> is the name
                     of the resource itself.

   <b>Low</b> <b>Level</b> <b>Loading</b> <b>Interface</b>
       The <u>Loader</u> class is the basic building block for loading entities and resources. The class manages a list
       of loading commands which is executed at once by calling the <u>Loader.execute()</u> method. It is important  to
       execute  the commands at once to get a consistent renaming of resources when using resource name prefixes
       otherwise the loaded resources would get a new  unique  name  at  each  loading  process  even  when  the
       resources are loaded from the same document.

       <b>class</b> <b>ezdxf.xref.Loader(sdoc:</b> <u>Drawing</u><b>,</b> <b>tdoc:</b> <u>Drawing</u><b>,</b> <b>conflict_policy=ConflictPolicy.KEEP)</b>
              Load entities and resources from the source DXF document <u>sdoc</u> into the target DXF document.

              <b>Parameters</b>

                     • <b>sdoc</b> – source DXF document

                     • <b>tdoc</b> – target DXF document

                     • <b>conflict_policy</b> – <u>ConflictPolicy</u>

              <b>load_modelspace(target_layout:</b> <b>BaseLayout</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>filter_fn:</b> <b>Callable[[DXFEntity],</b> <b>bool]</b> <b>|</b>
              <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Loads  the  content  of  the  modelspace of the source document into a layout of the target
                     document, the modelspace of the target document is the default target  layout.  The  filter
                     function  <u>filter_fn</u>  is  used to skip source entities, the function should return <b>False</b> for
                     entities to ignore and <b>True</b> otherwise.

                     <b>Parameters</b>

                            • <b>target_layout</b> – target layout can be any layout: modelspace, paperspace layout  or
                              block layout.

                            • <b>filter_fn</b> – function to filter source entities

              <b>load_paperspace_layout(psp:</b> <b>Paperspace,</b> <b>filter_fn:</b> <b>Callable[[DXFEntity],</b> <b>bool]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b>
              <b>None</b>
                     Loads  a  paperspace  layout  as  a  new  paperspace layout into the target document.  If a
                     paperspace layout with same name already exists the layout will  be  renamed  to   “&lt;layout
                     name&gt; (2)” or “&lt;layout name&gt; (3)” and so on.  The filter function <u>filter_fn</u> is used to skip
                     source  entities,  the  function  should  return  <b>False</b>  for  entities  to  ignore and <b>True</b>
                     otherwise.

                     The content of the modelspace which may be displayed through a VIEWPORT entity will <b>not</b>  be
                     loaded!

                     <b>Parameters</b>

                            • <b>psp</b> – the source paperspace layout

                            • <b>filter_fn</b> – function to filter source entities

              <b>load_paperspace_layout_into(psp:</b> <b>Paperspace,</b> <b>target_layout:</b> <b>BaseLayout,</b> <b>filter_fn:</b>
              <b>Callable[[DXFEntity],</b> <b>bool]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Loads  the  content  of a paperspace layout into an existing layout of the target document.
                     The filter function <u>filter_fn</u> is used to skip source entities, the function  should  return
                     <b>False</b> for entities to ignore and <b>True</b> otherwise.

                     The  content of the modelspace which may be displayed through a VIEWPORT entity will <b>not</b> be
                     loaded!

                     <b>Parameters</b>

                            • <b>psp</b> – the source paperspace layout

                            • <b>target_layout</b> – target layout can be any layout: modelspace, paperspace layout  or
                              block layout.

                            • <b>filter_fn</b> – function to filter source entities

              <b>load_block_layout(block_layout:</b> <b>BlockLayout)</b> <b>-&gt;</b> <b>None</b>
                     Loads  a block layout (block definition) as a new block layout into the target document. If
                     a block layout with the same name exists the conflict policy will be applied.  This  method
                     cannot load modelspace or paperspace layouts.

                     <b>Parameters</b>
                            <b>block_layout</b> – the source block layout

              <b>load_block_layout_into(block_layout:</b> <b>BlockLayout,</b> <b>target_layout:</b> <b>BaseLayout)</b> <b>-&gt;</b> <b>None</b>
                     Loads  the  content  of  a  block  layout (block definition) into an existing layout of the
                     target document.  This method cannot load the content of modelspace or paperspace layouts.

                     <b>Parameters</b>

                            • <b>block_layout</b> – the source block layout

                            • <b>target_layout</b> – target layout can be any layout: modelspace, paperspace layout  or
                              block layout.

              <b>load_layers(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads  the layers defined by the argument <u>names</u> into the target document.  In the case of a
                     name conflict the conflict policy will be applied.

              <b>load_linetypes(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads the linetypes defined by the argument <u>names</u> into the target document.  In the case of
                     a name conflict the conflict policy will be applied.

              <b>load_text_styles(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads the TEXT styles defined by the argument <u>names</u> into the target document.  In the  case
                     of a name conflict the conflict policy will be applied.

              <b>load_dim_styles(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads  the  DIMENSION styles defined by the argument <u>names</u> into the target document. In the
                     case of a name conflict the conflict policy will be applied.

              <b>load_mline_styles(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads the MLINE styles defined by the argument <u>names</u> into the target document. In the  case
                     of a name conflict the conflict policy will be applied.

              <b>load_mleader_styles(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads the MULTILEADER styles defined by the argument <u>names</u> into the target document. In the
                     case of a name conflict the conflict policy will be applied.

              <b>load_materials(names:</b> <b>Sequence[str])</b> <b>-&gt;</b> <b>None</b>
                     Loads  the MATERIALS defined by the argument <u>names</u> into the target document. In the case of
                     a name conflict the conflict policy will be applied.

              <b>execute(xref_prefix:</b> <b>str</b> <b>=</b> <b>'')</b> <b>-&gt;</b> <b>None</b>
                     Execute all loading commands. The <u>xref_prefix</u> string is used as XREF name when the conflict
                     policy <u>ConflictPolicy.XREF_PREFIX</u> is applied.

</pre><h4><b>HOWTO</b></h4><pre>
       The Howto section show how to accomplish specific tasks with <u>ezdxf</u> in  a  straight  forward  way  without
       teaching  basics  or internals, if you are looking for more information about the ezdxf internals look at
       the <u>Reference</u> section or if you want to learn how to use <u>ezdxf</u> go to the  <u>Tutorials</u>  section  or  to  the
       <u>Basic</u> <u>Concepts</u> section.

   <b>General</b> <b>Document</b>
       General preconditions:

          import sys
          import ezdxf

          try:
              doc = ezdxf.readfile("your_dxf_file.dxf")
          except IOError:
              print(f"Not a DXF file or a generic I/O error.")
              <a href="../man1/sys.exit.1.html">sys.exit</a>(1)
          except ezdxf.DXFStructureError:
              print(f"Invalid or corrupted DXF file.")
              <a href="../man2/sys.exit.2.html">sys.exit</a>(2)
          msp = doc.modelspace()

       This  works well with DXF files from trusted sources like AutoCAD or BricsCAD, for loading DXF files with
       minor or major flaws look at the <u>ezdxf.recover</u> module.

   <b>Load</b> <b>DXF</b> <b>Files</b> <b>with</b> <b>Structure</b> <b>Errors</b>
       If you know the files you will process have most likely minor  or  major  flaws,  use  the  <u>ezdxf.recover</u>
       module:

          import sys
          from ezdxf import recover

          try:  # low level structure repair:
              doc, auditor = recover.readfile(name)
          except IOError:
              print(f"Not a DXF file or a generic I/O error.")
              <a href="../man1/sys.exit.1.html">sys.exit</a>(1)
          except ezdxf.DXFStructureError:
              print(f"Invalid or corrupted DXF file: {name}.")
              <a href="../man2/sys.exit.2.html">sys.exit</a>(2)

          # DXF file can still have unrecoverable errors, but this is maybe
          # just a problem when saving the recovered DXF file.
          if auditor.has_errors:
              print(f"Found unrecoverable errors in DXF file: {name}.")
              auditor.print_error_report()

       For more loading scenarios follow the link: <u>ezdxf.recover</u>

   <b>Set/Get</b> <b>Header</b> <b>Variables</b>
       <u>ezdxf</u> has an interface to get and set HEADER variables:

          doc.header["VarName"] = value
          value = doc.header["VarName"]

       <b>SEE</b> <b>ALSO:</b>
          <u>HeaderSection</u> and online documentation from Autodesk for available <u>header</u> <u>variables</u>.

   <b>Set</b> <b>DXF</b> <b>Drawing</b> <b>Units</b>
       The  header  variable  $INSUNITS  defines  the drawing units for the modelspace and therefore for the DXF
       document if no further settings are applied. The most common units are 6 for meters and 1 for inches.

       Use this HEADER variables to setup the default units for CAD applications  opening  the  DXF  file.  This
       setting  is  not  relevant  for <u>ezdxf</u> API calls, which are unitless for length values and coordinates and
       decimal degrees for angles (in most cases).

       Sets drawing units:

          doc.header["$INSUNITS"] = 6

       For more information see section <u>DXF</u> <u>Units</u>.

   <b>Create</b> <b>More</b> <b>Readable</b> <b>DXF</b> <b>Files</b> <b>(DXF</b> <b>Pretty</b> <b>Printer)</b>
       DXF files are plain text files, you can open this files with  every  text  editor  which  handles  bigger
       files. But it is not really easy to get quick the information you want.

       Create a more readable HTML file (DXF Pretty Printer):

          # Call as executable script from the command line:
          ezdxf pp FILE [FILE ...]

          # Call as module on Windows:
          py -m ezdxf pp FILE [FILE ...]

          # Call as module on Linux/Mac
          python3 -m ezdxf pp FILE [FILE ...]

       This  creates  a  HTML file with a nicer layout than a plain text file, and handles are links between DXF
       entities, this simplifies the navigation between the DXF entities.

          usage: ezdxf pp [-h] [-o] [-r] [-x] [-l] FILE [FILE ...]

          positional arguments:
            FILE             DXF files pretty print

          optional arguments:
            -h, --help       show this help message and exit
            -o, --open       open generated HTML file with the default web browser
            -r, --raw        raw mode - just print tags, no DXF structure interpretation
            -x, --nocompile  don't compile points coordinates into single tags (only in
                             raw mode)
            -l, --legacy     legacy mode - reorders DXF point coordinates

       <b>IMPORTANT:</b>
          This does not render the graphical content of the DXF file to a HTML canvas element.

   <b>Calculate</b> <b>Extents</b> <b>for</b> <b>the</b> <b>Modelspace</b>
       Since <u>ezdxf</u> v0.16 exist a <u>ezdxf.bbox</u> module to calculate bounding boxes for  DXF  entities.  This  module
       makes the extents calculation very easy, but read the documentation for the <u>bbox</u> module to understand its
       limitations.

          import ezdxf
          from ezdxf import bbox

          doc = ezdxf.readfile("your.dxf")
          msp = doc.modelspace()

          extents = <a href="../manmsp/bbox.extents.msp.html">bbox.extents</a>(msp)

       The returned <u>extents</u> is a <u>ezdxf.math.BoundingBox</u> object.

   <b>Set</b> <b>Initial</b> <b>View/Zoom</b> <b>for</b> <b>the</b> <b>Modelspace</b>
       To show an arbitrary location of the modelspace centered in the CAD application window, set the <b>'*Active'</b>
       VPORT  to  this  location.  The  DXF attribute <b>dxf.center</b> defines the location in the modelspace, and the
       <b>dxf.height</b> specifies the area of the modelspace to view. Shortcut function:

          doc.set_modelspace_vport(height=10, center=(10, 10))

       <b>SEE</b> <b>ALSO:</b>
          The <u>ezdxf.zoom</u> module is another way to set the initial modelspace view.

       Setting the initial view to the extents of all entities in the modelspace:

          import ezdxf
          from ezdxf import zoom

          doc = ezdxf.readfile("your.dxf")
          msp = doc.modelspace()
          <a href="../manmsp/zoom.extents.msp.html">zoom.extents</a>(msp)

       Setting the initial view to the extents of just some entities:

          lines = msp.query("LINES")
          zoom.objects(lines)

       The <u>zoom</u> module also works for paperspace layouts.

       <b>IMPORTANT:</b>
          The <u>zoom</u> module uses the <u>bbox</u> module to calculate the  bounding  boxes  for  DXF  entities.  Read  the
          documentation  for  the <u>bbox</u> module to understand its limitations and the bounding box calculation for
          large documents can take a while!

   <b>Hide</b> <b>the</b> <b>UCS</b> <b>Icon</b>
       The visibility of the UCS icon is controlled by the DXF <u>ucs_icon</u> attribute of the <u>VPort</u> entity:

          • bit 0: 0=hide, 1=show

          • bit 1: 0=display in lower left corner, 1=display at origin

       The state of the UCS icon can be set in conjunction with the initial <u>VPort</u> of the model space, this  code
       turns off the UCS icon:

          doc.set_modelspace_vport(10, center=(10, 10), dxfattribs={"ucs_icon": 0})

       Alternative: turn off UCS icons for all <b>VPort</b> entries in the active viewport configuration:

          for vport in doc.viewports.get_config("*Active"):
              vport.dxf.ucs_icon = 0

   <b>Show</b> <b>Lineweights</b> <b>in</b> <b>DXF</b> <b>Viewers</b>
       By default lines and curves are shown without lineweights in DXF viewers.  By setting the header variable
       $LWDISPLAY to 1 the DXF viewer should display lineweights, if supported by the viewer.

          doc.header["$LWDISPLAY"] = 1

   <b>Add</b> <u><b>ezdxf</b></u> <b>Resources</b> <b>to</b> <b>Existing</b> <b>DXF</b> <b>Document</b>
       Add all <u>ezdxf</u> specific resources (line types, text- and dimension styles) to an existing DXF document:

          import ezdxf
          from ezdxf.tools.standards import setup_drawing

          doc = ezdxf.readfile("your.dxf")
          setup_drawing(doc, topics="all")

   <b>Set</b> <b>Logging</b> <b>Level</b> <b>of</b> <u><b>ezdxf</b></u>
       Set  the logging level of the <u>ezdxf</u> package to a higher level to minimize logging messages from ezdxf. At
       level <b>ERROR</b> only severe errors will be logged and <b>WARNING</b>, <b>INFO</b> and <b>DEBUG</b> messages will be suppressed:

          import logging

          logging.getLogger("ezdxf").setLevel(logging.ERROR)

   <b>DXF</b> <b>Viewer</b>
   <b>A360</b> <b>Viewer</b> <b>Problems</b>
       AutoDesk web service <u>A360</u> seems to be more picky than the AutoCAD desktop applications, may be  it  helps
       to use the latest DXF version supported by ezdxf, which is DXF R2018 (AC1032) in the year of writing this
       lines (2018).

   <b>DXF</b> <b>Entities</b> <b>Are</b> <b>Not</b> <b>Displayed</b> <b>in</b> <b>the</b> <b>Viewer</b>
       <u>ezdxf</u>  does  not  automatically  locate  the main viewport of the modelspace at the entities, you have to
       perform the “Zoom to Extends” command, here in TrueView 2020: [image]

       And here in the Autodesk Online Viewer: [image]

       Add this line to your code to relocate the main viewport, adjust the <u>center</u> (in  modelspace  coordinates)
       and the <u>height</u> (in drawing units) arguments to your needs:

          doc.set_modelspace_vport(height=10, center=(0, 0))

   <b>Show</b> <b>IMAGES/XREFS</b> <b>on</b> <b>Loading</b> <b>in</b> <b>AutoCAD</b>
       If  you  are  adding XREFS and IMAGES with relative paths to existing drawings and they do not show up in
       AutoCAD immediately, change the HEADER variable <b>$PROJECTNAME=''</b> to <u>(not</u> <u>really)</u> solve this problem.   The
       ezdxf templates for DXF R2004 and later have <b>$PROJECTNAME=''</b> as default value.

       Thanks to <u>David</u> <u>Booth</u>:
          If the filename in the IMAGEDEF contains the full path (absolute in AutoCAD) then it shows on loading,
          otherwise it won’t display (reports as unreadable) until you manually reload using XREF manager.

          A  workaround  (to show IMAGES on loading) appears to be to save the full file path in the DXF or save
          it as a DWG.

       Thanks to <u>Zac</u> <u>Luzader</u>:
          Has anyone else noticed that very short simple image file names seem to avoid  this  problem?  Once  I
          ensured  that  the  image  file’s  name  was short and had no special characters (letters, numbers and
          underscores only) the problem seemed to go away.  I didn’t rigorously analyze the behavior as its very
          time consuming.

          Also: You can safely put the image in a subdirectory  and  use  a  relative  path.  The  name  of  the
          subdirectory  does  not seem to trigger this problem, provided that the image file name itself is very
          short and simple.

          Also pro tip: The XRef manager exists in DWG TrueView 2023, but access to it is only possible  if  you
          have  a  completely  broken  reference. Create a DXF with a reference to a non-existent file, then the
          error dialog will let you open the XRef Manager.  Once it is open you can pin it and it will  be  open
          next time, even if you have no broken references.

       <b>SEE</b> <b>ALSO:</b>
          Discussion on github: <u>Images</u> <u>don’t</u> <u>show</u> <u>in</u> <u>AutoCAD</u> <u>until</u> <u>…</u>

   <b>Set</b> <b>Initial</b> <b>View/Zoom</b> <b>for</b> <b>the</b> <b>Modelspace</b>
       See section “General Document”: <u>Set</u> <u>Initial</u> <u>View/Zoom</u> <u>for</u> <u>the</u> <u>Modelspace</u>

   <b>Show</b> <b>Lineweights</b> <b>in</b> <b>DXF</b> <b>Viewers</b>
       By default lines and curves are shown without lineweights in DXF viewers.  By setting the header variable
       $LWDISPLAY to 1 the DXF viewer should display lineweights, if supported by the viewer.

          doc.header["$LWDISPLAY"] = 1

   <b>DXF</b> <b>Content</b>
       General preconditions:

          import sys
          import ezdxf

          try:
              doc = ezdxf.readfile("your_dxf_file.dxf")
          except IOError:
              print(f'Not a DXF file or a generic I/O error.')
              <a href="../man1/sys.exit.1.html">sys.exit</a>(1)
          except ezdxf.DXFStructureError:
              print(f'Invalid or corrupted DXF file.')
              <a href="../man2/sys.exit.2.html">sys.exit</a>(2)
          msp = doc.modelspace()

   <b>Get/Set</b> <b>Entity</b> <b>Color</b>
       The entity color is stored as <u>ACI</u> (AutoCAD Color Index):

          aci = entity.dxf.color

       Default value is 256 which means BYLAYER:

          layer = doc.layers.get(entity.dxf.layer)
          aci = layer.get_color()

       The  special  <u>get_color()</u>  method  is required, because the color attribute <b>Layer.dxf.color</b> is misused as
       layer on/off flag, a negative color value means the layer is off.

       ACI value 0 means BYBLOCK, which means the color from the block reference (INSERT entity).

       Set color as ACI value as int in range [0, 256]:

          entity.dxf.color = 1

       The ACI value 7 has a special meaning, it is white on dark backgrounds and white on light backgrounds.

   <b>Get/Set</b> <b>Entity</b> <b>RGB</b> <b>Color</b>
       RGB true color values are supported since DXF R13 (AC1012), the 24-bit RGB value is stored as integer  in
       the DXF attribute <u>true_color</u>:

          # 24 bit binary value: 0bRRRRRRRRGGGGGGGGBBBBBBBB or hex value: 0xRRGGBB
          # set true color value to red
          entity.dxf.true_color = 0xFF0000

       Use the helper functions from the <u>ezdxf.colors</u> module for RGB integer value handling:

          from ezdxf import colors

          entity.dxf.true_color = colors.rgb2int((0xFF, 0, 0))
          r, g, b = colors.int2rgb(entity.dxf.true_color)

       The  RGB  values of the AutoCAD default colors are not officially documented, but an accurate translation
       table is included in <u>ezdxf</u>:

          # Warning: ACI value 256 (BYLAYER) raises an IndexError!
          rgb24 = colors.DXF_DEFAULT_COLORS[aci]
          print(f"RGB Hex Value: #{rgb24:06X}")
          r, g, b = colors.int2rgb(rgb24)
          print(f"RGB Channel Values: R={r:02X} G={g:02X} b={b:02X}")

       If <b>color</b> and <b>true_color</b> values are set, BricsCAD and AutoCAD use the <b>true_color</b> value  as  display  color
       for the entity.

   <b>Get/Set</b> <b>True</b> <b>Color</b> <b>as</b> <b>RGB-Tuple</b>
       Get/Set the true color value as (r, g, b)-tuple by the <u>rgb</u> property of the <u>DXFGraphic</u> entity:

          # set true color value to red
          entity.rgb = (0xFF, 0, 0)

          # get true color values
          r, g, b = entity.rgb

   <b>Get/Set</b> <b>Block</b> <b>Reference</b> <b>Attributes</b>
       Block  references  (<u>Insert</u>) can have attached attributes (<u>Attrib</u>), these are simple text annotations with
       an associated tag appended to the block reference.

       Iterate over all appended attributes:

          # get all INSERT entities with entity.dxf.name == "Part12"
          blockrefs = msp.query('INSERT[name=="Part12"]')
          if len(blockrefs):
              entity = blockrefs[0]  # process first entity found
              for attrib in entity.attribs:
                  if attrib.dxf.tag == "diameter":  # identify attribute by tag
                      attrib.dxf.text = "17mm"  # change attribute content

       Get attribute by tag:

          diameter = entity.get_attrib('diameter')
          if diameter is not None:
              diameter.dxf.text = "17mm"

   <b>Adding</b> <b>XDATA</b> <b>to</b> <b>Entities</b>
       Adding XDATA as list of tuples (group code, value) by <u>set_xdata()</u>, overwrites data if already present:

          doc.appids.new('YOUR_APPID')  # IMPORTANT: create an APP ID entry

          circle = msp.add_circle((10, 10), 100)
          circle.set_xdata(
              'YOUR_APPID',
              [
                  (1000, 'your_web_link.org'),
                  (1002, '{'),
                  (1000, 'some text'),
                  (1002, '{'),
                  (1071, 1),
                  (1002, '}'),
                  (1002, '}')
              ])

       For group code meaning see DXF reference section <u>DXF</u> <u>Group</u> <u>Codes</u>  <u>in</u>  <u>Numerical</u>  <u>Order</u>  <u>Reference</u>,  valid
       group codes are in the range 1000 - 1071.

       Method <u>get_xdata()</u> returns the extended data for an entity as <u>Tags</u> object.

       <b>SEE</b> <b>ALSO:</b>
          Tutorial: <u>Storing</u> <u>Custom</u> <u>Data</u> <u>in</u> <u>DXF</u> <u>Files</u>

   <b>Get</b> <b>Overridden</b> <b>DIMSTYLE</b> <b>Values</b> <b>from</b> <b>DIMENSION</b>
       In  general  the  <u>Dimension</u>  styling  and  config attributes are stored in the <b>Dimstyle</b> entity, but every
       attribute can be overridden for each  DIMENSION  entity  individually,  get  overwritten  values  by  the
       <b>DimstyleOverride</b> object as shown in the following example:

          for dimension in msp.query('DIMENSION'):
              dimstyle_override = dimension.override()  # requires v0.12
              dimtol = dimstyle_override['dimtol']
              if dimtol:
                  print(f'{str(dimension)} has tolerance values:')
                  dimtp = dimstyle_override['dimtp']
                  dimtm = dimstyle_override['dimtm']
                  print(f'Upper tolerance: {dimtp}')
                  print(f'Lower tolerance: {dimtm}')

       The  <b>DimstyleOverride</b>  object  returns  the  value  of  the  underlying  DIMSTYLE objects if the value in
       DIMENSION was not overwritten, or <b>None</b> if the value was neither defined in DIMSTYLE nor in DIMENSION.

   <b>Override</b> <b>DIMSTYLE</b> <b>Values</b> <b>for</b> <b>DIMENSION</b>
       Same as above, the <b>DimstyleOverride</b> object supports also overriding DIMSTYLE values.  But just overriding
       this values have no effect  on  the  graphical  representation  of  the  DIMENSION  entity,  because  CAD
       applications  just show the associated anonymous block which contains the graphical representation on the
       DIMENSION entity as simple DXF entities. Call  the  <b>render</b>  method  of  the  <b>DimstyleOverride</b>  object  to
       recreate  this  graphical  representation  by  <u>ezdxf</u>,  but <u>ezdxf</u> <b>does</b> <b>not</b> support all DIMENSION types and
       DIMVARS yet, and results <b>will</b> <b>differ</b> from AutoCAD or BricsCAD renderings.

          dimstyle_override = dimension.override()
          dimstyle_override.set_tolerance(0.1)

          # delete associated geometry block
          del doc.blocks[dimension.dxf.geometry]

          # recreate geometry block
          dimstyle_override.render()

   <b>How</b> <b>to</b> <b>Change</b> <b>the</b> <b>HATCH</b> <b>Pattern</b> <b>Origin</b> <b>Point</b>
       This code sets the origin of the first pattern line to the given <u>origin</u> and the origins of all  remaining
       pattern lines relative to the first pattern line origin.

          from ezdxf.entities import Hatch, Pattern
          from ezdxf.math import Vec2

          def shift_pattern_origin(hatch: Hatch, offset: Vec2):
              if isinstance(hatch.pattern, Pattern):
                  for pattern_line in hatch.pattern.lines:
                      pattern_line.base_point += offset

          def reset_pattern_origin_of_first_pattern_line(hatch: Hatch, origin: Vec2):
              if isinstance(hatch.pattern, Pattern) and len(hatch.pattern.lines):
                  first_pattern_line = hatch.pattern.lines[0]
                  offset = origin - first_pattern_line.base_point
                  shift_pattern_origin(hatch, offset)

       <b>SEE</b> <b>ALSO:</b>

          • Discussion <u>#769</u>

   <b>How</b> <b>to</b> <b>Get</b> <b>the</b> <b>Length</b> <b>of</b> <b>a</b> <b>Spline</b> <b>or</b> <b>Polyline</b>
       There  exist  no  analytical  function to calculate the length of a <u>B-spline</u>, you have to approximate the
       curve and calculate the length of the polyline.  The construction tool <u>ezdxf.math.ConstructionPolyline</u> is
       may be useful for that.

          import ezdxf
          from ezdxf.math import ConstructionPolyline

          doc = ezdxf.new()
          msp = doc.modelspace()
          fit_points = [(0, 0, 0), (750, 500, 0), (1750, 500, 0), (2250, 1250, 0)]

          spline = msp.add_spline(fit_points)
          # Adjust the max. sagitta distance to your needs or run the calculation in a loop
          # reducing the distance until the difference to the previous run is smaller
          # than your expected precision:
          polyline = ConstructionPolyline(spline.flattening(distance=0.1))
          print(f"approximated length = {polyline.length:.2f}")

   <b>How</b> <b>to</b> <b>Resolve</b> <b>DXF</b> <b>Properties</b>
       Graphical properties of DXF entities (color, lineweight, …) are sometimes hard to resolve because of  the
       complex possibilities to inherit properties from layers or blocks, or overriding them by <u>ctb</u> files.

       The <u>drawing</u> add-on provides the <u>RenderContext</u> class that can be used to resolve properties of entities in
       the context of their use:

          import ezdxf
          from ezdxf.addons.drawing.properties import RenderContext

          doc = ezdxf.new()
          doc.layers.add("LINE", color=ezdxf.colors.RED)
          msp = doc.modelspace()
          line = msp.add_line((0, 0), (1, 0), dxfattribs={"layer": "LINE"})

          ctx = RenderContext(doc)
          <a href="../manmsp/ctx.set_current_layout.msp.html">ctx.set_current_layout</a>(msp)
          print(f"resolved RGB value: {ctx.resolve_color(line)}")

       Output:

          resolved RGB value: #ff0000

       This  works  in most simple cases, resolving properties of objects in viewports or nested blocks requires
       additional information that is beyond the scope of a simple guide.

   <b>How</b> <b>to</b> <b>Find</b> <b>XREF</b> <b>Definitions</b>
       XREFs are normal block definitions and can be found in the BLOCKS section:

          for block_layout in doc.blocks:
              block = block_layout.block  # the BLOCK entity
              if block.is_xref:
                  handle_xref(block_layout)
              elif block.is_xref_overlay:
                  handle_xref_overlay(block_layout)

       <b>SEE</b> <b>ALSO:</b>

          • documentation of the <u>ezdxf.xref</u> module

          • <u>ezdxf.layouts.BlockLayout</u>

   <b>How</b> <b>to</b> <b>Find</b> <b>XREF</b> <b>References</b>
       An XREF reference is a block reference (INSERT entity) to the block definition of the XREF:

          for insert in msp.query("INSERT"):
              if insert.is_xref:
                  handle_xref_reference(insert)
                  # ... or get the XREF definition
                  block_layout = insert.block()
                  if block_layout is not None:
                      block = block_layout.block
                      if block.is_xref:
                          handle_xref(block_layout)
                      elif block.is_xref_overlay:
                          handle_xref_overlay(block_layout)

       Like any normal block, an XREF can be inserted multiple times.

       <b>SEE</b> <b>ALSO:</b>

          • documentation of the <u>ezdxf.xref</u> module

          • <u>ezdxf.layouts.BlockLayout</u>

   <b>Fonts</b>
   <b>Rendering</b> <b>SHX</b> <b>Fonts</b>
       The SHX font format is not documented nor supported by many libraries/packages like  <u>Matplotlib</u>  and  <u>Qt</u>,
       therefore  only  SHX  fonts  which  have  corresponding  TTF-fonts can be rendered by these backends. The
       mapping from/to SHX/TTF fonts is hard coded in the source code file: <u>fonts.py</u>

       Since <u>ezdxf</u> v1.1 is the rendering of SHX fonts supported if the path to  these  fonts  is  added  to  the
       <b>support_dirs</b> in the <u>Config</u> <u>Files</u>.

   <b>Rebuild</b> <b>Font</b> <b>Manager</b> <b>Cache</b>
       If  you  wanna use new installed fonts which are not included in the current cache file of <u>ezdxf</u> you have
       to rebuild the cache file:

          import ezdxf
          from ezdxf.fonts import fonts

          fonts.build_system_font_cache()

       or call the <u>ezdxf</u> launcher to do that:

          ezdxf --fonts

   <b>Drawing</b> <b>Add-on</b>
       This section consolidates the <u>FAQ</u> about the drawing add-on from the github forum.

   <b>All</b> <b>Backends</b>
   <b>How</b> <b>to</b> <b>Set</b> <b>Background</b> <b>and</b> <b>Foreground</b> <b>Colors</b>
       Override the default background and foreground colors.  The foreground color is the <u>AutoCAD</u>  <u>Color</u>  <u>Index</u>
       <u>(ACI)</u>  7,  which  is  white/black  depending  on  the  background  color.  If the foreground color is not
       specified, the foreground color is white for dark backgrounds  and  black  for  light  backgrounds.   The
       required color format is a hex string “#RRGGBBAA”.

          from ezdxf.addons.drawing.properties import LayoutProperties


          # -x-x-x snip -x-x-x-
          fig: plt.Figure = plt.figure()
          ax: plt.Axes = fig.add_axes((0, 0, 1, 1))
          ctx = RenderContext(doc)

          # get the modelspace properties
          msp_properties = <a href="../manmsp/LayoutProperties.from_layout.msp.html">LayoutProperties.from_layout</a>(msp)

          # set light gray background color and black foreground color
          msp_properties.set_colors("#eaeaea")
          out = MatplotlibBackend(ax)

          # override the layout properties and render the modelspace
          Frontend(ctx, out).draw_layout(
              msp,
              finalize=True,
              layout_properties=msp_properties,
          )
          fig.savefig("image.png")

       A light background “#eaeaea” has a black foreground color by default: [image]

       A dark background “#0a0a0a” has a white foreground color by default:


          # -x-x-x snip -x-x-x-
          msp_properties.set_colors("#0a0a0a")

          # -x-x-x snip -x-x-x-
       [image]

   <b>How</b> <b>to</b> <b>Set</b> <b>a</b> <b>Transparent</b> <b>Background</b> <b>Color</b>
       The  override color include an alpha transparency “#RRGGBBAA” value. An alpha value of “00” is opaque and
       “ff” is fully transparent.  A transparent background color still defines the foreground color!

       <b>HINT:</b>
          The <b>savefig()</b> function of the matplotlib backend requires the <u>transparent</u> argument to be set  to  <b>True</b>
          to support transparency.

       A light and fully transparent background “#eaeaeaff” has a black foreground color by default:


          # -x-x-x snip -x-x-x-
          msp_properties.set_colors("#eaeaeaff")


          # -x-x-x snip -x-x-x-
          fig.savefig("image.png", transparent=True)
       [image]

       A dark and fully transparent background “#0a0a0aff” has a <b>white</b> foreground color by default:


          # -x-x-x snip -x-x-x-
          msp_properties.set_colors("#0a0a0aff")


          # -x-x-x snip -x-x-x-
          fig.savefig("image.png", transparent=True)
       [image]

   <b>How</b> <b>to</b> <b>Exclude</b> <b>DXF</b> <b>Entities</b> <b>from</b> <b>Rendering</b>
       • If all unwanted entities are on the same layer switch off the layer.

       • If the document is not saved later, you can delete the entities or set them invisible.

       • Filter the unwanted entities by a filter function.

       The  argument <u>filter_func</u> of the <b>Frontend.draw_layout()</b> method expects a function which takes a graphical
       DXF entity as input and returns <b>True</b> if the entity should be rendered or <b>False</b> to exclude the entity from
       rendering.

       This filter function excludes all DXF entities with an ACI color value of 2:

          from ezdxf.entities import DXFGraphic

          def my_filter(e: DXFGraphic) -&gt; bool:
              return e.dxf.color != 2


          # -x-x-x snip -x-x-x-
          Frontend(ctx, out).draw_layout(msp, finalize=True, filter_func=my_filter)

       <b>IMPORTANT:</b>
          Not all attributes have a default value if the attribute does not exist.  If you are  not  sure  about
          this, use the <b>get()</b> method:

              def my_filter(e: DXFGraphic) -&gt; bool:
                  return e.dxf.get("color", 7) != 2

   <b>How</b> <b>to</b> <b>Override</b> <b>Properties</b> <b>of</b> <b>DXF</b> <b>Entities</b>
       Create a custom <b>Frontend</b> class and override the the <b>override_properties()</b> method:

          class MyFrontend(Frontend):
              def override_properties(self, entity: DXFGraphic, properties: Properties) -&gt; None:
                  # remove alpha channel from all entities, "#RRGGBBAA"
                  properties.color = properties.color[:7]


          # -x-x-x snip -x-x-x-
          MyFrontend(ctx, out).draw_layout(msp, finalize=True)

       <b>SEE</b> <b>ALSO:</b>

          • <u>ezdxf.addons.drawing.properties.Properties</u>

   <b>Matplotlib</b> <b>Backend</b>
       <b>SEE</b> <b>ALSO:</b>

          • Matplotlib package: <u>https://matplotlib.org/stable/api/matplotlib_configuration_api.html</u>

          • <b>Figure</b> API: <u>https://matplotlib.org/stable/api/figure_api.html</u>

          • <b>Axes</b> API: <u>https://matplotlib.org/stable/api/axis_api.html</u>

   <b>How</b> <b>to</b> <b>Get</b> <b>the</b> <b>Pixel</b> <b>Coordinates</b> <b>of</b> <b>DXF</b> <b>Entities</b>
       <b>SEE</b> <b>ALSO:</b>

          • Source: <u>https://github.com/mozman/ezdxf/discussions/219</u>

       Transformation from modelspace coordinates to image coordinates:

          import matplotlib.pyplot as plt
          from PIL import Image, ImageDraw

          import ezdxf
          from ezdxf.math import Matrix44
          from ezdxf.addons.drawing import RenderContext, Frontend
          from ezdxf.addons.drawing.matplotlib import MatplotlibBackend

          def get_wcs_to_image_transform(
              ax: plt.Axes, image_size: tuple[int, int]
          ) -&gt; Matrix44:
              """Returns the transformation matrix from modelspace coordinates to image
              coordinates.
              """

              x1, x2 = ax.get_xlim()
              y1, y2 = ax.get_ylim()
              data_width, data_height = x2 - x1, y2 - y1
              image_width, image_height = image_size
              return (
                  Matrix44.translate(-x1, -y1, 0)
                  @ Matrix44.scale(
                      image_width / data_width, -image_height / data_height, 1.0
                  )
                  # +1 to counteract the effect of the pixels being flipped in y
                  @ Matrix44.translate(0, image_height + 1, 0)
              )

          # create the DXF document
          doc = ezdxf.new()
          msp = doc.modelspace()
          msp.add_lwpolyline([(0, 0), (1, 0), (1, 1), (0, 1)], close=True)
          msp.add_line((0, 0), (1, 1))

          # export the pixel image
          fig: plt.Figure = plt.figure()
          ax: plt.Axes = fig.add_axes([0, 0, 1, 1])
          ctx = RenderContext(doc)
          out = MatplotlibBackend(ax)
          Frontend(ctx, out).draw_layout(msp, finalize=True)
          fig.savefig("cad.png")
          plt.close(fig)

          # reload the pixel image by Pillow (PIL)
          img = Image.open("cad.png")
          draw = ImageDraw.Draw(img)

          # add some annotations to the pixel image by using modelspace coordinates
          m = get_wcs_to_image_transform(ax, img.size)
          a, b, c = (
              (v.x, v.y)  # draw.line() expects tuple[float, float] as coordinates
              # transform modelspace coordinates to image coordinates
              for v in m.transform_vertices([(0.25, 0.75), (0.75, 0.25), (1, 1)])
          )
          draw.line([a, b, c, a], fill=(255, 0, 0))

          # show the image by the default image viewer
          img.show()

   <b>How</b> <b>to</b> <b>Get</b> <b>Modelspace</b> <b>Coordinates</b> <b>from</b> <b>Pixel</b> <b>Coordinates</b>
       This is the reverse operation of the previous how-to: <u>How</u> <u>to</u> <u>Get</u> <u>the</u> <u>Pixel</u> <u>Coordinates</u> <u>of</u> <u>DXF</u> <u>Entities</u>

       <b>SEE</b> <b>ALSO:</b>

          • Full example script: <u>wcs_to_image_coordinates.py</u>

          • Source: <u>https://github.com/mozman/ezdxf/discussions/269</u>

          def get_image_to_wcs_transform(
              ax: plt.Axes, image_size: tuple[int, int]
          ) -&gt; Matrix44:
              m = get_wcs_to_image_transform(ax, image_size)
              m.inverse()
              return m


          # -x-x-x snip -x-x-x-
          img2wcs = get_image_to_wcs_transform(ax, img.size)
          print(f"0.25, 0.75 == {img2wcs.transform(a).<a href="../man2/round.2.html">round</a>(2)}")
          print(f"0.75, 0.25 == {img2wcs.transform(b).<a href="../man2/round.2.html">round</a>(2)}")
          print(f"1.00, 1.00 == {img2wcs.transform(c).<a href="../man2/round.2.html">round</a>(2)}")

   <b>How</b> <b>to</b> <b>Export</b> <b>a</b> <b>Specific</b> <b>Area</b> <b>of</b> <b>the</b> <b>Modelspace</b>
       This code exports the specified modelspace area from (5, 3) to (7, 8) as a 2x5 inch PNG image to maintain
       the aspect ratio of the source area.

       Use case: render only a specific area of the modelspace.

       <b>SEE</b> <b>ALSO:</b>

          • Full example script: <u>export_specific_area.py</u>

          • Source: <u>https://github.com/mozman/ezdxf/discussions/451</u>


          # -x-x-x snip -x-x-x-
          # export the pixel image
          fig: plt.Figure = plt.figure()
          ax: plt.Axes = fig.add_axes([0, 0, 1, 1])
          ctx = RenderContext(doc)
          out = MatplotlibBackend(ax)
          Frontend(ctx, out).draw_layout(msp, finalize=True)

          # setting the export area:
          xmin, xmax = 5, 7
          ymin, ymax = 3, 8
          ax.set_xlim(xmin, xmax)
          ax.set_ylim(ymin, ymax)

          # set the output size to get the expected aspect ratio:
          fig.set_size_inches(xmax - xmin, ymax - ymin)
          fig.savefig("x5y3_to_x7y8.png")
          plt.close(fig)

   <b>How</b> <b>to</b> <b>Render</b> <b>Without</b> <b>Margins</b>
       To remove the empty space at the image borders set the margins of the <b>Axes</b> object to zero:

          <a href="../man0/ax.margins.0.html">ax.margins</a>(0)
          fig.savefig("image_without_margins.png")
          plt.close(fig)

       <b>SEE</b> <b>ALSO:</b>

          • Matplotlib docs about <u>margins</u>

   <b>How</b> <b>to</b> <b>Set</b> <b>the</b> <b>Pixel</b> <b>Count</b> <b>per</b> <b>Drawing</b> <b>Unit</b>
       This  code  exports the modelspace with an extent of 5 x 3 drawing units with 100 pixels per drawing unit
       as a 500 x 300 pixel image.

       Use case: render the content with a fixed number of pixels for a drawing unit, e.g. a drawing unit  of  1
       inch should be rendered by 100 pixels.

       <b>SEE</b> <b>ALSO:</b>

          • Full example script: <u>export_image_pixel_size.py</u>

          • Source: <u>https://github.com/mozman/ezdxf/discussions/357</u>


          # -x-x-x snip -x-x-x-
          def set_pixel_density(fig: plt.Figure, ax: plt.Axes, ppu: int):
              """Argument `ppu` is pixels per drawing unit."""
              xmin, xmax = ax.get_xlim()
              width = xmax - xmin
              ymin, ymax = ax.get_ylim()
              height = ymax - ymin
              dpi = fig.dpi
              width_inch = width * ppu / dpi
              height_inch = height * ppu / dpi
              fig.set_size_inches(width_inch, height_inch)


          # -x-x-x snip -x-x-x-
          # export image with 100 pixels per drawing unit = 500x300 pixels
          set_pixel_density(fig, ax, 100)
          fig.savefig("box_500x300.png")
          plt.close(fig)

   <b>How</b> <b>to</b> <b>Export</b> <b>a</b> <b>Specific</b> <b>Image</b> <b>Size</b> <b>in</b> <b>Pixels</b>
       This code exports the modelspace with an extent of 5 x 3 drawing units as a 1000 x 600 pixel Image.

       Use case: render the content with a fixed image size in pixels.

       <b>SEE</b> <b>ALSO:</b>

          • Full example script: <u>export_image_pixel_size.py</u>

          • Source: <u>https://github.com/mozman/ezdxf/discussions/357</u>


          # -x-x-x snip -x-x-x-
          def set_pixel_size(fig: plt.Figure, size: tuple[int, int]):
              x, y = size
              fig.set_size_inches(x / fig.dpi, y / fig.dpi)


          # -x-x-x snip -x-x-x-
          # export image with a size of 1000x600 pixels
          set_pixel_size(fig, (1000, 600))
          fig.savefig("box_1000x600.png")
          plt.close(fig)

   <b>How</b> <b>to</b> <b>Set</b> <b>the</b> <b>Page</b> <b>Size</b> <b>in</b> <b>Inches</b>
       The page- or image size in inches is set by the <b>set_size_inches()</b> method of the <b>Figure</b> class. The content
       within the <b>Axes</b> limits will be scaled to fill the page.

       Use  case:  render  the whole content to a PDF document with a specific paper size without worrying about
       scale.

          fig.set_size_inches(8, 11)

   <b>How</b> <b>to</b> <b>Render</b> <b>at</b> <b>a</b> <b>Specific</b> <b>Scale</b>
       This code exports the modelspace at a specific scale and paper size.

       Use case: render the content to a PDF document with a specific paper size and scale, but not all  content
       may be rendered.

       <b>SEE</b> <b>ALSO:</b>

          • Full example script: <u>render_to_scale.py</u>

          • Source: <u>https://github.com/mozman/ezdxf/discussions/665</u>


          # -x-x-x snip -x-x-x-
          def render_limits(
              origin: tuple[float, float],
              size_in_inches: tuple[float, float],
              scale: float,
          ) -&gt; tuple[float, float, float, float]:
              """Returns the final render limits in drawing units.

              Args:
                   origin: lower left corner of the modelspace area to render
                   size_in_inches: paper size in inches
                   scale: render scale, e.g. scale=100 means 1:100, 1m is
                       rendered as 0.01m or 1cm on paper

              """
              min_x, min_y = origin
              max_x = min_x + size_in_inches[0] * scale
              max_y = min_y + size_in_inches[1] * scale
              return min_x, min_y, max_x, max_y

          def export_to_scale(
              paper_size: tuple[float, float] = (8.5, 11),
              origin: tuple[float, float] = (0, 0),
              scale: float = 1,
              dpi: int = 300,
          ):
              """Render the modelspace content with to a specific paper size and scale.

              Args:
                  paper_size: paper size in inches
                  origin: lower left corner of the modelspace area to render
                  scale: render scale, e.g. scale=100 means 1:100, 1m is
                      rendered as 0.01m or 1cm on paper
                  dpi: pixel density on paper as dots per inch

              """

              # -x-x-x snip -x-x-x-
              ctx = RenderContext(doc)
              fig: plt.Figure = plt.figure(dpi=dpi)
              ax: plt.Axes = fig.add_axes([0, 0, 1, 1])

              # disable all margins
              <a href="../man0/ax.margins.0.html">ax.margins</a>(0)

              # get the final render limits in drawing units:
              min_x, min_y, max_x, max_y = render_limits(
                  origin, paper_size, scale
              )

              ax.set_xlim(min_x, max_x)
              ax.set_ylim(min_y, max_y)

              out = MatplotlibBackend(ax)
              # finalizing invokes auto-scaling by default!
              Frontend(ctx, out).draw_layout(msp, finalize=False)

              # set output size in inches:
              fig.set_size_inches(paper_size[0], paper_size[1], forward=True)

              fig.savefig(f"image_scale_1_{scale}.pdf", dpi=dpi)
              plt.close(fig)

   <b>How</b> <b>to</b> <b>Control</b> <b>the</b> <b>Line</b> <b>Width</b>
       The  DXF  <b>lineweight</b>  attribute  defines the line width as absolute width on the output medium (e.g. 25 =
       0.25mm) and therefore depends only on the DPI (dots per  inch)  setting  of  the  <b>Figure</b>  class  and  the
       <b>savefig()</b> method.

       There are two additional settings in the <u>Configuration</u> class which influences the line width:

       • <u>min_lineweight</u> sets the minimum line width in 1/300 inch - a value of 300 is a line width of 1 inch

       • <u>lineweight_scaling</u>, multiply the line width by a this factor

       The  following table shows the line width in pixels for all valid DXF lineweights for a resolution of 72,
       100, 200 and 300 dpi: [image]

       <b>SEE</b> <b>ALSO:</b>
          Discussion: <u>https://github.com/mozman/ezdxf/discussions/797</u>

</pre><h4><b>FAQ</b></h4><pre>
       These are the old FAQ until late 2023, new FAQs will only be added to the <u>Knowledge</u> <u>Graph</u>.

   <b>What</b> <b>is</b> <b>the</b> <b>Relationship</b> <b>between</b> <b>ezdxf,</b> <b>dxfwrite</b> <b>and</b> <b>dxfgrabber?</b>
       In 2010 I started my first Python package for creating DXF documents called <u>dxfwrite</u>, this package  can’t
       read  DXF files and writes only the DXF R12 (AC1009) version.  While <u>dxfwrite</u> works fine, I wanted a more
       versatile package, that can read and write DXF files and maybe also supports newer DXF formats  than  DXF
       R12.

       This  was the start of the <u>ezdxf</u> package in 2011, but the progress was so slow, that I created a spin off
       in 2012 called <u>dxfgrabber</u>, which implements only the reading part of <u>ezdxf</u>, which I needed  for  my  work
       and  I  wasn’t sure if <u>ezdxf</u> will ever be usable. Luckily in 2014 the first usable version of <u>ezdxf</u> could
       be released. The <u>ezdxf</u> package has all the features of <u>dxfwrite</u> and <u>dxfgrabber</u> and much more, but with  a
       different API. So <u>ezdxf</u> is not a drop-in replacement for <u>dxfgrabber</u> or <u>dxfwrite</u>.

       Since  <u>ezdxf</u>  can  do all the things that <u>dxfwrite</u> and <u>dxfgrabber</u> can do, I focused on the development of
       <u>ezdxf</u>, <u>dxfwrite</u> and <u>dxfgrabber</u> are in maintenance-only mode and will  not  get  any  new  features,  just
       bugfixes.

       There  are  no  advantages  of  <u>dxfwrite</u>  over  <u>ezdxf</u>,  <u>dxfwrite</u>  has a smaller memory footprint, but the
       <b>r12writer</b> add-on does the same job as <u>dxfwrite</u> without any in-memory structures by writing  direct  to  a
       stream  or  file  and  there  is  also  no advantage of <u>dxfgrabber</u> over <u>ezdxf</u> for ordinary DXF files, the
       smaller memory footprint of <u>dxfgrabber</u> is not noticeable and for really big files the <b>iterdxf</b> add-on does
       a better job.

   <b>Imported</b> <b>ezdxf</b> <b>package</b> <b>has</b> <b>no</b> <b>content.</b> <b>(readfile,</b> <b>new)</b>
       1. AttributeError: partially initialized module ‘ezdxf’ has no attribute ‘readfile’ (most likely due to a
          circular import)

          Did you name your file/script “ezdxf.py”? This causes problems with circular  imports.  Renaming  your
          file/script should solve this issue.

       2. AttributeError: module ‘ezdxf’ has no attribute ‘readfile’

          This  could  be  a  hidden  permission  error,  for more information about this issue read Petr Zemeks
          article: <u>https://blog.petrzemek.net/2020/11/17/when-you-import-a-python-package-and-it-is-empty/</u>

   <b>How</b> <b>to</b> <b>add/edit</b> <b>ACIS</b> <b>based</b> <b>entities</b> <b>like</b> <b>3DSOLID,</b> <b>REGION</b> <b>or</b> <b>SURFACE?</b>
       The BODY, 3DSOLID, SURFACE, REGION and so on, are stored as ACIS data embedded in the DXF file. The  ACIS
       data  is  stored as SAT (text) format in the entity itself for DXF R2000-R2010 and as SAB (binary) format
       in the ACDSDATA section for DXF R2013+. <u>Ezdxf</u> can read SAT and SAB data, but only write SAT data.

       The ACIS data is a proprietary format from <u>Spatial</u> <u>Inc.</u>, and there exist no free available  documentation
       or  open source libraries to create or edit SAT or SAB data, and also <u>ezdxf</u> provides no functionality for
       creating or editing ACIS data.

       The ACIS support provided by <u>ezdxf</u> is only useful for users which  have  access  to  the  ACIS  SDK  from
       <u>Spatial</u> <u>Inc.</u>.

   <b>Are</b> <b>OLE/OLE2</b> <b>entities</b> <b>supported?</b>
       TLDR; NO!

       The  Wikipedia  definition of <u>OLE</u>: Object Linking &amp; Embedding (OLE) is a proprietary technology developed
       by Microsoft that allows embedding and linking to documents and other objects. For developers, it brought
       OLE Control Extension (OCX), a way to develop and use custom user  interface  elements.  On  a  technical
       level,  an  OLE object is any object that implements the <b>IOleObject</b> interface, possibly along with a wide
       range of other interfaces, depending on the object’s needs.

       Therefore <u>ezdxf</u> does not support this entities in any way,  this  only  work  on  Windows  and  with  the
       required editing application installed.  The binary data stored in the OLE objects cannot be used without
       the editing application.

       In  my  opinion, using OLE objects in a CAD drawing is a very bad design decision that can and will cause
       problems opening these files in the future,  even  in  AutoCAD  on  Windows  when  the  required  editing
       application is no longer available or the underlying technology is no longer supported.

       All  of  this is unacceptable for a data storage format that should be accessed for many years or decades
       (e.g. construction drawings for buildings or bridges).

   <b>Rendering</b> <b>SHX</b> <b>fonts</b>
       The SHX font format is not documented nor supported by many libraries/packages like  <u>Matplotlib</u>  and  <u>Qt</u>,
       therefore  only  SHX fonts which have corresponding TTF-fonts can be rendered by these backends. See also
       how-tos about <u>Fonts</u>

   <b>Drawing</b> <b>Add-on</b>
       There is a dedicated how-to section for the <u>Drawing</u> <u>Add-on</u>.

   <b>Is</b> <b>the</b> <b>AutoCAD</b> <b>command</b> <b>XYZ</b> <b>available?</b>
       TLDR; Would you expect Photoshop features from a JPG library?

       The package is designed as an interface to the DXF format and  therefore  does  not  offer  any  advanced
       features  of  interactive  CAD  applications.  First,  some  tasks are difficult to perform without human
       guidance, and second, in complex situations, it’s not that easy to tell a “headless” system what  exactly
       to do, so it’s very likely that not many users would ever use these features, despite the fact that a lot
       of time and effort would have to be spent on development, testing and long-term support.

</pre><h4><b>REFERENCE</b></h4><pre>
       The <u>DXF</u> <u>Reference</u> is online available at <u>Autodesk</u>.

       Quoted from the original DXF 12 Reference which is not available on the web:
          Since  the  AutoCAD  drawing  database  (.dwg  file)  is  written  in  a  compact  format that changes
          significantly as new features are added to AutoCAD, we do not document its format and do not recommend
          that you attempt to write programs to read it directly. To assist in  interchanging  drawings  between
          AutoCAD  and  other  programs,  a  Drawing  Interchange  file  format  (DXF)  has  been  defined.  All
          implementations of AutoCAD accept this format and are able to convert it to and  from  their  internal
          drawing file representation.

   <b>DXF</b> <b>Document</b>
   <b>Document</b> <b>Management</b>
   <b>Create</b> <b>New</b> <b>Drawings</b>
       <b>ezdxf.new(dxfversion='AC1027',</b> <b>setup=False,</b> <b>units=6)</b> <b>-&gt;</b> <u>Drawing</u>
              Create a new <b>Drawing</b> from scratch, <u>dxfversion</u> can be either “AC1009” the official DXF version name
              or “R12” the AutoCAD release name.

              <u>new()</u> can create drawings for following DXF versions:
                                                ┌─────────┬─────────────────┐
                                                │ Version │ AutoCAD Release │
                                                ├─────────┼─────────────────┤
                                                │ AC1009  │ AutoCAD R12     │
                                                ├─────────┼─────────────────┤
                                                │ AC1015  │ AutoCAD R2000   │
                                                ├─────────┼─────────────────┤
                                                │ AC1018  │ AutoCAD R2004   │
                                                ├─────────┼─────────────────┤
                                                │ AC1021  │ AutoCAD R2007   │
                                                ├─────────┼─────────────────┤
                                                │ AC1024  │ AutoCAD R2010   │
                                                ├─────────┼─────────────────┤
                                                │ AC1027  │ AutoCAD R2013   │
                                                ├─────────┼─────────────────┤
                                                │ AC1032  │ AutoCAD R2018   │
                                                └─────────┴─────────────────┘

              The <u>units</u> argument defines th document and modelspace units. The header variable $MEASUREMENT will
              be  set  according to the given <u>units</u>, 0 for inch, feet, miles, … and 1 for metric units. For more
              information go to module <u>ezdxf.units</u>

              <b>Parameters</b>

                     • <b>dxfversion</b> – DXF version specifier as string, default is “AC1027” respectively “R2013”

                     • <b>setup</b> –

                       setup default styles, <b>False</b> for no setup, <b>True</b> to setup everything or a list of topics as
                       strings, e.g. [“linetypes”, “styles”] to setup only some topics:
                                       ───────────────────────────────────────────────────────
                                       │ Topic        │ Description                          │
                                       ├──────────────┼──────────────────────────────────────┤
                                       │ linetypes    │ setup line types                     │
                                       ├──────────────┼──────────────────────────────────────┤
                                       │ styles       │ setup text styles                    │
                                       ├──────────────┼──────────────────────────────────────┤
                                       │ dimstyles    │ setup default <u>ezdxf</u> dimension styles │
                                       ├──────────────┼──────────────────────────────────────┤
                                       │ visualstyles │ setup 25 standard visual styles      │
                                       └──────────────┴──────────────────────────────────────┘

                     • <b>units</b> – document and modelspace units, default is 6 for meters

   <b>Open</b> <b>Drawings</b>
       Open DXF drawings from file system or text stream, byte stream usage is not supported.

       DXF files prior to R2007 requires file encoding defined by header variable $DWGCODEPAGE,  DXF  R2007  and
       later requires an UTF-8 encoding.

       <u>ezdxf</u> supports reading of files for following DXF versions:
                            ┌──────────┬─────────┬──────────────┬────────────────────────┐
                            │ Version  │ Release │ Encoding     │ Remarks                │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ &lt; AC1009 │         │ $DWGCODEPAGE │ pre     AutoCAD    R12 │
                            │          │         │              │ upgraded to AC1009     │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1009   │ R12     │ $DWGCODEPAGE │ AutoCAD R12            │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1012   │ R13     │ $DWGCODEPAGE │ AutoCAD  R13  upgraded │
                            │          │         │              │ to AC1015              │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1014   │ R14     │ $DWGCODEPAGE │ AutoCAD  R14  upgraded │
                            │          │         │              │ to AC1015              │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1015   │ R2000   │ $DWGCODEPAGE │ AutoCAD R2000          │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1018   │ R2004   │ $DWGCODEPAGE │ AutoCAD R2004          │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1021   │ R2007   │ UTF-8        │ AutoCAD R2007          │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1024   │ R2010   │ UTF-8        │ AutoCAD R2010          │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1027   │ R2013   │ UTF-8        │ AutoCAD R2013          │
                            ├──────────┼─────────┼──────────────┼────────────────────────┤
                            │ AC1032   │ R2018   │ UTF-8        │ AutoCAD R2018          │
                            └──────────┴─────────┴──────────────┴────────────────────────┘

       <b>ezdxf.readfile(filename:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>encoding:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>errors:</b> <b>str</b> <b>=</b> <b>'surrogateescape')</b> <b>-&gt;</b>
       <u>Drawing</u>
              Read the DXF document <u>filename</u> from the file-system.

              This is the preferred method to load existing  ASCII  or  Binary  DXF  files,  the  required  text
              encoding will be detected automatically and decoding errors will be ignored.

              Override  encoding  detection  by setting argument <u>encoding</u> to the estimated encoding. (use Python
              encoding names like in the <b>open()</b> function).

              If this function struggles to load the DXF document and raises a <b>DXFStructureError</b> exception,  try
              the <u>ezdxf.recover.readfile()</u> function to load this corrupt DXF document.

              <b>Parameters</b>

                     • <b>filename</b> – filename of the ASCII- or Binary DXF document

                     • <b>encoding</b>  –  use <b>None</b> for auto detect (default), or set a specific encoding like “utf-8”,
                       argument is ignored for Binary DXF files

                     • <b>errors</b> –

                       specify decoding error handler

                       • ”surrogateescape” to preserve possible binary data (default)

                       • ”ignore” to use the replacement char U+FFFD “�” for invalid data

                       • ”strict” to raise an <b>UnicodeDecodeError</b> exception for invalid data

              <b>Raises</b>

                     • <b>IOError</b> – not a DXF file or file does not exist

                     • <u>DXFStructureError</u> – for invalid or corrupted DXF structures

                     • <b>UnicodeDecodeError</b> – if <u>errors</u> is “strict” and a decoding error occurs

       <b>ezdxf.read(stream:</b> <b>TextIO)</b> <b>-&gt;</b> <u>Drawing</u>
              Read a DXF document from a text-stream. Open stream in text mode (<b>mode='rt'</b>) and set correct  text
              encoding, the stream requires at least a <b>readline()</b> method.

              Since  DXF  version  R2007  (AC1021)  file  encoding  is  always  “utf-8”, use the helper function
              <b>dxf_stream_info()</b> to detect the required  text  encoding  for  prior  DXF  versions.  To  preserve
              possible binary data in use <b>errors='surrogateescape'</b> as error handler for the import stream.

              If  this function struggles to load the DXF document and raises a <b>DXFStructureError</b> exception, try
              the <u>ezdxf.recover.read()</u> function to load this corrupt DXF document.

              <b>Parameters</b>
                     <b>stream</b> – input text stream opened with correct encoding

              <b>Raises</b> <u>DXFStructureError</u> – for invalid or corrupted DXF structures

       <b>ezdxf.readzip(zipfile:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>filename:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>errors:</b> <b>str</b> <b>=</b> <b>'surrogateescape')</b> <b>-&gt;</b>
       <u>Drawing</u>
              Load a DXF document specified by <u>filename</u> from a zip archive, or if <u>filename</u> is <b>None</b> the first DXF
              document in the zip archive.

              <b>Parameters</b>

                     • <b>zipfile</b> – name of the zip archive

                     • <b>filename</b> – filename of DXF file, or <b>None</b> to load the first  DXF  document  from  the  zip
                       archive.

                     • <b>errors</b> –

                       specify decoding error handler

                       • ”surrogateescape” to preserve possible binary data (default)

                       • ”ignore” to use the replacement char U+FFFD “�” for invalid data

                       • ”strict” to raise an <b>UnicodeDecodeError</b> exception for invalid data

              <b>Raises</b>

                     • <b>IOError</b> – not a DXF file or file does not exist or
                           if <u>filename</u> is <b>None</b> - no DXF file found

                     • <u>DXFStructureError</u> – for invalid or corrupted DXF structures

                     • <b>UnicodeDecodeError</b> – if <u>errors</u> is “strict” and a decoding error occurs

       <b>ezdxf.decode_base64(data:</b> <b>bytes,</b> <b>errors:</b> <b>str</b> <b>=</b> <b>'surrogateescape')</b> <b>-&gt;</b> <u>Drawing</u>
              Load a DXF document from base64 encoded binary data, like uploaded data to web applications.

              <b>Parameters</b>

                     • <b>data</b> – DXF document base64 encoded binary data

                     • <b>errors</b> –

                       specify decoding error handler

                       • ”surrogateescape” to preserve possible binary data (default)

                       • ”ignore” to use the replacement char U+FFFD “�” for invalid data

                       • ”strict” to raise an <b>UnicodeDecodeError</b> exception for invalid data

              <b>Raises</b>

                     • <u>DXFStructureError</u> – for invalid or corrupted DXF structures

                     • <b>UnicodeDecodeError</b> – if <u>errors</u> is “strict” and a decoding error occurs

       <b>HINT:</b>
          This  works  well  with DXF files from trusted sources like AutoCAD or BricsCAD, for loading DXF files
          with minor or major flaws look at the <u>ezdxf.recover</u> module.

   <b>Save</b> <b>Drawings</b>
       Save the DXF document to the file system by <u>Drawing</u> methods <u>save()</u> or <u>saveas()</u>.  Write the  DXF  document
       to  a  text  stream with <u>write()</u>, the text stream requires at least a <b>write()</b> method. Get required output
       encoding for text streams by property <b>Drawing.output_encoding</b>

   <b>Drawing</b> <b>Settings</b>
       The <u>HeaderSection</u> stores meta data like modelspace extensions, user  name  or  saving  time  and  current
       application  settings,  like actual layer, text style or dimension style settings. These settings are not
       necessary to process DXF  data  and  therefore  many  of  this  settings  are  not  maintained  by  <u>ezdxf</u>
       automatically.

   <b>Header</b> <b>variables</b> <b>set</b> <b>at</b> <b>new</b>
                               ┌──────────────────┬───────────────────────────────────┐
                               │ $ACADVER         │ DXF version                       │
                               ├──────────────────┼───────────────────────────────────┤
                               │ $TDCREATE        │ date/time at creating the drawing │
                               ├──────────────────┼───────────────────────────────────┤
                               │ $FINGERPRINTGUID │ every drawing gets a GUID         │
                               └──────────────────┴───────────────────────────────────┘

   <b>Header</b> <b>variables</b> <b>updated</b> <b>at</b> <b>saving</b>
                                ┌──────────────┬─────────────────────────────────────┐
                                │ $TDUPDATE    │ actual date/time at saving          │
                                ├──────────────┼─────────────────────────────────────┤
                                │ $HANDSEED    │ next available handle as hex string │
                                ├──────────────┼─────────────────────────────────────┤
                                │ $DWGCODEPAGE │ encoding setting                    │
                                ├──────────────┼─────────────────────────────────────┤
                                │ $VERSIONGUID │ every saved version gets a new GUID │
                                └──────────────┴─────────────────────────────────────┘

       <b>SEE</b> <b>ALSO:</b>

          • Howto: <u>Set/Get</u> <u>Header</u> <u>Variables</u>

          • Howto: <u>Set</u> <u>DXF</u> <u>Drawing</u> <u>Units</u>

   <b>Ezdxf</b> <b>Metadata</b>
       Store  internal  metadata  like <u>ezdxf</u> version and creation time for a new created document as metadata in
       the DXF file. Only standard DXF features are used to store meta data and this meta data is  preserved  by
       Autodesk products, BricsCAD and of course <u>ezdxf</u>. Other 3rd party DXF libraries may remove this meta data.

       For DXF R12 the meta data is stored as XDATA by AppID <b>EZDXF</b> in the model space BLOCK entity in the BLOCKS
       section.

       For  DXF  R2000+  the meta data is stored in the “root” DICTIONARY in the OBJECTS section as a DICTIONARY
       object by the key <b>EZDXF_META</b>.

       The <b>MetaData</b> object has a dict-like interface and can also store custom metadata:

          metadata = doc.ezdxf_metadata()

          # set data
          metadata["MY_CUSTOM_META_DATA"] = "a string with max. length of 254"

          # get data, raises a KeyError() if key not exist
          value = metadata["MY_CUSTOM_META_DATA"]

          # get data, returns an empty string if key not exist
          value = metadata.get("MY_CUSTOM_META_DATA")

          # delete entry, raises a KeyError() if key not exist
          del metadata["MY_CUSTOM_META_DATA"]

          # discard entry, does not raise a KeyError() if key not exist
          metadata.discard("MY_CUSTOM_META_DATA")

       Keys and values are limited to strings with a max. length of 254 characters and line ending  <b>\n</b>  will  be
       replaced by <b>\P</b>.

       Keys used by <u>ezdxf</u>:

          • <b>WRITTEN_BY_EZDXF</b>: <u>ezdxf</u> version and UTC time in ISO format

          • <b>CREATED_BY_EZDXF</b>: <u>ezdxf</u> version and UTC time in ISO format

       Example of the ezdxf marker string: <b>0.16.4b1</b> <b>@</b> <b>2021-06-12T07:35:34.898808+00:00</b>

       <b>class</b> <b>ezdxf.document.MetaData</b>

              <b>abstract</b> <b>MetaData.__contains__(key:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <u>key</u> <b>in</b> self.

              <b>abstract</b> <b>MetaData.__getitem__(key:</b> <b>str)</b> <b>-&gt;</b> <b>str</b>
                     Returns the value for self[<u>key</u>].

                     <b>Raises</b> <b>KeyError</b> – <u>key</u> does not exist

              <b>MetaData.get(key:</b> <b>str,</b> <b>default:</b> <b>str</b> <b>=</b> <b>'')</b> <b>-&gt;</b> <b>str</b>
                     Returns the value for <u>key</u>. Returns <u>default</u> if <u>key</u> not exist.

              <b>abstract</b> <b>MetaData.__setitem__(key:</b> <b>str,</b> <b>value:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Set self[<u>key</u>] to <u>value</u>.

              <b>abstract</b> <b>MetaData.__delitem__(key:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Delete self[<u>key</u>].

                     <b>Raises</b> <b>KeyError</b> – <u>key</u> does not exist

              <b>MetaData.discard(key:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Remove <u>key</u>, does <b>not</b> raise an exception if <u>key</u> not exist.

   <b>Drawing</b> <b>Class</b>
       The <u>Drawing</u> class is the central management structure of a DXF document.

   <b>Access</b> <b>Layouts</b>
       • <u>Drawing.modelspace()</u>

       • <u>Drawing.paperspace()</u>

   <b>Access</b> <b>Resources</b>
       • Application ID Table: <u>Drawing.appids</u>

       • Block Definition Table: <u>Drawing.blocks</u>

       • Dimension Style Table: <u>Drawing.dimstyles</u>

       • Layer Table: <u>Drawing.layers</u>

       • Linetype Table: <u>Drawing.linetypes</u>

       • MLeader Style Table: <u>Drawing.mleader_styles</u>

       • MLine Style Table: <u>Drawing.mline_styles</u>

       • Material Table: <u>Drawing.materials</u>

       • Text Style Table: <u>Drawing.styles</u>

       • UCS Table: <u>Drawing.ucs</u>

       • VPort Table: <u>Drawing.viewports</u>

       • View Table: <u>Drawing.views</u>

       • Classes Section: <u>Drawing.classes</u>

       • Object Section: <u>Drawing.objects</u>

       • Entity Database: <b>Drawing.entitydb</b>

       • Entity Groups: <u>Drawing.groups</u>

       • Header Variables: <u>Drawing.header</u>

   <b>Drawing</b> <b>Class</b>
       <b>class</b> <b>ezdxf.document.Drawing</b>
              The <u>Drawing</u> class is the central management structure of a DXF document.

              <b>dxfversion</b>
                     Actual DXF version like <b>'AC1009'</b>, set by <u>ezdxf.new()</u> or <u>ezdxf.readfile()</u>.

                     For supported DXF versions see <u>Document</u> <u>Management</u>

              <b>acad_release</b>
                     The AutoCAD release name like <b>'R12'</b> or <b>'R2000'</b> for actual <u>dxfversion</u>.

              <b>encoding</b>
                     Text  encoding of <u>Drawing</u>, the default encoding for new drawings is <b>'cp1252'</b>. Starting with
                     DXF R2007 (AC1021), DXF files are written as UTF-8 encoded text files,  regardless  of  the
                     attribute <u>encoding</u>.  The text encoding can be changed to encodings listed below.

                     see also: <u>DXF</u> <u>File</u> <u>Encoding</u>
                                                   ┌───────────┬────────────────┐
                                                   │ supported │ encodings      │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp874'</b>   │ Thai           │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp932'</b>   │ Japanese       │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'gbk'</b>     │ UnifiedChinese │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp949'</b>   │ Korean         │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp950'</b>   │ TradChinese    │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1250'</b>  │ CentralEurope  │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1251'</b>  │ Cyrillic       │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1252'</b>  │ WesternEurope  │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1253'</b>  │ Greek          │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1254'</b>  │ Turkish        │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1255'</b>  │ Hebrew         │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1256'</b>  │ Arabic         │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1257'</b>  │ Baltic         │
                                                   ├───────────┼────────────────┤
                                                   │ <b>'cp1258'</b>  │ Vietnam        │
                                                   └───────────┴────────────────┘

              <b>output_encoding</b>
                     Returns required output encoding for saving to filesystem or encoding to binary data.

              <b>filename</b>
                     <u>Drawing</u> filename, if loaded by <u>ezdxf.readfile()</u> else <b>None</b>.

              <b>rootdict</b>
                     Reference to the root dictionary of the OBJECTS section.

              <b>header</b> Reference to the <u>HeaderSection</u>, get/set drawing settings as header variables.

              <b>entities</b>
                     Reference to the <b>EntitySection</b> of the drawing, where all graphical entities are stored, but
                     only  from modelspace and the <u>active</u> paperspace layout. Just for your information: Entities
                     of other paperspace layouts are stored as <u>BlockLayout</u> in the <u>BlocksSection</u>.

              <b>objects</b>
                     Reference to the objects section, see also <u>ObjectsSection</u>.

              <b>blocks</b> Reference to the blocks section, see also <u>BlocksSection</u>.

              <b>tables</b> Reference to the tables section, see also <u>TablesSection</u>.

              <b>classes</b>
                     Reference to the classes section, see also <u>ClassesSection</u>.

              <b>layouts</b>
                     Reference to the layout manager, see also <u>Layouts</u>.

              <b>groups</b> Collection of all groups, see also <u>GroupCollection</u>.

                     requires DXF R13 or later

              <b>layers</b> Shortcut for <b>Drawing.tables.layers</b>

                     Reference to the layers table, where you can create, get and remove layers, see also  <u>Table</u>
                     and <u>Layer</u>

              <b>styles</b> Shortcut for <b>Drawing.tables.styles</b>

                     Reference to the styles table, see also <u>Textstyle</u>.

              <b>dimstyles</b>
                     Shortcut for <b>Drawing.tables.dimstyles</b>

                     Reference to the dimstyles table, see also <u>DimStyle</u>.

              <b>linetypes</b>
                     Shortcut for <b>Drawing.tables.linetypes</b>

                     Reference to the linetypes table, see also <u>Linetype</u>.

              <b>views</b>  Shortcut for <b>Drawing.tables.views</b>

                     Reference to the views table, see also <u>View</u>.

              <b>viewports</b>
                     Shortcut for <b>Drawing.tables.viewports</b>

                     Reference to the viewports table, see also <u>VPort</u>.

              <b>ucs</b>    Shortcut for <b>Drawing.tables.ucs</b>

                     Reference to the ucs table, see also <u>UCSTableEntry</u>.

              <b>appids</b> Shortcut for <b>Drawing.tables.appids</b>

                     Reference to the appids table, see also <u>AppID</u>.

              <b>materials</b>
                     <b>MaterialCollection</b> of all <b>Material</b> objects.

              <b>mline_styles</b>
                     <b>MLineStyleCollection</b> of all <u>MLineStyle</u> objects.

              <b>mleader_styles</b>
                     <b>MLeaderStyleCollection</b> of all <u>MLeaderStyle</u> objects.

              <b>units</b>  Get and set the document/modelspace base units as enum, for more information read this: <u>DXF</u>
                     <u>Units</u>.

              <b>get_abs_filepath</b> <b>=</b> <b>&lt;function</b> <b>Drawing.get_abs_filepath&gt;</b>

              <b>save(encoding:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>fmt:</b> <b>str</b> <b>=</b> <b>'asc')</b> <b>-&gt;</b> <b>None</b>
                     Write  drawing  to  file-system  by using the <u>filename</u> attribute as filename. Override file
                     encoding by argument <u>encoding</u>, handle with care, but this option allows you to  create  DXF
                     files for applications that handle file encoding different from AutoCAD.

                     <b>Parameters</b>

                            • <b>encoding</b> – override default encoding as Python encoding string like <b>'utf-8'</b>

                            • <b>fmt</b> – <b>'asc'</b> for ASCII DXF (default) or <b>'bin'</b> for Binary DXF

              <b>saveas(filename:</b> <b>PathLike</b> <b>|</b> <b>str,</b> <b>encoding:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>fmt:</b> <b>str</b> <b>=</b> <b>'asc')</b> <b>-&gt;</b> <b>None</b>
                     Set  <u>Drawing</u>  attribute <u>filename</u> to <u>filename</u> and write drawing to the file system. Override
                     file encoding by argument <u>encoding</u>, handle with care, but this option allows you to  create
                     DXF files for applications that handles file encoding different than AutoCAD.

                     <b>Parameters</b>

                            • <b>filename</b> – file name as string

                            • <b>encoding</b> – override default encoding as Python encoding string like <b>'utf-8'</b>

                            • <b>fmt</b> – <b>'asc'</b> for ASCII DXF (default) or <b>'bin'</b> for Binary DXF

              <b>write(stream:</b> <b>TextIO</b> <b>|</b> <b>BinaryIO,</b> <b>fmt:</b> <b>str</b> <b>=</b> <b>'asc')</b> <b>-&gt;</b> <b>None</b>
                     Write  drawing  as  ASCII DXF to a text stream or as Binary DXF to a binary stream. For DXF
                     R2004 (AC1018) and prior open stream with drawing <u>encoding</u> and  <b>mode='wt'</b>.  For  DXF  R2007
                     (AC1021)  and  later  use  <b>encoding='utf-8'</b>, or better use the later added <u>Drawing</u> property
                     <u>output_encoding</u> which returns the correct encoding automatically. The correct and  required
                     error handler is <b>errors='dxfreplace'</b>!

                     If  writing  to  a  <b>StringIO</b>  stream, use <u>Drawing.encode()</u> to encode the result string from
                     <b>StringIO.get_value()</b>:

                        binary = doc.encode(stream.get_value())

                     <b>Parameters</b>

                            • <b>stream</b> – output text stream or binary stream

                            • <b>fmt</b> – “asc” for ASCII DXF (default) or “bin” for binary DXF

              <b>encode_base64()</b> <b>-&gt;</b> <b>bytes</b>
                     Returns DXF document as base64 encoded binary data.

              <b>encode(s:</b> <b>str)</b> <b>-&gt;</b> <b>bytes</b>
                     Encode string <u>s</u> with correct encoding and error handler.

              <b>query(query:</b> <b>str</b> <b>=</b> <b>'*')</b> <b>-&gt;</b> <u>EntityQuery</u>
                     Entity query over all layouts and blocks, excluding the OBJECTS section  and  the  resource
                     tables of the TABLES section.

                     <b>Parameters</b>
                            <b>query</b> – query string

                     <b>SEE</b> <b>ALSO:</b>
                        <u>Entity</u> <u>Query</u> <u>String</u> and <u>Retrieve</u> <u>entities</u> <u>by</u> <u>query</u> <u>language</u>

              <b>groupby(dxfattrib='',</b> <b>key=None)</b> <b>-&gt;</b> <b>dict</b>
                     Groups  DXF  entities  of  all  layouts and blocks (excluding the OBJECTS section) by a DXF
                     attribute or a key function.

                     <b>Parameters</b>

                            • <b>dxfattrib</b> – grouping DXF attribute like “layer”

                            • <b>key</b> – key function, which accepts a <b>DXFEntity</b> as argument and returns  a  hashable
                              grouping key or <b>None</b> to ignore this entity.

                     <b>SEE</b> <b>ALSO:</b>
                        <u>groupby()</u> documentation

              <b>modelspace()</b> <b>-&gt;</b> <b>Modelspace</b>
                     Returns  the  modelspace  layout,  displayed as “Model” tab in CAD applications, defined by
                     block record named “*Model_Space”.

              <b>paperspace(name:</b> <b>str</b> <b>=</b> <b>'')</b> <b>-&gt;</b> <b>Paperspace</b>
                     Returns paperspace layout <u>name</u> or the active paperspace if no name is given.

                     <b>Parameters</b>
                            <b>name</b> – paperspace name or empty string for the active paperspace

                     <b>Raises</b> <b>KeyError</b> – if the modelspace was acquired or layout <u>name</u> does not exist

              <b>layout(name:</b> <b>str</b> <b>=</b> <b>'')</b> <b>-&gt;</b> <u>Layout</u>
                     Returns paperspace layout <u>name</u> or the first layout in tab-order if no name is given.

                     <b>Parameters</b>
                            <b>name</b> – paperspace name or empty string for the first paperspace in tab-order

                     <b>Raises</b> <b>KeyError</b> – layout <u>name</u> does not exist

              <b>active_layout()</b> <b>-&gt;</b> <b>Paperspace</b>
                     Returns the active paperspace layout, defined by block record name “*Paper_Space”.

              <b>layout_names()</b> <b>-&gt;</b> <b>Iterable[str]</b>
                     Returns all layout names in arbitrary order.

              <b>layout_names_in_taborder()</b> <b>-&gt;</b> <b>Iterable[str]</b>
                     Returns all layout names in tab-order, “Model” is always the first name.

              <b>new_layout(name,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <b>Paperspace</b>
                     Create a new paperspace layout <u>name</u>. Returns a <u>Paperspace</u> object. DXF R12 (AC1009) supports
                     only one paperspace layout, only the active paperspace layout is saved, other  layouts  are
                     dismissed.

                     <b>Parameters</b>

                            • <b>name</b> – unique layout name

                            • <b>dxfattribs</b> – additional DXF attributes for the <b>DXFLayout</b> entity

                     <b>Raises</b> <u>DXFValueError</u> – paperspace layout <u>name</u> already exist

              <b>page_setup(name:</b> <b>str</b> <b>=</b> <b>'Layout1',</b> <b>fmt:</b> <b>str</b> <b>=</b> <b>'ISO</b> <b>A3',</b> <b>landscape=True)</b> <b>-&gt;</b> <b>Paperspace</b>
                     Creates  a new paperspace layout if <u>name</u> does not exist or reset the existing layout.  This
                     method requires DXF R2000 or newer.  The paper format name <u>fmt</u> defines one of the following
                     paper sizes, measures in landscape orientation:
                                                ┌─────────┬───────┬───────┬────────┐
                                                │ Name    │ Units │ Width │ Height │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ISO A0  │ mm    │ 1189  │ 841    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ISO A1  │ mm    │ 841   │ 594    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ISO A2  │ mm    │ 594   │ 420    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ISO A3  │ mm    │ 420   │ 297    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ISO A4  │ mm    │ 297   │ 210    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ANSI A  │ inch  │ 11    │ 8.5    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ANSI B  │ inch  │ 17    │ 11     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ANSI C  │ inch  │ 22    │ 17     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ANSI D  │ inch  │ 34    │ 22     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ANSI E  │ inch  │ 44    │ 34     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ARCH C  │ inch  │ 24    │ 18     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ARCH D  │ inch  │ 36    │ 24     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ARCH E  │ inch  │ 48    │ 36     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ ARCH E1 │ inch  │ 42    │ 30     │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ Letter  │ inch  │ 11    │ 8.5    │
                                                ├─────────┼───────┼───────┼────────┤
                                                │ Legal   │ inch  │ 14    │ 8.5    │
                                                └─────────┴───────┴───────┴────────┘

                     The layout uses the associated units of the paper format as drawing units, has  no  margins
                     or offset defined and the scale of the paperspace layout is 1:1.

                     <b>Parameters</b>

                            • <b>name</b> – paperspace layout name

                            • <b>fmt</b> – paper format

                            • <b>landscape</b> – <b>True</b> for landscape orientation, <b>False</b> for portrait orientation

              <b>delete_layout(name:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Delete  paper  space layout <u>name</u> and all entities owned by this layout.  Available only for
                     DXF R2000 or later, DXF R12 supports only one paperspace, and it can’t be deleted.

              <b>add_image_def(filename:</b> <b>str,</b> <b>size_in_pixel:</b> <b>tuple[int,</b> <b>int],</b> <b>name=None)</b>
                     Add an image definition to the objects section.

                     Add an <b>ImageDef</b> entity to the drawing (objects section). <u>filename</u> is the image file name as
                     relative or absolute path and <u>size_in_pixel</u> is the image size in pixel as (x, y) tuple.  To
                     avoid  dependencies to external packages, <u>ezdxf</u> can not determine the image size by itself.
                     Returns a <b>ImageDef</b> entity which is needed  to  create  an  image  reference.  <u>name</u>  is  the
                     internal image name, if set to <b>None</b>, name is auto-generated.

                     Absolute  image  paths  works best for AutoCAD but not perfect, you have to update external
                     references manually in AutoCAD, which is not possible in TrueView.  If  the  drawing  units
                     differ from 1 meter, you also have to use: <u>set_raster_variables()</u>.

                     <b>Parameters</b>

                            • <b>filename</b> – image file name (absolute path works best for AutoCAD)

                            • <b>size_in_pixel</b> – image size in pixel as (x, y) tuple

                            • <b>name</b>  –  image  name  for  internal use, None for using filename as name (best for
                              AutoCAD)

                     <b>SEE</b> <b>ALSO:</b>
                        <u>Tutorial</u> <u>for</u> <u>Image</u> <u>and</u> <u>ImageDef</u>

              <b>set_raster_variables(frame:</b> <b>int</b> <b>=</b> <b>0,</b> <b>quality:</b> <b>int</b> <b>=</b> <b>1,</b> <b>units:</b> <b>str</b> <b>=</b> <b>'m')</b>
                     Set raster variables.

                     <b>Parameters</b>

                            • <b>frame</b> – 0 = do not show image frame; 1 = show image frame

                            • <b>quality</b> – 0 = draft; 1 = high

                            • <b>units</b> –

                              units for inserting images. This defines the real world unit for one drawing  unit
                              for the purpose of inserting and scaling images with an associated resolution.
                                                       ──────────────────────────────
                                                         mm   Millimeter
                                                       ──────────────────────────────
                                                         cm   Centimeter
                                                       ──────────────────────────────
                                                         m    Meter (ezdxf default)
                                                       ──────────────────────────────
                                                         km   Kilometer
                                                       ──────────────────────────────
                                                         in   Inch
                                                       ──────────────────────────────
                                                         ft   Foot
                                                       ──────────────────────────────
                                                         yd   Yard
                                                       ──────────────────────────────
                                                         mi   Mile
                                                       ┌────┬───────────────────────┐
                                                       │    │                       │
                                                       │    │                       │
              <b>set_wipeout_variables(frame=0)</b>           │    │                       │
                     Set wipeout variables.            │    │                       │
                                                       │    │                       │
                     <b>Parameters</b>                        │    │                       │
--
</pre><h4><b>LAUNCHER</b></h4><pre>
       The command line script <u>ezdxf</u> launches various sub-commands:
                               ┌─────────────┬───────────────────────────────────────┐
                               │ <b>pp</b>          │ DXF pretty printer,  replacement  for │
                               │             │ the previous <u>dxfpp</u> command            │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>audit</b>       │ Audit and repair DXF files            │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>draw</b>        │ Draw  and  convert  DXF  files by the │
                               │             │ Matplotlib backend                    │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>view</b>        │ PyQt DXF file viewer                  │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>browse</b>      │ PyQt DXF structure  browser  for  DXF │
                               │             │ debugging and curious people          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>browse-acis</b> │ PyQt  ACIS entity content browser for │
                               │             │ SAT/SAB debugging                     │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>strip</b>       │ Strip  comments  and   THUMBNAILIMAGE │
                               │             │ section from DXF files                │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>config</b>      │ Manage config files                   │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>info</b>        │ Show  information  and optional stats │
                               │             │ of DXF files as loaded by ezdxf       │
                               ├─────────────┼───────────────────────────────────────┤
                               │ <b>hpgl</b>        │ View and/or convert HPGL/2 plot files │
                               │             │ to DXF, SVG or PDF                    │
                               └─────────────┴───────────────────────────────────────┘

       The help option <b>-h</b> is supported by the main script and all sub-commands:

          C:\&gt; ezdxf -h
          usage: ezdxf [-h] [-V] [-v] [--config CONFIG] [--log LOG]
                       {pp,audit,draw,view,browse,browse-acis,strip,config} ...

          Command launcher for the Python package "ezdxf":
          https://pypi.org/project/ezdxf/

          positional arguments:
            {pp,audit,draw,view,browse,strip}
              pp                  pretty print DXF files as HTML file
              audit               audit and repair DXF files
              draw                draw and convert DXF files by Matplotlib
              view                view DXF files by the PyQt viewer
              browse              browse DXF file structure
              browse-acis         browse ACIS structures in DXF files
              strip               strip comments from DXF files
              config              manage config files
              info                show information and optional stats of DXF files loaded by ezdxf,
                                  this may not represent the original content of the file, use the
                                  browse command to see the original content

          optional arguments:
            -h, --help            show this help message and exit
            -V, --version         show version and exit
            -f, --fonts           rebuild system font cache and print all fonts found
            -v, --verbose         give more output
            --config CONFIG       path to a config file
            --log LOG             path to a verbose appending log

       <b>NOTE:</b>
          The <b>ezdxf</b> script  is the only executable script installed on the user system.

   <b>System</b>
       <b>ezdxf</b> <b>-V</b> shows the <u>ezdxf</u> and <u>Python</u> version your are running and if the C-extensions are used.

          ezdxf 1.1.0b1 from c:\source\ezdxf.git\src\ezdxf
          Python version: 3.11.2 (tags/v3.11.2:878ead1, Feb  7 2023, 16:38:35) [MSC v.1934 64 bit (AMD64)]
          using C-extensions: yes

       <b>ezdxf</b> <b>-f</b> rebuilds the system font cache and shows all fonts found.

   <b>Pretty</b> <b>Printer</b>
       Pretty print the DXF text content as HTML file and open the file in the default web browser:

          C:\&gt; ezdxf pp -o gear.dxf
       [image]

       Print help:

          C:\&gt; ezdxf pp -h
          usage: ezdxf pp [-h] [-o] [-r] [-x] [-l] [-s SECTIONS] FILE [FILE ...]

          positional arguments:
            FILE                  DXF files pretty print

          optional arguments:
            -h, --help            show this help message and exit
            -o, --open            open generated HTML file by the default web browser
            -r, --raw             raw mode, no DXF structure interpretation
            -x, --nocompile       don't compile points coordinates into single tags (only in raw mode)
            -l, --legacy          legacy mode, reorder DXF point coordinates
            -s SECTIONS, --sections SECTIONS
                                  choose sections to include and their order, h=HEADER, c=CLASSES,
                                  t=TABLES, b=BLOCKS, e=ENTITIES, o=OBJECTS

   <b>Audit</b>
       Audit and recover the DXF file “gear.dxf” and save the recovered version as “gear.rec.dxf”:

          C:\&gt; ezdxf audit -s gear.dxf

          auditing file: gear.dxf
          No errors found.
          Saved recovered file as: gear.rec.dxf

       Print help:

          C:\&gt; ezdxf audit -h
          usage: ezdxf audit [-h] [-s] FILE [FILE ...]

          positional arguments:
            FILE        audit DXF files

          optional arguments:
            -h, --help  show this help message and exit
            -s, --save  save recovered files with extension ".rec.dxf"

   <b>Draw</b>
       Convert the DXF file “gear.dxf” into a SVG file by the <u>Matplotlib</u> backend:

          C:\&gt; ezdxf draw -o gear.svg gear.dxf

       The “gear.svg” created by the <u>Matplotlib</u> backend: [image]

       Show all output formats supported by the <u>Matplotlib</u> backend on your system. This output may vary:

          C:\&gt; ezdxf draw --formats
          eps: Encapsulated Postscript
          jpg: Joint Photographic Experts Group
          jpeg: Joint Photographic Experts Group
          pdf: Portable Document Format
          pgf: PGF code for LaTeX
          png: Portable Network Graphics
          ps: Postscript
          raw: Raw RGBA bitmap
          rgba: Raw RGBA bitmap
          svg: Scalable Vector Graphics
          svgz: Scalable Vector Graphics
          tif: Tagged Image File Format
          tiff: Tagged Image File Format

       Print help:

          C:\&gt; ezdxf draw -h
          usage: ezdxf draw [-h] [--formats] [-l LAYOUT] [--all-layers-visible]
                            [--all-entities-visible] [-o OUT] [--dpi DPI] [-v]
                            [FILE]

          positional arguments:
            FILE                  DXF file to view or convert

          optional arguments:
            -h, --help            show this help message and exit
            --formats             show all supported export formats and exit
            -l LAYOUT, --layout LAYOUT
                                  select the layout to draw, default is "Model"
            --all-layers-visible  draw all layers including the ones marked as invisible
            --all-entities-visible
                                  draw all entities including the ones marked as
                                  invisible (some entities are individually marked as
                                  invisible even if the layer is visible)
            -o OUT, --out OUT     output filename for export
            --dpi DPI             target render resolution, default is 300
            -v, --verbose         give more output

   <b>View</b>
       View the DXF file “gear.dxf” by the <u>PyQt</u> backend:

          C:\&gt; ezdxf view gear.dxf
       [image]

       Print help:

          C:\&gt; ezdxf view -h
          usage: ezdxf view [-h] [-l LAYOUT] [--lwscale LWSCALE] [FILE]

          positional arguments:
            FILE                  DXF file to view

          optional arguments:
            -h, --help            show this help message and exit
            -l LAYOUT, --layout LAYOUT
                                  select the layout to draw, default is "Model"
            --lwscale LWSCALE     set custom line weight scaling, default is 0 to
                                  disable line weights at all

   <b>Browse</b>
       Browse the internal structure of a DXF file like a file system:

          C:\&gt; ezdxf browse gear.dxf
       [image]

          C:\&gt; ezdxf browse -h
          usage: ezdxf browse [-h] [-l LINE] [-g HANDLE] [FILE]

          positional arguments:
            FILE                  DXF file to browse

          optional arguments:
            -h, --help            show this help message and exit
            -l LINE, --line LINE  go to line number
            -g HANDLE, --handle HANDLE
                                  go to entity by HANDLE, HANDLE has to be a hex value without
                                  any prefix like 'fefe'

       The <u>browse</u> command stores options in the config file, e.g. for the <u>Notepad++</u> on Windows:

          [browse-command]

          text_editor = "C:\Program Files\Notepad++\notepad++.exe" "{filename}" -n{num}
          icon_size = 32

       <b>text_editor</b> is a simple format string: <b>text_editor.format(filename="test.dxf",</b> <b>num=100)</b>

       Quote commands including spaces and always quote the filename argument!

       For <u>xed</u> on Linux Mint use (note: absolute path to executable):

          [browse-command]

          text_editor = /usr/bin/xed "{filename}" +{num}
          icon_size = 32

       For <u>gedit</u> on Linux use (untested):

          [browse-command]

          text_editor = /usr/bin/gedit +{num} "{filename}"
          icon_size = 32

       The <u>browse</u> command opens a DXF structure browser to investigate the  internals  of  a  DXF  file  without
       interpreting  the  content. The functionality of the DXF browser is similar to the DXF <u>Pretty</u> <u>Printer</u> (<u>pp</u>
       command), but without the disadvantage of creating giant HTML files.  The  intended  usage  is  debugging
       invalid  DXF  files,  which  can  not  be  loaded by the <u>ezdxf.readfile()</u> or the <u>ezdxf.recover.readfile()</u>
       functions.

   <b>Line</b> <b>Numbers</b>
       The low level tag loader ignores DXF comments (group code 999). If there are comments in the DXF file the
       line numbers displayed in the DXF browser are not synchronized,  use  the  <u>strip</u>  command  beforehand  to
       remove all comments from the DXF file in order to keep the line numbers synchronized.

   <b>GUI</b> <b>Features</b>
       The  tree  view  on the left shows the outline of the DXF file. The number in round brackets on the right
       side of each item shows the count of structure entities within the structure layer, the  value  in  angle
       brackets on the left side is the entity handle.

       The right list view shows the entity content as DXF tags.  Structure tags (data type &lt;ctrl&gt;) are shown in
       blue,  a  double  click  on a reference handle (datatype &lt;ref&gt;) jumps to the referenced entity, reference
       handles of non-existent targets are shown in red.

       Clicking on the first structure tag in the list opens the DXF  reference  provided  by  Autodesk  in  the
       standard web browser.

   <b>Auto</b> <b>Reload</b>
       The  browser  automatically  displays  a  dialog for reloading DXF files if they have been modified by an
       external application.

   <b>Menus</b> <b>and</b> <b>Shortcuts</b>
       •

         <b>File</b> <b>Menu</b>

                • <b>Open</b> <b>DXF</b> <b>file…</b> <u>Ctrl+O</u>

                • <b>Reload</b> <b>DXF</b> <b>file</b> <u>Ctrl+R</u>

                • <b>Open</b> <b>in</b> <b>Text</b> <b>Editor</b> <u>Ctrl+T</u>, open the DXF file in the associated text  editor  at  the  current
                  location

                • <b>Export</b> <b>DXF</b> <b>Entity…</b> <u>Ctrl+E</u>, export the current DXF entity shown in the list view as text file

                • <b>Copy</b>  <b>selected</b>  <b>DXF</b>  <b>Tags</b>  <b>to</b>  <b>Clipboard</b>  <u>Ctrl+C</u>,  copy the current selected DXF tags into the
                  clipboard

                • <b>Copy</b> <b>DXF</b> <b>Entity</b> <b>to</b> <b>Clipboard</b> <u>Ctrl+Shift+C</u>, copy all DXF tags of the current DXF  entity  shown
                  in the list view into the clipboard

                • <b>Quit</b> <u>Ctrl+Q</u>

       •

         <b>Navigate</b> <b>Menu</b>

                • <b>Go</b> <b>to</b> <b>Handle…</b> <u>Ctrl+G</u>

                • <b>Go</b> <b>to</b> <b>Line…</b> <u>Ctrl+L</u>

                • <b>Find</b> <b>Text…</b> <u>Ctrl+F</u>, opens the find text dialog

                • <b>Next</b> <b>Entity</b> <u>Ctrl+Right</u>, go to the next entity in the DXF structure

                • <b>Previous</b> <b>Entity</b> <u>Ctrl+Right</u>, go to the previous entity in the DXF structure

                • <b>Show</b> <b>Entity</b> <b>in</b> <b>TreeView</b> <u>Ctrl+Down</u>, expand the left tree view to the currently displayed entity
                  in the list view - this does not happen automatically for performance reasons

                • <b>Entity</b> <b>History</b> <b>Back</b> <u>Alt+Left</u>

                • <b>Entity</b> <b>History</b> <b>Forward</b> <u>Alt+Right</u>

                • <b>Go</b> <b>to</b> <b>HEADERS</b> <b>Section</b> <u>Shift+H</u>

                • <b>Go</b> <b>to</b> <b>BLOCKS</b> <b>Section</b> <u>Shift+B</u>

                • <b>Go</b> <b>to</b> <b>ENTITIES</b> <b>Section</b> <u>Shift+E</u>

                • <b>Go</b> <b>to</b> <b>OBJECTS</b> <b>Section</b> <u>Shift+O</u>

       •

         <b>Bookmarks</b> <b>Menu</b>

                • <b>Store</b> <b>Bookmark…</b> <u>Ctrl+Shift+B</u>, store current location as named bookmark

                • <b>Go</b> <b>to</b> <b>Bookmark…</b> <u>Ctrl+B</u>, go to stored location

   <b>Browse-ACIS</b>
       Show and export the <u>SAT</u> or <u>SAB</u> content of <u>ACIS</u> entities:

          C:\&gt; ezdxf browse-acis 3dsolid.dxf
       [image]

       The  DXF  format  stores  modern solid geometry as <u>SAT</u> data for DXF R2000 - R2010 and as <u>SAB</u> data for DXF
       R2013 and later. This command shows the content of this entities and also let you export the raw data for
       further processing.

   <b>Entity</b> <b>View</b>
       The entity view is a read-only text editor, it’s possible to select and copy parts of the text  into  the
       clipboard.   To  improve  the  readability  all ACIS entities get automatically an id because AutoCAD and
       BricsCAD use relative references for ACIS data export and do not assign entity ids.  The id is  shown  as
       decimal number in parenthesis after the entity name. The <b>~</b> character is a shortcut for a null-pointer.

          C:\&gt;ezdxf browse-acis -h
          usage: ezdxf browse-acis [-h] [-g HANDLE] [FILE]

          positional arguments:
            FILE                  DXF file to browse

          options:
            -h, --help            show this help message and exit
            -g HANDLE, --handle HANDLE
                                  go to entity by HANDLE, HANDLE has to be a hex value
                                  without any prefix like 'fefe'

   <b>Menus</b> <b>and</b> <b>Shortcuts</b>
       •

         <b>File</b> <b>Menu</b>

                • <b>Open</b> <b>DXF</b> <b>file…</b> <u>Ctrl+O</u>

                • <b>Reload</b> <b>DXF</b> <b>file</b> <u>Ctrl+R</u>

                • <b>Export</b> <b>Current</b> <b>Entity</b> <b>View…</b> <u>Ctrl+E</u>, Export the parsed content of the entity view as text file

                • <b>Export</b>  <b>Raw</b> <b>SAT/SAB</b> <b>Data…</b> <u>Ctrl+W</u>, export the raw SAT data as text file and the raw SAB data as
                  a binary file for further processing

                • <b>Quit</b> <u>Ctrl+Q</u>

   <b>Strip</b>
       Strip comment tags (group code 999) from ASCII DXF files  and  can  remove  the  THUMBNAILIMAGE  section.
       Binary DXF files are not supported.

          C:\&gt; ezdxf strip -h
          usage: ezdxf strip [-h] [-b] [-v] FILE [FILE ...]

          positional arguments:
            FILE           DXF file to process, wildcards "*" and "?" are supported

          optional arguments:
            -h, --help       show this help message and exit
            -b, --backup     make a backup copy with extension ".bak" from the DXF file,
                             overwrites existing backup files
            -t, --thumbnail  strip THUMBNAILIMAGE section
            -v, --verbose    give more output

   <b>Config</b>
       Manage config files.

          C:\&gt; ezdxf config -h
          usage: ezdxf config [-h] [-p] [-w FILE] [--home] [--reset]

          optional arguments:
            -h, --help   show this help message and exit
            -p, --print  print configuration
            -w FILE, --write FILE
                         write configuration
            --home       create config file 'ezdxf.ini' in the user home directory
                         '<a href="file:~/.config/ezdxf">~/.config/ezdxf</a>', $XDG_CONFIG_HOME is supported if set

            --reset      factory reset, delete default config files 'ezdxf.ini'

   <b>Info</b>
       Show  information and optional stats of DXF files as loaded by <u>ezdxf</u>, this may not represent the original
       content of the file, use the <u>browse</u> command to see the original content. The  upgrade  is  necessary  for
       very  old  DXF versions prior to R12 and for the “special” versions R13 and R14. The <u>-s</u> option shows some
       statistics about the DXF content like entity count or table  count.  Use  the  <u>-v</u>  option  show  more  of
       everything.

          C:\&gt; ezdxf info -h
          usage: ezdxf info [-h] [-v] [-s] FILE [FILE ...]

          positional arguments:
            FILE           DXF file to process, wildcards "*" and "?" are supported

          options:
            -h, --help     show this help message and exit
            -v, --verbose  give more output
            -s, --stats    show content stats

       This  is  the  verbose  output  for  an  old DXF R10 file and shows that the loading process created some
       required structures which do not exist in DXF R10 files, like  the  BLOCK_RECORD  table  or  the  OBJECTS
       section:

          C:\&gt; ezdxf info -v -s test_R10.dxf

          Filename: "test_R10.dxf"
          Loaded content was upgraded from DXF Version AC1006 (R10)
          Release: R12
          DXF Version: AC1009
          Maintenance Version: &lt;undefined&gt;
          Codepage: ANSI_1252
          Encoding: cp1252
          Unit system: Imperial
          Modelspace units: Unitless
          $LASTSAVEDBY: &lt;undefined&gt;
          $HANDSEED: 0
          $FINGERPRINTGUID: {9EADDC7C-5982-4C68-B770-8A62378C2B90}
          $VERSIONGUID: {49336E63-D99B-45EC-803C-4D2BD03A7DE0}
          $USERI1=0
          $USERI2=0
          $USERI3=0
          $USERI4=0
          $USERI5=0
          $USERR1=0.0
          $USERR2=0.0
          $USERR3=0.0
          $USERR4=0.0
          $USERR5=0.0
          File was not created by ezdxf &gt;= 0.16.4
          File was not written by ezdxf &gt;= 0.16.4
          Content stats:
          LAYER table entries: 18
            0
            Defpoints
            LYR_00
            LYR_01
            LYR_02
            LYR_03
            LYR_04
            LYR_05
            LYR_06
            LYR_07
            LYR_08
            LYR_09
            LYR_10
            LYR_11
            LYR_12
            LYR_13
            LYR_14
            LYR_15
          LTYPE table entries: 13
            BORDER
            ByBlock
            ByLayer
            CENTER
            CONTINUOUS
            CUTTING
            DASHDOT
            DASHED
            DIVIDE
            DOT
            HIDDEN
            PHANTOM
            STITCH
          STYLE table entries: 1
            STANDARD
          DIMSTYLE table entries: 1
            Standard
          APPID table entries: 1
            ACAD
          UCS table entries: 0
          VIEW table entries: 0
          VPORT table entries: 1
            *Active
          BLOCK_RECORD table entries: 2
            *Model_Space
            *Paper_Space
          Entities in modelspace: 78
            ARC (2)
            CIRCLE (2)
            LINE (74)
          Entities in OBJECTS section: 20
            ACDBDICTIONARYWDFLT (1)
            ACDBPLACEHOLDER (1)
            DICTIONARY (11)
            LAYOUT (2)
            MATERIAL (3)
            MLEADERSTYLE (1)
            MLINESTYLE (1)

   <b>Show</b> <b>Version</b> <b>&amp;</b> <b>Configuration</b>
       Show the <u>ezdxf</u> version and configuration:

          C:\&gt; ezdxf -Vv

          ezdxf v0.16.5b0 @ d:\source\ezdxf.git\src\ezdxf
          Python version: 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)]
          using C-extensions: yes
          using Matplotlib: yes

          Configuration:
          [core]
          default_dimension_text_style = OpenSansCondensed-Light
          test_files = D:\Source\dxftest
          font_cache_directory =
          load_proxy_graphics = true
          store_proxy_graphics = true
          log_unprocessed_tags = false
          filter_invalid_xdata_group_codes = true
          write_fixed_meta_data_for_testing = false
          disable_c_ext = false

          [browse-command]
          text_editor = "C:\Program Files\Notepad++\notepad++.exe" "{filename}" -n{num}

          Environment Variables:
          EZDXF_DISABLE_C_EXT=
          EZDXF_TEST_FILES=D:\Source\dxftest
          EZDXF_CONFIG_FILE=

          Existing Configuration Files:
          C:\Users\manfred\.config\ezdxf\ezdxf.ini

       <b>SEE</b> <b>ALSO:</b>
          Documentation of the <u>ezdxf.options</u> module and the <u>Environment</u> <u>Variables</u>.

   <b>HPGL/2</b> <b>Viewer/Converter</b>
       New in version 1.1.

       The <b>hpgl</b> command shows and/or converts <u>HPGL/2</u> plot files to DXF, SVG or PDF.

   <b>DXF</b>
       The  page  content  is created at the origin of the modelspace and 1 drawing unit is 1 plot unit (1 plu =
       0.025mm) unless scaling values are provided.

       The content of HPGL files is intended to be  plotted  on  white  paper,  so  the  appearance  on  a  dark
       background  in  modelspace  is  not  very  clear. To fix this, the <b>--map_black_to_white</b> option maps black
       fillings and lines to white.

       All entities are mapped to a layer named  <b>COLOR_&lt;#&gt;</b> according to the pen number.  In order to process the
       content better, it is also possible to assign the DXF elements an ACI color value according  to  the  pen
       number  through  the  <b>--aci</b>  option,  but then the RGB color is lost because the RGB color always has the
       higher priority over the <u>ACI</u> value.

       The first paperspace layout “Layout0” is set up to print the entire modelspace on one sheet, the size  of
       the page is the size of the original plot file in millimeters.

   <b>SVG</b>
       The  plot  units  are  mapped 1:1 to <b>viewBox</b> units and the size of image is the size of the original plot
       file in millimeters.

   <b>PDF</b>
       The plot units are converted to PDF units (1/72 inch) so the size of image is the size  of  the  original
       plot file in millimeters.

   <b>All</b> <b>Formats</b>
       HPGL/2’s  merge control works at the pixel level and cannot be replicated by DXF, but to prevent fillings
       from obscuring text, the filled polygons are sorted by luminance - this can be forced or disabled by  the
       <b>--merge_control</b> option.

       Some  plot  files  that  contain pure HPGL/2 code do not contain the escape sequence “Enter HPGL/2 mode”,
       without this sequence the HPGL/2 parser cannot recognize the beginning of the HPGL/2  code.  The  <b>--force</b>
       option  inserts  the  “Enter HPGL/2 mode” escape sequence into the data stream, regardless of whether the
       file is an HPGL/2 plot file or not, so be careful.

          C:\&gt; ezdxf hpgl -h
          usage: ezdxf hpgl [-h] [-e FORMAT] [-r {0,90,180,270}] [-x SX] [-y SY] [-m {0,1,2}]
                            [-f] [--aci] [--map_black_to_white]
                            [FILE]

          positional arguments:
            FILE                  view and/or convert HPGL/2 plot files, wildcards (*, ?)
                                  supported in command line mode

          options:
            -h, --help            show this help message and exit
            -e FORMAT, --export FORMAT
                                  convert HPGL/2 plot file to SVG, PDF or DXF from the
                                  command line (no gui)
            -r {0,90,180,270}, --rotate {0,90,180,270}
                                  rotate page about 90, 180 or 270 degrees (no gui)
            -x SX, --scale_x SX   scale page in x-axis direction, use negative values to
                                  mirror page, (no gui)
            -y SY, --scale_y SY   scale page in y-axis direction, use negative values to
                                  mirror page (no gui)
            -m {0,1,2}, --merge_control {0,1,2}
                                  provides control over the order of filled polygons, 0=off
                                  (print order), 1=luminance (order by luminance), 2=auto
                                  (default)
            -f, --force           inserts the mandatory 'enter HPGL/2 mode' escape sequence
                                  into the data stream; use this flag when no HPGL/2 data was
                                  found and you are sure the file is a HPGL/2 plot file
            --aci                 use pen numbers as ACI colors (DXF only)
            --map_black_to_white  map black RGB plot colors to white RGB, does not affect ACI
                                  colors (DXF only)

          Note that plot files are intended to be plotted on white paper.

</pre><h4><b>RENDERING</b></h4><pre>
       The <u>ezdxf.render</u> subpackage provides helpful utilities to create complex forms.

       • create complex meshes as <u>Mesh</u> entity.

       • render complex curves like bezier curves, euler spirals or splines as <u>Polyline</u> entity

       • vertex generators for simple and complex forms like circle, ellipse or euler spiral

       Content

   <b>Spline</b>
       <b>class</b> <b>ezdxf.render.Spline(points:</b> <b>Iterable[</b><u>UVec</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>segments:</b> <b>int</b> <b>=</b> <b>100)</b>
              This class can be used to render B-splines into DXF R12 files as approximated  <u>Polyline</u>  entities.
              The advantage of this class over the <u>R12Spline</u> class is, that this is a real 3D curve, which means
              that  the  B-spline  vertices do have to be located in a flat plane, and no <u>UCS</u> class is needed to
              place the curve in 3D space.

              <b>SEE</b> <b>ALSO:</b>
                 The newer <u>BSpline</u> class provides the advanced vertex interpolation method <u>flattening()</u>.

              <b>__init__(points:</b> <b>Iterable[</b><u>UVec</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>segments:</b> <b>int</b> <b>=</b> <b>100)</b>

                     <b>Parameters</b>

                            • <b>points</b> – spline definition points

                            • <b>segments</b> – count of line segments for approximation, vertex count is <u>segments</u> + 1

              <b>subdivide(segments:</b> <b>int</b> <b>=</b> <b>4)</b> <b>-&gt;</b> <b>None</b>
                     Calculate overall segment count, where segments is the sub-segment  count,  <u>segments</u>  =  4,
                     means 4 line segments between two definition points e.g. 4 definition points and 4 segments
                     = 12 overall segments, useful for fit point rendering.

                     <b>Parameters</b>
                            <b>segments</b> – sub-segments count between two definition points

              <b>render_as_fit_points(layout:</b> <u>BaseLayout</u><b>,</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b> <b>method:</b> <b>str</b> <b>=</b> <b>'chord',</b> <b>dxfattribs:</b> <b>dict</b>
              <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Render a B-spline as 2D/3D <u>Polyline</u>, where the definition points are fit points.

                        • 2D spline vertices uses: <u>add_polyline2d()</u>

                        • 3D spline vertices uses: <u>add_polyline3d()</u>

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>method</b>   –  “uniform”,  “distance”/”chord”,  “centripetal”/”sqrt_chord”  or  “arc”
                              calculation method for parameter t

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>render_open_bspline(layout:</b> <u>BaseLayout</u><b>,</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render an open uniform B-spline as 3D <u>Polyline</u>.  Definition points are control points.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>render_uniform_bspline(layout:</b> <u>BaseLayout</u><b>,</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render a uniform B-spline as 3D <u>Polyline</u>.  Definition points are control points.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>render_closed_bspline(layout:</b> <u>BaseLayout</u><b>,</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render a closed uniform B-spline as 3D <u>Polyline</u>.  Definition points are control points.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>render_open_rbspline(layout:</b> <u>BaseLayout</u><b>,</b> <b>weights:</b> <b>Iterable[float],</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b>
              <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render a rational open uniform BSpline as  3D  <u>Polyline</u>.   Definition  points  are  control
                     points.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>weights</b>  –  list  of  weights, requires a weight value (float) for each definition
                              point.

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>render_uniform_rbspline(layout:</b> <u>BaseLayout</u><b>,</b> <b>weights:</b> <b>Iterable[float],</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b>
              <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render a rational uniform B-spline as 3D <u>Polyline</u>.  Definition points are control points.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>weights</b> – list of weights, requires a weight value  (float)  for  each  definition
                              point.

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>render_closed_rbspline(layout:</b> <u>BaseLayout</u><b>,</b> <b>weights:</b> <b>Iterable[float],</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b>
              <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render a rational B-spline as 3D <u>Polyline</u>.  Definition points are control points.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>weights</b>  –  list  of  weights, requires a weight value (float) for each definition
                              point.

                            • <b>degree</b> – degree of B-spline (order = <u>degree</u> + 1)

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

   <b>R12Spline</b>
       <b>class</b> <b>ezdxf.render.R12Spline(control_points:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>degree:</b> <b>int</b> <b>=</b> <b>2,</b> <b>closed:</b> <b>bool</b> <b>=</b> <b>True)</b>
              DXF R12 supports 2D B-splines, but Autodesk do not document the usage in the  DXF  Reference.  The
              base entity for splines in DXF R12 is the POLYLINE entity. The spline itself is always in a plane,
              but  as any 2D entity, the spline can be transformed into the 3D object by elevation and extrusion
              (<u>OCS</u>, <u>UCS</u>).

              This way it was possible to store the spline  parameters  in  the  DXF  R12  file,  to  allow  CAD
              applications to modify the spline parameters and rerender the B-spline afterward again as polyline
              approximation.  Therefore,  the result is not better than an approximation by the <u>Spline</u> class, it
              is also just a POLYLINE entity, but maybe someone need exact this tool in the future.

              <b>__init__(control_points:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>degree:</b> <b>int</b> <b>=</b> <b>2,</b> <b>closed:</b> <b>bool</b> <b>=</b> <b>True)</b>

                     <b>Parameters</b>

                            • <b>control_points</b> – B-spline control frame vertices

                            • <b>degree</b> – degree of B-spline, only 2 and 3 is supported

                            • <b>closed</b> – <b>True</b> for closed curve

              <b>render(layout:</b> <u>BaseLayout</u><b>,</b> <b>segments:</b> <b>int</b> <b>=</b> <b>40,</b> <b>ucs:</b> <u>UCS</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>dxfattribs=None)</b> <b>-&gt;</b>
              <u>Polyline</u>
                     Renders the B-spline into <u>layout</u> as 2D <u>Polyline</u> entity. Use an <u>UCS</u> to place the  2D  spline
                     in the 3D space, see <u>approximate()</u> for more information.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>segments</b> – count of line segments for approximation, vertex count is <u>segments</u> + 1

                            • <b>ucs</b> – <u>UCS</u> definition, control points in ucs coordinates.

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

              <b>approximate(segments:</b> <b>int</b> <b>=</b> <b>40,</b> <b>ucs:</b> <u>UCS</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>list[</b><u>UVec</u><b>]</b>
                     Approximate  the  B-spline  by a polyline with <u>segments</u> line segments.  If <u>ucs</u> is not <b>None</b>,
                     ucs defines an <u>UCS</u>, to transform the curve into <u>OCS</u>. The control points are placed xy-plane
                     of the UCS, don’t use z-axis coordinates, if so make sure all control points are in a plane
                     parallel to the OCS base plane (UCS xy-plane), else the result is unpredictable and depends
                     on the CAD application used to open the DXF file - it may crash.

                     <b>Parameters</b>

                            • <b>segments</b> – count of line segments for approximation, vertex count is <u>segments</u> + 1

                            • <b>ucs</b> – <u>UCS</u> definition, control points in ucs coordinates

                     <b>Returns</b>
                            list of vertices in <u>OCS</u> as <u>Vec3</u> objects

   <b>Bezier</b>
       <b>class</b> <b>ezdxf.render.Bezier</b>
              Render a bezier curve as 2D/3D <u>Polyline</u>.

              The <u>Bezier</u> class is implemented with multiple segments, each  segment  is  an  optimized  4  point
              bezier  curve,  the  4 control points of the curve are: the start point (1) and the end point (4),
              point (2) is start point + start vector and point (3) is end point + end vector. Each segment  has
              its own approximation count.

              <b>SEE</b> <b>ALSO:</b>
                 The new <u>ezdxf.path</u> package provides many advanced construction tools based on the <u>Path</u> class.

              <b>start(point:</b> <u>UVec</u><b>,</b> <b>tangent:</b> <u>UVec</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Set start point and start tangent.

                     <b>Parameters</b>

                            • <b>point</b> – start point

                            • <b>tangent</b>  –  start tangent as vector, example: (5, 0, 0) means a horizontal tangent
                              with a length of 5 drawing units

              <b>append(point:</b> <u>UVec</u><b>,</b> <b>tangent1:</b> <u>UVec</u><b>,</b> <b>tangent2:</b> <u>UVec</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>segments:</b> <b>int</b> <b>=</b> <b>20)</b>
                     Append a control point with two control tangents.

                     <b>Parameters</b>

                            • <b>point</b> – control point

                            • <b>tangent1</b> – first tangent as vector “left” of the control point

                            • <b>tangent2</b> – second tangent as vector “right”  of  the  control  point,  if  omitted
                              <u>tangent2</u> = <u>-tangent1</u>

                            • <b>segments</b>  –  count  of line segments for the polyline approximation, count of line
                              segments from the previous control point to the appended control point.

              <b>render(layout:</b> <u>BaseLayout</u><b>,</b> <b>force3d:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <b>None</b>
                     Render Bezier curve as 2D/3D <u>Polyline</u>.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>force3d</b> – force 3D polyline rendering

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

   <b>EulerSpiral</b>
       <b>class</b> <b>ezdxf.render.EulerSpiral(curvature:</b> <b>float</b> <b>=</b> <b>1)</b>
              Render an <u>euler</u> <u>spiral</u> as a 3D <u>Polyline</u> or a <u>Spline</u> entity.

              This is a parametric curve, which always starts at the origin (0, 0).

              <b>__init__(curvature:</b> <b>float</b> <b>=</b> <b>1)</b>

                     <b>Parameters</b>
                            <b>curvature</b> – Radius of curvature

              <b>render_polyline(layout:</b> <u>BaseLayout</u><b>,</b> <b>length:</b> <b>float</b> <b>=</b> <b>1,</b> <b>segments:</b> <b>int</b> <b>=</b> <b>100,</b> <b>matrix:</b> <u>Matrix44</u> <b>|</b>
              <b>None</b> <b>=</b> <b>None,</b> <b>dxfattribs=None)</b>
                     Render curve as <u>Polyline</u>.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>length</b> – length measured along the spiral curve from its initial position

                            • <b>segments</b> – count of line segments to use, vertex count is <u>segments</u> + 1

                            • <b>matrix</b> – transformation matrix as <u>Matrix44</u>

                            • <b>dxfattribs</b> – DXF attributes for <u>Polyline</u>

                     <b>Returns</b>
                            <u>Polyline</u>

              <b>render_spline(layout:</b> <u>BaseLayout</u><b>,</b> <b>length:</b> <b>float</b> <b>=</b> <b>1,</b> <b>fit_points:</b> <b>int</b> <b>=</b> <b>10,</b> <b>degree:</b> <b>int</b> <b>=</b> <b>3,</b>
              <b>matrix:</b> <u>Matrix44</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>dxfattribs=None)</b>
                     Render curve as <u>Spline</u>.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>length</b> – length measured along the spiral curve from its initial position

                            • <b>fit_points</b> – count of spline fit points to use

                            • <b>degree</b> – degree of B-spline

                            • <b>matrix</b> – transformation matrix as <u>Matrix44</u>

                            • <b>dxfattribs</b> – DXF attributes for <u>Spline</u>

                     <b>Returns</b>
                            <u>Spline</u>

   <b>Random</b> <b>Paths</b>
       Random path generators for testing purpose.

       <b>ezdxf.render.random_2d_path(steps:</b> <b>int</b> <b>=</b> <b>100,</b> <b>max_step_size:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>max_heading:</b> <b>float</b> <b>=</b> <b>math.pi</b> <b>/</b>
       <b>2,</b> <b>retarget:</b> <b>int</b> <b>=</b> <b>20)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec2</u><b>]</b>
              Returns a random 2D path as iterable of <u>Vec2</u> objects.

              <b>Parameters</b>

                     • <b>steps</b> – count of vertices to generate

                     • <b>max_step_size</b> – max step size

                     • <b>max_heading</b> – limit heading angle change per step to ± max_heading/2 in radians

                     • <b>retarget</b> – specifies steps before changing global walking target

       <b>ezdxf.render.random_3d_path(steps:</b> <b>int</b> <b>=</b> <b>100,</b> <b>max_step_size:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>max_heading:</b> <b>float</b> <b>=</b> <b>math.pi</b> <b>/</b>
       <b>2.0,</b> <b>max_pitch:</b> <b>float</b> <b>=</b> <b>math.pi</b> <b>/</b> <b>8.0,</b> <b>retarget:</b> <b>int</b> <b>=</b> <b>20)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec3</u><b>]</b>
              Returns a random 3D path as iterable of <u>Vec3</u> objects.

              <b>Parameters</b>

                     • <b>steps</b> – count of vertices to generate

                     • <b>max_step_size</b> – max step size

                     • <b>max_heading</b> – limit heading angle change per step to ± max_heading/2, rotation about  the
                       z-axis in radians

                     • <b>max_pitch</b> – limit pitch angle change per step to ± max_pitch/2, rotation about the x-axis
                       in radians

                     • <b>retarget</b> – specifies steps before changing global walking target

   <b>Forms</b>
          This module provides functions to create 2D and 3D forms as vertices or mesh objects.

          2D Forms

          • <u>box()</u>

          • <u>circle()</u>

          • <u>ellipse()</u>

          • <u>euler_spiral()</u>

          • <u>gear()</u>

          • <u>ngon()</u>

          • <u>square()</u>

          • <u>star()</u>

          • <u>turtle()</u>

          3D Forms

          • <u>cone_2p()</u>

          • <u>cone()</u>

          • <u>cube()</u>

          • <u>cylinder()</u>

          • <u>cylinder_2p()</u>

          • <u>helix()</u>

          • <u>sphere()</u>

          • <u>torus()</u>

          3D Form Builder

          • <u>extrude()</u>

          • <u>extrude_twist_scale()</u>

          • <u>from_profiles_linear()</u>

          • <u>from_profiles_spline()</u>

          • <u>rotation_form()</u>

          • <u>sweep()</u>

          • <u>sweep_profile()</u>

   <b>2D</b> <b>Forms</b>
          Basic 2D shapes as iterable of <u>Vec3</u>.

       <b>ezdxf.render.forms.box(sx:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>sy:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>center=False)</b> <b>-&gt;</b> <b>tuple[</b><u>Vec3</u><b>,</b> <u>Vec3</u><b>,</b> <u>Vec3</u><b>,</b> <u>Vec3</u><b>]</b>
              Returns  4  vertices  for a box with a width of <u>sx</u> by and a height of <u>sy</u>. The center of the box in
              (0, 0) if <u>center</u> is <b>True</b> otherwise the lower left corner is (0, 0), upper  right  corner  is  (<u>sx</u>,
              <u>sy</u>).

       <b>ezdxf.render.forms.circle(count:</b> <b>int,</b> <b>radius:</b> <b>float</b> <b>=</b> <b>1,</b> <b>elevation:</b> <b>float</b> <b>=</b> <b>0,</b> <b>close:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b>
       <b>Iterable[</b><u>Vec3</u><b>]</b>
              Create  polygon  vertices  for  a <u>circle</u> with the given <u>radius</u> and approximated by <u>count</u> vertices,
              <u>elevation</u> is the z-axis for all vertices.

              <b>Parameters</b>

                     • <b>count</b> – count of polygon vertices

                     • <b>radius</b> – circle radius

                     • <b>elevation</b> – z-axis for all vertices

                     • <b>close</b> – yields first vertex also as last vertex if <b>True</b>.

              <b>Returns</b>
                     vertices in counter-clockwise orientation as <u>Vec3</u> objects

       <b>ezdxf.render.forms.ellipse(count:</b> <b>int,</b> <b>rx:</b> <b>float</b> <b>=</b> <b>1,</b> <b>ry:</b> <b>float</b> <b>=</b> <b>1,</b> <b>start_param:</b> <b>float</b> <b>=</b> <b>0,</b> <b>end_param:</b>
       <b>float</b> <b>=</b> <b>math.tau,</b> <b>elevation:</b> <b>float</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec3</u><b>]</b>
              Create polygon vertices for an <u>ellipse</u> with given <u>rx</u> as x-axis radius  and  <u>ry</u>  as  y-axis  radius
              approximated  by  <u>count</u> vertices, <u>elevation</u> is the z-axis for all vertices.  The ellipse goes from
              <u>start_param</u> to <u>end_param</u> in counter clockwise orientation.

              <b>Parameters</b>

                     • <b>count</b> – count of polygon vertices

                     • <b>rx</b> – ellipse x-axis radius

                     • <b>ry</b> – ellipse y-axis radius

                     • <b>start_param</b> – start of ellipse in range [0, 2π]

                     • <b>end_param</b> – end of ellipse in range [0, 2π]

                     • <b>elevation</b> – z-axis for all vertices

              <b>Returns</b>
                     vertices in counter clockwise orientation as <u>Vec3</u> objects

       <b>ezdxf.render.forms.euler_spiral(count:</b> <b>int,</b> <b>length:</b> <b>float</b> <b>=</b> <b>1,</b> <b>curvature:</b> <b>float</b> <b>=</b> <b>1,</b> <b>elevation:</b> <b>float</b> <b>=</b>
       <b>0)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec3</u><b>]</b>
              Create polygon vertices for an <u>euler</u> <u>spiral</u> of a given <u>length</u> and radius of curvature. This  is  a
              parametric curve, which always starts at the origin (0, 0).

              <b>Parameters</b>

                     • <b>count</b> – count of polygon vertices

                     • <b>length</b> – length of curve in drawing units

                     • <b>curvature</b> – radius of curvature

                     • <b>elevation</b> – z-axis for all vertices

              <b>Returns</b>
                     vertices as <u>Vec3</u> objects

       <b>ezdxf.render.forms.gear(count:</b> <b>int,</b> <b>top_width:</b> <b>float,</b> <b>bottom_width:</b> <b>float,</b> <b>height:</b> <b>float,</b> <b>outside_radius:</b>
       <b>float,</b> <b>elevation:</b> <b>float</b> <b>=</b> <b>0,</b> <b>close:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec3</u><b>]</b>
              Returns the corner vertices of a <u>gear</u> <u>shape</u> (cogwheel).

              <b>WARNING:</b>
                 This function does not create correct gears for mechanical engineering!

              <b>Parameters</b>

                     • <b>count</b> – teeth count &gt;= 3

                     • <b>top_width</b> – teeth width at outside radius

                     • <b>bottom_width</b> – teeth width at base radius

                     • <b>height</b> – teeth height; base radius = outside radius - height

                     • <b>outside_radius</b> – outside radius

                     • <b>elevation</b> – z-axis for all vertices

                     • <b>close</b> – yields first vertex also as last vertex if True.

              <b>Returns</b>
                     vertices in counter clockwise orientation as <u>Vec3</u> objects

       <b>ezdxf.render.forms.ngon(count:</b> <b>int,</b> <b>length:</b> <b>float</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>radius:</b> <b>float</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>rotation:</b>
       <b>float</b> <b>=</b> <b>0.0,</b> <b>elevation:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>close:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec3</u><b>]</b>
              Returns  the  corner  vertices  of  a <u>regular</u> <u>polygon</u>.  The polygon size is determined by the edge
              <u>length</u> or the circum <u>radius</u> argument. If both are given <u>length</u> has the higher priority.

              <b>Parameters</b>

                     • <b>count</b> – count of polygon corners &gt;= 3

                     • <b>length</b> – length of polygon side

                     • <b>radius</b> – circum radius

                     • <b>rotation</b> – rotation angle in radians

                     • <b>elevation</b> – z-axis for all vertices

                     • <b>close</b> – yields first vertex also as last vertex if <b>True</b>.

              <b>Returns</b>
                     vertices as <u>Vec3</u> objects

       <b>ezdxf.render.forms.square(size:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>center=False)</b> <b>-&gt;</b> <b>tuple[</b><u>Vec3</u><b>,</b> <u>Vec3</u><b>,</b> <u>Vec3</u><b>,</b> <u>Vec3</u><b>]</b>
              Returns 4 vertices for a square with a side length of the given <u>size</u>.  The center of the square in
              (0, 0) if <u>center</u> is <b>True</b> otherwise the lower left corner is (0, 0), upper right corner  is  (<u>size</u>,
              <u>size</u>).

       <b>ezdxf.render.forms.star(count:</b> <b>int,</b> <b>r1:</b> <b>float,</b> <b>r2:</b> <b>float,</b> <b>rotation:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>elevation:</b> <b>float</b> <b>=</b> <b>0.0,</b>
       <b>close:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <b>Iterable[</b><u>Vec3</u><b>]</b>
              Returns the corner vertices for a <u>star</u> <u>shape</u>.

              The  shape  has  <u>count</u>  spikes,  <u>r1</u>  defines the radius of the “outer” vertices and <u>r2</u> defines the
              radius of the “inner” vertices, but this does not mean that <u>r1</u> has to be greater than <u>r2</u>.

              <b>Parameters</b>

                     • <b>count</b> – spike count &gt;= 3

                     • <b>r1</b> – radius 1

                     • <b>r2</b> – radius 2

                     • <b>rotation</b> – rotation angle in radians

                     • <b>elevation</b> – z-axis for all vertices

                     • <b>close</b> – yields first vertex also as last vertex if <b>True</b>.

              <b>Returns</b>
                     vertices as <u>Vec3</u> objects

       <b>ezdxf.render.forms.turtle(commands:</b> <b>str,</b> <b>start=Vec2(0,</b> <b>0),</b> <b>angle:</b> <b>float</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>Iterator[</b><u>Vec2</u><b>]</b>
              Returns the 2D vertices of a polyline created by turtle-graphic like commands:

              • <b>&lt;length&gt;</b> - go &lt;length&gt; units forward in current direction and yield vertex

              • <b>r&lt;angle&gt;</b> - turn right &lt;angle&gt; in degrees, a missing angle is 90 deg

              • <b>l&lt;angle&gt;</b> - turn left &lt;angle&gt; in degrees, a missing angle is 90 deg

              • <b>@&lt;x&gt;,&lt;y&gt;</b> - go relative &lt;x&gt;,&lt;y&gt; and yield vertex

              The command string <b>"10</b> <b>l</b> <b>10</b> <b>l</b> <b>10"</b> returns the 4 corner vertices of a square with a side length  of
              10 drawing units.

              <b>Parameters</b>

                     • <b>commands</b> – command string, commands are separated by spaces

                     • <b>start</b> – starting point, default is (0, 0)

                     • <b>angle</b> – starting direction, default is 0 deg

   <b>3D</b> <b>Forms</b>
       Create 3D forms as <u>MeshTransformer</u> objects.

       <b>ezdxf.render.forms.cube(center:</b> <b>bool</b> <b>=</b> <b>True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Create a <u>cube</u> as <u>MeshTransformer</u> object.

              <b>Parameters</b>
                     <b>center</b> – ‘mass’ center of cube, <b>(0,</b> <b>0,</b> <b>0)</b> if <b>True</b>, else first corner at <b>(0,</b> <b>0,</b> <b>0)</b>

              Returns: <u>MeshTransformer</u>

       <b>ezdxf.render.forms.cone(count:</b> <b>int</b> <b>=</b> <b>16,</b> <b>radius:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>apex:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>1),</b> <b>*,</b> <b>caps=True)</b> <b>-&gt;</b>
       <b>MeshTransformer</b>
              Create a <u>cone</u> as <u>MeshTransformer</u> object, the base center is fixed in the origin (0, 0, 0).

              <b>Parameters</b>

                     • <b>count</b> – edge count of basis_vector

                     • <b>radius</b> – radius of basis_vector

                     • <b>apex</b> – tip of the cone

                     • <b>caps</b> – add a bottom face as ngon if <b>True</b>

       <b>ezdxf.render.forms.cone_2p(count:</b> <b>int</b> <b>=</b> <b>16,</b> <b>radius:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>base_center:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>0),</b> <b>apex:</b>
       <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>1),</b> <b>*,</b> <b>caps=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Create  a  <u>cone</u>  as  <u>MeshTransformer</u> object from two points, <u>base_center</u> is the center of the base
              circle and <u>apex</u> as the tip of the cone.

              <b>Parameters</b>

                     • <b>count</b> – edge count of basis_vector

                     • <b>radius</b> – radius of basis_vector

                     • <b>base_center</b> – center point of base circle

                     • <b>apex</b> – tip of the cone

                     • <b>caps</b> – add a bottom face as ngon if <b>True</b>

              <b>Raises</b> <b>ValueError</b> – the cone orientation cannot be detected (base center == apex)

       <b>ezdxf.render.forms.cylinder(count:</b> <b>int</b> <b>=</b> <b>16,</b> <b>radius:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>top_radius:</b> <b>float</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b>
       <b>top_center:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>1),</b> <b>*,</b> <b>caps=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Create a <u>cylinder</u> as <u>MeshTransformer</u> object, the base center is fixed in the origin (0, 0, 0).

              <b>Parameters</b>

                     • <b>count</b> – profiles edge count

                     • <b>radius</b> – radius for bottom profile

                     • <b>top_radius</b> – radius for top profile, if <b>None</b> top_radius == radius

                     • <b>top_center</b> – location vector for the center of the top profile

                     • <b>caps</b> – close hull with top- and  bottom faces (ngons)

       <b>ezdxf.render.forms.cylinder_2p(count:</b> <b>int</b> <b>=</b> <b>16,</b> <b>radius:</b> <b>float</b> <b>=</b> <b>1,</b> <b>base_center:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>0),</b>
       <b>top_center:</b> <u>UVec</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>1),</b> <b>*,</b> <b>caps=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Creates a <u>cylinder</u> as <u>MeshTransformer</u> object from two points, <u>base_center</u> is  the  center  of  the
              base circle and, <u>top_center</u> the center of the top circle.

              <b>Parameters</b>

                     • <b>count</b> – cylinder profile edge count

                     • <b>radius</b> – radius for bottom profile

                     • <b>base_center</b> – center of base circle

                     • <b>top_center</b> – center of top circle

                     • <b>caps</b> – close hull with top- and  bottom faces (ngons)

              <b>Raises</b> <b>ValueError</b> – the cylinder orientation cannot be detected (base center == top center)

       <b>ezdxf.render.forms.helix(radius:</b> <b>float,</b> <b>pitch:</b> <b>float,</b> <b>turns:</b> <b>float,</b> <b>resolution:</b> <b>int</b> <b>=</b> <b>16,</b> <b>ccw=True)</b> <b>-&gt;</b>
       <b>Iterator[</b><u>Vec3</u><b>]</b>
              Yields  the vertices of a <u>helix</u>.  The center of the helix is always (0, 0), a positive <u>pitch</u> value
              creates a helix along the +z-axis, a negative value along the -z-axis.

              <b>Parameters</b>

                     • <b>radius</b> – helix radius

                     • <b>pitch</b> – the height of one complete helix turn

                     • <b>turns</b> – count of turns

                     • <b>resolution</b> – vertices per turn

                     • <b>ccw</b> – creates a counter-clockwise turning (right-handed) helix if <b>True</b>

       <b>ezdxf.render.forms.sphere(count:</b> <b>int</b> <b>=</b> <b>16,</b> <b>stacks:</b> <b>int</b> <b>=</b> <b>8,</b> <b>radius:</b> <b>float</b> <b>=</b> <b>1,</b> <b>*,</b> <b>quads=True)</b> <b>-&gt;</b>
       <b>MeshTransformer</b>
              Create a <u>sphere</u> as <u>MeshTransformer</u> object, the center of the sphere is always at (0, 0, 0).

              <b>Parameters</b>

                     • <b>count</b> – longitudinal slices

                     • <b>stacks</b> – latitude slices

                     • <b>radius</b> – radius of sphere

                     • <b>quads</b> – use quadrilaterals as faces if <b>True</b> else triangles

       <b>ezdxf.render.forms.torus(major_count:</b> <b>int</b> <b>=</b> <b>16,</b> <b>minor_count:</b> <b>int</b> <b>=</b> <b>8,</b> <b>major_radius=1.0,</b> <b>minor_radius=0.1,</b>
       <b>start_angle:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>end_angle:</b> <b>float</b> <b>=</b> <b>math.tau,</b> <b>*,</b> <b>caps=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Create a <u>torus</u> as <u>MeshTransformer</u> object, the center of the torus is always  at  (0,  0,  0).  The
              <u>major_radius</u> has to be bigger than the <u>minor_radius</u>.

              <b>Parameters</b>

                     • <b>major_count</b> – count of circles

                     • <b>minor_count</b> – count of circle vertices

                     • <b>major_radius</b> – radius of the circle center

                     • <b>minor_radius</b> – radius of circle

                     • <b>start_angle</b> – start angle of torus in radians

                     • <b>end_angle</b> – end angle of torus in radians

                     • <b>caps</b> – close hull with start- and end faces (ngons) if the torus is open

   <b>3D</b> <b>Form</b> <b>Builder</b>
       <b>ezdxf.render.forms.extrude(profile:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>path:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>close=True,</b> <b>caps=False)</b> <b>-&gt;</b>
       <b>MeshTransformer</b>
              Extrude  a  <u>profile</u>  polygon  along  a  <u>path</u>  polyline,  the  vertices  of  <u>profile</u>  should  be in
              counter-clockwise order.  The sweeping profile will not be rotated at extrusion!

              <b>Parameters</b>

                     • <b>profile</b> – sweeping profile as list of (x, y, z) tuples in counter-clockwise order

                     • <b>path</b> – extrusion path as list of (x, y, z) tuples

                     • <b>close</b> – close profile polygon if <b>True</b>

                     • <b>caps</b> – close hull with top- and bottom faces (ngons)

              Returns: <u>MeshTransformer</u>

       <b>ezdxf.render.forms.extrude_twist_scale(profile:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>path:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>*,</b> <b>twist:</b> <b>float</b> <b>=</b>
       <b>0.0,</b> <b>scale:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>step_size:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>close=True,</b> <b>caps=False,</b> <b>quads=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Extrude a  <u>profile</u>  polygon  along  a  <u>path</u>  polyline,  the  vertices  of  <u>profile</u>  should  be  in
              counter-clockwise  order.   This implementation can scale and twist the sweeping profile along the
              extrusion path. The <u>path</u> segment points are fix  points,  the  <u>max_step_size</u>  is  used  to  create
              intermediate  profiles  between  this fix points. The <u>max_step_size</u> is adapted for each segment to
              create equally spaced distances.  The twist angle is the rotation angle in radians and  the  scale
              <u>argument</u> defines the scale factor of the final profile.  The twist angle and scaling factor of the
              intermediate profiles will be linear interpolated between the start and end values.

              <b>Parameters</b>

                     • <b>profile</b> – sweeping profile as list of (x, y, z) tuples in counter-clockwise order

                     • <b>path</b> – extrusion path as list of (x, y, z) tuples

                     • <b>twist</b> – rotate sweeping profile up to the given end rotation angle in radians

                     • <b>scale</b> – scale sweeping profile gradually from 1.0 to given value

                     • <b>step_size</b>  – rough distance between automatically created intermediate profiles, the step
                       size is adapted to the distances between the path segment points, a value od 0.0 disables
                       creating intermediate profiles

                     • <b>close</b> – close profile polygon if <b>True</b>

                     • <b>caps</b> – close hull with top- and  bottom faces (ngons)

                     • <b>quads</b> – use quads for “sweeping” faces if <b>True</b> else triangles, the top and  bottom  faces
                       are always ngons

              Returns: <u>MeshTransformer</u>

       <b>ezdxf.render.forms.from_profiles_linear(profiles:</b> <b>Sequence[Sequence[</b><u>Vec3</u><b>]],</b> <b>*,</b> <b>close=True,</b> <b>quads=True,</b>
       <b>caps=False)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Returns a <u>MeshTransformer</u> instance from linear connected <u>profiles</u>.

              <b>Parameters</b>

                     • <b>profiles</b> – list of profiles

                     • <b>close</b> – close profile polygon if <b>True</b>

                     • <b>quads</b> – use quadrilaterals as connection faces if <b>True</b> else triangles

                     • <b>caps</b> – close hull with top- and bottom faces (ngons)

       <b>ezdxf.render.forms.from_profiles_spline(profiles:</b> <b>Sequence[Sequence[</b><u>Vec3</u><b>]],</b> <b>subdivide:</b> <b>int</b> <b>=</b> <b>4,</b> <b>*,</b>
       <b>close=True,</b> <b>quads=True,</b> <b>caps=False)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Returns  a  <u>MeshTransformer</u>  instance by spline interpolation between given <u>profiles</u>.  Requires at
              least 4 profiles. A <u>subdivide</u> value of 4, means, create 4 face loops between two profiles, without
              interpolation two profiles create one face loop.

              <b>Parameters</b>

                     • <b>profiles</b> – list of profiles

                     • <b>subdivide</b> – count of face loops

                     • <b>close</b> – close profile polygon if <b>True</b>

                     • <b>quads</b> – use quadrilaterals as connection faces if <b>True</b> else triangles

                     • <b>caps</b> – close hull with top- and bottom faces (ngons)

       <b>ezdxf.render.forms.rotation_form(count:</b> <b>int,</b> <b>profile:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>angle:</b> <b>float</b> <b>=</b> <b>math.tau,</b> <b>axis:</b> <u>UVec</u>
       <b>=</b> <b>(1,</b> <b>0,</b> <b>0),</b> <b>*,</b> <b>caps=False)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Returns a <u>MeshTransformer</u> instance created by rotating a <u>profile</u> around an <u>axis</u>.

              <b>Parameters</b>

                     • <b>count</b> – count of rotated profiles

                     • <b>profile</b> – profile to rotate as list of vertices

                     • <b>angle</b> – rotation angle in radians

                     • <b>axis</b> – rotation axis

                     • <b>caps</b> – close hull with start- and end faces (ngons)

       <b>ezdxf.render.forms.sweep(profile:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>sweeping_path:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>*,</b> <b>close=True,</b>
       <b>quads=True,</b> <b>caps=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
              Returns the mesh from sweeping a profile along a 3D path, where  the  sweeping  path  defines  the
              final location in the <u>WCS</u>.

              The  profile  is  defined in a reference system. The origin of this reference system will be moved
              along the sweeping path where the z-axis of the reference  system  is  pointing  into  the  moving
              direction.

              Returns the mesh as <u>ezdxf.render.MeshTransformer</u> object.

              <b>Parameters</b>

                     • <b>profile</b>  –  sweeping  profile  defined  in  the reference system as iterable of (x, y, z)
                       coordinates in counter-clockwise order

                     • <b>sweeping_path</b> – the sweeping path defined in the WCS as iterable of (x, y, z) coordinates

                     • <b>close</b> – close sweeping profile if <b>True</b>

                     • <b>quads</b> – use quadrilaterals as connection faces if <b>True</b> else triangles

                     • <b>caps</b> – close hull with top- and bottom faces (ngons)

       <b>ezdxf.render.forms.sweep_profile(profile:</b> <b>Iterable[</b><u>UVec</u><b>],</b> <b>sweeping_path:</b> <b>Iterable[</b><u>UVec</u><b>])</b> <b>-&gt;</b>
       <b>list[Sequence[</b><u>Vec3</u><b>]]</b>
              Returns the intermediate profiles of sweeping a profile along a 3D path where  the  sweeping  path
              defines the final location in the <u>WCS</u>.

              The  profile  is  defined in a reference system. The origin of this reference system will be moved
              along the sweeping path where the z-axis of the reference  system  is  pointing  into  the  moving
              direction.

              Returns the start-, end- and all intermediate profiles along the sweeping path.

   <b>MeshBuilder</b>
       The  <u>MeshBuilder</u>  classes  are helper tools to manage meshes buildup by vertices and faces.  The vertices
       are stored in a vertices list as <b>Vec3</b> instances.  The faces are stored as a sequence  of  vertex  indices
       which  is  the location of the vertex in the vertex list. A single <u>MeshBuilder</u> class can contain multiple
       separated meshes at the same time.

       The method <u>MeshBuilder.render_mesh()</u> renders the content as a single  DXF  <u>Mesh</u>  entity,  which  supports
       ngons, ngons are polygons with more than 4 vertices. This entity requires at least DXF R2000.

       The  method  <u>MeshBuilder.render_polyface()</u>  renders  the  content  as a single DXF <u>Polyface</u> entity, which
       supports only triangles and quadrilaterals. This entity is supported by DXF R12.

       The method <u>MeshBuilder.render_3dfaces()</u> renders each face of the mesh as a  single   DXF  <u>Face3d</u>  entity,
       which supports only triangles and quadrilaterals. This entity is supported by DXF R12.

       The  <u>MeshTransformer</u>  class  is often used as an interface object to transfer mesh data between functions
       and moduls, like for the mesh exchange add-on <u>meshex</u>.

       The basic <u>MeshBuilder</u> class does not support transformations.

       <b>class</b> <b>ezdxf.render.MeshBuilder</b>

              <b>vertices</b>
                     List of vertices as <u>Vec3</u> or <b>(x,</b> <b>y,</b> <b>z)</b> tuple

              <b>faces</b>  List of faces as list of vertex indices,  where a vertex index is the index of  the  vertex
                     in  the <u>vertices</u> list. A face requires at least three vertices, <u>Mesh</u> supports ngons, so the
                     count of vertices is not limited.

              <b>add_face(vertices:</b> <b>Iterable[</b><u>UVec</u><b>])</b> <b>-&gt;</b> <b>None</b>
                     Add a face as vertices list to the mesh. A face requires at least 3 vertices,  each  vertex
                     is a <b>(x,</b> <b>y,</b> <b>z)</b> tuple or <u>Vec3</u> object. The new vertex indices are stored as face in the <u>faces</u>
                     list.

                     <b>Parameters</b>
                            <b>vertices</b>  –  list  of at least 3 vertices <b>[(x1,</b> <b>y1,</b> <b>z1),</b> <b>(x2,</b> <b>y2,</b> <b>z2),</b> <b>(x3,</b> <b>y3,</b> <b>y3),</b>
                            <b>...]</b>

              <b>add_mesh(vertices:</b> <b>list[</b><u>Vec3</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>faces:</b> <b>list[Sequence[int]]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>mesh=None)</b>
              <b>-&gt;</b> <b>None</b>
                     Add another mesh to this mesh.

                     A <u>mesh</u> can be a <u>MeshBuilder</u>, <u>MeshVertexMerger</u> or <u>Mesh</u> object  or  requires  the  attributes
                     <u>vertices</u> and <u>faces</u>.

                     <b>Parameters</b>

                            • <b>vertices</b> – list of vertices, a vertex is a <b>(x,</b> <b>y,</b> <b>z)</b> tuple or <u>Vec3</u> object

                            • <b>faces</b> – list of faces, a face is a list of vertex indices

                            • <b>mesh</b> – another mesh entity

              <b>add_vertices(vertices:</b> <b>Iterable[</b><u>UVec</u><b>])</b> <b>-&gt;</b> <b>Sequence[int]</b>
                     Add  new  vertices  to the mesh, each vertex is a <b>(x,</b> <b>y,</b> <b>z)</b> tuple or a <u>Vec3</u> object, returns
                     the indices of the <u>vertices</u> added to the <u>vertices</u> list.

                     e.g. adding 4 vertices to an  empty  mesh,  returns  the  indices  <b>(0,</b>  <b>1,</b>  <b>2,</b>  <b>3)</b>,  adding
                     additional 4 vertices returns the indices <b>(4,</b> <b>5,</b> <b>6,</b> <b>7)</b>.

                     <b>Parameters</b>
                            <b>vertices</b> – list of vertices, vertex as <b>(x,</b> <b>y,</b> <b>z)</b> tuple or <u>Vec3</u> objects

                     <b>Returns</b>
                            indices of the <u>vertices</u> added to the <u>vertices</u> list

                     <b>Return</b> <b>type</b>
                            tuple

              <b>bbox()</b> <b>-&gt;</b> <u>BoundingBox</u>
                     Returns the <u>BoundingBox</u> of the mesh.

              <b>copy()</b> Returns a copy of mesh.

              <b>diagnose()</b> <b>-&gt;</b> <b>MeshDiagnose</b>
                     Returns the <u>MeshDiagnose</u> object for this mesh.

              <b>face_normals()</b> <b>-&gt;</b> <b>Iterator[</b><u>Vec3</u><b>]</b>
                     Yields all face normals, yields the <b>NULLVEC</b> instance for degenerated faces.

              <b>face_orientation_detector(reference:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <u>FaceOrientationDetector</u>
                     Returns  a  <u>FaceOrientationDetector</u>  or  short  <u>fod</u>  instance.   The forward orientation is
                     defined by the <u>reference</u> face which is 0 by default.

                     The <u>fod</u> can check if all faces are reachable from the reference face and if all faces  have
                     the same orientation. The <u>fod</u> can be reused to unify the face orientation of the mesh.

              <b>faces_as_vertices()</b> <b>-&gt;</b> <b>Iterator[list[</b><u>Vec3</u><b>]]</b>
                     Yields all faces as list of vertices.

              <b>flip_normals()</b> <b>-&gt;</b> <b>None</b>
                     Flips the normals of all faces by reversing the vertex order inplace.

              <b>classmethod</b> <b>from_builder(other:</b> <u>MeshBuilder</u><b>)</b>
                     Create  new  mesh  from  other  mesh  builder,  faster  than  <u>from_mesh()</u> but supports only
                     <u>MeshBuilder</u> and inherited classes.

              <b>classmethod</b> <b>from_mesh(other:</b> <u>MeshBuilder</u> <b>|</b> <u>Mesh</u><b>)</b> <b>-&gt;</b> <b>T</b>
                     Create new mesh from other mesh as class method.

                     <b>Parameters</b>
                            <b>other</b> – <u>mesh</u> of type <u>MeshBuilder</u> and inherited or DXF  <u>Mesh</u>  entity  or  any  object
                            providing attributes <u>vertices</u>, <b>edges</b> and <u>faces</u>.

              <b>classmethod</b> <b>from_polyface(other:</b> <u>Polymesh</u> <b>|</b> <u>Polyface</u><b>)</b> <b>-&gt;</b> <b>T</b>
                     Create new mesh from a  <u>Polyface</u> or <u>Polymesh</u> object.

              <b>get_face_vertices(index:</b> <b>int)</b> <b>-&gt;</b> <b>Sequence[</b><u>Vec3</u><b>]</b>
                     Returns the face <u>index</u> as sequence of <u>Vec3</u> objects.

              <b>get_face_normal(index:</b> <b>int)</b> <b>-&gt;</b> <u>Vec3</u>
                     Returns  the  normal  vector  of  the  face <u>index</u> as <u>Vec3</u>, returns the <b>NULLVEC</b> instance for
                     degenerated  faces.

              <b>merge_coplanar_faces(passes:</b> <b>int</b> <b>=</b> <b>1)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns a new <u>MeshBuilder</u> object with merged adjacent coplanar faces.

                     The faces have to share at least two vertices and  have  to  have  the  same  clockwise  or
                     counter-clockwise vertex order.

                     The current implementation is not very capable!

              <b>mesh_tessellation(max_vertex_count:</b> <b>int</b> <b>=</b> <b>4)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns a new <u>MeshTransformer</u> instance, where each face has no more vertices than the given
                     <u>max_vertex_count</u>.

                     The  <u>fast</u>  mode  uses a shortcut for faces with less than 6 vertices which may not work for
                     concave faces!

              <b>normalize_faces()</b> <b>-&gt;</b> <b>None</b>
                     Removes duplicated vertex indices from faces and stores all faces as open faces, where  the
                     last vertex is not coincident with the first vertex.

              <b>open_faces()</b> <b>-&gt;</b> <b>Iterator[Sequence[int]]</b>
                     Yields  all faces as sequence of integers where the first vertex is not coincident with the
                     last vertex.

              <b>optimize_vertices(precision:</b> <b>int</b> <b>=</b> <b>6)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns a new mesh with optimized vertices. Coincident vertices are merged together and all
                     faces are open faces (first vertex != last vertex). Uses  internally  the  <u>MeshVertexMerger</u>
                     class to merge vertices.

              <b>render_3dfaces(layout:</b> <b>GenericLayoutType,</b> <b>dxfattribs=None,</b> <b>matrix:</b> <u>Matrix44</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>ucs:</b>
              <u>UCS</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
                     Render mesh as <u>Face3d</u> entities into <u>layout</u>.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>dxfattribs</b> – dict of DXF attributes e.g. <b>{'layer':</b> <b>'mesh',</b> <b>'color':</b> <b>7}</b>

                            • <b>matrix</b> – transformation matrix of type <u>Matrix44</u>

                            • <b>ucs</b> – transform vertices by <u>UCS</u> to <u>WCS</u>

              <b>render_mesh(layout:</b> <b>GenericLayoutType,</b> <b>dxfattribs=None,</b> <b>matrix:</b> <u>Matrix44</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>ucs:</b> <u>UCS</u> <b>|</b>
              <b>None</b> <b>=</b> <b>None)</b>
                     Render mesh as <u>Mesh</u> entity into <u>layout</u>.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>dxfattribs</b> – dict of DXF attributes e.g. <b>{'layer':</b> <b>'mesh',</b> <b>'color':</b> <b>7}</b>

                            • <b>matrix</b> – transformation matrix of type <u>Matrix44</u>

                            • <b>ucs</b> – transform vertices by <u>UCS</u> to <u>WCS</u>

              <b>render_normals(layout:</b> <b>GenericLayoutType,</b> <b>length:</b> <b>float</b> <b>=</b> <b>1,</b> <b>relative=True,</b> <b>dxfattribs=None)</b>
                     Render  face  normals  as  <u>Line</u>  entities  into <u>layout</u>, useful to check orientation of mesh
                     faces.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>length</b> – visual length of normal, use length &lt; 0  to  point  normals  in  opposite
                              direction

                            • <b>relative</b> – scale length relative to face size if <b>True</b>

                            • <b>dxfattribs</b> – dict of DXF attributes e.g. <b>{'layer':</b> <b>'normals',</b> <b>'color':</b> <b>6}</b>

              <b>render_polyface(layout:</b> <b>GenericLayoutType,</b> <b>dxfattribs=None,</b> <b>matrix:</b> <u>Matrix44</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>ucs:</b>
              <u>UCS</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
                     Render mesh as <u>Polyface</u> entity into <u>layout</u>.

                     <b>Parameters</b>

                            • <b>layout</b> – <u>BaseLayout</u> object

                            • <b>dxfattribs</b> – dict of DXF attributes e.g. <b>{'layer':</b> <b>'mesh',</b> <b>'color':</b> <b>7}</b>

                            • <b>matrix</b> – transformation matrix of type <u>Matrix44</u>

                            • <b>ucs</b> – transform vertices by <u>UCS</u> to <u>WCS</u>

              <b>separate_meshes()</b> <b>-&gt;</b> <b>list[MeshTransformer]</b>
                     A  single  <u>MeshBuilder</u>  instance can store multiple separated meshes. This function returns
                     this separated meshes as multiple <u>MeshTransformer</u> instances.

              <b>subdivide(level:</b> <b>int</b> <b>=</b> <b>1,</b> <b>quads=True)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns a new <u>MeshTransformer</u> object with all faces subdivided.

                     <b>Parameters</b>

                            • <b>level</b> – subdivide levels from 1 to max of 5

                            • <b>quads</b> – create quad faces if <b>True</b> else create triangles

              <b>subdivide_ngons(max_vertex_count=4)</b> <b>-&gt;</b> <b>Iterator[Sequence[</b><u>Vec3</u><b>]]</b>
                     Yields all faces as sequence of <u>Vec3</u> instances,  where  all  ngons  which  have  more  than
                     <u>max_vertex_count</u>  vertices  gets  subdivided.   In  contrast  to the <u>tessellation()</u> method,
                     creates this method a new vertex in the centroid of  the  face.  This  can  create  a  more
                     regular tessellation but only works reliable for convex faces!

              <b>tessellation(max_vertex_count:</b> <b>int</b> <b>=</b> <b>4)</b> <b>-&gt;</b> <b>Iterator[Sequence[</b><u>Vec3</u><b>]]</b>
                     Yields  all  faces  as  sequence of <u>Vec3</u> instances, each face has no more vertices than the
                     given <u>max_vertex_count</u>. This method uses the “ear  clipping”  algorithm  which  works  with
                     concave faces too and does not create any additional vertices.

              <b>unify_face_normals(*,</b> <b>fod:</b> <u>FaceOrientationDetector</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns  a  new  <u>MeshTransformer</u> object with unified face normal vectors of all faces.  The
                     forward direction (not necessarily outwards) is defined by the face-normals of the majority
                     of the faces.  This function can not process non-manifold meshes (more than two  faces  are
                     connected by a single edge) or multiple disconnected meshes in a single <u>MeshBuilder</u> object.

                     It is possible to pass in an existing <u>FaceOrientationDetector</u> instance as argument <u>fod</u>.

                     <b>Raises</b>

                            • <b>NonManifoldError</b> – non-manifold mesh

                            • <b>MultipleMeshesError</b> – the <u>MeshBuilder</u> object contains multiple disconnected meshes

              <b>unify_face_normals_by_reference(reference:</b> <b>int</b> <b>=</b> <b>0,</b> <b>*,</b> <b>force_outwards=False,</b> <b>fod:</b>
              <u>FaceOrientationDetector</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns  a  new  <u>MeshTransformer</u> object with unified face normal vectors of all faces.  The
                     forward direction (not necessarily outwards) is defined by the reference face, which is the
                     first face of the <u>mesh</u> by default.  This function can not process non-manifold meshes (more
                     than two faces are connected by a single edge) or multiple disconnected meshes in a  single
                     <u>MeshBuilder</u> object.

                     The  outward  direction  of  all  face  normals  can  be  forced  by  stetting the argument
                     <u>force_outwards</u> to <b>True</b> but this works only for closed surfaces, and it’s time-consuming!

                     It is not possible to check for a closed surface as long the face normal  vectors  are  not
                     unified.  But it can be done afterward by the attribute <u>MeshDiagnose.is_closed_surface()</u> to
                     see if the result is trustworthy.

                     It is possible to pass in an existing <u>FaceOrientationDetector</u> instance as argument <u>fod</u>.

                     <b>Parameters</b>

                            • <b>reference</b> – index of the reference face

                            • <b>force_outwards</b> – forces face-normals to point outwards, this works only for closed
                              surfaces, and it’s time-consuming!

                            • <b>fod</b> – <u>FaceOrientationDetector</u> instance

                     <b>Raises</b> <b>ValueError</b> – non-manifold mesh or the <u>MeshBuilder</u> object
                                contains multiple disconnected meshes

   <b>MeshTransformer</b>
       Same functionality as <u>MeshBuilder</u> but supports inplace transformation.

       <b>class</b> <b>ezdxf.render.MeshTransformer</b>
              Subclass of <u>MeshBuilder</u>

              <b>transform(matrix:</b> <u>Matrix44</u><b>)</b>
                     Transform mesh inplace by applying the transformation <u>matrix</u>.

                     <b>Parameters</b>
                            <b>matrix</b> – 4x4 transformation matrix as <u>Matrix44</u> object

              <b>translate(dx:</b> <b>float</b> <b>|</b> <u>UVec</u> <b>=</b> <b>0,</b> <b>dy:</b> <b>float</b> <b>=</b> <b>0,</b> <b>dz:</b> <b>float</b> <b>=</b> <b>0)</b>
                     Translate mesh inplace.

                     <b>Parameters</b>

                            • <b>dx</b> – translation in x-axis or translation vector

                            • <b>dy</b> – translation in y-axis

                            • <b>dz</b> – translation in z-axis

              <b>scale(sx:</b> <b>float</b> <b>=</b> <b>1,</b> <b>sy:</b> <b>float</b> <b>=</b> <b>1,</b> <b>sz:</b> <b>float</b> <b>=</b> <b>1)</b>
                     Scale mesh inplace.

                     <b>Parameters</b>

                            • <b>sx</b> – scale factor for x-axis

                            • <b>sy</b> – scale factor for y-axis

                            • <b>sz</b> – scale factor for z-axis

              <b>scale_uniform(s:</b> <b>float)</b>
                     Scale mesh uniform inplace.

                     <b>Parameters</b>
                            <b>s</b> – scale factor for x-, y- and z-axis

              <b>rotate_x(angle:</b> <b>float)</b>
                     Rotate mesh around x-axis about <u>angle</u> inplace.

                     <b>Parameters</b>
                            <b>angle</b> – rotation angle in radians

              <b>rotate_y(angle:</b> <b>float)</b>
                     Rotate mesh around y-axis about <u>angle</u> inplace.

                     <b>Parameters</b>
                            <b>angle</b> – rotation angle in radians

              <b>rotate_z(angle:</b> <b>float)</b>
                     Rotate mesh around z-axis about <u>angle</u> inplace.

                     <b>Parameters</b>
                            <b>angle</b> – rotation angle in radians

              <b>rotate_axis(axis:</b> <u>UVec</u><b>,</b> <b>angle:</b> <b>float)</b>
                     Rotate mesh around an arbitrary axis located in the origin (0, 0, 0) about <u>angle</u>.

                     <b>Parameters</b>

                            • <b>axis</b> – rotation axis as Vec3

                            • <b>angle</b> – rotation angle in radians

   <b>MeshVertexMerger</b>
       Same functionality as <u>MeshBuilder</u>,  but  created  meshes  with  unique  vertices  and  no  doublets,  but
       <u>MeshVertexMerger</u>  needs  extra  memory  for  bookkeeping  and also does not support transformations.  The
       location of the merged vertices is the location of the first vertex with the same key.

       This  class  is  intended  as  intermediate  object  to  create  compact  meshes  and  convert  them   to
       <u>MeshTransformer</u> objects to apply transformations:

          mesh = MeshVertexMerger()

          # create your mesh
          mesh.add_face(...)

          # convert mesh to MeshTransformer object
          return <a href="../manmesh/MeshTransformer.from_builder.mesh.html">MeshTransformer.from_builder</a>(mesh)

       <b>class</b> <b>ezdxf.render.MeshVertexMerger(precision:</b> <b>int</b> <b>=</b> <b>6)</b>
              Subclass of <u>MeshBuilder</u>

              Mesh with unique vertices and no doublets, but needs extra memory for bookkeeping.

              <u>MeshVertexMerger</u>  creates  a key for every vertex by rounding its components by the Python <b>round()</b>
              function and a given <u>precision</u> value. Each vertex with the same key gets the  same  vertex  index,
              which  is  the  index  of  first  vertex  with this key, so all vertices with the same key will be
              located at the location of this first vertex. If you want an average location of all vertices with
              the same key use the <u>MeshAverageVertexMerger</u> class.

              <b>Parameters</b>
                     <b>precision</b> – floating point precision for vertex rounding

   <b>MeshAverageVertexMerger</b>
       This is an extended version of <u>MeshVertexMerger</u>.  The location of the  merged  vertices  is  the  average
       location  of  all  vertices  with  the  same  key,  this  needs extra memory and runtime in comparison to
       <u>MeshVertexMerger</u> and this class also does not support transformations.

       <b>class</b> <b>ezdxf.render.MeshAverageVertexMerger(precision:</b> <b>int</b> <b>=</b> <b>6)</b>
              Subclass of <u>MeshBuilder</u>

              Mesh with unique vertices and no doublets, but needs extra memory for bookkeeping and runtime  for
              calculation of average vertex location.

              <u>MeshAverageVertexMerger</u>  creates  a  key for every vertex by rounding its components by the Python
              <b>round()</b> function and a given <u>precision</u> value. Each vertex with the same key gets the  same  vertex
              index,  which  is  the index of first vertex with this key, the difference to the <u>MeshVertexMerger</u>
              class is the calculation of the average location for all vertices with the same  key,  this  needs
              extra  memory  to  keep track of the count of vertices for each key and extra runtime for updating
              the vertex location each time a vertex with an existing key is added.

              <b>Parameters</b>
                     <b>precision</b> – floating point precision for vertex rounding

       <b>class</b> <b>ezdxf.render.mesh.EdgeStat(count:</b> <b>int,</b> <b>balance:</b> <b>int)</b>
              Named tuple of edge statistics.

              <b>count</b>  how often the edge <u>(a,</u> <u>b)</u> is used in faces as <u>(a,</u> <u>b)</u> or <u>(b,</u> <u>a)</u>

              <b>balance</b>
                     count of edges <u>(a,</u> <u>b)</u> - count of edges <u>(b,</u> <u>a)</u> and should be 0 in “healthy” closed surfaces,
                     if the balance is not 0, maybe doubled coincident faces  exist  or  faces  may  have  mixed
                     clockwise and counter-clockwise vertex orders

   <b>MeshBuilder</b> <b>Helper</b> <b>Classes</b>
       <b>class</b> <b>ezdxf.render.MeshDiagnose</b>
              Diagnose  tool which can be used to analyze and detect errors of <u>MeshBuilder</u> objects like topology
              errors for closed surfaces.  The object contains cached values, which do not get  updated  if  the
              source mesh will be changed!

              <b>NOTE:</b>
                 There   exist   no   tools   in   <u>ezdxf</u>  to  repair  broken  surfaces,  but  you  can  use  the
                 <u>ezdxf.addons.meshex</u> addon to exchange meshes with the open source tool <u>MeshLab</u>.

              Create an instance of this tool by the <u>MeshBuilder.diagnose()</u> method.

              <b>property</b> <b>bbox:</b> <u>BoundingBox</u>
                     Returns the <u>BoundingBox</u> of the mesh. (cached data)

              <b>property</b> <b>edge_stats:</b> <b>Dict[Tuple[int,</b> <b>int],</b> <u>EdgeStat</u><b>]</b>
                     Returns the edge statistics as a <b>dict</b>. The dict-key is the edge  as  tuple  of  two  vertex
                     indices  <u>(a,</u>  <u>b)</u>  where  <u>a</u> is always smaller than <u>b</u>. The dict-value is an <b>EdgeStat</b> tuple of
                     edge count and edge balance, see <b>EdgeStat</b>  for  the  definition  of  edge  count  and  edge
                     balance. (cached data)

              <b>property</b> <b>euler_characteristic:</b> <b>int</b>
                     Returns the Euler characteristic: <u>https://en.wikipedia.org/wiki/Euler_characteristic</u>

                     This number is always 2 for convex polyhedra.

              <b>property</b> <b>face_normals:</b> <b>Sequence[</b><u>Vec3</u><b>]</b>
                     Returns all face normal vectors  as sequence. The <b>NULLVEC</b> instance is used as normal vector
                     for degenerated faces. (cached data)

              <b>property</b> <b>faces:</b> <b>Sequence[Sequence[int]]</b>
                     Sequence of faces as <b>Sequence[int]</b>

              <b>property</b> <b>is_closed_surface:</b> <b>bool</b>
                     Returns <b>True</b> if the mesh has a closed surface.  This method does not require a unified face
                     orientation.  If multiple separated meshes are present the state is only <b>True</b> if <b>all</b> meshes
                     have a closed surface. (cached data)

                     Returns <b>False</b> for non-manifold meshes.

              <b>property</b> <b>is_edge_balance_broken:</b> <b>bool</b>
                     Returns  <b>True</b>  if  the  edge  balance is broken, this indicates a topology error for closed
                     surfaces. A non-broken edge balance reflects that each edge connects two faces,  where  the
                     edge  is  clockwise oriented in the first face and counter-clockwise oriented in the second
                     face.  A broken edge balance indicates possible topology  errors  like  mixed  face  vertex
                     orientations  or  a  non-manifold  mesh where an edge connects more than two faces. (cached
                     data)

              <b>property</b> <b>is_manifold:</b> <b>bool</b>
                     Returns <b>True</b> if all edges have an edge count &lt; 3. (cached data)

                     A non-manifold mesh has edges with 3 or more connected faces.

              <b>property</b> <b>n_edges:</b> <b>int</b>
                     Returns the unique edge count. (cached data)

              <b>property</b> <b>n_faces:</b> <b>int</b>
                     Returns the face count.

              <b>property</b> <b>n_vertices:</b> <b>int</b>
                     Returns the vertex count.

              <b>property</b> <b>vertices:</b> <b>Sequence[</b><u>Vec3</u><b>]</b>
                     Sequence of mesh vertices as <u>Vec3</u> instances

              <b>centroid()</b> <b>-&gt;</b> <u>Vec3</u>
                     Returns the centroid of all vertices. (center of mass)

              <b>estimate_face_normals_direction()</b> <b>-&gt;</b> <b>float</b>
                     Returns the estimated face-normals direction as <b>float</b> value in the range [-1.0, 1.0] for  a
                     closed surface.

                     This  heuristic  works  well  for  simple  convex  hulls  but  struggles  with more complex
                     structures like a torus (doughnut).

                     A counter-clockwise (ccw) vertex arrangement for outward pointing faces is  assumed  but  a
                     clockwise (cw) arrangement works too but the return values are reversed.

                     The  closer  the  value  to 1.0 (-1.0 for cw) the more likely all normals pointing outwards
                     from the surface.

                     The closer the value to -1.0 (1.0 for cw) the more likely all normals pointing inwards from
                     the surface.

                     There are no exact confidence values if all faces pointing outwards, here some examples for
                     surfaces created by <u>ezdxf.render.forms</u> functions:

                        • <u>cube()</u> returns 1.0

                        • <u>cylinder()</u> returns 0.9992

                        • <u>sphere()</u> returns 0.9994

                        • <u>cone()</u> returns 0.9162

                        • <u>cylinder()</u> with all hull faces pointing outwards but  caps  pointing  inwards  returns
                          0.7785  but the property <u>is_edge_balance_broken</u> returns <b>True</b> which indicates the mixed
                          vertex orientation

                        • and the estimation of 0.0469 for a <u>torus()</u> is barely usable

              <b>has_non_planar_faces()</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if any face is non-planar.

              <b>surface_area()</b> <b>-&gt;</b> <b>float</b>
                     Returns the surface area.

              <b>total_edge_count()</b> <b>-&gt;</b> <b>int</b>
                     Returns the total edge count of all faces, shared edges are  counted  separately  for  each
                     face.  In  closed  surfaces  this count should be 2x the unique edge count <u>n_edges</u>. (cached
                     data)

              <b>unique_edges()</b> <b>-&gt;</b> <b>Iterable[Tuple[int,</b> <b>int]]</b>
                     Yields the unique edges of the mesh as int 2-tuples. (cached data)

              <b>volume()</b> <b>-&gt;</b> <b>float</b>
                     Returns the volume of a closed surface or 0 otherwise.

                     <b>WARNING:</b>
                        The face vertices have to be in counter-clockwise order, this requirement is not checked
                        by this method.

                        The result is not  correct  for  multiple  separated  meshes  in  a  single  MeshBuilder
                        object!!!

       <b>class</b> <b>ezdxf.render.FaceOrientationDetector(mesh:</b> <b>MeshBuilder,</b> <b>reference:</b> <b>int</b> <b>=</b> <b>0)</b>
              Helper   class   for   face   orientation  and  face  normal  vector  detection.  Use  the  method
              <u>MeshBuilder.face_orientation_detector()</u> to create an instance.

              The face orientation detector classifies the  faces  of  a  mesh  by  their  forward  or  backward
              orientation.   The  forward orientation is defined by a reference face, which is the first face of
              the mesh by default and this orientation is not necessarily outwards.

              This class has some overlapping features with <u>MeshDiagnose</u> but it has  a  longer  setup  time  and
              needs more memory than <u>MeshDiagnose</u>.

              <b>Parameters</b>

                     • <b>mesh</b> – source mesh as <u>MeshBuilder</u> object

                     • <b>reference</b> – index of the reference face

              <b>is_manifold</b>
                     <b>True</b>  if  all  edges  have  an edge count &lt; 3. A non-manifold mesh has edges with 3 or more
                     connected faces.

              <b>property</b> <b>all_reachable:</b> <b>bool</b>
                     Returns <b>True</b> if  all  faces  are  reachable  from  the  reference  face  same  as  property
                     <u>is_single_mesh</u>.

              <b>property</b> <b>count:</b> <b>tuple[int,</b> <b>int]</b>
                     Returns the count of forward and backward oriented faces.

              <b>property</b> <b>backward_faces:</b> <b>Iterator[Sequence[int]]</b>
                     Yields all backward oriented faces.

              <b>property</b> <b>forward_faces:</b> <b>Iterator[Sequence[int]]</b>
                     Yields all forward oriented faces.

              <b>property</b> <b>has_uniform_face_normals:</b> <b>bool</b>
                     Returns <b>True</b> if all reachable faces are forward oriented according to the reference face.

              <b>property</b> <b>is_closed_surface:</b> <b>bool</b>
                     Returns <b>True</b> if the mesh has a closed surface.  This method does not require a unified face
                     orientation.  If multiple separated meshes are present the state is only <b>True</b> if <b>all</b> meshes
                     have a closed surface.

                     Returns <b>False</b> for non-manifold meshes.

              <b>property</b> <b>is_single_mesh:</b> <b>bool</b>
                     Returns <b>True</b> if only a single mesh is present same as property <u>all_reachable</u>.

              <b>classify_faces(reference:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>None</b>
                     Detect the forward and backward oriented faces.

                     The forward and backward orientation has to be defined by a <u>reference</u> face.

              <b>is_reference_face_pointing_outwards()</b> <b>-&gt;</b> <b>bool</b>
                     Returns  <b>True</b>  if  the normal vector of the reference face is pointing outwards. This works
                     only for meshes  with  unified  faces  which  represent  a  closed  surfaces,  and  it’s  a
                     time-consuming calculation!

   <b>Trace</b>
       This module provides tools to create banded lines like LWPOLYLINE with width information.  Path rendering
       as quadrilaterals: <u>Trace</u>, <u>Solid</u> or <u>Face3d</u>.

       <b>class</b> <b>ezdxf.render.trace.TraceBuilder</b>
              Sequence of 2D banded lines like polylines with start- and end width or curves with start- and end
              width.

              <b>NOTE:</b>
                 Accepts 3D input, but z-axis is ignored. The <u>TraceBuilder</u> is a 2D only object and uses only the
                 <u>OCS</u> coordinates!

              <b>abs_tol</b>
                     Absolute tolerance for floating point comparisons

              <b>append(trace:</b> <b>AbstractTrace)</b> <b>-&gt;</b> <b>None</b>
                     Append a new trace.

              <b>close()</b>
                     Close multi traces by merging first and last trace, if linear traces.

              <b>faces()</b> <b>-&gt;</b> <b>Iterable[Tuple[</b><u>Vec2</u><b>,</b> <u>Vec2</u><b>,</b> <u>Vec2</u><b>,</b> <u>Vec2</u><b>]]</b>
                     Yields all faces as 4-tuples of <u>Vec2</u> objects in <u>OCS</u>.

              <b>faces_wcs(ocs:</b> <u>OCS</u><b>,</b> <b>elevation:</b> <b>float)</b> <b>-&gt;</b> <b>Iterable[Sequence[</b><u>Vec3</u><b>]]</b>
                     Yields all faces as 4-tuples of <u>Vec3</u> objects in <u>WCS</u>.

              <b>virtual_entities(dxftype='TRACE',</b> <b>dxfattribs=None,</b> <b>doc:</b> <u>Drawing</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b>
              <b>Iterable[Quadrilateral]</b>
                     Yields faces as SOLID, TRACE or 3DFACE entities with DXF attributes given in <u>dxfattribs</u>.

                     If  a  document  is  given,  the  doc attribute of the new entities will be set and the new
                     entities will be automatically added to the entity database of that document.

                     <b>NOTE:</b>
                        The <u>TraceBuilder</u> is a 2D only object and uses only the <u>OCS</u> coordinates!

                     <b>Parameters</b>

                            • <b>dxftype</b> – DXF type as string, “SOLID”, “TRACE” or “3DFACE”

                            • <b>dxfattribs</b> – DXF attributes for SOLID, TRACE or 3DFACE entities

                            • <b>doc</b> – associated document

              <b>classmethod</b> <b>from_polyline(polyline:</b> <u>DXFGraphic</u><b>,</b> <b>segments:</b> <b>int</b> <b>=</b> <b>64)</b> <b>-&gt;</b> <u>TraceBuilder</u>
                     Create a complete trace from a LWPOLYLINE or a 2D POLYLINE entity,  the  trace  consist  of
                     multiple sub-traces if <u>bulge</u> values are present. Uses only the <u>OCS</u> coordinates!

                     <b>Parameters</b>

                            • <b>polyline</b> – <u>LWPolyline</u> or 2D <u>Polyline</u>

                            • <b>segments</b>  –  count  of segments for bulge approximation, given count is for a full
                              circle, partial arcs have proportional less segments, but at least 3

              <b>__len__()</b>

              <b>__getitem__()</b>

       <b>class</b> <b>ezdxf.render.trace.LinearTrace</b>
              Linear 2D banded lines like polylines with start- and end width.

              Accepts 3D input, but z-axis is ignored.

              <b>abs_tol</b>
                     Absolute tolerance for floating point comparisons

              <b>is_started</b>
                     <u>True</u> if at least one station exist.

              <b>add_station(point:</b> <u>UVec</u><b>,</b> <b>start_width:</b> <b>float,</b> <b>end_width:</b> <b>float</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a trace station (like a vertex) at location <u>point</u>, <u>start_width</u> is the width of the next
                     segment starting at this station, <u>end_width</u> is the end width of the next segment.

                     Adding the last location again, replaces the actual last location e.g.   adding  lines  (a,
                     b),  (b,  c),  creates only 3 stations (a, b, c), this is very important to connect to/from
                     splines.

                     <b>Parameters</b>

                            • <b>point</b> – 2D location (vertex), z-axis of 3D vertices is ignored.

                            • <b>start_width</b> – start width of next segment

                            • <b>end_width</b> – end width of next segment

              <b>faces()</b> <b>-&gt;</b> <b>Iterable[Tuple[</b><u>Vec2</u><b>,</b> <u>Vec2</u><b>,</b> <u>Vec2</u><b>,</b> <u>Vec2</u><b>]]</b>
                     Yields all faces as 4-tuples of <u>Vec2</u> objects.

                     First and last miter is 90 degrees if the path is not closed, otherwise the intersection of
                     first and last segment is taken into account, a closed path has to have explicit  the  same
                     last and first vertex.

              <b>virtual_entities(dxftype='TRACE',</b> <b>dxfattribs=None,</b> <b>doc:</b> <u>Drawing</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b>
              <b>Iterable[Quadrilateral]</b>
                     Yields faces as SOLID, TRACE or 3DFACE entities with DXF attributes given in <u>dxfattribs</u>.

                     If  a  document  is  given,  the  doc attribute of the new entities will be set and the new
                     entities will be automatically added to the entity database of that document.

                     <b>Parameters</b>

                            • <b>dxftype</b> – DXF type as string, “SOLID”, “TRACE” or “3DFACE”

                            • <b>dxfattribs</b> – DXF attributes for SOLID, TRACE or 3DFACE entities

                            • <b>doc</b> – associated document

       <b>class</b> <b>ezdxf.render.trace.CurvedTrace</b>
              2D banded curves like arcs or splines with start- and end width.

              Represents always only one curved entity and all miter of  curve  segments  are  perpendicular  to
              curve tangents.

              Accepts 3D input, but z-axis is ignored.

              <b>faces()</b> <b>-&gt;</b> <b>Iterable[Tuple[</b><u>Vec2</u><b>,</b> <u>Vec2</u><b>,</b> <u>Vec2</u><b>,</b> <u>Vec2</u><b>]]</b>
                     Yields all faces as 4-tuples of <u>Vec2</u> objects.

              <b>virtual_entities(dxftype='TRACE',</b> <b>dxfattribs=None,</b> <b>doc:</b> <u>Drawing</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b>
              <b>Iterable[Quadrilateral]</b>
                     Yields faces as SOLID, TRACE or 3DFACE entities with DXF attributes given in <u>dxfattribs</u>.

                     If  a  document  is  given,  the  doc attribute of the new entities will be set and the new
                     entities will be automatically added to the entity database of that document.

                     <b>Parameters</b>

                            • <b>dxftype</b> – DXF type as string, “SOLID”, “TRACE” or “3DFACE”

                            • <b>dxfattribs</b> – DXF attributes for SOLID, TRACE or 3DFACE entities

                            • <b>doc</b> – associated document

              <b>classmethod</b> <b>from_arc(arc:</b> <u>ConstructionArc</u><b>,</b> <b>start_width:</b> <b>float,</b> <b>end_width:</b> <b>float,</b> <b>segments:</b> <b>int</b> <b>=</b>
              <b>64)</b> <b>-&gt;</b> <u>CurvedTrace</u>
                     Create curved trace from an arc.

                     <b>Parameters</b>

                            • <b>arc</b> – <u>ConstructionArc</u> object

                            • <b>start_width</b> – start width

                            • <b>end_width</b> – end width

                            • <b>segments</b> – count of segments for full circle (360 degree)  approximation,  partial
                              arcs have proportional less segments, but at least 3

                     <b>Raises</b> <b>ValueError</b> – if arc.radius &lt;= 0

              <b>classmethod</b> <b>from_spline(spline:</b> <u>BSpline</u><b>,</b> <b>start_width:</b> <b>float,</b> <b>end_width:</b> <b>float,</b> <b>segments:</b> <b>int)</b> <b>-&gt;</b>
              <u>CurvedTrace</u>
                     Create curved trace from a B-spline.

                     <b>Parameters</b>

                            • <b>spline</b> – <u>BSpline</u> object

                            • <b>start_width</b> – start width

                            • <b>end_width</b> – end width

                            • <b>segments</b> – count of segments for approximation

   <b>Point</b> <b>Rendering</b>
       Helper function to render <u>Point</u> entities as DXF primitives.

       <b>ezdxf.render.point.virtual_entities(point:</b> <b>Point,</b> <b>pdsize:</b> <b>float</b> <b>=</b> <b>1,</b> <b>pdmode:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>list[DXFGraphic]</b>
              Yields  point  graphic  as  DXF  primitives  LINE and CIRCLE entities.  The dimensionless point is
              rendered as zero-length line!

              Check for this condition:

                 e.dxftype() == 'LINE' and e.dxf.start.isclose(e.dxf.end)

              if the rendering engine can’t handle zero-length lines.

              <b>Parameters</b>

                     • <b>point</b> – DXF POINT entity

                     • <b>pdsize</b> – point size in drawing units

                     • <b>pdmode</b> – point styling mode, see <u>Point</u> class

       <b>SEE</b> <b>ALSO:</b>
          Go to <u>ezdxf.entities.Point</u> class documentation for more information about POINT styling modes.

   <b>MultiLeaderBuilder</b>
       These are helper classes to build <u>MultiLeader</u> entities in an easy way.  The <b>MultiLeader</b>  entity  supports
       two kinds of content, for each exist a specialized builder class:

       • <u>MultiLeaderMTextBuilder</u> for <u>MText</u> content

       • <u>MultiLeaderBlockBuilder</u> for <u>Block</u> content

       The usual steps of the building process are:

          1. create entity by a factory method

                 • <u>add_multileader_mtext()</u>

                 • <u>add_multileader_block()</u>

          2. set the content

                 • <u>MultiLeaderMTextBuilder.set_content()</u>

                 • <u>MultiLeaderBlockBuilder.set_content()</u>

                 • <u>MultiLeaderBlockBuilder.set_attribute()</u>

          3. set properties

                 • <u>MultiLeaderBuilder.set_arrow_properties()</u>

                 • <u>MultiLeaderBuilder.set_connection_properties()</u>

                 • <u>MultiLeaderBuilder.set_connection_types()</u>

                 • <u>MultiLeaderBuilder.set_leader_properties()</u>

                 • <u>MultiLeaderBuilder.set_mleader_style()</u>

                 • <u>MultiLeaderBuilder.set_overall_scaling()</u>

          4. add one or more leader lines

                 • <u>MultiLeaderBuilder.add_leader_line()</u>

          5. finalize building process

                 • <u>MultiLeaderBuilder.build()</u>

       The <u>Tutorial</u> <u>for</u> <u>MultiLeader</u> shows how to use these helper classes in more detail.

       <b>class</b> <b>ezdxf.render.MultiLeaderBuilder</b>
              Abstract base class to build <u>MultiLeader</u> entities.

              <b>property</b> <b>context:</b> <b>MLeaderContext</b>
                     Returns the context entity <u>MLeaderContext</u>.

              <b>property</b> <b>multileader:</b> <b>MultiLeader</b>
                     Returns the <u>MultiLeader</u> entity.

              <b>add_leader_line(side:</b> <u>ConnectionSide</u><b>,</b> <b>vertices:</b> <b>Iterable[</b><u>Vec2</u><b>])</b> <b>-&gt;</b> <b>None</b>
                     Add leader as iterable of vertices in render UCS coordinates (<u>WCS</u> by default).

                     <b>NOTE:</b>
                        Vertical (top, bottom) and horizontal attachment sides (left, right) can not be mixed in
                        a single entity - this is a limitation of the MULTILEADER entity.

                     <b>Parameters</b>

                            • <b>side</b> – connection side where to attach the leader line

                            • <b>vertices</b> – leader vertices

              <b>build(insert:</b> <u>Vec2</u><b>,</b> <b>rotation:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>ucs:</b> <u>UCS</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Compute  the  required  geometry  data. The construction plane is the xy-plane of the given
                     render <u>UCS</u>.

                     <b>Parameters</b>

                            • <b>insert</b> – insert location for the content in render UCS coordinates

                            • <b>rotation</b> – content rotation angle around the render UCS z-axis in degrees

                            • <b>ucs</b> – the render <u>UCS</u>, default is the <u>WCS</u>

              <b>set_arrow_properties(name:</b> <b>str</b> <b>=</b> <b>'',</b> <b>size:</b> <b>float</b> <b>=</b> <b>0.0)</b>
                     Set leader arrow properties all leader lines have the same arrow type.

                     The MULTILEADER entity is able to support multiple arrows, but this seems to be unsupported
                     by CAD applications and is therefore also not supported by the builder classes.

              <b>set_connection_properties(landing_gap:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>dogleg_length:</b> <b>float</b> <b>=</b> <b>0.0)</b>
                     Set the properties how to connect the leader line to the content.

                     The landing gap is the space between the content and the start  of  the  leader  line.  The
                     “dogleg”  is  the  first  line  segment  of the leader in the “horizontal” direction of the
                     content.

              <b>set_connection_types(left=HorizontalConnection.by_style,</b> <b>right=HorizontalConnection.by_style,</b>
              <b>top=VerticalConnection.by_style,</b> <b>bottom=VerticalConnection.by_style)</b>
                     Set the connection type for each connection side.

              <b>set_leader_properties(color:</b> <b>int</b> <b>|</b> <u>RGB</u> <b>=</b> <b>colors.BYBLOCK,</b> <b>linetype:</b> <b>str</b> <b>=</b> <b>'BYBLOCK',</b> <b>lineweight:</b>
              <b>int</b> <b>=</b> <b>const.LINEWEIGHT_BYBLOCK,</b> <b>leader_type=LeaderType.straight_lines)</b>
                     Set leader line properties.

                     <b>Parameters</b>

                            • <b>color</b> – line color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> or RGB tuple

                            • <b>linetype</b> – as name string, e.g. “BYLAYER”

                            • <b>lineweight</b> – as integer value, see: <u>Lineweights</u>

                            • <b>leader_type</b> – straight lines of spline type

              <b>set_mleader_style(style:</b> <b>MLeaderStyle)</b>
                     Reset base properties by <u>MLeaderStyle</u> properties. This also resets the content!

              <b>set_overall_scaling(scale:</b> <b>float)</b>
                     Set the overall scaling factor for the whole entity, except for the leader line vertices!

                     <b>Parameters</b>
                            <b>scale</b> – scaling factor &gt; 0.0

   <b>MultiLeaderMTextBuilder</b>
       Specialization of <u>MultiLeaderBuilder</u> to build <u>MultiLeader</u> with MTEXT content.

       <b>class</b> <b>ezdxf.render.MultiLeaderMTextBuilder</b>

              <b>set_content(content:</b> <b>str,</b> <b>color:</b> <b>int</b> <b>|</b> <u>RGB</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>char_height:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>alignment:</b>
              <u>TextAlignment</u> <b>=</b> <b>TextAlignment.left,</b> <b>style:</b> <b>str</b> <b>=</b> <b>'')</b>
                     Set MTEXT content.

                     <b>Parameters</b>

                            • <b>content</b> – MTEXT content as string

                            • <b>color</b> – block color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> or RGB tuple

                            • <b>char_height</b> – initial char height in drawing units

                            • <b>alignment</b> – <u>TextAlignment</u> - left, center, right

                            • <b>style</b> – name of <u>Textstyle</u> as string

              <b>quick_leader(content:</b> <b>str,</b> <b>target:</b> <u>Vec2</u><b>,</b> <b>segment1:</b> <u>Vec2</u><b>,</b> <b>segment2:</b> <u>Vec2</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b>
              <b>connection_type:</b> <u>HorizontalConnection</u> <b>|</b> <u>VerticalConnection</u> <b>=</b>
              <b>HorizontalConnection.middle_of_top_line,</b> <b>ucs:</b> <u>UCS</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Creates a quick MTEXT leader. The <u>target</u> point defines where the  leader  points  to.   The
                     <u>segment1</u>  is the first segment of the leader line relative to the <u>target</u> point, <u>segment2</u> is
                     an optional second line segment relative to the first line  segment.   The  <u>connection_type</u>
                     defines  the  type  of  connection  (horizontal or vertical) and the MTEXT alignment (left,
                     center or right).  Horizontal connections  are  always  left  or  right  aligned,  vertical
                     connections are always center aligned.

                     <b>Parameters</b>

                            • <b>content</b> – MTEXT content string

                            • <b>target</b> – leader target point as <b>Vec2</b>

                            • <b>segment1</b> – first leader line segment as relative distance to <u>insert</u>

                            • <b>segment2</b>  – optional second leader line segment as relative distance to first line
                              segment

                            • <b>connection_type</b> – one of <u>HorizontalConnection</u> or <u>VerticalConnection</u>

                            • <b>ucs</b> – the rendering <u>UCS</u>, default is the <u>WCS</u>

   <b>MultiLeaderBlockBuilder</b>
       Specialization of <u>MultiLeaderBuilder</u> to build <u>MultiLeader</u> with BLOCK content.

       <b>class</b> <b>ezdxf.render.MultiLeaderBlockBuilder</b>

              <b>property</b> <b>block_layout:</b> <u>BlockLayout</u>
                     Returns the block layout.

              <b>property</b> <b>extents:</b> <u>BoundingBox</u>
                     Returns the bounding box of the block.

              <b>set_content(name:</b> <b>str,</b> <b>color:</b> <b>int</b> <b>|</b> <u>RGB</u> <b>=</b> <b>colors.BYBLOCK,</b> <b>scale:</b> <b>float</b> <b>=</b> <b>1.0,</b>
              <b>alignment=BlockAlignment.center_extents)</b>
                     Set BLOCK content.

                     <b>Parameters</b>

                            • <b>name</b> – the block name as string

                            • <b>color</b> – block color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> or RGB tuple

                            • <b>scale</b> – the block scaling, not to be confused with overall scaling

                            • <b>alignment</b> – the block insertion point or the center of extents

              <b>set_attribute(tag:</b> <b>str,</b> <b>text:</b> <b>str,</b> <b>width:</b> <b>float</b> <b>=</b> <b>1.0)</b>
                     Add BLOCK attributes based on an ATTDEF entity in the block definition. All  properties  of
                     the  new  created  ATTRIB  entity  are  defined by the template ATTDEF entity including the
                     location.

                     <b>Parameters</b>

                            • <b>tag</b> – attribute tag name

                            • <b>text</b> – attribute content string

                            • <b>width</b> – width factor

   <b>Enums</b>
       <b>class</b> <b>ezdxf.render.LeaderType(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b> <b>start=1,</b>
       <b>boundary=None)</b>
              The leader type.

              <b>none</b>

              <b>straight_lines</b>

              <b>splines</b>

       <b>class</b> <b>ezdxf.render.ConnectionSide(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b> <b>start=1,</b>
       <b>boundary=None)</b>
              The leader connection side.

              Vertical (top, bottom) and horizontal attachment sides (left, right) can not be mixed in a  single
              entity - this is a limitation of the MULTILEADER entity.

              <b>left</b>

              <b>right</b>

              <b>top</b>

              <b>bottom</b>

       <b>class</b> <b>ezdxf.render.HorizontalConnection(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              The horizontal leader connection type.

              <b>by_style</b>

              <b>top_of_top_line</b>

              <b>middle_of_top_line</b>

              <b>middle_of_text</b>

              <b>middle_of_bottom_line</b>

              <b>bottom_of_bottom_line</b>

              <b>bottom_of_bottom_line_underline</b>

              <b>bottom_of_top_line_underline</b>

              <b>bottom_of_top_line</b>

              <b>bottom_of_top_line_underline_all</b>

       <b>class</b> <b>ezdxf.render.VerticalConnection(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              The vertical leader connection type.

              <b>by_style</b>

              <b>center</b>

              <b>center_overline</b>

       <b>class</b> <b>ezdxf.render.TextAlignment(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b> <b>start=1,</b>
       <b>boundary=None)</b>
              The <b>MText</b> alignment type.

              <b>left</b>

              <b>center</b>

              <b>right</b>

       <b>class</b> <b>ezdxf.render.BlockAlignment(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b> <b>start=1,</b>
       <b>boundary=None)</b>
              The <b>Block</b> alignment type.

              <b>center_extents</b>

              <b>insertion_point</b>

   <b>Arrows</b>
       This  module  provides  support  for  the  AutoCAD  standard  arrow  heads  used in DIMENSION, LEADER and
       MULTILEADER entities. Library user don’t have to use the <u>ARROWS</u> objects directly,  but  should  know  the
       arrow names stored in it as attributes. The arrow names should be accessed that way:

          import ezdxf

          arrow = ezdxf.ARROWS.closed_filled

       <b>ezdxf.render.arrows.ARROWS</b>
              Single instance of <b>_</b><u>Arrows</u> to work with.

       <b>class</b> <b>ezdxf.render.arrows._Arrows</b>
              Management object for standard arrows.

              <b>__acad__</b>
                     Set of AutoCAD standard arrow names.

              <b>__ezdxf__</b>
                     Set of arrow names special to <u>ezdxf</u>.

              <b>architectural_tick</b>
                     [image]

              <b>closed_filled</b>
                     [image]

              <b>dot</b>    [image]

              <b>dot_small</b>
                     [image]

              <b>dot_blank</b>
                     [image]

              <b>origin_indicator</b>
                     [image]

              <b>origin_indicator_2</b>
                     [image]

              <b>open</b>   [image]

              <b>right_angle</b>
                     [image]

              <b>open_30</b>
                     [image]

              <b>closed</b> [image]

              <b>dot_smallblank</b>
                     [image]

              <b>none</b>   [image]

              <b>oblique</b>
                     [image]

              <b>box_filled</b>
                     [image]

              <b>box</b>    [image]

              <b>closed_blank</b>
                     [image]

              <b>datum_triangle_filled</b>
                     [image]

              <b>datum_triangle</b>
                     [image]

              <b>integral</b>
                     [image]

              <b>ez_arrow</b>
                     [image]

              <b>ez_arrow_blank</b>
                     [image]

              <b>ez_arrow_filled</b>
                     [image]

              <b>is_acad_arrow(item:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if <u>item</u> is a standard AutoCAD arrow.

              <b>is_ezdxf_arrow(item:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if <u>item</u> is a special <u>ezdxf</u> arrow.

              <b>insert_arrow(layout:</b> <b>GenericLayoutType,</b> <b>name:</b> <b>str,</b> <b>insert:</b> <u>UVec</u> <b>=</b> <b>NULLVEC,</b> <b>size:</b> <b>float</b> <b>=</b> <b>1.0,</b>
              <b>rotation:</b> <b>float</b> <b>=</b> <b>0,</b> <b>*,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <u>Vec2</u>
                     Insert arrow as block reference into <u>layout</u>.

              <b>render_arrow(layout:</b> <b>GenericLayoutType,</b> <b>name:</b> <b>str,</b> <b>insert:</b> <u>UVec</u> <b>=</b> <b>NULLVEC,</b> <b>size:</b> <b>float</b> <b>=</b> <b>1.0,</b>
              <b>rotation:</b> <b>float</b> <b>=</b> <b>0,</b> <b>*,</b> <b>dxfattribs=None)</b> <b>-&gt;</b> <u>Vec2</u>
                     Render arrow as basic DXF entities into <u>layout</u>.

              <b>virtual_entities(name:</b> <b>str,</b> <b>insert:</b> <u>UVec</u> <b>=</b> <b>NULLVEC,</b> <b>size:</b> <b>float</b> <b>=</b> <b>0.625,</b> <b>rotation:</b> <b>float</b> <b>=</b> <b>0,</b> <b>*,</b>
              <b>dxfattribs=None)</b> <b>-&gt;</b> <b>Iterator[</b><u>DXFGraphic</u><b>]</b>
                     Returns all arrow components as virtual DXF entities.

   <b>Hatching</b>
       This module provides rendering support for hatch patterns as used in <u>Hatch</u> and <u>MPolygon</u> entities.

   <b>High</b> <b>Level</b> <b>Functions</b>
       <b>ezdxf.render.hatching.hatch_entity(polygon:</b> <b>DXFPolygon,</b> <b>filter_text_boxes=True,</b> <b>jiggle_origin:</b> <b>bool</b> <b>=</b>
       <b>True)</b> <b>-&gt;</b> <b>Iterator[tuple[</b><u>Vec3</u><b>,</b> <u>Vec3</u><b>]]</b>
              Yields  the  hatch pattern of the given HATCH or MPOLYGON entity as 3D lines.  Each line is a pair
              of <u>Vec3</u> instances as start- and end vertex, points are represented as lines of zero length,  which
              means the start vertex is equal to the end vertex.

              The  function yields nothing if <u>polygon</u> has a solid- or gradient filling or does not have a usable
              pattern assigned.

              <b>Parameters</b>

                     • <b>polygon</b> – <u>Hatch</u> or <u>MPolygon</u> entity

                     • <b>filter_text_boxes</b> – ignore text boxes if <b>True</b>

                     • <b>jiggle_origin</b> – move pattern line origins a small amount to avoid intersections in corner
                       points which causes errors in patterns

       <b>ezdxf.render.hatching.hatch_polygons(baseline:</b> <u>HatchBaseLine</u><b>,</b> <b>polygons:</b> <b>Sequence[Sequence[</b><u>Vec2</u><b>]],</b>
       <b>terminate:</b> <b>Callable[[],</b> <b>bool]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>Iterator[</b><u>Line</u><b>]</b>
              Yields all pattern lines for all hatch lines generated by the  given  <u>HatchBaseLine</u>,  intersecting
              the  given  2D  polygons as <u>Line</u> instances.  The <u>polygons</u> should represent a single entity with or
              without holes, the order of the polygons  and  their  winding  orientation  (cw  or  ccw)  is  not
              important. Entities which do not intersect or overlap should be handled separately!

              Each polygon is a sequence of <u>Vec2</u> instances, they are treated as closed polygons even if the last
              vertex is not equal to the first vertex.

              The hole detection is done by a simple inside/outside counting algorithm and far from perfect, but
              is able to handle ordinary polygons well.

              The  terminate function WILL BE CALLED PERIODICALLY AND should return <b>True</b> to terminate execution.
              This can be used to implement a timeout, which can be required if  using  a  very  small  hatching
              distance, especially if you get the data from untrusted sources.

              <b>Parameters</b>

                     • <b>baseline</b> – <u>HatchBaseLine</u>

                     • <b>polygons</b>  –  multiple  sequences  of  <b>Vec2</b>  instances  of  a  single entity, the order of
                       exterior- and hole paths and the  winding  orientation  (cw  or  ccw)  of  paths  is  not
                       important

                     • <b>terminate</b>  –  callback  function  which  is called periodically and should return <b>True</b> to
                       terminate the hatching function

       <b>ezdxf.render.hatching.hatch_paths(baseline:</b> <u>HatchBaseLine</u><b>,</b> <b>paths:</b> <b>Sequence[Path],</b> <b>terminate:</b> <b>Callable[[],</b>
       <b>bool]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>Iterator[</b><u>Line</u><b>]</b>
              Yields all pattern lines for all hatch lines generated by the  given  <u>HatchBaseLine</u>,  intersecting
              the  given  2D  <u>Path</u>  instances  as  <u>Line</u>  instances.  The paths are handled as projected into the
              xy-plane the z-axis of path vertices will be ignored if present.

              Same as the <u>hatch_polygons()</u> function, but  for  <u>Path</u>  instances  instead  of  polygons  build  of
              vertices.  This  function <b>does</b> <b>not</b> <b>flatten</b> the paths into vertices, instead the real intersections
              of the Bézier curves and the hatch lines are calculated.

              For more information see the docs of the <u>hatch_polygons()</u> function.

              <b>Parameters</b>

                     • <b>baseline</b> – <u>HatchBaseLine</u>

                     • <b>paths</b> – sequence of <u>Path</u> instances of a single entity, the order of  exterior-  and  hole
                       paths and the winding orientation (cw or ccw) of the paths is not important

                     • <b>terminate</b>  –  callback  function  which  is called periodically and should return <b>True</b> to
                       terminate the hatching function

   <b>Classes</b>
       <b>class</b> <b>ezdxf.render.hatching.HatchBaseLine(origin:</b> <u>Vec2</u><b>,</b> <b>direction:</b> <u>Vec2</u><b>,</b> <b>offset:</b> <u>Vec2</u><b>,</b> <b>line_pattern:</b>
       <b>list[float]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>min_hatch_line_distance=MIN_HATCH_LINE_DISTANCE)</b>
              A hatch baseline defines the source line for hatching a geometry.  A complete hatch pattern  of  a
              DXF entity can consist of one or more hatch baselines.

              <b>Parameters</b>

                     • <b>origin</b> – the origin of the hatch line as <u>Vec2</u> instance

                     • <b>direction</b> – the hatch line direction as <u>Vec2</u> instance, must not (0, 0)

                     • <b>offset</b> – the offset of the hatch line origin to the next or to the previous hatch line

                     • <b>line_pattern</b> – line pattern as sequence of floats, see also <u>PatternRenderer</u>

                     • <b>min_hatch_line_distance</b>   –   minimum   hatch   line   distance   to  render,  raises  an
                       <u>DenseHatchingLinesError</u> exception if the distance between hatch  lines  is  smaller  than
                       this value

              <b>Raises</b>

                     • <u>HatchLineDirectionError</u> – hatch baseline has no direction, (0, 0) vector

                     • <u>DenseHatchingLinesError</u> – hatching lines are too narrow

              <b>hatch_line(distance:</b> <b>float)</b> <b>-&gt;</b> <u>HatchLine</u>
                     Returns the <u>HatchLine</u> at the given signed <u>distance</u>.

              <b>pattern_renderer(distance:</b> <b>float)</b> <b>-&gt;</b> <u>PatternRenderer</u>
                     Returns the <u>PatternRenderer</u> for the given signed <u>distance</u>.

              <b>signed_distance(point:</b> <u>Vec2</u><b>)</b> <b>-&gt;</b> <b>float</b>
                     Returns the signed normal distance of the given <u>point</u> from this hatch baseline.

       <b>class</b> <b>ezdxf.render.hatching.HatchLine(origin:</b> <u>Vec2</u><b>,</b> <b>direction:</b> <u>Vec2</u><b>,</b> <b>distance:</b> <b>float)</b>
              Represents a single hatch line.

              <b>Parameters</b>

                     • <b>origin</b> – the origin of the hatch line as <u>Vec2</u> instance

                     • <b>direction</b> – the hatch line direction as <u>Vec2</u> instance, must not (0, 0)

                     • <b>distance</b> – the normal distance to the base hatch line as float

              <b>intersect_line(a:</b> <u>Vec2</u><b>,</b> <b>b:</b> <u>Vec2</u><b>,</b> <b>dist_a:</b> <b>float,</b> <b>dist_b:</b> <b>float)</b> <b>-&gt;</b> <u>Intersection</u>
                     Returns  the  <u>Intersection</u>  of  this hatch line and the line defined by the points <u>a</u> and <u>b</u>.
                     The arguments <u>dist_a</u> and <u>dist_b</u> are the signed normal distances of the points <u>a</u> and <u>b</u>  from
                     the  hatch  baseline.   The normal distances from the baseline are easy to calculate by the
                     <u>HatchBaseLine.signed_distance()</u> method and allow  a  fast  intersection  calculation  by  a
                     simple point interpolation.

                     <b>Parameters</b>

                            • <b>a</b> – start point of the line as <u>Vec2</u> instance

                            • <b>b</b> – end point of the line as <u>Vec2</u> instance

                            • <b>dist_a</b> – normal distance of point <u>a</u> to the hatch baseline as float

                            • <b>dist_b</b> – normal distance of point <u>b</u> to the hatch baseline as float

              <b>intersect_cubic_bezier_curve(curve:</b> <u>Bezier4P</u><b>)</b> <b>-&gt;</b> <b>Sequence[</b><u>Intersection</u><b>]</b>
                     Returns 0 to 3 <u>Intersection</u> points of this hatch line with a cubic Bèzier curve.

                     <b>Parameters</b>
                            <b>curve</b> – the cubic Bèzier curve as <u>ezdxf.math.Bezier4P</u> instance

       <b>class</b> <b>ezdxf.render.hatching.PatternRenderer(hatch_line:</b> <u>HatchLine</u><b>,</b> <b>pattern:</b> <b>Sequence[float])</b>
              The  hatch  pattern  of  a  DXF  entity  has  one  or more <u>HatchBaseLine</u> instances with an origin,
              direction, offset and line pattern.  The <u>PatternRenderer</u> for a certain distance from the  baseline
              has to be acquired from the <u>HatchBaseLine</u> by the <u>pattern_renderer()</u> method.

              The  origin  of  the  hatch line is the starting point of the line pattern. The offset defines the
              origin of the adjacent hatch line and doesn’t have to be orthogonal to the hatch line direction.

              <b>Line</b> <b>Pattern</b>

              The line pattern is a sequence of floats, where a value &gt; 0.0 is a dash, a value &lt; 0.0  is  a  gap
              and value of 0.0 is a point.

              <b>Parameters</b>

                     • <b>hatch_line</b> – <u>HatchLine</u>

                     • <b>pattern</b> – the line pattern as sequence of float values

              <b>render(start:</b> <u>Vec2</u><b>,</b> <b>end:</b> <u>Vec2</u><b>)</b> <b>-&gt;</b> <b>Iterator[tuple[</b><u>Vec2</u><b>,</b> <u>Vec2</u><b>]]</b>
                     Yields the pattern lines as pairs of <u>Vec2</u> instances from the start- to the end point on the
                     hatch  line.   For  points  the  start- and end point are the same <u>Vec2</u> instance and can be
                     tested by the <b>is</b> operator.

                     The start- and end points should be located collinear at the hatch line of  this  instance,
                     otherwise the points a projected onto this hatch line.

       <b>class</b> <b>ezdxf.render.hatching.Intersection(type:</b> <u>IntersectionType</u> <b>=</b> <b>IntersectionType.NONE,</b> <b>p0:</b> <u>Vec2</u> <b>=</b>
       <b>Vec2(nan,</b> <b>nan),</b> <b>p1:</b> <u>Vec2</u> <b>=</b> <b>Vec2(nan,</b> <b>nan))</b>
              Represents an intersection.

              <b>type</b>   intersection type as <u>IntersectionType</u> instance

              <b>p0</b>     (first) intersection point as <u>Vec2</u> instance

              <b>p1</b>     second intersection point as <u>Vec2</u> instance, only if <u>type</u> is COLLINEAR

       <b>class</b> <b>ezdxf.render.hatching.IntersectionType(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>

              <b>NONE</b>   no intersection

              <b>REGULAR</b>
                     regular intersection point at a polygon edge or a Bèzier curve

              <b>START</b>  intersection point at the start vertex of a polygon edge

              <b>END</b>    intersection point at the end vertex of a polygon edge

              <b>COLLINEAR</b>
                     intersection is collinear to a polygon edge

       <b>class</b> <b>ezdxf.render.hatching.Line(start:</b> <b>'Vec2',</b> <b>end:</b> <b>'Vec2',</b> <b>distance:</b> <b>'float')</b>

              <b>start</b>  start point as <u>Vec2</u> instance

              <b>end</b>    end point as <u>Vec2</u> instance

              <b>distance</b>
                     signed normal distance to the <u>HatchBaseLine</u>

   <b>Helper</b> <b>Functions</b>
       <b>ezdxf.render.hatching.hatch_boundary_paths(polygon:</b> <b>DXFPolygon,</b> <b>filter_text_boxes=True)</b> <b>-&gt;</b> <b>list[</b><u>Path</u><b>]</b>
              Returns  the  hatch  boundary  paths  as <u>ezdxf.path.Path</u> instances of HATCH and MPOLYGON entities.
              Ignores text boxes if argument <u>filter_text_boxes</u> is <b>True</b>.

       <b>ezdxf.render.hatching.hatch_line_distances(point_distances:</b> <b>Sequence[float],</b> <b>normal_distance:</b> <b>float)</b> <b>-&gt;</b>
       <b>list[float]</b>
              Returns all hatch line distances in the range of the given point distances.

       <b>ezdxf.render.hatching.pattern_baselines(polygon:</b> <b>DXFPolygon,</b> <b>min_hatch_line_distance:</b> <b>float</b> <b>=</b>
       <b>MIN_HATCH_LINE_DISTANCE,</b> <b>*,</b> <b>jiggle_origin:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <b>Iterator[</b><u>HatchBaseLine</u><b>]</b>
              Yields the hatch pattern baselines of HATCH and MPOLYGON entities as <u>HatchBaseLine</u> instances.  Set
              <u>jiggle_origin</u> to <b>True</b> to move pattern line origins a small amount to avoid intersections in corner
              points which causes errors in patterns.

   <b>Exceptions</b>
       <b>class</b> <b>ezdxf.render.hatching.HatchingError</b>
              Base exception class of the <b>hatching</b> module.

       <b>class</b> <b>ezdxf.render.hatching.HatchLineDirectionError</b>
              Hatching direction is undefined or a (0, 0) vector.

       <b>class</b> <b>ezdxf.render.hatching.DenseHatchingLinesError</b>
              Very small hatching distance which creates too many hatching lines.

</pre><h4><b>ADD-ONS</b></h4><pre>
   <b>Drawing</b> <b>/</b> <b>Export</b> <b>Add-on</b>
       This add-on provides the functionality to render a DXF document to produce a rasterized or vector-graphic
       image which can be saved to a file or viewed interactively depending on the backend being used.

       The module provides two example scripts in the folder <b>examples/addons/drawing</b> which can be  run  to  save
       rendered images to files or view an interactive visualisation.

          $ ./draw_cad.py --supported_formats
          # will list the file formats supported by the matplotlib backend.
          # Many formats are supported including vector graphics formats
          # such as pdf and svg

          $ ./draw_cad.py &lt;my_file.dxf&gt; --out image.png

          # draw a layout other than the model space
          $ ./draw_cad.py &lt;my_file.dxf&gt; --layout Layout1 --out image.png

          # opens a GUI application to view CAD files
          $ ./cad_viewer.py

       <b>SEE</b> <b>ALSO:</b>
          How-to section for the FAQ about the <u>Drawing</u> <u>Add-on</u>.

   <b>Design</b>
       The  implementation  of the <b>drawing</b> add-on is divided into a frontend and multiple backends. The frontend
       handles the translation of DXF features  and  properties  into  simplified  structures,  which  are  then
       processed by the backends.

   <b>Common</b> <b>Limitations</b> <b>to</b> <b>all</b> <b>Backends</b>
       • rich text formatting of the MTEXT entity is close to AutoCAD but not pixel perfect

       • relative size of POINT entities cannot be replicated exactly

       • rendering of ACIS entities is not supported

       • no 3D rendering engine, therefore:

            • 3D entities are projected into the xy-plane and 3D text is not supported

            • only top view rendering of the modelspace

            • VIEWPORTS are always rendered as top view

            • no visual style support

       • only basic support for:

         • infinite lines (rendered as lines with a finite length)

         • OLE2FRAME entities (rendered as rectangles)

         • vertical text (will render as horizontal text)

         • rendering of additional MTEXT columns may be incorrect

   <b>MatplotlibBackend</b>
       The <b>MatplotlibBackend</b> is used by the <u>Draw</u> command of the <u>ezdxf</u> launcher.

       Example for the usage of the <b>Matplotlib</b> backend:

          import sys
          import matplotlib.pyplot as plt
          from ezdxf import recover
          from ezdxf.addons.drawing import RenderContext, Frontend
          from ezdxf.addons.drawing.matplotlib import MatplotlibBackend

          # Safe loading procedure (requires ezdxf v0.14):
          try:
              doc, auditor = recover.readfile('your.dxf')
          except IOError:
              print(f'Not a DXF file or a generic I/O error.')
              <a href="../man1/sys.exit.1.html">sys.exit</a>(1)
          except ezdxf.DXFStructureError:
              print(f'Invalid or corrupted DXF file.')
              <a href="../man2/sys.exit.2.html">sys.exit</a>(2)

          # The auditor.errors attribute stores severe errors,
          # which may raise exceptions when rendering.
          if not auditor.has_errors:
              fig = plt.figure()
              ax = fig.add_axes([0, 0, 1, 1])
              ctx = RenderContext(doc)
              out = MatplotlibBackend(ax)
              Frontend(ctx, out).draw_layout(doc.modelspace(), finalize=True)
              fig.savefig('your.png', dpi=300)

       Simplified render workflow but with less control:

          from ezdxf import recover
          from ezdxf.addons.drawing import matplotlib

          # Exception handling left out for compactness:
          doc, auditor = recover.readfile('your.dxf')
          if not auditor.has_errors:
              matplotlib.qsave(doc.modelspace(), 'your.png')

   <b>PyQtBackend</b>
       <b>class</b> <b>ezdxf.addons.drawing.pyqt.PyQtBackend(scene=None)</b>
              Backend  which  uses the <b>PySide6</b> package to implement an interactive viewer. The <b>PyQt5</b> package can
              be used as fallback if the <b>PySide6</b> package is not available.

              <b>Parameters</b>
                     <b>scene</b> -- drawing canvas of type <b>QtWidgets.QGraphicsScene</b>, if <b>None</b>  a  new  canvas  will  be
                     created

       The <b>PyQtBackend</b> is used by the <u>View</u> command of the <u>ezdxf</u> launcher.

       <b>SEE</b> <b>ALSO:</b>
          The  <u>qtviewer.py</u>  module implements the core of a simple DXF viewer and the <u>cad_viewer.py</u> example is a
          skeleton to show how to launch the <b>CADViewer</b> class.

   <b>Recorder</b>
       New in version 1.1.

       This is a special backend which records the output of the <u>Frontend</u> class  in  compact  numpy  arrays  and
       these  recordings  and  can  be  played by a <b>Player</b> instance on one or more backends.  The recorded numpy
       arrays support measurement of bounding boxes and transformations which is for some backends a requirement
       to place the DXF content on size limited pages.

       <b>class</b> <b>ezdxf.addons.drawing.recorder.Recorder</b>
              Records the output of the Frontend class.

              The class implements the <b>BackendInterface</b> but does not record  <b>enter_entity()</b>,  <b>exit_entity()</b>  and
              <b>clear()</b> events.

              <b>player()</b> <b>-&gt;</b> <u>Player</u>
                     Returns  a  <u>Player</u>  instance  with  the  original recordings! Make a copy of this player to
                     protect the original recordings from being modified:

                        safe_player = recorder.player().copy()

       <b>class</b> <b>ezdxf.addons.drawing.recorder.Player</b>
              Plays the recordings of the <u>Recorder</u> backend on another backend.

              <b>bbox()</b> <b>-&gt;</b> <u>BoundingBox2d</u>
                     Returns the bounding box of all records as <u>BoundingBox2d</u>.

              <b>copy()</b> <b>-&gt;</b> <b>Self</b>
                     Returns a copy of the player with non-shared recordings.

              <b>crop_rect(p1:</b> <u>UVec</u><b>,</b> <b>p2:</b> <u>UVec</u><b>,</b> <b>distance:</b> <b>float)</b> <b>-&gt;</b> <b>None</b>
                     Crop recorded shapes inplace by a rectangle defined by two points.

                     The argument <u>distance</u> defines the approximation  precision  for  paths  which  have  to  be
                     approximated  as  polylines  for  cropping  but only paths which are really get cropped are
                     approximated, paths that are fully inside the crop box will not be approximated.

                     <b>Parameters</b>

                            • <b>p1</b> -- first corner of the clipping rectangle

                            • <b>p2</b> -- second corner of the clipping rectangle

                            • <b>distance</b> -- maximum distance from the center of the curve to  the  center  of  the
                              line  segment between two approximation points to determine if a segment should be
                              subdivided.

              <b>recordings()</b> <b>-&gt;</b> <b>Iterator[tuple[</b><u>RecordType</u><b>,</b> <b>BackendProperties,</b> <b>Any]]</b>
                     Yields all recordings as <u>(RecordType,</u> <u>BackendProperties,</u> <u>Data)</u> tuples.

                     The content of the <u>Data</u> field is determined by the enum <u>RecordType</u>:

                     • <u>RecordType.POINTS</u> returns a <b>NumpyPoints2d</b> instance, len() == 1 is a point, len() == 2  is
                       a line, len() &gt; 2 is a filled polygon

                     • <u>RecordType.SOLID_LINES</u>  returns  a  <b>NumpyPoints2d</b>  instance  where  each  pair  (n,  n+1)
                       represents the start- and end point of a line

                     • <u>RecordType.PATH</u>: returns a <b>NumpyPath2d</b> instance that represents a linear 2D path

                     • <u>RecordType.FILLED_PATHS</u> returns a tuple (exterior_paths, holes), where exterior_paths and
                       holes are tuples of <b>NumpyPath2d</b>.

              <b>replay(backend:</b> <u>BackendInterface</u><b>,</b> <b>override:</b> <b>Callable[[BackendProperties],</b> <u>Override</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
              <b>-&gt;</b> <b>None</b>
                     Replay the recording on another backend that implements the <b>BackendInterface</b>. The  optional
                     <u>override</u> function can be used to override the properties and state of data records, it gets
                     the <b>BackendProperties</b> as input and must return an <u>Override</u> instance.

              <b>transform(m:</b> <u>Matrix44</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Transforms the recordings inplace by a transformation matrix <u>m</u> of type <u>Matrix44</u>.

       <b>class</b> <b>ezdxf.addons.drawing.recorder.Override(properties:</b> <b>BackendProperties,</b> <b>is_visible:</b> <b>bool</b> <b>=</b> <b>True)</b>
              Represents the override state for a data record.

              <b>properties</b>
                     original or modified <b>BackendProperties</b>

                     <b>Type</b>   ezdxf.addons.drawing.properties.BackendProperties

              <b>is_visible</b>
                     override visibility e.g. switch layers on/off

                     <b>Type</b>   bool

       <b>class</b> <b>ezdxf.addons.drawing.recorder.RecordType(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              Enum, determines the data record type.

              <b>POINTS</b>

              <b>SOLID_LINES</b>

              <b>PATH</b>

              <b>FILLED_PATHS</b>

   <b>Layout</b>
       New in version 1.1.

       The  <b>Layout</b>  class builds the page layout and the matrix to transform the DXF content to page coordinates
       according to the layout <b>Settings</b>.  The DXF coordinate transformation is required for PDF and HPGL/2 which
       expects the output coordinates in the first quadrant and SVG which has an inverted y-axis.

       The <b>Layout</b> class uses following classes and enums for configuration:

       • <u>Page</u> - page definition

       • <u>Margins</u> - page margins definition

       • <u>Settings</u>  - configuration settings

       • <u>Units</u>  - enum for page units

       <b>class</b> <b>ezdxf.addons.drawing.layout.Page(width:</b> <b>float,</b> <b>height:</b> <b>float,</b> <b>units:</b> <u>Units</u> <b>=</b> <b>Units.mm,</b> <b>margins:</b>
       <u>Margins</u> <b>=</b> <b>(0,</b> <b>0,</b> <b>0,</b> <b>0),</b> <b>max_width:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>max_height:</b> <b>float</b> <b>=</b> <b>0.0)</b>
              Page definition class

              <b>width</b>  page width, 0 for auto-detect

                     <b>Type</b>   float

              <b>height</b> page height, 0 for auto-detect

                     <b>Type</b>   float

              <b>units</b>  page units as enum <u>Units</u>

                     <b>Type</b>   <u>ezdxf.addons.drawing.layout.Units</u>

              <b>margins</b>
                     page margins in page units

                     <b>Type</b>   <u>ezdxf.addons.drawing.layout.Margins</u>

              <b>max_width</b>
                     limit width for auto-detection, 0 for unlimited

                     <b>Type</b>   float

              <b>max_height</b>
                     limit height for auto-detection, 0 for unlimited

                     <b>Type</b>   float

              <b>property</b> <b>is_landscape:</b> <b>bool</b>
                     Returns <b>True</b> if the page has landscape orientation.

              <b>property</b> <b>is_portrait:</b> <b>bool</b>
                     Returns <b>True</b> if the page has portrait orientation. (square is portrait)

              <b>to_landscape()</b> <b>-&gt;</b> <b>None</b>
                     Converts the page to landscape orientation.

              <b>to_portrait()</b> <b>-&gt;</b> <b>None</b>
                     Converts the page to portrait orientation.

       <b>class</b> <b>ezdxf.addons.drawing.layout.Margins(top:</b> <b>float,</b> <b>right:</b> <b>float,</b> <b>bottom:</b> <b>float,</b> <b>left:</b> <b>float)</b>
              Page margins definition class

              <b>top</b>

                     <b>Type</b>   float

              <b>left</b>

                     <b>Type</b>   float

              <b>bottom</b>

                     <b>Type</b>   float

              <b>right</b>

                     <b>Type</b>   float

              <b>classmethod</b> <b>all(margin:</b> <b>float)</b> <b>-&gt;</b> <b>Self</b>
                     Returns a page margins definition class with four equal margins.

              <b>classmethod</b> <b>all2(top_bottom:</b> <b>float,</b> <b>left_right:</b> <b>float)</b> <b>-&gt;</b> <b>Self</b>
                     Returns a page margins definition class with equal top-bottom and left-right margins.

              <b>scale(factor:</b> <b>float)</b> <b>-&gt;</b> <b>Self</b>

       <b>class</b> <b>ezdxf.addons.drawing.layout.PageAlignment(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              Page alignment of content as enum.

              <b>TOP_LEFT</b>

              <b>TOP_CENTER</b>

              <b>TOP_RIGHT</b>

              <b>MIDDLE_LEFT</b>

              <b>MIDDLE_CENTER</b>

              <b>MIDDLE_RIGHT</b>

              <b>BOTTOM_LEFT</b>

              <b>BOTTOM_CENTER</b>

              <b>BOTTOM_RIGHT</b>

       <b>class</b> <b>ezdxf.addons.drawing.layout.Settings(content_rotation:</b> <b>int</b> <b>=</b> <b>0,</b> <b>fit_page:</b> <b>bool</b> <b>=</b> <b>True,</b> <b>scale:</b> <b>float</b>
       <b>=</b> <b>1.0,</b> <b>page_alignment:</b> <u>PageAlignment</u> <b>=</b> <b>PageAlignment.MIDDLE_CENTER,</b> <b>crop_at_margins:</b> <b>bool</b> <b>=</b> <b>False,</b>
       <b>max_stroke_width:</b> <b>float</b> <b>=</b> <b>0.001,</b> <b>min_stroke_width:</b> <b>float</b> <b>=</b> <b>0.05,</b> <b>fixed_stroke_width:</b> <b>float</b> <b>=</b> <b>0.15,</b>
       <b>output_coordinate_space:</b> <b>float</b> <b>=</b> <b>1000000)</b>
              The Layout settings.

              <b>content_rotation</b>
                     Rotate content about 0, 90,  180 or 270 degrees

                     <b>Type</b>   int

              <b>fit_page</b>
                     Scale content to fit the page.

                     <b>Type</b>   bool

              <b>page_alignment</b>
                     Supported by backends that use the <u>Page</u> class to define  the  size  of  the  output  media,
                     default alignment is <u>PageAlignment.MIDDLE_CENTER</u>

                     <b>Type</b>   <u>ezdxf.addons.drawing.layout.PageAlignment</u>

              <b>crop_at_margins</b>
                     crops  the  content  at the page margins if <b>True</b>, when supported by the backend, default is
                     <b>False</b>

                     <b>Type</b>   bool

              <b>scale</b>  Factor to scale the DXF units of model- or paperspace, to represent  1mm  in  the  rendered
                     output drawing. Only uniform scaling is supported.

                     e.g.  scale  1:100  and  DXF  units  are meters, 1m = 1000mm corresponds 10mm in the output
                     drawing = 10 / 1000 = 0.01;

                     e.g. scale 1:1; DXF units are mm = 1 / 1 = 1.0 the default value

                     The value is ignored if the page size is defined and the content  fits  the  page  and  the
                     value is also used to determine missing page sizes (width or height).

                     <b>Type</b>   float

              <b>max_stroke_width</b>
                     Used for <b>LineweightPolicy.RELATIVE</b> policy, <u>max_stroke_width</u> is defined as percentage of the
                     content extents, e.g. 0.001 is 0.1% of max(page-width, page-height)

                     <b>Type</b>   float

              <b>min_stroke_width</b>
                     Used  for  <b>LineweightPolicy.RELATIVE</b>  policy,  <u>min_stroke_width</u> is defined as percentage of
                     <u>max_stroke_width</u>, e.g. 0.05 is 5% of <u>max_stroke_width</u>

                     <b>Type</b>   float

              <b>fixed_stroke_width</b>
                     Used  for  <b>LineweightPolicy.RELATIVE_FIXED</b>  policy,  <u>fixed_stroke_width</u>   is   defined   as
                     percentage of <u>max_stroke_width</u>, e.g. 0.15 is 15% of <u>max_stroke_width</u>

                     <b>Type</b>   float

              <b>output_coordinate_space</b>
                     expert   feature   to  map  the  DXF  coordinates  to  the  output  coordinate  system  [0,
                     output_coordinate_space]

                     <b>Type</b>   float

       <b>class</b> <b>ezdxf.addons.drawing.layout.Units(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              Page units as enum.

              <b>inch</b>   25.4 mm

              <b>px</b>     1/96 inch

              <b>pt</b>     1/72 inch

              <b>mm</b>

              <b>cm</b>

   <b>SVGBackend</b>
       New in version 1.1.

       <b>class</b> <b>ezdxf.addons.drawing.svg.SVGBackend</b>
              This is a native SVG rendering backend and does not require any external packages  to  render  SVG
              images other than the core dependencies.  This backend support content cropping at page margins.

              <b>get_xml_root_element(page:</b> <u>Page</u><b>,</b> <b>*,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings(),</b> <b>render_box:</b>
              <u>BoundingBox2d</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>Element</b>

              <b>get_string(page:</b> <u>Page</u><b>,</b> <b>*,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings(),</b> <b>render_box:</b> <u>BoundingBox2d</u> <b>|</b> <b>None</b>
              <b>=</b> <b>None,</b> <b>xml_declaration=True)</b> <b>-&gt;</b> <b>str</b>
                     Returns the XML data as unicode string.

                     <b>Parameters</b>

                            • <b>page</b> -- page definition, see <u>Page</u>

                            • <b>settings</b> -- layout settings, see <u>Settings</u>

                            • <b>render_box</b> -- set explicit region to render, default is content bounding box

                            • <b>xml_declaration</b>  -- inserts the "&lt;?xml version='1.0' encoding='utf-8'?&gt;" string in
                              front of the &lt;svg&gt; element

       Usage:

          from ezdxf.addons.drawing import Frontend, RenderContext
          from ezdxf.addons.drawing import layout, svg

          doc = ezdxf.readfile("your.dxf")
          msp = doc.modelspace()
          backend = svg.SVGBackend()
          Frontend(RenderContext(doc), backend).<a href="../manmsp/draw_layout.msp.html">draw_layout</a>(msp)

          with open("your.svg", "wt") as fp:
              fp.write(backend.get_string(layout.Page(0, 0))

   <b>PyMuPdfBackend</b>
       New in version 1.1.

       <b>class</b> <b>ezdxf.addons.drawing.pymupdf.PyMuPdfBackend</b>
              This backend uses the <u>PyMuPdf</u> package to create PDF,  PNG,  PPM  and  PBM  output.   This  backend
              support content cropping at page margins.

              PyMuPDF  is  licensed  under  the <u>AGPL</u>. Sorry, but it's the best package for the job I've found so
              far.

              Install package:

                 pip install pymupdf

              <b>get_pdf_bytes(page:</b> <u>Page</u><b>,</b> <b>*,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings(),</b> <b>render_box:</b> <u>BoundingBox2d</u> <b>|</b>
              <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>bytes</b>
                     Returns the PDF document as bytes.

                     <b>Parameters</b>

                            • <b>page</b> -- page definition, see <u>Page</u>

                            • <b>settings</b> -- layout settings, see <u>Settings</u>

                            • <b>render_box</b> -- set explicit region to render, default is content bounding box

              <b>get_pixmap_bytes(page:</b> <u>Page</u><b>,</b> <b>*,</b> <b>fmt='png',</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings(),</b> <b>dpi:</b> <b>int</b> <b>=</b> <b>96,</b>
              <b>alpha=False,</b> <b>render_box:</b> <u>BoundingBox2d</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>bytes</b>
                     Returns a pixel image as bytes, supported image formats:
                                            ┌─────┬────────────────────────────────────┐
                                            │ png │ Portable Network Graphics          │
                                            ├─────┼────────────────────────────────────┤
                                            │ ppm │ Portable Pixmap (no alpha channel) │
                                            ├─────┼────────────────────────────────────┤
                                            │ pbm │ Portable Bitmap (no alpha channel) │
                                            └─────┴────────────────────────────────────┘

                     <b>Parameters</b>

                            • <b>page</b> -- page definition, see <u>Page</u>

                            • <b>fmt</b> -- image format

                            • <b>settings</b> -- layout settings, see <u>Settings</u>

                            • <b>dpi</b> -- output resolution in dots per inch

                            • <b>alpha</b> -- add alpha channel (transparency)

                            • <b>render_box</b> -- set explicit region to render, default is content bounding box

       Usage:

          import ezdxf
          from ezdxf.addons.drawing import Frontend, RenderContext
          from ezdxf.addons.drawing import layout, pymupdf

          doc = ezdxf.readfile("your.dxf")
          msp = doc.modelspace()
          backend = pymupdf.PyMuPdfBackend()
          Frontend(RenderContext(doc), backend).<a href="../manmsp/draw_layout.msp.html">draw_layout</a>(msp)

          with open("your.pdf", "wb") as fp:
              fp.write(backend.get_pdf_bytes(layout.Page(0, 0))

       Load the output of the <b>PyMuPdfBackend</b> into the <b>Image</b> class of the <u>Pillow</u> package for  further  processing
       or to output additional image formats:

          import io
          from PIL import Image

          ...  # see above

          # the ppm format is faster to process than png
          fp = io.BytesIO(backend.get_pixmap_bytes(layout.Page(0, 0), fmt="ppm", dpi=300))
          image = Image.open(fp, formats=["ppm"])

   <b>PlotterBackend</b>
       New in version 1.1.

       <b>class</b> <b>ezdxf.addons.drawing.hpgl2.PlotterBackend</b>
              The  <u>PlotterBackend</u> creates HPGL/2 plot files for output on raster plotters. This backend does not
              need any additional packages.  This backend support content cropping at page margins.

              The plot files are tested by the plot file viewer <u>ViewCompanion</u> <u>Standard</u> but not on real  hardware
              - please use with care and give feedback.

              <b>get_bytes(page:</b> <u>Page</u><b>,</b> <b>*,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings(),</b> <b>render_box:</b> <u>BoundingBox2d</u> <b>|</b> <b>None</b>
              <b>=</b> <b>None,</b> <b>curves=True,</b> <b>decimal_places:</b> <b>int</b> <b>=</b> <b>1,</b> <b>base=64)</b> <b>-&gt;</b> <b>bytes</b>
                     Returns the HPGL/2 data as bytes.

                     <b>Parameters</b>

                            • <b>page</b> -- page definition, see <u>Page</u>

                            • <b>settings</b> -- layout settings, see <u>Settings</u>

                            • <b>render_box</b> -- set explicit region to render, default is content bounding box

                            • <b>curves</b> -- use Bèzier curves for HPGL/2 output

                            • <b>decimal_places</b>  --  HPGL/2  output  precision, less decimal places creates smaller
                              files but for the price of imprecise curves (text)

                            • <b>base</b> -- base for polyline encoding, 32 for 7 bit encoding or 64 for 8 bit encoding

              <b>compatible(page:</b> <u>Page</u><b>,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings())</b> <b>-&gt;</b> <b>bytes</b>
                     Returns the HPGL/2 data as  7-bit  encoded  bytes  curves  as  approximated  polylines  and
                     coordinates  are rounded to integer values.  Has often the smallest file size and should be
                     compatible to all output devices but has a low quality text rendering.

              <b>low_quality(page:</b> <u>Page</u><b>,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings())</b> <b>-&gt;</b> <b>bytes</b>
                     Returns the HPGL/2 data as 8-bit encoded bytes, curves as Bézier curves and coordinates are
                     rounded to integer values.  Has a smaller file size than  normal  quality  and  the  output
                     device must support 8-bit encoding and Bèzier curves.

              <b>normal_quality(page:</b> <u>Page</u><b>,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings())</b> <b>-&gt;</b> <b>bytes</b>
                     Returns the HPGL/2 data as 8-bit encoded bytes, curves as Bézier curves and coordinates are
                     floats  rounded  to  one  decimal place.  Has a smaller file size than high quality and the
                     output device must support 8-bit encoding, Bèzier curves and fractional coordinates.

              <b>high_quality(page:</b> <u>Page</u><b>,</b> <b>settings:</b> <u>Settings</u> <b>=</b> <b>layout.Settings())</b> <b>-&gt;</b> <b>bytes</b>
                     Returns the HPGL/2 data as 8-bit  encoded  bytes  and  all  curves  as  Bézier  curves  and
                     coordinates  are  floats  rounded to two decimal places.  Has the largest file size and the
                     output device must support 8-bit encoding, Bèzier curves and fractional coordinates.

       Usage:

          import ezdxf
          from ezdxf.addons.drawing import Frontend, RenderContext
          from ezdxf.addons.drawing import layout, hpgl2

          doc = ezdxf.readfile("your.dxf")
          psp = doc.paperspace("Layout1")
          backend = hpgl2.PlotterBackend()
          Frontend(RenderContext(doc), backend).draw_layout(psp)
          page = layout.Page.from_dxf_layout(psp)

          with open("your.plt", "wb") as fp:
              fp.write(backend.normal_quality(page)

       You can check the output by the HPGL/2 viewer:

          ezdxf hpgl your.plt

   <b>DXFBackend</b>
       New in version 1.1.

       <b>class</b> <b>ezdxf.addons.drawing.dxf.DXFBackend(layout:</b> <b>BaseLayout,</b> <b>color_mode:</b> <u>ColorMode</u> <b>=</b> <b>ColorMode.RGB)</b>
              The <u>DXFBackend</u> creates simple DXF files of  POINT,  LINE,  LWPOLYLINE  and  HATCH  entities.  This
              backend does ot need any additional packages.

              <b>Parameters</b>

                     • <b>layout</b> -- a DXF <u>BaseLayout</u>

                     • <b>color_mode</b> -- see <u>ColorMode</u>

       <b>class</b> <b>ezdxf.addons.drawing.dxf.ColorMode(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              This enum is used to define the color output mode of the <u>DXFBackend</u>.

              <b>ACI</b>    the color is set as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> and assigned by layer

              <b>RGB</b>    the color is set as RGB true color value

       Render a paperspace layout into modelspace:

          import ezdxf
          from ezdxf.addons.drawing import Frontend, RenderContext
          from ezdxf.addons.drawing import layout, dxf

          doc = ezdxf.readfile("your.dxf")
          layout1 = doc.paperspace("Layout1")
          output_doc = ezdxf.new()
          output_msp = output_doc.modelspace()

          backend = dxf.DXFBackend(output_msp)
          Frontend(RenderContext(doc), backend).draw_layout(layout1)

          output_doc.saveas("layout1_in_modelspace.dxf")

   <b>Configuration</b>
       Additional  options  for  the  drawing  add-on  can  be  passed  by  the  <u>config</u> argument of the <b>Frontend</b>
       constructor <b>__init__()</b>. Not every option will be supported by all backends.

       Usage:

          my_config = Configuration(lineweight_scaling=2)

       <b>class</b> <b>ezdxf.addons.drawing.config.Configuration(pdsize:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>pdmode:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b>
       <b>measurement:</b> <u>Measurement</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>show_defpoints:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>proxy_graphic_policy:</b>
       <u>ProxyGraphicPolicy</u> <b>=</b> <b>ProxyGraphicPolicy.SHOW,</b> <b>line_policy:</b> <u>LinePolicy</u> <b>=</b> <b>LinePolicy.ACCURATE,</b>
       <b>hatch_policy:</b> <u>HatchPolicy</u> <b>=</b> <b>HatchPolicy.NORMAL,</b> <b>infinite_line_length:</b> <b>float</b> <b>=</b> <b>20,</b> <b>lineweight_scaling:</b>
       <b>float</b> <b>=</b> <b>1.0,</b> <b>min_lineweight:</b> <b>float</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>min_dash_length:</b> <b>float</b> <b>=</b> <b>0.1,</b> <b>max_flattening_distance:</b>
       <b>float</b> <b>=</b> <b>0.01,</b> <b>circle_approximation_count:</b> <b>int</b> <b>=</b> <b>128,</b> <b>hatching_timeout:</b> <b>float</b> <b>=</b> <b>30.0,</b>
       <b>min_hatch_line_distance:</b> <b>float</b> <b>=</b> <b>0.0001,</b> <b>color_policy:</b> <u>ColorPolicy</u> <b>=</b> <b>ColorPolicy.COLOR,</b> <b>custom_fg_color:</b>
       <b>str</b> <b>=</b> <b>'#000000',</b> <b>background_policy:</b> <u>BackgroundPolicy</u> <b>=</b> <b>BackgroundPolicy.DEFAULT,</b> <b>custom_bg_color:</b> <b>str</b> <b>=</b>
       <b>'#ffffff',</b> <b>lineweight_policy:</b> <u>LineweightPolicy</u> <b>=</b> <b>LineweightPolicy.ABSOLUTE,</b> <b>text_policy:</b> <u>TextPolicy</u> <b>=</b>
       <b>TextPolicy.FILLING)</b>
              Configuration options for the <b>drawing</b> add-on.

              <b>pdsize</b> the size to draw POINT entities (in drawing units) set to None to  use  the  $PDSIZE  value
                     from the dxf document header
                                          ┌──────┬───────────────────────────────────────┐
                                          │ 0    │ 5% of draw area height                │
                                          ├──────┼───────────────────────────────────────┤
                                          │ &lt;0   │ Specifies   a   percentage   of   the │
                                          │      │ viewport size                         │
                                          ├──────┼───────────────────────────────────────┤
                                          │ &gt;0   │ Specifies an absolute size            │
                                          ├──────┼───────────────────────────────────────┤
                                          │ None │ use the $PDMODE value  from  the  dxf │
                                          │      │ document header                       │
                                          └──────┴───────────────────────────────────────┘

                     <b>Type</b>   int | None

              <b>pdmode</b> point styling mode (see POINT documentation)

                     see <u>Point</u> class documentation

                     <b>Type</b>   int | None

              <b>measurement</b>
                     whether to use metric or imperial units as enum <u>ezdxf.enums.Measurement</u>
                                          ┌──────┬───────────────────────────────────────┐
                                          │ 0    │ use imperial units (in, ft, yd, ...)  │
                                          ├──────┼───────────────────────────────────────┤
                                          │ 1    │ use metric units (ISO meters)         │
                                          ├──────┼───────────────────────────────────────┤
                                          │ None │ use  the  $MEASUREMENT value from the │
                                          │      │ dxf document header                   │
                                          └──────┴───────────────────────────────────────┘

                     <b>Type</b>   <u>ezdxf.enums.Measurement</u> | None

              <b>show_defpoints</b>
                     whether to show or filter out POINT entities on the defpoints layer

                     <b>Type</b>   bool

              <b>proxy_graphic_policy</b>
                     the action to take when a proxy graphic is encountered

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.ProxyGraphicPolicy</u>

              <b>line_policy</b>
                     the method to use when drawing styled lines (eg dashed, dotted etc)

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.LinePolicy</u>

              <b>hatch_policy</b>
                     the method to use when drawing HATCH entities

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.HatchPolicy</u>

              <b>infinite_line_length</b>
                     the length to use when drawing infinite lines

                     <b>Type</b>   float

              <b>lineweight_scaling</b>
                     multiplies every lineweight by this factor; set this factor to 0.0 for a  constant  minimum
                     line  width  defined  by  the  <u>min_lineweight</u>  setting for all lineweights; the correct DXF
                     lineweight often looks too thick in SVG, so setting a factor &lt; 1  can  improve  the  visual
                     appearance

                     <b>Type</b>   float

              <b>min_lineweight</b>
                     the minimum line width in 1/300 inch; set to <b>None</b> for let the backend choose.

                     <b>Type</b>   float | None

              <b>min_dash_length</b>
                     the minimum length for a dash when drawing a styled line (default value is arbitrary)

                     <b>Type</b>   float

              <b>max_flattening_distance</b>
                     Max  flattening  distance  in drawing units see Path.flattening documentation.  The backend
                     implementation should calculate an appropriate value, like 1 screen- or paper pixel on  the
                     output medium, but converted into drawing units. Sets Path() approximation accuracy

                     <b>Type</b>   float

              <b>circle_approximation_count</b>
                     Approximate  a  full  circle by <u>n</u> segments, arcs have proportional less segments. Only used
                     for approximation of arcs in banded polylines.

                     <b>Type</b>   int

              <b>hatching_timeout</b>
                     hatching timeout for a single entity, very dense hatching patterns can cause  a  very  long
                     execution time, the default timeout for a single entity is 30 seconds.

                     <b>Type</b>   float

              <b>min_hatch_line_distance</b>
                     minimum hatch line distance to render, narrower pattern lines are rendered as solid filling

                     <b>Type</b>   float

              <b>color_policy</b>

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.ColorPolicy</u>

              <b>custom_fg_color</b>
                     Used  for  <b>ColorPolicy.custom</b>  policy,  custom foreground color as "#RRGGBBAA" color string
                     (RGB+alpha)

                     <b>Type</b>   str

              <b>background_policy</b>

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.BackgroundPolicy</u>

              <b>custom_bg_color</b>
                     Used for <b>BackgroundPolicy.custom</b> policy,  custom  background  color  as  "#RRGGBBAA"  color
                     string (RGB+alpha)

                     <b>Type</b>   str

              <b>lineweight_policy</b>

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.LineweightPolicy</u>

              <b>text_policy</b>

                     <b>Type</b>   <u>ezdxf.addons.drawing.config.TextPolicy</u>

              <b>with_changes()</b>
                     Returns a new frozen <u>Configuration</u> object with modified values.

   <b>BackgroundPolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.BackgroundPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              This enum is used to define the background color.

              <b>DEFAULT</b>
                     as resolved by the <b>Frontend</b> class

              <b>WHITE</b>  white background

              <b>BLACK</b>  black background

              <b>OFF</b>    fully transparent background

              <b>CUSTOM</b> custom background color by <u>Configuration.custom_bg_color</u>

   <b>ColorPolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.ColorPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              This enum is used to define how to determine the line/fill color.

              <b>COLOR</b>  as resolved by the <b>Frontend</b> class

              <b>COLOR_SWAP_BW</b>
                     as resolved by the <b>Frontend</b> class but swaps black and white

              <b>COLOR_NEGATIVE</b>
                     invert all colors

              <b>MONOCHROME</b>
                     maps all colors to gray scale in range [0%, 100%]

              <b>MONOCHROME_DARK_BG</b>
                     maps all colors to gray scale in range [30%, 100%], brightens colors for dark backgrounds

              <b>MONOCHROME_LIGHT_BG</b>
                     maps all colors to gray scale in range [0%, 70%], darkens colors for light backgrounds

              <b>BLACK</b>  maps all colors to black

              <b>WHITE</b>  maps all colors to white

              <b>CUSTOM</b> maps all colors to custom color <u>Configuration.custom_fg_color</u>

   <b>HatchPolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.HatchPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              The action to take when a HATCH entity is encountered

              <b>NORMAL</b> render pattern and solid fillings

              <b>IGNORE</b> do not show HATCH entities at all

              <b>SHOW_OUTLINE</b>
                     show only the outline of HATCH entities

              <b>SHOW_SOLID</b>
                     show HATCH entities as solid filling regardless of the pattern

   <b>LinePolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.LinePolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>

              <b>SOLID</b>  draw all lines as solid regardless of the linetype style

              <b>ACCURATE</b>
                     render styled lines as accurately as possible

   <b>LineweightPolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.LineweightPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              This enum is used to define how to determine the lineweight.

              <b>ABSOLUTE</b>
                     in mm as resolved by the <b>Frontend</b> class

              <b>RELATIVE</b>
                     lineweight is relative to page size

              <b>RELATIVE_FIXED</b>
                     fixed lineweight relative to page size for all strokes

   <b>ProxyGraphicPolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.ProxyGraphicPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              The action to take when an entity with a proxy graphic is encountered

              <b>NOTE:</b>
                 To  get  proxy  graphics  support  proxy  graphics  have  to  be  loaded: Set the global option
                 <u>ezdxf.options.load_proxy_graphics</u> to <b>True</b>, which is the default value.

                 This can not prevent drawing proxy graphic inside of blocks, because this is beyond the  domain
                 of the drawing add-on!

              <b>IGNORE</b> do not display proxy graphics (skip_entity will be called instead)

              <b>SHOW</b>   if the entity cannot be rendered directly (e.g. if not implemented) but a proxy is present:
                     display the proxy

              <b>PREFER</b> display proxy graphics even for entities where direct rendering is available

   <b>TextPolicy</b>
       <b>class</b> <b>ezdxf.addons.drawing.config.TextPolicy(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              This enum is used to define the text rendering.

              <b>FILLING</b>
                     text is rendered as solid filling (default)

              <b>OUTLINE</b>
                     text is rendered as outline paths

              <b>REPLACE_RECT</b>
                     replace text by a rectangle

              <b>REPLACE_FILL</b>
                     replace text by a filled rectangle

              <b>IGNORE</b> ignore text at all

   <b>Properties</b>
       <b>class</b> <b>ezdxf.addons.drawing.properties.Properties</b>
              An  implementation agnostic representation of DXF entity properties like color and linetype. These
              properties represent the actual values after resolving all DXF specific rules like "by layer", "by
              block" and so on.

              <b>color</b>  The actual color value of the DXF entity as "#RRGGBB" or "#RRGGBBAA" string. An alpha value
                     of "00" is opaque and "ff" is fully transparent.

              <b>rgb</b>    RGB values extract from the <u>color</u> value as tuple of integers.

              <b>luminance</b>
                     Perceived luminance calculated from the <u>color</u> value as float in the range [0.0, 1.0].

              <b>linetype_name</b>
                     The actual linetype name as string like "CONTINUOUS"

              <b>linetype_pattern</b>
                     The simplified DXF linetype pattern as tuple of floats, all  line  elements  and  gaps  are
                     values  greater  than  0.0  and  0.0  represents  a point. Line or point elements do always
                     alternate with gap elements: line-gap-line-gap-point-gap and the pattern always ends with a
                     gap.  The continuous line is an empty tuple.

              <b>linetype_scale</b>
                     The scaling factor as float to apply to the <u>linetype_pattern</u>.

              <b>lineweight</b>
                     The absolute lineweight to render in mm as float.

              <b>is_visible</b>
                     Visibility flag as bool.

              <b>layer</b>  The actual layer name the entity resides on as UPPERCASE string.

              <b>font</b>   The <b>FontFace</b> used for text rendering or <b>None</b>.

              <b>filling</b>
                     The actual <b>Filling</b> properties of the entity or <b>None</b>.

              <b>units</b>  The actual drawing units as <u>InsertUnits</u> enum.

   <b>LayerProperties</b>
       <b>class</b> <b>ezdxf.addons.drawing.properties.LayerProperties</b>
              Actual layer properties, inherits from class <b>Properties</b>.

              <b>is_visible</b>
                     Modified meaning: whether entities belonging to this layer should be drawn

              <b>layer</b>  Modified meaning: stores real layer name (mixed case)

   <b>LayoutProperties</b>
       <b>class</b> <b>ezdxf.addons.drawing.properties.LayoutProperties</b>
              Actual layout properties.

              <b>name</b>   Layout name as string

              <b>units</b>  Layout units as <u>InsertUnits</u> enum.

              <b>property</b> <b>LayoutProperties.background_color:</b> <b>str</b>
                     Returns the default layout background color.

              <b>property</b> <b>LayoutProperties.default_color:</b> <b>str</b>
                     Returns the default layout foreground color.

              <b>property</b> <b>LayoutProperties.has_dark_background:</b> <b>bool</b>
                     Returns <b>True</b> if the actual background-color is "dark".

              <b>LayoutProperties.set_colors(bg:</b> <b>str,</b> <b>fg:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Setup default layout colors.

                     Required color format "#RRGGBB" or including alpha transparency "#RRGGBBAA".

   <b>RenderContext</b>
       <b>class</b> <b>ezdxf.addons.drawing.properties.RenderContext(doc:</b> <u>Drawing</u> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>*,</b> <b>ctb:</b> <b>str</b> <b>=</b> <b>'',</b>
       <b>export_mode:</b> <b>bool</b> <b>=</b> <b>False)</b>
              The render context for the given DXF document. The <u>RenderContext</u> resolves the  properties  of  DXF
              entities from the context they reside in to actual values like RGB colors, transparency, linewidth
              and so on.

              A  given  <u>ctb</u> file (plot style file) overrides the default properties for all layouts, which means
              the plot style table stored in the layout is always ignored.

              <b>Parameters</b>

                     • <b>doc</b> -- DXF document

                     • <b>ctb</b> -- path to a plot style table

                     • <b>export_mode</b> -- Whether to render the document as it would look when exported (plotted) by
                       a CAD application to a file such as pdf, or whether to render the document  as  it  would
                       appear inside a CAD application.

              <b>resolve_aci_color(aci:</b> <b>int,</b> <b>resolved_layer:</b> <b>str)</b> <b>-&gt;</b> <b>str</b>
                     Resolve the <u>aci</u> color as hex color string: "#RRGGBB"

              <b>resolve_all(entity:</b> <b>DXFGraphic)</b> <b>-&gt;</b> <u>Properties</u>
                     Resolve all properties of <u>entity</u>.

              <b>resolve_color(entity:</b> <b>DXFGraphic,</b> <b>*,</b> <b>resolved_layer:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>str</b>
                     Resolve the rgb-color of <u>entity</u> as hex color string: "#RRGGBB" or "#RRGGBBAA".

              <b>resolve_filling(entity:</b> <b>DXFGraphic)</b> <b>-&gt;</b> <b>Filling</b> <b>|</b> <b>None</b>
                     Resolve filling properties (SOLID, GRADIENT, PATTERN) of <u>entity</u>.

              <b>resolve_font(entity:</b> <b>DXFGraphic)</b> <b>-&gt;</b> <u>FontFace</u> <b>|</b> <b>None</b>
                     Resolve the text style of <u>entity</u> to a font name.  Returns <b>None</b> for the default font.

              <b>resolve_layer(entity:</b> <b>DXFGraphic)</b> <b>-&gt;</b> <b>str</b>
                     Resolve the layer of <u>entity</u>, this is only relevant for entities inside of block references.

              <b>resolve_layer_properties(layer:</b> <b>Layer)</b> <b>-&gt;</b> <u>LayerProperties</u>
                     Resolve layer properties.

              <b>resolve_linetype(entity:</b> <b>DXFGraphic,</b> <b>*,</b> <b>resolved_layer:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>tuple[str,</b>
              <b>Sequence[float]]</b>
                     Resolve  the  linetype of <u>entity</u>. Returns a tuple of the linetype name as upper-case string
                     and the simplified linetype pattern as tuple of floats.

              <b>resolve_lineweight(entity:</b> <b>DXFGraphic,</b> <b>*,</b> <b>resolved_layer:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>float</b>
                     Resolve the lineweight of <u>entity</u> in mm.

                     DXF stores the lineweight in mm times 100 (e.g. 0.13mm = 13).  The smallest line weight  is
                     0  and  the  biggest  line  weight  is 211.  The DXF/DWG format is limited to a fixed value
                     table, see: <b>ezdxf.lldxf.const.VALID_DXF_LINEWEIGHTS</b>

                     CAD applications draw lineweight 0mm as an undefined small value, to  prevent  backends  to
                     draw nothing for lineweight 0mm the smallest return value is 0.01mm.

              <b>resolve_units()</b> <b>-&gt;</b> <u>InsertUnits</u>

              <b>resolve_visible(entity:</b> <b>DXFGraphic,</b> <b>*,</b> <b>resolved_layer:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>bool</b>
                     Resolve the visibility state of <u>entity</u>. Returns <b>True</b> if <u>entity</u> is visible.

              <b>set_current_layout(layout:</b> <u>Layout</u><b>,</b> <b>ctb:</b> <b>str</b> <b>=</b> <b>'')</b>
                     Set the current layout and update layout specific properties.

              <b>set_layer_properties_override(func:</b> <b>Callable[[Sequence[</b><u>LayerProperties</u><b>]],</b> <b>None]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
                     The  function  <u>func</u> is called with the current layer properties as argument after resetting
                     them, so the function can override the layer properties.

       The <b>RenderContext</b> class can be used isolated from the <b>drawing</b> add-on to resolve DXF properties.

   <b>Frontend</b>
       <b>class</b> <b>ezdxf.addons.drawing.frontend.Frontend(ctx:</b> <u>RenderContext</u><b>,</b> <b>out:</b> <u>BackendInterface</u><b>,</b> <b>config:</b>
       <u>Configuration</u> <b>=</b> <b>Configuration.defaults(),</b> <b>bbox_cache:</b> <u>ezdxf.bbox.Cache</u> <b>=</b> <b>None)</b>
              Drawing frontend for 2D backends, responsible for decomposing entities into graphic primitives and
              resolving entity properties.

              By passing the bounding box cache of the modelspace entities can speed  up  paperspace  rendering,
              because the frontend can filter entities which are not visible in the VIEWPORT. Even passing in an
              empty cache can speed up rendering time when multiple viewports need to be processed.

              <b>Parameters</b>

                     • <b>ctx</b> -- the properties relevant to rendering derived from a DXF document

                     • <b>out</b> -- the 2D backend to draw to

                     • <b>config</b> -- settings to configure the drawing frontend and backend

                     • <b>bbox_cache</b>  -- bounding box cache of the modelspace entities or an empty cache which will
                       be filled dynamically when rendering multiple viewports or <b>None</b> to disable  bounding  box
                       caching at all

              <b>log_message(message:</b> <b>str)</b>
                     Log given message - override to alter behavior.

              <b>skip_entity(entity:</b> <b>DXFEntity,</b> <b>msg:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Called for skipped entities - override to alter behavior.

              <b>override_properties(entity:</b> <b>DXFGraphic,</b> <b>properties:</b> <u>Properties</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     The  <u>override_properties()</u> filter can change the properties of an entity independent of the
                     DXF attributes.

                     This filter has access to the DXF attributes by  the  <u>entity</u>  object,  the  current  render
                     context,  and the resolved properties by the <u>properties</u> object. It is recommended to modify
                     only the <u>properties</u> object in this filter.

              <b>draw_layout(layout:</b> <b>Layout,</b> <b>finalize:</b> <b>bool</b> <b>=</b> <b>True,</b> <b>*,</b> <b>filter_func:</b> <b>Callable[[DXFGraphic],</b> <b>bool]</b> <b>|</b>
              <b>None</b> <b>=</b> <b>None,</b> <b>layout_properties:</b> <u>LayoutProperties</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Draw all entities of the given <u>layout</u>.

                     Draws the entities of the layout in the default or redefined  redraw-order  and  calls  the
                     <b>finalize()</b>  method  of the backend if requested.  The default redraw order is the ascending
                     handle order not the order the entities are stored in the layout.

                     The method skips invisible entities and  entities  for  which  the  given  filter  function
                     returns <b>False</b>.

                     <b>Parameters</b>

                            • <b>layout</b> -- layout to draw of type <u>Layout</u>

                            • <b>finalize</b>  --  <b>True</b>  if  the  <b>finalize()</b>  method  of  the  backend should be called
                              automatically

                            • <b>filter_func</b> -- function to filter DXf entities, the function should  return  <b>False</b>
                              if a given entity should be ignored

                            • <b>layout_properties</b> -- override the default layout properties

   <b>BackendInterface</b>
       <b>class</b> <b>ezdxf.addons.drawing.backend.BackendInterface</b>
              Public interface definition for 2D rendering backends.

              For more information read the source code: <u>backend.py</u>

   <b>Backend</b>
       <b>class</b> <b>ezdxf.addons.drawing.backend.Backend</b>
              Abstract base class for concrete backend implementations and implements some default features.

              For more information read the source code: <u>backend.py</u>

   <b>Details</b>
       The  rendering  is performed in two stages. The frontend traverses the DXF document structure, converting
       each encountered entity into primitive drawing commands.  These commands  are  fed  to  a  backend  which
       implements the interface: <u>Backend</u>.

       Although the resulting images will not be pixel-perfect with AutoCAD (which was taken as the ground truth
       when developing this add-on) great care has been taken to achieve similar behavior in some areas:

       • The  algorithm  for determining color should match AutoCAD. However, the color palette is not stored in
         the DXF file, so the chosen colors may be different  to  what  is  expected.  The  <u>RenderContext</u>  class
         supports  passing  a  plot  style table (<u>CTB</u>-file) as custom color palette but uses the same palette as
         AutoCAD by default.

       • Text rendering is quite accurate, text positioning, alignment and  word  wrapping  are  very  faithful.
         Differences  may  occur  if a different font from what was used by the CAD application but even in that
         case, for supported backends, measurements are taken of the font being used to match text as closely as
         possible.

       • Visibility determination (based on which layers are visible) should match AutoCAD

       <b>SEE</b> <b>ALSO:</b>

          • <u>draw_cad.py</u> for a simple use of this module

          • <u>cad_viewer.py</u> for an advanced use of this module

          • <u>Notes</u> <u>on</u> <u>Rendering</u> <u>DXF</u> <u>Content</u> for additional behaviours documented during the development  of  this
            add-on.

   <b>Geo</b> <b>Interface</b>
   <b>Intended</b> <b>Usage</b>
       The  intended usage of the <u>ezdxf.addons.geo</u> module is as tool to work with geospatial data in conjunction
       with dedicated geospatial applications and libraries and the module can  not  and  should  not  replicate
       their functionality.

       The  only  reimplemented  feature  is  the  most  common  WSG84  EPSG:3395 World Mercator projection, for
       everything else use the dedicated packages like:

       • <u>pyproj</u> - Cartographic projections and coordinate transformations library.

       • <u>Shapely</u> - Manipulation and analysis of geometric objects in the Cartesian plane.

       • <u>PyShp</u> - The Python Shapefile Library (PyShp) reads and writes ESRI Shapefiles in pure Python.

       • <u>GeoJSON</u> - GeoJSON interface for Python.

       • <u>GDAL</u> - Tools for programming and manipulating the GDAL Geospatial Data Abstraction Library.

       • <u>Fiona</u> - Fiona is GDAL’s neat and nimble vector API for Python programmers.

       • <u>QGIS</u> - A free and open source geographic information system.

       • and many more …

       This module provides support for the  <b>__geo_interface__</b>: <u>https://gist.github.com/sgillies/2217756</u>

       Which is also supported by <u>Shapely</u>, for  supported  types  see  the  <u>GeoJSON</u>  Standard  and  examples  in
       <u>Appendix-A</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Tutorial</u>  <u>for</u>  <u>the</u>  <u>Geo</u>  <u>Add-on</u>  for  loading  GPX  data  into DXF files with an existing geo location
          reference and exporting DXF entities as GeoJSON data.

   <b>Proxy</b> <b>From</b> <b>Mapping</b>
       The <u>GeoProxy</u> represents a <b>__geo_interface__</b> mapping, create a  new  proxy  by  <u>GeoProxy.parse()</u>  from  an
       external  <b>__geo_interface__</b>  mapping.   <u>GeoProxy.to_dxf_entities()</u>  returns  new  DXF  entities from this
       mapping.  Returns “Point” as <u>Point</u> entity,  “LineString” as <u>LWPolyline</u>  entity  and  “Polygon”  as  <u>Hatch</u>
       entity  or  as  separated  <u>LWPolyline</u>  entities  (or  both)  and  new  in  v0.16.6 as <u>MPolygon</u>.  Supports
       “MultiPoint”,     “MultiLineString”,     “MultiPolygon”,     “GeometryCollection”,     “Feature”      and
       “FeatureCollection”.  Add new DXF entities to a layout by the <b>Layout.add_entity()</b> method.

   <b>Proxy</b> <b>From</b> <b>DXF</b> <b>Entity</b>
       The <u>proxy()</u> function or the constructor <u>GeoProxy.from_dxf_entities()</u> creates a new <u>GeoProxy</u> object from a
       single  DXF  entity  or from an iterable of DXF entities, entities without a corresponding representation
       will be approximated.

       Supported DXF entities are:

       • POINT as “Point”

       • LINE as “LineString”

       • LWPOLYLINE as “LineString” if open and “Polygon” if closed

       • POLYLINE as “LineString” if open and “Polygon” if closed, supports only 2D and 3D  polylines,  POLYMESH
         and POLYFACE are not supported

       • SOLID, TRACE, 3DFACE as “Polygon”

       • CIRCLE, ARC, ELLIPSE and SPLINE by approximation as “LineString” if open and “Polygon” if closed

       • HATCH and MPOLYGON as “Polygon”, holes are supported

       <b>WARNING:</b>
          This  module  does  no  extensive  validity checks for “Polygon” objects and because DXF has different
          requirements for HATCH boundary paths than the <u>GeoJSON</u> Standard, it  is  possible  to  create  invalid
          “Polygon”  objects.   It  is recommended to check critical objects by a sophisticated geometry library
          like <u>Shapely</u>.

   <b>Module</b> <b>Functions</b>
       <b>ezdxf.addons.geo.proxy(entity:</b> <b>DXFGraphic</b> <b>|</b> <b>Iterable[DXFGraphic],</b> <b>distance:</b> <b>float</b> <b>=</b>
       <b>MAX_FLATTENING_DISTANCE,</b> <b>force_line_string:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <u>GeoProxy</u>
              Returns a <u>GeoProxy</u> object.

              <b>Parameters</b>

                     • <b>entity</b> – a single DXF entity or iterable of DXF entities

                     • <b>distance</b> – maximum flattening distance for curve approximations

                     • <b>force_line_string</b>  –  by  default  this  function  returns  Polygon  objects  for  closed
                       geometries   like  CIRCLE,  SOLID,  closed  POLYLINE  and  so  on,  by  setting  argument
                       <u>force_line_string</u> to <b>True</b>, this entities will be returned as LineString objects.

       <b>ezdxf.addons.geo.dxf_entities(geo_mapping:</b> <b>MutableMapping[str,</b> <b>Any],</b> <b>polygon=PolygonConversion.HATCH,</b>
       <b>dxfattribs=None,</b> <b>*,</b> <b>post_process:</b> <b>Callable[[DXFGraphic,</b> <b>MutableMapping[str,</b> <b>Any]],</b> <b>None]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
       <b>-&gt;</b> <b>Iterator[DXFGraphic]</b>
              Returns <b>__geo_interface__</b> mappings as DXF entities.

              The enum <u>polygon</u> determines the method to convert polygons, use <u>PolygonConversion.HATCH</u> for  <u>Hatch</u>
              entity,  <u>PolygonConversion.POLYLINE</u>  for  <u>LWPolyline</u>  or  <u>PolygonConversion.HATCH_AND_POLYLINE</u> for
              both.  Option <u>PolygonConversion.POLYLINE</u> returns for the exterior path and each hole  a  separated
              <b>LWPolyline</b> entity. The <b>Hatch</b> entity supports holes, but has no explicit borderline.

              Yields <b>Hatch</b> always before <b>LWPolyline</b> entities.

              <u>PolygonConversion.MPOLYGON</u>  support  was  added  in  v0.16.6,  which  is like a <u>Hatch</u> entity  with
              additional borderlines, but the MPOLYGON entity  is  not  a  core  DXF  entity  and  DXF  viewers,
              applications  and  libraries  my  not  support  this  entity.  The DXF attribute <u>color</u> defines the
              borderline color and <u>fill_color</u> the color of the solid filling.

              The returned DXF entities can be added to a layout by the <b>Layout.add_entity()</b> method.

              <b>Parameters</b>

                     • <b>geo_mapping</b>  –  <b>__geo__interface__</b>  mapping  as  <b>dict</b>  or  a   Python   object   with   a
                       <b>__geo__interface__</b> property

                     • <b>polygon</b> – see <u>PolygonConversion</u>

                     • <b>dxfattribs</b> – dict with additional DXF attributes

                     • <b>post_process</b>  –  post  process  function  of type <b>PostProcesFunc</b> that get the created DXF
                       entity and the geo mapping as input, see reference implementation <u>assign_layers()</u>

       <b>ezdxf.addons.geo.gfilter(entities:</b> <b>Iterable[DXFGraphic])</b> <b>-&gt;</b> <b>Iterator[DXFGraphic]</b>
              Filter DXF entities from iterable  <u>entities</u>,  which  are  incompatible  to  the  <b>__geo_reference__</b>
              interface.

   <b>GeoProxy</b> <b>Class</b>
       <b>class</b> <b>ezdxf.addons.geo.GeoProxy(geo_mapping:</b> <b>MutableMapping[str,</b> <b>Any],</b> <b>places:</b> <b>int</b> <b>=</b> <b>6)</b>
              Stores the <b>__geo_interface__</b> mapping in a parsed and compiled form.

              Stores coordinates as <b>Vec3</b> objects and represents “Polygon” always as tuple (exterior, holes) even
              without holes.

              The  GeoJSON specification recommends 6 decimal places for latitude and longitude which equates to
              roughly 10cm of precision. You may need slightly more for certain applications, 9  decimal  places
              would be sufficient for professional survey-grade GPS coordinates.

              <b>Parameters</b>

                     • <b>geo_mapping</b> – parsed and compiled <b>__geo_interface__</b> mapping

                     • <b>places</b> – decimal places to round for <b>__geo_interface__</b> export

              <b>__geo_interface__</b>
                     Returns the <b>__geo_interface__</b> compatible mapping as <b>dict</b>.

              <b>geotype</b>
                     Property returns the top level entity type or <b>None</b>.

              <b>classmethod</b> <b>parse(geo_mapping:</b> <b>MutableMapping[str,</b> <b>Any])</b> <b>-&gt;</b> <b>Self</b>
                     Parse  and  compile  a  <b>__geo_interface__</b>  mapping  as  <b>dict</b>  or  a  Python  object  with a
                     <b>__geo_interface__</b> property, does some basic syntax checks, converts  all  coordinates  into
                     <b>Vec3</b> objects, represents “Polygon” always as tuple (exterior, holes) even without holes.

              <b>classmethod</b> <b>from_dxf_entities(entity:</b> <b>DXFGraphic</b> <b>|</b> <b>Iterable[DXFGraphic],</b> <b>distance:</b> <b>float</b> <b>=</b>
              <b>MAX_FLATTENING_DISTANCE,</b> <b>force_line_string:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <u>GeoProxy</u>
                     Constructor from a single DXF entity or an iterable of DXF entities.

                     <b>Parameters</b>

                            • <b>entity</b> – DXF entity or entities

                            • <b>distance</b> – maximum flattening distance for curve approximations

                            • <b>force_line_string</b>  –  by  default this function returns Polygon objects for closed
                              geometries like CIRCLE, SOLID, closed POLYLINE and  so  on,  by  setting  argument
                              <u>force_line_string</u> to <b>True</b>, this entities will be returned as LineString objects.

              <b>to_dxf_entities(polygon=PolygonConversion.HATCH,</b> <b>dxfattribs=None,</b> <b>*,</b> <b>post_process:</b>
              <b>Callable[[DXFGraphic,</b> <b>MutableMapping[str,</b> <b>Any]],</b> <b>None]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>Iterator[DXFGraphic]</b>
                     Returns stored <b>__geo_interface__</b> mappings as DXF entities.

                     The  <u>polygon</u>  argument determines the method to convert polygons, use 1 for <u>Hatch</u> entity, 2
                     for <u>LWPolyline</u> or 3 for both.  Option 2 returns for the  exterior  path  and  each  hole  a
                     separated  <b>LWPolyline</b>  entity.  The  <b>Hatch</b>  entity  supports  holes,  but  has  no explicit
                     borderline.

                     Yields <b>Hatch</b> always before <b>LWPolyline</b> entities.

                     <u>MPolygon</u> support was added in v0.16.6, which  is  like  a  <u>Hatch</u>  entity   with  additional
                     borderlines, but the MPOLYGON entity is not a core DXF entity and DXF viewers, applications
                     and  libraries  my  not support this entity. The DXF attribute <u>color</u> defines the borderline
                     color and <u>fill_color</u> the color of the solid filling.

                     The returned DXF entities can be added to a layout by the <b>Layout.add_entity()</b> method.

                     <b>Parameters</b>

                            • <b>polygon</b> – see <u>PolygonConversion</u>

                            • <b>dxfattribs</b> – dict with additional DXF attributes

                            • <b>post_process</b> – post process function of type <b>PostProcesFunc</b> that get  the  created
                              DXF   entity   and   the  geo  mapping  as  input,  see  reference  implementation
                              <u>assign_layers()</u>

              <b>copy()</b> <b>-&gt;</b> <u>GeoProxy</u>
                     Returns a deep copy.

              <b>__iter__()</b> <b>-&gt;</b> <b>Iterator[MutableMapping[str,</b> <b>Any]]</b>
                     Iterate over all geometry entities.

                     Yields  only  “Point”,  “LineString”,  “Polygon”,   “MultiPoint”,   “MultiLineString”   and
                     “MultiPolygon”  objects,  returns  the content of “GeometryCollection”, “FeatureCollection”
                     and “Feature” as geometry objects (“Point”, …).

              <b>wcs_to_crs(crs:</b> <u>Matrix44</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Transform all coordinates recursive from <u>WCS</u> coordinates into Coordinate  Reference  System
                     (CRS) by transformation matrix <u>crs</u> inplace.

                     The  CRS  is  defined  by the <u>GeoData</u> entity, get the <b>GeoData</b> entity from the modelspace by
                     method <u>get_geodata()</u>.  The CRS transformation matrix  can  be  acquired  form  the  <b>GeoData</b>
                     object by <u>get_crs_transformation()</u> method:

                        doc = ezdxf.readfile('file.dxf')
                        msp = doc.modelspace()
                        geodata = msp.get_geodata()
                        if geodata:
                            matrix, axis_ordering = geodata.get_crs_transformation()

                     If  <u>axis_ordering</u>  is <b>False</b> the CRS is not compatible with the <b>__geo_interface__</b> or GeoJSON
                     (see chapter 3.1.1).

                     <b>Parameters</b>
                            <b>crs</b> – transformation matrix of type <u>Matrix44</u>

              <b>crs_to_wcs(crs:</b> <u>Matrix44</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Transform all coordinates recursive from CRS into <u>WCS</u> coordinates by transformation  matrix
                     <u>crs</u> inplace, see also <u>GeoProxy.wcs_to_crs()</u>.

                     <b>Parameters</b>
                            <b>crs</b> – transformation matrix of type <u>Matrix44</u>

              <b>globe_to_map(func:</b> <b>Callable[[</b><u>Vec3</u><b>],</b> <u>Vec3</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Transform  all coordinates recursive from globe representation in longitude and latitude in
                     decimal degrees into 2D map representation in meters.

                     Default  is  WGS84  <u>EPSG:4326</u>  (GPS)   to   WGS84   <u>EPSG:3395</u>   World   Mercator   function
                     <u>wgs84_4326_to_3395()</u>.

                     Use the <u>pyproj</u> package to write a custom projection function as needed.

                     <b>Parameters</b>
                            <b>func</b>  –  custom transformation function, which takes one <b>Vec3</b> object as argument and
                            returns the result as a <b>Vec3</b> object.

              <b>map_to_globe(func:</b> <b>Callable[[</b><u>Vec3</u><b>],</b> <u>Vec3</u><b>]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Transform all coordinates recursive  from  2D  map  representation  in  meters  into  globe
                     representation as longitude and latitude in decimal degrees.

                     Default   is   WGS84   <u>EPSG:3395</u>   World   Mercator   to   WGS84   <u>EPSG:4326</u>  GPS  function
                     <u>wgs84_3395_to_4326()</u>.

                     Use the <u>pyproj</u> package to write a custom projection function as needed.

                     <b>Parameters</b>
                            <b>func</b> – custom transformation function, which takes one <b>Vec3</b> object as  argument  and
                            returns the result as a <b>Vec3</b> object.

              <b>apply(func:</b> <b>Callable[[</b><u>Vec3</u><b>],</b> <u>Vec3</u><b>])</b> <b>-&gt;</b> <b>None</b>
                     Apply the transformation function <u>func</u> recursive to all coordinates.

                     <b>Parameters</b>
                            <b>func</b> – transformation function as Callable[[Vec3], Vec3]

              <b>filter(func:</b> <b>Callable[[</b><u>GeoProxy</u><b>],</b> <b>bool])</b> <b>-&gt;</b> <b>None</b>
                     Removes  all  mappings  for  which  <u>func()</u>  returns <b>False</b>.  The function only has to handle
                     Point, LineString and Polygon entities, other entities like MultiPolygon are  divided  into
                     separate entities also any collection.

   <b>Helper</b> <b>Functions</b>
       <b>ezdxf.addons.geo.wgs84_4326_to_3395(location:</b> <u>Vec3</u><b>)</b> <b>-&gt;</b> <u>Vec3</u>
              Transform  WGS84  <u>EPSG:4326</u> location given as latitude and longitude in decimal degrees as used by
              GPS into World Mercator cartesian 2D coordinates in meters <u>EPSG:3395</u>.

              <b>Parameters</b>
                     <b>location</b> – <b>Vec3</b> object, x-attribute represents the longitude value (East-West)  in  decimal
                     degrees and the y-attribute represents the latitude value (North-South) in decimal degrees.

       <b>ezdxf.addons.geo.wgs84_3395_to_4326(location:</b> <u>Vec3</u><b>,</b> <b>tol:</b> <b>float</b> <b>=</b> <b>1e-6)</b> <b>-&gt;</b> <u>Vec3</u>
              Transform WGS84 World Mercator <u>EPSG:3395</u> location given as cartesian 2D coordinates x, y in meters
              into WGS84 decimal degrees as longitude and latitude <u>EPSG:4326</u> as used by GPS.

              <b>Parameters</b>

                     • <b>location</b> – <b>Vec3</b> object, z-axis is ignored

                     • <b>tol</b> – accuracy for latitude calculation

       <b>ezdxf.addons.geo.dms2dd(d:</b> <b>float,</b> <b>m:</b> <b>float</b> <b>=</b> <b>0,</b> <b>s:</b> <b>float</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>float</b>
              Convert degree, minutes, seconds into decimal degrees.

       <b>ezdxf.addons.geo.dd2dms(dd:</b> <b>float)</b> <b>-&gt;</b> <b>tuple[float,</b> <b>float,</b> <b>float]</b>
              Convert decimal degrees into degree, minutes, seconds.

       <b>ezdxf.addons.geo.assign_layers(entity:</b> <b>DXFGraphic,</b> <b>mapping:</b> <b>MutableMapping[str,</b> <b>Any])</b> <b>-&gt;</b> <b>None</b>
              Reference implementation for a <b>post_process()</b> function.

              <b>SEE</b> <b>ALSO:</b>
                 <u>dxf_entities()</u>

          def assign_layers(entity: DXFGraphic, mapping: GeoMapping) -&gt; None:
              properties = mapping.get("properties)
              if properties is None:
                  return
              layer = properties.get("layer")
              if layer:
                  entity.dxf.layer = layer

   <b>Types</b>
       <b>class</b> <b>ezdxf.addons.geo.PolygonConversion(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              Polygon conversion types as <b>IntEnum</b>.

              <b>HATCH</b>

              <b>POLYLINE</b>

              <b>HATCH_AND_POLYLINE</b>

              <b>MPOLYGON</b>

       <b>ezdxf.addons.geo.GeoMapping</b>
              alias of <b>MutableMapping</b>[<b>str</b>, <b>Any</b>]

       <b>ezdxf.addons.geo.PostProcessFunc</b>
              alias of <b>Callable</b>[[<b>DXFGraphic</b>, <b>MutableMapping</b>[<b>str</b>, <b>Any</b>]], <b>None</b>]

   <b>Importer</b>
       This  add-on  is  meant  to  import  graphical entities from another DXF drawing and their required table
       entries like LAYER, LTYPE or STYLE.

       Because of complex extensibility of the DXF format and the lack of sufficient documentation, I decided to
       remove most of the possible source  drawing  dependencies  from  imported  entities,  therefore  imported
       entities  may not look the same as the original entities in the source drawing, but at least the geometry
       should be the same and the DXF file does not break.

       Removed data which could contain source drawing dependencies: Extension Dictionaries, AppData and XDATA.

       <b>WARNING:</b>
          DON’T EXPECT PERFECT RESULTS!

       The <u>Importer</u> supports following data import:

          • entities which are really safe to import: LINE, POINT, CIRCLE,  ARC,  TEXT,  SOLID,  TRACE,  3DFACE,
            SHAPE,  POLYLINE,  ATTRIB,  ATTDEF,  INSERT, ELLIPSE, MTEXT, LWPOLYLINE, SPLINE, HATCH, MESH, XLINE,
            RAY, DIMENSION, LEADER, VIEWPORT

          • table and table entry import is restricted to LAYER, LTYPE, STYLE, DIMSTYLE

          • import of BLOCK definitions is supported

          • import of paper space layouts is supported

       Import of DXF objects from the OBJECTS section is not supported.

       DIMSTYLE override for entities DIMENSION and LEADER is not supported.

       Example:

          import ezdxf
          from ezdxf.addons import Importer

          sdoc = ezdxf.readfile('original.dxf')
          tdoc = ezdxf.new()

          importer = Importer(sdoc, tdoc)

          # import all entities from source modelspace into modelspace of the target drawing
          importer.import_modelspace()

          # import all paperspace layouts from source drawing
          importer.import_paperspace_layouts()

          # import all CIRCLE and LINE entities from source modelspace into an arbitrary target layout.
          # create target layout
          tblock = tdoc.blocks.new('SOURCE_ENTS')
          # query source entities
          ents = sdoc.modelspace().query('CIRCLE LINE')
          # import source entities into target block
          importer.import_entities(ents, tblock)

          # This is ALWAYS the last &amp; required step, without finalizing the target drawing is maybe invalid!
          # This step imports all additional required table entries and block definitions.
          importer.finalize()

          tdoc.saveas('imported.dxf')

       <b>class</b> <b>ezdxf.addons.importer.Importer(source:</b> <u>Drawing</u><b>,</b> <b>target:</b> <u>Drawing</u><b>)</b>
              The <u>Importer</u> class is central element for importing data from other DXF documents.

              <b>Parameters</b>

                     • <b>source</b> – source <b>Drawing</b>

                     • <b>target</b> – target <b>Drawing</b>

              <b>source</b> source DXF document

              <b>target</b> target DXF document

              <b>used_layers</b>
                     Set of used layer names as string, AutoCAD accepts layer names without a LAYER table entry.

              <b>used_linetypes</b>
                     Set of used linetype names as string, these linetypes require a TABLE entry or AutoCAD will
                     crash.

              <b>used_styles</b>
                     Set of used text style names, these text styles require  a  TABLE  entry  or  AutoCAD  will
                     crash.

              <b>used_dimstyles</b>
                     Set  of used dimension style names, these dimension styles require a TABLE entry or AutoCAD
                     will crash.

              <b>finalize()</b> <b>-&gt;</b> <b>None</b>
                     Finalize the import by importing required table  entries  and  BLOCK  definitions,  without
                     finalization  the  target document is maybe invalid for AutoCAD. Call the <u>finalize()</u> method
                     as last step of the import process.

              <b>import_block(block_name:</b> <b>str,</b> <b>rename=True)</b> <b>-&gt;</b> <b>str</b>
                     Import one BLOCK definition from source document.

                     If the BLOCK already exist the BLOCK will be renamed if argument <u>rename</u> is <b>True</b>,  otherwise
                     the  existing  BLOCK in the target document will be used instead of the BLOCK in the source
                     document.  Required name resolving for imported block references (INSERT), will be done  in
                     the <u>Importer.finalize()</u> method.

                     To  replace an existing BLOCK in the target document, just delete it before importing data:
                     <b>target.blocks.delete_block(block_name,</b> <b>safe=False)</b>

                     <b>Parameters</b>

                            • <b>block_name</b> – name of BLOCK to import

                            • <b>rename</b> – rename BLOCK if a BLOCK with  the  same  name  already  exist  in  target
                              document

                     Returns: (renamed) BLOCK name

                     <b>Raises</b> <b>ValueError</b> – BLOCK in source document not found (defined)

              <b>import_blocks(block_names:</b> <b>Iterable[str],</b> <b>rename=False)</b> <b>-&gt;</b> <b>None</b>
                     Import all BLOCK definitions from source document.

                     If  a  BLOCK  already exist the BLOCK will be renamed if argument <u>rename</u> is <b>True</b>, otherwise
                     the existing BLOCK in the target document will be used instead of the BLOCK from the source
                     document.  Required name resolving for imported BLOCK references (INSERT), will be done  in
                     the <u>Importer.finalize()</u> method.

                     <b>Parameters</b>

                            • <b>block_names</b> – names of BLOCK definitions to import

                            • <b>rename</b>  –  rename  BLOCK  if  a  BLOCK  with the same name already exist in target
                              document

                     <b>Raises</b> <b>ValueError</b> – BLOCK in source document not found (defined)

              <b>import_entities(entities:</b> <b>Iterable[</b><u>DXFEntity</u><b>],</b> <b>target_layout:</b> <u>BaseLayout</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Import all <u>entities</u> into <u>target_layout</u>  or  the  modelspace  of  the  target  document,  if
                     <u>target_layout</u> is <b>None</b>.

                     <b>Parameters</b>

                            • <b>entities</b> – Iterable of DXF entities

                            • <b>target_layout</b>  –  any  layout  (modelspace,  paperspace  or block) from the target
                              document

                     <b>Raises</b> <u>DXFStructureError</u> – <u>target_layout</u> is not a layout of target document

              <b>import_entity(entity:</b> <u>DXFEntity</u><b>,</b> <b>target_layout:</b> <u>BaseLayout</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Imports a single DXF <u>entity</u> into <u>target_layout</u> or the modelspace of the target document, if
                     <u>target_layout</u> is <b>None</b>.

                     <b>Parameters</b>

                            • <b>entity</b> – DXF entity to import

                            • <b>target_layout</b> – any layout (modelspace,  paperspace  or  block)  from  the  target
                              document

                     <b>Raises</b> <u>DXFStructureError</u> – <u>target_layout</u> is not a layout of target document

              <b>import_modelspace(target_layout:</b> <u>BaseLayout</u> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Import  all  entities  from  source  modelspace into <u>target_layout</u> or the modelspace of the
                     target document, if <u>target_layout</u> is <b>None</b>.

                     <b>Parameters</b>
                            <b>target_layout</b> – any  layout  (modelspace,  paperspace  or  block)  from  the  target
                            document

                     <b>Raises</b> <u>DXFStructureError</u> – <u>target_layout</u> is not a layout of target document

              <b>import_paperspace_layout(name:</b> <b>str)</b> <b>-&gt;</b> <u>Layout</u>
                     Import paperspace layout <u>name</u> into the target document.

                     Recreates  the  source  paperspace  layout  in  the  target  document,  renames  the target
                     paperspace if a paperspace with same <u>name</u> already exist and imports all entities  from  the
                     source paperspace into the target paperspace.

                     <b>Parameters</b>
                            <b>name</b> – source paper space name as string

                     Returns: new created target paperspace <b>Layout</b>

                     <b>Raises</b>

                            • <b>KeyError</b> – source paperspace does not exist

                            • <u>DXFTypeError</u> – invalid modelspace import

              <b>import_paperspace_layouts()</b> <b>-&gt;</b> <b>None</b>
                     Import  all  paperspace layouts and their content into the target document.  Target layouts
                     will be renamed if a layout with the same name already exist. Layouts will be  imported  in
                     original tab order.

              <b>import_shape_files(fonts:</b> <b>set[str])</b> <b>-&gt;</b> <b>None</b>
                     Import  shape  file table entries from the source document into the target document.  Shape
                     file entries are stored in the styles table but without a name.

              <b>import_table(name:</b> <b>str,</b> <b>entries:</b> <b>str</b> <b>|</b> <b>Iterable[str]</b> <b>=</b> <b>'*',</b> <b>replace=False)</b> <b>-&gt;</b> <b>None</b>
                     Import specific table entries from the source document into the target document.

                     <b>Parameters</b>

                            • <b>name</b> – valid table names are “layers”, “linetypes” and “styles”

                            • <b>entries</b> – Iterable of table names as strings, or a single table name  or  “*”  for
                              all table entries

                            • <b>replace</b>  –  <b>True</b>  to replace the already existing table entry else ignore existing
                              entries

                     <b>Raises</b> <b>TypeError</b> – unsupported table type

              <b>import_tables(table_names:</b> <b>str</b> <b>|</b> <b>Iterable[str]</b> <b>=</b> <b>'*',</b> <b>replace=False)</b> <b>-&gt;</b> <b>None</b>
                     Import DXF tables from the source document into the target document.

                     <b>Parameters</b>

                            • <b>table_names</b> – iterable of tables names as strings,  or  a  single  table  name  as
                              string or “*” for all supported tables

                            • <b>replace</b>  –  <b>True</b>  to  replace  already existing table entries else ignore existing
                              entries

                     <b>Raises</b> <b>TypeError</b> – unsupported table type

              <b>recreate_source_layout(name:</b> <b>str)</b> <b>-&gt;</b> <u>Layout</u>
                     Recreate source paperspace layout <u>name</u> in the target document.  The layout will be  renamed
                     if  <u>name</u>  already  exist  in the target document. Returns target modelspace for layout name
                     “Model”.

                     <b>Parameters</b>
                            <b>name</b> – layout name as string

                     <b>Raises</b> <b>KeyError</b> – if source layout <u>name</u> not exist

   <b>dxf2code</b>
       Translate DXF entities and structures into Python source code.

       Short example:

          import ezdxf
          from ezdxf.addons.dxf2code import entities_to_code, block_to_code

          doc = ezdxf.readfile('original.dxf')
          msp = doc.modelspace()
          source = <a href="../manmsp/entities_to_code.msp.html">entities_to_code</a>(msp)

          # create source code for a block definition
          block_source = block_to_code(doc.blocks['MyBlock'])

          # merge source code objects
          source.merge(block_source)

          with open('source.py', mode='wt') as f:
              f.write(source.import_str())
              f.write('\n\n')
              f.write(source.code_str())
              f.write('\n')

       <b>ezdxf.addons.dxf2code.entities_to_code(entities:</b> <b>Iterable[</b><u>DXFEntity</u><b>],</b> <b>layout:</b> <b>str</b> <b>=</b> <b>'layout',</b> <b>ignore:</b>
       <b>Iterable[str]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>Code</u>
              Translates DXF entities into Python source code to recreate this entities by ezdxf.

              <b>Parameters</b>

                     • <b>entities</b> – iterable of DXFEntity

                     • <b>layout</b> – variable name of the layout (model space or block) as string

                     • <b>ignore</b> – iterable of entities types to ignore as strings like <b>['IMAGE',</b> <b>'DIMENSION']</b>

              <b>Returns</b>
                     <u>Code</u>

       <b>ezdxf.addons.dxf2code.block_to_code(block:</b> <u>BlockLayout</u><b>,</b> <b>drawing:</b> <b>str</b> <b>=</b> <b>'doc',</b> <b>ignore:</b> <b>Iterable[str]</b> <b>|</b>
       <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>Code</u>
              Translates a BLOCK into Python source code to recreate the BLOCK by ezdxf.

              <b>Parameters</b>

                     • <b>block</b> – block definition layout

                     • <b>drawing</b> – variable name of the drawing as string

                     • <b>ignore</b> – iterable of entities types to ignore as strings like [‘IMAGE’, ‘DIMENSION’]

              <b>Returns</b>
                     <u>Code</u>

       <b>ezdxf.addons.dxf2code.table_entries_to_code(entities:</b> <b>Iterable[</b><u>DXFEntity</u><b>],</b> <b>drawing='doc')</b> <b>-&gt;</b> <u>Code</u>

       <b>ezdxf.addons.dxf2code.black(code:</b> <b>str,</b> <b>line_length=88,</b> <b>fast:</b> <b>bool</b> <b>=</b> <b>True)</b> <b>-&gt;</b> <b>str</b>
              Returns the source <u>code</u> as a single string formatted by <u>Black</u>

              Requires the installed <u>Black</u> formatter:

                 pip3 install black

              <b>Parameters</b>

                     • <b>code</b> – source code

                     • <b>line_length</b> – max. source code line length

                     • <b>fast</b> – <b>True</b> for fast mode, <b>False</b> to check that the reformatted code is valid

              <b>Raises</b> <b>ImportError</b> – Black is not available

       <b>class</b> <b>ezdxf.addons.dxf2code.Code</b>
              Source code container.

              <b>code</b>   Source code line storage, store lines without line ending <b>\\n</b>

              <b>imports</b>
                     source code line storage for global imports, store lines without line ending <b>\\n</b>

              <b>layers</b> Layers used by the generated source code, AutoCAD accepts layer names without a LAYER table
                     entry.

              <b>linetypes</b>
                     Linetypes used by the generated source code, these  linetypes  require  a  TABLE  entry  or
                     AutoCAD will crash.

              <b>styles</b> Text  styles  used by the generated source code, these text styles require a TABLE entry or
                     AutoCAD will crash.

              <b>dimstyles</b>
                     Dimension styles  used by the generated source code, these dimension styles require a TABLE
                     entry or AutoCAD will crash.

              <b>blocks</b> Blocks used by the generated source code, these blocks require a BLOCK  definition  in  the
                     BLOCKS section or AutoCAD will crash.

              <b>code_str(indent:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>str</b>
                     Returns the source code as a single string.

                     <b>Parameters</b>
                            <b>indent</b> – source code indentation count by spaces

              <b>black_code_str(line_length=88)</b> <b>-&gt;</b> <b>str</b>
                     Returns the source code as a single string formatted by <u>Black</u>

                     <b>Parameters</b>
                            <b>line_length</b> – max. source code line length

                     <b>Raises</b> <b>ImportError</b> – Black is not available

              <b>import_str(indent:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>str</b>
                     Returns required imports as a single string.

                     <b>Parameters</b>
                            <b>indent</b> – source code indentation count by spaces

              <b>merge(code:</b> <u>Code</u><b>,</b> <b>indent:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>None</b>
                     Add another <u>Code</u> object.

              <b>add_import(statement:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Add import statement, identical import statements are merged together.

              <b>add_line(code:</b> <b>str,</b> <b>indent:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>None</b>
                     Add a single source code line without line ending <b>\n</b>.

              <b>add_lines(code:</b> <b>Iterable[str],</b> <b>indent:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>None</b>
                     Add multiple source code lines without line ending <b>\n</b>.

   <b>iterdxf</b>
       This add-on allows iterating over entities of the modelspace of really big (&gt; 5GB) DXF files which do not
       fit into memory by only loading one entity at the time. Only ASCII DXF files are supported.

       The  entities  are  regular <u>DXFGraphic</u> objects with access to all supported DXF attributes, this entities
       can be written to new DXF files created by the <u>IterDXF.export()</u>  method.   The  new  <u>add_foreign_entity()</u>
       method allows also to add this entities to new regular <u>ezdxf</u> drawings (except for the INSERT entity), but
       resources  like  linetype  and  style  are  removed,  only  layer will be preserved but only with default
       attributes like color <b>7</b> and linetype <b>CONTINUOUS</b>.

       The following example shows how to split a big DXF files into several separated DXF files which  contains
       only LINE, TEXT or POLYLINE entities.

          from ezdxf.addons import iterdxf

          doc = iterdxf.opendxf('big.dxf')
          line_exporter = doc.export('line.dxf')
          text_exporter = doc.export('text.dxf')
          polyline_exporter = doc.export('polyline.dxf')
          try:
              for entity in doc.modelspace():
                  if entity.dxftype() == 'LINE':
                      line_exporter.write(entity)
                  elif entity.dxftype() == 'TEXT':
                      text_exporter.write(entity)
                  elif entity.dxftype() == 'POLYLINE':
                      polyline_exporter.write(entity)
          finally:
              line_exporter.close()
              text_exporter.close()
              polyline_exporter.close()
              doc.close()

       Supported DXF types:

       3DFACE,  ARC,  ATTDEF,  ATTRIB,  CIRCLE,  DIMENSION,  ELLIPSE, HATCH, HELIX, IMAGE, INSERT, LEADER, LINE,
       LWPOLYLINE, MESH, MLEADER, MLINE, MTEXT, POINT, POLYLINE, RAY, SHAPE, SOLID, SPLINE, TEXT, TRACE, VERTEX,
       WIPEOUT, XLINE

       Transfer simple entities to another DXF document, this works for  some  supported  entities,  except  for
       entities  with  strong dependencies to the original document like INSERT look at <u>add_foreign_entity()</u> for
       all supported types:

          newdoc = ezdxf.new()
          msp = newdoc.modelspace()
          # line is an entity from a big source file
          msp.add_foreign_entity(line)
          # and so on ...
          msp.add_foreign_entity(lwpolyline)
          <a href="../manmesh/msp.add_foreign_entity.mesh.html">msp.add_foreign_entity</a>(mesh)
          msp.add_foreign_entity(polyface)

       Transfer MESH and POLYFACE (dxftype for POLYFACE and POLYMESH is  POLYLINE!)  entities  into  a  new  DXF
       document by the <b>MeshTransformer</b> class:

          from ezdxf.render import MeshTransformer

          # mesh is MESH from a big source file
          t = <a href="../manmesh/MeshTransformer.from_mesh.mesh.html">MeshTransformer.from_mesh</a>(mesh)
          # create a new MESH entity from MeshTransformer
          <a href="../manmsp/t.render.msp.html">t.render</a>(msp)

          # polyface is POLYFACE from a big source file
          t = MeshTransformer.from_polyface(polyface)
          # create a new POLYMESH entity from MeshTransformer
          <a href="../manmsp/t.render_polyface.msp.html">t.render_polyface</a>(msp)

       Another  way  to  import  entities from a big source file into new DXF documents is to split the big file
       into smaller parts and use the <u>Importer</u> add-on for a more safe entity import.

       <b>ezdxf.addons.iterdxf.opendxf(filename:</b> <b>Path</b> <b>|</b> <b>str,</b> <b>errors:</b> <b>str</b> <b>=</b> <b>'surrogateescape')</b> <b>-&gt;</b> <u>IterDXF</u>
              Open DXF file for iterating, be sure to open valid DXF files, no  DXF  structure  checks  will  be
              applied.

              Use this function to split up big DXF files as shown in the example above.

              <b>Parameters</b>

                     • <b>filename</b> – DXF filename of a seekable DXF file.

                     • <b>errors</b> –

                       specify decoding error handler

                       • ”surrogateescape” to preserve possible binary data (default)

                       • ”ignore” to use the replacement char U+FFFD “�” for invalid data

                       • ”strict” to raise an <b>UnicodeDecodeError</b> exception for invalid data

              <b>Raises</b>

                     • <u>DXFStructureError</u> – invalid or incomplete DXF file

                     • <b>UnicodeDecodeError</b> – if <u>errors</u> is “strict” and a decoding error occurs

       <b>ezdxf.addons.iterdxf.modelspace(filename:</b> <b>Path</b> <b>|</b> <b>str,</b> <b>types:</b> <b>Iterable[str]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>errors:</b> <b>str</b> <b>=</b>
       <b>'surrogateescape')</b> <b>-&gt;</b> <b>Iterable[DXFGraphic]</b>
              Iterate over all modelspace entities as <b>DXFGraphic</b> objects of a seekable file.

              Use  this  function to iterate “quick” over modelspace entities of a DXF file, filtering DXF types
              may speed up things if many entity types will be skipped.

              <b>Parameters</b>

                     • <b>filename</b> – filename of a seekable DXF file

                     • <b>types</b> – DXF types like <b>['LINE',</b> <b>'3DFACE']</b> which should  be  returned,  <b>None</b>  returns  all
                       supported types.

                     • <b>errors</b> –

                       specify decoding error handler

                       • ”surrogateescape” to preserve possible binary data (default)

                       • ”ignore” to use the replacement char U+FFFD “�” for invalid data

                       • ”strict” to raise an <b>UnicodeDecodeError</b> exception for invalid data

              <b>Raises</b>

                     • <u>DXFStructureError</u> – invalid or incomplete DXF file

                     • <b>UnicodeDecodeError</b> – if <u>errors</u> is “strict” and a decoding error occurs

       <b>ezdxf.addons.iterdxf.single_pass_modelspace(stream:</b> <b>BinaryIO,</b> <b>types:</b> <b>Iterable[str]</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>errors:</b>
       <b>str</b> <b>=</b> <b>'surrogateescape')</b> <b>-&gt;</b> <b>Iterable[DXFGraphic]</b>
              Iterate over all modelspace entities as <b>DXFGraphic</b> objects in a single pass.

              Use this function to ‘quick’ iterate over modelspace entities of a <b>not</b> seekable binary DXF stream,
              filtering DXF types may speed up things if many entity types will be skipped.

              <b>Parameters</b>

                     • <b>stream</b> – (not seekable) binary DXF stream

                     • <b>types</b>  –  DXF  types  like  <b>['LINE',</b> <b>'3DFACE']</b> which should be returned, <b>None</b> returns all
                       supported types.

                     • <b>errors</b> –

                       specify decoding error handler

                       • ”surrogateescape” to preserve possible binary data (default)

                       • ”ignore” to use the replacement char U+FFFD “�” for invalid data

                       • ”strict” to raise an <b>UnicodeDecodeError</b> exception for invalid data

              <b>Raises</b>

                     • <u>DXFStructureError</u> – Invalid or incomplete DXF file

                     • <b>UnicodeDecodeError</b> – if <u>errors</u> is “strict” and a decoding error occurs

       <b>class</b> <b>ezdxf.addons.iterdxf.IterDXF</b>

              <b>export(name:</b> <b>Path</b> <b>|</b> <b>str)</b> <b>-&gt;</b> <u>IterDXFWriter</u>
                     Returns a companion object to export parts from the source DXF file into another DXF  file,
                     the new file will have the same HEADER, CLASSES, TABLES, BLOCKS and OBJECTS sections, which
                     guarantees all necessary dependencies are present in the new file.

                     <b>Parameters</b>
                            <b>name</b> – filename, no special requirements

              <b>modelspace(types:</b> <b>Iterable[str]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>Iterable[DXFGraphic]</b>
                     Returns  an  iterator  for all supported DXF entities in the modelspace. These entities are
                     regular <u>DXFGraphic</u> objects but without a valid document assigned. It is <b>not</b> possible to add
                     these entities to other <u>ezdxf</u> documents.

                     It is only possible to recreate the objects by factory functions base on attributes of  the
                     source  entity.   For MESH, POLYMESH and POLYFACE it is possible to use the <u>MeshTransformer</u>
                     class to render (recreate) this objects as new entities in another document.

                     <b>Parameters</b>
                            <b>types</b> – DXF types like <b>['LINE',</b> <b>'3DFACE']</b> which should be returned, <b>None</b> returns all
                            supported types.

              <b>close()</b>
                     Safe closing source DXF file.

       <b>class</b> <b>ezdxf.addons.iterdxf.IterDXFWriter</b>

              <b>write(entity:</b> <b>DXFGraphic)</b>
                     Write a DXF entity from the source DXF file to the export file.

                     Don’t write entities from different documents than the source DXF  file,  dependencies  and
                     resources  will not match, maybe it will work once, but not in a reliable way for different
                     DXF documents.

              <b>close()</b>
                     Safe closing of exported DXF file. Copying of OBJECTS section happens only at  closing  the
                     file, without closing the new DXF file is invalid.

   <b>ODA</b> <b>File</b> <b>Converter</b> <b>Support</b>
       Use an installed <u>ODA</u> <u>File</u> <u>Converter</u> for converting between different versions of <u>.dwg</u>, <u>.dxb</u> and <u>.dxf</u>.

       <b>WARNING:</b>
          Execution  of  an  external  application  is  a  big  security  issue! Especially when the path to the
          executable can be altered.

          To avoid this problem delete the <b>ezdxf.addons.odafc.py</b> module.

   <b>Install</b> <b>ODA</b> <b>File</b> <b>Converter</b>
       The <u>ODA</u> <u>File</u> <u>Converter</u> has to be installed by the user, the application  is  available  for  Windows  XP,
       Windows 7 or later, Mac OS X, and Linux in 32/64-bit RPM and DEB format.

   <b>AppImage</b> <b>Support</b>
       The  option  “unix_exec_path”  defines  an  executable for Linux and macOS, this executable overrides the
       default command <b>ODAFileConverter</b>.  Assign an <b>absolute</b> path to the executable  to  that  key  and  if  the
       executable is not found the add-on falls back to the <b>ODAFileConverter</b> command.

       The  option  “unix_exec_path”  also  adds  support  for  AppImages  provided by the Open Design Alliance.
       Download the AppImage file and store it in a folder of your  choice  (e.g.  <b><a href="file:~/Apps">~/Apps</a></b>)  and  make  the  file
       executable:

          chmod a+x <a href="file:~/Apps/ODAFileConverter_QT5_lnxX64_8.3dll_23.9.AppImage">~/Apps/ODAFileConverter_QT5_lnxX64_8.3dll_23.9.AppImage</a>

       Add the <b>absolute</b> path as config option “unix_exec_path” to the “odafc-addon” section:

          [odafc-addon]
          win_exec_path = "C:\Program Files\ODA\ODAFileConverter\ODAFileConverter.exe"
          unix_exec_path = "<a href="file:/home/">/home/</a>&lt;your user name&gt;/Apps/ODAFileConverter_QT5_lnxX64_8.3dll_23.9.AppImage"

       This  overrides  the default command <b>ODAFileConverter</b> and if the executable is not found the add-on falls
       back to the <b>ODAFileConverter</b> command.

       <b>SEE</b> <b>ALSO:</b>
          For more information about config files see section: <u>Global</u> <u>Options</u> <u>Object</u>

   <b>Suppressed</b> <b>GUI</b>
       On Windows the GUI of the ODA File Converter is suppressed, on Linux you may have  to  install  the  <b>xvfb</b>
       package to prevent this, for macOS is no solution known.

   <b>Supported</b> <b>DXF</b> <b>and</b> <b>DWG</b> <b>Versions</b>
       ODA  File  Converter  version  strings,  you  can use any of this strings to specify a version, <b>'R..'</b> and
       <b>'AC....'</b> strings will be automatically mapped to <b>'ACAD....'</b> strings:
                                        ┌──────────┬───────────────┬─────────┐
                                        │ ODAFC    │ ezdxf         │ Version │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD9    │ not supported │ AC1004  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD10   │ not supported │ AC1006  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD12   │ R12           │ AC1009  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD13   │ R13           │ AC1012  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD14   │ R14           │ AC1014  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD2000 │ R2000         │ AC1015  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD2004 │ R2004         │ AC1018  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD2007 │ R2007         │ AC1021  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD2010 │ R2010         │ AC1024  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD2013 │ R2013         │ AC1027  │
                                        ├──────────┼───────────────┼─────────┤
                                        │ ACAD2018 │ R2018         │ AC1032  │
                                        └──────────┴───────────────┴─────────┘

   <b>Config</b>
       On Windows  the  path  to  the  <b>ODAFileConverter.exe</b>  executable  is  stored  in  the  config  file  (see
       <u>ezdxf.options</u>) in the “odafc-addon” section as key “win_exec_path”, the default entry is:

          [odafc-addon]
          win_exec_path = "C:\Program Files\ODA\ODAFileConverter\ODAFileConverter.exe"
          unix_exec_path =

       On  Linux  and  macOS  the  <b>ODAFileConverter</b> command is located by the <b>shutil.which()</b> function but can be
       overridden since version 1.0 by the key “linux_exec_path”.

   <b>Usage</b>
          from ezdxf.addons import odafc

          # Load a DWG file
          doc = odafc.readfile('my.dwg')

          # Use loaded document like any other ezdxf document
          print(f'Document loaded as DXF version: {doc.dxfversion}.')
          msp = doc.modelspace()
          ...

          # Export document as DWG file for AutoCAD R2018
          odafc.export_dwg(doc, 'my_R2018.dwg', version='R2018')

       <b>ezdxf.addons.odafc.win_exec_path</b>
              Path to installed <u>ODA</u> <u>File</u>  <u>Converter</u>  executable  on  Windows  systems,  default  is  <b>"C:\Program</b>
              <b>Files\ODA\ODAFileConverter\ODAFileConverter.exe"</b>.

       <b>ezdxf.addons.odafc.unix_exec_path</b>
              Absolute  path  to  a  Linux or macOS executable if set, otherwise an empty string and the default
              command <b>ODAFileConverter</b> is used.

       <b>ezdxf.addons.odafc.is_installed()</b> <b>-&gt;</b> <b>bool</b>
              Returns <b>True</b> if the ODAFileConverter is installed.

       <b>ezdxf.addons.odafc.readfile(filename:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>version:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>*,</b> <b>audit:</b> <b>bool</b> <b>=</b> <b>False)</b>
       <b>-&gt;</b> <u>Drawing</u> <b>|</b> <b>None</b>
              Uses an installed <u>ODA</u> <u>File</u> <u>Converter</u> to convert a DWG/DXB/DXF file into a temporary DXF  file  and
              load this file by <u>ezdxf</u>.

              <b>Parameters</b>

                     • <b>filename</b> – file to load by ODA File Converter

                     • <b>version</b>  –  load  file as specific DXF version, by default the same version as the source
                       file or if not detectable the latest by <u>ezdxf</u> supported version.

                     • <b>audit</b> – audit source file before loading

              <b>Raises</b>

                     • <b>FileNotFoundError</b> – source file not found

                     • <b>odafc.UnknownODAFCError</b> – conversion failed for unknown reasons

                     • <b>odafc.UnsupportedVersion</b> – invalid DWG version specified

                     • <b>odafc.UnsupportedFileFormat</b> – unsupported file extension

                     • <b>odafc.ODAFCNotInstalledError</b> – ODA File Converter not installed

       <b>ezdxf.addons.odafc.export_dwg(doc:</b> <u>Drawing</u><b>,</b> <b>filename:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>version:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>*,</b>
       <b>audit:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>replace:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <b>None</b>
              Uses an installed <u>ODA</u> <u>File</u> <u>Converter</u> to export the DXF document <u>doc</u> as a DWG file.

              A temporary DXF file will be created and converted to DWG by the ODA File Converter. If <u>version</u> is
              not specified the DXF version of the source document is used.

              <b>Parameters</b>

                     • <b>doc</b> – <u>ezdxf</u> DXF document as <b>Drawing</b> object

                     • <b>filename</b> – output DWG filename, the extension will be set to “.dwg”

                     • <b>version</b> – DWG version to export, by default the same version as the source document.

                     • <b>audit</b> – audit source file by ODA File Converter at exporting

                     • <b>replace</b> – replace existing DWG file if <b>True</b>

              <b>Raises</b>

                     • <b>FileExistsError</b> – target file already exists, and argument <u>replace</u> is
                           <b>False</b>

                     • <b>FileNotFoundError</b> – parent directory of target file does not exist

                     • <b>odafc.UnknownODAFCError</b> – exporting DWG failed for unknown reasons

                     • <b>odafc.ODAFCNotInstalledError</b> – ODA File Converter not installed

       <b>ezdxf.addons.odafc.convert(source:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>dest:</b> <b>str</b> <b>|</b> <b>PathLike</b> <b>=</b> <b>'',</b> <b>*,</b> <b>version='R2018',</b>
       <b>audit=True,</b> <b>replace=False)</b>
              Convert <u>source</u> file to <u>dest</u> file.

              The file extension defines the target format e.g.  <b>convert("test.dxf",</b>  <b>"Test.dwg")</b>  converts  the
              source  file  to a DWG file.  If <u>dest</u> is an empty string the conversion depends on the source file
              format and is DXF to DWG or DWG to DXF.  To convert DXF to DXF an explicit destination filename is
              required: <b>convert("r12.dxf",</b> <b>"r2013.dxf",</b> <b>version="R2013")</b>

              <b>Parameters</b>

                     • <b>source</b> – source file

                     • <b>dest</b> – destination file, an empty string uses the source filename with the  extension  of
                       the target format e.g. “test.dxf” -&gt; “test.dwg”

                     • <b>version</b> – output DXF/DWG version e.g. “ACAD2018”, “R2018”, “AC1032”

                     • <b>audit</b> – audit files

                     • <b>replace</b> – replace existing destination file

              <b>Raises</b>

                     • <b>FileNotFoundError</b> – source file or destination folder does not exist

                     • <b>FileExistsError</b> – destination file already exists and argument <u>replace</u>
                           is <b>False</b>

                     • <b>odafc.UnsupportedVersion</b> – invalid DXF version specified

                     • <b>odafc.UnsupportedFileFormat</b> – unsupported file extension

                     • <b>odafc.UnknownODAFCError</b> – conversion failed for unknown reasons

                     • <b>odafc.ODAFCNotInstalledError</b> – ODA File Converter not installed

   <b>R12</b> <b>Export</b>
       New in version 1.1.

       This  module  exports any DXF file as a simple DXF R12 file. Many complex entities will be converted into
       DXF primitives.  This exporter is intended for creating a simple file format as an input format for other
       software such as laser cutters. In order to get a file that can be edited well in a CAD application,  the
       results of the ODA file converter are much better.

   <b>Usage</b>
          import ezdxf
          from ezdxf.addons import r12export

          doc = ezdxf.readfile("any.dxf")
          r12export.saveas(doc, "r12.dxf")

   <b>Converted</b> <b>Entity</b> <b>Types</b>
                               ┌─────────────┬───────────────────────────────────────┐
                               │ LWPOLYLINE  │ translated to POLYLINE                │
                               ├─────────────┼───────────────────────────────────────┤
                               │ MESH        │ translated to POLYLINE (PolyfaceMesh) │
                               ├─────────────┼───────────────────────────────────────┤
                               │ SPLINE      │ flattened to POLYLINE                 │
                               ├─────────────┼───────────────────────────────────────┤
                               │ ELLIPSE     │ flattened to POLYLINE                 │
                               ├─────────────┼───────────────────────────────────────┤
                               │ MTEXT       │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ LEADER      │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ MLEADER     │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ MULTILEADER │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ MLINE       │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ HATCH       │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ MPOLYGON    │ exploded into DXF primitives          │
                               ├─────────────┼───────────────────────────────────────┤
                               │ ACAD_TABLE  │ export of pre-rendered BLOCK content  │
                               └─────────────┴───────────────────────────────────────┘

       For proxy- or unknown entities the available proxy graphic will be exported as DXF primitives.

   <b>Limitations</b>
       • Explosion of MTEXT into DXF primitives is not perfect

       • Pattern rendering for complex HATCH entities has issues

       • Solid fill rendering for complex HATCH entities has issues

   <b>ODA</b> <b>File</b> <b>Converter</b>
       The  advantage  of  the  <u>r12export</u>  module  is that the ODA file converter isn’t needed, but the ODA file
       converter will produce a much better result:

          from ezdxf.addons import odafc

          odafc.convert("any.dxf", "r12.dxf", version="R12")

   <b>Functions</b>
                                 ┌─────────┬───────────────────────────────────────┐
                                 │ <u>write</u>   │ Write a DXF document as  DXF  version │
                                 │         │ R12 to a text stream.                 │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <u>saveas</u>  │ Write  a  DXF document as DXF version │
                                 │         │ R12 to a file.                        │
                                 ├─────────┼───────────────────────────────────────┤
                                 │ <u>convert</u> │ Export and reload DXF document as DXF │
                                 │         │ version R12.                          │
                                 └─────────┴───────────────────────────────────────┘

       <b>ezdxf.addons.r12export.write(doc:</b> <u>Drawing</u><b>,</b> <b>stream:</b> <b>TextIO,</b> <b>*,</b> <b>max_sagitta:</b> <b>float</b> <b>=</b> <b>MAX_SAGITTA)</b> <b>-&gt;</b> <b>None</b>
              Write a DXF document as DXF version R12 to a text stream. The <u>max_sagitta</u> argument determines  the
              accuracy of the curve flatting for SPLINE and ELLIPSE entities.

              <b>Parameters</b>

                     • <b>doc</b> – DXF document to export

                     • <b>stream</b> – output stream, use <b>doc.encoding</b> as encoding

                     • <b>max_sagitta</b>  –  maximum  distance  from the center of the curve to the center of the line
                       segment between two approximation points to determine if a segment should be subdivided.

       <b>ezdxf.addons.r12export.saveas(doc:</b> <u>Drawing</u><b>,</b> <b>filepath:</b> <b>str</b> <b>|</b> <b>PathLike,</b> <b>*,</b> <b>max_sagitta:</b> <b>float</b> <b>=</b>
       <b>MAX_SAGITTA)</b> <b>-&gt;</b> <b>None</b>
              Write a DXF document as DXF version R12  to  a  file.  The  <u>max_sagitta</u>  argument  determines  the
              accuracy of the curve flatting for SPLINE and ELLIPSE entities.

              <b>Parameters</b>

                     • <b>doc</b> – DXF document to export

                     • <b>filepath</b> – output filename

                     • <b>max_sagitta</b>  –  maximum  distance  from the center of the curve to the center of the line
                       segment between two approximation points to determine if a segment should be subdivided.

       <b>ezdxf.addons.r12export.convert(doc:</b> <u>Drawing</u><b>,</b> <b>*,</b> <b>max_sagitta:</b> <b>float</b> <b>=</b> <b>MAX_SAGITTA)</b> <b>-&gt;</b> <u>Drawing</u>
              Export and reload DXF document as DXF version R12.

              Writes the DXF document into a temporary file at the file-system and  reloads  this  file  by  the
              <u>ezdxf.readfile()</u> function.

   <b>r12writer</b>
       The  fast  file/stream  writer creates simple DXF R12 drawings with just an ENTITIES section. The HEADER,
       TABLES and BLOCKS sections are not present except FIXED-TABLES are written. Only LINE, CIRCLE, ARC, TEXT,
       POINT, SOLID, 3DFACE and POLYLINE entities are supported. FIXED-TABLES is a  predefined  TABLES  section,
       which will be written, if the init argument <u>fixed_tables</u> of <u>R12FastStreamWriter</u> is <b>True</b>.

       The  <u>R12FastStreamWriter</u>  writes  the  DXF  entities  as strings direct to the stream without creating an
       in-memory drawing and therefore the processing is very fast.

       Because of the lack of a BLOCKS section, BLOCK/INSERT can not be used.  Layers  can  be  used,  but  this
       layers  have  a  default  setting  color  =  <b>7</b>  (black/white) and linetype = <b>'Continuous'</b>. If writing the
       FIXED-TABLES, some predefined text styles and line  types  are  available,  else  text  style  is  always
       <b>'STANDARD'</b> and line type is always <b>'ByLayer'</b>.

       If using FIXED-TABLES, following predefined line types are available:

       • CONTINUOUS

       • CENTER <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b>

       • CENTERX2 <b>________</b>  <b>__</b>  <b>________</b>  <b>__</b>  <b>________</b>

       • CENTER2 <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b> <b>_</b> <b>____</b>

       • DASHED <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>__</b> <b>_</b>

       • DASHEDX2 <b>____</b>  <b>____</b>  <b>____</b>  <b>____</b>  <b>____</b>  <b>____</b>

       • DASHED2 <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b> <b>_</b>

       • PHANTOM <b>______</b>  <b>__</b>  <b>__</b>  <b>______</b>  <b>__</b>  <b>__</b>  <b>______</b>

       • PHANTOMX2 <b>____________</b>    <b>____</b>    <b>____</b>    <b>____________</b>

       • PHANTOM2 <b>___</b> <b>_</b> <b>_</b> <b>___</b> <b>_</b> <b>_</b> <b>___</b> <b>_</b> <b>_</b> <b>___</b> <b>_</b> <b>_</b> <b>___</b>

       • DASHDOT <b>__</b> <b>.</b> <b>__</b> <b>.</b> <b>__</b> <b>.</b> <b>__</b> <b>.</b> <b>__</b> <b>.</b> <b>__</b> <b>.</b> <b>__</b> <b>.</b> <b>__</b>

       • DASHDOTX2 <b>____</b>  <b>.</b>  <b>____</b>  <b>.</b>  <b>____</b>  <b>.</b>  <b>____</b>

       • DASHDOT2 <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b>

       • DOT <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>  <b>.</b>

       • DOTX2 <b>.</b>    <b>.</b>    <b>.</b>    <b>.</b>    <b>.</b>    <b>.</b>    <b>.</b>    <b>.</b>

       • DOT2 <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b> <b>.</b>

       • DIVIDE <b>__</b> <b>.</b> <b>.</b> <b>__</b> <b>.</b> <b>.</b> <b>__</b> <b>.</b> <b>.</b> <b>__</b> <b>.</b> <b>.</b> <b>__</b> <b>.</b> <b>.</b> <b>__</b>

       • DIVIDEX2 <b>____</b>  <b>.</b> <b>.</b>  <b>____</b>  <b>.</b> <b>.</b>  <b>____</b>  <b>.</b> <b>.</b>  <b>____</b>

       • DIVIDE2 <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b> <b>.</b> <b>_</b>

       If using FIXED-TABLES, following predefined text styles are available:

       • OpenSans

       • OpenSansCondensed-Light

   <b>Tutorial</b>
       A simple example with different DXF entities:

          from random import random
          from ezdxf.addons import r12writer

          with r12writer("quick_and_dirty_dxf_r12.dxf") as dxf:
              dxf.add_line((0, 0), (17, 23))
              dxf.add_circle((0, 0), radius=2)
              dxf.add_arc((0, 0), radius=3, start=0, end=175)
              dxf.add_solid([(0, 0), (1, 0), (0, 1), (1, 1)])
              dxf.add_point((1.5, 1.5))

              # 2d polyline, new in v0.12
              dxf.add_polyline_2d([(5, 5), (7, 3), (7, 6)])

              # 2d polyline with bulge value, new in v0.12
              dxf.add_polyline_2d([(5, 5), (7, 3, 0.5), (7, 6)], format='xyb')

              # 3d polyline only, changed in v0.12
              dxf.add_polyline([(4, 3, 2), (8, 5, 0), (2, 4, 9)])

              dxf.add_text("test the text entity", align="MIDDLE_CENTER")

       A simple example of writing really many entities in a short time:

          from random import random
          from ezdxf.addons import r12writer

          MAX_X_COORD = 1000.0
          MAX_Y_COORD = 1000.0
          CIRCLE_COUNT = 1000000

          with r12writer("many_circles.dxf") as dxf:
              for i in range(CIRCLE_COUNT):
                  dxf.add_circle((MAX_X_COORD*random(), MAX_Y_COORD*random()), radius=2)

       Show all available line types:

          import ezdxf

          LINETYPES = [
              'CONTINUOUS', 'CENTER', 'CENTERX2', 'CENTER2',
              'DASHED', 'DASHEDX2', 'DASHED2', 'PHANTOM', 'PHANTOMX2',
              'PHANTOM2', 'DASHDOT', 'DASHDOTX2', 'DASHDOT2', 'DOT',
              'DOTX2', 'DOT2', 'DIVIDE', 'DIVIDEX2', 'DIVIDE2',
          ]

          with r12writer('r12_linetypes.dxf', fixed_tables=True) as dxf:
              for n, ltype in enumerate(LINETYPES):
                  dxf.add_line((0, n), (10, n), linetype=ltype)
                  dxf.add_text(ltype, (0, n+0.1), height=0.25, style='OpenSansCondensed-Light')

   <b>Reference</b>
       <b>ezdxf.addons.r12writer.r12writer(stream:</b> <b>TextIO</b> <b>|</b> <b>BinaryIO</b> <b>|</b> <b>str,</b> <b>fixed_tables=False,</b> <b>fmt='asc')</b> <b>-&gt;</b>
       <u>R12FastStreamWriter</u>
              Context manager for writing DXF entities to a stream/file. <u>stream</u> can be any file like object with
              a  <b>write()</b> method or just a string for writing DXF entities to the file system. If <u>fixed_tables</u> is
              <b>True</b>, a standard TABLES section is written in front of the ENTITIES section  and  some  predefined
              text styles and line types can be used.

              Set  argument  <u>fmt</u>  to “asc” to write ASCII DXF file (default) or “bin” to write Binary DXF files.
              ASCII DXF require a <b>TextIO</b> stream and Binary DXF require a <b>BinaryIO</b> stream.

       <b>class</b> <b>ezdxf.addons.r12writer.R12FastStreamWriter(stream:</b> <b>TextIO,</b> <b>fixed_tables=False)</b>
              Fast stream writer to create simple DXF R12 drawings.

              <b>Parameters</b>

                     • <b>stream</b> – a file like object with a <b>write()</b> method.

                     • <b>fixed_tables</b> – if <u>fixed_tables</u> is <b>True</b>, a standard TABLES section is written in front  of
                       the ENTITIES section and some predefined text styles and line types can be used.

              <b>close()</b> <b>-&gt;</b> <b>None</b>
                     Writes the DXF tail. Call is not necessary when using the context manager <u>r12writer()</u>.

              <b>add_line(start:</b> <b>Sequence[float],</b> <b>end:</b> <b>Sequence[float],</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b>
              <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a LINE entity from <u>start</u> to <u>end</u>.

                     <b>Parameters</b>

                            • <b>start</b> – start vertex as <b>(x,</b> <b>y[,</b> <b>z])</b> tuple

                            • <b>end</b> – end vertex as  as <b>(x,</b> <b>y[,</b> <b>z])</b> tuple

                            • <b>layer</b>  –  layer  name as string, without a layer definition the assigned color = <b>7</b>
                              (black/white) and line type is <b>'Continuous'</b>.

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> in the  range  from  <b>0</b>  to  <b>256</b>,  <b>0</b>  is
                              <u>ByBlock</u>  and  <b>256</b>  is  <u>ByLayer</u>,  default  is  <u>ByLayer</u>  which  is  always color = <b>7</b>
                              (black/white) without a layer definition.

                            • <b>linetype</b> – line type as string, if FIXED-TABLES are written some  predefined  line
                              types   are  available,  else  line  type  is  always  <u>ByLayer</u>,  which  is  always
                              <b>'Continuous'</b> without a LAYERS table.

              <b>add_circle(center:</b> <b>Sequence[float],</b> <b>radius:</b> <b>float,</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b>
              <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a CIRCLE entity.

                     <b>Parameters</b>

                            • <b>center</b> – circle center point as <b>(x,</b> <b>y)</b> tuple

                            • <b>radius</b> – circle radius as float

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_arc(center:</b> <b>Sequence[float],</b> <b>radius:</b> <b>float,</b> <b>start:</b> <b>float</b> <b>=</b> <b>0,</b> <b>end:</b> <b>float</b> <b>=</b> <b>360,</b> <b>layer:</b> <b>str</b> <b>=</b>
              <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add an ARC entity. The arc goes counter-clockwise from <u>start</u> angle to <u>end</u> angle.

                     <b>Parameters</b>

                            • <b>center</b> – arc center point as <b>(x,</b> <b>y)</b> tuple

                            • <b>radius</b> – arc radius as float

                            • <b>start</b> – arc start angle in degrees as float

                            • <b>end</b> – arc end angle in degrees as float

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_point(location:</b> <b>Sequence[float],</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b>
              <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a POINT entity.

                     <b>Parameters</b>

                            • <b>location</b> – point location as <b>(x,</b> <b>y</b> <b>[,z])</b> tuple

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_3dface(vertices:</b> <b>Iterable[Sequence[float]],</b> <b>invisible:</b> <b>int</b> <b>=</b> <b>0,</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b>
              <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a 3DFACE entity. 3DFACE is a spatial area with 3 or 4 vertices, all vertices have to be
                     in the same plane.

                     <b>Parameters</b>

                            • <b>vertices</b> – iterable of 3 or 4 <b>(x,</b> <b>y,</b> <b>z)</b> vertices.

                            • <b>invisible</b> –

                              bit coded flag to define the invisible edges,

                              1. edge = 1

                              2. edge = 2

                              3. edge = 4

                              4. edge = 8

                              Add edge values to set multiple edges invisible, 1. edge + 3. edge = 1 +  4  =  5,
                              all edges = 15

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_solid(vertices:</b> <b>Iterable[Sequence[float]],</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b>
              <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add  a  SOLID  entity.  SOLID  is  a  solid filled area with 3 or 4 edges and SOLID is a 2D
                     entity.

                     <b>Parameters</b>

                            • <b>vertices</b> – iterable of 3 or 4 <b>(x,</b> <b>y[,</b> <b>z])</b> tuples, z-axis will be ignored.

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_polyline_2d(points:</b> <b>Iterable[Sequence],</b> <b>format:</b> <b>str</b> <b>=</b> <b>'xy',</b> <b>closed:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>start_width:</b>
              <b>float</b> <b>=</b> <b>0,</b> <b>end_width:</b> <b>float</b> <b>=</b> <b>0,</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b>
              <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a 2D POLYLINE entity with start width, end width and bulge value support.

                     Format codes:
                                              ┌───┬──────────────────────────────────┐
                                              │ x │ x-coordinate                     │
                                              ├───┼──────────────────────────────────┤
                                              │ y │ y-coordinate                     │
                                              ├───┼──────────────────────────────────┤
                                              │ s │ start width                      │
                                              ├───┼──────────────────────────────────┤
                                              │ e │ end width                        │
                                              ├───┼──────────────────────────────────┤
                                              │ b │ bulge value                      │
                                              ├───┼──────────────────────────────────┤
                                              │ v │ (x, y) tuple (z-axis is ignored) │
                                              └───┴──────────────────────────────────┘

                     <b>Parameters</b>

                            • <b>points</b> – iterable of (x, y,  [start_width,  [end_width,  [bulge]]])  tuple,  value
                              order according to the <u>format</u> string, unset values default to <b>0</b>

                            • <b>format</b> – format: format string, default is <b>'xy'</b>

                            • <b>closed</b> – <b>True</b> creates a closed polyline

                            • <b>start_width</b> – default start width, default is <b>0</b>

                            • <b>end_width</b> – default end width, default is <b>0</b>

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_polyline(vertices:</b> <b>Iterable[Sequence[float]],</b> <b>closed:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b>
              <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a 3D POLYLINE entity.

                     <b>Parameters</b>

                            • <b>vertices</b> – iterable of <b>(x,</b> <b>y[,</b> <b>z])</b> tuples, z-axis is <b>0</b> by default

                            • <b>closed</b> – <b>True</b> creates a closed polyline

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_polyface(vertices:</b> <b>Iterable[Sequence[float]],</b> <b>faces:</b> <b>Iterable[Sequence[int]],</b> <b>layer:</b> <b>str</b> <b>=</b>
              <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add  a POLYFACE entity. The POLYFACE entity supports only faces of maximum 4 vertices, more
                     indices will be ignored. A simple square would be:

                        v0 = (0, 0, 0)
                        v1 = (1, 0, 0)
                        v2 = (1, 1, 0)
                        v3 = (0, 1, 0)
                        dxf.add_polyface(vertices=[v0, v1, v2, v3], faces=[(0, 1, 2, 3)])

                     All 3D form functions of the <u>ezdxf.render.forms</u> module return  <u>MeshBuilder</u>  objects,  which
                     provide the required vertex and face lists.

                     See sphere example: <u>https://github.com/mozman/ezdxf/blob/master/examples/r12writer.py</u>

                     <b>Parameters</b>

                            • <b>vertices</b> – iterable of <b>(x,</b> <b>y,</b> <b>z)</b> tuples

                            • <b>faces</b> – iterable of 3 or 4 vertex indices, indices have to be 0-based

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_polymesh(vertices:</b> <b>Iterable[Sequence[float]],</b> <b>size:</b> <b>tuple[int,</b> <b>int],</b> <b>closed=(False,</b> <b>False),</b>
              <b>layer:</b> <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>linetype:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add  a  POLYMESH entity. A POLYMESH is a mesh of m rows and n columns, each mesh vertex has
                     its own x-, y- and z coordinates. The mesh can be closed  in  m-  and/or  n-direction.  The
                     vertices  have  to  be  in column order:  (m0, n0), (m0, n1), (m0, n2), (m1, n0), (m1, n1),
                     (m1, n2), …

                     See example: <u>https://github.com/mozman/ezdxf/blob/master/examples/r12writer.py</u>

                     <b>Parameters</b>

                            • <b>vertices</b> – iterable of <b>(x,</b> <b>y,</b> <b>z)</b> tuples, in column order

                            • <b>size</b> – mesh dimension as (m, n)-tuple, requirement: <b>len(vertices)</b> <b>==</b> <b>m*n</b>

                            • <b>closed</b> – (m_closed, n_closed) tuple, for closed mesh in m and/or n direction

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>

                            • <b>linetype</b> – line type as string see <u>add_line()</u>

              <b>add_text(text:</b> <b>str,</b> <b>insert:</b> <b>Sequence[float]</b> <b>=</b> <b>(0,</b> <b>0),</b> <b>height:</b> <b>float</b> <b>=</b> <b>1.0,</b> <b>width:</b> <b>float</b> <b>=</b> <b>1.0,</b>
              <b>align:</b> <b>str</b> <b>=</b> <b>'LEFT',</b> <b>rotation:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>oblique:</b> <b>float</b> <b>=</b> <b>0.0,</b> <b>style:</b> <b>str</b> <b>=</b> <b>'STANDARD',</b> <b>layer:</b>
              <b>str</b> <b>=</b> <b>'0',</b> <b>color:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Add a one line TEXT entity.

                     <b>Parameters</b>

                            • <b>text</b> – the text as string

                            • <b>insert</b> – insert location as <b>(x,</b> <b>y)</b> tuple

                            • <b>height</b> – text height in drawing units

                            • <b>width</b> – text width as factor

                            • <b>align</b> – text alignment, see table below

                            • <b>rotation</b> – text rotation in degrees as float

                            • <b>oblique</b> – oblique in degrees as float, vertical = <b>0</b> (default)

                            • <b>style</b> – text style name as string, if FIXED-TABLES  are  written  some  predefined
                              text styles are available, else text style is always <b>'STANDARD'</b>.

                            • <b>layer</b> – layer name as string see <u>add_line()</u>

                            • <b>color</b> – color as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> see <u>add_line()</u>
                                    ┌────────────┬─────────────┬───────────────┬──────────────┐
                                    │ Vert/Horiz │ Left        │ Center        │ Right        │
                                    ├────────────┼─────────────┼───────────────┼──────────────┤
                                    │ Top        │ <b>TOP_LEFT</b>    │ <b>TOP_CENTER</b>    │ <b>TOP_RIGHT</b>    │
                                    ├────────────┼─────────────┼───────────────┼──────────────┤
                                    │ Middle     │ <b>MIDDLE_LEFT</b> │ <b>MIDDLE_CENTER</b> │ <b>MIDDLE_RIGHT</b> │
                                    ├────────────┼─────────────┼───────────────┼──────────────┤
                                    │ Bottom     │ <b>BOTTOM_LEFT</b> │ <b>BOTTOM_CENTER</b> │ <b>BOTTOM_RIGHT</b> │
                                    ├────────────┼─────────────┼───────────────┼──────────────┤
                                    │ Baseline   │ <b>LEFT</b>        │ <b>CENTER</b>        │ <b>RIGHT</b>        │
                                    └────────────┴─────────────┴───────────────┴──────────────┘

                     The special alignments <b>ALIGNED</b> and <b>FIT</b> are not available.

   <b>text2path</b>
       Tools  to  convert  text  strings  and text based DXF entities into outer- and inner linear paths as <u>Path</u>
       objects. At the moment only the TEXT and the ATTRIB entity can be converted into paths and hatches.

       New in version 1.1: Text rendering is done by the <u>fontTools</u> package, which is a hard dependency of <u>ezdxf</u>.
       Support for stroke fonts, these are the basic vector fonts included in CAD applications, like .shx,  .shp
       or .lff fonts was added but these fonts cannot be rendered as HATCH entities.

       The  required  font  files  are  not  included  with <u>ezdxf</u> as they are copyrighted or, in the case of the
       LibreCAD font format, licensed under the “GPL v2 and later”.  Set the paths to such stroke fonts  in  the
       config file, see option <u>ezdxf.options.support_dirs</u>:

          [core]
          support_dirs =
              "C:\Program Files\Bricsys\BricsCAD V23 en_US\Fonts",
              <a href="file:~/shx_fonts">~/shx_fonts</a>,
              <a href="file:~/shp_fonts">~/shp_fonts</a>,
              <a href="file:~/lff_fonts">~/lff_fonts</a>,

       Don’t expect a 100% match compared to CAD applications but the results with <u>fontTools</u> are better than the
       previous <u>Matplotlib</u> renderings.

   <b>Text</b> <b>Alignments</b>
       The text alignments are enums of type <u>ezdxf.enums.TextEntityAlignment</u>
                              ┌──────────┬─────────────┬───────────────┬──────────────┐
                              │ Vertical │ Left        │ Center        │ Right        │
                              ├──────────┼─────────────┼───────────────┼──────────────┤
                              │ Top      │ TOP_LEFT    │ TOP_CENTER    │ TOP_RIGHT    │
                              ├──────────┼─────────────┼───────────────┼──────────────┤
                              │ Middle   │ MIDDLE_LEFT │ MIDDLE_CENTER │ MIDDLE_RIGHT │
                              ├──────────┼─────────────┼───────────────┼──────────────┤
                              │ Bottom   │ BOTTOM_LEFT │ BOTTOM_CENTER │ BOTTOM_RIGHT │
                              ├──────────┼─────────────┼───────────────┼──────────────┤
                              │ Baseline │ LEFT        │ CENTER        │ RIGHT        │
                              └──────────┴─────────────┴───────────────┴──────────────┘

       The  vertical  middle  alignments (MIDDLE_XXX), center the text vertically in the middle of the uppercase
       letter “X” (cap height).

       Special alignments, where the horizontal alignment is always in the center of the text:

       • ALIGNED: text is scaled to match the given <u>length</u>, scales x- and y-direction by the same factor.

       • FIT: text is scaled to match the given <u>length</u>, but scales only in x-direction.

       • MIDDLE: insertion point is the center of the total height  (cap  height  +  descender  height)  without
         scaling, the <u>length</u> argument is ignored.

   <b>Font</b> <b>Face</b> <b>Definition</b>
       A  font  face  is  defined  by  the  Matplotlib  compatible  <b>FontFace</b>  object by <b>font-family</b>, <b>font-style</b>,
       <b>font-stretch</b> and <b>font-weight</b>.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Font</u> <u>Anatomy</u>

          • <u>Font</u> <u>Properties</u>

   <b>String</b> <b>Functions</b>
       <b>ezdxf.addons.text2path.make_path_from_str(s:</b> <b>str,</b> <b>font:</b> <u>FontFace</u><b>,</b> <b>size:</b> <b>float</b> <b>=</b> <b>1.0,</b>
       <b>align=TextEntityAlignment.LEFT,</b> <b>length:</b> <b>float</b> <b>=</b> <b>0,</b> <b>m:</b> <u>Matrix44</u> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>Path</b>
              Convert a single line string <u>s</u> into a <u>Multi-Path</u> object.  The text  <u>size</u>  is  the  height  of  the
              uppercase  letter  “X”  (cap  height).  The paths are aligned about the insertion point at (0, 0).
              BASELINE means the bottom of the letter “X”.

              <b>Parameters</b>

                     • <b>s</b> – text to convert

                     • <b>font</b> – font face definition as <b>FontFace</b> object

                     • <b>size</b> – text size (cap height) in drawing units

                     • <b>align</b> – alignment as <u>ezdxf.enums.TextEntityAlignment</u>, default is <b>LEFT</b>

                     • <b>length</b> – target length for the <b>ALIGNED</b> and <b>FIT</b> alignments

                     • <b>m</b> – transformation <u>Matrix44</u>

       <b>ezdxf.addons.text2path.make_paths_from_str(s:</b> <b>str,</b> <b>font:</b> <u>FontFace</u><b>,</b> <b>size:</b> <b>float</b> <b>=</b> <b>1.0,</b>
       <b>align=TextEntityAlignment.LEFT,</b> <b>length:</b> <b>float</b> <b>=</b> <b>0,</b> <b>m:</b> <u>Matrix44</u> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>list[Path]</b>
              Convert a single line string <u>s</u> into a list of <u>Path</u> objects. All paths are returned as  a  list  of
              <u>Single-Path</u>  objects.   The text <u>size</u> is the height of the uppercase letter “X” (cap height).  The
              paths are aligned about the insertion point at (0, 0).  BASELINE means the bottom  of  the  letter
              “X”.

              <b>Parameters</b>

                     • <b>s</b> – text to convert

                     • <b>font</b> – font face definition as <b>FontFace</b> object

                     • <b>size</b> – text size (cap height) in drawing units

                     • <b>align</b> – alignment as <u>ezdxf.enums.TextEntityAlignment</u>, default is <b>LEFT</b>

                     • <b>length</b> – target length for the <b>ALIGNED</b> and <b>FIT</b> alignments

                     • <b>m</b> – transformation <u>Matrix44</u>

       <b>ezdxf.addons.text2path.make_hatches_from_str(s:</b> <b>str,</b> <b>font:</b> <u>FontFace</u><b>,</b> <b>size:</b> <b>float</b> <b>=</b> <b>1.0,</b>
       <b>align=TextEntityAlignment.LEFT,</b> <b>length:</b> <b>float</b> <b>=</b> <b>0,</b> <b>dxfattribs=None,</b> <b>m:</b> <u>Matrix44</u> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>list[Hatch]</b>
              Convert a single line string <u>s</u> into a list of virtual <u>Hatch</u> entities.  The text <u>size</u> is the height
              of  the uppercase letter “X” (cap height).  The paths are aligned about the insertion point at (0,
              0).  The HATCH entities are aligned to this insertion point. BASELINE  means  the  bottom  of  the
              letter “X”.

              <b>IMPORTANT:</b>
                 Returns an empty list for .shx, .shp and .lff fonts a.k.a. stroke fonts.

              <b>Parameters</b>

                     • <b>s</b> – text to convert

                     • <b>font</b> – font face definition as <b>FontFace</b> object

                     • <b>size</b> – text size (cap height) in drawing units

                     • <b>align</b> – alignment as <u>ezdxf.enums.TextEntityAlignment</u>, default is <b>LEFT</b>

                     • <b>length</b> – target length for the <b>ALIGNED</b> and <b>FIT</b> alignments

                     • <b>dxfattribs</b> – additional DXF attributes

                     • <b>m</b> – transformation <u>Matrix44</u>

   <b>Entity</b> <b>Functions</b>
       <b>class</b> <b>ezdxf.addons.text2path.Kind(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b> <b>start=1,</b>
       <b>boundary=None)</b>
              The <u>Kind</u> enum defines the DXF types to create as bit flags, e.g. 1+2 to get HATCHES as filling and
              SPLINES and POLYLINES as outline:
                                    ┌─────┬─────────────┬──────────────────────────────┐
                                    │ Int │ Enum        │ Description                  │
                                    ├─────┼─────────────┼──────────────────────────────┤
                                    │ 1   │ HATCHES     │ <u>Hatch</u> entities as filling    │
                                    ├─────┼─────────────┼──────────────────────────────┤
                                    │ 2   │ SPLINES     │ <u>Spline</u>   and   3D   <u>Polyline</u> │
                                    │     │             │ entities as outline          │
                                    ├─────┼─────────────┼──────────────────────────────┤
                                    │ 4   │ LWPOLYLINES │ <u>LWPolyline</u>    entities    as │
                                    │     │             │ approximated     (flattened) │
                                    │     │             │ outline                      │
                                    └─────┴─────────────┴──────────────────────────────┘

       <b>ezdxf.addons.text2path.virtual_entities(entity:</b> <b>Text</b> <b>|</b> <b>Attrib,</b> <b>kind:</b> <b>int</b> <b>=</b> <b>Kind.HATCHES)</b> <b>-&gt;</b> <u>EntityQuery</u>
              Convert the text content of DXF entities TEXT and ATTRIB  into  virtual  SPLINE  and  3D  POLYLINE
              entities or approximated LWPOLYLINE entities as outlines, or as HATCH entities as fillings.

              Returns the virtual DXF entities as an <u>EntityQuery</u> object.

              <b>Parameters</b>

                     • <b>entity</b> – TEXT or ATTRIB entity

                     • <b>kind</b> – kind of entities to create as bit flags, see enum <u>Kind</u>

       <b>ezdxf.addons.text2path.explode(entity:</b> <b>Text</b> <b>|</b> <b>Attrib,</b> <b>kind:</b> <b>int</b> <b>=</b> <b>Kind.HATCHES,</b> <b>target=None)</b> <b>-&gt;</b>
       <u>EntityQuery</u>
              Explode  the  text <u>entity</u> into virtual entities, see <u>virtual_entities()</u>. The source entity will be
              destroyed.

              The target layout is given by the <u>target</u> argument, if <u>target</u> is <b>None</b>, the  target  layout  is  the
              source layout of the text entity.

              Returns the created DXF entities as an <u>EntityQuery</u> object.

              <b>Parameters</b>

                     • <b>entity</b> – TEXT or ATTRIB entity to explode

                     • <b>kind</b> – kind of entities to create as bit flags, see enum <u>Kind</u>

                     • <b>target</b>  –  target  layout  for  new created DXF entities, <b>None</b> for the same layout as the
                       source entity.

       <b>ezdxf.addons.text2path.make_path_from_entity(entity:</b> <b>Text</b> <b>|</b> <b>Attrib)</b> <b>-&gt;</b> <b>Path</b>
              Convert text content from DXF entities TEXT and ATTRIB into a <u>Multi-Path</u> object.   The  paths  are
              located at the location of the source entity.

       <b>ezdxf.addons.text2path.make_paths_from_entity(entity:</b> <b>Text</b> <b>|</b> <b>Attrib)</b> <b>-&gt;</b> <b>list[Path]</b>
              Convert  text content from DXF entities TEXT and ATTRIB into a list of <u>Path</u> objects. All paths are
              returned as a list of <u>Single-Path</u> objects.  The paths are located at the location  of  the  source
              entity.

   <b>MTextExplode</b>
       This  tool  is  meant  to  explode MTEXT entities into single line TEXT entities by replicating the MTEXT
       layout as close as possible. This tool requires the optional Matplotlib package to create usable results,
       nonetheless it also works without Matplotlib, but then uses a mono-spaced replacement font for text  size
       measuring which leads to very inaccurate results.

       The supported MTEXT features are:

       • changing text color

       • text strokes: underline, overline and strike through

       • changing text size, width and oblique

       • changing font faces

       • stacked text (fractions)

       • multi-column support

       • background color

       • text frame

       The tool requires an initialized DXF document io implement all these features by creating additional text
       styles.  When  exploding  multiple  MTEXT  entities,  they  can  share  this  new  text  styles. Call the
       <b>MTextExplode.finalize()</b> method just once after all MTEXT entities are processed to  create  the  required
       text styles, or use <b>MTextExplode</b> as context manager by using the <b>with</b> statement, see examples below.

       There are also many limitations:

       • A 100% accurate result cannot be achieved.

       • Character tracking is not supported.

       • Tabulator stops have only limited support for LEFT and JUSTIFIED aligned paragraphs to support numbered
         and bullet lists. An excessive use of tabs will lead to incorrect results.

       • The DISTRIBUTED alignment will be replaced by the JUSTIFIED alignment.

       • Text flow is always “left to right”.

       • The  line  spacing  mostly corresponds to the “EXACT” style, except for stacked text (fractions), which
         corresponds more to the “AT LEAST” style, but not precisely. This behavior maybe will  improve  in  the
         future.

       • FIELDS are not evaluated by <u>ezdxf</u>.

       <b>class</b> <b>ezdxf.addons.MTextExplode(layout,</b> <b>doc=None,</b> <b>spacing_factor=1.0)</b>
              The  <u>MTextExplode</u> class is a tool to disassemble MTEXT entities into single line TEXT entities and
              additional LINE entities if required to emulate strokes.

              The <u>layout</u> argument defines the target layout  for “exploded”  parts  of  the  MTEXT  entity.  Use
              argument  <u>doc</u>  if  the  target  layout  has  no  DXF  document assigned like virtual layouts.  The
              <u>spacing_factor</u> argument is an advanced tuning parameter to scale the size of space chars.

              <b>explode(mtext:</b> <b>MText,</b> <b>destroy=True)</b>
                     Explode <u>mtext</u> and destroy the source entity if argument <u>destroy</u> is <b>True</b>.

              <b>finalize()</b>
                     Create required text styles. This method is called automatically if the class  is  used  as
                     context manager. This method does not work with virtual layouts if no document was assigned
                     at initialization!

       Example to explode all MTEXT entities in the DXF file “mtext.dxf”:

          import ezdxf
          from ezdxf.addons import MTextExplode

          doc = ezdxf.readfile("mtext.dxf")
          msp = doc.modelspace()
          with <a href="../manmsp/MTextExplode.msp.html">MTextExplode</a>(msp) as xpl:
              for mtext in msp.query("MTEXT"):
                  <a href="../manmtext/xpl.explode.mtext.html">xpl.explode</a>(mtext)
          doc.saveas("xpl_mtext.dxf")

       Explode all MTEXT entities into the block “EXPLODE”:

          import ezdxf
          from ezdxf.addons import MTextExplode

          doc = ezdxf.readfile("mtext.dxf")
          msp = doc.modelspace()
          blk = doc.blocks.new("EXPLODE")
          with MTextExplode(blk) as xpl:
              for mtext in msp.query("MTEXT"):
                  <a href="../manmtext/xpl.explode.mtext.html">xpl.explode</a>(mtext)
          msp.add_block_ref("EXPLODE", (0, 0))
          doc.saveas("xpl_into_block.dxf")

   <b>HPGL/2</b> <b>Converter</b> <b>Add-on</b>
       New in version 1.1.

       The <b>hpgl2</b> add-on provides tools to process and convert HPGL/2 plot files.

   <b>What</b> <b>are</b> <b>HPGL/2</b> <b>Plot</b> <b>Files?</b>
       The  Hewlett-Packard  Graphics  Language  (HPGL)  is  a  vector graphics language originally developed by
       Hewlett-Packard in the 1970s. HPGL is widely used for controlling pen plotters and other output  devices,
       and it has become a de facto standard for communicating between computers and output devices in the field
       of computer-aided design (CAD) and drafting.

       HPGL  is a command-driven language that consists of a series of commands that control the movement of the
       plotter pen, the selection of pens and other output parameters, and the drawing of geometric shapes  such
       as  lines, arcs, circles, and text. The language is interpreted by the plotter or other output device and
       translated into physical pen movements on the drawing surface.

       HPGL has evolved over the years, and various extensions have been added to support more complex  graphics
       operations  and to improve compatibility with other graphics languages.  Despite the development of newer
       graphics languages and file formats, HPGL  remains  a  widely  used  format  for  vector-based  graphics,
       particularly in the engineering and architectural fields.

   <b>The</b> <b>Goal</b> <b>of</b> <b>This</b> <b>Add-on</b>
       An  HPGL/2  plot  file  contains  all  of the data generated by a CAD application that has been sent to a
       plotter to print an engineering drawing. In the past, the only way to access this data was to view it  on
       a  plotter  or  an  specialized  application,  which  could be expensive and impractical for many people.
       However, this module provides functions and classes to convert  HPGL/2  plot  files  into  modern  vector
       graphic formats such as <u>PDF</u> and <u>SVG</u> and of course DXF, allowing the data to be viewed and processed using
       a wide range of software tools.

       <b>IMPORTANT:</b>
          The Python module PyMuPDF is required for the PDF export: <u>https://pypi.org/project/PyMuPDF/</u>

       The  <u>Plotter</u>  class  in the <b>hpgl2</b> add-on supports only the most commonly used commands of HPGL/2. This is
       because many CAD applications use only a small  subset  of  HPGL/2  to  create  their  output,  typically
       consisting  of  polylines  and  filled  polygons.  For more information on the supported commands, please
       refer to the documentation for the <u>Plotter</u> class.

       To use the HPGL2 add-on, the entry point is the <u>ezdxf.addons.hpgl2.api</u> module.  This module contains  the
       public interface of the add-on and should be imported in the following way:

          from ezdxf.addons.hpgl2 import api as hpgl2

          with open("hpgl2.plt", "rb") as fp:
              data = fp.read()
          doc = hpgl2.to_dxf(data, color_mode=hpgl2.ColorMode.ACI)
          doc.saveas("hpgl2_as.dxf")

   <b>High</b> <b>Level</b> <b>Functions</b>
                                ┌───────────┬───────────────────────────────────────┐
                                │ <u>to_dxf</u>    │ Exports  the  HPGL/2  commands of the │
                                │           │ byte stream <u>b</u> as a DXF document.      │
                                ├───────────┼───────────────────────────────────────┤
                                │ <u>to_svg</u>    │ Exports the HPGL/2  commands  of  the │
                                │           │ byte stream <u>b</u> as SVG string.          │
                                ├───────────┼───────────────────────────────────────┤
                                │ <u>to_pdf</u>    │ Exports  the  HPGL/2  commands of the │
                                │           │ byte stream <u>b</u> as PDF data.            │
                                ├───────────┼───────────────────────────────────────┤
                                │ <u>to_pixmap</u> │ Exports the HPGL/2  commands  of  the │
                                │           │ byte stream <u>b</u> as pixel image.         │
                                └───────────┴───────────────────────────────────────┘

       <b>ezdxf.addons.hpgl2.api.to_dxf(b:</b> <b>bytes,</b> <b>*,</b> <b>rotation:</b> <b>int</b> <b>=</b> <b>0,</b> <b>mirror_x:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>mirror_y:</b> <b>bool</b> <b>=</b>
       <b>False,</b> <b>color_mode=ColorMode.RGB,</b> <b>merge_control:</b> <u>MergeControl</u> <b>=</b> <b>MergeControl.AUTO)</b> <b>-&gt;</b> <u>Drawing</u>
              Exports the HPGL/2 commands of the byte stream <u>b</u> as a DXF document.

              The  page  content is created at the origin of the modelspace and 1 drawing unit is 1 plot unit (1
              plu = 0.025mm) unless scaling values are provided.

              The content of HPGL files is intended to be plotted on white paper, therefore a white filling will
              be added as background in color mode <b>RGB</b>.

              All entities are assigned to a layer according to the pen number with the name  scheme  <b>PEN_&lt;###&gt;</b>.
              In  order  to  be  able to process the file better, it is also possible to assign the <u>ACI</u> color by
              layer by setting the argument <u>color_mode</u> to <u>ColorMode.ACI</u>, but then the RGB color is lost  because
              the RGB color has always the higher priority over the <u>ACI</u>.

              The first paperspace layout “Layout1” of the DXF document is set up to print the entire modelspace
              on one sheet, the size of the page is the size of the original plot file in millimeters.

              HPGL/2’s  merge  control  works at the pixel level and cannot be replicated by DXF, but to prevent
              fillings from obscuring text, the filled polygons are sorted by luminance - this can be forced  or
              disabled by the argument <u>merge_control</u>, see also <u>MergeControl</u> enum.

              <b>Parameters</b>

                     • <b>b</b> – plot file content as bytes

                     • <b>rotation</b> – rotation angle of 0, 90, 180 or 270 degrees

                     • <b>mirror_x</b> – mirror in x-axis direction

                     • <b>mirror_y</b> – mirror in y-axis direction

                     • <b>color_mode</b>  –  the color mode controls how color values are assigned to DXF entities, see
                       <u>ColorMode</u>

                     • <b>merge_control</b> – how to order filled polygons, see <u>MergeControl</u>

              Returns: DXF document as instance of class <u>Drawing</u>

       <b>ezdxf.addons.hpgl2.api.to_svg(b:</b> <b>bytes,</b> <b>*,</b> <b>rotation:</b> <b>int</b> <b>=</b> <b>0,</b> <b>mirror_x:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>mirror_y:</b> <b>bool</b> <b>=</b>
       <b>False,</b> <b>merge_control=MergeControl.AUTO)</b> <b>-&gt;</b> <b>str</b>
              Exports the HPGL/2 commands of the byte stream <u>b</u> as SVG string.

              The plot units are mapped 1:1 to <b>viewBox</b> units and the size of image is the size of  the  original
              plot file in millimeters.

              HPGL/2’s  merge  control  works at the pixel level and cannot be replicated by the backend, but to
              prevent fillings from obscuring text, the filled polygons are sorted by luminance -  this  can  be
              forced or disabled by the argument <u>merge_control</u>, see also <u>MergeControl</u> enum.

              <b>Parameters</b>

                     • <b>b</b> – plot file content as bytes

                     • <b>rotation</b> – rotation angle of 0, 90, 180 or 270 degrees

                     • <b>mirror_x</b> – mirror in x-axis direction

                     • <b>mirror_y</b> – mirror in y-axis direction

                     • <b>merge_control</b> – how to order filled polygons, see <u>MergeControl</u>

              Returns: SVG content as <b>str</b>

       <b>ezdxf.addons.hpgl2.api.to_pdf(b:</b> <b>bytes,</b> <b>*,</b> <b>rotation:</b> <b>int</b> <b>=</b> <b>0,</b> <b>mirror_x:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>mirror_y:</b> <b>bool</b> <b>=</b>
       <b>False,</b> <b>merge_control=MergeControl.AUTO)</b> <b>-&gt;</b> <b>bytes</b>
              Exports the HPGL/2 commands of the byte stream <u>b</u> as PDF data.

              The  plot units (1 plu = 0.025mm) are converted to PDF units (1/72 inch) so the image has the size
              of the original plot file.

              HPGL/2’s merge control works at the pixel level and cannot be replicated by the  backend,  but  to
              prevent  fillings  from  obscuring text, the filled polygons are sorted by luminance - this can be
              forced or disabled by the argument <u>merge_control</u>, see also <u>MergeControl</u> enum.

              Python module PyMuPDF is required: <u>https://pypi.org/project/PyMuPDF/</u>

              <b>Parameters</b>

                     • <b>b</b> – plot file content as bytes

                     • <b>rotation</b> – rotation angle of 0, 90, 180 or 270 degrees

                     • <b>mirror_x</b> – mirror in x-axis direction

                     • <b>mirror_y</b> – mirror in y-axis direction

                     • <b>merge_control</b> – how to order filled polygons, see <u>MergeControl</u>

              Returns: PDF content as <b>bytes</b>

       <b>ezdxf.addons.hpgl2.api.to_pixmap(b:</b> <b>bytes,</b> <b>*,</b> <b>rotation:</b> <b>int</b> <b>=</b> <b>0,</b> <b>mirror_x:</b> <b>bool</b> <b>=</b> <b>False,</b> <b>mirror_y:</b> <b>bool</b> <b>=</b>
       <b>False,</b> <b>merge_control=MergeControl.AUTO,</b> <b>fmt:</b> <b>str</b> <b>=</b> <b>'png',</b> <b>dpi:</b> <b>int</b> <b>=</b> <b>96)</b> <b>-&gt;</b> <b>bytes</b>
              Exports the HPGL/2 commands of the byte stream <u>b</u> as pixel image.

              Supported image formats:
                                              ┌─────┬───────────────────────────┐
                                              │ png │ Portable Network Graphics │
                                              ├─────┼───────────────────────────┤
                                              │ ppm │ Portable Pixmap           │
                                              ├─────┼───────────────────────────┤
                                              │ pbm │ Portable Bitmap           │
                                              └─────┴───────────────────────────┘

              The plot units (1 plu = 0.025mm) are converted to dot per inch (dpi) so the image has the size  of
              the original plot file.

              HPGL/2’s  merge  control  works at the pixel level and cannot be replicated by the backend, but to
              prevent fillings from obscuring text, the filled polygons are sorted by luminance -  this  can  be
              forced or disabled by the argument <u>merge_control</u>, see also <u>MergeControl</u> enum.

              Python module PyMuPDF is required: <u>https://pypi.org/project/PyMuPDF/</u>

              <b>Parameters</b>

                     • <b>b</b> – plot file content as bytes

                     • <b>rotation</b> – rotation angle of 0, 90, 180 or 270 degrees

                     • <b>mirror_x</b> – mirror in x-axis direction

                     • <b>mirror_y</b> – mirror in y-axis direction

                     • <b>merge_control</b> – how to order filled polygons, see <u>MergeControl</u>

                     • <b>fmt</b> – image format

                     • <b>dpi</b> – output resolution in dots per inch

              Returns: image content as <b>bytes</b>

       <b>class</b> <b>ezdxf.addons.hpgl2.api.ColorMode</b>
              The color mode controls how color values are assigned to DXF entities

              <b>ACI</b>    Use  the  pen  number  as <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> for DXF entities, ignores the RGB color
                     values

              <b>RGB</b>    Use the pen number as <u>AutoCAD</u> <u>Color</u> <u>Index</u>  <u>(ACI)</u>  but  also  set  the  RGB  color  for  DXF
                     entities,  RGB  color  values  have always higher priority than the ACI when displaying DXF
                     content.

       <b>class</b> <b>ezdxf.addons.hpgl2.api.MergeControl</b>
              Merge control enumeration.

              <b>NONE</b>   export filled polygons in print order

              <b>LUMINANCE</b>
                     sort filled polygons by luminance

              <b>AUTO</b>   guess best order of filled polygons

   <b>The</b> <b>Low</b> <b>Level</b> <b>Functions</b> <b>and</b> <b>Classes</b>
       <b>ezdxf.addons.hpgl2.api.hpgl2_commands(s:</b> <b>bytes)</b> <b>-&gt;</b> <b>list[Command]</b>
              Low level plot file parser, extracts the HPGL/2 from the byte stream <u>b</u>.

              <b>IMPORTANT:</b>
                 This parser expects the “Enter HPGL/2 mode” escape sequence to recognize HPGL/2  commands.  The
                 sequence looks like this: <b>[ESC]%1B</b>, multiple variants of this sequence are supported.

       The  HPGL/2  commands  are often mixed with the Printer Command Language (<u>PCL</u>) and/or the Raster Transfer
       Language (<u>RTL</u>) commands in a single plot file.

       Some plot files that contain pure HPGL/2 code do not contain the escape  sequence  “Enter  HPGL/2  mode”,
       without  this  sequence  the  HPGL/2  parser  cannot  recognize the beginning of the HPGL/2 code. Add the
       <b>ENTER_HPGL2_MODE</b> sequence in front of the bytes stream to switch on the HPGL/2  manually,  regardless  of
       whether the file is an HPGL/2 plot file or not, so be careful:

          commands = hpgl2_commands(hpgl2.ENTER_HPGL2_MODE + data)

       <b>class</b> <b>ezdxf.addons.hpgl2.api.Interpreter(plotter:</b> <u>Plotter</u><b>)</b>
              The <u>Interpreter</u> is the frontend for the <u>Plotter</u> class.  The <u>run()</u> methods interprets the low level
              HPGL  commands  from  the  <u>hpgl2_commands()</u>  parser  and sends the commands to the virtual plotter
              device, which sends his output to a low level <b>Backend</b> class.

              Most CAD application send a very restricted subset of commands to plotters, mostly just  polylines
              and  filled  polygons.  Implementing the whole HPGL/2 command set is not worth the effort - unless
              reality proofs otherwise.

              Not implemented commands:

                 • the whole character group - text is send as filled polygons or polylines

                 • configuration group: IN, DF, RO, IW - the plotter is initialized by creating  a  new  plotter
                   and page rotation is handled by the add-on itself

                 • polygon group: EA, ER, EW, FA, RR, WG, the rectangle and wedge commands

                 • line  and fill attributes group: LA, RF, SM, SV, TR, UL, WU, linetypes and hatch patterns are
                   decomposed into simple lines by CAD applications

              <b>Parameters</b>
                     <b>plotter</b> – virtual <u>Plotter</u> device

              <b>errors</b> List of error messages occurred during the interpretation of the HPGL/2 commands.

              <b>not_implemented_commands</b>
                     List of all unsupported/ignored commands from the input stream.

              <b>run(commands:</b> <b>list[Command])</b> <b>-&gt;</b> <b>None</b>
                     Interprets the low level HPGL commands from  the  <u>hpgl2_commands()</u>  parser  and  sends  the
                     commands to the virtual plotter device.

              <b>disable_commands(commands:</b> <b>Iterable[str])</b> <b>-&gt;</b> <b>None</b>
                     Disable  commands manually, like the scaling command [“SC”, “IP”, “IR”].  This is a feature
                     for experts, because disabling commands which changes  the  pen  location  may  distort  or
                     destroy the plotter output.

       <b>class</b> <b>ezdxf.addons.hpgl2.api.Plotter(backend:</b> <b>Backend)</b>
              The <u>Plotter</u> class represents a virtual plotter device.

              The  HPGL/2  commands  send  by  the  <u>Interpreter</u>  are  processed into simple polylines and filled
              polygons and send to low level <b>Backend</b>.

              HPGL/2 uses a units system called “Plot Units”:

              • 1 plot unit (plu) = 0.025mm

              • 40 plu = 1 mm

              • 1016 plu = 1 inch

              The Plotter device does not support font rendering and page rotation (RO).  The  scaling  commands
              IP, RP, SC are supported.

   <b>Recorder</b>
       <b>class</b> <b>ezdxf.addons.hpgl2.api.Recorder</b>
              The <u>Recorder</u> class records the output of the <u>Plotter</u> class.

              All input coordinates are page coordinates:

              • 1 plot unit (plu) = 0.025mm

              • 40 plu = 1 mm

              • 1016 plu = 1 inch

              <b>player()</b> <b>-&gt;</b> <u>Player</u>
                     Returns  a  <u>Player</u>  instance  with  the  original recordings. Make a copy of this player to
                     protect the original recordings from being modified:

                        safe_player = recorder.player().copy()

              <b>draw_polyline(properties:</b> <u>Properties</u><b>,</b> <b>points:</b> <b>Sequence[</b><u>Vec2</u><b>])</b> <b>-&gt;</b> <b>None</b>
                     Draws a polyline from a sequence <u>points</u>. The input coordinates are page coordinates in plot
                     units. The <u>points</u> sequence can contain 0 or more points!

                     <b>Parameters</b>

                            • <b>properties</b> – display <b>Properties</b> for the polyline

                            • <b>points</b> – sequence of <u>ezdxf.math.Vec2</u> instances

              <b>draw_paths(properties:</b> <u>Properties</u><b>,</b> <b>paths:</b> <b>Sequence[Path],</b> <b>filled:</b> <b>bool)</b> <b>-&gt;</b> <b>None</b>
                     Draws filled or outline paths from the sequence of <u>paths</u>. The input  coordinates  are  page
                     coordinates  in plot units. The <u>paths</u> sequence can contain 0 or more single <u>Path</u> instances.
                     Draws outline paths if Properties.FillType is NONE and filled paths otherwise.

                     <b>Parameters</b>

                            • <b>properties</b> – display <b>Properties</b> for the filled polygon

                            • <b>paths</b> – sequence of single <u>ezdxf.path.Path</u> instances

                            • <b>filled</b> – draw filled paths if <b>True</b> otherwise outline paths

   <b>Player</b>
       <b>class</b> <b>ezdxf.addons.hpgl2.api.Player(records:</b> <b>list[DataRecord],</b> <b>properties:</b> <b>dict[int,</b> <u>Properties</u><b>])</b>
              This class replays the recordings of the <u>Recorder</u> class on another backend. The class  can  modify
              the recorded output.

              <b>copy()</b> <b>-&gt;</b> <b>Self</b>
                     Returns a new <u>Player</u> instance with a copy of recordings.

              <b>recordings()</b> <b>-&gt;</b> <b>Iterator[tuple[RecordType,</b> <u>Properties</u><b>,</b> <b>Any]]</b>
                     Yields all recordings as <u>(RecordType,</u> <u>Properties,</u> <u>Data)</u> tuples.

                     The content of the <u>Data</u> field is determined by the enum <b>RecordType</b>:

                     • <b>RecordType.POLYLINE</b> returns a <b>NumpyPoints2d</b> instance

                     • <b>RecordType.FILLED_POLYGON</b> returns a tuple of <b>NumpyPath2d</b> instances

              <b>replay(backend:</b> <b>Backend)</b> <b>-&gt;</b> <b>None</b>
                     Replay the recording on another backend.

              <b>bbox()</b> <b>-&gt;</b> <u>BoundingBox2d</u>
                     Returns the bounding box of all recorded polylines and polygons as <u>BoundingBox2d</u>.

              <b>transform(m:</b> <u>Matrix44</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Transforms the recordings by a transformation matrix <u>m</u> of type <u>Matrix44</u>.

              <b>sort_filled_paths()</b> <b>-&gt;</b> <b>None</b>
                     Sort filled paths by descending luminance (from light to dark).

                     This  also  changes  the  plot  order  in  the way that all filled paths are plotted before
                     polylines and outline paths.

   <b>Properties</b>
       <b>class</b> <b>ezdxf.addons.hpgl2.properties.Properties</b>
              Consolidated display properties.

              <b>pen_index</b>
                     pen index as int

              <b>pen_color</b>
                     pen color as <b>RGB</b> tuple

              <b>pen_width</b>
                     pen width in millimeters (float)

              <b>fill_type</b>
                     <u>FillType</u> of filled polygons

              <b>fill_method</b>
                     <u>FillMethod</u> of filled polygons

              <b>fill_hatch_line_angle</b>
                     fill hatch line angle in degrees

              <b>fill_hatch_line_spacing</b>
                     fill hatch line distance in plotter units

              <b>fill_shading_density</b>
                     fill shading density in percent from 0 to 100.

              <b>resolve_pen_color()</b> <b>-&gt;</b> <u>RGB</u>
                     Returns the final RGB pen color.

              <b>resolve_fill_color()</b> <b>-&gt;</b> <u>RGB</u>
                     Returns the final RGB fill color.

       <b>class</b> <b>ezdxf.addons.hpgl2.properties.FillType(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b> <b>type=None,</b>
       <b>start=1,</b> <b>boundary=None)</b>
              Fill type enumeration.

              <b>NONE</b>

              <b>SOLID</b>

              <b>HATCHING</b>

              <b>CROSS_HATCHING</b>

              <b>SHADING</b>

       <b>class</b> <b>ezdxf.addons.hpgl2.properties.FillMethod(value,</b> <b>names=None,</b> <b>*,</b> <b>module=None,</b> <b>qualname=None,</b>
       <b>type=None,</b> <b>start=1,</b> <b>boundary=None)</b>
              Fill method enumeration.

              <b>EVEN_ODD</b>

              <b>NONE_ZERO_WINDING</b>

   <b>Exceptions</b>
       <b>class</b> <b>ezdxf.addons.hpgl2.api.Hpgl2Error</b>
              Base exception for the <b>hpgl2</b> add-on.

       <b>class</b> <b>ezdxf.addons.hpgl2.api.Hpgl2DataNotFound</b>
              No HPGL/2 data was found, maybe the “Enter HPGL/2 mode” escape sequence is missing.

       <b>class</b> <b>ezdxf.addons.hpgl2.api.EmptyDrawing</b>
              The HPGL/2 commands do not produce any content.

   <b>PyCSG</b>
       Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean  operations  like  union  and
       intersection  to  combine  3D  solids.  This  library  implements  CSG operations on meshes elegantly and
       concisely using BSP trees, and is meant to serve  as  an  easily  understandable  implementation  of  the
       algorithm. All edge cases involving overlapping coplanar polygons in both solids are correctly handled.

       Example for usage:

          import ezdxf
          from ezdxf.render.forms import cube, cylinder_2p
          from ezdxf.addons.pycsg import CSG

          # create new DXF document
          doc = ezdxf.new()
          msp = doc.modelspace()

          # create same geometric primitives as MeshTransformer() objects
          cube1 = cube()
          cylinder1 = cylinder_2p(count=32, base_center=(0, -1, 0), top_center=(0, 1, 0), radius=.25)

          # build solid union
          union = CSG(cube1) + CSG(cylinder1)
          # convert to mesh and render mesh to modelspace
          union.mesh().render(msp, dxfattribs={'color': 1})

          # build solid difference
          difference = CSG(cube1) - CSG(cylinder1)
          # convert to mesh, translate mesh and render mesh to modelspace
          difference.mesh().translate(1.5).render(msp, dxfattribs={'color': 3})

          # build solid intersection
          intersection = CSG(cube1) * CSG(cylinder1)
          # convert to mesh, translate mesh and render mesh to modelspace
          intersection.mesh().translate(2.75).render(msp, dxfattribs={'color': 5})

          doc.saveas('csg.dxf')
       [image: Cube vs Cylinder] [image]

       This  CSG  kernel supports only meshes as <u>MeshBuilder</u> objects, which can be created from and converted to
       DXF <u>Mesh</u> entities.

       This CSG kernel is <b>not</b> compatible with ACIS objects like <u>Solid3d</u>, <u>Body</u>, <u>Surface</u> or <u>Region</u>.

       <b>NOTE:</b>
          This is a pure Python implementation, don’t expect great performance and the implementation  is  based
          on an unbalanced <u>BSP</u> <u>tree</u>, so in the case of <b>RecursionError</b>, increase the recursion limit:

              import sys

              actual_limit = sys.getrecursionlimit()
              # default is 1000, increasing too much may cause a seg fault
              <a href="../man10000/sys.setrecursionlimit.10000.html">sys.setrecursionlimit</a>(10000)

              ...  # do the CSG stuff

              sys.setrecursionlimit(actual_limit)

       CSG  works  also  with  spheres,  but  with  really  bad  runtime behavior and most likely <b>RecursionError</b>
       exceptions, and use <u>quadrilaterals</u> as body faces to reduce face count by setting argument <u>quads</u> to <b>True</b>.

          import ezdxf

          from ezdxf.render.forms import sphere, cube
          from ezdxf.addons.pycsg import CSG

          doc = ezdxf.new()
          doc.set_modelspace_vport(6, center=(5, 0))
          msp = doc.modelspace()

          cube1 = cube().translate(-.5, -.5, -.5)
          sphere1 = sphere(count=32, stacks=16, radius=.5, quads=True)

          union = (CSG(cube1) + CSG(sphere1)).mesh()
          union.render(msp, dxfattribs={'color': 1})

          subtract = (CSG(cube1) - CSG(sphere1)).mesh().translate(2.5)
          subtract.render(msp, dxfattribs={'color': 3})

          intersection = (CSG(cube1) * CSG(sphere1)).mesh().<a href="../man4/translate.4.html">translate</a>(4)
          intersection.render(msp, dxfattribs={'color': 5})
       [image: Cube vs Sphere] [image]

       Hard Core CSG - Menger Sponge Level 3 vs Sphere

       Required runtime on an old Xeon E5-1620 Workstation @ 3.60GHz, with default recursion limit  of  1000  on
       Windows 10:

          • CPython 3.8.1 64bit: ~60 seconds,

          • pypy3  [PyPy  7.2.0]  32bit:  ~6 seconds, and using <b>__slots__</b> reduced runtime below 5 seconds, yes -
            pypy is worth a look for long running scripts!

          from ezdxf.render.forms import sphere
          from ezdxf.addons import MengerSponge
          from ezdxf.addons.pycsg import CSG

          doc = ezdxf.new()
          doc.layers.new('sponge', dxfattribs={'color': 5})
          doc.layers.new('sphere', dxfattribs={'color': 6})

          doc.set_modelspace_vport(6, center=(5, 0))
          msp = doc.modelspace()

          sponge1 = MengerSponge(level=3).mesh()
          sphere1 = sphere(count=32, stacks=16, radius=.5, quads=True).translate(.25, .25, 1)

          subtract = (CSG(sponge1, meshid=1) - CSG(sphere1, meshid=2))
          # get mesh result by id
          <a href="../man1/subtract.mesh.1.html">subtract.mesh</a>(1).render(msp, dxfattribs={'layer': 'sponge'})
          <a href="../man2/subtract.mesh.2.html">subtract.mesh</a>(2).render(msp, dxfattribs={'layer': 'sphere'})
       [image: Menger Sponge vs Sphere] [image]

   <b>CSG</b> <b>Class</b>
       <b>class</b> <b>ezdxf.addons.pycsg.CSG(mesh:</b> <u>MeshBuilder</u><b>,</b> <b>meshid:</b> <b>int</b> <b>=</b> <b>0)</b>
              Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean operations like  union
              and intersection to combine 3D solids. This class implements CSG operations on meshes.

              New  3D solids are created from <u>MeshBuilder</u> objects and results can be exported as <u>MeshTransformer</u>
              objects to <u>ezdxf</u> by method <u>mesh()</u>.

              <b>Parameters</b>

                     • <b>mesh</b> – <u>ezdxf.render.MeshBuilder</u> or inherited object

                     • <b>meshid</b> – individual mesh ID to separate result meshes, <b>0</b> is default

              <b>mesh(meshid:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>MeshTransformer</b>
                     Returns a <u>ezdxf.render.MeshTransformer</u> object.

                     <b>Parameters</b>
                            <b>meshid</b> – individual mesh ID, <b>0</b> is default

              <b>union(other:</b> <u>CSG</u><b>)</b> <b>-&gt;</b> <u>CSG</u>
                     Return a new CSG solid representing space in either this  solid  or  in  the  solid  <u>other</u>.
                     Neither this solid nor the solid <u>other</u> are modified:

                        A.union(B)

                        +-------+            +-------+
                        |       |            |       |
                        |   A   |            |       |
                        |    +--+----+   =   |       +----+
                        +----+--+    |       +----+       |
                             |   B   |            |       |
                             |       |            |       |
                             +-------+            +-------+

              <b>__add__()</b>

                        union = A + B

              <b>subtract(other:</b> <u>CSG</u><b>)</b> <b>-&gt;</b> <u>CSG</u>
                     Return a new CSG solid representing space in this solid but not in the solid <u>other</u>. Neither
                     this solid nor the solid <u>other</u> are modified:

                        A.subtract(B)

                        +-------+            +-------+
                        |       |            |       |
                        |   A   |            |       |
                        |    +--+----+   =   |    +--+
                        +----+--+    |       +----+
                             |   B   |
                             |       |
                             +-------+

              <b>__sub__()</b>

                        difference = A - B

              <b>intersect(other:</b> <u>CSG</u><b>)</b> <b>-&gt;</b> <u>CSG</u>
                     Return  a  new CSG solid representing space both this solid and in the solid <u>other</u>. Neither
                     this solid nor the solid <u>other</u> are modified:

                        A.intersect(B)

                        +-------+
                        |       |
                        |   A   |
                        |    +--+----+   =   +--+
                        +----+--+    |       +--+
                             |   B   |
                             |       |
                             +-------+

              <b>__mul__()</b>

                        intersection = A * B

              <b>inverse()</b> <b>-&gt;</b> <u>CSG</u>
                     Return a new CSG solid with solid and empty space switched. This solid is not modified.

   <b>License</b>
       • Original implementation <u>csg.js</u>, Copyright (c) 2011 Evan Wallace (<u><a href="http://madebyevan.com/">http://madebyevan.com/</a></u>), under the MIT
         license.

       • Python port <u>pycsg</u>, Copyright (c) 2012 Tim Knip (<u><a href="http://www.floorplanner.com">http://www.floorplanner.com</a></u>), under the MIT license.

       • Additions by Alex Pletzer (Pennsylvania State University)

       • Integration as <u>ezdxf</u> add-on, Copyright (c) 2020, Manfred Moitzi, MIT License.

   <b>Plot</b> <b>Style</b> <b>Files</b> <b>(CTB/STB)</b>
       CTB and STB files store plot styles used by AutoCAD and BricsCAD for printing and plotting.

       If the plot style table is attached to a <u>Paperspace</u> or the <u>Modelspace</u>, a change of a plot  style  affects
       any  object  that  uses  that  plot style. CTB files contain color dependent plot style tables, STB files
       contain named plot style tables.

       <b>SEE</b> <b>ALSO:</b>

          • <u>Using</u> <u>plot</u> <u>style</u> <u>tables</u> <u>in</u> <u>AutoCAD</u>

          • <u>AutoCAD</u> <u>Plot</u> <u>Style</u> <u>Table</u> <u>Editor</u>

          • <u>BricsCAD</u> <u>Plot</u> <u>Style</u> <u>Table</u> <u>Editor</u>

          • AUTODESK KNOWLEDGE NETWORK: How to <u>install</u> CTB files in AutoCAD

       <b>ezdxf.addons.acadctb.load(filename:</b> <b>str</b> <b>|</b> <b>PathLike)</b> <b>-&gt;</b> <u>ColorDependentPlotStyles</u> <b>|</b> <u>NamedPlotStyles</u>
              Load the CTB or STB file <u>filename</u> from file system.

       <b>ezdxf.addons.acadctb.new_ctb()</b> <b>-&gt;</b> <u>ColorDependentPlotStyles</u>
              Create a new CTB file.

       <b>ezdxf.addons.acadctb.new_stb()</b> <b>-&gt;</b> <u>NamedPlotStyles</u>
              Create a new STB file.

   <b>ColorDependentPlotStyles</b>
       Color dependent plot style table (CTB file), table entries are <u>PlotStyle</u> objects.

       <b>class</b> <b>ezdxf.addons.acadctb.ColorDependentPlotStyles</b>

              <b>description</b>
                     Custom description of plot style file.

              <b>scale_factor</b>
                     Specifies the factor by which to scale non-ISO linetypes and fill patterns.

              <b>apply_factor</b>
                     Specifies whether or not you want to apply the <u>scale_factor</u>.

              <b>custom_lineweight_display_units</b>
                     Set <b>1</b> for showing lineweight in inch in AutoCAD CTB  editor  window,  but  lineweights  are
                     always defined in millimeters.

              <b>lineweights</b>
                     Lineweights table as <b>array.array</b>

              <b>__getitem__(aci:</b> <b>int)</b> <b>-&gt;</b> <u>PlotStyle</u>
                     Returns <u>PlotStyle</u> for <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u> <u>aci</u>.

              <b>__iter__()</b>
                     Iterable of all plot styles.

              <b>new_style(aci:</b> <b>int,</b> <b>data:</b> <b>dict</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>PlotStyle</u>
                     Set <u>aci</u> to new attributes defined by <u>data</u> dict.

                     <b>Parameters</b>

                            • <b>aci</b> – <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>

                            • <b>data</b>  –  <b>dict</b>  of  <u>PlotStyle</u>  attributes: description, color, physical_pen_number,
                              virtual_pen_number,   screen,   linepattern_size,   linetype,   adaptive_linetype,
                              lineweight, end_style, join_style, fill_style

              <b>get_lineweight(aci:</b> <b>int)</b>
                     Returns the assigned lineweight for <u>PlotStyle</u> <u>aci</u> in millimeter.

              <b>get_lineweight_index(lineweight:</b> <b>float)</b> <b>-&gt;</b> <b>int</b>
                     Get index of <u>lineweight</u> in the lineweight table or append <u>lineweight</u> to lineweight table.

              <b>get_table_lineweight(index:</b> <b>int)</b> <b>-&gt;</b> <b>float</b>
                     Returns lineweight in millimeters of lineweight table entry <u>index</u>.

                     <b>Parameters</b>
                            <b>index</b> – lineweight table index = <u>PlotStyle.lineweight</u>

                     <b>Returns</b>
                            lineweight in mm or <b>0.0</b> for use entity lineweight

              <b>set_table_lineweight(index:</b> <b>int,</b> <b>lineweight:</b> <b>float)</b> <b>-&gt;</b> <b>int</b>
                     Argument <u>index</u> is the lineweight table index, not the <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>.

                     <b>Parameters</b>

                            • <b>index</b> – lineweight table index = <u>PlotStyle.lineweight</u>

                            • <b>lineweight</b> – in millimeters

              <b>save()</b> Save CTB file as <u>filename</u> to the file system.

              <b>write(stream:</b> <b>BinaryIO)</b> <b>-&gt;</b> <b>None</b>
                     Compress and write CTB file to binary <u>stream</u>.

   <b>NamedPlotStyles</b>
       Named plot style table (STB file), table entries are <u>PlotStyle</u> objects.

       <b>class</b> <b>ezdxf.addons.acadctb.NamedPlotStyles</b>

              <b>description</b>
                     Custom description of plot style file.

              <b>scale_factor</b>
                     Specifies the factor by which to scale non-ISO linetypes and fill patterns.

              <b>apply_factor</b>
                     Specifies whether or not you want to apply the <u>scale_factor</u>.

              <b>custom_lineweight_display_units</b>
                     Set  <b>1</b>  for  showing  lineweight  in inch in AutoCAD CTB editor window, but lineweights are
                     always defined in millimeters.

              <b>lineweights</b>
                     Lineweights table as <b>array.array</b>

              <b>__getitem__(name:</b> <b>str)</b> <b>-&gt;</b> <u>PlotStyle</u>
                     Returns <u>PlotStyle</u> by <u>name</u>.

              <b>__delitem__(name:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Delete plot style <u>name</u>. Plot style <b>'Normal'</b> is not deletable.

              <b>__iter__()</b> <b>-&gt;</b> <b>Iterable[str]</b>
                     Iterable of all plot style names.

              <b>new_style(name:</b> <b>str,</b> <b>data:</b> <b>dict</b> <b>|</b> <b>None</b> <b>=</b> <b>None,</b> <b>localized_name:</b> <b>str</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>PlotStyle</u>
                     Create new class:<u>PlotStyle</u> <u>name</u> by attribute dict <u>data</u>, replaces  existing  class:<u>PlotStyle</u>
                     objects.

                     <b>Parameters</b>

                            • <b>name</b> – plot style name

                            • <b>localized_name</b> – name shown in plot style editor, uses <u>name</u> if <b>None</b>

                            • <b>data</b>  –  <b>dict</b>  of  <u>PlotStyle</u>  attributes: description, color, physical_pen_number,
                              virtual_pen_number,   screen,   linepattern_size,   linetype,   adaptive_linetype,
                              lineweight, end_style, join_style, fill_style

              <b>get_lineweight(name:</b> <b>str)</b>
                     Returns the assigned lineweight for <u>PlotStyle</u> <u>name</u> in millimeter.

              <b>get_lineweight_index(lineweight:</b> <b>float)</b> <b>-&gt;</b> <b>int</b>
                     Get index of <u>lineweight</u> in the lineweight table or append <u>lineweight</u> to lineweight table.

              <b>get_table_lineweight(index:</b> <b>int)</b> <b>-&gt;</b> <b>float</b>
                     Returns lineweight in millimeters of lineweight table entry <u>index</u>.

                     <b>Parameters</b>
                            <b>index</b> – lineweight table index = <u>PlotStyle.lineweight</u>

                     <b>Returns</b>
                            lineweight in mm or <b>0.0</b> for use entity lineweight

              <b>set_table_lineweight(index:</b> <b>int,</b> <b>lineweight:</b> <b>float)</b> <b>-&gt;</b> <b>int</b>
                     Argument <u>index</u> is the lineweight table index, not the <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>.

                     <b>Parameters</b>

                            • <b>index</b> – lineweight table index = <u>PlotStyle.lineweight</u>

                            • <b>lineweight</b> – in millimeters

              <b>save()</b> Save STB file as <u>filename</u> to the file system.

              <b>write()</b>
                     Compress and write STB file to binary <u>stream</u>.

   <b>PlotStyle</b>
       <b>class</b> <b>ezdxf.addons.acadctb.PlotStyle</b>

              <b>index</b>  Table index (0-based). (int)

              <b>aci</b>    <u>AutoCAD</u>  <u>Color</u>  <u>Index</u>  <u>(ACI)</u>  in range from <b>1</b> to <b>255</b>. Has no meaning for named plot styles.
                     (int)

              <b>description</b>
                     Custom description of plot style. (str)

              <b>physical_pen_number</b>
                     Specifies physical plotter pen, valid range from <b>1</b> to <b>32</b> or <u>AUTOMATIC</u>. (int)

              <b>virtual_pen_number</b>
                     Only used by non-pen plotters and only if they are configured for virtual pens. valid range
                     from <b>1</b> to <b>255</b> or <u>AUTOMATIC</u>. (int)

              <b>screen</b> Specifies the color intensity of the plot on the paper, valid range is from <b>0</b> to <b>100</b>. (int)

                     If you select <b>100</b> the drawing will plotted with its full  color  intensity.  In  order  for
                     screening to work, the <u>dithering</u> option must be active.

              <b>linetype</b>
                     Overrides the entity linetype, default value is <u>OBJECT_LINETYPE</u>. (bool)

              <b>adaptive_linetype</b>
                     <b>True</b>  if  a  complete  linetype  pattern is more important than a correct linetype scaling,
                     default is <b>True</b>. (bool)

              <b>linepattern_size</b>
                     Line pattern size, default = <b>0.5</b>. (float)

              <b>lineweight</b>
                     Overrides the entity lineWEIGHT, default value is <u>OBJECT_LINEWEIGHT</u>. This is an index  into
                     the <b>UserStyles.lineweights</b> table. (int)

              <b>end_style</b>
                     Line end cap style, see table below, default is <b>END_STYLE_OBJECT</b> (int)

              <b>join_style</b>
                     Line join style, see table below, default is <b>JOIN_STYLE_OBJECT</b> (int)

              <b>fill_style</b>
                     Line fill style, see table below, default is <b>FILL_STYLE_OBJECT</b> (int)

              <b>dithering</b>
                     Depending  on  the capabilities of your plotter, dithering approximates the colors with dot
                     patterns. When this option is <b>False</b>, the colors are mapped to the nearest color,  resulting
                     in a smaller range of colors when plotting.

                     Dithering  is  available  only whether you select the object’s color or assign a plot style
                     color.

              <b>grayscale</b>
                     Plot colors in grayscale. (bool)

   <b>Default</b> <b>Line</b> <b>Weights</b>
                                                    ┌────┬──────┐
                                                    │ #  │ [mm] │
                                                    ├────┼──────┤
                                                    │ 0  │ 0.00 │
                                                    ├────┼──────┤
                                                    │ 1  │ 0.05 │
                                                    ├────┼──────┤
                                                    │ 2  │ 0.09 │
                                                    ├────┼──────┤
                                                    │ 3  │ 0.10 │
                                                    ├────┼──────┤
                                                    │ 4  │ 0.13 │
                                                    ├────┼──────┤
                                                    │ 5  │ 0.15 │
                                                    ├────┼──────┤
                                                    │ 6  │ 0.18 │
                                                    ├────┼──────┤
                                                    │ 7  │ 0.20 │
                                                    ├────┼──────┤
                                                    │ 8  │ 0.25 │
                                                    ├────┼──────┤
                                                    │ 9  │ 0.30 │
                                                    ├────┼──────┤
                                                    │ 10 │ 0.35 │
                                                    ├────┼──────┤
                                                    │ 11 │ 0.40 │
                                                    ├────┼──────┤
                                                    │ 12 │ 0.45 │
                                                    ├────┼──────┤
                                                    │ 13 │ 0.50 │
                                                    ├────┼──────┤
                                                    │ 14 │ 0.53 │
                                                    ├────┼──────┤
                                                    │ 15 │ 0.60 │
                                                    ├────┼──────┤
                                                    │ 16 │ 0.65 │
                                                    ├────┼──────┤
                                                    │ 17 │ 0.70 │
                                                    ├────┼──────┤
                                                    │ 18 │ 0.80 │
                                                    ├────┼──────┤
                                                    │ 19 │ 0.90 │
                                                    ├────┼──────┤
                                                    │ 20 │ 1.00 │
                                                    ├────┼──────┤
                                                    │ 21 │ 1.06 │
                                                    ├────┼──────┤
                                                    │ 22 │ 1.20 │
                                                    ├────┼──────┤
                                                    │ 23 │ 1.40 │
                                                    ├────┼──────┤
                                                    │ 24 │ 1.58 │
                                                    ├────┼──────┤
                                                    │ 25 │ 2.00 │
                                                    ├────┼──────┤
                                                    │ 26 │ 2.11 │
                                                    └────┴──────┘

   <b>Predefined</b> <b>Values</b>
       <b>ezdxf.addons.acadctb.AUTOMATIC</b>

       <b>ezdxf.addons.acadctb.OBJECT_LINEWEIGHT</b>

       <b>ezdxf.addons.acadctb.OBJECT_LINETYPE</b>

       <b>ezdxf.addons.acadctb.OBJECT_COLOR</b>

       <b>ezdxf.addons.acadctb.OBJECT_COLOR2</b>

   <b>Line</b> <b>End</b> <b>Style</b>
       [image]
                                              ┌───────────────────┬───┐
                                              │ END_STYLE_BUTT    │ <b>0</b> │
                                              ├───────────────────┼───┤
                                              │ END_STYLE_SQUARE  │ <b>1</b> │
                                              ├───────────────────┼───┤
                                              │ END_STYLE_ROUND   │ <b>2</b> │
                                              ├───────────────────┼───┤
                                              │ END_STYLE_DIAMOND │ <b>3</b> │
                                              ├───────────────────┼───┤
                                              │ END_STYLE_OBJECT  │ <b>4</b> │
                                              └───────────────────┴───┘

   <b>Line</b> <b>Join</b> <b>Style</b>
       [image]
                                              ┌────────────────────┬───┐
                                              │ JOIN_STYLE_MITER   │ <b>0</b> │
                                              ├────────────────────┼───┤
                                              │ JOIN_STYLE_BEVEL   │ <b>1</b> │
                                              ├────────────────────┼───┤
                                              │ JOIN_STYLE_ROUND   │ <b>2</b> │
                                              ├────────────────────┼───┤
                                              │ JOIN_STYLE_DIAMOND │ <b>3</b> │
                                              ├────────────────────┼───┤
                                              │ JOIN_STYLE_OBJECT  │ <b>5</b> │
                                              └────────────────────┴───┘

   <b>Fill</b> <b>Style</b>
       [image]
                                         ┌────────────────────────────┬────┐
                                         │ FILL_STYLE_SOLID           │ <b>64</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_CHECKERBOARD    │ <b>65</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_CROSSHATCH      │ <b>66</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_DIAMONDS        │ <b>67</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_HORIZONTAL_BARS │ <b>68</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_SLANT_LEFT      │ <b>69</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_SLANT_RIGHT     │ <b>70</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_SQUARE_DOTS     │ <b>71</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_VERICAL_BARS    │ <b>72</b> │
                                         ├────────────────────────────┼────┤
                                         │ FILL_STYLE_OBJECT          │ <b>73</b> │
                                         └────────────────────────────┴────┘

   <b>Linetypes</b>
       [image] [image]
                                    ─────────────────────────────────────────────
                                      Linetype name                       Value
                                    ─────────────────────────────────────────────
                                      Solid                               0
                                    ─────────────────────────────────────────────
                                      Dashed                              1
                                    ─────────────────────────────────────────────
                                      Dotted                              2
                                    ─────────────────────────────────────────────
                                      Dash Dot                            3
                                    ─────────────────────────────────────────────
                                      Short Dash                          4
                                    ─────────────────────────────────────────────
                                      Medium Dash                         5
                                    ─────────────────────────────────────────────
                                      Long Dash                           6
                                    ─────────────────────────────────────────────
                                      Short Dash x2                       7
                                    ─────────────────────────────────────────────
                                      Medium Dash x2                      8
                                    ─────────────────────────────────────────────
                                      Long Dash x2                        9
                                    ─────────────────────────────────────────────
                                      Medium Lang Dash                    10
                                    ─────────────────────────────────────────────
                                      Medium Dash Short Dash Short Dash   11
                                    ─────────────────────────────────────────────
                                      Long Dash Short Dash                12
                                    ─────────────────────────────────────────────
                                      Long Dash Dot Dot                   13
                                    ─────────────────────────────────────────────
                                      Long Dash Dot                       14
                                    ─────────────────────────────────────────────
                                      Medium Dash Dot Short Dash Dot      15
                                    ─────────────────────────────────────────────
                                      Sparse Dot                          16
                                    ─────────────────────────────────────────────
                                      ISO Dash                            17
                                    ─────────────────────────────────────────────
                                      ISO Dash Space                      18
                                    ─────────────────────────────────────────────
                                      ISO Long Dash Dot                   19
                                    ─────────────────────────────────────────────
                                      ISO Long Dash Double Dot            20
                                    ─────────────────────────────────────────────
                                      ISO Long Dash Triple Dot            21
                                    ─────────────────────────────────────────────
                                      ISO Dot                             22
                                    ─────────────────────────────────────────────
                                      ISO Long Dash Short Dash            23
                                    ─────────────────────────────────────────────
                                      ISO Long Dash Double Short Dash     24
                                    ─────────────────────────────────────────────
                                      ISO Dash Dot                        25
                                    ─────────────────────────────────────────────
                                      ISO Double Dash Dot                 26
                                    ─────────────────────────────────────────────
                                      ISO Dash Double Dot                 27
                                    ─────────────────────────────────────────────
                                      ISO Double Dash Double Dot          28
                                    ─────────────────────────────────────────────
                                      ISO Dash Triple Dot                 29
                                    ─────────────────────────────────────────────
                                      ISO Double Dash Triple Dot          30
                                    ─────────────────────────────────────────────
                                      Use entity linetype                 31
                                    ┌───────────────────────────────────┬───────┐
                                    │                                   │       │
   <b>Showcase</b> <b>Forms</b>                   │                                   │       │
   <b>MengerSponge</b>                     │                                   │       │
       Build a 3D <u>Menger</u> <u>sponge</u>.    │                                   │       │
                                    │                                   │       │
--
</pre><h4><b>DXF</b> <b>INTERNALS</b></h4><pre>
       • <u>DXF</u> <u>Reference</u> provided by Autodesk.

       • <u>DXF</u> <u>Developer</u> <u>Documentation</u> provided by Autodesk.

   <b>Basic</b> <b>DXF</b> <b>Structures</b>
   <b>DXF</b> <b>File</b> <b>Encoding</b>
   <b>DXF</b> <b>R2004</b> <b>and</b> <b>prior</b>
       Drawing files of DXF R2004 (AC1018) and prior are saved as ASCII files  with  the  encoding  set  by  the
       header variable $DWGCODEPAGE, which is <b>ANSI_1252</b> by default if $DWGCODEPAGE is not set.

       Characters  used  in  the  drawing which do not exist in the chosen ASCII encoding are encoded as unicode
       characters with the schema <b>\U+nnnn</b>. see <u>Unicode</u> <u>table</u>

   <b>Known</b> <b>$DWGCODEPAGE</b> <b>encodings</b>
                                       ┌───────────┬────────┬────────────────┐
                                       │ DXF       │ Python │ Name           │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_874  │ cp874  │ Thai           │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_932  │ cp932  │ Japanese       │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_936  │ gbk    │ UnifiedChinese │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_949  │ cp949  │ Korean         │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_950  │ cp950  │ TradChinese    │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1250 │ cp1250 │ CentralEurope  │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1251 │ cp1251 │ Cyrillic       │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1252 │ cp1252 │ WesternEurope  │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1253 │ cp1253 │ Greek          │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1254 │ cp1254 │ Turkish        │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1255 │ cp1255 │ Hebrew         │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1256 │ cp1256 │ Arabic         │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1257 │ cp1257 │ Baltic         │
                                       ├───────────┼────────┼────────────────┤
                                       │ ANSI_1258 │ cp1258 │ Vietnam        │
                                       └───────────┴────────┴────────────────┘

   <b>DXF</b> <b>R2007</b> <b>and</b> <b>later</b>
       Starting with DXF R2007 (AC1021) the drawing file is UTF-8 encoded, the header variable  $DWGCODEPAGE  is
       still in use, but I don’t know, if the setting still has any meaning.

       Encoding characters in the unicode schema <b>\U+nnnn</b> is still functional.

       <b>SEE</b> <b>ALSO:</b>
          <u>String</u> <u>value</u> <u>encoding</u>

   <b>DXF</b> <b>Tags</b>
       A  Drawing  Interchange  File is simply an ASCII text file with a file type of .dxf and special formatted
       text. The basic file structure are DXF tags, a DXF tag consist of a DXF group code as an integer value on
       its own line and a the DXF value on the following line.  In the ezdxf  documentation  DXF  tags  will  be
       written as (group code, value).

       With the introduction of extended symbol names in DXF R2000, the 255-character limit for strings has been
       increased  to  2049 single-byte characters not including the newline at the end of the line.  Nonetheless
       its safer to use only strings with 255 and less characters, because its not clear if this  fact  is  true
       for  ALL  string  group  codes  or only for symbols like layer- or text style names and not all 3rd party
       libraries may handle this fact correct. The MTEXT content and binary data is still  divided  into  chunks
       with less than 255 characters.

       Group codes are indicating the value type:
                                ┌────────────┬───────────────────────────────────────┐
                                │ Group Code │ Value Type                            │
                                ├────────────┼───────────────────────────────────────┤
                                │ 0-9        │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 10-39      │ Double precision 3D point value       │
                                ├────────────┼───────────────────────────────────────┤
                                │ 40-59      │ Double-precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 60-79      │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 90-99      │ 32-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 100        │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 102        │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 105        │ String representing hexadecimal (hex) │
                                │            │ handle value                          │
                                ├────────────┼───────────────────────────────────────┤
                                │ 110-119    │ Double precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 120-129    │ Double precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 130-139    │ Double precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 140-149    │ Double        precision        scalar │
                                │            │ floating-point value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 160-169    │ 64-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 170-179    │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 210-239    │ Double-precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 270-279    │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 280-289    │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 290-299    │ Boolean flag value                    │
                                ├────────────┼───────────────────────────────────────┤
                                │ 300-309    │ Arbitrary text string                 │
                                ├────────────┼───────────────────────────────────────┤
                                │ 310-319    │ String  representing  hex  value   of │
                                │            │ binary chunk                          │
                                ├────────────┼───────────────────────────────────────┤
                                │ 320-329    │ Arbitrary pointer, hex object ID, not │
                                │            │ translated  during  INSERT  and  XREF │
                                │            │ operations                            │
                                ├────────────┼───────────────────────────────────────┤
                                │ 330-339    │ Soft-pointer,    hex    object    ID, │
                                │            │ translated  during  INSERT  and  XREF │
                                │            │ operations                            │
                                ├────────────┼───────────────────────────────────────┤
                                │ 340-349    │ Hard-pointer,    hex    object    ID, │
                                │            │ translated  during  INSERT  and  XREF │
                                │            │ operations                            │
                                ├────────────┼───────────────────────────────────────┤
                                │ 350-359    │ Soft-owner, hex object ID, translated │
                                │            │ during INSERT and XREF operations     │
                                ├────────────┼───────────────────────────────────────┤
                                │ 360-369    │ Hard-owner, hex object ID, translated │
                                │            │ during INSERT and XREF operations     │
                                ├────────────┼───────────────────────────────────────┤
                                │ 370-379    │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 380-389    │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 390-399    │ String representing hex handle value  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 400-409    │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 410-419    │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 420-429    │ 32-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 430-439    │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 440-449    │ 32-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 450-459    │ Long                                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 460-469    │ Double-precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 470-479    │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 480-481    │ Hard-pointer,    hex    object    ID, │
                                │            │ translated  during  INSERT  and  XREF │
                                │            │ operations                            │
                                ├────────────┼───────────────────────────────────────┤
                                │ 999        │ Comment (string)                      │
                                ├────────────┼───────────────────────────────────────┤
                                │ 1000-1009  │ String                                │
                                ├────────────┼───────────────────────────────────────┤
                                │ 1010-1059  │ Double-precision floating-point value │
                                ├────────────┼───────────────────────────────────────┤
                                │ 1060-1070  │ 16-bit integer value                  │
                                ├────────────┼───────────────────────────────────────┤
                                │ 1071       │ 32-bit integer value                  │
                                └────────────┴───────────────────────────────────────┘

       Explanation for some important group codes:
                              ┌───────────────┬───────────────────────────────────────┐
                              │ Group Code    │ Meaning                               │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 0             │ DXF structure tag,  entity  start/end │
                              │               │ or table entries                      │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 1             │ The primary text value for an entity  │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 2             │ A  name:  Attribute  tag, Block name, │
                              │               │ and so on. Also used  to  identify  a │
                              │               │ DXF section or table name.            │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 3-4           │ Other textual or name values          │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 5             │ Entity handle as hex string (fixed)   │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 6             │ Line type name (fixed)                │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 7             │ Text style name (fixed)               │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 8             │ Layer name (fixed)                    │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 9             │ Variable  name  identifier (used only │
                              │               │ in HEADER section of the DXF file)    │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 10            │ Primary X coordinate (start point  of │
                              │               │ a  Line  or  Text entity, center of a │
                              │               │ Circle, etc.)                         │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 11-18         │ Other X coordinates                   │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 20            │ Primary  Y  coordinate.   2n   values │
                              │               │ always  correspond  to  1n values and │
                              │               │ immediately follow them in  the  file │
                              │               │ (expected by ezdxf!)                  │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 21-28         │ Other Y coordinates                   │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 30            │ Primary   Z   coordinate.  3n  values │
                              │               │ always correspond to 1n and 2n values │
                              │               │ and immediately follow  them  in  the │
                              │               │ file (expected by ezdxf!)             │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 31-38         │ Other Z coordinates                   │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 39            │ This  entity’s  thickness  if nonzero │
                              │               │ (fixed)                               │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 40-48         │ Float  values  (text  height,   scale │
                              │               │ factors, etc.)                        │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 49            │ Repeated  value  - multiple 49 groups │
                              │               │ may appear in one entity for variable │
                              │               │ length  tables  (such  as  the   dash │
                              │               │ lengths  in  the  LTYPE  table). A 7x │
                              │               │ group always appears before the first │
                              │               │ 49 group to specify the table length  │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 50-58         │ Angles in degree                      │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 62            │ Color number (fixed)                  │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 66            │ “Entities follow” flag (fixed),  only │
                              │               │ in INSERT and POLYLINE entities       │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 67            │ Identifies   whether   entity  is  in │
                              │               │ modelspace (0) or paperspace (1)      │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 68            │ Identifies whether viewport is on but │
                              │               │ fully off screen, is not  active,  or │
                              │               │ is off                                │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 69            │ Viewport identification number        │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 70-78         │ Integer values such as repeat counts, │
                              │               │ flag bits, or modes                   │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 105           │ DIMSTYLE  entity handle as hex string │
                              │               │ (fixed)                               │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 210, 220, 230 │ X, Y, and Z components  of  extrusion │
                              │               │ direction (fixed)                     │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 310           │ Proxy   entity   graphics  as  binary │
                              │               │ encoded data                          │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 330           │ Owner handle as hex string            │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 347           │ MATERIAL handle as hex string         │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 348           │ VISUALSTYLE  handle as hex string     │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 370           │ Lineweight  in  mm  times  100  (e.g. │
                              │               │ 0.13mm = 13).                         │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 390           │ PLOTSTYLE handle as hex string        │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 420           │ True color value as 0x00RRGGBB 24-bit │
                              │               │ value                                 │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 430           │ Color name as string                  │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 440           │ Transparency  value  0x020000TT  0  = │
                              │               │ fully transparent / 255 = opaque      │
                              ├───────────────┼───────────────────────────────────────┤
                              │ 999           │ Comments                              │
                              └───────────────┴───────────────────────────────────────┘

       For explanation of all group codes see: <u>DXF</u> <u>Group</u> <u>Codes</u> <u>in</u> <u>Numerical</u> <u>Order</u> <u>Reference</u> provided by Autodesk

   <b>Extended</b> <b>Data</b>
       <u>DXF</u> <u>R2018</u> <u>Reference</u>

       Extended data (XDATA) is created by AutoLISP or ObjectARX applications but  any  other  application  like
       <u>ezdxf</u>  can  also  define  XDATA.  If  an  entity  contains  extended data, it <b>follows</b> the entity’s normal
       definition.

       But  extended  group  codes  (&gt;=1000)  can  appear  <b>before</b>  the  XDATA  section,  an   example   is   the
       BLOCKBASEPOINTPARAMETER entity in AutoCAD Civil 3D or AutoCAD Map 3D.
                             ┌──────────────────┬───────────────────────────────────────┐
                             │ Group Code       │ Description                           │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1000             │ Strings in extended data can be up to │
                             │                  │ 255  bytes  long (with the 256th byte │
                             │                  │ reserved for the null character)      │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1001             │ (fixed) Registered  application  name │
                             │                  │ (ASCII  string  up  to 31 bytes long) │
                             │                  │ for XDATA                             │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1002             │ (fixed)  An  extended  data   control │
                             │                  │ string  can  be  either  <b>'{'</b>  or <b>'}'</b>. │
                             │                  │ These braces enable  applications  to │
                             │                  │ organize  their  data  by subdividing │
                             │                  │ the data into  lists.  Lists  can  be │
                             │                  │ nested.                               │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1003             │ Name of the layer associated with the │
                             │                  │ extended data                         │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1004             │ Binary   data   is   organized   into │
                             │                  │ variable-length chunks.  The  maximum │
                             │                  │ length of each chunk is 127 bytes. In │
                             │                  │ ASCII   DXF  files,  binary  data  is │
                             │                  │ represented   as    a    string    of │
                             │                  │ hexadecimal  digits,  two  per binary │
                             │                  │ byte                                  │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1005             │ Database Handle of  entities  in  the │
                             │                  │ drawing  database,  see  also:  <u>About</u> │
                             │                  │ <u>1005</u> <u>Group</u> <u>Codes</u>                      │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1010, 1020, 1030 │ Three real values, in the order X, Y, │
                             │                  │ Z. They can be used  as  a  point  or │
                             │                  │ vector   record   that  will  not  be │
                             │                  │ modified at any transformation of the │
                             │                  │ entity.                               │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1011, 1021, 1031 │ a WCS point that  is  moved,  scaled, │
                             │                  │ rotated  and  mirrored along with the │
                             │                  │ entity                                │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1012, 1012, 1022 │ a WCS displacement  that  is  scaled, │
                             │                  │ rotated  and  mirrored along with the │
                             │                  │ entity, but is not moved              │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1013, 1023, 1033 │ a WCS direction that is  rotated  and │
                             │                  │ mirrored  along  with the entity, but │
                             │                  │ is not moved or scaled                │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1040             │ A real value                          │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1041             │ Distance, a real value that is scaled │
                             │                  │ along with the parent entity          │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1042             │ Scale Factor, also a real value  that │
                             │                  │ is scaled along with the parent.  The │
                             │                  │ difference  between  a distance and a │
                             │                  │ scale factor is application-defined   │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1070             │ A 16-bit integer (signed or unsigned) │
                             ├──────────────────┼───────────────────────────────────────┤
                             │ 1071             │ A 32-bit signed (long) integer        │
                             └──────────────────┴───────────────────────────────────────┘

       The (1001, …) tag indicates the beginning of extended data. In  contrast  to  normal  entity  data,  with
       extended data the same group code can appear multiple times, and <b>order</b> <b>is</b> <b>important</b>.

       Extended  data is grouped by registered application name. Each registered application group begins with a
       (1001, APPID) tag, with the  application  name  as  APPID  string  value.  Registered  application  names
       correspond to APPID symbol table entries.

       An  application  can  use  as many APPID names as needed. APPID names are permanent, although they can be
       purged if they aren’t currently used in the drawing.  Each APPID name can have  <b>no</b>  <b>more</b>  <b>than</b>  <b>one</b>  <b>data</b>
       <b>group</b>  attached  to  each  entity.  Within an application group, the sequence of extended data groups and
       their meaning is defined by the application.

   <b>String</b> <b>value</b> <b>encoding</b>
       String values stored in a DXF file is plain ASCII or UTF-8, AutoCAD also supports CIF (Common Interchange
       Format) and MIF (Maker Interchange Format) encoding. The UTF-8 format is only supported in DXF R2007  and
       later.

       Ezdxf on import converts all strings into Python unicode strings without encoding or decoding CIF/MIF.

       String  values  containing  Unicode  characters are represented with control character sequences <b>\U+nnnn</b>.
       (e.g. <b>r'TEST\U+7F3A\U+4E4F\U+89E3\U+91CA\U+6B63THIS\U+56FE'</b>)

       To support the DXF unicode encoding ezdxf registers an encoding codec <u>dxf_backslash_replace</u>,  defined  in
       <b>ezdxf.lldxf.encoding()</b>.

       String values can be stored with these dxf group codes:

       • 0 - 9

       • 100 - 101

       • 300 - 309

       • 410 - 419

       • 430 - 439

       • 470 - 479

       • 999 - 1003

   <b>Multi</b> <b>tag</b> <b>text</b> <b>(MTEXT)</b>
       If  the  text string is less than 250 characters, all characters appear in tag (1, …). If the text string
       is longer than 250 characters, the string is divided into 250-character chunks, which appear  in  one  or
       more  (3,  …)  tags.  If  (3,  …)  tags  are  used, the last group is a (1, …) tag and has fewer than 250
       characters:

          3
          ... TwoHundredAndFifty Characters ....
          3
          ... TwoHundredAndFifty Characters ....
          1
          less than TwoHundredAndFifty Characters

       As far I know this is only supported by the MTEXT entity.

       <b>SEE</b> <b>ALSO:</b>
          <u>DXF</u> <u>File</u> <u>Encoding</u>

   <b>DXF</b> <b>R13</b> <b>and</b> <b>later</b> <b>tag</b> <b>structure</b>
       With the introduction of DXF R13 Autodesk added additional group codes and DXF tag structures to the  DXF
       Standard.

   <b>Subclass</b> <b>Markers</b>
       Subclass  markers  (100,  Subclass  Name)  divides  DXF objects into several sections. Group codes can be
       reused in different sections. A subclass ends with the following subclass marker or at the  beginning  of
       xdata or the end of the object. See <u>Subclass</u> <u>Marker</u> <u>Example</u> in the DXF Reference.

   <b>Quote</b> <b>about</b> <b>group</b> <b>codes</b> <b>from</b> <b>the</b> <b>DXF</b> <b>reference</b>
          Some  group  codes  that  define an entity always appear; others are optional and appear only if their
          values differ from the defaults.

          <b>Do</b> <b>not</b> write programs that <b>rely</b> <b>on</b> <b>the</b> <b>order</b> <b>given</b> <b>here</b>. The end of an entity is indicated by the next
          0 group, which begins the next entity or indicates the end of the section.

          <b>Note:</b> Accommodating DXF files from future releases of AutoCAD will be easier if  you  write  your  DXF
          processing  program in a table-driven way, ignore undefined group codes, and make no assumptions about
          the order of group codes in an entity. With each new AutoCAD release, new group codes will be added to
          entities to accommodate additional features.

   <b>Usage</b> <b>of</b> <b>group</b> <b>codes</b> <b>in</b> <b>subclasses</b> <b>twice</b>
       Some later entities entities contains the same group code twice for different purposes, so order  in  the
       sense of which one comes first is important.  (e.g. ATTDEF group code 280)

   <b>Tag</b> <b>order</b> <b>is</b> <b>sometimes</b> <b>important</b> <b>especially</b> <b>for</b> <b>AutoCAD</b>
       In  LWPOLYLINE  the order of tags is important, if the <u>count</u> tag is not the first tag in the AcDbPolyline
       subclass, AutoCAD will not close the polyline when the <u>close</u> flag is set, by the way  other  applications
       like BricsCAD ignores the tag order and renders the polyline always correct.

   <b>Extension</b> <b>Dictionary</b>
       The  extension  dictionary  is  an  optional  sequence that stores the handle of a DICTIONARY object that
       belongs to the current object, which in turn may contain entries.  This  facility  allows  attachment  of
       arbitrary database objects to any database object. Any object or entity may have this section.

       The extension dictionary tag sequence:

          102
          {ACAD_XDICTIONARY
          360
          Hard-owner ID/handle to owner dictionary
          102
          }

   <b>Persistent</b> <b>Reactors</b>
       Persistent reactors are an optional sequence that stores object handles of objects registering themselves
       as reactors on the current object. Any object or entity may have this section.

       The persistent reactors tag sequence:

          102
          {ACAD_REACTORS
          330
          first Soft-pointer ID/handle to owner dictionary
          330
          second Soft-pointer ID/handle to owner dictionary
          ...
          102
          }

   <b>Application-Defined</b> <b>Codes</b>
       Starting  at  DXF  R13,  DXF  objects  can  contain  application-defined  codes  outside  of  XDATA. This
       application-defined codes can contain any tag except (0, …) and (102, ‘{…’). “{YOURAPPID” means the APPID
       string with an preceding “{”. The application defined data tag sequence:

          102
          {YOURAPPID
          ...
          102
          }

       <b>(102,</b> <b>'YOURAPPID}')</b> is also a valid closing tag:

          102
          {YOURAPPID
          ...
          102
          YOURAPPID}

       All groups defined with a beginning (102, …) appear in  the  DXF  reference  before  the  first  subclass
       marker,  I  don’t  know  if these groups can appear after the first or any subclass marker. Ezdxf accepts
       them at any position, and by default ezdxf adds new app data in front of the first subclass marker to the
       first tag section of an DXF object.

       <b>Exception</b> <b>XRECORD:</b> Tags with group code 102 and a value string without a  preceding  “{”  or  the  scheme
       “YOURAPPID}”, should be treated as usual group codes.

   <b>Embedded</b> <b>Objects</b>
       The  concept  of  embedded  objects was introduced with AutoCAD 2018 (DXF version AC1032) and this is the
       only information I found about it at the Autodesk knowledge base: <u>Embedded</u> <u>and</u> <u>Encapsulated</u> <u>Objects</u>

       Quote from <u>Embedded</u> <u>and</u> <u>Encapsulated</u> <u>Objects</u>:
          For DXF filing, the embedded object must be filed out and in after all the data of  the  encapsulating
          object has been filed out and in.

          A  separator  is  needed  between the encapsulating object’s data and the subsequent embedded object’s
          data. The separator must be similar in function to the group 0 or 100 in that it must cause the  filer
          to  stop  reading  data.   The  normal  DXF  group code 0 cannot be used because DXF proxies use it to
          determine when to stop reading data. The group code 100 could have been used, but it might have caused
          confusion when manually reading a DXF file, and there was a  need  to  distinguish  when  an  embedded
          object  is  about to be written out in order to do some internal bookkeeping. Therefore, the DXF group
          code 101 was introduced.

       <b>Hard</b> <b>facts:</b>

       • Only used in ATTRIB, ATTDEF (embedded MTEXT) and MTEXT (columns) in DXF R2018.

       • Embedded object start with (101, “Embedded Object”) tag

       • Embedded object is appended to the encapsulated object

       • Embedded object tags can contain any group code except the DXF structure tag (0, …)

       <b>Unconfirmed</b> <b>assumptions:</b>

       • The embedded object is written before the <u>Extended</u> <u>Data</u>. No examples for  entities  including  embedded
         objects and XDATA at the same time.

       • XDATA sections replaced by embedded objects, at least for the MTEXT entity

       • The encapsulating object can contain more than one embedded object.

       • Embedded objects separated by (101, “Embedded Object”) tags

       • every entity can contain embedded objects

       Real world example from an AutoCAD 2018 file:

          100       &lt;&lt;&lt; start of encapsulating object
          AcDbMText
          10
          2762.148
          20
          2327.073
          30
          0.0
          40
          2.5
          41
          18.852
          46
          0.0
          71
          1
          72
          5
          1
          {\fArial|b0|i0|c162|p34;CHANGE;\P\P\PTEXT}
          73
          1
          44
          1.0
          101       &lt;&lt;&lt; start of embedded object
          Embedded Object
          70
          1
          10
          1.0
          20
          0.0
          30
          0.0
          11
          2762.148
          21
          2327.073
          31
          0.0
          40
          18.852
          41
          0.0
          42
          15.428
          43
          15.043
          71
          2
          72
          1
          44
          18.852
          45
          12.5
          73
          0
          74
          0
          46
          0.0

   <b>Handles</b>
       A handle is an arbitrary but in your DXF file unique hex value as string like ‘10FF’.  It is common to to
       use uppercase letters for hex numbers. Handle can have up to 16 hexadecimal digits (8 bytes).

       For  DXF R10 until R12 the usage of handles was optional. The header variable $HANDLING set to 1 indicate
       the usage of handles, else $HANDLING is 0 or missing.

       For DXF R13 and later the usage of handles is mandatory and the header variable $HANDLING was removed.

       The $HANDSEED variable in the header section should be greater than the biggest handle used  in  the  DXF
       file,  so  a  CAD  application can assign handle values starting with the $HANDSEED value. But as always,
       don’t rely on the header variable it could be wrong, AutoCAD ignores this value.

   <b>Handle</b> <b>Definition</b>
       Entity handle definition is always the <b>(5,</b> <b>...)</b>, except for entities of the DIMSTYLE  table  <b>(105,</b>  <b>...)</b>,
       because the DIMSTYLE entity has also a group code 5 tag for DIMBLK.

   <b>Handle</b> <b>Pointer</b>
       A pointer is a reference to a DXF object in the same DXF file. There are four types of pointers:

       • Soft-pointer handle

       • Hard-pointer handle

       • Soft-owner handle

       • Hard-owner handle

       Also,  a group code range for “arbitrary” handles is defined to allow convenient storage of handle values
       that are unchanged at any operation (AutoCAD).

   <b>Pointer</b> <b>and</b> <b>Ownership</b>
       A pointer is a reference that indicates usage, but not possession or responsibility, for another  object.
       A  pointer reference means that the object uses the other object in some way, and shares access to it. An
       ownership reference means that an owner object is responsible for the objects for which it has  an  owner
       handle.  An object can have any number of pointer references associated with it, but it can have only one
       owner.

   <b>Hard</b> <b>and</b> <b>Soft</b> <b>References</b>
       Hard references, whether they are pointer or owner, protect an object from being purged.  Soft references
       do not.

       In AutoCAD, block definitions and complex entities are hard owners of their elements.  A symbol table and
       dictionaries  are  soft  owners  of their elements. Polyline entities are hard owners of their vertex and
       seqend entities. Insert entities are hard owners of their attrib and seqend entities.

       When establishing a reference to another object, it is recommended  that  you  think  about  whether  the
       reference should protect an object from the PURGE command.

       A hard- and soft pointers will be translated during INSERT and XREF operations.

   <b>Arbitrary</b> <b>Handles</b>
       Arbitrary  handles  are  distinct  in  that  they  are  not  translated to session-persistent identifiers
       internally, or to entity names in AutoLISP, and so on. They are stored as handles. When handle values are
       translated in drawing-merge operations, arbitrary handles are ignored.

       In all environments, arbitrary handles can be exchanged for entity names of the current drawing by  means
       of  the handent functions. A common usage of arbitrary handles is to refer to objects in external DXF and
       DWG files.

   <b>About</b> <b>1005</b> <b>Group</b> <b>Codes</b>
       <b>(1005,</b> <b>...)</b> xdata have the same behavior and semantics as  soft  pointers,  which  means  that  they  are
       translated  whenever  the  host  object  is  merged into a different drawing. However, 1005 items are not
       translated to session-persistent identifiers or internal entity names in AutoLISP and ObjectARX. They are
       stored as handles.

       When a drawing with handles and extended data handles is imported  into  another  drawing  using  INSERT,
       INSERT  <u>,</u>  <u>XREF</u>  <u>Bind,</u>  <u>XBIND,</u>  <u>or</u>  <u>partial</u> <u>OPEN,</u> <u>the</u> <u>extended</u> <u>data</u> <u>handles</u> <u>are</u> <u>**translated*</u> in the same
       manner as their corresponding entity handles, thus maintaining their binding. This is also  done  in  the
       EXPLODE  block  operation  or for any other AutoCAD operation. When AUDIT detects an extended data handle
       that doesn’t match the handle of an entity in the drawing file, it is considered an error.  If  AUDIT  is
       fixing entities, it sets the handle to “0”

   <b>DXF</b> <b>File</b> <b>Structure</b>
       A  DXF  File  is simply an ASCII text file with a file type of .dxf and special formatted text. The basic
       file structure are DXF tags, a DXF tag consist of a DXF group code as an integer value on  its  own  line
       and  a the DXF value on the following line. In the ezdxf documentation DXF tags will be written as <b>(group</b>
       <b>code,</b> <b>value)</b>. There exist a binary DXF format, but it seems that it is not often used  and  for  reducing
       file size, zipping is much more efficient.  <u>ezdxf</u> does support reading binary encoded DXF files.

       <b>SEE</b> <b>ALSO:</b>
          For more information about DXF tags see: <u>DXF</u> <u>Tags</u>

       A  usual  DXF file is organized in sections, starting with the DXF tag (0, ‘SECTION’) and ending with the
       DXF tag (0, ‘ENDSEC’). The (0, ‘EOF’) tag signals the end of file.

       1. <b>HEADER:</b> General information about the drawing is  found  in  this  section  of  the  DXF  file.   Each
          parameter has a variable name starting with ‘$’ and an associated value. Has to be the first section.

       2. <b>CLASSES:</b> Holds the information for application defined classes. (DXF R13 and later)

       3. <b>TABLES:</b>: Contains several tables for style and property definitions.

          • Linetype table (LTYPE)

          • Layer table (LAYER)

          • Text Style table (STYLE)

          • View  table  (VIEW):  (IMHO)  layout  of the CAD working space, only interesting for interactive CAD
            applications

          • Viewport configuration table (VPORT): The VPORT table is unique  in  that  it  may  contain  several
            entries with the same name (indicating a multiple-viewport configuration). The entries corresponding
            to  the  active viewport configuration all have the name *ACTIVE. The first such entry describes the
            current viewport.

          • Dimension Style table (DIMSTYLE)

          • User Coordinate System table (UCS) (IMHO) only interesting for interactive CAD applications

          • Application Identification table (APPID): Table of names for  all  applications  registered  with  a
            drawing.

          • Block Record table (BLOCK_RECORD) (DXF R13 and Later)

       4. <b>BLOCKS:</b>  Contains  all  block definitions. The block name *Model_Space or *MODEL_SPACE is reserved for
          the drawing modelspace and the block name *Paper_Space or *PAPER_SPACE  is  reserved  for  the  <u>active</u>
          paperspace  layout.   Both  block  definitions are empty, the content of the modelspace and the <u>active</u>
          paperspace is stored in the ENTITIES section. The entities of other  layouts  are  stored  in  special
          block definitions called *Paper_Spacennn, nnn is an arbitrary but unique number.

       5. <b>ENTITIES:</b> Contains all graphical entities of the modelspace and the <u>active</u> paperspace layout. Entities
          of other layouts are stored in the BLOCKS sections.

       6. <b>OBJECTS:</b> Contains all non-graphical objects of the drawing (DXF R13 and later)

       7. <b>THUMBNAILIMAGE:</b>  Contains  a preview image of the DXF file, it is optional and can usually be ignored.
          (DXF R13 and later)

       8. <b>ACDSDATA:</b> (DXF R2013 and later) No information in the DXF reference about this section

       9. <b>END</b> <b>OF</b> <b>FILE</b>

       For further information read the original <u>DXF</u> <u>Reference</u>.

       Structure of a usual DXF R12 file:

          0           &lt;&lt;&lt; Begin HEADER section, has to be the first section
          SECTION
          2
          HEADER
                      &lt;&lt;&lt; Header variable items go here
          0           &lt;&lt;&lt; End HEADER section
          ENDSEC
          0           &lt;&lt;&lt; Begin TABLES section
          SECTION
          2
          TABLES
          0
          TABLE
          2
          VPORT
          70          &lt;&lt;&lt; viewport table maximum item count
                      &lt;&lt;&lt; viewport table items go here
          0
          ENDTAB
          0
          TABLE
          2
          APPID, DIMSTYLE, LTYPE, LAYER, STYLE, UCS, VIEW, or VPORT
          70          &lt;&lt;&lt; Table maximum item count, a not reliable value and ignored by AutoCAD
                      &lt;&lt;&lt; Table items go here
          0
          ENDTAB
          0           &lt;&lt;&lt; End TABLES section
          ENDSEC
          0           &lt;&lt;&lt; Begin BLOCKS section
          SECTION
          2
          BLOCKS
                      &lt;&lt;&lt; Block definition entities go here
          0           &lt;&lt;&lt; End BLOCKS section
          ENDSEC
          0           &lt;&lt;&lt; Begin ENTITIES section
          SECTION
          2
          ENTITIES
                      &lt;&lt;&lt; Drawing entities go here
          0           &lt;&lt;&lt; End ENTITIES section
          ENDSEC
          0           &lt;&lt;&lt; End of file marker (required)
          EOF

   <b>Minimal</b> <b>DXF</b> <b>Content</b>
   <b>DXF</b> <b>R12</b>
       Contrary to the previous chapter, the DXF R12 format  (AC1009)  and  prior  requires  just  the  ENTITIES
       section:

          0
          SECTION
          2
          ENTITIES
          0
          ENDSEC
          0
          EOF

   <b>DXF</b> <b>R13/R14</b> <b>and</b> <b>later</b>
       DXF version R13/14 and later needs much more DXF content than DXF R12.

       Required sections: HEADER, CLASSES, TABLES, ENTITIES, OBJECTS

       The HEADER section requires two entries:

       • $ACADVER

       • $HANDSEED

       The CLASSES section can be empty, but some DXF entities requires class definitions to work in AutoCAD.

       The TABLES section requires following tables:

       • VPORT entry *ACTIVE is not required! Empty table is ok for AutoCAD.

       • LTYPE with at least the following line types defined:

         • BYBLOCK

         • BYLAYER

         • CONTINUOUS

       • LAYER with at least an entry for layer ‘0’

       • STYLE with at least an entry for style STANDARD

       • VIEW can be empty

       • UCS can be empty

       • APPID with at least an entry for ACAD

       • DIMSTYLE with at least an entry for style STANDARD

       • BLOCK_RECORDS with two entries:

         • *MODEL_SPACE

         • *PAPER_SPACE

       The BLOCKS section requires two BLOCKS:

       • *MODEL_SPACE

       • *PAPER_SPACE

       The ENTITIES section can be empty.

       The OBJECTS section requires following entities:

       • DICTIONARY - the root dict - one entry named ACAD_GROUP

       • DICTIONARY ACAD_GROUP can be empty

       Minimal DXF to download: <u>https://github.com/mozman/ezdxf/tree/master/examples_dxf</u>

   <b>Data</b> <b>Model</b>
   <b>Database</b> <b>Objects</b>
       (from the DXF Reference)

       AutoCAD  drawings  consist  largely  of structured containers for database objects. Database objects each
       have the following features:

          • A handle whose value is unique to the drawing/DXF file, and is constant  for  the  lifetime  of  the
            drawing. This format has existed since AutoCAD Release 10, and as of AutoCAD Release 13, handles are
            always enabled.

          • An optional XDATA table, as entities have had since AutoCAD Release 11.

          • An optional persistent reactor table.

          • An  optional  ownership pointer to an extension dictionary which, in turn, owns subobjects placed in
            it by an application.

       Symbol tables and symbol table records are database objects and, thus, have a handle.  They can also have
       xdata and persistent reactors in their DXF records.

   <b>DXF</b> <b>R12</b> <b>Data</b> <b>Model</b>
       The DXF R12 data model is identical to the file structure:

          • HEADER section: common settings for the DXF drawing

          • TABLES section: definitions for LAYERS, LINETYPE, STYLES ….

          • BLOCKS section: block definitions and its content

          • ENTITIES section: modelspace and paperspace content

       References are realized by simple names. The INSERT entity references the BLOCK definition by  the  BLOCK
       name, a TEXT entity defines the associated STYLE and LAYER by its name and so on, handles are not needed.
       Layout  association  of graphical entities in the ENTITIES section by the paper_space tag <b>(67,</b> <b>0</b> <b>or</b> <b>1)</b>, 0
       or missing tag means modelspace, 1 means paperspace. The content of BLOCK definitions is enclosed by  the
       BLOCK and the ENDBLK entity, no additional references are needed.

       A  clean and simple file structure and data model, which seems to be the reason why the DXF R12 Reference
       (released 1992) is still a widely used file format and Autodesk/AutoCAD supports the  format  by  reading
       and writing DXF R12 files until today (DXF R13/R14 has no writing support by AutoCAD!).

       <b>TODO:</b> <b>list</b> <b>of</b> <b>available</b> <b>entities</b>

       <b>SEE</b> <b>ALSO:</b>
          More information about the DXF <u>DXF</u> <u>File</u> <u>Structure</u>

   <b>DXF</b> <b>R13+</b> <b>Data</b> <b>Model</b>
       With  the DXF R13 file format, handles are mandatory and they are really used for organizing the new data
       structures introduced with DXF R13.

       The HEADER section is still the same with just more available settings.

       The new CLASSES section contains AutoCAD specific data, has to be written like AutoCAD it does, but  must
       not be understood.

       The TABLES section got a new BLOCK_RECORD table - see <u>Block</u> <u>Management</u> <u>Structures</u> for more information.

       The  BLOCKS  sections  is mostly the same, but with handles, owner tags and new ENTITY types.  Not active
       paperspace layouts store their content also in the BLOCKS section - see <u>Layout</u> <u>Management</u> <u>Structures</u>  for
       more information.

       The ENTITIES section is also mostly same, but with handles, owner tags and new ENTITY types.

       <b>TODO:</b> <b>list</b> <b>of</b> <b>new</b> <b>available</b> <b>entities</b>

       And the new OBJECTS section - now its getting complicated!

       Most  information  about  the OBJECTS section is just guessed or gathered by trail and error, because the
       documentation of the OBJECTS section and its objects in the DXF reference provided by  Autodesk  is  very
       shallow.   This  is  also  the  reason  why  I  started  the DXF Internals section, may be it helps other
       developers to start one or two steps above level zero.

       The OBJECTS sections stores all the non-graphical entities of the DXF  drawing.   Non-graphical  entities
       from  now  on  just  called  ‘DXF  objects’  to  differentiate  them from graphical entities, just called
       ‘entities’. The OBJECTS section follows commonly the ENTITIES section, but this is not mandatory.

       DXF R13 introduces several new DXF objects, which resides exclusive in the OBJECTS  section,  taken  from
       the  DXF  R14  reference,  because  I have no access to the DXF R13 reference, the DXF R13 reference is a
       compiled .hlp file which can’t be read on Windows 10 or later, this  a  perfect  example  for  not  using
       closed (proprietary) data formats ;):

          • DICTIONARY: a general structural entity as a &lt;name: handle&gt; container

          • ACDBDICTIONARYWDFLT: a DICTIONARY with a default value

          • DICTIONARYVAR: used by AutoCAD to store named values in the database

          • ACAD_PROXY_OBJECT: proxy object for entities created by other applications than AutoCAD

          • GROUP: groups graphical entities without the need of a BLOCK definition

          • IDBUFFER: just a list of references to objects

          • IMAGEDEF: IMAGE definition structure, required by the IMAGE entity

          • IMAGEDEF_REACTOR: also required by the IMAGE entity

          • LAYER_INDEX: container for LAYER names

          • MLINESTYLE

          • OBJECT_PTR

          • RASTERVARIABLES

          • SPATIAL_INDEX: is always written out empty to a DXF file. This object can be ignored.

          • SPATIAL_FILTER

          • SORTENTSTABLE: control for regeneration/redraw order of entities

          • XRECORD:  used to store and manage arbitrary data. This object is similar in concept to XDATA but is
            not limited by size or order. Not supported by R13c0 through R13c3.

       Still missing the LAYOUT object, which is mandatory in DXF R2000 to manage multiple paperspace layouts. I
       don’t know how DXF R13/R14 manages multiple layouts or if they even support this  feature,  but  I  don’t
       care  much  about  DXF  R13/R14, because AutoCAD has no write support for this two formats anymore. Ezdxf
       tries to upgrade this two DXF versions to DXF R2000 with the advantage of only two different data  models
       to support: DXF R12 and DXF R2000+

       New objects introduced by DXF R2000:

          • LAYOUT: management object for modelspace and multiple paperspace layouts

          • ACDBPLACEHOLDER: surprise - just a place holder

       New objects in DXF R2004:

          • DIMASSOC

          • LAYER_FILTER

          • MATERIAL

          • PLOTSETTINGS

          • VBA_PROJECT

       New objects in DXF R2007:

          • DATATABLE

          • FIELD

          • LIGHTLIST

          • RENDER

          • RENDERENVIRONMENT

          • MENTALRAYRENDERSETTINGS

          • RENDERGLOBAL

          • SECTION

          • SUNSTUDY

          • TABLESTYLE

          • UNDERLAYDEFINITION

          • VISUALSTYLE

          • WIPEOUTVARIABLES

       New objects in DXF R2013:

          • GEODATA

       New objects in DXF R2018:

          • ACDBNAVISWORKSMODELDEF

       Undocumented objects:

          • SCALE

          • ACDBSECTIONVIEWSTYLE

          • FIELDLIST

   <b>Objects</b> <b>Organisation</b>
       Many objects in the OBJECTS section are organized in a tree-like structure of DICTIONARY objects.

       Starting  point for this data structure is the ‘root’ DICTIONARY with several entries to other DICTIONARY
       objects.  The root DICTIONARY has to be the first object in the OBJECTS section.   The  management  dicts
       for  GROUP  and  LAYOUT  objects  are  really important, but IMHO most of the other management tables are
       optional and for the most use cases not necessary.  Ezdxf creates only these entries in the root dict and
       most of them pointing to an empty DICTIONARY:

          • ACAD_COLOR: points to an empty DICTIONARY

          • ACAD_GROUP: required

          • ACAD_LAYOUT: required

          • ACAD_MATERIAL: points to an empty DICTIONARY

          • ACAD_MLEADERSTYLE: points to an empty DICTIONARY

          • ACAD_MLINESTYLE: points to an empty DICTIONARY

          • ACAD_PLOTSETTINGS: points to an empty DICTIONARY

          • ACAD_PLOTSTYLENAME: required, points to ACDBDICTIONARYWDFLT with one entry: ‘Normal’

          • ACAD_SCALELIST: points to an empty DICTIONARY

          • ACAD_TABLESTYLE: points to an empty DICTIONARY

          • ACAD_VISUALSTYLE: points to an empty DICTIONARY

   <b>Root</b> <b>DICTIONARY</b> <b>content</b> <b>for</b> <b>DXF</b> <b>R2018</b>
          0
          SECTION
          2       &lt;&lt;&lt; start of the OBJECTS section
          OBJECTS
          0       &lt;&lt;&lt; root DICTIONARY has to be the first object in the OBJECTS section
          DICTIONARY
          5       &lt;&lt;&lt; handle
          C
          330     &lt;&lt;&lt; owner tag
          0       &lt;&lt;&lt; always #0, has no owner
          100
          AcDbDictionary
          281     &lt;&lt;&lt; hard owner flag
          1
          3       &lt;&lt;&lt; first entry
          ACAD_CIP_PREVIOUS_PRODUCT_INFO
          350     &lt;&lt;&lt; handle to target (pointer)
          78B     &lt;&lt;&lt; points to a XRECORD with product info about the creator application
          3       &lt;&lt;&lt; entry with unknown meaning, if I should guess: something with about colors ...
          ACAD_COLOR
          350
          4FB     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; entry with unknown meaning
          ACAD_DETAILVIEWSTYLE
          350
          7ED     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; GROUP management, mandatory in all DXF versions
          ACAD_GROUP
          350
          4FC     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; LAYOUT management, mandatory if more than the *active* paperspace is used
          ACAD_LAYOUT
          350
          4FD     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; MATERIAL management
          ACAD_MATERIAL
          350
          4FE     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; MLEADERSTYLE management
          ACAD_MLEADERSTYLE
          350
          4FF     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; MLINESTYLE management
          ACAD_MLINESTYLE
          350
          500     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; PLOTSETTINGS management
          ACAD_PLOTSETTINGS
          350
          501     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; plot style name management
          ACAD_PLOTSTYLENAME
          350
          503     &lt;&lt;&lt; points to a ACDBDICTIONARYWDFLT
          3       &lt;&lt;&lt; SCALE management
          ACAD_SCALELIST
          350
          504     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; entry with unknown meaning
          ACAD_SECTIONVIEWSTYLE
          350
          7EB     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; TABLESTYLE management
          ACAD_TABLESTYLE
          350
          505     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; VISUALSTYLE management
          ACAD_VISUALSTYLE
          350
          506     &lt;&lt;&lt; points to a DICTIONARY
          3       &lt;&lt;&lt; entry with unknown meaning
          ACDB_RECOMPOSE_DATA
          350
          7F3
          3       &lt;&lt;&lt; entry with unknown meaning
          AcDbVariableDictionary
          350
          7AE     &lt;&lt;&lt; points to a DICTIONARY with handles to DICTIONARYVAR objects
          0
          DICTIONARY
          ...
          ...
          0
          ENDSEC

   <b>DXF</b> <b>Structures</b>
   <b>DXF</b> <b>Sections</b>
   <b>HEADER</b> <b>Section</b>
       In DXF R12 and prior the HEADER section was optional, but since DXF R13 the HEADER section is  mandatory.
       The overall structure is:

          0           &lt;&lt;&lt; Begin HEADER section
          SECTION
          2
          HEADER
          9
          $ACADVER    &lt;&lt;&lt; Header variable items go here
          1
          AC1009
          ...
          0
          ENDSEC      &lt;&lt;&lt; End HEADER section

       A header variable has a name defined by a <b>(9,</b> <b>Name)</b> tag and following value tags.

       <b>SEE</b> <b>ALSO:</b>
          Documentation of <u>ezdxf</u> <u>HeaderSection</u> class.

          DXF Reference: <u>Header</u> <u>Variables</u>

   <b>CLASSES</b> <b>Section</b>
       The  CLASSES  section contains CLASS definitions which are only important for Autodesk products, some DXF
       entities require a class definition or AutoCAD will not open the DXF file.

       The CLASSES sections was introduced with DXF AC1015 (AutoCAD Release R13).

       <b>SEE</b> <b>ALSO:</b>
          DXF Reference: <u>About</u> <u>the</u> <u>DXF</u> <u>CLASSES</u> <u>Section</u>

          Documentation of <u>ezdxf</u> <u>ClassesSection</u> class.

       The CLASSES section in DXF files holds the information for application-defined  classes  whose  instances
       appear  in  the  BLOCKS,  ENTITIES,  and  OBJECTS  sections  of the database.  It is assumed that a class
       definition is permanently fixed in the class hierarchy.  All fields are required.

       <b>Update</b> <b>2019-03-03:</b>

       Class names are not unique, Autodesk Architectural Desktop 2007 uses the same name,  but  with  different
       CPP  class  names  in the CLASS section, so storing classes in a dictionary by name as key caused loss of
       class entries in ezdxf, using a tuple of (name, cpp_class_name) as storage key solved the problem.

   <b>CLASS</b> <b>Entities</b>
       <b>SEE</b> <b>ALSO:</b>
          DXF Reference: <u>Group</u> <u>Codes</u> <u>for</u> <u>the</u> <u>CLASS</u> <u>entity</u>

       CLASS entities have no handle and therefore ezdxf does not store the CLASS entity in the drawing entities
       database!

          0
          SECTION
          2           &lt;&lt;&lt; begin CLASSES section
          CLASSES
          0           &lt;&lt;&lt; first CLASS entity
          CLASS
          1           &lt;&lt;&lt; class DXF entity name; THIS ENTRY IS MAYBE NOT UNIQUE
          ACDBDICTIONARYWDFLT
          2           &lt;&lt;&lt; C++ class name; always unique
          AcDbDictionaryWithDefault
          3           &lt;&lt;&lt; application name
          ObjectDBX Classes
          90          &lt;&lt;&lt; proxy capabilities flags
          0
          91          &lt;&lt;&lt; instance counter for custom class, since DXF version AC1018 (R2004)
          0           &lt;&lt;&lt; no problem if the counter is wrong, AutoCAD doesn't care about
          280         &lt;&lt;&lt; was-a-proxy flag: 1= class was not loaded when this DXF file was created
          0           &lt;&lt;&lt; 0= otherwise
          281         &lt;&lt;&lt; is-an-entity flag: 1= instances reside in the BLOCKS or ENTITIES section
          0           &lt;&lt;&lt; 0= instances may appear only in the OBJECTS section
          0           &lt;&lt;&lt; next CLASS entity
          CLASS
          ...
          0           &lt;&lt;&lt; end of CLASSES section
          ENDSEC

   <b>TABLES</b> <b>Section</b>
       The TABLES section contains the resource tables of a DXF document.

   <b>APPID</b> <b>Table</b>
       The <u>APPID</u> table stores unique application identifiers. These identifiers are used to mark sub-sections in
       the XDATA section of DXF entities. AutoCAD will not load DXF files which uses AppIDs without an entry  in
       the AppIDs table and the “ACAD” entry must always exist.

       Some known AppIDs:
                          ┌──────────────────────┬──────────┬──────────────────────────────┐
                          │ APPID                │ Used by  │ Description                  │
                          ├──────────────────────┼──────────┼──────────────────────────────┤
                          │ ACAD                 │ Autodesk │ various use cases            │
                          ├──────────────────────┼──────────┼──────────────────────────────┤
                          │ AcAecLayerStandard   │ Autodesk │ layer description            │
                          ├──────────────────────┼──────────┼──────────────────────────────┤
                          │ AcCmTransparency     │ Autodesk │ layer transparency           │
                          ├──────────────────────┼──────────┼──────────────────────────────┤
                          │ HATCHBACKGROUNDCOLOR │ Autodesk │ background color for pattern │
                          │                      │          │ fillings                     │
                          ├──────────────────────┼──────────┼──────────────────────────────┤
                          │ EZDXF                │ ezdxf    │ meta data                    │
                          └──────────────────────┴──────────┴──────────────────────────────┘

       <b>SEE</b> <b>ALSO:</b>

          • DXF Reference: <u>TABLES</u> <u>Section</u>

          • DXF Reference: <u>APPID</u> Table

          • <u>AppID</u> class

   <b>Table</b> <b>Structure</b> <b>DXF</b> <b>R12</b>
          0           &lt;&lt;&lt; start of table
          TABLE
          2           &lt;&lt;&lt; table type
          APPID
          70          &lt;&lt;&lt; count of table entries, AutoCAD ignores this value
          3
          0           &lt;&lt;&lt; 1. table entry
          APPID
          2           &lt;&lt;&lt; unique application identifier
          ACAD
          70          &lt;&lt;&lt; flags, see `APPID`_ reference
          0           &lt;&lt;&lt; in common cases always 0
          0           &lt;&lt;&lt; next table entry
          APPID
          ...
          0           &lt;&lt;&lt; end of APPID table
          ENDTAB

   <b>Table</b> <b>Structure</b> <b>DXF</b> <b>R2000+</b>
          0           &lt;&lt;&lt; start of table
          TABLE
          2           &lt;&lt;&lt; table type
          APPID
          5           &lt;&lt;&lt; table handle
          3
          330         &lt;&lt;&lt; owner tag, tables have no owner
          0
          100         &lt;&lt;&lt; subclass marker
          AcDbSymbolTable
          70          &lt;&lt;&lt; count of table entries, AutoCAD ignores this value
          3
          0           &lt;&lt;&lt; first table entry
          APPID
          5           &lt;&lt;&lt; handle of appid
          2A
          330         &lt;&lt;&lt; owner handle, handle of APPID table
          3
          100         &lt;&lt;&lt; subclass marker
          AcDbSymbolTableRecord
          100         &lt;&lt;&lt; subclass marker
          AcDbRegAppTableRecord
          2           &lt;&lt;&lt; unique application identifier
          ACAD
          70          &lt;&lt;&lt; flags, see `APPID`_ reference
          0           &lt;&lt;&lt; in common cases always 0
          0           &lt;&lt;&lt; next table entry
          APPID
          ...
          0           &lt;&lt;&lt; end of APPID table
          ENDTAB

   <b>Name</b> <b>References</b>
       APPID table entries are referenced by name:

          • XDATA section of DXF entities

   <b>BLOCK_RECORD</b> <b>Table</b>
       Block records are essential elements for the entities management, each layout (modelspace and paperspace)
       and  every block definition has a block record entry. This block record is the hard <u>owner</u> of the entities
       of layouts, each entity has an owner handle which points to a block record of the layout.

   <b>DIMSTYLE</b> <b>Table</b>
       The <u>DIMSTYLE</u> table stores all dimension style definitions of a DXF drawing.

       You have access to the dimension styles table by the attribute <b>Drawing.dimstyles</b>.

       <b>SEE</b> <b>ALSO:</b>

          • DXF Reference: <u>TABLES</u> <u>Section</u>

          • DXF Reference: <u>DIMSTYLE</u> Table

   <b>Table</b> <b>Structure</b> <b>DXF</b> <b>R12</b>
          0           &lt;&lt;&lt; start of table
          TABLE
          2           &lt;&lt;&lt; set table type
          DIMSTYLE
          70          &lt;&lt;&lt; count of line types defined in this table, AutoCAD ignores this value
          9
          0           &lt;&lt;&lt; 1. DIMSTYLE table entry
          DIMSTYLE
                      &lt;&lt;&lt; DIMSTYLE data tags
          0           &lt;&lt;&lt; 2. DIMSTYLE table entry
          DIMSTYLE
                      &lt;&lt;&lt; DIMSTYLE data tags and so on
          0           &lt;&lt;&lt; end of DIMSTYLE table
          ENDTAB

   <b>DIMSTYLE</b> <b>Entry</b> <b>DXF</b> <b>R12</b>
   <b>DIMSTYLE</b> <b>Variables</b> <b>DXF</b> <b>R12</b>
       Source: <u>CADDManager</u> <u>Blog</u> [image] [image]
                                  ──────────────────────────────────────────────────
                                    DIMVAR     Code   Description
                                  ──────────────────────────────────────────────────
                                    DIMALT     170    Controls  the   display   of
                                                      alternate      units      in
                                                      dimensions.
                                  ──────────────────────────────────────────────────
                                    DIMALTD    171    Controls   the   number   of
                                                      decimal  places in alternate
                                                      units. If DIMALT  is  turned
                                                      on,  DIMALTD sets the number
                                                      of digits displayed  to  the
                                                      right  of  the decimal point
                                                      in       the       alternate
                                                      measurement.
                                  ──────────────────────────────────────────────────
                                    DIMALTF    143    Controls  the multiplier for
                                                      alternate units.  If  DIMALT
                                                      is    turned   on,   DIMALTF
                                                      multiplies linear dimensions
                                                      by a  factor  to  produce  a
                                                      value in an alternate system
                                                      of  measurement. The initial
                                                      value represents the  number
                                                      of millimeters in an inch.
                                  ──────────────────────────────────────────────────
                                    DIMAPOST   4      Specifies  a  text prefix or
                                                      suffix  (or  both)  to   the
                                                      alternate          dimension
                                                      measurement for all types of
                                                      dimensions  except  angular.
                                                      For instance, if the current
                                                      units   are   Architectural,
                                                      DIMALT  is  on,  DIMALTF  is
                                                      25.4    (the    number    of
                                                      millimeters    per    inch),
                                                      DIMALTD is 2, and DIMPOST is
                                                      set  to  “mm”, a distance of
                                                      10 units would be  displayed
                                                      as 10”[254.00mm].
                                  ──────────────────────────────────────────────────
                                    DIMASZ     41     Controls    the    size   of
                                                      dimension  line  and  leader
                                                      line     arrowheads.    Also
                                                      controls the  size  of  hook
                                                      lines.   Multiples   of  the
                                                      arrowhead   size   determine
                                                      whether  dimension lines and
                                                      text should fit between  the
                                                      extension  lines.  DIMASZ is
                                                      also used to scale arrowhead
                                                      blocks  if  set  by  DIMBLK.
                                                      DIMASZ  has  no  effect when
                                                      DIMTSZ is other than zero.
                                  ──────────────────────────────────────────────────
                                    DIMBLK     5      Sets  the  arrowhead   block
                                                      displayed  at  the  ends  of
                                                      dimension lines.
                                  ──────────────────────────────────────────────────
                                    DIMBLK1    6      Sets the arrowhead  for  the
                                                      first  end  of the dimension
                                                      line when DIMSAH is 1.
                                  ──────────────────────────────────────────────────
                                    DIMBLK2    7      Sets the arrowhead  for  the
                                                      second  end of the dimension
                                                      line when DIMSAH is 1.
                                  ──────────────────────────────────────────────────
                                    DIMCEN     141    Controls drawing  of  circle
                                                      or   arc  center  marks  and
                                                      centerlines      by      the
                                                      DIMCENTER,  DIMDIAMETER, and
                                                      DIMRADIUS   commands.    For
                                                      DIMDIAMETER  and  DIMRADIUS,
                                                      the  center  mark  is  drawn
                                                      only   if   you   place  the
                                                      dimension line  outside  the
                                                      circle or arc.

                                                             • 0   =    No  center
                                                               marks or lines  are
                                                               drawn

                                                             • &lt;0   =  Centerlines
                                                               are drawn

                                                             • &gt;0 =  Center  marks
                                                               are drawn
                                  ──────────────────────────────────────────────────
                                    DIMCLRD    176    Assigns  colors to dimension
                                                      lines,    arrowheads,    and
                                                      dimension leader lines.

                                                             • 0 =  BYBLOCK

                                                             • 1-255 = ACI AutoCAD
                                                               Color Index

                                                             • 256 =  BYLAYER
                                  ──────────────────────────────────────────────────
                                    DIMCLRE    177    Assigns  colors to dimension
                                                      extension lines, values like
                                                      DIMCLRD
                                  ──────────────────────────────────────────────────
                                    DIMCLRT    178    Assigns colors to  dimension
                                                      text, values like DIMCLRD
                                  ──────────────────────────────────────────────────
                                    DIMDLE     46     Sets    the   distance   the
                                                      dimension    line    extends
                                                      beyond  the  extension  line
                                                      when  oblique  strokes   are
                                                      drawn instead of arrowheads.
                                  ──────────────────────────────────────────────────
                                    DIMDLI     43     Controls  the spacing of the
                                                      dimension lines in  baseline
                                                      dimensions.  Each  dimension
                                                      line  is  offset  from   the
                                                      previous one by this amount,
                                                      if   necessary,   to   avoid
                                                      drawing  over  it.   Changes
                                                      made  with  DIMDLI  are  not
                                                      applied     to      existing
                                                      dimensions.
                                  ──────────────────────────────────────────────────
                                    DIMEXE     44     Specifies  how far to extend
                                                      the  extension  line  beyond
                                                      the dimension line.
                                  ──────────────────────────────────────────────────
                                    DIMEXO     42     Specifies  how far extension
                                                      lines are offset from origin
                                                      points.  With   fixed-length
                                                      extension  lines, this value
                                                      determines    the    minimum
                                                      offset.
                                  ──────────────────────────────────────────────────
                                    DIMGAP     147    Sets the distance around the
                                                      dimension   text   when  the
                                                      dimension  line  breaks   to
                                                      accommodate  dimension text.
                                                      Also sets  the  gap  between
                                                      annotation  and  a hook line
                                                      created  with   the   LEADER
                                                      command.   If  you  enter  a
                                                      negative    value,    DIMGAP
                                                      places   a  box  around  the
                                                      dimension text.

                                                      DIMGAP is also used  as  the
                                                      minimum length for pieces of
                                                      the dimension line. When the
                                                      default   position  for  the
                                                      dimension      text       is
                                                      calculated,      text     is
                                                      positioned    inside     the
                                                      extension   lines   only  if
                                                      doing    so    breaks    the
                                                      dimension   lines  into  two
                                                      segments at least as long as
                                                      DIMGAP.  Text  placed  above
                                                      or  below the dimension line
                                                      is  moved  inside  only   if
                                                      there   is   room   for  the
                                                      arrowheads, dimension  text,
                                                      and a margin between them at
                                                      least  as large as DIMGAP: 2
                                                      * (DIMASZ + DIMGAP).
                                  ──────────────────────────────────────────────────
                                    DIMLFAC    144    Sets  a  scale  factor   for
                                                      linear             dimension
                                                      measurements.   All   linear
                                                      dimension         distances,
                                                      including radii,  diameters,
                                                      and     coordinates,     are
                                                      multiplied by DIMLFAC before
                                                      being converted to dimension
                                                      text.  Positive  values   of
                                                      DIMLFAC   are   applied   to
                                                      dimensions      in      both
                                                      modelspace  and  paperspace;
                                                      negative values are  applied
                                                      to paperspace only.

                                                      DIMLFAC applies primarily to
                                                      nonassociative    dimensions
                                                      (DIMASSOC set 0 or  1).  For
                                                      nonassociative dimensions in
                                                      paperspace,  DIMLFAC must be
                                                      set  individually  for  each
                                                      layout      viewport      to
                                                      accommodate         viewport
                                                      scaling.

                                                      DIMLFAC  has  no  effect  on
                                                      angular dimensions,  and  is
                                                      not  applied  to  the values
                                                      held in  DIMRND,  DIMTM,  or
                                                      DIMTP.
                                  ──────────────────────────────────────────────────
                                    DIMLIM     72     Generates  dimension  limits
                                                      as the default text. Setting
                                                      DIMLIM to  On  turns  DIMTOL
                                                      off.

                                                             • 0    =    Dimension
                                                               limits   are    not
                                                               generated        as
                                                               default text

                                                             • 1    =    Dimension
                                                               limits          are
                                                               generated        as
                                                               default text
                                  ──────────────────────────────────────────────────
                                    DIMPOST    3      Specifies  a  text prefix or
                                                      suffix  (or  both)  to   the
                                                      dimension measurement.

                                                      For  example, to establish a
                                                      suffix for millimeters,  set
                                                      DIMPOST to mm; a distance of
                                                      19.2    units    would    be
                                                      displayed  as  19.2  mm.  If
                                                      tolerances  are  turned  on,
                                                      the suffix is applied to the
                                                      tolerances as well as to the
                                                      main dimension.

                                                      Use   “&lt;&gt;”    to    indicate
                                                      placement  of  the  text  in
                                                      relation  to  the  dimension
                                                      value.  For  example,  enter
                                                      “&lt;&gt;mm”  to  display  a   5.0
                                                      millimeter  radial dimension
                                                      as “5.0mm”. If  you  entered
                                                      mm “&lt;&gt;”, the dimension would
                                                      be displayed as “mm 5.0”.
                                  ──────────────────────────────────────────────────
                                    DIMRND     45     Rounds    all   dimensioning
                                                      distances to  the  specified
                                                      value.

                                                      For  instance,  if DIMRND is
                                                      set to 0.25,  all  distances
                                                      round  to  the  nearest 0.25
                                                      unit. If you set  DIMRND  to
                                                      1.0,  all distances round to
                                                      the  nearest  integer.  Note
                                                      that  the  number  of digits
                                                      edited  after  the   decimal
                                                      point    depends    on   the
                                                      precision  set  by   DIMDEC.
                                                      DIMRND  does  not  apply  to
                                                      angular dimensions.
                                  ──────────────────────────────────────────────────
                                    DIMSAH     173    Controls  the   display   of
                                                      dimension   line   arrowhead
                                                      blocks.

                                                             • 0 =  Use  arrowhead
                                                               blocks    set    by
                                                               DIMBLK

                                                             • 1 =  Use  arrowhead
                                                               blocks    set    by
                                                               DIMBLK1 and DIMBLK2
                                  ──────────────────────────────────────────────────
                                    DIMSCALE   40     Sets   the   overall   scale
                                                      factor       applied      to
                                                      dimensioning variables  that
                                                      specify sizes, distances, or
                                                      offsets.  Also  affects  the
                                                      leader  objects   with   the
                                                      LEADER command.

                                                      Use  MLEADERSCALE  to  scale
                                                      multileader objects  created
                                                      with the MLEADER command.

                                                             • 0.0  = A reasonable
                                                               default  value   is
                                                               computed  based  on
                                                               the scaling between
                                                               the  current  model
                                                               space  viewport and
                                                               paperspace. If  you
                                                               are  in  paperspace
                                                               or  modelspace  and
                                                               not    using    the
                                                               paperspace feature,
                                                               the scale factor is
                                                               1.0.

                                                             • &gt;0 = A scale factor
                                                               is  computed   that
                                                               leads  text  sizes,
                                                               arrowhead    sizes,
                                                               and   other  scaled
                                                               distances  to  plot
                                                               at    their    face
                                                               values.

                                                             DIMSCALE   does   not
                                                             affect       measured
                                                             lengths, coordinates,
                                                             or angles.

                                                             Use    DIMSCALE    to
                                                             control  the  overall
                                                             scale of  dimensions.
                                                             However,    if    the
                                                             current     dimension
                                                             style  is annotative,
                                                             DIMSCALE           is
                                                             automatically  set to
                                                             zero     and      the
                                                             dimension   scale  is
                                                             controlled   by   the
                                                             CANNOSCALE     system
                                                             variable.    DIMSCALE
                                                             cannot  be  set  to a
                                                             non-zero  value  when
                                                             using      annotative
                                                             dimensions.
                                  ──────────────────────────────────────────────────
                                    DIMSE1     75     Suppresses  display  of  the
                                                      first extension line.

                                                             • 0  = Extension line
                                                               is not suppressed

                                                             • 1 = Extension  line
                                                               is suppressed
                                  ──────────────────────────────────────────────────
                                    DIMSE2     76     Suppresses  display  of  the
                                                      second extension line.

                                                             • 0 = Extension  line
                                                               is not suppressed

                                                             • 1  = Extension line
                                                               is suppressed
                                  ──────────────────────────────────────────────────
                                    DIMSOXD    175    Suppresses arrowheads if not
                                                      enough  space  is  available
                                                      inside the extension lines.

                                                             • 0  = Arrowheads are
                                                               not suppressed

                                                             • 1 = Arrowheads  are
                                                               suppressed

                                                             If  not  enough space
                                                             is  available  inside
                                                             the  extension  lines
                                                             and  DIMTIX  is   on,
                                                             setting DIMSOXD to On
                                                             suppresses        the
                                                             arrowheads. If DIMTIX
                                                             is off,  DIMSOXD  has
                                                             no effect.
                                  ──────────────────────────────────────────────────
                                    DIMTAD     77     Controls     the    vertical
                                                      position of text in relation
                                                      to the dimension line.

                                                             • 0  =  Centers   the
                                                               dimension      text
                                                               between         the
                                                               extension lines.

                                                             • 1   =   Places  the
                                                               dimension      text
                                                               above the dimension
                                                               line   except  when
                                                               the dimension  line
                                                               is  not  horizontal
                                                               and text inside the
                                                               extension lines  is
                                                               forced   horizontal
                                                               (DIMTIH =  1).  The
                                                               distance  from  the
                                                               dimension  line  to
                                                               the baseline of the
                                                               lowest line of text
                                                               is    the   current
                                                               DIMGAP value.

                                                             • 2  =   Places   the
                                                               dimension  text  on
                                                               the  side  of   the
                                                               dimension      line
                                                               farthest away  from
                                                               the        defining
                                                               points.

                                                             • 3  =   Places   the
                                                               dimension  text  to
                                                               conform to Japanese
                                                               Industrial
                                                               Standards (JIS).

                                                             • 4  =   Places   the
                                                               dimension      text
                                                               below the dimension
                                                               line.
                                  ──────────────────────────────────────────────────
                                    DIMTFAC    146    Specifies a scale factor for
                                                      the text height of fractions
                                                      and     tolerance     values
                                                      relative  to  the  dimension
                                                      text  height,  as   set   by
                                                      DIMTXT.

                                                      For  example,  if DIMTFAC is
                                                      set to 1.0, the text  height
                                                      of  fractions and tolerances
                                                      is the same  height  as  the
                                                      dimension  text.  If DIMTFAC
                                                      is set to 0.7500,  the  text
                                                      height   of   fractions  and
                                                      tolerances is three-quarters
                                                      the size of dimension text.
                                  ──────────────────────────────────────────────────
                                    DIMTIH     73     Controls  the  position   of
                                                      dimension  text  inside  the
                                                      extension  lines   for   all
                                                      dimension    types    except
                                                      Ordinate.

                                                             • 0  =  Aligns   text
                                                               with  the dimension
                                                               line

                                                             • 1  =   Draws   text
                                                               horizontally
                                  ──────────────────────────────────────────────────
                                    DIMTIX     174    Draws text between extension
                                                      lines.

                                                             • 0 = Varies with the
                                                               type  of dimension.
                                                               For   linear    and
                                                               angular dimensions,
                                                               text    is   placed
                                                               inside          the
                                                               extension  lines if
                                                               there is sufficient
                                                               room.  For   radius
                                                               and        diameter
                                                               dimensions      hat
                                                               don’t   fit  inside
                                                               the circle or  arc,
                                                               DIMTIX    has    no
                                                               effect  and  always
                                                               forces   the   text
                                                               outside the  circle
                                                               or arc.

                                                             • 1 = Draws dimension
                                                               text   between  the
                                                               extension     lines
                                                               even  if  it  would
                                                               ordinarily       be
                                                               placed      outside
                                                               those lines
                                  ──────────────────────────────────────────────────
                                    DIMTM      48     Sets the minimum (or  lower)
                                                      tolerance      limit     for
                                                      dimension text  when  DIMTOL
                                                      or   DIMLIM  is  on.   DIMTM
                                                      accepts  signed  values.  If
                                                      DIMTOL  is  on and DIMTP and
                                                      DIMTM are set  to  the  same
                                                      value,  a tolerance value is
                                                      drawn. If  DIMTM  and  DIMTP
                                  │          │      │ values   differ,  the  upper │
                                  │          │      │ tolerance is drawn above the │
                                  │          │      │ lower, and a  plus  sign  is │
                                  │          │      │ added  to the DIMTP value if │
                                  │          │      │ it is positive.  For  DIMTM, │
                                  │          │      │ the    program    uses   the │
                                  │          │      │ negative of  the  value  you │
                                  │          │      │ enter  (adding  a minus sign │
                                  │          │      │ if you  specify  a  positive │
                                  │          │      │ number  and  a  plus sign if │
                                  │          │      │ you   specify   a   negative │
                                  │          │      │ number).                     │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTOFL  │ 172  │ Controls whether a dimension │
                                  │          │      │ line  is  drawn  between the │
                                  │          │      │ extension  lines  even  when │
                                  │          │      │ the  text is placed outside. │
                                  │          │      │ For  radius   and   diameter │
                                  │          │      │ dimensions  (when  DIMTIX is │
                                  │          │      │ off), draws a dimension line │
                                  │          │      │ inside the circle or arc and │
                                  │          │      │ places the text, arrowheads, │
                                  │          │      │ and leader outside.          │
                                  │          │      │                              │
                                  │          │      │        • 0 = Does  not  draw │
                                  │          │      │          dimension     lines │
                                  │          │      │          between         the │
                                  │          │      │          measured     points │
                                  │          │      │          when arrowheads are │
                                  │          │      │          placed outside  the │
                                  │          │      │          measured points     │
                                  │          │      │                              │
                                  │          │      │        • 1 = Draws dimension │
                                  │          │      │          lines  between  the │
                                  │          │      │          measured     points │
                                  │          │      │          even           when │
                                  │          │      │          arrowheads      are │
                                  │          │      │          placed  outside the │
                                  │          │      │          measured points     │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTOH   │ 74   │ Controls  the  position   of │
                                  │          │      │ dimension  text  outside the │
                                  │          │      │ extension lines.             │
                                  │          │      │                              │
                                  │          │      │        • 0  =  Aligns   text │
                                  │          │      │          with  the dimension │
                                  │          │      │          line                │
                                  │          │      │                              │
                                  │          │      │        • 1  =   Draws   text │
                                  │          │      │          horizontally        │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTOL   │ 71   │ Appends     tolerances    to │
                                  │          │      │ dimension   text.    Setting │
                                  │          │      │ DIMTOL  to  on  turns DIMLIM │
                                  │          │      │ off.                         │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTP    │ 47   │ Sets the maximum (or  upper) │
                                  │          │      │ tolerance      limit     for │
                                  │          │      │ dimension text  when  DIMTOL │
                                  │          │      │ or   DIMLIM  is  on.   DIMTP │
                                  │          │      │ accepts  signed  values.  If │
                                  │          │      │ DIMTOL  is  on and DIMTP and │
                                  │          │      │ DIMTM are set  to  the  same │
                                  │          │      │ value,  a tolerance value is │
                                  │          │      │ drawn. If  DIMTM  and  DIMTP │
                                  │          │      │ values   differ,  the  upper │
                                  │          │      │ tolerance is drawn above the │
                                  │          │      │ lower and  a  plus  sign  is │
                                  │          │      │ added  to the DIMTP value if │
                                  │          │      │ it is positive.              │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTSZ   │ 142  │ Specifies   the   size    of │
                                  │          │      │ oblique     strokes    drawn │
                                  │          │      │ instead  of  arrowheads  for │
                                  │          │      │ linear, radius, and diameter │
                                  │          │      │ dimensioning.                │
                                  │          │      │                              │
                                  │          │      │        • 0      =      Draws │
                                  │          │      │          arrowheads.         │
                                  │          │      │                              │
                                  │          │      │        • &gt;0 = Draws  oblique │
                                  │          │      │          strokes  instead of │
                                  │          │      │          arrowheads.     The │
                                  │          │      │          size of the oblique │
                                  │          │      │          strokes          is │
                                  │          │      │          determined by  this │
                                  │          │      │          value multiplied by │
                                  │          │      │          the DIMSCALE value  │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTVP   │ 145  │ Controls     the    vertical │
                                  │          │      │ position of  dimension  text │
                                  │          │      │ above or below the dimension │
                                  │          │      │ line.  The  DIMTVP  value is │
                                  │          │      │ used when DIMTAD  =  0.  The │
                                  │          │      │ magnitude  of  the  vertical │
                                  │          │      │ offset  of   text   is   the │
                                  │          │      │ product  of  the text height │
                                  │          │      │ and DIMTVP.  Setting  DIMTVP │
                                  │          │      │ to   1.0  is  equivalent  to │
                                  │          │      │ setting  DIMTAD  =  1.   The │
                                  │          │      │ dimension   line  splits  to │
                                  │          │      │ accommodate the text only if │
                                  │          │      │ the absolute value of DIMTVP │
                                  │          │      │ is less than 0.7.            │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMTXT   │ 140  │ Specifies  the   height   of │
                                  │          │      │ dimension  text,  unless the │
                                  │          │      │ current  text  style  has  a │
                                  │          │      │ fixed height.                │
                                  ├──────────┼──────┼──────────────────────────────┤
                                  │ DIMZIN   │ 78   │ Controls  the suppression of │
                                  │          │      │ zeros in  the  primary  unit │
                                  │          │      │ value.   Values  0-3  affect │
                                  │          │      │ feet-and-inch     dimensions │
                                  │          │      │ only:                        │
                                  │          │      │                              │
                                  │          │      │        • 0 = Suppresses zero │
                                  │          │      │          feet  and precisely │
                                  │          │      │          zero inches         │
                                  │          │      │                              │
                                  │          │      │        • 1 =  Includes  zero │
                                  │          │      │          feet  and precisely │
                                  │          │      │          zero inches         │
                                  │          │      │                              │
                                  │          │      │        • 2 =  Includes  zero │
                                  │          │      │          feet and suppresses │
                                  │          │      │          zero inches         │
                                  │          │      │                              │
                                  │          │      │        • 3  =  Includes zero │
                                  │          │      │          inches          and │
                                  │          │      │          suppresses     zero │
                                  │          │      │          feet                │
                                  │          │      │                              │
                                  │          │      │        • 4   (Bit    3)    = │
                                  │          │      │          Suppresses  leading │
                                  │          │      │          zeros  in   decimal │
                                  │          │      │          dimensions     (for │
                                  │          │      │          example,     0.5000 │
                                  │          │      │          becomes .5000)      │
                                  │          │      │                              │
                                  │          │      │        • 8    (Bit    4)   = │
                                  │          │      │          Suppresses trailing │
                                  │          │      │          zeros  in   decimal │
                                  │          │      │          dimensions     (for │
                                  │          │      │          example,    12.5000 │
                                  │          │      │          becomes 12.5)       │
                                  │          │      │                              │
                                  │          │      │        • 12   (Bit   3+4)  = │
                                  │          │      │          Suppresses     both │
                                  │          │      │          leading         and │
                                  │          │      │          trailing zeros (for │
                                  │          │      │          example,     0.5000 │
                                  │          │      │          becomes .5)         │
                                  └──────────┴──────┴──────────────────────────────┘

   <b>Table</b> <b>Structure</b> <b>DXF</b> <b>R2000+</b>
          0           &lt;&lt;&lt; start of table
          TABLE
          2           &lt;&lt;&lt; set table type
          DIMSTYLE
          5           &lt;&lt;&lt; DIMSTYLE table handle
          5F
          330         &lt;&lt;&lt; owner tag, tables has no owner
          0
          100         &lt;&lt;&lt; subclass marker
          AcDbSymbolTable
          70          &lt;&lt;&lt; count of dimension styles defined in this table, AutoCAD ignores this value
          9
          0           &lt;&lt;&lt; 1. DIMSTYLE table entry
          DIMSTYLE
                      &lt;&lt;&lt; DIMSTYLE data tags
          0           &lt;&lt;&lt; 2. DIMSTYLE table entry
          DIMSTYLE
                      &lt;&lt;&lt; DIMSTYLE data tags and so on
          0           &lt;&lt;&lt; end of DIMSTYLE table
          ENDTAB

   <b>Additional</b> <b>DIMSTYLE</b> <b>Variables</b> <b>DXF</b> <b>R13/14</b>
       Source: <u>CADDManager</u> <u>Blog</u>
                            ─────────────────────────────────────────────────────────────
                              DIMVAR            code   Description
                            ─────────────────────────────────────────────────────────────
                              DIMADEC           179    Controls   the   number   of
                                                       precision  places  displayed
                                                       in angular dimensions.
                            ─────────────────────────────────────────────────────────────
                              DIMALTTD          274    Sets  the  number of decimal
                                                       places  for  the   tolerance
                                                       values   in   the  alternate
                                                       units of a dimension.
                            ─────────────────────────────────────────────────────────────
                              DIMALTTZ          286    Controls   suppression    of
                                                       zeros in tolerance values.
                            ─────────────────────────────────────────────────────────────
                              DIMALTU           273    Sets  the  units  format for
                                                       alternate   units   of   all
                                                       dimension  substyles  except
                                                       Angular.
                            ─────────────────────────────────────────────────────────────
                              DIMALTZ           285    Controls the suppression  of
                                                       zeros   for  alternate  unit
                                                       dimension  values.   DIMALTZ
                                                       values       0-3      affect
                                                       feet-and-inch     dimensions
                                                       only.
                            ─────────────────────────────────────────────────────────────
                              DIMAUNIT          275    Sets  the  units  format for
                                                       angular dimensions.

                                                              • 0 = Decimal degrees

                                                              • 1                 =
                                                                Degrees/minutes/seconds

                                                              • 2 = Grad

                                                              • 3 = Radians
                            ─────────────────────────────────────────────────────────────
                              DIMBLK_HANDLE     342    defines  DIMBLK as handle to the
                                                       BLOCK RECORD entry
                            ─────────────────────────────────────────────────────────────
                              DIMBLK1_HANDLE    343    defines DIMBLK1 as handle to the
                                                       BLOCK RECORD entry
                            ─────────────────────────────────────────────────────────────
                              DIMBLK2_HANDLE    344    defines DIMBLK2 as handle to the
                                                       BLOCK RECORD entry
                            ─────────────────────────────────────────────────────────────
                              DIMDEC            271    Sets  the  number   of   decimal
                                                       places displayed for the primary
                                                       units   of   a   dimension.  The
                                                       precision is based on the  units
                                                       or   angle   format   you   have
                                                       selected.
                            ─────────────────────────────────────────────────────────────
                              DIMDSEP           278    Specifies   a   single-character
                                                       decimal  separator  to  use when
                                                       creating dimensions  whose  unit
                                                       format    is    decimal.    When
                                                       prompted,   enter    a    single
                                                       character at the Command prompt.
                                                       If  dimension  units  is  set to
                                                       Decimal, the  DIMDSEP  character
                                                       is  used  instead of the default
                                                       decimal point. If DIMDSEP is set
                                                       to NULL (default value, reset by
                                                       entering a period), the  decimal
                                                       point  is  used as the dimension
                                                       separator.
                            ─────────────────────────────────────────────────────────────
                              DIMJUST           280    Controls     the      horizontal
                                                       positioning of dimension text.

                                                              • 0  = Positions the text
                                                                above   the   dimension
                                                                line                and
                                                                center-justifies     it
                                                                between  the  extension
                                                                lines

                                                              • 1 = Positions the  text
                                                                next   to   the   first
                                                                extension line

                                                              • 2 = Positions the  text
                                                                next   to   the  second
                                                                extension line

                                                              • 3 = Positions the  text
                                                                above  and aligned with
                                                                the   first   extension
                                                                line

                                                              • 4   =   =Positions  the
                                                                text above and  aligned
                                                                with     the     second
                                                                extension line
                            ─────────────────────────────────────────────────────────────
                              DIMSD1            281    Controls  suppression   of   the
                                                       first    dimension    line   and
                                                       arrowhead.   When   turned   on,
                                                       suppresses  the  display  of the
                                                       dimension  line  and   arrowhead
                                                       between the first extension line
                                                       and the text.

                                                              • 0   =  First  dimension
                                                                line is not suppressed

                                                              • 1  =  First   dimension
                                                                line is suppressed
                            ─────────────────────────────────────────────────────────────
                              DIMSD2            282    Controls   suppression   of  the
                                                       second   dimension   line    and
                                                       arrowhead.   When   turned   on,
                                                       suppresses the  display  of  the
                                                       dimension   line  and  arrowhead
                                                       between  the  second   extension
                                                       line and the text.

                                                              • 0  =  Second  dimension
                                                                line is not suppressed

                                                              • 1  =  Second  dimension
                                                                line is suppressed
                            ─────────────────────────────────────────────────────────────
                              DIMTDEC           272    Sets   the   number  of  decimal
                                                       places to display  in  tolerance
                                                       values  for the primary units in
                                                       a   dimension.    This    system
                                                       variable  has  no  effect unless
                                                       DIMTOL is set to On. The default
                                                       for DIMTOL is Off.
                            ─────────────────────────────────────────────────────────────
                              DIMTOLJ           283    Sets the vertical  justification
                                                       for tolerance values relative to
                                                       the   nominal   dimension  text.
                                                       This  system  variable  has   no
                                                       effect  unless  DIMTOL is set to
                                                       On. The default  for  DIMTOL  is
                                                       Off.

                                                              • 0 = Bottom

                                                              • 1 = Middle

                                                              • 2 = Top
                            ─────────────────────────────────────────────────────────────
                              DIMTXSTY_HANDLE   340    Specifies  the text style of the
                                                       dimension  as  handle  to  STYLE
                                                       table entry
                            ─────────────────────────────────────────────────────────────
                              DIMTZIN           284    Controls   the   suppression  of
                                                       zeros in tolerance values.

                                                       Values 0-3 affect  feet-and-inch
                                                       dimensions only.

                                                              • 0   =  Suppresses  zero
                                                                feet and precisely zero
                                                                inches

                                                              • 1 = Includes zero  feet
                                                                and    precisely   zero
                                                                inches

                                                              • 2 = Includes zero  feet
                                                                and   suppresses   zero
                                                                inches

                                                              • 3   =   Includes   zero
                                                                inches  and  suppresses
                                                                zero feet

                                                              • 4 = Suppresses  leading
                                                                zeros     in    decimal
                                                                dimensions         (for
                                                                example, 0.5000 becomes
                                                                .5000)

                                                              • 8 = Suppresses trailing
                                                                zeros     in    decimal
                                                                dimensions         (for
                                                                example,        12.5000
                                                                becomes 12.5)

                                                              • 12  =  Suppresses  both
                                                                leading   and  trailing
                                                                zeros   (for   example,
                                                                0.5000 becomes .5)
                            ─────────────────────────────────────────────────────────────
                              DIMUPT            288    Controls       options       for
                                                       user-positioned text.

                                                              • 0  =  Cursor   controls
                                                                only the dimension line
                                                                location

                                                              • 1   =  Cursor  controls
                                                                both the text  position
                                                                and  the dimension line
                                                                location
                            ┌─────────────────┬──────┬──────────────────────────────────┐
                            │                 │      │                                  │
--
</pre><h4><b>DEVELOPER</b> <b>GUIDES</b></h4><pre>
       Information about <u>ezdxf</u> internals.

   <b>Source</b> <b>Code</b> <b>Formatting</b>
       Reformat code by <u>Black</u> with the default setting of 88 characters per line:

          C:\&gt; black &lt;python-file&gt;

   <b>Type</b> <b>Annotations</b>
       The  use  of  type  annotations  is encouraged. New modules should pass <u>mypy</u> without errors in non-strict
       mode. Using <b>#</b> <b>type:</b> <b>ignore</b> is fine  in  tricky  situations  -  type  annotations  should  be  helpful  in
       understanding the code and not be a burden.

       The following global options are required to pass <u>mypy</u> without error messages:

          [mypy]
          python_version = 3.7
          ignore_missing_imports = True

       Read <u>this</u> to learn where <u>mypy</u> searches for config files.

       Use  the  <u>mypy</u>  command  line  option <b>--ignore-missing-imports</b> and <b>-p</b> to check the whole package from any
       location in the file system:

          PS D:\Source\ezdxf.git&gt; mypy --ignore-missing-imports -p ezdxf
          Success: no issues found in 255 source files

   <b>Design</b>
       The <u>Package</u> <u>Design</u> <u>for</u> <u>Developers</u> section shows the structure of the <u>ezdxf</u> package  for  developers  with
       more  experience,  which  want  to have more insight into the package an maybe want to develop add-ons or
       want contribute to the <u>ezdxf</u> package.  <b>!!!</b> <b>UNDER</b> <b>CONSTRUCTION</b> <b>!!!</b>

   <b>Package</b> <b>Design</b> <b>for</b> <b>Developers</b>
       A DXF document is divided into several sections, this sections are managed by  the  <b>Drawing</b>  object.  For
       each section exist a corresponding attribute in the <b>Drawing</b> object:
                                           ┌──────────┬──────────────────┐
                                           │ Section  │ Attribute        │
                                           ├──────────┼──────────────────┤
                                           │ HEADER   │ <b>Drawing.header</b>   │
                                           ├──────────┼──────────────────┤
                                           │ CLASSES  │ <b>Drawing.classes</b>  │
                                           ├──────────┼──────────────────┤
                                           │ TABLES   │ <b>Drawing.tables</b>   │
                                           ├──────────┼──────────────────┤
                                           │ BLOCKS   │ <b>Drawing.blocks</b>   │
                                           ├──────────┼──────────────────┤
                                           │ ENTITIES │ <b>Drawing.entities</b> │
                                           ├──────────┼──────────────────┤
                                           │ OBJECTS  │ <b>Drawing.objects</b>  │
                                           └──────────┴──────────────────┘

       Resource  entities  (LAYER, STYLE, LTYPE, …) are stored in tables in the TABLES section. A table owns the
       table entries, the owner handle of table entry is the handle of the table. Each table has a  shortcut  in
       the <b>Drawing</b> object:
                                       ┌──────────────┬───────────────────────┐
                                       │ Table        │ Attribute             │
                                       ├──────────────┼───────────────────────┤
                                       │ APPID        │ <b>Drawing.appids</b>        │
                                       ├──────────────┼───────────────────────┤
                                       │ BLOCK_RECORD │ <b>Drawing.block_records</b> │
                                       ├──────────────┼───────────────────────┤
                                       │ DIMSTYLE     │ <b>Drawing.dimstyles</b>     │
                                       ├──────────────┼───────────────────────┤
                                       │ LAYER        │ <b>Drawing.layers</b>        │
                                       ├──────────────┼───────────────────────┤
                                       │ LTYPE        │ <b>Drawing.linetypes</b>     │
                                       ├──────────────┼───────────────────────┤
                                       │ STYLE        │ <b>Drawing.styles</b>        │
                                       ├──────────────┼───────────────────────┤
                                       │ UCS          │ <b>Drawing.ucs</b>           │
                                       ├──────────────┼───────────────────────┤
                                       │ VIEW         │ <b>Drawing.views</b>         │
                                       ├──────────────┼───────────────────────┤
                                       │ VPORT        │ <b>Drawing.viewports</b>     │
                                       └──────────────┴───────────────────────┘

       Graphical  entities  are  stored  in  layouts:  <u>Modelspace</u>, <u>Paperspace</u> layouts and <u>BlockLayout</u>.  The core
       management object of this layouts is the BLOCK_RECORD entity (<u>BlockRecord</u>), the BLOCK_RECORD is the  real
       owner  of  the  entities,  the  owner  handle  of  the entities is the handle of the BLOCK_RECORD and the
       BLOCK_RECORD also owns and manages the entity space of the layout which  contains  all  entities  of  the
       layout.

       For more information about layouts see also: <u>Layout</u> <u>Management</u> <u>Structures</u>

       For more information about blocks see also: <u>Block</u> <u>Management</u> <u>Structures</u>

       Non-graphical  entities (objects) are stored in the OBJECTS section.  Every object has a parent object in
       the OBJECTS section, most likely a DICTIONARY object, and is stored in the entity space  of  the  OBJECTS
       section.

       For more information about the OBJECTS section see also: <u>OBJECTS</u> <u>Section</u>

       All  table  entries,  DXF  entities  and  DXF  objects  are stored in the entities database accessible as
       <b>Drawing.entitydb</b>. The entity database is a simple key, value storage, key is the entity handle, value  is
       the DXF object.

       For more information about the DXF data model see also: <u>Data</u> <u>Model</u>

   <b>Terminology</b>
   <b>States</b>
       DXF entities and objects can have different states:

       <b>UNBOUND</b>
              Entity is not stored in the <b>Drawing</b> entity database and DXF attribute <b>handle</b> is <b>None</b> and attribute
              <b>doc</b> can be <b>None</b>

       <b>BOUND</b>  Entity  is stored in the <b>Drawing</b> entity database, attribute <b>doc</b> has a reference to <b>Drawing</b> and DXF
              attribute <b>handle</b> is not <b>None</b>

       <b>UNLINKED</b>
              Entity is not linked to a layout/owner, DXF attribute <b>owner</b> is <b>None</b>

       <b>LINKED</b> Entity is linked to a layout/owner, DXF attribute <b>owner</b> is not <b>None</b>

       <b>Virtual</b> <b>Entity</b>
              State: UNBOUND &amp; UNLINKED

       <b>Unlinked</b> <b>Entity</b>
              State: BOUND &amp; UNLINKED

       <b>Bound</b> <b>Entity</b>
              State: BOUND &amp; LINKED

   <b>Actions</b>
       <b>NEW</b>    Create a new DXF document

       <b>LOAD</b>   Load a DXF document from an external source

       <b>CREATE</b> Create DXF structures from NEW or LOAD data

       <b>DESTROY</b>
              Delete DXF structures

       <b>BIND</b>   Bind an entity to a <b>Drawing</b>, set entity state to BOUND &amp; UNLINKED and  check  or  create  required
              resources

       <b>UNBIND</b> unbind …

       <b>LINK</b>   Link  an  entity  to  an  owner/layout.   This makes an entity to a real DXF entity, which will be
              exported at the saving process. Any DXF entity can only  be  linked  to  <b>one</b>  parent  entity  like
              DICTIONARY or BLOCK_RECORD.

       <b>UNLINK</b> unlink …

   <b>Loading</b> <b>a</b> <b>DXF</b> <b>Document</b>
       Loading  a  DXF  document from an external source, creates a new <b>Drawing</b> object. This loading process has
       two stages:

   <b>First</b> <b>Loading</b> <b>Stage</b>
       • LOAD content from external source as <b>SectionDict</b>: <b>loader.load_dxf_structure()</b>

       • LOAD tag structures as <b>DXFEntity</b> objects: <b>loader.load_dxf_entities()</b>

       • BIND entities: <b>loader.load_and_bind_dxf_content()</b>; Special handling of the BIND  process,  because  the
         <b>Drawing</b> is not full initialized, a complete validation is not possible at this stage.

   <b>Second</b> <b>Loading</b> <b>Stage</b>
       Parse <b>SectionDict</b>:

       • CREATE sections: HEADER, CLASSES, TABLES, BLOCKS and OBJECTS

       • CREATE layouts: Blocks, Layouts

       • LINK entities to a owner/layout

       The  ENTITIES section is a relict from older DXF versions and has to be exported including the modelspace
       and active paperspace entities, but all entities reside  in  a  BLOCK  definition,  even  modelspace  and
       paperspace layouts are only BLOCK definitions and ezdxf has no explicit ENTITIES section.

       Source  Code:  as  developer  start  your  journey  at <b>ezdxf.document.Drawing.read()</b>, which has no public
       documentation, because package-user should use <u>ezdxf.read()</u> and <u>ezdxf.readfile()</u>.

   <b>New</b> <b>DXF</b> <b>Document</b>
   <b>Creating</b> <b>New</b> <b>DXF</b> <b>Entities</b>
       The default constructor of each entity type creates a new virtual entity:

       • DXF attribute <u>owner</u> is <b>None</b>

       • DXF attribute <u>handle</u> is <b>None</b>

       • Attribute <u>doc</u> is <b>None</b>

       The <b>DXFEntity.new()</b> constructor creates entities with given <u>owner</u>, <u>handle</u> and <u>doc</u> attributes, if  <u>doc</u>  is
       not  <b>None</b>  and  entity  is  not already bound to a document, the <b>new()</b> constructor automatically bind the
       entity to the given document <u>doc</u>.

       There exist only two scenarios:

       1. UNBOUND: <u>doc</u> is <b>None</b> and <u>handle</u> is <b>None</b>

       2. BOUND: <u>doc</u> is not <b>None</b> and <u>handle</u> is not <b>None</b>

   <b>Factory</b> <b>functions</b>
       • <b>new()</b>, create a new virtual DXF object/entity

       • <b>load()</b>, load (create) virtual DXF object/entity from DXF tags

       • <b>bind()</b>, bind an entity to a document, create required resources  if  necessary  (e.g.  ImageDefReactor,
         SEQEND) and raise exceptions for non-existing resources.

         • Bind  entity  loaded  from an external source to a document, all referenced resources must exist, but
           try to repair as many flaws as possible because errors were created by another  application  and  are
           not the responsibility of the package-user.

         • Bind  an  entity from another DXF document, all invalid resources will be removed silently or created
           (e.g. SEQEND). This is a simple import from another document without  resource  import,  for  a  more
           advanced import including resources exist the <b>importer</b> add-on.

         • Bootstrap  problem  for  binding  loaded  table entries and objects in the OBJECTS section! Can’t use
           <b>Auditor</b> to repair this objects, because the DXF document is not fully initialized.

       • <b>is_bound()</b> returns True if <u>entity</u> is bound to document <u>doc</u>

       • <b>unbind()</b> function to remove an entity from a document and set state to a virtual entity,  which  should
         also <u>UNLINK</u> the entity from layout, because an layout can not store a virtual entity.

       • <b>cls()</b>, returns the class

       • <b>register_entity()</b>, registration decorator

       • <b>replace_entity()</b>, registration decorator

   <b>Class</b> <b>Interfaces</b>
   <b>DXF</b> <b>Entities</b>
       • NEW constructor to create an entity from scratch

       • LOAD constructor to create an entity loaded from an external source

       • DESTROY  interface  to  kill  an  entity, set entity state to <u>dead</u>, which means <b>entity.is_alive</b> returns
         False. All entity iterators like <b>EntitySpace</b>, <b>EntityQuery</b>,  and  <b>EntityDB</b>  must  filter  (ignore)  <u>dead</u>
         entities.  Calling <b>DXFEntity.destroy()</b> is a regular way to delete entities.

       • LINK  an entity to a layout by <b>BlockRecord.link()</b>, which set the <u>owner</u> handle to BLOCK_RECORD handle (=
         layout key) and add the entity to the entity space of the BLOCK_RECORD  and  set/clear  the  paperspace
         flag.

   <b>DXF</b> <b>Objects</b>
       • NEW, LOAD, DESTROY see DXF entities

       • LINK:  Linking  an  DXF  object means adding the entity to a parent object in the OBJECTS section, most
         likely a DICTIONARY object, and adding the object to the entity  space  of  the  OBJECTS  section,  the
         root-dict  is  the  only entity in the OBJECTS section which has an invalid owner handle “0”. Any other
         object with an invalid or destroyed owner is an  orphaned  entity.   The  audit  process  destroys  and
         removes orphaned objects.

       • Extension  dictionaries  (ACAD_XDICTIONARY)  are DICTIONARY objects located in the OBJECTS sections and
         can reference/own other entities of the OBJECTS section.

       • The root-dictionary is the only entity in the OBJECTS section which has an invalid  owner  handle  “0”.
         Any other object with an invalid or destroyed owner is an orphaned entity.

   <b>Layouts</b>
       • LINK interface to link an entity to a layout

       • UNLINK interface to remove an entity from a layout

   <b>Database</b>
       • BIND interface to add an entity to the database of a document

       • <b>delete_entity()</b> interface, same as UNBIND and DESTROY an entity

   <b>Internal</b> <b>Data</b> <b>Structures</b>
   <b>Entity</b> <b>Database</b>
       The  <u>EntityDB</u> is a simple key/value database to store <u>DXFEntity</u> objects by it’s handle, every <u>Drawing</u> has
       its own <u>EntityDB</u>, stored in the <b>Drawing</b> attribute <b>entitydb</b>.

       Every DXF entity/object, except tables and sections, are represented as  <b>DXFEntity</b>  or  inherited  types,
       this entities are stored in the <u>EntityDB</u>, database-key is the <b>dxf.handle</b> as plain hex string.

       All iterators like <b>keys()</b>, <b>values()</b>, <b>items()</b> and <b>__iter__()</b> do not yield destroyed entities.

       <b>WARNING:</b>
          The <b>get()</b> method and the index operator <b>[]</b>, return destroyed entities and entities from the trashcan.

       <b>class</b> <b>ezdxf.entitydb.EntityDB</b>

              <b>__getitem__(handle:</b> <b>str)</b> <b>-&gt;</b> <u>DXFEntity</u>
                     Get entity by <u>handle</u>, does not filter destroyed entities nor entities in the trashcan.

              <b>__setitem__(handle:</b> <b>str,</b> <b>entity:</b> <u>DXFEntity</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Set <u>entity</u> for <u>handle</u>.

              <b>__delitem__(handle:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Delete entity by <u>handle</u>. Removes entity only from database, does not destroy the entity.

              <b>__contains__(item:</b> <b>str</b> <b>|</b> <u>DXFEntity</u><b>)</b> <b>-&gt;</b> <b>bool</b>
                     <b>True</b> if database contains <u>handle</u>.

              <b>__len__()</b> <b>-&gt;</b> <b>int</b>
                     Count of database items.

              <b>__iter__()</b> <b>-&gt;</b> <b>Iterator[str]</b>
                     Iterable of all handles, does filter destroyed entities but not entities in the trashcan.

              <b>get(handle:</b> <b>str)</b> <b>-&gt;</b> <u>DXFEntity</u> <b>|</b> <b>None</b>
                     Returns entity for <u>handle</u> or <b>None</b> if no entry exist, does not filter destroyed entities.

              <b>next_handle()</b> <b>-&gt;</b> <b>str</b>
                     Returns next unique handle.

              <b>keys()</b> <b>-&gt;</b> <b>Iterable[str]</b>
                     Iterable of all handles, does filter destroyed entities.

              <b>values()</b> <b>-&gt;</b> <b>Iterable[</b><u>DXFEntity</u><b>]</b>
                     Iterable of all entities, does filter destroyed entities.

              <b>items()</b> <b>-&gt;</b> <b>Iterable[Tuple[str,</b> <u>DXFEntity</u><b>]]</b>
                     Iterable of all (handle, entities) pairs, does filter destroyed entities.

              <b>add(entity:</b> <u>DXFEntity</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Add  <u>entity</u>  to  database, assigns a new handle to the <u>entity</u> if <b>entity.dxf.handle</b> is <b>None</b>.
                     Adding the same entity multiple times is possible and creates only a single database entry.

              <b>new_trashcan()</b> <b>-&gt;</b> <b>Trashcan</b>
                     Returns a new trashcan, empty trashcan manually by: : func:<u>Trashcan.clear()</u>.

              <b>trashcan()</b> <b>-&gt;</b> <b>Trashcan</b>
                     Returns a new trashcan in context manager mode,  trashcan  will  be  emptied  when  leaving
                     context.

              <b>purge()</b> <b>-&gt;</b> <b>None</b>
                     Remove all destroyed entities from database, but does not empty the trashcan.

              <b>query(query:</b> <b>str</b> <b>=</b> <b>'*')</b> <b>-&gt;</b> <u>EntityQuery</u>
                     Entity query over all entities in the DXF document.

                     <b>Parameters</b>
                            <b>query</b> – query string

                     <b>SEE</b> <b>ALSO:</b>
                        <u>Entity</u> <u>Query</u> <u>String</u> and <u>Retrieve</u> <u>entities</u> <u>by</u> <u>query</u> <u>language</u>

   <b>Entity</b> <b>Space</b>
       <b>class</b> <b>ezdxf.entitydb.EntitySpace(entities:</b> <b>Iterable[DXFEntity]</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b>
              An  <u>EntitySpace</u>  is  a  collection of <u>DXFEntity</u> objects, that stores only  references to <b>DXFEntity</b>
              objects.

              The <u>Modelspace</u>, any <u>Paperspace</u> layout and <u>BlockLayout</u> objects have  an  <u>EntitySpace</u>  container  to
              store their entities.

              <b>__iter__()</b> <b>-&gt;</b> <b>Iterable[</b><u>DXFEntity</u><b>]</b>
                     Iterable of all entities, filters destroyed entities.

              <b>__getitem__(index)</b> <b>-&gt;</b> <u>DXFEntity</u>
                     Get entity at index <u>item</u>

                     <u>EntitySpace</u>  has  a  standard  Python list like interface, therefore <u>index</u> can be any valid
                     list indexing or slicing term, like a single index <b>layout[-1]</b> to get the last entity, or an
                     index slice <b>layout[:10]</b> to get the first 10 or fewer entities as <b>list[DXFEntity]</b>. Does  not
                     filter destroyed entities.

              <b>__len__()</b> <b>-&gt;</b> <b>int</b>
                     Count of entities including destroyed entities.

              <b>has_handle(handle:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     <b>True</b> if <u>handle</u> is present, does filter destroyed entities.

              <b>purge()</b>
                     Remove all destroyed entities from entity space.

              <b>add(entity:</b> <u>DXFEntity</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Add <u>entity</u>.

              <b>extend(entities:</b> <b>Iterable[</b><u>DXFEntity</u><b>])</b> <b>-&gt;</b> <b>None</b>
                     Add multiple <u>entities</u>.

              <b>remove(entity:</b> <u>DXFEntity</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Remove <u>entity</u>.

              <b>clear()</b> <b>-&gt;</b> <b>None</b>
                     Remove all entities.

   <b>DXF</b> <b>Types</b>
       Required DXF tag interface:

          • property <b>code</b>: group code as int

          • property <b>value</b>: tag value of unspecific type

          • <b>dxfstr()</b>: returns the DXF string

          • <b>clone()</b>: returns a deep copy of tag

   <b>DXFTag</b> <b>Factory</b> <b>Functions</b>
       <b>ezdxf.lldxf.types.dxftag(code:</b> <b>int,</b> <b>value:</b> <b>Any)</b> <b>-&gt;</b> <u>DXFTag</u>
              DXF tag factory function.

              <b>Parameters</b>

                     • <b>code</b> – group code

                     • <b>value</b> – tag value

              Returns: <u>DXFTag</u> or inherited

       <b>ezdxf.lldxf.types.tuples_to_tags(iterable:</b> <b>Iterable[tuple[int,</b> <b>Any]])</b> <b>-&gt;</b> <b>Iterable[</b><u>DXFTag</u><b>]</b>
              Returns an iterable if <u>DXFTag</u> or inherited, accepts an iterable of (code, value) tuples as input.

   <b>DXFTag</b>
       <b>class</b> <b>ezdxf.lldxf.types.DXFTag(code:</b> <b>int,</b> <b>value:</b> <b>Any)</b>
              Immutable DXFTag class.

              <b>Parameters</b>

                     • <b>code</b> – group code as int

                     • <b>value</b> – tag value, type depends on group code

              <b>code</b>   group code as int (do not change)

              <b>value</b>  tag value (read-only property)

              <b>__eq__(other)</b> <b>-&gt;</b> <b>bool</b>
                     <b>True</b> if <u>other</u> and <u>self</u> has same content for <u>code</u> and <u>value</u>.

              <b>__getitem__(index:</b> <b>int)</b>
                     Returns <u>code</u> for index 0 and <u>value</u> for index 1, emulates a tuple.

              <b>__hash__()</b>
                     Hash support, <u>DXFTag</u> can be used in sets and as dict key.

              <b>__iter__()</b>
                     Returns (code, value) tuples.

              <b>__repr__()</b> <b>-&gt;</b> <b>str</b>
                     Returns representation string <b>'DXFTag(code,</b> <b>value)'</b>.

              <b>__str__()</b> <b>-&gt;</b> <b>str</b>
                     Returns content string <b>'(code,</b> <b>value)'</b>.

              <b>clone()</b> <b>-&gt;</b> <u>DXFTag</u>
                     Returns  a  clone  of  itself,  this  method  is  necessary  for  the more complex (and not
                     immutable) DXF tag types.

              <b>dxfstr()</b> <b>-&gt;</b> <b>str</b>
                     Returns the DXF string e.g. <b>'</b>  <b>0\nLINE\n'</b>

   <b>DXFBinaryTag</b>
       <b>class</b> <b>ezdxf.lldxf.types.DXFBinaryTag(DXFTag)</b>
              Immutable BinaryTags class - immutable by design, not by implementation.

              <b>dxfstr()</b> <b>-&gt;</b> <b>str</b>
                     Returns the DXF string for all vertex components.

              <b>tostring()</b> <b>-&gt;</b> <b>str</b>
                     Returns binary value as single hex-string.

   <b>DXFVertex</b>
       <b>class</b> <b>ezdxf.lldxf.types.DXFVertex(DXFTag)</b>
              Represents a 2D or 3D vertex, stores only the group code of the x-component of the vertex, because
              the y-group-code is x-group-code + 10 and z-group-code id x-group-code+20, this  is  a  rule  that
              ALWAYS applies.  This tag is <u>immutable</u> by design, not by implementation.

              <b>Parameters</b>

                     • <b>code</b> – group code of x-component

                     • <b>value</b> – sequence of x, y and optional z values

              <b>dxfstr()</b> <b>-&gt;</b> <b>str</b>
                     Returns the DXF string for all vertex components.

              <b>dxftags()</b> <b>-&gt;</b> <b>Iterable[</b><u>DXFTag</u><b>]</b>
                     Returns all vertex components as single <u>DXFTag</u> objects.

   <b>NONE_TAG</b>
       <b>ezdxf.lldxf.types.NONE_TAG</b>
              Special tag representing a none existing tag.

   <b>Tags</b>
       A  list of <u>DXFTag</u>, inherits from Python standard list.  Unlike the statement in the DXF Reference “Do not
       write programs that rely on the order given here”, tag order is sometimes essential and some group  codes
       may appear multiples times in one entity. At the worst case (<b>Material</b>: normal map shares group codes with
       diffuse map) using same group codes with different meanings.

       <b>class</b> <b>ezdxf.lldxf.tags.Tags</b>
              Subclass of <b>list</b>.

              Collection of <u>DXFTag</u> as flat list. Low level tag container, only required for advanced stuff.

              <b>classmethod</b> <b>from_text(text:</b> <b>str)</b> <b>-&gt;</b> <u>Tags</u>
                     Constructor from DXF string.

              <b>dxftype()</b> <b>-&gt;</b> <b>str</b>
                     Returns DXF type of entity, e.g. <b>'LINE'</b>.

              <b>get_handle()</b> <b>-&gt;</b> <b>str</b>
                     Get DXF handle. Raises <b>DXFValueError</b> if handle not exist.

                     <b>Returns</b>
                            handle as plain hex string like <b>'FF00'</b>

                     <b>Raises</b> <u>DXFValueError</u> – no handle found

              <b>replace_handle(new_handle:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Replace existing handle.

                     <b>Parameters</b>
                            <b>new_handle</b> – new handle as plain hex string e.g. <b>'FF00'</b>

              <b>has_tag(code:</b> <b>int)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if a <u>DXFTag</u> with given group <u>code</u> is present.

                     <b>Parameters</b>
                            <b>code</b> – group code as int

              <b>has_embedded_objects()</b> <b>-&gt;</b> <b>bool</b>

              <b>get_first_tag(code:</b> <b>int,</b> <b>default=DXFValueError)</b> <b>-&gt;</b> <u>DXFTag</u>
                     Returns  first  <u>DXFTag</u>  with given group code or <u>default</u>, if <u>default</u> != <b>DXFValueError</b>, else
                     raises <b>DXFValueError</b>.

                     <b>Parameters</b>

                            • <b>code</b> – group code as int

                            • <b>default</b> – return value for default case or raises <b>DXFValueError</b>

              <b>get_first_value(code:</b> <b>int,</b> <b>default=DXFValueError)</b> <b>-&gt;</b> <b>Any</b>
                     Returns value of first <u>DXFTag</u> with given group code or default if <u>default</u> != <b>DXFValueError</b>,
                     else raises <b>DXFValueError</b>.

                     <b>Parameters</b>

                            • <b>code</b> – group code as int

                            • <b>default</b> – return value for default case or raises <b>DXFValueError</b>

              <b>find_all(code:</b> <b>int)</b> <b>-&gt;</b> <b>List[</b><u>DXFTag</u><b>]</b>
                     Returns a list of <u>DXFTag</u> with given group code.

                     <b>Parameters</b>
                            <b>code</b> – group code as int

              <b>filter(codes:</b> <b>Iterable[int])</b> <b>-&gt;</b> <b>Iterable[</b><u>DXFTag</u><b>]</b>
                     Iterate and filter tags by group <u>codes</u>.

                     <b>Parameters</b>
                            <b>codes</b> – group codes to filter

              <b>collect_consecutive_tags(codes:</b> <b>Iterable[int],</b> <b>start:</b> <b>int</b> <b>=</b> <b>0,</b> <b>end:</b> <b>int</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>Tags</u>
                     Collect all consecutive tags with group code in <u>codes</u>, <u>start</u> and <u>end</u>  delimits  the  search
                     range. A tag code not in codes ends the process.

                     <b>Parameters</b>

                            • <b>codes</b> – iterable of group codes

                            • <b>start</b> – start index as int

                            • <b>end</b> – end index as int, <b>None</b> for end index = <b>len(self)</b>

                     <b>Returns</b>
                            collected tags as <u>Tags</u>

              <b>tag_index(code:</b> <b>int,</b> <b>start:</b> <b>int</b> <b>=</b> <b>0,</b> <b>end:</b> <b>int</b> <b>|</b> <b>None</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <b>int</b>
                     Return index of first <u>DXFTag</u> with given group code.

                     <b>Parameters</b>

                            • <b>code</b> – group code as int

                            • <b>start</b> – start index as int

                            • <b>end</b> – end index as int, <b>None</b> for end index = <b>len(self)</b>

              <b>update(tag:</b> <u>DXFTag</u><b>)</b>
                     Update  first  existing  tag  with  same group code as <u>tag</u>, raises <b>DXFValueError</b> if tag not
                     exist.

              <b>set_first(tag:</b> <u>DXFTag</u><b>)</b>
                     Update first existing tag with group code <b>tag.code</b> or append tag.

              <b>remove_tags(codes:</b> <b>Iterable[int])</b> <b>-&gt;</b> <b>None</b>
                     Remove all tags inplace with group codes specified in <u>codes</u>.

                     <b>Parameters</b>
                            <b>codes</b> – iterable of group codes as int

              <b>remove_tags_except(codes:</b> <b>Iterable[int])</b> <b>-&gt;</b> <b>None</b>
                     Remove all tags inplace except those with group codes specified in <u>codes</u>.

                     <b>Parameters</b>
                            <b>codes</b> – iterable of group codes

              <b>pop_tags(codes:</b> <b>Iterable[int])</b> <b>-&gt;</b> <b>Iterable[</b><u>DXFTag</u><b>]</b>
                     Pop tags with group codes specified in <u>codes</u>.

                     <b>Parameters</b>
                            <b>codes</b> – iterable of group codes

              <b>classmethod</b> <b>strip(tags:</b> <u>Tags</u><b>,</b> <b>codes:</b> <b>Iterable[int])</b> <b>-&gt;</b> <u>Tags</u>
                     Constructor from <u>tags</u>, strips all tags with group codes in <u>codes</u> from tags.

                     <b>Parameters</b>

                            • <b>tags</b> – iterable of <u>DXFTag</u>

                            • <b>codes</b> – iterable of group codes as int

       <b>ezdxf.lldxf.tags.group_tags(tags:</b> <b>Iterable[</b><u>DXFTag</u><b>],</b> <b>splitcode:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <b>Iterable[</b><u>Tags</u><b>]</b>
              Group of tags starts with a SplitTag and ends before the next SplitTag.  A SplitTag is a tag  with
              code == splitcode, like (0, ‘SECTION’) for splitcode == 0.

              <b>Parameters</b>

                     • <b>tags</b> – iterable of <b>DXFTag</b>

                     • <b>splitcode</b> – group code of split tag

       <b>class</b> <b>ezdxf.lldxf.extendedtags.ExtendedTags(tags:</b> <b>Iterable[</b><u>DXFTag</u><b>]</b> <b>=</b> <b>None,</b> <b>legacy=False)</b>
              Represents the extended DXF tag structure introduced with DXF R13.

              <b>Args:</b>  tags: iterable of <u>DXFTag</u> legacy: flag for DXF R12 tags

              <b>appdata</b>
                     Application defined data as list of <b>Tags</b>

              <b>subclasses</b>
                     Subclasses as list of <b>Tags</b>

              <b>xdata</b>  XDATA as list of <b>Tags</b>

              <b>embedded_objects</b>
                     embedded objects as list of <b>Tags</b>

              <b>noclass</b>
                     Short cut to access first subclass.

              <b>get_handle()</b> <b>-&gt;</b> <b>str</b>
                     Returns handle as hex string.

              <b>dxftype()</b> <b>-&gt;</b> <b>str</b>
                     Returns DXF type as string like “LINE”.

              <b>replace_handle(handle:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Replace the existing entity handle by a new value.

              <b>legacy_repair()</b>
                     Legacy (DXF R12) tags handling and repair.

              <b>clone()</b> <b>-&gt;</b> <u>ExtendedTags</u>
                     Shallow copy.

              <b>flatten_subclasses()</b>
                     Flatten subclasses in legacy mode (DXF R12).

                     There  exists  DXF  R12  with subclass markers, technical incorrect but works if the reader
                     ignore subclass marker tags, unfortunately ezdxf tries to use  this  subclass  markers  and
                     therefore R12 parsing by ezdxf does not work without removing these subclass markers.

                     This   method   removes   all   subclass   markers   and   flattens   all  subclasses  into
                     ExtendedTags.noclass.

              <b>get_subclass(name:</b> <b>str,</b> <b>pos:</b> <b>int</b> <b>=</b> <b>0)</b> <b>-&gt;</b> <u>Tags</u>
                     Get subclass <u>name</u>.

                     <b>Parameters</b>

                            • <b>name</b> – subclass name as string like “AcDbEntity”

                            • <b>pos</b> – start searching at subclass <u>pos</u>.

              <b>has_xdata(appid:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     <b>True</b> if has XDATA for <u>appid</u>.

              <b>get_xdata(appid:</b> <b>str)</b> <b>-&gt;</b> <u>Tags</u>
                     Returns XDATA for <u>appid</u> as <b>Tags</b>.

              <b>set_xdata(appid:</b> <b>str,</b> <b>tags:</b> <b>IterableTags)</b> <b>-&gt;</b> <b>None</b>
                     Set <u>tags</u> as XDATA for <u>appid</u>.

              <b>new_xdata(appid:</b> <b>str,</b> <b>tags:</b> <b>'IterableTags'</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>Tags</u>
                     Append a new XDATA block.

                     Assumes that no XDATA block with the same <u>appid</u> already exist:

                        try:
                            xdata = tags.get_xdata('EZDXF')
                        except ValueError:
                            xdata = tags.new_xdata('EZDXF')

              <b>has_app_data(appid:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     <b>True</b> if has application defined data for <u>appid</u>.

              <b>get_app_data(appid:</b> <b>str)</b> <b>-&gt;</b> <u>Tags</u>
                     Returns application defined data for <u>appid</u> as <b>Tags</b> including marker tags.

              <b>get_app_data_content(appid:</b> <b>str)</b> <b>-&gt;</b> <u>Tags</u>
                     Returns application defined data for <u>appid</u> as <b>Tags</b> without first and last marker tag.

              <b>set_app_data_content(appid:</b> <b>str,</b> <b>tags:</b> <b>IterableTags)</b> <b>-&gt;</b> <b>None</b>
                     Set application defined data for <u>appid</u> for already exiting data.

              <b>new_app_data(appid:</b> <b>str,</b> <b>tags:</b> <b>'IterableTags'</b> <b>=</b> <b>None,</b> <b>subclass_name:</b> <b>str</b> <b>=</b> <b>None)</b> <b>-&gt;</b> <u>Tags</u>
                     Append a new application defined data to subclass <u>subclass_name</u>.

                     Assumes that no app data block with the same <u>appid</u> already exist:

                        try:
                            app_data = tags.get_app_data('{ACAD_REACTORS', tags)
                        except ValueError:
                            app_data = tags.new_app_data('{ACAD_REACTORS', tags)

              <b>classmethod</b> <b>from_text(text:</b> <b>str,</b> <b>legacy:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <u>ExtendedTags</u>
                     Create <u>ExtendedTags</u> from DXF text.

   <b>Packed</b> <b>DXF</b> <b>Tags</b>
       Store DXF tags in compact data structures as <b>list</b> or <b>array.array</b> to reduce memory usage.

       <b>class</b> <b>ezdxf.lldxf.packedtags.TagList(data:</b> <b>Iterable</b> <b>=</b> <b>None)</b>
              Store data in a standard Python <b>list</b>.

              <b>Args:</b>  data: iterable of DXF tag values.

              <b>values</b> Data storage as <b>list</b>.

              <b>clone()</b> <b>-&gt;</b> <u>TagList</u>
                     Returns a deep copy.

              <b>classmethod</b> <b>from_tags(tags:</b> <u>Tags</u><b>,</b> <b>code:</b> <b>int)</b> <b>-&gt;</b> <u>TagList</u>
                     Setup list from iterable tags.

                     <b>Parameters</b>

                            • <b>tags</b> – tag collection as <u>Tags</u>

                            • <b>code</b> – group code to collect

              <b>clear()</b> <b>-&gt;</b> <b>None</b>
                     Delete all data values.

       <b>class</b> <b>ezdxf.lldxf.packedtags.TagArray(data:</b> <b>Iterable</b> <b>=</b> <b>None)</b>
              <u>TagArray</u> is a subclass of <u>TagList</u>, which store data in an <b>array.array</b>.  Array type is  defined  by
              class variable <b>DTYPE</b>.

              <b>Args:</b>  data: iterable of DXF tag values.

              <b>DTYPE</b>  <b>array.array</b> type as string

              <b>values</b> Data storage as <b>array.array</b>

              <b>set_values(values:</b> <b>Iterable)</b> <b>-&gt;</b> <b>None</b>
                     Replace data by <u>values</u>.

       <b>class</b> <b>ezdxf.lldxf.packedtags.VertexArray(data:</b> <b>Iterable</b> <b>=</b> <b>None)</b>
              Store vertices in an <b>array.array('d')</b>.  Vertex size is defined by class variable <u>VERTEX_SIZE</u>.

              <b>Args:</b>  data: iterable of vertex values as linear list e.g. <b>[x1,</b> <b>y1,</b> <b>x2,</b> <b>y2,</b> <b>x3,</b> <b>y3,</b> <b>...]</b>.

              <b>VERTEX_SIZE</b>
                     Size of vertex (2 or 3 axis).

              <b>__len__()</b> <b>-&gt;</b> <b>int</b>
                     Count of vertices.

              <b>__getitem__(index:</b> <b>int)</b>
                     Get vertex at <u>index</u>, extended slicing supported.

              <b>__setitem__(index:</b> <b>int,</b> <b>point:</b> <b>Sequence[float])</b> <b>-&gt;</b> <b>None</b>
                     Set vertex <u>point</u> at <u>index</u>, extended slicing not supported.

              <b>__delitem__(index:</b> <b>int)</b> <b>-&gt;</b> <b>None</b>
                     Delete vertex at <u>index</u>, extended slicing supported.

              <b>__iter__()</b> <b>-&gt;</b> <b>Iterator[Sequence[float]]</b>
                     Returns iterable of vertices.

              <b>__str__()</b> <b>-&gt;</b> <b>str</b>
                     String representation.

              <b>insert(pos:</b> <b>int,</b> <b>point:</b> <b>Sequence[float])</b>
                     Insert <u>point</u> in front of vertex at index <u>pos</u>.

                     <b>Parameters</b>

                            • <b>pos</b> – insert position

                            • <b>point</b> – point as tuple

              <b>append(point:</b> <b>Sequence[float])</b> <b>-&gt;</b> <b>None</b>
                     Append <u>point</u>.

              <b>extend(points:</b> <b>Iterable[Sequence[float]])</b> <b>-&gt;</b> <b>None</b>
                     Extend array by <u>points</u>.

              <b>set(points:</b> <b>Iterable[Sequence[float]])</b> <b>-&gt;</b> <b>None</b>
                     Replace all vertices by <u>points</u>.

              <b>clear()</b> <b>-&gt;</b> <b>None</b>
                     Delete all vertices.

              <b>clone()</b> <b>-&gt;</b> <u>VertexArray</u>
                     Returns a deep copy.

              <b>classmethod</b> <b>from_tags(tags:</b> <b>Iterable[</b><u>DXFTag</u><b>],</b> <b>code:</b> <b>int</b> <b>=</b> <b>10)</b> <b>-&gt;</b> <u>VertexArray</u>
                     Setup point array from iterable tags.

                     <b>Parameters</b>

                            • <b>tags</b> – iterable of <u>DXFVertex</u>

                            • <b>code</b> – group code to collect

              <b>export_dxf(tagwriter:</b> <b>AbstractTagWriter,</b> <b>code=10)</b>

   <b>XData</b>
       <b>class</b> <b>ezdxf.entities.xdata.XData</b>
              Internal management class for XDATA.

              <b>SEE</b> <b>ALSO:</b>

                 • XDATA user reference: <u>Extended</u> <u>Data</u> <u>(XDATA)</u>

                 • Wrapper class to store a list in XDATA: <u>XDataUserList</u>

                 • Wrapper class to store a dict in XDATA: <u>XDataUserDict</u>

                 • Tutorial: <u>Storing</u> <u>Custom</u> <u>Data</u> <u>in</u> <u>DXF</u> <u>Files</u>

                 • DXF Internals: <u>Extended</u> <u>Data</u>

                 • <u>DXF</u> <u>R2018</u> <u>Reference</u>

              <b>__contains__(appid:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if  DXF tags for <u>appid</u> exist.

              <b>add(appid:</b> <b>str,</b> <b>tags:</b> <b>Iterable[tuple[int,</b> <b>Any]</b> <b>|</b> <u>DXFTag</u><b>])</b> <b>-&gt;</b> <b>None</b>
                     Add  a  list of DXF tags for <u>appid</u>. The <u>tags</u> argument is an iterable of (group code, value)
                     tuples, where the group code has to be an integer value. The mandatory XDATA marker  (1001,
                     appid) is added automatically if front of the tags if missing.

                     Each entity can contain only one list of tags for each <u>appid</u>.  Adding a second list of tags
                     for the same <u>appid</u> replaces the existing list of tags.

                     The  valid  XDATA group codes are restricted to some specific values in the range from 1000
                     to 1071, for more information see also the internals about <u>Extended</u> <u>Data</u>.

              <b>get(appid:</b> <b>str)</b> <b>-&gt;</b> <u>Tags</u>
                     Returns the DXF tags as <u>Tags</u> list stored by <u>appid</u>.

                     <b>Raises</b> <u>DXFValueError</u> – no data for <u>appid</u> exist

              <b>discard(appid)</b>
                     Delete DXF tags for <u>appid</u>. None existing appids are silently ignored.

              <b>has_xlist(appid:</b> <b>str,</b> <b>name:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if list <u>name</u> from XDATA <u>appid</u> exists.

                     <b>Parameters</b>

                            • <b>appid</b> – APPID

                            • <b>name</b> – list name

              <b>get_xlist(appid:</b> <b>str,</b> <b>name:</b> <b>str)</b> <b>-&gt;</b> <b>list[tuple]</b>
                     Get list <u>name</u> from XDATA <u>appid</u>.

                     <b>Parameters</b>

                            • <b>appid</b> – APPID

                            • <b>name</b> – list name

                     Returns: list of DXFTags including list name and curly braces ‘{’ ‘}’ tags

                     <b>Raises</b>

                            • <u>DXFKeyError</u> – XDATA <u>appid</u> does not exist

                            • <u>DXFValueError</u> – list <u>name</u> does not exist

              <b>set_xlist(appid:</b> <b>str,</b> <b>name:</b> <b>str,</b> <b>tags:</b> <b>Iterable)</b> <b>-&gt;</b> <b>None</b>
                     Create new list <u>name</u> of XDATA <u>appid</u> with <u>xdata_tags</u>  and  replaces  list  <u>name</u>  if  already
                     exists.

                     <b>Parameters</b>

                            • <b>appid</b> – APPID

                            • <b>name</b> – list name

                            • <b>tags</b> – list content as DXFTags or (code, value) tuples, list name and curly braces
                              ‘{’ ‘}’ tags will be added

              <b>discard_xlist(appid:</b> <b>str,</b> <b>name:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Deletes list <u>name</u> from XDATA <u>appid</u>. Ignores silently if XDATA <u>appid</u> or list <u>name</u> not exist.

                     <b>Parameters</b>

                            • <b>appid</b> – APPID

                            • <b>name</b> – list name

              <b>replace_xlist(appid:</b> <b>str,</b> <b>name:</b> <b>str,</b> <b>tags:</b> <b>Iterable)</b> <b>-&gt;</b> <b>None</b>
                     Replaces  list  <u>name</u>  of existing XDATA <u>appid</u> by <u>tags</u>. Appends new list if list <u>name</u> do not
                     exist, but raises <u>DXFValueError</u> if XDATA <u>appid</u> do not exist.

                     Low level interface, if not sure use <u>set_xdata_list()</u> instead.

                     <b>Parameters</b>

                            • <b>appid</b> – APPID

                            • <b>name</b> – list name

                            • <b>tags</b> – list content as DXFTags or (code, value) tuples, list name and curly braces
                              ‘{’ ‘}’ tags will be added

                     <b>Raises</b> <u>DXFValueError</u> – XDATA <u>appid</u> do not exist

              <b>transform(m:</b> <u>Matrix44</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Transform XDATA tags with group codes 1011, 1012, 1013, 1041 and  1042  inplace.  For  more
                     information see <u>Extended</u> <u>Data</u> Internals.

   <b>Application-Defined</b> <b>Data</b> <b>(AppData)</b>
       Starting at DXF R13, DXF objects can contain application-defined codes (AppData) outside of XDATA.

       All  AppData  is  defined  with a beginning (102, “{APPID”) tag and according to the DXF reference appear
       should appear before the first subclass marker.

       There are two known use cases of this data structure in Autodesk products:

       • <b>ACAD_REACTORS</b>, store handles to persistent reactors in a DXF entity

       • <b>ACAD_XDICTIONARY</b>, store handle to the extension dictionary of a DXF entity

       Both AppIDs are not defined/stored in the AppID table!

       <b>class</b> <b>ezdxf.entities.appdata.AppData</b>
              Internal management class for Application defined data.

              <b>SEE</b> <b>ALSO:</b>

                 • User reference: <u>Application-Defined</u> <u>Data</u> <u>(AppData)</u>

                 • Internals about <u>Application-Defined</u> <u>Codes</u> tags

              <b>__contains__(appid:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if application-defined data exist for <u>appid</u>.

              <b>__len__()</b> <b>-&gt;</b> <b>int</b>
                     Returns the count of AppData.

              <b>add(appid:</b> <b>str,</b> <b>data:</b> <b>Iterable[Sequence])</b> <b>-&gt;</b> <b>None</b>
                     Add application-defined tags for <u>appid</u>.  Adds first tag (102, “{APPID”) if not exist.  Adds
                     last tag (102, “}” if not exist.

              <b>get(appid:</b> <b>str)</b> <b>-&gt;</b> <u>Tags</u>
                     Get application-defined data for <u>appid</u> as <u>Tags</u> container.  The first tag  is  always  (102,
                     “{APPID”).  The last tag is always (102, “}”).

              <b>set(tags:</b> <u>Tags</u><b>)</b> <b>-&gt;</b> <b>None</b>
                     Store  raw  application-defined  data  tags.  The first tag has to be (102, “{APPID”).  The
                     last tag has to be (102, “}”).

              <b>discard(appid:</b> <b>str)</b>
                     Delete application-defined data for <u>appid</u> without raising and error if <u>appid</u> doesn’t exist.

   <b>Reactors</b>
       <b>class</b> <b>ezdxf.entities.appdata.Reactors</b>
              Internal management class for persistent reactor handles. Handles are stored as hex  strings  like
              <b>"ABBA"</b>.

              <b>SEE</b> <b>ALSO:</b>

                 • User reference: <u>Reactors</u>

                 • Internals about <u>Persistent</u> <u>Reactors</u> tags

              <b>__contains__(handle:</b> <b>str)</b> <b>-&gt;</b> <b>bool</b>
                     Returns <b>True</b> if <u>handle</u> is registered.

              <b>__len__()</b> <b>-&gt;</b> <b>int</b>
                     Returns count of registered handles.

              <b>__iter__()</b> <b>-&gt;</b> <b>Iterator[str]</b>
                     Returns an iterator for all registered handles.

              <b>add(handle:</b> <b>str)</b> <b>-&gt;</b> <b>None</b>
                     Add a single <u>handle</u>.

              <b>get()</b> <b>-&gt;</b> <b>list[str]</b>
                     Returns all registered handles as sorted list.

              <b>set(handles:</b> <b>Iterable[str]</b> <b>|</b> <b>None)</b> <b>-&gt;</b> <b>None</b>
                     Reset all handles.

              <b>discard(handle:</b> <b>str)</b>
                     Discard a single <u>handle</u>.

   <b>Documentation</b> <b>Guide</b>
   <b>Formatting</b> <b>Guide</b>
       This section is only for <u>myself</u>, because of the long pauses between develop iterations, I often forget to
       be consistent in documentation formatting.

       Documentation is written with <u>Sphinx</u> and <u>reSturcturedText</u>.

       Started  integration  of  documentation  into  source  code and using <u>autodoc</u> features of <u>Sphinx</u> wherever
       useful.

       Sphinx theme provided by <u>Read</u> <u>the</u> <u>Docs</u> :

          pip install sphinx-rtd-theme

   <u><b>guide</b></u> <b>—</b> <b>Example</b> <b>module</b>
       <b>guide.example_func(a:</b> <b>int,</b> <b>b:</b> <b>str,</b> <b>test:</b> <b>str</b> <b>=</b> <b>None,</b> <b>flag:</b> <b>bool</b> <b>=</b> <b>True)</b> <b>-&gt;</b> <b>None</b>
              Parameters <u>a</u> and <u>b</u> are positional arguments, argument <u>test</u> defaults to <b>None</b> and <u>flag</u> to <b>True</b>.  Set
              <u>a</u> to 70 and <u>b</u> to “x”  as  an  example.  Inline  code  examples  <b>example_func(70,</b>  <b>'x')</b>  or  simple
              <b>example_func(70,</b> <b>"x")</b>

                 • arguments: <u>a</u>, <u>b</u>, <u>test</u> and <u>flags</u>

                 • literal number values: 1, 2 … 999

                 • literal string values: “a String”

                 • literal tags: (5, “F000”)

                 • inline code: call a <b>example_func(x)</b>

                 • Python keywords: <b>None</b>, <b>True</b>, <b>False</b>, <b>tuple</b>, <b>list</b>, <b>dict</b>, <b>str</b>, <b>int</b>, <b>float</b>

                 • Exception classes: <b>DXFAttributeError</b>

       <b>class</b> <b>guide.ExampleCls(**kwargs)</b>
              The  <u>ExampleCls</u> constructor accepts a number of optional keyword arguments.  Each keyword argument
              corresponds to an instance attribute, so for example

                 e = ExampleCls(flag=True)

              <b>flag</b>   This is the attribute <u>flag</u>.

              <b>set_axis(axis)</b>
                     axis as (x, y, z) tuple

                     <b>Args:</b>  axis: (x, y, z) tuple

              <b>example_method(flag:</b> <b>bool</b> <b>=</b> <b>False)</b> <b>-&gt;</b> <b>None</b>
                     Method <u>example_method()</u> of class <u>ExampleCls</u>

   <b>Text</b> <b>Formatting</b>
       <b>DXF</b> <b>version</b>
              DXF R12 (AC1009), DXF R2004 (AC1018)

       <b>DXF</b> <b>Types</b>
              DXF types are always written in uppercase letters  but  without  further  formatting:  DXF,  LINE,
              CIRCLE

       <b>(internal</b> <b>API)</b>
              Marks methods as internal API, gets no public documentation.

       <b>(internal</b> <b>class)</b>
              Marks classes only for internal usage, gets not public documentation.

       <b>Spatial</b> <b>Dimensions</b>
              2D and 3D with an uppercase letter D

       <b>Axis</b>   x-axis, y-axis and z-axis

       <b>Planes</b> xy-plane, xz-plane, yz-plane

       <b>Layouts</b>
              modelspace, paperspace [layout], block [layout]

       <b>Extended</b> <b>Entity</b> <b>Data</b>
              AppData, XDATA, embedded object, APPID

</pre><h4><b>GLOSSARY</b></h4><pre>
       <b>ACI</b>    <u>AutoCAD</u> <u>Color</u> <u>Index</u> <u>(ACI)</u>

       <b>ACIS</b>   The  3D  ACIS Modeler (<u>ACIS</u>) is a geometric modeling kernel developed by <u>Spatial</u> <u>Corp.</u> ® (formerly
              <u>Spatial</u> <u>Technology</u>) and now part of <u>Dassault</u> <u>Systems</u>. All ACIS  based  DXF  entities  store  their
              geometry  as <u>SAT</u> or <u>SAB</u> data. These are not open data formats and a license has to be purchased to
              get access to their SDK, therefore <u>ezdxf</u> can not provide any support for creating,  processing  or
              transforming of ACIS based DXF entities.

       <b>bulge</b>  The <u>Bulge</u> <u>value</u> is used to create arc shaped line segments in <u>Polyline</u> and <u>LWPolyline</u> entities.

       <b>CAD</b>    Computer-Assisted Drafting or Computer-Aided Design

       <b>CTB</b>    Color dependent plot style table (<b>ColorDependentPlotStyles</b>)

       <b>DWG</b>    Proprietary  file  format  of  <u>AutoCAD</u> ®. Documentation for this format is available from the Open
              Design Alliance (<u>ODA</u>) at their  <u>Downloads</u>  section.  This  documentation  is  created  by  reverse
              engineering therefore not perfect nor complete.

       <b>DXF</b>    Drawing  eXchange  Format  is  a  file format used by <u>AutoCAD</u> ® to interchange data with other <u>CAD</u>
              applications. <u>DXF</u> is a trademark of <u>Autodesk</u> ®. See also <u>What</u> <u>is</u> <u>DXF?</u>

       <b>proxy-graphic</b>
              The proxy-graphic is an internal data format to add a graphical  representation  to  DXF  entities
              which  are  unknown  (custom DXF entities), not documented or very complex so CAD applications can
              display them without knowledge about the internal structure of these entities.

       <b>raw-color</b>
              Raw color value as stored in DWG files, this integer value can represent <u>ACI</u> values as well as and
              <u>true-color</u> values

       <b>reliable</b> <b>CAD</b> <b>application</b>
              CAD applications which create valid DXF documents in the meaning and interpretation  of  <u>Autodesk</u>.
              See also <u>What</u> <u>is</u> <u>DXF?</u>

       <b>SAB</b>    ACIS file format (Standard ACIS Binary), binary stored data

       <b>SAT</b>    ACIS file format (Standard ACIS Text), data stored as ASCII text

       <b>STB</b>    Named plot style table (<b>NamedPlotStyles</b>)

       <b>true-color</b>
              RGB color representation, a combination red, green and blue values to define a color.

</pre><h4><b>KNOWLEDGE</b> <b>GRAPH</b></h4><pre>
       I have started managing notes and documents that are not included in the <u>ezdxf</u> documentation in <u>Logseq</u> in
       late  2023.   It  works  like  a wiki but does not require a backend server. The Information is edited as
       Markdown files, which is much more intuitive than reStructured Text, and the content is stored  in  local
       files.

       The notes are included in the source code repository on Github in the <u>notes</u> <u>folder</u>.

       A  published  edition  of  this Knowledge Graph is included on the <u>ezdxf</u> website and is accessible by the
       link <u>https://ezdxf.mozman.at/notes</u>.

       The Knowledge Graph includes:

       • <u>Release</u> <u>Notes</u> of future releases and some versions back

       • <u>CHANGELOG</u>

       • <u>IDEAS</u> for future releases

       • <u>FAQ</u> and the <u>HOWTO</u> sections from this documentation

       • all my notes to <u>ezdxf</u>

       • In the future the <u>DXF</u> <u>Internals</u> section from this documentation may also move to the Knowledge Graph.

       Logseq’s outline structure is not ideal for all the documents I want to include, but I chose <u>Logseq</u>  over
       <u>Obsidian.md</u>  because it is open source and can publish the knowledge graph as a static website, static in
       the sense of no server-side code execution.

       his feature is important to me for hosting the content of the Knowledge Graph on the <u>ezdxf`</u> website   and
       cannot be achieved for free with <u>Obsidian.md</u>.

       <u>Logseq</u>  is  an  <u>Electron</u>  application that runs on all platforms, with the disadvantage: it’s an <u>Electron</u>
       application.

</pre><h4><b>INDICES</b> <b>AND</b> <b>TABLES</b></h4><pre>
       • <u>Index</u>

       • <u>Search</u> <u>Page</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Manfred Moitzi

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2011-2023, Manfred Moitzi

1.1.3                                             Nov 25, 2023                                          <u><a href="../man1/EZDXF.1.html">EZDXF</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>