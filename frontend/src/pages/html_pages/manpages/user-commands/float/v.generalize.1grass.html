<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.generalize  - Performs vector based generalization.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.generalize</b>  - Performs vector based generalization.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector,  generalization,  simplification,  smoothing,  displacement,  network  generalization,  topology,
       geometry

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.generalize</b>
       <b>v.generalize</b> <b>--help</b>
       <b>v.generalize</b> [-<b>lt</b>] <b>input</b>=<u>name</u>   [<b>layer</b>=<u>string</u>]    [<b>type</b>=<u>string</u>[,<u>string</u>,...]]   <b>output</b>=<u>name</u>   [<b>error</b>=<u>name</u>]
       <b>method</b>=<u>string</u>      <b>threshold</b>=<u>float</u>       [<b>look_ahead</b>=<u>integer</u>]       [<b>reduction</b>=<u>float</u>]       [<b>slide</b>=<u>float</u>]
       [<b>angle_thresh</b>=<u>float</u>]    [<b>degree_thresh</b>=<u>integer</u>]    [<b>closeness_thresh</b>=<u>float</u>]     [<b>betweeness_thresh</b>=<u>float</u>]
       [<b>alpha</b>=<u>float</u>]    [<b>beta</b>=<u>float</u>]    [<b>iterations</b>=<u>integer</u>]    [<b>cats</b>=<u>range</u>]   [<b>where</b>=<u>sql_query</u>]   [--<b>overwrite</b>]
       [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-l</b>
           Disable loop support
           Do not modify end points of lines forming a closed loop

       <b>-t</b>
           Do not copy attributes

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Or data source for direct OGR access

       <b>layer</b>=<u>string</u>
           Layer number or name (’-1’ for all layers)
           A single vector map can be connected to multiple database tables. This number determines which  table
           to use. When used with direct OGR access this is the layer name.
           Default: <u>-1</u>

       <b>type</b>=<u>string[,string</u>,...]
           Input feature type
           Options: <u>line,</u> <u>boundary,</u> <u>area</u>
           Default: <u>line,boundary,area</u>

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for output vector map

       <b>error</b>=<u>name</u>
           Error map with failed generalizations
           Lines and boundaries causing errors (collapsed to a point or topology errors)

       <b>method</b>=<u>string</u> <b>[required]</b>
           Generalization algorithm
           Options:   <u>douglas,</u>   <u>douglas_reduction,</u>   <u>lang,</u>   <u>reduction,</u>   <u>reumann,</u>   <u>boyle,</u>  <u>sliding_averaging,</u>
           <u>distance_weighting,</u> <u>chaiken,</u> <u>hermite,</u> <u>snakes,</u> <u>network,</u> <u>displacement</u>
           <b>douglas</b>: Douglas-Peucker Algorithm
           <b>douglas_reduction</b>: Douglas-Peucker Algorithm with reduction parameter
           <b>lang</b>: Lang Simplification Algorithm
           <b>reduction</b>: Vertex Reduction Algorithm eliminates points close to each other
           <b>reumann</b>: Reumann-Witkam Algorithm
           <b>boyle</b>: Boyle’s Forward-Looking Algorithm
           <b>sliding_averaging</b>: McMaster’s Sliding Averaging Algorithm
           <b>distance_weighting</b>: McMaster’s Distance-Weighting Algorithm
           <b>chaiken</b>: Chaiken’s Algorithm
           <b>hermite</b>: Interpolation by Cubic Hermite Splines
           <b>snakes</b>: Snakes method for line smoothing
           <b>network</b>: Network generalization
           <b>displacement</b>: Displacement of lines close to each other

       <b>threshold</b>=<u>float</u> <b>[required]</b>
           Maximal tolerance value
           Options: <u>0-1000000000</u>

       <b>look_ahead</b>=<u>integer</u>
           Look-ahead parameter
           Default: <u>7</u>

       <b>reduction</b>=<u>float</u>
           Percentage of the points in the output of ’douglas_reduction’ algorithm
           Options: <u>0-100</u>
           Default: <u>50</u>

       <b>slide</b>=<u>float</u>
           Slide of computed point toward the original point
           Options: <u>0-1</u>
           Default: <u>0.5</u>

       <b>angle_thresh</b>=<u>float</u>
           Minimum angle between two consecutive segments in Hermite method
           Options: <u>0-180</u>
           Default: <u>3</u>

       <b>degree_thresh</b>=<u>integer</u>
           Degree threshold in network generalization
           Default: <u>0</u>

       <b>closeness_thresh</b>=<u>float</u>
           Closeness threshold in network generalization
           Options: <u>0-1</u>
           Default: <u>0</u>

       <b>betweeness_thresh</b>=<u>float</u>
           Betweeness threshold in network generalization
           Default: <u>0</u>

       <b>alpha</b>=<u>float</u>
           Snakes alpha parameter
           Default: <u>1.0</u>

       <b>beta</b>=<u>float</u>
           Snakes beta parameter
           Default: <u>1.0</u>

       <b>iterations</b>=<u>integer</u>
           Number of iterations
           Default: <u>1</u>

       <b>cats</b>=<u>range</u>
           Category values
           Example: 1,3,7-9,13

       <b>where</b>=<u>sql_query</u>
           WHERE conditions of SQL statement without ’where’ keyword
           Example: income &lt; 1000 and population &gt;= 10000

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.generalize</u> is a module for the generalization of GRASS vector maps. This module consists of  algorithms
       for  line  simplification,  line  smoothing,  network generalization and displacement (new methods may be
       added later).

       The <b>cats</b> and <b>where</b> options are used only if a <b>layer</b> &gt;  0  is  specified,  otherwise,  those  options  are
       ignored.  Be aware that the default is <u>layer=-1</u>, meaning that all layers are processed, ignoring the <b>cats</b>
       and <b>where</b> options.

       If <b>type=area</b> is selected, boundaries of selected areas will be generalized, and the options <b>cats</b>,  <b>where</b>,
       and <b>layer</b> will be used to select areas.

</pre><h4><b>NOTES</b></h4><pre>
       (Line) simplification is a process of reducing the complexity of vector features. The module transforms a
       line  into  another  line consisting of fewer vertices, that still approximate the original line. Most of
       the algorithms described below select a subset of points on the original line.

       (Line) smoothing is a "reverse" process which takes as input a line and produces a  smoother  approximate
       of  the  original.  In some cases, this is achieved by inserting new vertices into the original line, and
       can total up to 4000% of the number of vertices in the original. In such an instance, it is always a good
       idea to simplify the line after smoothing.

       Smoothing  and  simplification  algorithms  implemented  in  this  module  work  line   by   line,   i.e.
       simplification/smoothing  of  one  line does not affect the other lines; they are treated separately. For
       isolated loops formed by a single line/boundary, he first and the last point of each line/boundary can be
       translated and/or deleted, unless the <u>-l</u> flag is used to disable loop support.

       Lines and boundaries are not translated if they would collapse to a  single  point.  Boundaries  are  not
       translated  if  they  would  intersect  with  themselves or other boundaries. Such erroneous features are
       written to an optional <u>error</u> vector map. Overlaying the <u>error</u> map over the generalized map indicates  the
       kind  of  error.   Lines/boundaries collapsing to a point are written out as points, boundaries violating
       topology are written out as boundaries. The <u>error</u> map  can  be  overlaid  over  the  generalized  map  to
       understand why some features were not generalized.

   <b>SIMPLIFICATION</b>
       Simplification  can  fail  for  many  boundaries if the simplification parameters would result in a large
       reduction of vertices. If many lines/boundaries could not be simplified, try  different  parameters  that
       would cause a lower degree of simplification.

       <u>v.generalize</u> contains following line simplification algorithms:

           •   Douglas-Peucker Algorithm

           •   Douglas-Peucker Reduction Algorithm

           •   Lang Algorithm

           •   Vertex Reduction

           •   Reumann-Witkam Algorithm
       Different  algorithms  require different parameters, but all the algorithms have one parameter in common:
       the <b>threshold</b> parameter, given in map units (for latitude-longitude  projects:  in  decimal  degree).  In
       general, the degree of simplification increases with the increasing value of <b>threshold</b>.

   <b>ALGORITHM</b> <b>DESCRIPTIONS</b>
           •   <u>Douglas-Peucker</u>  -  "Quicksort"  of  line  simplification,  the most widely used algorithm. Input
               parameters: <b>input</b>, <b>threshold</b>. For more information, see:
               <a href="http://geomalgorithms.com/a16-_decimate-1.html">http://geomalgorithms.com/a16-_decimate-1.html</a>.

           •   <u>Douglas-Peucker</u> <u>Reduction</u> <u>Algorithm</u> is essentially the same algorithm as the algorithm above, the
               difference being that it takes an additional <b>reduction</b> parameter which denotes the percentage  of
               the  number  of points on the new line with respect to the number of points on the original line.
               Input parameters: <b>input</b>, <b>threshold</b>, <b>reduction</b>.

           •   <u>Lang</u> - Another standard algorithm.  Input  parameters:  <b>input</b>,  <b>threshold</b>,  <b>look_ahead</b>.   For  an
               excellent description, see:
               <a href="http://www.sli.unimelb.edu.au/gisweb/LGmodule/LGLangVisualisation.htm">http://www.sli.unimelb.edu.au/gisweb/LGmodule/LGLangVisualisation.htm</a>.

           •   <u>Vertex</u>  <u>Reduction</u>  -  Simplest among the algorithms. Input parameters: <b>input</b>, <b>threshold</b>.  Given a
               line, this algorithm removes the points of  this  line  which  are  closer  to  each  other  than
               <b>threshold</b>.  More  precisely, if p1 and p2 are two consecutive points, and the distance between p2
               and p1 is less than <b>threshold</b>, it removes p2 and  repeats  the  same  process  on  the  remaining
               points.

           •   <u>Reumann-Witkam</u>  -  Input parameters: <b>input</b>, <b>threshold</b>.  This algorithm quite reasonably preserves
               the global characteristics of the lines. For more information, see for example:
               <a href="http://psimpl.sourceforge.net/reumann-witkam.html">http://psimpl.sourceforge.net/reumann-witkam.html</a>.
       <u>Douglas-Peucker</u> and <u>Douglas-Peucker</u> <u>Reduction</u> <u>Algorithm</u> use the same method to simplify the  lines.  Note
       that
       v.generalize input=boundary_county output=boundary_county_dp20 method=douglas threshold=20
       is equivalent to
       v.generalize input=boundary_county output=boundary_county_dp_red20_100 \
                    method=douglas_reduction threshold=20 reduction=100
       However, in this case, the first method is faster. Also observe that <u>douglas_reduction</u> never outputs more
       vertices  than  <u>douglas</u>,  and  that,  in  general, <u>douglas</u> is more efficient than <u>douglas_reduction</u>. More
       importantly, the effect of
       v.generalize input=boundary_county output=boundary_county_dp_red0_30 \
                    method=douglas_reduction threshold=0 reduction=30
       is that ’out’ contains approximately only 30% of points of ’in’.

   <b>SMOOTHING</b>
       The following smoothing algorithms are implemented in <u>v.generalize</u>:

           •   <u>Boyle’s</u> <u>Forward-Looking</u> <u>Algorithm</u> - The position of each point depends on  the  position  of  the
               previous  points and the point <b>look_ahead</b> ahead. <b>look_ahead</b> consecutive points. Input parameters:
               <b>input</b>, <b>look_ahead</b>.

           •   <u>McMaster’s</u> <u>Sliding</u> <u>Averaging</u> <u>Algorithm</u> - Input Parameters: <b>input</b>,  <b>slide</b>,  <b>look_ahead</b>.   The  new
               position  of  each  point is the average of the <b>look_ahead</b> points around. Parameter <b>slide</b> is used
               for linear interpolation between old and new position (see below).

           •   <u>McMaster’s</u> <u>Distance-Weighting</u> <u>Algorithm</u> - Takes the weighted average  of  <b>look_ahead</b>  consecutive
               points  where  the  weight  is  the  reciprocal  of  the distance from the point to the currently
               smoothed point. The parameter <b>slide</b>  is  used  for  linear  interpolation  between  the  original
               position  of  the  point  and  newly computed position where value 0 means the original position.
               Input parameters: <b>input</b>, <b>slide</b>, <b>look_ahead</b>.

           •   <u>Chaiken’s</u> <u>Algorithm</u> - "Inscribes" a line touching the original line such that the points on  this
               new  line  are  at  least  <u>threshold</u>  apart.  Input  parameters: <b>input</b>, <b>threshold</b>. This algorithm
               approximates the given line very well.

           •   <u>Hermite</u> <u>Interpolation</u> - This algorithm takes the points of the given line as the  control  points
               of hermite cubic spline and approximates this spline by the points approximately <b>threshold</b> apart.
               This  method  has excellent results for small values of <b>threshold</b>, but in this case it produces a
               huge number of new points and some simplification is usually needed.   Input  parameters:  <b>input</b>,
               <b>threshold</b>, <b>angle_thresh</b>.  <b>Angle_thresh</b> is used for reducing the number of the points.  It denotes
               the minimal angle (in degrees) between two consecutive segments of a line.

           •   <u>Snakes</u> is the method of minimisation of the "energy" of a line. This method preserves the general
               characteristics  of  the lines but smooths the "sharp corners" of a line. Input parameters <b>input</b>,
               <b>alpha</b>, <b>beta</b>.  This algorithm works very well for small values of <b>alpha</b> and <b>beta</b>  (between  0  and
               5). These parameters affect the "sharpness" and the curvature of the computed line.
       One  of  the  key  advantages  of  <u>Hermite</u> <u>Interpolation</u> is the fact that the computed line always passes
       through the points of the original line, whereas the lines produced by  the  remaining  algorithms  never
       pass  through  these points. In some sense, this algorithm outputs a line which "circumscribes" the input
       line.

       On the other hand, <u>Chaiken’s</u> <u>Algorithm</u> outputs a line which "inscribes" a given  line.  The  output  line
       always  touches/intersects  the centre of the input line segment between two consecutive points. For more
       iterations, the property above does not hold, but the computed lines  are  very  similar  to  the  Bezier
       Splines.  The  disadvantage of the two algorithms given above is that they increase the number of points.
       However, <u>Hermite</u> <u>Interpolation</u> can be used as another simplification algorithm. To achieve  this,  it  is
       necessary to set <u>angle_thresh</u> to higher values (15 or so).

       One  restriction  on  both McMasters’ Algorithms is that <u>look_ahead</u> parameter must be odd. Also note that
       these algorithms have no effect if <u>look_ahead</u> <u>=</u> <u>1</u>.

       Note that <u>Boyle’s</u>, <u>McMasters’</u> and <u>Snakes</u> algorithm are sometimes used in the signal processing to  smooth
       the  signals.   More  importantly,  these algorithms never change the number of points on the lines; they
       only translate the points, and do not insert any new points.

       <u>Snakes</u> Algorithm is (asymptotically) the slowest among the algorithms presented above. Also, it  requires
       quite  a  lot  of memory.  This means that it is not very efficient for maps with the lines consisting of
       many segments.

   <b>DISPLACEMENT</b>
       The displacement is used when the lines overlap and/or are close to each other at the  current  level  of
       detail. In general, displacement methods move the conflicting features apart so that they do not interact
       and can be distinguished.

       This  module  implements  an  algorithm for displacement of linear features based on the <u>Snakes</u> approach.
       This method generally yields very good results; however, it requires a lot of  memory  and  is  not  very
       efficient.

       Displacement is selected by <b>method=displacement</b>. It uses the following parameters:

           •   <b>threshold</b>  - specifies critical distance. Two features interact if they are closer than <b>threshold</b>
               apart.

           •   <b>alpha</b>, <b>beta</b> - These parameters define the rigidity of lines.  For larger values  of  <b>alpha</b>,  <b>beta</b>
               (&gt;=1),  the algorithm does a better job at retaining the original shape of the lines, possibly at
               the expense of displacement distance. If the values of <b>alpha</b>, <b>beta</b> are too small (&lt;=0.001),  then
               the  lines are moved sufficiently, but the geometry and topology of lines can be destroyed.  Most
               likely the best way to find the good values of <b>alpha</b>, <b>beta</b> is by trial and error.

           •   <b>iterations</b> - denotes the number of iterations the interactions between the  lines  are  resolved.
               Good starting points for values of <b>iterations</b> are between 10 and 100.
       The lines affected by the algorithm can be specified by the <b>layer</b>, <b>cats</b> and <b>where</b> parameters.

   <b>NETWORK</b> <b>GENERALIZATION</b>
       Used  for  selecting  "the  most  important"  part of the network. This is based on the graph algorithms.
       Network generalization is applied if method=network.  The algorithm calculates three centrality  measures
       for  each  line  in  the network and only the lines with the values greater than thresholds are selected.
       The behaviour of algorithm can be altered by the following parameters:

           •   <b>degree_thresh</b> - algorithm selects only the lines which share a point with at least  <b>degree_thresh</b>
               different lines.

           •   <b>closeness_thresh</b>  -  is  always in the range (0, 1]. Only the lines with the closeness centrality
               value at least <b>closeness_thresh</b> apart are selected. The lines in the centre  of  a  network  have
               greater  values of this measure than the lines near the border of a network. This means that this
               parameter can be used for selecting the centre(s) of a network. Note that  if  closeness_thresh=0
               then everything is selected.

           •   <b>betweeness_thresh</b>  -  Again,  only  the  lines  with  a  betweeness  centrality  measure at least
               <b>betweeness_thresh</b> are selected. This value is always positive and is larger for  large  networks.
               It  denotes  to  what  extent  a line is in between the other lines in the network. This value is
               large for the lines which lie between other lines and lie on the paths between  two  parts  of  a
               network.  In  the terminology of road networks, these are highways, bypasses, main roads/streets,
               etc.
       All three parameters above can be presented at the same time. In that case, the  algorithm  selects  only
       the lines which meet each criterion.

       Also, the outputted network may not be connected if the value of <b>betweeness_thresh</b> is too large.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>SIMPLIFICATION</b> <b>EXAMPLE</b>
       Simplification  of  county  boundaries with DP method (North Carolina sample dataset), threshold given in
       mapset units (here: meters):
       v.generalize input=boundary_county output=boundary_county_dp20 \
         method=douglas threshold=20 error=boundary_county_dp20_leftover
       <u>Figure:</u> <u>Vector</u> <u>simplification</u> <u>example</u> <u>(spatial</u> <u>subset:</u> <u>original</u> <u>map</u> <u>shown</u> <u>in</u> <u>black,</u> <u>simplified</u>  <u>map</u>  <u>with</u>
       <u>26%</u> <u>remaining</u> <u>vertices</u> <u>shown</u> <u>in</u> <u>red)</u>

   <b>SMOOTHING</b> <b>EXAMPLE</b>
       Smoothing  of road network with Chaiken method (North Carolina sample dataset), threshold given in mapset
       units (here: meters):
       v.generalize input=roads output=roads_chaiken method=chaiken \
         threshold=1 error=roads_chaiken_leftover
       <u>Figure:</u> <u>Vector</u> <u>smoothing</u> <u>example</u> <u>(spatial</u> <u>subset:</u> <u>original</u> <u>map</u> <u>shown</u> <u>in</u> <u>black,</u>  <u>smoothed</u>  <u>map</u>  <u>with</u>  <u>500%</u>
       <u>increased</u> <u>number</u> <u>of</u> <u>vertices</u> <u>shown</u> <u>in</u> <u>red)</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>v.clean,</u> <u>v.dissolve</u>

       v.generalize Tutorial (GRASS-Wiki)

</pre><h4><b>AUTHORS</b></h4><pre>
       Daniel Bundala, Google Summer of Code 2007, Student
       Wolf Bergenheim, Mentor
       Partial rewrite: Markus Metz

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.generalize source code (history)

       Accessed: Friday Apr 04 01:20:20 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                 <u><a href="../man1grass/v.generalize.1grass.html">v.generalize</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>