<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commands and command line parameters -</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fsvs">fsvs_1.2.12-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Commands and command line parameters -

       fsvs is a client for subversion repositories; it is designed for fast versioning of big directory trees.
       fsvs is a client for subversion repositories; it is designed for fast versioning of big directory trees.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       fsvs command [options] [args]

       The following commands are understood by FSVS:

</pre><h4><b>Local</b> <b>configuration</b> <b>and</b> <b>information:</b></h4><pre>
       <b>urls</b>
           Define working copy base directories by their URL(s)

       <b>status</b>
           Get a list of changed entries

       <b>info</b>
           Display detailed information about single entries

       <b>log</b>
           Fetch the log messages from the repository

       <b>diff</b>
           Get differences between files (local and remote)

       <b>copyfrom-detect</b>
           Ask FSVS about probably copied/moved/renamed entries; see <b>cp</b>

</pre><h4><b>Defining</b> <b>which</b> <b>entries</b> <b>to</b> <b>take:</b></h4><pre>
       <b>ignore</b> <b>and</b> <b>rign</b>
           Define ignore patterns

       <b>unversion</b>
           Remove entries from versioning

       <b>add</b>
           Add entries that would be ignored

       <b>cp,</b> <b>mv</b>
           Tell FSVS that entries were copied

</pre><h4><b>Commands</b> <b>working</b> <b>with</b> <b>the</b> <b>repository:</b></h4><pre>
       <b>commit</b>
           Send changed data to the repository

       <b>update</b>
           Get updates from the repository

       <b>checkout</b>
           Fetch some part of the repository, and register it as working copy

       <b>cat</b>
           Get a file from the directory

       <b>revert</b> <b>and</b> <b>uncp</b>
           Undo local changes and entry markings

       <b>remote-status</b>
           Ask what an <b>update</b> would bring

</pre><h4><b>Property</b> <b>handling:</b></h4><pre>
       <b>prop-set</b>
           Set user-defined properties

       <b>prop-get</b>
           Ask value of user-defined properties

       <b>prop-list</b>
           Get a list of user-defined properties

</pre><h4><b>Additional</b> <b>commands</b> <b>used</b> <b>for</b> <b>recovery</b> <b>and</b> <b>debugging:</b></h4><pre>
       <b>export</b>
           Fetch some part of the repository

       <b>sync-repos</b>
           Drop local information about the entries, and fetch the current list from the repository.

       <b>Note:</b>
           Multi-url-operations are relatively new; there might be rough edges.

       The  <b>return</b> <b>code</b> is 0 for success, or 2 for an error. 1 is returned if the option <b>Checking</b> <b>for</b> <b>changes</b> <b>in</b>
       <b>a</b> <b>script</b> is used, and changes are found; see also <b>Filtering</b> <b>entries</b>.

</pre><h4><b>Universal</b> <b>options</b></h4><pre>
   <b>-V</b> <b>--</b> <b>show</b> <b>version</b>
        -V makes FSVS print the version and a copyright notice, and exit.

   <b>-d</b> <b>and</b> <b>-D</b> <b>--</b> <b>debugging</b>
        If FSVS was compiled using --enable-debug you can enable printing of debug messages (to STDOUT) with -d.
       Per default all messages are printed; if you're only interested in a subset, you  can  use  -D  <u>start-of-</u>
       <u>function-name</u>.

             fsvs -d -D waa_ status

        would  call  the <u>status</u> action, printing all debug messages of all WAA functions - waa__init, waa__open,
       etc.

        For more details on the other debugging options <b>debug_output</b> and <b>debug_buffer</b>  please  see  the  options
       list.

   <b>-N,</b> <b>-R</b> <b>--</b> <b>recursion</b>
        The  -N  and -R switches in effect just decrement/increment a counter; the behaviour is chosen depending
       on that. So a command line of -N -N -N -R -R is equivalent to -3 +2 = -1, this results in -N.

   <b>-q,</b> <b>-v</b> <b>--</b> <b>verbose/quiet</b>
        -v/-q set/clear verbosity flags, and so give more/less output.

        Please see <b>the</b> <b>verbose</b> <b>option</b> for more details.

   <b>-C</b> <b>--</b> <b>checksum</b>
        -C chooses to use more change detection checks; please see <b>the</b> <b>change_check</b> <b>option</b> for more details.

   <b>-f</b> <b>--</b> <b>filter</b> <b>entries</b>
        This parameter allows one to do a bit of filtering of entries, or, for some operations, modification  of
       the work done on given entries.

        It  requires  a  specification  at  the end, which can be any combination of any, text, new, deleted (or
       removed), meta, mtime, group, mode, changed or owner; default or def use the default value.

        By giving eg. the value text, with a <b>status</b> action only entries that are new or changed are shown;  with
       mtime,group only entries whose group or modification time has changed are printed.

       <b>Note:</b>
           Please see <b>Change</b> <b>detection</b> for some more information.

           If  an  entry  gets  replaced  with  an entry of a different type (eg. a directory gets replaced by a
           file), that counts as deleted <b>and</b> new.

       If you use -v, it's used as a any internally.

        If you use the string none, it resets the bitmask to <b>no</b> entries shown; then you can built a new mask. So
       owner,none,any,none,delete would show deleted entries. If the value  after  all  commandline  parsing  is
       none, it is reset to the default.

   <b>-W</b> <b>warning=action</b> <b>--</b> <b>set</b> <b>warnings</b>
        Here  you can define the behaviour for certain situations that should not normally happen, but which you
       might encounter.

        The general format here is <u>specification</u> = <u>action</u>, where <u>specification</u> is a string matching the start of
       at least one of the defined situations, and <u>action</u> is one of these:

       • <u>once</u> to print only a single warning,

       • <u>always</u> to print a warning message <b>every</b> time,

       • <u>stop</u> to abort the program,

       • <u>ignore</u> to simply ignore this situation, or

       • <u>count</u> to just count the number of occurrences.

        If <u>specification</u> matches more than one situation, all of them are set; eg. for <u>meta=ignore</u> all of  <u>meta-</u>
       <u>mtime</u>, <u>meta-user</u> etc. are ignored.

        If  at  least  a  single  warning  that  is <b>not</b> ignored is encountered during the program run, a list of
       warnings along with the number of messages it would have printed with the setting <u>always</u> is displayed, to
       inform the user of possible problems.

        The following situations can be handled with this: <u>meta-mtime</u>, <u>meta-user</u>, <u>meta-group</u>,  <u>meta-umask</u>  These
       warnings are issued if a meta-data property that was fetched from the repository couldn't be parsed. This
       can only happen if some other program or a user changes properties on entries.
        In this case you can use -Wmeta=always or -Wmeta=count, until the repository is clean again.

       <u>no-urllist</u> This warning is issued if a <b>info</b> action is executed, but no URLs have been defined yet.

       <u>charset-invalid</u>  If  the  function  <a href="../man3/nl_langinfo.3.html">nl_langinfo</a>(3)  couldn't  return  the  name  of the current character
       encoding, a default of UTF-8 is used. You might need that for  a  minimal  system  installation,  eg.  on
       recovery.

       <u>chmod-eperm</u>,  <u>chown-eperm</u> If you update a working copy as normal user, and get to update a file which has
       another owner but which you may modify, you'll get errors because neither the user, group, nor  mode  can
       be set.
        This way you can make the errors non-fatal.

       <u>chmod-other</u>, <u>chown-other</u> If you get another error than EPERM in the situation above, you might find these
       useful.

       <u>mixed-rev-wc</u>  If  you  specify  some  revision  number  on a <b>revert</b>, it will complain that mixed-revision
       working copies are not allowed.
        While you cannot enable mixed-revision working copies (I'm working on that) you  can  avoid  being  told
       every time.

       <u>propname-reserved</u>  It  is  normally  not  allowed  to set a property with the <b>prop-set</b> action with a name
       matching some reserved prefixes.

        <u>ignpat-wcbase</u> This warning is issued if an <b>absolute</b> <b>ignore</b>  pattern' does not  match  the  working  copy
       base directory. \n
        See \ref ignpat_shell_abs 'absolute shell patterns" for more details.

       <u>diff-status</u>  GNU  diff  has  defined that it returns an exit code 2 in case of an error; sadly it returns
       that also for binary files, so that a simply fsvs diff some-binary-file  text-file  would  abort  without
       printing the diff for the second file.
        Because  of  this FSVS currently ignores the exit status of diff per default, but this can be changed by
       setting this option to eg. <u>stop</u>.

        Also an environment variable FSVS_WARNINGS is used and parsed; it is simply a whitespace-separated  list
       of option specifications.

   <b>-u</b> <b>URLname[@revision[:revision]]</b> <b>--</b> <b>select</b> <b>URLs</b>
        Some commands can be reduced to a subset of defined URLs; the <b>update</b> command is a example.

        If  you  have  more  than a single URL in use for your working copy, update normally updates <b>all</b> entries
       from <b>all</b> URLs. By using this parameter you can tell FSVS to update only the specified URLs.

        The parameter can be used repeatedly; the value can have multiple URLs, separated by whitespace  or  one
       of ',;'.

          fsvs up -u base_install,boot@32 -u gcc

        This  would  get  HEAD  of  base_install  and  gcc, and set the target revision of the boot URL <b>for</b> <b>this</b>
       <b>command</b> at 32.

   <b>-o</b> <b>[name[=value]]</b> <b>--</b> <b>other</b> <b>options</b>
        This is used for setting some seldom used option, for which default can be set in a  configuration  file
       (to be implemented, currently only command-line).

        For a list of these please see <b>Further</b> <b>options</b> <b>for</b> <b>FSVS.</b>.

</pre><h4><b>Signals</b></h4><pre>
        If  you  have  a  running  FSVS,  and  you want to change its verbosity, you can send the process either
       SIGUSR1 (to make it more verbose) or SIGUSR2 (more quiet).

</pre><h4><b>add</b></h4><pre>
        fsvs add [-u URLNAME] PATH [PATH...]

        With this command you can explicitly define entries to be versioned, even if they have a matching ignore
       pattern. They will be sent to the repository on the next commit, just like other new  entries,  and  will
       therefore be reported as <u>New</u> .

        The  -u  option  can  be used if you're have more than one URL defined for this working copy and want to
       have the entries pinned to the this URL.

   <b>Example</b>
        Say, you're versioning your home directory, and gave an ignore pattern of .<a href="file:/.">/.</a>* to ignore all .*  entries
       in  your home-directory. Now you want .bashrc, .ssh/config, and your complete .kde3-tree saved, just like
       other data.

        So you tell fsvs to not ignore these entries:

           fsvs add .bashrc .ssh/config .kde3

        Now the entries below .kde3 would match your earlier .<a href="file:/.">/.</a>* pattern  (as  a  match  at  the  beginning  is
       sufficient), so you have to insert a negative ignore pattern (a <u>take</u> pattern):

           fsvs ignore prepend t./.kde3

        Now a fsvs st would show your entries as <u>New</u> , and the next commit will send them to the repository.

</pre><h4><b>unversion</b></h4><pre>
        fsvs unversion PATH [PATH...]

        This  command  flags  the given paths locally as removed. On the next commit they will be deleted in the
       repository, and the local information of them will be removed, but not the entries  themselves.  So  they
       will show up as <u>New</u> again, and you get another chance at ignoring them.

   <b>Example</b>
        Say,  you're  versioning  your  home  directory,  and  found  that  you no longer want .bash_history and
       .sh_history versioned. So you do

           fsvs unversion .bash_history .sh_history

        and these files will be reported as d (will be deleted, but only in the repository).

        Then you do a

           fsvs commit

        Now fsvs would report these files as New , as it does no longer know anything about them; but  that  can
       be cured by

           fsvs ignore '.<a href="file:/.">/.</a>*sh_history'

        Now these two files won't be shown as <u>New</u> , either.

        The  example  also shows why the given paths are not just entered as separate ignore patterns - they are
       just single cases of a (probably) much broader pattern.

       <b>Note:</b>
           If you didn't use some kind of escaping for the pattern, the shell would  expand  it  to  the  actual
           filenames, which is (normally) not what you want.

</pre><h4><b>_build_new_list</b></h4><pre>
        This  is  used  mainly  for  debugging.  It  traverses  the filesystem and builds a new entries file. In
       production it should not be used; as neither URLs nor the revision of the entries is  known,  information
       is lost by calling this function!

        Look at <b>sync-repos</b>.

</pre><h4><b>delay</b></h4><pre>
        This  command  delays execution until time has passed at least to the next second after writing the data
       files used by FSVS (<b>dir</b> and <b>urls</b>).

        This command is for use in scripts; where previously the <b>delay</b> option was used, this can be  substituted
       by the given command followed by the delay command.

        The advantage against the <b>delay</b> option is that read-only commands can be used in the meantime.

        An example:

          fsvs commit <a href="file:/etc/X11">/etc/X11</a> -m 'Backup of X11'
          ... read-only commands, like 'status'
          fsvs delay <a href="file:/etc/X11">/etc/X11</a>
          ... read-write commands, like 'commit'

        The optional path can point to any path in the WC.

        In  the testing framework it is used to save a bit of time; in normal operation, where FSVS commands are
       not so tightly packed, it is normally preferable to use the <b>delay</b> option.

</pre><h4><b>cat</b></h4><pre>
        fsvs cat [-r rev] path

        Fetches a file repository, and outputs it to STDOUT. If no revision is specified, it defaults  to  BASE,
       ie. the current local revision number of the entry.

</pre><h4><b>checkout</b></h4><pre>
        fsvs checkout [path] URL [URLs...]

        Sets one or more URLs for the current working directory (or the directory path), and does an <b>checkout</b> of
       these URLs.

        Example:

        fsvs checkout . <a href="http://svn/repos/installation/machine-1/trunk">http://svn/repos/installation/machine-1/trunk</a>

        The  distinction whether a directory is given or not is done based on the result of URL-parsing -- if it
       looks like an URL, it is used as an URL.
        Please mind that at most a single path is allowed; as soon as two non-URLs are found an error message is
       printed.

        If no directory is given, '.' is used; this differs from the usual subversion usage, but might be better
       suited for usage as a recovery tool (where versioning / is common). Opinions welcome.

        The given path must exist, and <b>should</b> be empty -- FSVS will abort on conflicts, ie. if files that should
       be created already exist.
        If there's a need to create that directory, please say so;  patches  for  some  parameter  like  -p  are
       welcome.

        For  a  format  definition  of  the  URLs  please see the chapter <b>Format</b> <b>of</b> <b>URLs</b> and the <b>urls</b> and <b>update</b>
       commands.

        Furthermore you might be interested in <b>Using</b> <b>an</b> <b>alternate</b> <b>root</b> <b>directory</b> and <b>Recovery</b> <b>for</b> <b>a</b>  <b>non-booting</b>
       <b>system</b>.

</pre><h4><b>commit</b></h4><pre>
        fsvs commit [-m 'message'|-F filename] [-v] [-C [-C]] [PATH [PATH ...]]

        Commits (parts of) the current state of the working copy into the repository.

   <b>Example</b>
        The working copy is <a href="file:/etc">/etc</a> , and it is set up and committed already.
        Then  <a href="file:/etc/hosts">/etc/hosts</a>  and /etc/inittab got modified. Since these are non-related changes, you'd like them to
       be in separate commits.

        So you simply run these commands:

        fsvs commit -m 'Added some host' <a href="file:/etc/hosts">/etc/hosts</a>
        fsvs commit -m 'Tweaked default runlevel' /etc/inittab

        If the current directory is <a href="file:/etc">/etc</a> you could even drop the <a href="file:/etc/">/etc/</a> in front, and use just the filenames.

        Please see <b>status</b> for explanations on -v and -C .
        For advanced backup usage see also <b>the</b>  commit-pipe property".

</pre><h4><b>cp</b></h4><pre>
        fsvs cp [-r rev] SRC DEST
        fsvs cp dump
        fsvs cp load

        The copy command marks DEST as a copy of SRC at revision rev, so that on the next  commit  of  DEST  the
       corresponding source path is sent as copy source.

        The default value for rev is BASE, ie. the revision the SRC (locally) is at.

        Please  note  that  this command works <b>always</b> on a directory <b>structure</b> - if you say to copy a directory,
       the <b>whole</b> structure is marked as copy. That means that if some entries below the copy are  missing,  they
       are reported as removed from the copy on the next commit.
        (Of  course  it is possible to mark files as copied, too; non-recursive copies are not possible, but can
       be emulated by having parts of the destination tree removed.)

       <b>Note:</b>
           TODO: There will be differences in the exact usage - copy will try to run  the  cp  command,  whereas
           copied will just remember the relation.

       If  this command are used without parameters, the currently defined relations are printed; please keep in
       mind that the <b>key</b> is the destination name, ie. the 2nd line of each pair!

        The input format for load is newline-separated - first a SRC line, followed by a DEST line, then an line
       with just a dot ('.') as delimiter. If you've got filenames with newlines or  other  special  characters,
       you have to give the paths as arguments.

        Internally  the  paths  are stored relative to the working copy base directory, and they're printed that
       way, too.

        Later definitions are <b>appended</b> to the internal database; to undo mistakes, use the <b>uncopy</b> action.

       <b>Note:</b>
           <b>Important:</b> User-defined properties like <b>fsvs:commit-pipe</b> are <b>not</b> copied to the destinations,  because
           of  space/time  issues  (traversing  through  entire  subtrees,  copying a lot of property-files) and
           because it's not sure that this is really wanted. <b>TODO:</b> option for copying properties?

           As subversion currently treats a rename as copy+delete, the <b>mv</b> command is an alias to <b>cp</b>.

       If you have a need to give the filenames dump or load as first parameter  for  copyfrom  relations,  give
       some path, too, as in './dump'.

       <b>Note:</b>
           The source is internally stored as URL with revision number, so that operations like these

              $ fsvs cp a b
              $ rm a/1
              $ fsvs ci a
              $ fsvs ci b

            work  -  FSVS sends the old (too recent!) revision number as source, and so the local filelist stays
           consistent with the repository.
            But it is not implemented (yet) to give an URL as copyfrom source directly - we'd have  to  fetch  a
           list of entries (and possibly the data!) from the repository.

</pre><h4><b>copyfrom-detect</b></h4><pre>
        fsvs copyfrom-detect [paths...]

        This  command  tells FSVS to look through the new entries, and see whether it can find some that seem to
       be copied from others already known.
        It will output a list with source and destination path and why it could match.

        This is  just  for  information  purposes  and  doesn't  change  any  FSVS  state,  (TODO:  unless  some
       option/parameter is set).

        The  list  format  is <b>on</b> <b>purpose</b> incompatible with the load syntax, as the best match normally has to be
       taken manually.

         If <b>verbose</b> is used, an additional value giving the percentage of matching  blocks,  and  the  count  of
       possibly copied entries is printed.

        Example:

          $ fsvs copyfrom-list -v
          newfile1
            md5:oldfileA
          newfile2
            md5:oldfileB
            md5:oldfileC
            md5:oldfileD
          newfile3
            inode:oldfileI
            manber=82.6:oldfileF
            manber=74.2:oldfileG
            manber=53.3:oldfileH
            ...
          3 copyfrom relations found.

        The abbreviations are: <u>md5</u> The <b>MD5</b> of the new file is identical to that of one or more already committed
       files; there is no percentage.

       <u>inode</u>  The  <b>device/inode</b> number is identical to the given known entry; this could mean that the old entry
       has been renamed or hardlinked. <b>Note:</b> Not all filesystems have persistent inode numbers (eg.  NFS)  -  so
       depending on your filesystems this might not be a good indicator!

       <u>name</u> The entry has the same name as another entry.

       <u>manber</u>  Analysing files of similar size shows some percentage of (variable-sized) <b>common</b> <b>blocks</b> (ignoring
       the order of the blocks).

       <u>dirlist</u> The new directory has similar files to the old directory.
        The percentage is (number_of_common_entries)/(files_in_dir1 + files_in_dir2 - number_of_common_entries).

       <b>Note:</b>
           <b>manber</b> matching is not implemented yet.

           If too many possible matches for an entry are found, not all are printed; only an  indicator  ...  is
           shown at the end.

</pre><h4><b>uncp</b></h4><pre>
        fsvs uncopy DEST [DEST ...]

        The  uncopy command removes a copyfrom mark from the destination entry. This will make the entry unknown
       again, and reported as New on the next invocations.

        Only the base of a copy can be un-copied; if a directory structure was copied, and the  given  entry  is
       just implicitly copied, this command will return an error.

        This  is  not  folded in <b>revert</b>, because it's not clear whether revert on copied, changed entries should
       restore the original copyfrom data or remove the copy attribute; by using  another  command  this  is  no
       longer ambiguous.

        Example:

          $ fsvs copy SourceFile DestFile
          # Whoops, was wrong!
          $ fsvs uncopy DestFile

</pre><h4><b>diff</b></h4><pre>
        fsvs diff [-v] [-r rev[:rev2]] [-R] PATH [PATH...]

        This command gives you diffs between local and repository files.

        With -v the meta-data is additionally printed, and changes shown.

        If  you  don't  give  the revision arguments, you get a diff of the base revision in the repository (the
       last commit) against your current local file. With one revision, you diff this repository version against
       your local file. With  both  revisions  given,  the  difference  between  these  repository  versions  is
       calculated.

        You'll need the diff program, as the files are simply passed as parameters to it.

        The  default  is  to  do non-recursive diffs; so fsvs diff . will output the changes in all files <b>in</b> <b>the</b>
       <b>current</b> <b>directory</b> and below.

        The output for special files is the diff of the internal subversion storage, which includes the type  of
       the special file, but no newline at the end of the line (which diff complains about).

        For entries marked as copy the diff against the (clean) source entry is printed.

        Please see also <b>Options</b> <b>relating</b> <b>to</b> <b>the</b> <b>'diff'</b> <b>action</b> and <b>Using</b> <b>colordiff</b>.

</pre><h4><b>export</b></h4><pre>
        fsvs export REPOS_URL [-r rev]

        If you want to export a directory from your repository <b>without</b> storing any FSVS-related data you can use
       this command.

        This  restores  all  meta-data - owner, group, access mask and modification time; its primary use is for
       data recovery.

        The data gets written (in the correct directory structure)  below  the  current  working  directory;  if
       entries already exist, the export will stop, so this should be an empty directory.

</pre><h4><b>help</b></h4><pre>
        help [command]

        This  command shows general or specific <b>help</b> (for the given command). A similar function is available by
       using -h or -? after a command.

</pre><h4><b>groups</b></h4><pre>
        fsvs groups dump|load
        fsvs groups [prepend|append|at=n] group-definition [group-def ...]
        fsvs ignore [prepend|append|at=n] pattern [pattern ...]
        fsvs groups test [-v|-q] [pattern ...]

        This command adds patterns to the end of the pattern list, or, with prepend, puts them at the  beginning
       of the list. With at=x the patterns are inserted at the position x , counting from 0.

        The  difference  between groups and ignore is that groups <b>requires</b> a group name, whereas the latter just
       assumes the default group ignore.

        For the specification please see the related <b>documentation</b> .

        fsvs dump prints the patterns to STDOUT . If there are special characters like CR or LF embedded in  the
       pattern <b>without</b> <b>encoding</b> (like \r or \n), the output will be garbled.

        The patterns may include * and ? as wildcards in one directory level, or ** for arbitrary strings.

        These  patterns  are  only matched against new (not yet known) files; entries that are already versioned
       are not invalidated.
        If the given path matches a new directory, entries below aren't found, either; but if this directory  or
       entries  below  are  already  versioned,  the  pattern  doesn't  work,  as the match is restricted to the
       directory.

        So:

            fsvs ignore .<a href="file:/tmp">/tmp</a>

        ignores the directory tmp; but if it has already been committed,  existing  entries  would  have  to  be
       unmarked with <b>fsvs</b> <b>unversion</b>. Normally it's better to use

            fsvs ignore .<a href="file:/tmp/">/tmp/</a>**

        as  that  takes  the directory itself (which might be needed after restore as a mount point anyway), but
       ignore <b>all</b> entries below.
        Currently this has the drawback that mtime changes will be reported and committed; this is not the  case
       if the whole directory is ignored.

        Examples:

            fsvs group group:unreadable,mode:4:0
            fsvs group 'group:secrets,<a href="file:/etc/">/etc/</a>*shadow'

            fsvs ignore <a href="file:/proc">/proc</a>
            fsvs ignore <a href="file:/dev/pts">/dev/pts</a>
            fsvs ignore '.<a href="file:/var/log/">/var/log/</a>*-*'
            fsvs ignore './**~'
            fsvs ignore './**/*.bak'
            fsvs ignore prepend 'take,./**.txt'
            fsvs ignore append 'take,./**.svg'
            fsvs ignore at=1 './**.tmp'

            fsvs group dump
            fsvs group dump -v

            echo './**.doc' | fsvs ignore load
            # Replaces the whole list

       <b>Note:</b>
           Please take care that your wildcard patterns are not expanded by the shell!

   <b>Testing</b> <b>patterns</b>
        To  see  more  easily  what  different  patterns  do  you  can  use  the  test subcommand. The following
       combinations are available:

       • fsvs groups test <u>pattern</u>  <u>Tests</u> <b>only</b> <u>the</u> <u>given</u> <u>pattern</u> <u>against</u> <u>all</u> <u>new</u> <u>entries</u> <u>in</u>  <u>your</u>  <u>working</u>  <u>copy,</u>
         <u>and</u> <u>prints</u> <u>the</u> <u>matching</u> <u>paths.</u> <u>The</u> <u>pattern</u> <u>is</u> <u>not</u> <u>stored</u> <u>in</u> <u>the</u> <u>pattern</u> <u>list.</u>
       • fsvs groups test
          Uses the already defined patterns on the new entries, and prints the group name, a tab, and the path.
          With -v you can see the matching pattern in the middle column, too.

        By  using -q you can avoid getting the whole list; this makes sense if you use the <b>group_stats</b> option at
       the same time.

</pre><h4><b>rign</b></h4><pre>
        fsvs rel-ignore [prepend|append|at=n] path-spec [path-spec ...]
        fsvs ri [prepend|append|at=n] path-spec [path-spec ...]

        If you keep the same repository data at more than one working copy on  the  same  machine,  it  will  be
       stored  in  different  paths  -  and  that makes absolute ignore patterns infeasible. But relative ignore
       patterns are anchored at the beginning of the WC root - which is a bit tiring to type if you're  deep  in
       your WC hierarchy and want to ignore some files.
        To  make  that  easier  you  can use the rel-ignore (abbreviated as ri) command; this converts all given
       path-specifications (which may include wildcards as per the shell pattern  specification  above)  to  WC-
       relative values before storing them.
        Example for <a href="file:/etc">/etc</a> as working copy root:
               fsvs rel-ignore '/etc/X11/xorg.conf.*'

               cd <a href="file:/etc/X11">/etc/X11</a>
               fsvs rel-ignore 'xorg.conf.*'

        Both commands would store the pattern './X11/xorg.conf.*'.
       <b>Note:</b>
           This works only for <b>shell</b> <b>patterns</b>.
       For  more  details  about  ignoring  files  please see the <b>ignore</b> command and <b>Specification</b> <b>of</b> <b>groups</b> <b>and</b>
       <b>patterns</b>.

</pre><h4><b>info</b></h4><pre>
        fsvs info [-R [-R]] [PATH...]

        Use this command to show information regarding one or more entries in your working copy.
        You can use -v to obtain slightly more information.
        This may sometimes be helpful for locating bugs, or to obtain the URL and revision  a  working  copy  is
       currently at.
        Example:
            $ fsvs info
            URL: file:
            ....       200  .
                    Type:           directory
                    Status:         0x0
                    Flags:          0x100000
                    Dev:            0
                    Inode:          24521
                    Mode:           040755
                    UID/GID:        1000/1000
                    MTime:          Thu Aug 17 16:34:24 2006
                    CTime:          Thu Aug 17 16:34:24 2006
                    Revision:       4
                    Size:           200

        The  default  is  to print information about the given entry only. With a single -R you'll get this data
       about <b>all</b> entries of a given directory; with another -R you'll get the whole (sub-)tree.

</pre><h4><b>log</b></h4><pre>
        fsvs log [-v] [-r rev1[:rev2]] [-u name] [path]

        This command views the revision log information associated with the given <u>path</u> at its topmost  URL,  or,
       if none is given, the highest priority URL.
        The optional <u>rev1</u> and <u>rev2</u> can be used to restrict the revisions that are shown; if no values are given,
       the  logs  are given starting from HEAD downwards, and then a limit on the number of revisions is applied
       (but see the <b>limit</b> option).
        If you use the <b>-v</b> -option, you get the files changed in each revision printed, too.
        There is an option controlling the output format; see the <b>log_output</b> <b>option</b>.
        Optionally the name of an URL can be given after -u; then the log of this URL, instead  of  the  topmost
       one, is shown.
        TODOs:
       • --stop-on-copy
       • Show revision for <b>all</b> URLs associated with a working copy? In which order?

</pre><h4><b>prop-get</b></h4><pre>
        fsvs prop-get PROPERTY-NAME PATH...

        Prints the data of the given property to STDOUT.
       <b>Note:</b>
           Be  careful!  This command will dump the property <b>as</b> <b>it</b> <b>is</b>, ie. with any special characters! If there
           are escape sequences or binary data in the property, your terminal might get messed up!
            If you want a safe way to look at the properties, use prop-list with the -v parameter.

</pre><h4><b>prop-set</b></h4><pre>
        fsvs prop-set [-u URLNAME] PROPERTY-NAME VALUE PATH...

        This command sets an arbitrary property value for the given path(s).
       <b>Note:</b>
           Some property prefixes are reserved;  currently  everything  starting  with  svn:  throws  a  (fatal)
           warning, and fsvs: is already used, too. See <b>Special</b> <b>property</b> <b>names</b>.
       If  you're  using  a  multi-URL setup, and the entry you'd like to work on should be pinned to a specific
       URL, you can use the -u parameter; this is like the <b>add</b> command, see there for more details.

</pre><h4><b>prop-del</b></h4><pre>
        fsvs prop-del PROPERTY-NAME PATH...

        This command removes a property for the given path(s).
        See also <b>prop-set</b>.

</pre><h4><b>prop-list</b></h4><pre>
        fsvs prop-list [-v] PATH...

        Lists the names of all properties for the given entry.
        With -v, the value is printed as well; special  characters  will  be  translated,  as  arbitrary  binary
       sequences could interfere with your terminal settings.
        If you need raw output, post a patch for --raw, or write a loop with <b>prop-get</b>.

</pre><h4><b>remote-status</b></h4><pre>
        fsvs remote-status PATH [-r rev]

        This command looks into the repository and tells you which files would get changed on an <b>update</b> - it's a
       dry-run for <b>update</b> .
        Per default it compares to HEAD, but you can choose another revision with the -r parameter.
        Please see the <b>update</b> documentation for details regarding multi-URL usage.

</pre><h4><b>resolve</b></h4><pre>
        fsvs resolve PATH [PATH...]

        When FSVS tries to update local files which have been changed, a conflict might occur. (For various ways
       of handling these please see the <b>conflict</b> option.)
        This command lets you mark such conflicts as resolved.

</pre><h4><b>revert</b></h4><pre>
        fsvs revert [-rRev] [-R] PATH [PATH...]

        This command undoes local modifications:
       • An entry that is marked to be unversioned gets this flag removed.
       • For  a  already  versioned  entry  (existing  in  the  repository) the local entry is replaced with its
         repository version, and its status and flags are cleared.
       • An entry that is a <b>modified</b> copy destination gets reverted to the copy source data.
       • Manually added entries are changed back to <u>'N'</u>ew.

        Please note that implicitly copied entries, ie. entries that are marked as copied  because  some  parent
       directory  is  the  base  of  a  copy,  <b>can</b> <b>not</b> be un-copied; they can only be reverted to their original
       (copied-from) data, or removed.
        If you want to undo a copy operation, please see the <b>uncopy</b> command.
        See also <b>HOWTO:</b> <b>Understand</b> <b>the</b> <b>entries'</b> <b>statii</b>.
        If a directory is given on the command line <b>all</b> <b>versioned</b> <b>entries</b> <b>in</b> <b>this</b> <b>directory</b> are reverted to  the
       old state; this behaviour can be modified with <b>-R/-N</b>, or see below.
        The  reverted  entries  are  printed,  along with the status they had <b>before</b> the revert (because the new
       status is per definition <u>unchanged</u>).
        If a revision is given, the entries' data is taken from this revision; furthermore, the  <b>new</b>  status  of
       that entry is shown.
       <b>Note:</b>
           Please  note  that  mixed  revision  working  copies are not (yet) possible; the <u>BASE</u> revision is not
           changed, and a simple revert without a revision arguments gives you that.
            By giving a revision parameter you can just choose to get the text from a different revision.

   <b>Difference</b> <b>to</b> <b>update</b>
        If something doesn't work as it should in  the  installation  you  can  revert  entries  until  you  are
       satisfied, and directly <b>commit</b> the new state.
        In contrast, if you <b>update</b> to an older version, you
       • cannot choose single entries (no mixed revision working copies yet),
       • and  you  cannot  commit  the  old  version  with changes, as the 'skipped' (later) changes will create
         conflicts in the repository.

   <b>Currently</b> <b>only</b> <b>known</b> <b>entries</b> <b>are</b> <b>handled.</b>
        If you need a switch (like --delete in <a href="../man1/rsync.1.html">rsync</a>(1) ) to remove unknown (new, not yet versioned) entries, to
       get the directory in the exact state it is in the repository, please tell the dev@ mailing list.
   <b>Removed</b> <b>directory</b> <b>structures</b>
        If a path is specified whose parent is missing, fsvs complains.
        We plan to provide a switch (probably -p), which would create (a sparse) tree up to this entry.
   <b>Recursive</b> <b>behaviour</b>
        When the user specifies a non-directory entry (file, device, symlink), this entry is reverted to the old
       state.
        If the user specifies a directory entry, these definitions should apply: command  line  switchresult  -N
       this  directory  only  (meta-data),  none  this  directory, and direct children of the directory, -R this
       directory, and the complete tree below.
   <b>Working</b> <b>with</b> <b>copied</b> <b>entries</b>
        If an entry is marked as copied from another entry  (and  not  committed!),  a  revert  will  fetch  the
       original copyfrom source. To undo the copy setting use the <b>uncopy</b> command.

</pre><h4><b>status</b></h4><pre>
        fsvs status [-C [-C]] [-v] [-f filter] [PATHs...]

        This command shows the entries that have been changed locally since the last commit.
        The most important output formats are:
       • A  status  columns  of four (or, with -v , six) characters. There are either flags or a '.' printed, so
         that it's easily parsed by scripts -- the number of columns is only changed by <b>-q,</b> <b>-v</b> <b>--</b> <b>verbose/quiet</b>.
       • The size of the entry, in bytes, or 'dir' for a directory, or 'dev' for a device.
       • The path and name of the entry, formatted by the <b>path</b> option.

        Normally only changed entries are printed; with -v all are printed, but see the <b>filter</b> option  for  more
       details.
        The status column can show the following flags:
       •
          'D' and 'N' are used for <u>deleted</u> and <u>new</u> entries.
       •
          'd'  and  'n'  are  used  for  entries  which  are  to be unversioned or added on the next commit; the
         characters were chosen as <u>little</u> <u>delete</u> (only in the repository, not removed locally)  and  <u>little</u>  <u>new</u>
         (although <b>ignored</b>). See <b>add</b> and <b>unversion</b>.
          If  such  an  entry does not exist, it is marked with an '!' in the last column -- because it has been
         manually marked, and so the removal is unexpected.
       • A changed type (character device to symlink, file to directory etc.) is given as 'R' (replaced), ie. as
         removed and newly added.
       •
          If the entry has been modified, the change is shown as 'C'.
          If the modification or status change timestamps (mtime, ctime) are changed, but the size is still  the
         same, the entry is marked as possibly changed (a question mark '?' in the last column) - but see <b>change</b>
         <b>detection</b> for details.
       • A 'x' signifies a conflict.
       •
          The  meta-data  flag  'm'  shows  meta-data changes like properties, modification timestamp and/or the
         rights (owner, group, mode); depending on the <b>-v/-q</b> command line parameters, it may be split  into  'P'
         (properties), 't' (time) and 'p' (permissions).
          If  'P'  is shown for the non-verbose case, it means <b>only</b> property changes, ie. the entries filesystem
         meta-data is unchanged.
       • A '+' is printed for files with a copy-from history; to see the URL of the  copyfrom  source,  see  the
         <b>verbose</b> option.

        Here's a table with the characters and their positions:
        *   Without -v    With -v
        *     ....         ......
        *     NmC?         NtpPC?
        *     DPx!         D   x!
        *     R  +         R    +
        *     d            d
        *     n            n
        *

        Furthermore  please  take a look at the <b>stat_color</b> option, and for more information about displayed data
       the <b>verbose</b> option.

</pre><h4><b>sync-repos</b></h4><pre>
        fsvs sync-repos [-r rev] [working copy base]

        This command loads the file list afresh from the repository.
        A following commit will send all differences and make the repository data identical to the local.
        This is normally not needed; the only use cases are
       • debugging and
       • recovering from data loss in the <b>$FSVS_WAA</b> area.

        It might be of use if you want to backup two similar machines. Then you could commit one machine into  a
       subdirectory  of  your repository, make a copy of that directory for another machine, and sync this other
       directory on the other machine.
        A commit then will transfer only _changed_ files; so if the two machines share 2GB of binaries  (<a href="file:/usr">/usr</a>  ,
       <a href="file:/bin">/bin</a>  ,  <a href="file:/lib">/lib</a>  ,  ...)  then  these  2GB are still shared in the repository, although over time they will
       deviate (as both committing machines know nothing of the other path with identical files).
        This kind of backup could be substituted by two or more levels of repository paths, which  get  <u>overlaid</u>
       in  a defined priority. So the base directory, which all machines derive from, will be committed from one
       machine, and it's no longer necessary for all machines to send identical files into the repository.
        The revision argument should only ever be used for debugging; if you fetch a filelist  for  a  revision,
       and then commit against later revisions, problems are bound to occur.
       <b>Note:</b>
           There's  issue  2286  in  subversion  which  describes  sharing  identical files in the repository in
           unrelated paths. By using this relaxes the storage needs; but the network transfers  would  still  be
           much larger than with the overlaid paths.

</pre><h4><b>update</b></h4><pre>
        fsvs update [-r rev] [working copy base]
        fsvs update [-u url@rev ...] [working copy base]

        This  command  does an update on the current working copy; per default for all defined URLs, but you can
       restrict that via <b>-u</b>.
        It first reads all filelist changes from the repositories, overlays them  (so  that  only  the  highest-
       priority entries are used), and then fetches all necessary changes.
   <b>Updating</b> <b>to</b> <b>zero</b>
        If you start an update with a target revision of zero, the entries belonging to that URL will be removed
       from your working copy, and the URL deleted from your URL list.
        This is a convenient way to replace an URL with another.

       <b>Note:</b>
           As  FSVS has no full mixed revision support yet, it doesn't know whether under the removed entry is a
           lower-priority one with the same path, which should get visible now.
            Directories get changed to the highest priority  URL  that  has  an  entry  below  (which  might  be
           hidden!).
       Because  of  this  you're advised to either use that only for completely distinct working copies, or do a
       <b>sync-repos</b> (and possibly one or more <b>revert</b> calls) after the update.

</pre><h4><b>urls</b></h4><pre>
        fsvs urls URL [URLs...]
        fsvs urls dump
        fsvs urls load

        Initializes a working copy administrative area and connects the current working directory to  REPOS_URL.
       All commits and updates will be done to this directory and against the given URL.
        Example:
        fsvs urls <a href="http://svn/repos/installation/machine-1/trunk">http://svn/repos/installation/machine-1/trunk</a>

        For a format definition of the URLs please see the chapter <b>Format</b> <b>of</b> <b>URLs</b>.
       <b>Note:</b>
           If  there  are  already  URLs  defined,  and you use that command later again, please note that as of
           1.0.18 <b>the</b> <b>older</b> <b>URLs</b> <b>are</b> <b>not</b> <b>overwritten</b> as before, but that the new URLs are <b>appended</b> to the  given
           list! If you want to start afresh, use something like
            true | fsvs urls load

   <b>Loading</b> <b>URLs</b>
        You can load a list of URLs from STDIN; use the load subcommand for that.
        Example:
        ( echo 'N:local,prio:10,<a href="http://svn/repos/install/machine-1/trunk">http://svn/repos/install/machine-1/trunk</a>' ;
            echo 'P:50,name:common,<a href="http://svn/repos/install/common/trunk">http://svn/repos/install/common/trunk</a>' ) |
          fsvs urls load

        Empty lines are ignored.
   <b>Dumping</b> <b>the</b> <b>defined</b> <b>URLs</b>
        To see which URLs are in use for the current WC, you can use dump.
        As  an optional parameter you can give a format statement: p priority n name r current revision t target
       revision R readonly-flag u URL I internal number for this URL
       <b>Note:</b>
           That's not a real printf()-format; only these and a few \ sequences are recognized.
       Example:
        fsvs urls dump '  %u %n:%p\n'
          <a href="http://svn/repos/installation/machine-1/trunk">http://svn/repos/installation/machine-1/trunk</a> local:10
          <a href="http://svn/repos/installation/common/trunk">http://svn/repos/installation/common/trunk</a> common:50

        The default format is 'name:%n,prio:%p,target:%t,ro:%r,%u\\n'; for a more readable version you  can  use
       <b>-v</b>.
   <b>Loading</b> <b>URLs</b>
        You can change the various parameters of the defined URLs like this:
        # Define an URL
        fsvs urls name:url1,target:77,readonly:1,<a href="http://anything/">http://anything/</a>...
        # Change values
        fsvs urls name:url1,target:HEAD
        fsvs urls readonly:0,<a href="http://anything/">http://anything/</a>...
        fsvs urls name:url1,prio:88,target:32

       <b>Note:</b>
           FSVS  as yet doesn't store the whole tree structures of all URLs. So if you change the priority of an
           URL, and re-mix the directory trees that way, you'll need a <b>sync-repos</b> and some <b>revert</b> commands.  I'd
           suggest to avoid this, until FSVS does handle that case better.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for fsvs from the source code.

Version trunk:2424                                 11 Mar 2010                    <u>FSVS</u> <u>-</u> <u>fast</u> <u>versioning</u> <u><a href="../man1/tool.1.html">tool</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>