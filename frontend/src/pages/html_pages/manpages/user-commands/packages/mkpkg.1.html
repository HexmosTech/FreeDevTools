<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mkpkg - make or update an IRAF package or library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/iraf-dev">iraf-dev_2.18.1~rc1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mkpkg - make or update an IRAF package or library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>mkpkg</b> [<u>options</u>] [ <u>module</u> <u>...</u>  ] [ <u>name=value</u> <u>...</u>  ]

</pre><h4><b>ARGUMENTS</b></h4><pre>
       <b>-d[ddd]</b>
              Debug  mode.   Print  detailed  messages describing what <u>mkpkg</u> is doing.  There are four levels of
              debug messages, selected by repeating the "d" character in the switch, e.g., "-d"  is  level  one,
              "-dd"  is  level  two, and so on.  The debug messages get progressively more detailed as the debug
              level increases.  Debug mode automatically enables the verbose mode messages.

       <b>-f</b> <u>file</u>
              Set the name of the file to be interpreted (default: "mkpkg").  The special value  "stdin"  (lower
              case)  allows  commands  to  be entered interactively from the standard input, e.g., for debugging
              <b>mkpkg</b>.

       <b>-i</b>     Ignore errors. Execution continues even if an error occurs.

       <b>-n</b>     No execute.  Go through the motions, but do not touch any files.  No  execute  mode  automatically
              enables  verbose  mode  (flag  "-v").  This switch should be used to verify new mkpkg files before
              execution.

       <b>-p</b> <u>pkgname</u>
              Load the package environment for the named external package, e.g., "mkpkg -p noao update".  If the
              same package is always specified the environment variable or logical name PKGENV may be defined at
              the host level to accomplish the same thing.  The  package  name  <u>must</u>  be  specified  when  doing
              software development in an external or layered package.

       <b>-v</b>     Verbose  mode.   A  message is printed whenever a file is touched.  Recommended when running large
              mkpkg jobs in batch mode.

       <u>module</u> The names of the module or modules (named entries in the "mkpkg" file)  to  be  executed.   If  no
              module  is  named  the  first  module  encountered  is executed, unless a <b>mkpkg</b> macro preprocessor
              directive at the beginning of the file specifies a different default action.

       <b>name=</b><u>value</u> <b>[name=</b><u>value</u> <b>...]</b>
              Enter the named symbol/value pair into the symbol table of  the  <b>mkpkg</b>  macro  preprocessor.   The
              symbols  <u>XFLAGS</u>  (for  the  XC  compiler)  and  <u>LFLAGS</u>  (for the linker) are predefined but may be
              redefined on the command line.  Case is ignored in symbol names for portability reasons.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>mkpkg</b> utility is used to make or update IRAF packages or libraries.  <b>mkpkg</b> is used to  bootstrap  the
       IRAF  system  hence is implemented as a foreign task, callable either from within the IRAF environment or
       from the host system.  Usage is identical in either case (except that the details of  when  a  particular
       argument  may  need  to  be  quoted  will vary depending on the command language used).  <b>mkpkg</b> is upwards
       compatible with the old <b>mklib</b> utility.

</pre><h4><b>1.</b> <b>Introduction</b></h4><pre>
       <b>Mkpkg</b> provides two major facilities: a library update capability and a  macro  preprocessor.   The  macro
       preprocessor  provides  symbol definition and replacement, conditional execution, and a number of builtin
       commands.  The usefulness of these facilities is enhanced by  the  ability  of  <b>mkpkg</b>  to  update  entire
       directory  trees,  or  to  enter  the  hierarchy  of <b>mkpkg</b> descriptors at any level.  For example, typing
       "mkpkg" in the root directory of IRAF will make or update the entire system, whereas  in  the  "iraf$sys"
       directory  <b>mkpkg</b>  will  update  only the system libraries, and in the "iraf$sys/fio" directory <b>mkpkg</b> will
       update only the FIO portion of the system library "libsys.a".

       The <b>mkpkg</b> utility is quite simple to use to maintain small packages or libraries, despite the  complexity
       of  the  discussion  which follows.  The reader is encouraged to study several examples of working mkpkg-
       files before reading further; examples will be found throughout the IRAF system.   The  mkpkg  files  for
       applications  packages  tend  to be very similar to one another, and it is quite possible to successfully
       copy and modify the mkpkg-file from another package without  studying  the  reference  information  given
       here.

</pre><h4><b>2.</b> <b>Lexical</b> <b>Conventions</b></h4><pre>
       The  lexical  conventions employed in <b>mkpkg</b> are those used throughout IRAF.  Comments may occur anywhere,
       begin with the character #, and extend to the end of the current line.  Blank lines are ignored virtually
       everywhere.  Newline may be escaped with backslash to continue on the next line.  All filenames are  IRAF
       virtual filenames with the following extensions.

               .a          object library
               .c          C source
               .e          executable (e.g., "x_package.e")
               .f          Fortran source
               .gc         generic C source
               .gx         generic SPP source
               .h          C or SPP header file
               .inc        include file
               .l          Lex source
               .o          object file
               .r          Ratfor source
               .s          assembler source
               .y          Yacc source

       Since  <b>mkpkg</b> is an IRAF utility it recognizes the major IRAF logical directories; these are summarized in
       the list below.  The IRAF (or UNIX) pathname convention is  used  to  specify  pathnames  rooted  in  the
       current directory or a logical directory.

               bin$        installed executables         iraf$bin/
               dev$        device tables                 iraf$dev/
               hlib$       machdep header files          host$hlib/
               host$       host system interface         [MACHDEP]
               iraf$       the root directory of IRAF    [MACHDEP]
               lib$        system library                iraf$lib/
               math$       math sources                  iraf$math/
               pkg$        applications packages         iraf$pkg/
               sys$        the VOS, system libraries     iraf$sys/
               tmp$        where temporary files go      [MACHDEP]

       All  other  directories should be referenced by giving the path from either the current directory or from
       one of the system logical directories shown above.  For example, "pkg$system/" is the root  directory  of
       the SYSTEM package, and ".." is the directory one level up from the current directory.

</pre><h4><b>3.</b> <b>Maintaining</b> <b>Libraries</b> <b>with</b> <b>MKPKG</b></h4><pre>
       Libraries are described by a <b>member</b> <b>list</b> module in the "mkpkg" file.  The syntax of a library member list
       module  is  shown below.  Note that the <b>mkpkg</b> module name for a library member list module is the same as
       the name of the actual library, hence must end with the extension ".a".

               libname.a:
                   member1         dep1 dep2 ... depN
                   member2         dep1 dep2 ... depN
                     ...
                   memberN         dep1 dep2 ... depN
                   ;

       Here, "libname.a" is the IRAF virtual filename of the library (regardless of what  directory  it  resides
       in),  "memberN"  is  the  name  of  a  source  file which may contain any number of actual library object
       modules, and "depN" is the name of a file upon which the named member  depends.   If  any  of  the  named
       dependency  files  is  newer  than  the corresponding member source file, or if the member source file is
       newer than the compiled library object module, the source file is recompiled and replaced in the library.
       Both source files and dependency files may reside in remote directories.  The names of  dependency  files
       in system libraries should be enclosed in &lt;&gt; delimiters, e.g., "&lt;fset.h&gt;".  Each member must be described
       on a separate line.

       If  the  library being updated does not reside in the current directory (directory from which the "mkpkg"
       command was entered) then the library must be "checked out" of the remote  directory  before  it  can  be
       updated,  and  checked  back  in  when  updating  is  complete.   These operations are performed by macro
       preprocessor directives, e.g.:

               $checkout libsys.a lib$
               $update   libsys.a
               $checkin  libsys.a lib$
               $exit

               libsys.a:
                   @symtab      # update libsys.a in ./symtab
                   brktime.x    &lt;time.h&gt;
                   environ.x    environ.com environ.h &lt;ctype.h&gt;
                                &lt;fset.h&gt; &lt;knet.h&gt;
                   main.x       &lt;clset.h&gt; &lt;config.h&gt; &lt;ctype.h&gt;
                                &lt;error.h&gt; &lt;fset.h&gt; &lt;knet.h&gt;
                                &lt;printf.h&gt; &lt;xwhen.h&gt;
                   onentry.x    &lt;clset.h&gt; &lt;fset.h&gt; &lt;knet.h&gt;
                   spline.x     &lt;math.h&gt; &lt;math/interp.h&gt;
                   ;

       Note that the checkout operation is required only in the directory from which  the  "mkpkg"  command  was
       entered,  since  the library has already been checked out when the mkpkg-file in a subdirectory is called
       to update its portion of the library (as in the "@symtab" in the example above).  The  checkout  commands
       should  however  be  included  in  each  mkpkg-file in a hierarchy in such a way that the library will be
       automatically checked out and back in if <b>mkpkg</b> is run from that directory.   The  checkout  commands  are
       ignored  if the mkpkg-file is entered when updating the library from a higher level, because in that case
       <b>mkpkg</b> will search for the named entry for the library being updated, ignoring the remainder of the mkpkg-
       file.

       Sometimes it is necessary or desirable to break the library member list up into separate  modules  within
       the  same  mkpkg-file,  e.g., to temporarily change the value of the symbol XFLAGS when compiling certain
       modules.  To do this use the "@" indirection operator in the primary module list  to  reference  a  named
       sublist,  as  in  the  example  below.  Normal indirection cannot be used unless the sublist resides in a
       subdirectory or in a different file in the current directory, e.g., "@./mki2", since a single  mkpkg-file
       cannot contain two modules with the same name.  The same restrictions apply to the <u>$update</u> operator.

               libpkg.a:
                   @(i2)
                   alpha.x
                   beta.x
                   zeta.f
                   ;
               i2:
                   $set    XFLAGS = "-cO -i2"
                   gamma.f
                   delta.f
                   ;

       In  the  example above five object modules are to be updated in the library "libpkg.a".  The files listed
       in module "i2", if out of date, will be compiled with the nonstandard XFLAGS (compiler  flags)  specified
       by the <u>$set</u> statement shown.

</pre><h4><b>4.</b> <b>The</b> <b>MKPKG</b> <b>Macro</b> <b>Preprocessor</b></h4><pre>
       The  <b>mkpkg</b>  macro preprocessor provides a simple recursive symbol definition and replacement facility, an
       include file facility, conditional execution facilities, an OS escape facility, and a number  of  builtin
       directives.   The names of the preprocessor directives always begin with a dollar sign; whitespace is not
       permitted between the dollar sign and the remainder of the name.  Several preprocessor directives may  be
       given  on  one  line  if  desired.  Preprocessor directives are executed as they are encountered, and may
       appear anywhere, even in the member list for a library.

</pre><h4><b>4.1.</b> <b>Symbol</b> <b>Replacement</b></h4><pre>
       Symbol substitution in the <b>mkpkg</b> macro preprocessor is carried out at the character level rather than  at
       the  token  level, allowing macro expansion within tokens, quoted strings, or OS escape commands.  Macros
       are recursively expanded but may not have arguments.

       Macros may be defined on the <b>mkpkg</b> command line, in the argument list to a  <b>$call</b>  or  <b>$update</b>  directive
       (see  below),  in  an  include  file referenced with the <b>$include</b> directive, or in a <b>$set</b> directive.  All
       symbols are global and hence available  to  all  lower  level  modules,  but  symbols  are  automatically
       discarded whenever a module exits, hence cannot affect higher level modules.  A local symbol may redefine
       a  previously  defined  symbol.   The  IRAF and host system environment is treated as an extension of the
       <b>mkpkg</b> symbol table, i.e., a logical directory such as "iraf" may be referenced  like  a  locally  defined
       symbol.

       Macro  replacement  occurs only when explicitly indicated in the input text, as in the following example,
       which prints the pathname of the <b>dev$graphcap</b> file on the  <b>mkpkg</b>  standard  output.   The  sequence  "$("
       triggers macro substitution.  The value of a symbol may be obtained interactively from the standard input
       by  adding  a question mark after the left parenthesis, i.e., "$(?terminal)" (this does not work with the
       -f stdin flag).  The contents of a file may be included using the notation "$(@<u>file</u>)".   Note  that  case
       is  ignored  in  macro  names;  by  convention, logical directories are normally given in lower case, and
       locally defined symbols in upper case.

               $echo $(dev)graphcap
               !xc $(XFLAGS) filea.x fileb.x

       Symbols are most commonly defined locally with the <b>$set</b> directive.  The <b>$include</b> directive is useful  for
       sharing  symbols  amongst  different  modules,  or  for  isolating any machine dependent definitions in a
       separate file.  The IRAF <b>mkpkg</b> system include file  <b>hlib$mkpkg.inc</b>  is  automatically  included  whenever
       <b>mkpkg</b> is run.

       <b>$set</b> <u>symbol</u> <b>=</b> <u>value</u>
              Enter  the  named  symbol  into the symbol table with the given string value.  Any existing symbol
              will be silently redefined.  Symbols defined within a module are discarded when the module exits.

       <b>$include</b> <u>filename</u>
              Read commands (e.g., <b>$set</b> directives) from the named include file.  The include  filename  may  be
              any  legal virtual filename, but only the major logical directories are recognized, e.g., "iraf$",
              "host$", "hlib$", "lib$", "pkg$", and so on.

              The use of the <b>$set</b> directive is illustrated in the example  below.   Note  the  doubling  of  the
              preprocessor  metacharacter to avoid macro expansion when entering the value of the GEN macro into
              the symbol table.  The sequence "$$" is replaced by a single "$" whenever it is encountered in the
              input stream.

                      $set GFLAGS = "-k -t silrdx -p ak/"
                      $set GEN    = "$generic $$(GFLAGS)"

                      ifolder (amulr.x, amul.x) $(GEN) amul.x $endif

</pre><h4><b>4.2</b> <b>Conditional</b> <b>Execution</b></h4><pre>
       Conditional control flow is implemented by  the  <b>$if</b>  directives  introduced  in  the  last  example  and
       described below.  The character "n" may be inserted after the "$if" prefix of any directive to negate the
       sense of the test, e.g., "$ifndef" tests whether the named symbol does not exist.  Nesting is permitted.

       <b>$ifdef</b> (<u>symbol</u> [<u>,</u> <u>symbol,</u> <u>...</u>])

              Test for the existence of one of the named symbols.

       <b>$ifeq</b> (<u>symbol,</u> <u>value</u> [, <u>value</u>, <u>...</u>])

              Test if the value of the named symbol matches one of the listed value strings.

       <b>$iferr</b>

              Test  for  an  error  return  from the last directive executed which touched a file. This has only
              effect if mkpkg is invoked with the <b>-i</b> option so that it doesn't exit on the first error.

       <b>$iffile</b> (<u>file</u> [, <u>file</u>, <u>...</u>])

              Test for the existence of any of the named files.

       <b>$ifnewer</b> (<u>file</u>, <u>filea</u>)
       <b>$ifnewer</b> (file: <u>filea</u> [, <u>fileb</u>, <u>...</u>])

              Test if the named file is newer (has been modified more recently) than any of the named  files  to
              the  right.  The colon syntax may be used for clarity when comparing one file to many, but a comma
              will do.

       <b>$ifolder</b> (<u>file</u>, <u>filea</u>)
       <b>$ifolder</b> (file: <u>filea</u> [, <u>fileb</u>, <u>...</u>])

              Test if the named file is older than any of the named files.

       <b>$else</b>

              Marks the <u>else</u> clause of an <u>if</u> statement.  The <u>else-if</u> construct is implemented  as  "$else  $if",
              i.e., as a combination of the two more primitive constructs.

       <b>$endif</b>

              Terminates a $if or $if-$else statement.

       <b>$end</b>

              Terminates  an  arbitrary  number  of  $if  or  $if-$else  statements.   This  is  most useful for
              terminating a long list of $if-$else clauses, where the alternative would  be  a  long  string  of
              $endif directives.

       <b>$exit</b>  Terminate  the current program; equivalent to a semicolon, but the latter is normally used only at
              the end of the program to match the colon at the beginning, whereas <b>$exit</b> is used in conditionals.

</pre><h4><b>4.3</b> <b>Calling</b> <b>Modules</b></h4><pre>
       The following preprocessor directives are available for calling <b>mkpkg</b> modules or altering the normal flow
       of control.

       <b>$call</b> <u>module</u>[@<u>subdir</u>[/<u>file</u>]] [name=<u>value</u> <u>...</u>]

              Call the named mkpkg-file module as a subroutine.  In most cases the called module will be in  the
              current  mkpkg-file,  but  the full module name syntax permits the module to be in any file of any
              subdirectory ("./file" references a different file in the current directory).   Arguments  may  be
              passed  to  the  called  module  using the symbol definition facility; any symbols defined in this
              fashion are available to any modules called in turn by the called  module,  but  the  symbols  are
              discarded when the called module returns.

       <b>$update</b> <u>module</u>[@<u>subdir</u>[/<u>file</u>]] [name=<u>value</u> <u>...</u>]

              Identical  to  <b>$call</b>  except that the named module is understood to be a library member list.  The
              current value of the symbol XFLAGS is used if XC is called to compile any  files.   If  the  named
              library does not exist one will be created (a warning message is issued).

       <b>$goto</b>

              Causes  execution to resume at the line following the indicated label.  The syntax of a goto label
              is identical to that of a mkpkg-file module name, i.e.,  a  line  starting  with  the  given  name
              followed by a colon.  The <u>$goto</u> statement automatically cancels any <u>$if</u> nesting.

</pre><h4><b>4.4</b> <b>Preprocessor</b> <b>Directives</b></h4><pre>
       The  remaining  preprocessor directives are described below in alphabetical order.  Additional capability
       is available via OS escapes, provided the resultant machine dependence is acceptable.

       <b>$echo</b> <u>message</u>

              Print the given message string on the standard output.  The string must be quoted if  it  contains
              any spaces.

       <b>$checkout</b> <u>file</u> <u>directory</u>

              Check  the  named  file  out  of  the  indicated directory.  The checkout operation makes the file
              accessible as if it were in the current directory; checkout is implemented either  as  a  symbolic
              link or as a physical file copy depending upon the host system.  The referenced directory may be a
              logical  directory,  e.g., "lib$", or a path, e.g, "pkg$images/".  Checkout is not disabled by the
              "-n" flag.

       <b>$checkin</b> <u>file</u> <u>directory</u>

              Check the named file back into the indicated directory.   The  checkin  operation  is  implemented
              either  as  a  remove  link  or  copy  and  delete depending upon the host system.  Checkin is not
              disabled by the "-n" flag.

       <b>$copy</b> <u>filea</u> <u>fileb</u>

              Make a copy <u>fileb</u> of the existing file <u>filea</u>.  On a UNIX host the copy operation will preserve the
              file modify date if the file is a library (to avoid the "symbol table out of date" syndrome).

       <b>$delete</b> <u>file</u> <b>[</b><u>file</u> <u>...</u><b>]</b>

              Delete the named file or files.

       <b>$generic</b> [<u>-k</u>] [<u>-p</u> <u>prefix</u>] [<u>-t</u> <u>types</u>] [<u>-o</u> <u>root</u>] <u>files</u>

              Run the generic preprocessor on the named files.  The generic preprocessor is  an  IRAF  bootstrap
              utility.

       <b>$xyacc</b> [<u>options</u>] <u>file</u>

              Run the xyacc parser generator on the named files.  The yacc parser generator is an IRAF bootstrap
              utility.

       <b>$link</b> [<u>switches</u>] <u>file1</u> <u>file2</u> <u>...</u> <u>fileN</u> [<u>-o</u> <u>file.e</u>]

              Call  XC with the given argument list to link the indicated files and libraries.  The value of the
              symbol LFLAGS (default value the null string) is automatically inserted at the  beginning  of  the
              command line.  This is equivalent to "!xc $(LFLAGS) ...".

       <b>$move</b> <u>file</u> <u>destination</u>

              Move the named file to the indicated directory, or rename the file in the current directory.

       <b>$omake</b> <u>file</u> <b>[</b><u>dep1</u><b>]</b> <b>[</b><u>dep2</u> <u>...</u><b>]</b>

              Compile  the  named  source  file  if  it does not have a corresponding object file in the current
              directory, if the object file is older, or if any of the listed dependency files are newer (or not
              found).  The current value of the symbol XFLAGS is used if XC is called to compile the file.

       <b>$purge</b> <u>directory</u>

              Delete all old versions of all files in the named directory.  Nothing is done if the  system  does
              not support multiple file versions.

       <b>$special</b> <u>directory</u> <b>:</b> <u>filelist</u> <b>;</b>

              Add  one  or  more files to the special file list for the host system.  This is a system facility,
              not intended for use in applications <b>mkpkg</b> files.  The special file list is a list of  all  source
              files  needing  special processing for the local host system.  Examples of special files are files
              which are optimized in assembler (or some other nonstandard language),  or  files  which  must  be
              compiled  in  a special way to get around bugs in a host compiler.  The special file list makes it
              possible to flag arbitrary files for special processing, without having  to  modify  the  standard
              software  distribution.   In  the  IRAF  system,  the  special  file  list  is defined in the file
              "hlib$mkpkg.sf" which is included automatically by "hlib$mkpkg.inc" whenever <b>mkpkg</b> is run.

              The syntax of a <u>filelist</u> entry is as follows:

                      modname source_file mkobj_command

              where <u>modname</u> is the filename of a library module as it appears in a library module list  for  the
              named  directory, <u>source_file</u> is the virtual pathname of the source file to be used in lieu of the
              standard portable source file <u>modname</u>, and <u>mkobj_command</u> is the <b>mkpkg</b> command (e.g., $xc or an  OS
              escape)  to  be  executed  to compile the named module.  The character "&amp;" appearing in either the
              source file name or mkobj command is replaced by <u>modname</u>.  If the  <u>mkobj_command</u>  is  omitted  the
              specified source file will be compiled with $XC using the current value of XFLAGS.

       <b>$xc</b> [<u>switches</u>] <u>file1</u> <u>file2</u> <u>...</u> <u>fileN</u>

              Call  the XC compiler to compile the named files.  Note that the value of the symbol XFLAGS is <u>not</u>
              used when XC is explicitly called in this fashion (XFLAGS is used by <b>$update</b> and <b>$omake</b>).

       <b>$debug</b> [on|off]

              Turn debug mode on or off.  If no argument is supplied debug mode is turned on.  Turning on  debug
              mode automatically enables verbose mode.

       <b>$verbose</b> [on|off]

              Turn verbose mode on or off.  If no argument is supplied verbose mode is turned on.

</pre><h4><b>5.</b> <b>Error</b> <b>Recovery</b></h4><pre>
       <b>mkpkg</b>  is  implemented in such a way that it is restartable.  If a <b>mkpkg</b> operation terminates prematurely
       for some reason, e.g., because of a compile error, execution error (such as cannot find the mkpkgfile  in
       a  subdirectory),  interrupt,  etc.,  then  the mkpkg command can be repeated after correcting the error,
       without repeating the operations already completed.  If <b>mkpkg</b> is interrupted it  may  leave  checked  out
       files,  objects compiled but not yet updated in a library, etc. lying about, but this is harmless and the
       intermediate files will be cleaned up when the errors  have  been  corrected  and  the  run  successfully
       completes.

       <b>EXAMPLES</b>
              Update the current package.

                      cl&gt; mkpkg

              Update the package library but do not relink.

                      cl&gt; mkpkg libpkg.a

              Make a listing of the package.

                      cl&gt; mkpkg listing

              Sample mkpkg-file for the above commands:

                      # Make my package.

                      $call relink
                      $exit

                      relink:
                          $update libpkg.a
                          $omake  x_mypkg.x
                          $link   x_mypkg.o -lxtools
                          ;

                      libpkg.a:
                          task1.x     pkg.h
                          task2.x
                          filea.x     pkg.com pkg.h &lt;fset.h&gt;
                          fileb.x     pkg.com
                          ;

                      listing:
                          !pr task1.x task2.x file[ab].x | vpr -Pvup
                          ;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/generic.1.html">generic</a></b>(1), <b><a href="../man1/xc.1.html">xc</a></b>(1).

       There is also information in the README.softools in the IRAF documentation directory.

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was taken from the IRAF mkpkg.hlp help file.

IRAF 2.17                                           June 2021                                           <u><a href="../man1/MKPKG.1.html">MKPKG</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>