<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>virt-v2v - Convert a guest to use KVM</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/virt-v2v">virt-v2v_2.6.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       virt-v2v - Convert a guest to use KVM

</pre><h4><b>SYNOPSIS</b></h4><pre>
        virt-v2v [-i mode] [other -i* options]
                 [-o mode] [other -o* options]
                 [virt-customize options]
                 [guest|filename]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Virt-v2v converts a single guest from a foreign hypervisor to run on KVM.  It can read Linux and Windows
       guests running on VMware, Xen, Hyper-V and some other hypervisors, and convert them to KVM managed by
       libvirt, OpenStack, oVirt, Red Hat Virtualisation (RHV) or several other targets.  It can modify the
       guest to make it bootable on KVM and install virtio drivers so it will run quickly.

       There is also a companion front-end called <b><a href="../man1/virt-p2v.1.html">virt-p2v</a></b>(1) which comes as an ISO, CD or PXE image that can be
       booted on physical machines to virtualize those machines (physical to virtual, or p2v).

       To estimate the disk space needed before conversion, see <b><a href="../man1/virt-v2v-inspector.1.html">virt-v2v-inspector</a></b>(1).

       For in-place conversion, there is a separate tool called <b><a href="../man1/virt-v2v-in-place.1.html">virt-v2v-in-place</a></b>(1).

   <b>Input</b> <b>and</b> <b>Output</b>
       You normally run virt-v2v with several <u>-i*</u> options controlling the input mode and also several <u>-o*</u>
       options controlling the output mode.  In this sense, "input" refers to the source foreign hypervisor such
       as VMware, and "output" refers to the target KVM-based management system such as oVirt or OpenStack.

       The input and output sides of virt-v2v are separate and unrelated.  Virt-v2v can read from any input and
       write to any output.  Therefore these sides of virt-v2v are documented separately in this manual.

       Virt-v2v normally copies from the input to the output, called "copying mode".  In this case the source
       guest is always left unchanged.  In-place conversions may be done using <b><a href="../man1/virt-v2v-in-place.1.html">virt-v2v-in-place</a></b>(1).

   <b>Customization</b>
       Virt-v2v can also customize the guest during conversion, using the same options as <b><a href="../man1/virt-customize.1.html">virt-customize</a></b>(1).
       For example, injecting files using <u>--upload</u>, or using <u>--firstboot-script</u> to add additional script(s) to
       run at the first boot after conversion.  Read the virt-customize manual for more information on this
       topic.

   <b>Other</b> <b>virt-v2v</b> <b>topics</b>
       <b><a href="../man1/virt-v2v-support.1.html">virt-v2v-support</a></b>(1) — Supported hypervisors, virtualization management systems, guests.

       <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1) — Input from VMware.

       <b><a href="../man1/virt-v2v-input-xen.1.html">virt-v2v-input-xen</a></b>(1) — Input from Xen.

       <b><a href="../man1/virt-v2v-output-local.1.html">virt-v2v-output-local</a></b>(1) — Output to local files or local libvirt.

       <b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1) — Output to oVirt or RHV.

       <b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1) — Output to OpenStack.

       <b><a href="../man1/virt-v2v-release-notes-1.42.1.html">virt-v2v-release-notes-1.42</a></b>(1) — Release notes for 1.42 release.

       <b><a href="../man1/virt-v2v-release-notes-2.0.1.html">virt-v2v-release-notes-2.0</a></b>(1) — Release notes for 2.0 release.

       <b><a href="../man1/virt-v2v-release-notes-2.2.1.html">virt-v2v-release-notes-2.2</a></b>(1) — Release notes for 2.2 release.

       <b><a href="../man1/virt-v2v-release-notes-2.4.1.html">virt-v2v-release-notes-2.4</a></b>(1) — Release notes for 2.4 release.

       <b><a href="../man1/virt-v2v-release-notes-2.6.1.html">virt-v2v-release-notes-2.6</a></b>(1) — Release notes for 2.6 release.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Convert</b> <b>from</b> <b>VMware</b> <b>vCenter</b> <b>server</b> <b>to</b> <b>local</b> <b>libvirt</b>
       You have a VMware vCenter server called "vcenter.example.com", a datacenter called "Datacenter", and an
       ESXi hypervisor called "esxi".  You want to convert a guest called "vmware_guest" to run locally under
       libvirt.

        virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest

       In this case you will most likely have to run virt-v2v as "root", since it needs to talk to the system
       libvirt daemon and copy the guest disks to <u>/var/lib/libvirt/images</u>.

       For more information see <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1).

   <b>Convert</b> <b>from</b> <b>VMware</b> <b>to</b> <b>RHV/oVirt</b>
       This is the same as the previous example, except you want to send the guest to a RHV Data Domain using
       the RHV REST API.  Guest network interface(s) are connected to the target network called "ovirtmgmt".

        virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest \
          -o rhv-upload -oc https://ovirt-engine.example.com/ovirt-engine/api \
          -os ovirt-data -op /tmp/ovirt-admin-password -of raw \
          -oo rhv-cafile=/tmp/ca.pem --bridge ovirtmgmt

       In this case the host running virt-v2v acts as a <b>conversion</b> <b>server</b>.

       For more information see <b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1).

   <b>Convert</b> <b>from</b> <b>ESXi</b> <b>hypervisor</b> <b>over</b> <b>SSH</b> <b>to</b> <b>local</b> <b>libvirt</b>
       You have an ESXi hypervisor called "esxi.example.com" with SSH access enabled.  You want to convert from
       VMFS storage on that server to a local file.

        virt-v2v \
          -i vmx -it ssh \
          "ssh://<a href="mailto:root@esxi.example.com">root@esxi.example.com</a>/vmfs/volumes/datastore1/guest/guest.vmx" \
          -o local -os <a href="file:/var/tmp">/var/tmp</a>

       The guest must not be running.  Virt-v2v would <u>not</u> need to be run as root in this case.

       For more information about converting from VMX files see <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1).

   <b>Convert</b> <b>disk</b> <b>image</b> <b>to</b> <b>OpenStack</b>
       Given a disk image from another hypervisor that you want to convert to run on OpenStack (only KVM-based
       OpenStack is supported), you can run virt-v2v inside an OpenStack VM (called "v2v-vm" below), and do:

        virt-v2v -i disk disk.img -o openstack -oo server-id=v2v-vm

       See <b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1).

   <b>Convert</b> <b>disk</b> <b>image</b> <b>to</b> <b>disk</b> <b>image</b>
       Given a disk image from another hypervisor that you want to convert to run on KVM, you have two options.
       The simplest way is to try:

        virt-v2v -i disk disk.img -o local -os <a href="file:/var/tmp">/var/tmp</a>

       where virt-v2v guesses everything about the input <u>disk.img</u> and (in this case) writes the converted result
       to <u><a href="file:/var/tmp">/var/tmp</a></u>.

       A more complex method is to write some libvirt XML describing the input guest (if you can get the source
       hypervisor to provide you with libvirt XML, then so much the better).  You can then do:

        virt-v2v -i libvirtxml guest-domain.xml -o local -os <a href="file:/var/tmp">/var/tmp</a>

       Since <u>guest-domain.xml</u> contains the path(s) to the guest disk image(s) you do not need to specify the
       name of the disk image on the command line.

       To convert a local disk image and immediately boot it in local qemu, do:

        virt-v2v -i disk disk.img -o qemu -os <a href="file:/var/tmp">/var/tmp</a> -oo qemu-boot

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--help</b>
           Display help.

       <b>--bandwidth</b> bps
       <b>--bandwidth-file</b> filename
           Some  input  methods are able to limit the network bandwidth they will use statically or dynamically.
           In the first variant this sets the bandwidth limit statically in bits per second.  Formats like "10M"
           may be used (meaning 10 megabits per second).

           In the second variant the bandwidth is limited dynamically from the content of the file (also in bits
           per second, in the same formats supported by  the  first  variant).   You  may  use  both  parameters
           together,  meaning:  first  limit  to  a  static rate, then you can create the file while virt-v2v is
           running to adjust the rate dynamically.

           This is only supported for:

           •   input from Xen

           •   input from VMware VMX when using the SSH transport method

           •   input from VDDK

           •   <u>-i</u> <u>libvirtxml</u> when using HTTP or HTTPS disks

           •   input from VMware vCenter server

           The options are silently ignored for other input methods.

       <b>-b</b> ...
       <b>--bridge</b> ...
           See <u>--network</u> below.

       <b>--block-driver</b> <b>virtio-blk</b>
       <b>--block-driver</b> <b>virtio-scsi</b>
           When choosing a block driver for Windows guests, prefer "virtio-blk" or "virtio-scsi".   The  default
           is "virtio-blk".

           Note this has no effect for Linux guests at the moment.  That may be added in future.

       <b>--colors</b>
       <b>--colours</b>
           Use  ANSI  colour sequences to colourize messages.  This is the default when the output is a tty.  If
           the output of the program is redirected to a file, ANSI colour sequences are disabled unless you  use
           this option.

       <b>--compressed</b>
           This is the same as <u>-oo</u> <u>compressed</u>.

       <b>--echo-keys</b>
           When  prompting  for keys and passphrases, virt-v2v normally turns echoing off so you cannot see what
           you are typing.  If you are not worried about Tempest attacks and there is no one else  in  the  room
           you can specify this flag to see what you are typing.

           Note  this options only applies to keys and passphrases for encrypted devices and partitions, not for
           passwords used to connect to remote servers.

       <b>-i</b> <b>disk</b>
           Set the input method to <u>disk</u>.

           In this mode you can read a virtual machine disk image with no metadata.  virt-v2v tries to guess the
           best default metadata.  This is usually adequate but you can get finer control  (eg.  of  memory  and
           vCPUs) by using <u>-i</u> <u>libvirtxml</u> instead.  Only guests that use a single disk can be imported this way.

       <b>-i</b> <b>libvirt</b>
           Set the input method to <u>libvirt</u>.  This is the default.

           In  this  mode  you  have  to specify a libvirt guest name or UUID on the command line.  You may also
           specify a libvirt connection URI (see <u>-ic</u>).

           See "Starting the libvirt system instance" below.

       <b>-i</b> <b>libvirtxml</b>
           Set the input method to <u>libvirtxml</u>.

           In this mode you have to pass a libvirt XML file on the command line.  This file is read in order  to
           get  metadata  about  the  source  guest (such as its name, amount of memory), and also to locate the
           input disks.  See "Minimal XML for -i libvirtxml option" below.

       <b>-i</b> <b>local</b>
           This is the same as <u>-i</u> <u>disk</u>.

       <b>-i</b> <b>ova</b>
           Set the input method to <u>ova</u>.

           In this mode you can read a VMware ova file.  Virt-v2v will read the ova manifest file and check  the
           vmdk  volumes for validity (checksums) as well as analyzing the ovf file, and then convert the guest.
           See <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1).

       <b>-i</b> <b>vmx</b>
           Set the input method to <u>vmx</u>.

           In this mode you can read a VMware vmx file directly or over SSH.  This is useful when VMware VMs are
           stored on an NFS server which you can mount directly, or where you have access  by  SSH  to  an  ESXi
           hypervisor.  See <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1).

       <b>-ic</b> libvirtURI
           Specify a libvirt connection URI to use when reading the guest.  This is only used when <u>-i</u> <u>libvirt</u>.

           Only  local  libvirt connections, VMware vCenter connections, or RHEL 5 Xen remote connections can be
           used.  Other remote libvirt connections will not work in general.

           See also <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1), <b><a href="../man1/virt-v2v-input-xen.1.html">virt-v2v-input-xen</a></b>(1).

       <b>-if</b> format
           For <u>-i</u> <u>disk</u> only, this specifies the format of the input disk image.  For  other  input  methods  you
           should specify the input format in the metadata.

       <b>-io</b> OPTION=VALUE
           Set  input  option(s)  related to the current input mode or transport.  To display short help on what
           options are available you can use:

            virt-v2v -it vddk -io "?"

       <b>-io</b> <b>vddk-libdir=</b>LIBDIR
           Set the VDDK library directory.  This directory should <u>contain</u> subdirectories called  <u>include</u>,  <u>lib64</u>
           etc., but do not include <u>lib64</u> actually in the parameter.

           In  most  cases  this  parameter  is  required  when  using  the  <u>-it</u>  <u>vddk</u>  (VDDK)  transport.   See
           <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1) for details.

       <b>-io</b> <b>vddk-thumbprint=</b>xx:xx:xx:...
           Set the thumbprint of the remote VMware server.

           This parameter is required when using the <u>-it</u> <u>vddk</u> (VDDK)  transport.   See  <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1)
           for details.

       <b>-io</b> <b>vddk-config=</b>FILENAME
       <b>-io</b> <b>vddk-cookie=</b>COOKIE
       <b>-io</b> <b>vddk-nfchostport=</b>PORT
       <b>-io</b> <b>vddk-port=</b>PORT
       <b>-io</b> <b>vddk-snapshot=</b>SNAPSHOT-MOREF
       <b>-io</b> <b>vddk-transports=</b>MODE:MODE:...
           When using VDDK mode, these options are passed unmodified to the <b><a href="../man1/nbdkit.1.html">nbdkit</a></b>(1) VDDK plugin.  Please refer
           to  <b><a href="../man1/nbdkit-vddk-plugin.1.html">nbdkit-vddk-plugin</a></b>(1).   Do  not use these options unless you know what you are doing.  These are
           all optional.

       <b>-ip</b> filename
           Supply a file containing a password to be used when connecting to the target hypervisor.  If this  is
           omitted  then  the  input  hypervisor  may  ask for the password interactively.  Note the file should
           contain the whole password, <b>without</b> <b>any</b> <b>trailing</b> <b>newline</b>, and for security the file should have  mode
           0600 so that others cannot read it.

       <b>-it</b> <b>ssh</b>
           When using <u>-i</u> <u>vmx</u>, this enables the ssh transport.  See <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1).

       <b>-it</b> <b>vddk</b>
           Use  VMware  VDDK  as a transport to copy the input disks.  See <b><a href="../man1/virt-v2v-input-vmware.1.html">virt-v2v-input-vmware</a></b>(1).  If you use
           this parameter then you may need to use other <u>-io</u> <u>vddk*</u> options to specify  how  to  connect  through
           VDDK.

       <b>--key</b> SELECTOR
           Specify a key for LUKS, to automatically open a LUKS device when using the inspection.

           <b>--key</b> NAME<b>:key:</b>KEY_STRING
           <b>--key</b> UUID<b>:key:</b>KEY_STRING
           <b>--key</b> <b>all:key:</b>KEY_STRING
               "NAME"  is the libguestfs device name (eg. "/dev/sda1").  "UUID" is the device UUID.  "all" means
               try the key against any encrypted device.

               Use the specified "KEY_STRING" as passphrase.

           <b>--key</b> NAME<b>:file:</b>FILENAME
           <b>--key</b> UUID<b>:file:</b>FILENAME
           <b>--key</b> <b>all:file:</b>FILENAME
               Read the passphrase from <u>FILENAME</u>.

           <b>--key</b> NAME<b>:clevis</b>
           <b>--key</b> UUID<b>:clevis</b>
           <b>--key</b> <b>all:clevis</b>
               Attempt passphrase-less unlocking for the device with Clevis, over the network.  Please refer  to
               "ENCRYPTED DISKS" in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for more information on network-bound disk encryption (NBDE).

               Note  that  if  any  such  option  is  present  on the command line, QEMU user networking will be
               automatically enabled for the libguestfs appliance.

       <b>--keys-from-stdin</b>
           Read key or passphrase parameters from stdin.  The default is to try to  read  passphrases  from  the
           user by opening <u>/dev/tty</u>.

           If  there  are multiple encrypted devices then you may need to supply multiple keys on stdin, one per
           line.

           Note <u>--keys-from-stdin</u> only applies to keys and passphrases for encrypted devices and partitions, not
           for passwords used to connect to remote servers.

       <b>--mac</b> aa:bb:cc:dd:ee:ff<b>:network:</b>out
       <b>--mac</b> aa:bb:cc:dd:ee:ff<b>:bridge:</b>out
           Map source NIC MAC address to a network or bridge.

           See "Networks and bridges" below.

       <b>--mac</b> aa:bb:cc:dd:ee:ff<b>:ip:</b>ipaddr[,gw[,len[,ns,ns,...]]]
           Force a particular interface (controlled by its MAC address) to have a static IP address after boot.

           The fields in the parameter are: "ipaddr" is the  IP  address.   "gw"  is  the  optional  gateway  IP
           address.   "len"  is  the optional subnet mask length (an integer).  The final parameters are zero or
           more nameserver IP addresses.

           This option can be supplied zero or more times.

           You only need to use this option for certain broken guests  such  as  Windows  which  are  unable  to
           preserve  MAC  to  static  IP address mappings automatically.  You don't need to use it if Windows is
           using DHCP.  It is currently ignored for Linux guests since they do not have this problem.

       <b>--machine-readable</b>
       <b>--machine-readable</b>=format
           This option is used to make the output more machine friendly when being  parsed  by  other  programs.
           See "Machine readable output" below.

       <b>-n</b> in:out
       <b>-n</b> out
       <b>--network</b> in:out
       <b>--network</b> out
       <b>-b</b> in:out
       <b>-b</b> out
       <b>--bridge</b> in:out
       <b>--bridge</b> out
           Map  network  (or  bridge)  called  "in"  to network (or bridge) called "out".  If no "in:" prefix is
           given, all other networks (or bridges) are mapped to "out".

           See "Networks and bridges" below.

       <b>-o</b> <b>disk</b>
           This is the same as <u>-o</u> <u>local</u>.

       <b>-o</b> <b>glance</b>
           This is a legacy option.  You should probably use <u>-o</u> <u>openstack</u> instead.

           Set the output method to OpenStack Glance.  In this mode the converted guest is uploaded  to  Glance.
           See <b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1).

       <b>-o</b> <b>kubevirt</b>
           Set  the  output method to <u>kubevirt</u>.  <b>Note</b> <b>the</b> <b>way</b> <b>this</b> <b>mode</b> <b>works</b> <b>is</b> <b>experimental</b> <b>and</b> <b>will</b> <b>change</b> <b>in</b>
           <b>future.</b>

           In this mode, the converted guest is written  to  a  local  directory  specified  by  <u>-os</u>  <u>/dir</u>  (the
           directory must exist).  The converted guest’s disks are written to:

            /dir/name-sda
            /dir/name-sdb
            [etc]

           and guest metadata is created in the associated YAML file:

            /dir/name.yaml

           where "name" is the guest name.

       <b>-o</b> <b>libvirt</b>
           Set the output method to <u>libvirt</u>.  This is the default.

           In  this  mode,  the  converted  guest is created as a libvirt guest.  You may also specify a libvirt
           connection URI (see <u>-oc</u>).

           See "Starting the libvirt system instance" below, and <b><a href="../man1/virt-v2v-output-local.1.html">virt-v2v-output-local</a></b>(1).

       <b>-o</b> <b>local</b>
           Set the output method to <u>local</u>.

           In this mode, the converted guest is written  to  a  local  directory  specified  by  <u>-os</u>  <u>/dir</u>  (the
           directory must exist).  The converted guest’s disks are written as:

            /dir/name-sda
            /dir/name-sdb
            [etc]

           and a libvirt XML file is created containing guest metadata:

            /dir/name.xml

           where "name" is the guest name.

       <b>-o</b> <b>null</b>
           Set the output method to <u>null</u>.

           The guest is converted and copied but the results are thrown away and no metadata is written.

       <b>-o</b> <b>openstack</b>
           Set the output method to OpenStack.  See <b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1).

       <b>-o</b> <b>ovirt</b>
           This is the same as <u>-o</u> <u>rhv</u>.

       <b>-o</b> <b>ovirt-upload</b>
           This is the same as <u>-o</u> <u>rhv-upload</u>.

       <b>-o</b> <b>qemu</b>
           Set the output method to <u>qemu</u>.

           This  is  similar  to  <u>-o</u>  <u>local</u>, except that a shell script is written which you can use to boot the
           guest in qemu.  The converted disks and shell script are written to the directory specified by <u>-os</u>.

           When using this output mode, you can also specify the <u>-oo</u> <u>qemu-boot</u>  option  which  boots  the  guest
           under qemu immediately.

       <b>-o</b> <b>rhev</b>
           This is the same as <u>-o</u> <u>rhv</u>.

       <b>-o</b> <b>rhv</b>
           Set the output method to <u>rhv</u>.

           The  converted  guest is written to a RHV Export Storage Domain.  The <u>-os</u> parameter must also be used
           to specify the location of the Export Storage Domain.  Note this does not actually import  the  guest
           into RHV.  You have to do that manually later using the UI.

           See <b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1).

       <b>-o</b> <b>rhv-upload</b>
           Set the output method to <u>rhv-upload</u>.

           The  converted  guest is written directly to a RHV Data Domain.  This is a faster method than <u>-o</u> <u>rhv</u>,
           but requires oVirt or RHV ≥ 4.2.

           See <b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1).

       <b>-o</b> <b>vdsm</b>
           Set the output method to <u>vdsm</u>.

           This  mode  is  similar  to  <u>-o</u>  <u>rhv</u>,  but  the  full  path  to  the  data  domain  must  be   given:
           <u>/rhv/data-center/&lt;data-center-uuid&gt;/&lt;data-domain-uuid&gt;</u>.   This  mode  is only used when virt-v2v runs
           under VDSM control.

       <b>-oa</b> <b>sparse</b>
       <b>-oa</b> <b>preallocated</b>
           Set the output file allocation mode.  The default is "sparse".

       <b>-oc</b> URI
           Specify a connection URI to use when writing the converted guest.

           For <u>-o</u> <u>libvirt</u> this is the libvirt URI.  Only local libvirt connections can be used.  Remote  libvirt
           connections will not work.  See <b><a href="../man1/virt-v2v-output-local.1.html">virt-v2v-output-local</a></b>(1) for further information.

       <b>-of</b> format
           When converting the guest, convert the disks to the given format.

           If not specified, then the input format is used.

       <b>-on</b> name
           Rename  the guest when converting it.  If this option is not used then the output name is the same as
           the input name.

       <b>-oo</b> OPTION=VALUE
           Set output option(s) related to the current output mode.  To display short help on what  options  are
           available you can use:

            $ virt-v2v -o libvirt -oo "?"
            Output options that can be used with -o libvirt:

             -oo compressed      Compress the output file (used only with
                                 -of qcow2)

       <b>-oo</b> <b>compressed</b>
           For  outputs  which support qcow2 format (<u>-of</u> <u>qcow2</u>), this writes a compressed qcow2 file.  It is the
           equivalent to the <u>-c</u> option of <b><a href="../man1/qemu-img.1.html">qemu-img</a></b>(1).

       <b>-oo</b> <b>guest-id=</b>"ID"
           For <u>-o</u> <u>openstack</u> (<b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1)) only, set a guest ID which is saved  on  each  Cinder
           volume in the "virt_v2v_guest_id" volume property.

       <b>-oo</b> <b>qemu-boot</b>
           When using <u>-o</u> <u>qemu</u> only, this boots the guest immediately after virt-v2v finishes.

       <b>-oo</b> <b>verify-server-certificate</b>
       <b>-oo</b> <b>verify-server-certificate=</b>"true|false"
           For  <u>-o</u>  <u>openstack</u> (<b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1)) only, this can be used to disable SSL certification
           validation when connecting to OpenStack by specifying <u>-oo</u> <u>verify-server-certificate=false</u>.

       <b>-oo</b> <b>os-</b>*<b>=</b>*
           For <u>-o</u> <u>openstack</u> (<b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1)) only, set  optional  OpenStack  authentication.   For
           example <u>-oo</u> <u>os-username=</u>NAME is equivalent to "openstack --os-username=NAME".

       <b>-oo</b> <b>rhv-cafile=</b><u>ca.pem</u>
           For <u>-o</u> <u>rhv-upload</u> (<b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1)) only, the <u>ca.pem</u> file (Certificate Authority), copied from
           <u>/etc/pki/ovirt-engine/ca.pem</u> on the oVirt engine.

       <b>-oo</b> <b>rhv-cluster=</b>"CLUSTERNAME"
           For  <u>-o</u>  <u>rhv-upload</u>  (<b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1))  only,  set the RHV Cluster Name.  If not given it uses
           "Default".

       <b>-oo</b> <b>rhv-proxy</b>
           For <u>-o</u> <u>rhv-upload</u> (<b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1)) only, proxy the upload  through  oVirt  Engine.   This  is
           slower  than  uploading  directly  to  the  oVirt node but may be necessary if you do not have direct
           network access to the nodes.

       <b>-oo</b> <b>rhv-verifypeer</b>
           For <u>-o</u> <u>rhv-upload</u> (<b><a href="../man1/virt-v2v-output-rhv.1.html">virt-v2v-output-rhv</a></b>(1)) only, verify the oVirt/RHV server’s identity  by  checking
           the server‘s certificate against the Certificate Authority.

       <b>-oo</b> <b>server-id=</b>"NAME|UUID"
           For  <u>-o</u> <u>openstack</u> (<b><a href="../man1/virt-v2v-output-openstack.1.html">virt-v2v-output-openstack</a></b>(1)) only, set the name of the conversion appliance where
           virt-v2v is running.

       <b>-oo</b> <b>vdsm-compat=0.10</b>
       <b>-oo</b> <b>vdsm-compat=1.1</b>
           If <u>-o</u> <u>vdsm</u> and the output format is qcow2, then we add the qcow2 <u>compat=0.10</u>  option  to  the  output
           file for compatibility with RHEL 6 (see https://bugzilla.redhat.com/1145582).

           If <u>-oo</u> <u>vdsm-compat=1.1</u> is used then modern qcow2 (<u>compat=1.1</u>) files are generated instead.

           Currently  <u>-oo</u>  <u>vdsm-compat=0.10</u>  is  the  default,  but this will change to <u>-oo</u> <u>vdsm-compat=1.1</u> in a
           future version of virt-v2v (when we can assume that everyone is using a modern version of qemu).

           <b>Note</b> <b>this</b> <b>option</b> <b>only</b> <b>affects</b> <u><b>-o</b></u> <u><b>vdsm</b></u> <b>output</b>.  All other output modes  (including  <u>-o</u>  <u>rhv</u>)  generate
           modern qcow2 <u>compat=1.1</u> files, always.

           If this option is available, then "vdsm-compat-option" will appear in the <u>--machine-readable</u> output.

       <b>-oo</b> <b>vdsm-image-uuid=</b>UUID
       <b>-oo</b> <b>vdsm-vol-uuid=</b>UUID
       <b>-oo</b> <b>vdsm-vm-uuid=</b>UUID
       <b>-oo</b> <b>vdsm-ovf-output=</b>DIR
           Normally  the  RHV  output  mode  chooses  random  UUIDs for the target guest.  However VDSM needs to
           control the UUIDs and passes these parameters when virt-v2v runs under VDSM control.  The  parameters
           control:

           •   the image directory of each guest disk (<u>-oo</u> <u>vdsm-image-uuid</u>) (this option is passed once for each
               guest disk)

           •   UUIDs for each guest disk (<u>-oo</u> <u>vdsm-vol-uuid</u>) (this option is passed once for each guest disk)

           •   the OVF file name (<u>-oo</u> <u>vdsm-vm-uuid</u>).

           •   the OVF output directory (default current directory) (<u>-oo</u> <u>vdsm-ovf-output</u>).

           The  format  of  UUIDs  is:  "12345678-1234-1234-1234-123456789abc"  (each  hex digit can be "0-9" or
           "a-f"), conforming to OSF DCE 1.1.

           These options can only be used with <u>-o</u> <u>vdsm</u>.

       <b>-oo</b> <b>vdsm-ovf-flavour=</b>flavour
           This option controls the format of the OVF generated at the end of conversion.  Currently  there  are
           two possible flavours:

           rhvexp
               The OVF format used in RHV export storage domain.

           ovirt
               The OVF format understood by oVirt REST API.

           For backward compatibility the default is <u>rhvexp</u>, but this may change in the future.

       <b>-op</b> file
           Supply  a  file  containing a password to be used when connecting to the target hypervisor.  Note the
           file should contain the whole password, <b>without</b> <b>any</b> <b>trailing</b>  <b>newline</b>,  and  for  security  the  file
           should have mode 0600 so that others cannot read it.

       <b>-os</b> storage
           The location of the storage for the converted guest.

           For <u>-o</u> <u>libvirt</u>, this is a libvirt directory pool (see "virsh pool-list") or pool UUID.

           For <u>-o</u> <u>local</u> and <u>-o</u> <u>qemu</u>, this is a directory name.  The directory must exist.

           For <u>-o</u> <u>rhv-upload</u>, this is the name of the destination Storage Domain.

           For <u>-o</u> <u>openstack</u>, this is the optional Cinder volume type.

           For <u>-o</u> <u>rhv</u>, this can be an NFS path of the Export Storage Domain of the form "&lt;host&gt;:&lt;path&gt;", eg:

            rhv-storage.example.com:/rhv/export

           The  NFS  export  must  be  mountable  and  writable by the user and host running virt-v2v, since the
           virt-v2v program has to actually mount it when it runs.  So you probably  have  to  run  virt-v2v  as
           "root".

           <b>Or:</b>  You  can  mount  the Export Storage Domain yourself, and point <u>-os</u> to the mountpoint.  Note that
           virt-v2v will still need to write to this remote directory, so virt-v2v will still  need  to  run  as
           "root".

           You will get an error if virt-v2v is unable to mount/write to the Export Storage Domain.

       <b>--print-source</b>
           Print  information  about  the  source guest and stop.  This option is useful when you are setting up
           network and bridge maps.  See "Networks and bridges".

       <b>--qemu-boot</b>
           This is the same as <u>-oo</u> <u>qemu-boot</u>.

       <b>-q</b>
       <b>--quiet</b>
           This disables progress bars and other unnecessary output.

       <b>--root</b> <b>ask</b>
       <b>--root</b> <b>single</b>
       <b>--root</b> <b>first</b>
       <b>--root</b> /dev/sdX
       <b>--root</b> /dev/VG/LV
           Choose the root filesystem to be converted.

           In the case where the virtual machine  is  dual-boot  or  multi-boot,  or  where  the  VM  has  other
           filesystems  that  look like operating systems, this option can be used to select the root filesystem
           (a.k.a. "C:" drive or <u>/</u>) of the operating system that is  to  be  converted.   The  Windows  Recovery
           Console,  certain attached DVD drives, and bugs in libguestfs inspection heuristics, can make a guest
           look like a multi-boot operating system.

           The default in virt-v2v ≤ 0.7.1 was <u>--root</u> <u>single</u>, which causes  virt-v2v  to  die  if  a  multi-boot
           operating system is found.

           Since  virt-v2v  ≥  0.7.2  the  default  is now <u>--root</u> <u>ask</u>: If the VM is found to be multi-boot, then
           virt-v2v will stop and list the possible root filesystems and  ask  the  user  which  to  use.   This
           requires that virt-v2v is run interactively.

           <u>--root</u> <u>first</u>  means  to  choose  the  first root device in the case of a multi-boot operating system.
           Since this is a heuristic, it may sometimes choose the wrong one.

           You can also name a specific root device, eg. <u>--root</u> <u>/dev/sda2</u> would mean to use the second partition
           on the first hard drive.  If the named root device does not exist or  was  not  detected  as  a  root
           device, then virt-v2v will fail.

           Note  that  there  is a bug in grub which prevents it from successfully booting a multiboot system if
           virtio is enabled.  Grub is only able to boot  an  operating  system  from  the  first  virtio  disk.
           Specifically,  <u><a href="file:/boot">/boot</a></u>  must be on the first virtio disk, and it cannot chainload an OS which is not in
           the first virtio disk.

       <b>-v</b>
       <b>--verbose</b>
           Enable verbose messages for debugging.

       <b>-V</b>
       <b>--version</b>
           Display version number and exit.

       <b>--wrap</b>
           Wrap error, warning, and informative messages.  This is the default when the output is a tty.  If the
           output of the program is redirected to a file, wrapping is disabled unless you use this option.

       <b>-x</b>  Enable tracing of libguestfs API calls.

   <b>Customization</b> <b>options</b>
       <b>--append-line</b> FILE:LINE
           Append a single line of text to the "FILE".  If the file does not already end with  a  newline,  then
           one  is  added  before  the  appended  line.  Also a newline is added to the end of the "LINE" string
           automatically.

           For example (assuming ordinary shell quoting) this command:

            --append-line '<a href="file:/etc/hosts">/etc/hosts</a>:10.0.0.1 foo'

           will add either "10.0.0.1 foo⏎" or "⏎10.0.0.1 foo⏎" to the file, the latter only if the existing file
           does not already end with a newline.

           "⏎" represents a newline character, which is guessed by looking at the existing content of the  file,
           so this command does the right thing for files using Unix or Windows line endings.  It also works for
           empty or non-existent files.

           To insert several lines, use the same option several times:

            --append-line '<a href="file:/etc/hosts">/etc/hosts</a>:10.0.0.1 foo'
            --append-line '<a href="file:/etc/hosts">/etc/hosts</a>:10.0.0.2 bar'

           To insert a blank line before the appended line, do:

            --append-line '<a href="file:/etc/hosts">/etc/hosts</a>:'
            --append-line '<a href="file:/etc/hosts">/etc/hosts</a>:10.0.0.1 foo'

       <b>--chmod</b> PERMISSIONS:FILE
           Change the permissions of "FILE" to "PERMISSIONS".

           <u>Note</u>:  "PERMISSIONS"  by  default would be decimal, unless you prefix it with 0 to get octal, ie. use
           0700 not 700.

       <b>--chown</b> UID:GID:PATH
           Change the owner user and group ID of a file or directory in the guest.  Note:

           •   Only numeric UIDs and GIDs will work, and these may not be the same inside the guest  as  on  the
               host.

           •   This will not work with Windows guests.

           For example:

            virt-customize --chown '0:0:/var/log/audit.log'

           See also: <u>--upload</u>.

       <b>--commands-from-file</b> FILENAME
           Read the customize commands from a file, one (and its arguments) each line.

           Each line contains a single customization command and its arguments, for example:

            delete /some/file
            install some-package
            password some-user:password:its-new-password

           Empty  lines  are  ignored,  and  lines  starting  with  "#"  are  comments  and are ignored as well.
           Furthermore, arguments can be spread across multiple lines, by adding a "\" (continuation  character)
           at the of a line, for example

            edit /some/file:\
              s/^OPT=.*/OPT=ok/

           The  commands  are  handled  in  the same order as they are in the file, as if they were specified as
           <u>--delete</u> <u>/some/file</u> on the command line.

       <b>--copy</b> SOURCE:DEST
           Copy files or directories recursively inside the guest.

           Wildcards cannot be used.

       <b>--copy-in</b> LOCALPATH:REMOTEDIR
           Copy local files or directories recursively into the  disk  image,  placing  them  in  the  directory
           "REMOTEDIR" (which must exist).

           Wildcards cannot be used.

       <b>--delete</b> PATH
           Delete a file from the guest.  Or delete a directory (and all its contents, recursively).

           You  can  use shell glob characters in the specified path.  Be careful to escape glob characters from
           the host shell, if that is required.  For example:

            virt-customize --delete '<a href="file:/var/log/">/var/log/</a>*.log'.

           See also: <u>--upload</u>, <u>--scrub</u>.

       <b>--edit</b> FILE:EXPR
           Edit "FILE" using the Perl expression "EXPR".

           Be careful to properly quote the expression to prevent it from being altered by the shell.

           Note that this option is only available when Perl 5 is installed.

           See "NON-INTERACTIVE EDITING" in <b><a href="../man1/virt-edit.1.html">virt-edit</a></b>(1).

       <b>--firstboot</b> SCRIPT
           Install "SCRIPT" inside the guest, so that when the guest first boots up, the script runs  (as  root,
           late in the boot process).

           The script is automatically chmod +x after installation in the guest.

           The  alternative version <u>--firstboot-command</u> is the same, but it conveniently wraps the command up in
           a single line script for you.

           You can have multiple <u>--firstboot</u> options.  They run in the  same  order  that  they  appear  on  the
           command line.

           Please  take a look at "FIRST BOOT SCRIPTS" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for more information and caveats about
           the first boot scripts.

           See also <u>--run</u>.

       <b>--firstboot-command</b> 'CMD+ARGS'
           Run command (and arguments) inside the guest when the guest first boots up (as root, late in the boot
           process).

           You can have multiple <u>--firstboot</u> options.  They run in the  same  order  that  they  appear  on  the
           command line.

           Please  take a look at "FIRST BOOT SCRIPTS" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for more information and caveats about
           the first boot scripts.

           See also <u>--run</u>.

       <b>--firstboot-install</b> PKG,PKG..
           Install the named packages (a comma-separated list).  These are installed when the guest first  boots
           using the guest’s package manager (eg. apt, yum, etc.) and the guest’s network connection.

           For   an  overview  on  the  different  ways  to  install  packages,  see  "INSTALLING  PACKAGES"  in
           <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1).

       <b>--hostname</b> HOSTNAME
           Set the hostname of the guest to "HOSTNAME".  You can use a dotted hostname.domainname (FQDN) if  you
           want.

       <b>--install</b> PKG,PKG..
           Install  the  named  packages  (a  comma-separated list).  These are installed during the image build
           using the guest’s package manager (eg. apt, yum, etc.) and the host’s network connection.

           For  an  overview  on  the  different  ways  to  install  packages,  see  "INSTALLING  PACKAGES"   in
           <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1).

           See also <u>--update</u>, <u>--uninstall</u>.

       <b>--link</b> TARGET:LINK[:LINK..]
           Create symbolic link(s) in the guest, starting at "LINK" and pointing at "TARGET".

       <b>--mkdir</b> DIR
           Create a directory in the guest.

           This  uses "mkdir -p" so any intermediate directories are created, and it also works if the directory
           already exists.

       <b>--move</b> SOURCE:DEST
           Move files or directories inside the guest.

           Wildcards cannot be used.

       <b>--no-logfile</b>
           Scrub "builder.log" (log file from build commands) from the image after building is complete.  If you
           don't want to reveal precisely how the image was built, use this option.

           See also: "LOG FILE".

       <b>--no-selinux-relabel</b>
           Do not attempt to correct the SELinux labels of files in the guest.

           In such guests that support SELinux, customization automatically relabels files so that they have the
           correct SELinux label.  (The relabeling  is  performed  immediately,  but  if  the  operation  fails,
           customization  will  instead touch <u>/.autorelabel</u> on the image to schedule a relabel operation for the
           next time the image boots.)  This option disables the automatic relabeling.

           The option is a no-op for guests that do not support SELinux.

       <b>--password</b> USER:SELECTOR
           Set the password for "USER".  (Note this option does <u>not</u> create the user account).

           See "USERS AND PASSWORDS" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for the format of the "SELECTOR" field, and also how  to
           set up user accounts.

       <b>--password-crypto</b> md5|sha256|sha512
           When  the  virt tools change or set a password in the guest, this option sets the password encryption
           of that password to "md5", "sha256" or "sha512".

           "sha256" and "sha512" require glibc ≥ 2.7 (check <b><a href="../man3/crypt.3.html">crypt</a></b>(3) inside the guest).

           "md5" will work with relatively old Linux guests (eg. RHEL 3),  but  is  not  secure  against  modern
           attacks.

           The  default is "sha512" unless libguestfs detects an old guest that didn't have support for SHA-512,
           in which case it will use "md5".  You can override libguestfs by specifying this option.

           Note this does not change the default password encryption used by the guest when you create new  user
           accounts  inside  the guest.  If you want to do that, then you should use the <u>--edit</u> option to modify
           "/etc/sysconfig/authconfig" (Fedora, RHEL) or "<a href="file:/etc/pam.d/common-password">/etc/pam.d/common-password</a>" (Debian, Ubuntu).

       <b>--root-password</b> SELECTOR
           Set the root password.

           See "USERS AND PASSWORDS" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for the format of the "SELECTOR" field, and also how  to
           set up user accounts.

           Note:  In  virt-builder,  if  you  <u>don't</u>  set  <u>--root-password</u>  then the guest is given a <u>random</u> root
           password.

       <b>--run</b> SCRIPT
           Run the shell script (or any program) called "SCRIPT" on the disk image.  The script runs virtualized
           inside a small appliance, chrooted into the guest filesystem.

           The script is automatically chmod +x.

           If libguestfs supports it then a limited network connection is available but it only allows  outgoing
           network  connections.   You can also attach data disks (eg. ISO files) as another way to provide data
           (eg. software packages) to the script without needing a network connection (<u>--attach</u>).  You can  also
           upload data files (<u>--upload</u>).

           You  can  have  multiple  <u>--run</u>  options.  They run in the same order that they appear on the command
           line.

           See also: <u>--firstboot</u>, <u>--attach</u>, <u>--upload</u>.

       <b>--run-command</b> 'CMD+ARGS'
           Run the command and arguments on the disk  image.   The  command  runs  virtualized  inside  a  small
           appliance, chrooted into the guest filesystem.

           If  libguestfs supports it then a limited network connection is available but it only allows outgoing
           network connections.  You can also attach data disks (eg. ISO files) as another way to  provide  data
           (eg.  software packages) to the script without needing a network connection (<u>--attach</u>).  You can also
           upload data files (<u>--upload</u>).

           You can have multiple <u>--run-command</u> options.  They run in the same order  that  they  appear  on  the
           command line.

           See also: <u>--firstboot</u>, <u>--attach</u>, <u>--upload</u>.

       <b>--scrub</b> FILE
           Scrub a file from the guest.  This is like <u>--delete</u> except that:

           •   It scrubs the data so a guest could not recover it.

           •   It cannot delete directories, only regular files.

       <b>--selinux-relabel</b>
           This is a compatibility option that does nothing.

       <b>--sm-attach</b> SELECTOR
           Attach to a pool using "subscription-manager".

           See "SUBSCRIPTION-MANAGER" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for the format of the "SELECTOR" field.

       <b>--sm-credentials</b> SELECTOR
           Set the credentials for "subscription-manager".

           See "SUBSCRIPTION-MANAGER" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for the format of the "SELECTOR" field.

       <b>--sm-register</b>
           Register the guest using "subscription-manager".

           This requires credentials being set using <u>--sm-credentials</u>.

       <b>--sm-remove</b>
           Remove all the subscriptions from the guest using "subscription-manager".

       <b>--sm-unregister</b>
           Unregister the guest using "subscription-manager".

       <b>--ssh-inject</b> USER[:SELECTOR]
           Inject  an  ssh key so the given "USER" will be able to log in over ssh without supplying a password.
           The "USER" must exist already in the guest.

           See "SSH KEYS" in <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1) for the format of the "SELECTOR" field.

           You can have multiple <u>--ssh-inject</u> options, for different users and also for more keys for each user.

       <b>--tar-in</b> TARFILE:REMOTEDIR
           Copy local files or directories from a local tar file called "TARFILE" into the disk  image,  placing
           them  in  the  directory "REMOTEDIR" (which must exist).  Note that the tar file must be uncompressed
           (<u>.tar.gz</u> files will not work here)

       <b>--timezone</b> TIMEZONE
           Set the default timezone of the guest to "TIMEZONE".  Use a location string like "Europe/London"

       <b>--touch</b> FILE
           This command performs a <b><a href="../man1/touch.1.html">touch</a></b>(1)-like operation on "FILE".

       <b>--truncate</b> FILE
           This command truncates "FILE" to a zero-length file. The file must exist already.

       <b>--truncate-recursive</b> PATH
           This command recursively truncates all files under "PATH" to zero-length.

       <b>--uninstall</b> PKG,PKG..
           Uninstall the named packages (a comma-separated list).  These are  removed  during  the  image  build
           using  the  guest’s  package  manager  (eg.  apt, yum, etc.).  Dependent packages may also need to be
           uninstalled to satisfy the request.

           See also <u>--install</u>, <u>--update</u>.

       <b>--update</b>
           Do the equivalent of "yum update", "apt-get upgrade", or whatever command is required to  update  the
           packages already installed in the template to their latest versions.

           See also <u>--install</u>, <u>--uninstall</u>.

       <b>--upload</b> FILE:DEST
           Upload  local  file  "FILE" to destination "DEST" in the disk image.  File owner and permissions from
           the original are preserved, so you should set them to what you want them to be in the disk image.

           "DEST" could be the final filename.  This can be used to rename the file on upload.

           If "DEST" is a directory name (which must already exist in the guest) then the file is uploaded  into
           that directory, and it keeps the same name as on the local filesystem.

           See also: <u>--mkdir</u>, <u>--delete</u>, <u>--scrub</u>.

       <b>--write</b> FILE:CONTENT
           Write "CONTENT" to "FILE".

</pre><h4><b>NOTES</b></h4><pre>
   <b>Xen</b> <b>paravirtualized</b> <b>guests</b>
       Older  versions  of virt-v2v could turn a Xen paravirtualized (PV) guest into a KVM guest by installing a
       new kernel.  This version of virt-v2v does <u>not</u> attempt to install any new kernels.  Instead it will  give
       you an error if there are <u>only</u> Xen PV kernels available.

       Therefore  before  conversion  you should check that a regular kernel is installed.  For some older Linux
       distributions, this means installing a kernel from the table below:

        RHEL 3         (Does not apply, as there was no Xen PV kernel)

        RHEL 4         i686 with &gt; 10GB of RAM: install 'kernel-hugemem'
                       i686 SMP: install 'kernel-smp'
                       other i686: install 'kernel'
                       x86-64 SMP with &gt; 8 CPUs: install 'kernel-largesmp'
                       x86-64 SMP: install 'kernel-smp'
                       other x86-64: install 'kernel'

        RHEL 5         i686: install 'kernel-PAE'
                       x86-64: install 'kernel'

        SLES 10        i586 with &gt; 10GB of RAM: install 'kernel-bigsmp'
                       i586 SMP: install 'kernel-smp'
                       other i586: install 'kernel-default'
                       x86-64 SMP: install 'kernel-smp'
                       other x86-64: install 'kernel-default'

        SLES 11+       i586: install 'kernel-pae'
                       x86-64: install 'kernel-default'

        Windows        (Does not apply, as there is no Xen PV Windows kernel)

   <b>Enabling</b> <b>virtio</b>
       "Virtio" is the name for a set of drivers which  make  disk  (block  device),  network  and  other  guest
       operations work much faster on KVM.

       Older  versions  of  virt-v2v  could  install  these  drivers  for certain Linux guests.  This version of
       virt-v2v does <u>not</u> attempt to install new Linux kernels or drivers, but will warn  you  if  they  are  not
       installed already.

       In order to enable virtio, and hence improve performance of the guest after conversion, you should ensure
       that the <b>minimum</b> versions of packages are installed <u>before</u> conversion, by consulting the table below.

        RHEL 3         No virtio drivers are available

        RHEL 4         kernel &gt;= 2.5.9-89.EL
                       lvm2 &gt;= 2.02.42-5.el4
                       device-mapper &gt;= 1.02.28-2.el4
                       selinux-policy-targeted &gt;= 1.17.30-2.152.el4
                       policycoreutils &gt;= 1.18.1-4.13

        RHEL 5         kernel &gt;= 2.6.18-128.el5
                       lvm2 &gt;= 2.02.40-6.el5
                       selinux-policy-targeted &gt;= 2.4.6-203.el5

        RHEL 6+        All versions support virtio

        Fedora         All versions support virtio

        SLES 11+       All versions support virtio

        SLES 10        kernel &gt;= 2.6.16.60-0.85.1

        OpenSUSE 11+   All versions support virtio

        OpenSUSE 10    kernel &gt;= 2.6.25.5-1.1

        Debian 6+      All versions support virtio

        Ubuntu 10.04+  All versions support virtio

        Windows        Drivers are installed from the ISO or directory pointed
                       to by the "VIRTIO_WIN" environment variable if present.
                       If the "VIRTIO_WIN" environment variable is absent
                       (which is the recommended setting), then libosinfo is
                       consulted first, for driver files that are locally
                       available on the conversion host.

   <b>RHEL</b> <b>4:</b> <b>SELinux</b> <b>relabel</b> <b>appears</b> <b>to</b> <b>hang</b> <b>forever</b>
       In RHEL ≤ 4.7 there was a bug which causes SELinux relabelling to appear to hang forever at:

        *** Warning -- SELinux relabel is required. ***
        *** Disabling security enforcement.         ***
        *** Relabeling could take a very long time, ***
        *** depending on file system size.          ***

       In  reality  it  is  waiting for you to press a key (but there is no visual indication of this).  You can
       either hit the "[Return]" key, at which point the guest will finish relabelling and reboot,  or  you  can
       install    policycoreutils    ≥   1.18.1-4.13   before   starting   the   v2v   conversion.    See   also
       https://bugzilla.redhat.com/show_bug.cgi?id=244636

   <b>Debian</b> <b>and</b> <b>Ubuntu</b>
       <u>"warning:</u> <u>could</u> <u>not</u> <u>determine</u> <u>a</u> <u>way</u> <u>to</u> <u>update</u> <u>the</u> <u>configuration</u> <u>of</u> <u>Grub2"</u>

       Currently, virt-v2v has no way to set the default kernel in Debian and Ubuntu  guests  using  GRUB  2  as
       bootloader.   This  means that virt-v2v will not change the default kernel used for booting, even in case
       it is not the best kernel available on the guest.  A recommended procedure is, before using virt-v2v,  to
       check  that  the  boot  kernel  is the best kernel available in the guest (for example by making sure the
       guest is up-to-date).

       <u>"vsyscall</u> <u>attempted</u> <u>with</u> <u>vsyscall=none"</u>

       When run on a recent Debian host virt-v2v may fail to convert guests which were created before 2013.   In
       the debugging output you will see a crash message similar to:

        vsyscall attempted with vsyscall=none ip:...
        segfault at ...

       This  is  caused  because  Debian removed support for running old binaries which used the legacy vsyscall
       page to call into the kernel.

       You can work around this problem by running this command before running virt-v2v:

        export LIBGUESTFS_APPEND="vsyscall=emulate"

       For more information, see https://bugzilla.redhat.com/1592061

   <b>Windows</b>
       <u>System</u> <u>disk</u> <u>on</u> <u>a</u> <u>Dynamic</u> <u>Disk</u> <u>is</u> <u>not</u> <u>supported</u>

       If the Windows system disk (the drive containing "\windows") is located on a Dynamic Disk then it  cannot
       be  converted.   Data  disks — that is, disks which are part of the guest but do not contain parts of the
       Windows operating system — may be Dynamic Disks.

       See https://bugzilla.redhat.com/2140548.

       <u>Windows</u> <u>≥</u> <u>8</u> <u>Fast</u> <u>Startup</u> <u>is</u> <u>incompatible</u> <u>with</u> <u>virt-v2v</u>

       Guests which use the Windows ≥ 8 "Fast Startup" feature  (or  guests  which  are  hibernated)  cannot  be
       converted with virt-v2v.  You will see an error:

        virt-v2v: error: unable to mount the disk image for writing. This has
        probably happened because Windows Hibernation or Fast Restart is being
        used in this guest. You have to disable this (in the guest) in order
        to use virt-v2v.

       As  the  message says, you need to boot the guest and disable the "Fast Startup" feature (Control Panel →
       Power Options → Choose what the power buttons do → Change settings that are currently unavailable →  Turn
       on fast startup), and shut down the guest, and then you will be able to convert it.

       For more information, see: "WINDOWS HIBERNATION AND WINDOWS 8 FAST STARTUP" in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       <u>Boot</u> <u>failure:</u> <u>0x0000007B</u>

       This  boot  failure  is  caused  by  Windows  being  unable  to  find  or load the right disk driver (eg.
       <u>viostor.sys</u>).  If you experience this error, here are some things to check:

       •   First ensure that the guest boots on the source hypervisor before conversion.

       •   Check you have the Windows virtio drivers available in <u>/usr/share/virtio-win</u>, and that  virt-v2v  did
           not print any warning about not being able to install virtio drivers.

           On  Red Hat Enterprise Linux 7,  you  will  need  to  install  the  signed  drivers  available in the
           "virtio-win" package.  If you do not have access to the signed drivers, then you will  probably  need
           to disable driver signing in the boot menus.

       •   Check  that you are presenting a virtio-blk interface (<b>not</b> virtio-scsi and <b>not</b> ide) to the guest.  On
           the qemu/KVM command line you should see something similar to this:

            ... -drive file=windows-sda,if=virtio ...

           In libvirt XML, you should see:

            &lt;target dev='vda' bus='virtio'/&gt;

       •   Check that Windows Group Policy does not prevent the  driver  from  being  installed  or  used.   Try
           deleting Windows Group Policy before conversion.

       •   Check  there  is  no  anti-virus or other software which implements Group Policy-like prohibitions on
           installing or using new drivers.

       •   Enable boot debugging and check the <u>viostor.sys</u> driver is being loaded.

       <u>OpenStack</u> <u>and</u> <u>Windows</u> <u>reactivation</u>

       OpenStack does not offer stable device / PCI addresses to guests.  Every time  it  creates  or  starts  a
       guest,  it  regenerates  the  libvirt  XML  for  that  guest  from scratch.  The libvirt XML will have no
       &lt;address&gt; fields.  Libvirt will then assign addresses to devices, in a predictable manner.  Addresses may
       change if any of the following are true:

       •   A new disk or network device has been added or removed from the guest.

       •   The version of OpenStack or (possibly) libvirt has changed.

       Because Windows does not like "hardware" changes of this kind, it may trigger Windows reactivation.

       This can also prevent booting with a 7B error [see previous  section]  if  the  guest  has  group  policy
       containing "Device Installation Restrictions".

       <u>Support</u> <u>for</u> <u>SHA-2</u> <u>certificates</u> <u>in</u> <u>Windows</u> <u>7</u> <u>and</u> <u>Windows</u> <u>Server</u> <u>2008</u> <u>R2</u>

       Later versions of the Windows virtio drivers are signed using SHA-2 certificates (instead of SHA-1).  The
       original  shipping  Windows 7 and Windows Server 2008 R2 did not understand SHA-2 certificates and so the
       Windows virtio drivers will not install properly.

       To     fix     this     you     must      apply      SHA-2      Code      Signing      Support      from:
       https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2015/3033929  before  converting the
       guest.

       For further information see: https://bugzilla.redhat.com/show_bug.cgi?id=1624878

   <b>Networks</b> <b>and</b> <b>bridges</b>
       Guests are usually connected to one or more networks, and when converted to  the  target  hypervisor  you
       usually  want  to reconnect those networks at the destination.  The options <u>--network</u>, <u>--bridge</u> and <u>--mac</u>
       allow you to do that.

       If you are unsure of what networks and bridges are in use on the source hypervisor, then you can  examine
       the  source  metadata  (libvirt  XML,  vCenter  information,  etc.).   Or  you  can run virt-v2v with the
       <u>--print-source</u> option which causes virt-v2v to print out the information it has about the  guest  on  the
       source and then exit.

       In the <u>--print-source</u> output you will see a section showing the guest’s Network Interface Cards (NICs):

        $ virt-v2v [-i ...] --print-source name
        [...]
        NICs:
            Network "default" mac: 52:54:00:d0:cf:0e

       Bridges  are  special  classes  of  network devices which are attached to a named external network on the
       source hypervisor, for example:

        $ virt-v2v [-i ...] --print-source name
        [...]
        NICs:
            Bridge "br0"

       To map a specific source bridge to a target network, for example "br0" on the source  to  "ovirtmgmt"  on
       the target, use:

        virt-v2v [...] --bridge br0:ovirtmgmt

       To map every bridge to a target network, use:

        virt-v2v [...] --bridge ovirtmgmt

       <u>Fine-grained</u> <u>mapping</u> <u>of</u> <u>guest</u> <u>NICs</u>

       The  <u>--mac</u> option gives you more control over the mapping, letting you map single NICs to either networks
       or bridges on the target.  For example a source guest with two NICs could map them  individually  to  two
       networks called "mgmt" and "clientdata" like this:

        $ virt-v2v [...] \
           --mac 52:54:00:d0:cf:0e:network:mgmt \
           --mac 52:54:00:d0:cf:0f:network:clientdata

       Note that virt-v2v does not have the ability to change a guest’s MAC address.  The MAC address is part of
       the  guest  metadata and must remain the same on source and target hypervisors.  Most guests will use the
       MAC address to set up persistent associations  between  NICs  and  internal  names  (like  "eth0"),  with
       firewall settings, or even for other purposes like software licensing.

   <b>Resource</b> <b>requirements</b>
       <u>Network</u>

       The  most  important  resource  for virt-v2v appears to be network bandwidth.  Virt-v2v should be able to
       copy guest data at gigabit ethernet speeds or greater.

       Ensure that the network connections between servers (conversion server, NFS server, vCenter, Xen) are  as
       fast and as low latency as possible.

       <u>Disk</u> <u>space</u>

       Virt-v2v  places  potentially  large  temporary  files  in  $VIRT_V2V_TMPDIR  (usually <u><a href="file:/var/tmp">/var/tmp</a></u>, see also
       "ENVIRONMENT VARIBLES" below).  Using tmpfs is a bad idea.

       For each guest disk, an overlay is stored temporarily.  This stores the changes made  during  conversion,
       and  is used as a cache.  The overlays are not particularly large - tens or low hundreds of megabytes per
       disk is typical.  In addition to the overlay(s), input and output methods may use disk space, as outlined
       in the table below.

       <u>-i</u> <u>ova</u>
           This temporarily places a full  copy  of  the  uncompressed  source  disks  in  $VIRT_V2V_TMPDIR  (or
           <u><a href="file:/var/tmp">/var/tmp</a></u>).

       <u>-o</u> <u>glance</u>
           This temporarily places a full copy of the output disks in $VIRT_V2V_TMPDIR (or <u><a href="file:/var/tmp">/var/tmp</a></u>).

       <u>-o</u> <u>local</u>
       <u>-o</u> <u>qemu</u>
           You must ensure there is sufficient space in the output directory for the converted guest.

       See also "Minimum free space check in the host" below.

       <u>VMware</u> <u>vCenter</u> <u>resources</u>

       Copying  from  VMware  vCenter  is  currently quite slow, but we believe this to be an issue with VMware.
       Ensuring the VMware ESXi hypervisor and vCenter are running on fast hardware with plenty of memory should
       alleviate this.

       <u>Compute</u> <u>power</u> <u>and</u> <u>RAM</u>

       Virt-v2v is not especially compute or RAM intensive.  If you are running many parallel conversions,  then
       you may consider allocating one CPU core and 2 GB of RAM per running instance.

       Virt-v2v can be run in a virtual machine.

       <u>Trimming</u>

       Virt-v2v  attempts  to  optimize  the  speed of conversion by ignoring guest filesystem data which is not
       used.  This would include unused filesystem blocks, blocks containing zeroes, and deleted files.

       To do this, virt-v2v issues a non-destructive <b><a href="../man8/fstrim.8.html">fstrim</a></b>(8) operation.  As this happens to an overlay  placed
       over the guest data, it does <b>not</b> affect the source in any way.

       If  this  fstrim  operation fails, you will see a warning, but virt-v2v will continue anyway.  It may run
       more slowly (in some cases much more slowly), because it is copying the unused parts of the disk.

       Unfortunately support for fstrim is not universal, and  it  also  depends  on  specific  details  of  the
       filesystem,  partition  alignment,  and  backing  storage.   As  an  example,  NTFS filesystems cannot be
       fstrimmed if they occupy a partition which is not aligned  to  the  underlying  storage.   That  was  the
       default  on  Windows  before Vista.  As another example, VFAT filesystems (used by UEFI guests) cannot be
       trimmed at all.

       fstrim support in the Linux kernel is improving gradually, so over time some of these  restrictions  will
       be lifted and virt-v2v will work faster.

   <b>Post-conversion</b> <b>tasks</b>
       <u>Guest</u> <u>network</u> <u>configuration</u>

       Virt-v2v  cannot  currently  reconfigure  a guest’s network configuration.  If the converted guest is not
       connected to the same subnet as the source, its network configuration may have to be updated.   See  also
       <b><a href="../man1/virt-customize.1.html">virt-customize</a></b>(1).

       <u>Converting</u> <u>a</u> <u>Windows</u> <u>guest</u>

       When converting a Windows guests, the conversion process is split into two stages:

       1.  Offline conversion.

       2.  First boot.

       The  guest  will  be  bootable  after  the  offline conversion stage, but will not yet have all necessary
       drivers installed to work correctly.  These will be installed automatically  the  first  time  the  guest
       boots.

       <b>N.B.</b> Windows may reboot 4 or more times the first time after conversion.  This is required to install the
       required  drivers,  guest  agents,  remove  VMware  Tools,  and  configure the network.  Take care not to
       interrupt the automatic driver installation process when logging in to the guest for the first  time,  as
       this may prevent the guest from subsequently booting correctly.

       <u>Removing</u> <u>VMware</u> <u>Tools</u> <u>from</u> <u>Windows</u> <u>guests</u>

       Virt-v2v attempts to remove VMware Tools.  For Windows guests this is supposed to happen during the first
       boot after conversion.

       We  use  VMware's  recommended uninstallation method as that is the safest choice.  If this fails, VMware
       Tools must be manually removed by some other method.

       One possible method is described here:  https://gist.github.com/broestls/f872872a00acee2fca02017160840624
       You  should  carefully check this script since it makes very invasive changes to the Windows Registry and
       filesystem.

   <b>Free</b> <b>space</b> <b>for</b> <b>conversion</b>
       <u>Free</u> <u>space</u> <u>in</u> <u>the</u> <u>guest</u>

       Virt-v2v checks there is sufficient free space  in  the  guest  filesystem  to  perform  the  conversion.
       Currently it checks:

       Linux root filesystem
           Minimum free space: 100 MB

       Linux <u><a href="file:/boot">/boot</a></u>
           Minimum free space: 50 MB

           This is because we need to build a new initramfs for some Enterprise Linux conversions.

       Windows "C:" drive
           Minimum free space: 100 MB

           We may have to copy in many virtio drivers and guest agents.

       Any other mountable filesystem
           Minimum free space: 10 MB

       In addition to the actual free space, each filesystem is required to have at least 100 available inodes.

       <u>Minimum</u> <u>free</u> <u>space</u> <u>check</u> <u>in</u> <u>the</u> <u>host</u>

       You  must  have  sufficient  free space in the host directory used to store large temporary overlays.  To
       find out which directory this is, use:

        $ df -h "`guestfish get-cachedir`"
        Filesystem        Size  Used Avail Use% Mounted on
        /dev/mapper/root   50G   40G  6.8G  86% /

       and look under the "Avail" column.  Virt-v2v will refuse to do the conversion at all unless at least  1GB
       is available there.  You can change the directory that virt-v2v uses by setting $VIRT_V2V_TMPDIR.

       See also "Resource requirements" above and "ENVIRONMENT VARIABLES" below.

   <b>Running</b> <b>virt-v2v</b> <b>as</b> <b>root</b> <b>or</b> <b>non-root</b>
       Nothing in virt-v2v inherently needs root access, and it will run just fine as a non-root user.  However,
       certain external features may require either root or a special user:

       Mounting the Export Storage Domain
           When  using <u>-o</u> <u>rhv</u> <u>-os</u> <u>server:/esd</u> virt-v2v has to have sufficient privileges to NFS mount the Export
           Storage Domain from "server".

           You can avoid needing root here by mounting it yourself before  running  virt-v2v,  and  passing  <u>-os</u>
           <u>/mountpoint</u> instead, but first of all read the next section ...

       Writing to the Export Storage Domain as 36:36
           RHV-M  cannot  read  files  and  directories  from the Export Storage Domain unless they have UID:GID
           36:36.  You will see VM import problems if the UID:GID is not correct.

           When you run virt-v2v <u>-o</u> <u>rhv</u> as root, virt-v2v attempts to create  files  and  directories  with  the
           correct  ownership.   If you run virt-v2v as non-root, it will probably still work, but you will need
           to manually change ownership after virt-v2v has finished.

       Writing to libvirt
           When using <u>-o</u> <u>libvirt</u>, you may need to run virt-v2v as root so that  it  can  write  to  the  libvirt
           system  instance  (ie.  "qemu:///system")  and  to  the  default  location  for  disk images (usually
           <u>/var/lib/libvirt/images</u>).

           You can avoid this by setting up libvirt connection authentication, see <a href="http://libvirt.org/auth.html">http://libvirt.org/auth.html</a>.
           Alternatively, use <u>-oc</u> <u>qemu:///session</u>, which will write to your per-user libvirt instance.

           See also "Starting the libvirt system instance".

       Writing to Openstack
           Because of how Cinder volumes are presented as  <u><a href="file:/dev">/dev</a></u>  block  devices,  using  <u>-o</u>  <u>openstack</u>  normally
           requires that virt-v2v is run as root.

       Writing to Glance
           This  does  <u>not</u>  need  root  (in  fact it probably won’t work), but may require either a special user
           and/or for you to source a script that sets authentication environment variables.  Consult the Glance
           documentation.

       Writing to block devices
           This normally requires root.  See the next section.

   <b>Writing</b> <b>to</b> <b>block</b> <b>devices</b>
       Some output modes write to local files.  In general these modes also let you write to block devices,  but
       before  you  run  virt-v2v you may have to arrange for symbolic links to the desired block devices in the
       output directory.

       For example if using <u>-o</u> <u>local</u> <u>-os</u> <u>/dir</u> then virt-v2v would normally create files called:

        /dir/name-sda     # first disk
        /dir/name-sdb     # second disk
        ...
        /dir/name.xml     # metadata

       If you wish the disks to be written to block devices then you would need to create <u>/dir/name-sda</u> (etc) as
       symlinks to the block devices:

        # lvcreate -L 10G -n VolumeForDiskA VG
        # lvcreate -L 6G -n VolumeForDiskB VG
        # ln -sf /dev/VG/VolumeForDiskA /dir/name-sda
        # ln -sf /dev/VG/VolumeForDiskB /dir/name-sdb

       Note that you must precreate the correct number of block devices of the correct size.  Typically <u>-of</u>  <u>raw</u>
       has to be used too, but other formats such as qcow2 can be useful occasionally so virt-v2v does not force
       you to use raw on block devices.

   <b>Minimal</b> <b>XML</b> <b>for</b> <b>-i</b> <b>libvirtxml</b> <b>option</b>
       When  using  the <u>-i</u> <u>libvirtxml</u> option, you have to supply some libvirt XML.  Writing this from scratch is
       hard, so the template below is helpful.

       <b>Note</b> <b>this</b> <b>should</b> <b>only</b> <b>be</b> <b>used</b> <b>for</b> <b>testing</b> <b>and/or</b> <b>where</b> <b>you</b> <b>know</b> <b>what</b> <b>you're</b> <b>doing!</b>  If you  have  libvirt
       metadata for the guest, always use that instead.

        &lt;domain type='kvm'&gt;
          &lt;name&gt; NAME &lt;/name&gt;
          &lt;memory&gt;1048576&lt;/memory&gt;
          &lt;vcpu&gt;2&lt;/vcpu&gt;
          &lt;os&gt;
            &lt;type&gt;hvm&lt;/type&gt;
            &lt;boot dev='hd'/&gt;
          &lt;/os&gt;
          &lt;features&gt;
            &lt;acpi/&gt;
            &lt;apic/&gt;
            &lt;pae/&gt;
          &lt;/features&gt;
          &lt;devices&gt;
            &lt;disk type='file' device='disk'&gt;
              &lt;driver name='qemu' type='raw'/&gt;
              &lt;source file='/path/to/disk/image'/&gt;
              &lt;target dev='hda' bus='ide'/&gt;
            &lt;/disk&gt;
            &lt;interface type='network'&gt;
              &lt;mac address='52:54:00:01:02:03'/&gt;
              &lt;source network='default'/&gt;
              &lt;model type='rtl8139'/&gt;
            &lt;/interface&gt;
          &lt;/devices&gt;
        &lt;/domain&gt;

   <b>Machine</b> <b>readable</b> <b>output</b>
       The  <u>--machine-readable</u> option can be used to make the output more machine friendly, which is useful when
       calling virt-v2v from other programs, GUIs etc.

       There are two ways to use this option.

       Firstly use the option on its own to query the capabilities of the virt-v2v binary.  Typical output looks
       like this:

        $ virt-v2v --machine-readable
        virt-v2v
        libguestfs-rewrite
        colours-option
        vdsm-compat-option
        input:disk
        [...]
        output:local
        [...]
        convert:linux
        convert:windows

       A list of features is printed, one per line, and the program exits with status 0.

       The "input:" and "output:" features refer to <u>-i</u> and <u>-o</u> (input and output mode) options supported by  this
       binary.  The "convert:" features refer to guest types that this binary knows how to convert.

       Secondly use the option in conjunction with other options to make the regular program output more machine
       friendly.

       At the moment this means:

       1.  Progress bar messages can be parsed from stdout by looking for this regular expression:

            ^[0-9]+/[0-9]+$

       2.  The calling program should treat messages sent to stdout (except for progress bar messages) as status
           messages.  They can be logged and/or displayed to the user.

       3.  The  calling  program  should treat messages sent to stderr as error messages.  In addition, virt-v2v
           exits with a non-zero status code if there was a fatal error.

       Virt-v2v ≤ 0.9.1 did not support the <u>--machine-readable</u>  option  at  all.   The  option  was  added  when
       virt-v2v was rewritten in 2014.

       It  is  possible  to  specify  a format string for controlling the output; see "ADVANCED MACHINE READABLE
       OUTPUT" in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

   <b>Starting</b> <b>the</b> <b>libvirt</b> <b>system</b> <b>instance</b>
        Failed to connect socket to '/var/run/libvirt/virtqemud-sock': No such file or directory
        Failed to connect socket to '/var/run/libvirt/virtqemud-sock-ro': Connection refused

       If you have just installed libvirt and virt-v2v, then you may see the errors above.  This  is  caused  by
       libvirt  daemons that provide various services not running straight after installation.  (This may depend
       on your distribution and vendor presets).

       To fix this on systemd-based distributions, do:

        systemctl isolate multi-user.target

       See also https://bugzilla.redhat.com/2182024.

</pre><h4><b>FILES</b></h4><pre>
       <u>/usr/share/virtio-win</u>
           (Optional)

           If this directory is present, then virtio  drivers  for  Windows  guests  will  be  found  from  this
           directory and installed in the guest during conversion.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       "VIRT_V2V_TMPDIR"
       "LIBGUESTFS_CACHEDIR"
           Location  of  the  temporary  directory  used  for  the potentially large temporary overlay file.  If
           neither environment variable is set then <u><a href="file:/var/tmp">/var/tmp</a></u> is used.

           To reliably ensure large temporary files are cleaned up (for example in case  virt-v2v  crashes)  you
           should  create  a  randomly  named  directory  under <u><a href="file:/var/tmp">/var/tmp</a></u>, set "VIRT_V2V_TMPDIR" to point to this
           directory, then when virt-v2v exits remove the directory.

           See the "Disk space" section above.

       "VIRT_TOOLS_DATA_DIR"
           This can point to the directory containing data files used for Windows conversion.

           Normally you do not need to set this.  If not set, a compiled-in default will be used (something like
           <u>/usr/share/virt-tools</u>).

           This directory may contain the following files:

           <u>rhsrvany.exe</u>
               (Required when doing conversions of Windows guests)

               This is the RHSrvAny Windows binary, used to install a "firstboot" script  in  the  guest  during
               conversion of Windows guests.

               See also: "https://github.com/rwmjones/rhsrvany"

           <u>pnp_wait.exe</u>
               (Recommended when doing conversions of Windows guests)

               This  tool  waits  for  newly  installed  Windows  devices  to  become available before trying to
               configure them, for example to set network configuration.  It is part of the RHSrvAny project.

           <u>pvvxsvc.exe</u>
               This is a Windows binary shipped with SUSE VMDP, used to install a "firstboot" script in  Windows
               guests.  It is an alternative to RHSrvAny.

       "VIRTIO_WIN"
           This  is an override for where virtio drivers for Windows are searched for.  It can be a directory <u>or</u>
           point to <u>virtio-win.iso</u> (CD ROM image containing drivers).

           If unset, then we look for drivers via whichever of these methods succeeds first:

           "osinfo-db"
               Load osinfo data from the default paths, and attempt to find drivers via libosinfo lookup.   This
               is the preferred method.

           <u>/usr/share/virtio-win/virtio-win.iso</u>
               The ISO containing virtio drivers for Windows.

           <u>/usr/share/virtio-win</u>
               The  exploded  tree  of  virtio drivers for Windows.  This is usually incomplete, hence the least
               preferred method.

           See "Enabling virtio".

       For other environment variables, see "ENVIRONMENT VARIABLES" in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

</pre><h4><b>OTHER</b> <b>TOOLS</b></h4><pre>
       <b><a href="../man8/engine-image-uploader.8.html">engine-image-uploader</a></b>(8)
           Variously called "engine-image-uploader", "ovirt-image-uploader" or "rhevm-image-uploader", this tool
           allows you to copy a guest from one oVirt or RHV Export Storage Domain to another.  It  only  permits
           importing a guest that was previously exported from another oVirt/RHV instance.

       import-to-ovirt.pl
           This  script  can  be  used  to  import  guests  that  already  run on KVM to oVirt or RHV.  For more
           information, see this blog posting by the author of virt-v2v:

           https://rwmj.wordpress.com/2015/09/18/importing-kvm-guests-to-ovirt-or-rhev/#content

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/virt-p2v.1.html">virt-p2v</a></b>(1),     <b><a href="../man1/virt-v2v-inspector.1.html">virt-v2v-inspector</a></b>(1),     <b><a href="../man1/virt-v2v-in-place.1.html">virt-v2v-in-place</a></b>(1),     <b><a href="../man1/virt-customize.1.html">virt-customize</a></b>(1),      <b><a href="../man1/virt-df.1.html">virt-df</a></b>(1),
       <b><a href="../man1/virt-filesystems.1.html">virt-filesystems</a></b>(1),    <b><a href="../man1/virt-sparsify.1.html">virt-sparsify</a></b>(1),   <b><a href="../man1/virt-sysprep.1.html">virt-sysprep</a></b>(1),   <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3),   <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1),   <b><a href="../man1/qemu-img.1.html">qemu-img</a></b>(1),
       <b><a href="../man8/engine-image-uploader.8.html">engine-image-uploader</a></b>(8), import-to-ovirt.pl, <b><a href="../man1/nbdkit.1.html">nbdkit</a></b>(1), <b><a href="../man1/nbdkit-vddk-plugin.1.html">nbdkit-vddk-plugin</a></b>(1), <a href="http://libguestfs.org/">http://libguestfs.org/</a>.

</pre><h4><b>AUTHORS</b></h4><pre>
       Matthew Booth

       Cédric Bosdonnat

       Laszlo Ersek

       Tomáš Golembiovský

       Shahar Havivi

       Richard W.M. Jones

       Roman Kagan

       Mike Latimer

       Nir Soffer

       Pino Toscano

       Xiaodai Wang

       Ming Xie

       Tingting Zheng

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2009-2024 Red Hat Inc.

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you can redistribute it and/or modify  it  under  the  terms  of  the  GNU
       General  Public License as published by the Free Software Foundation; either version 2 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
       License for more details.

       You should have received a copy of the GNU General Public License along with this program; if not,  write
       to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

</pre><h4><b>BUGS</b></h4><pre>
       To      get      a      list      of      bugs      against      libguestfs,      use      this     link:
       https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools

       To      report      a      new       bug       against       libguestfs,       use       this       link:
       https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools

       When reporting a bug, please supply:

       •   The version of libguestfs.

       •   Where you got libguestfs (eg. which Linux distro, compiled from source, etc)

       •   Describe the bug accurately and give a way to reproduce it.

       •   Run <b><a href="../man1/libguestfs-test-tool.1.html">libguestfs-test-tool</a></b>(1) and paste the <b>complete,</b> <b>unedited</b> output into the bug report.

virt-v2v-2.6.0                                     2024-11-30                                        <u><a href="../man1/virt-v2v.1.html">virt-v2v</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>