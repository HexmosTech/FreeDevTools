<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dfu-programmer - USB firmware upgrading for Atmel microcontrollers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/dfu-programmer">dfu-programmer_0.6.1-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dfu-programmer - USB firmware upgrading for Atmel microcontrollers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>dfu-programmer</b> target[:usb-bus,usb-addr] command [options] [parameters]
       <b>dfu-programmer</b> --help
       <b>dfu-programmer</b> --targets
       <b>dfu-programmer</b> --version

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>dfu-programmer</b>  is  a  multi-platform command line Device Firmware Upgrade (DFU) based programmer for the
       flash memory on Atmel AVR, AVR32, XMEGA and 8051 based  microcontrollers  which  ship  with  a  USB  boot
       loader.   It  supports  In System Programming (ISP) for developers and potentially product updates in the
       field.  Those boot loaders are patterned after the standard USB DFU 1.0 class specification,  but  depend
       on extensions defined by Atmel to the extent that standard DFU drivers will not work.

       To  use  it,  first  connect  the  device  to be programmed and ensure that it comes up in DFU mode.  The
       microcontrollers come up in that mode as shipped by Atmel; or they may reenter that mode after a  special
       hardware  reset.   Then invoke this program to issue one or more DFU commands.  You will normally need to
       start by issuing the "erase" command; the default  security  policies  prevent  extracting  firmware,  to
       prevent reverse engineering of what is usually proprietary code.

</pre><h4><b>SUPPORTED</b> <b>MICROCONTROLLERS</b></h4><pre>
       These chip names are used as the command line "target" parameter.

       8051 based controllers:
              at89c51snd1c, at89c51snd2c, at89c5130, at89c5131, and at89c5132.

       AVR based controllers:
              at90usb1287,  at90usb1286,  at90usb647, at90usb646, at90usb162, at90usb82, atmega32u6, atmega32u4,
              atmega32u2, atmega16u4, atmega16u2 and atmega8u2.

       AVR32 based controllers:
              at32uc3a0128,    at32uc3a1128,    at32uc3a0256,    at32uc3a1256,    at32uc3a0512,    at32uc3a1512,
              at32uc3a0512es,    at32uc3a1512es,   at32uc3a364,   at32uc3a364s,   at32uc3a3128,   at32uc3a3128s,
              at32uc3a3256, at32uc3a3256s, at32uc3a4256s, at32uc3b064, at32uc3b164, at32uc3b0128,  at32uc3b1128,
              at32uc3b0256,    at32uc3b1256,   at32uc3b0256es,   at32uc3b1256es,   at32uc3b1512,   at32uc3b0512,
              at32uc3c064, at32uc3c0128, at32uc3c0256, at32uc3c0512,  at32uc3c164,  at32uc3c1128,  at32uc3c1256,
              at32uc3c1512, at32uc3c264, at32uc3c2128, at32uc3c2256 and at32uc3c2512.

       XMEGA based controllers:
              atxmega64a1u,    atxmega128a1u,   atxmega64a3u,   atxmega128a3u,   atxmega192a3u,   atxmega256a3u,
              atxmega16a4u,   atxmega32a4u,   atxmega64a4u,    atxmega128a4u,    atxmega256a3bu,    atxmega64b1,
              atxmega128b1, atxmega64b3, atxmega128b3, atxmega64c3, atxmega128c3, atxmega256c3, atxmega384c3

</pre><h4><b>USAGE</b></h4><pre>
       There  are no mechanisms to implement gang programming.  By default, the first device that matches the id
       codes for the given target is selected. Many targets share the same  id  codes.   Accordingly,  you  will
       usually avoid connecting more than one device of a given family (AVR, XMEGA, AVR32 or 8051) at a time.

       The  target  may be qualified with the USB bus and address number of the device you wish to program. This
       allows programming multiple devices of the same family at the same time.

       All of these commands support the "global options".  Unless you override it, commands which write to  the
       microcontroller  will  perform  a validation step that rereads the data which was written, compares it to
       the expected result, and reports any errors.

       Note that unlike Atmel's BatchISP program, dfu-programmer will only perform a single operation at a time.
       Erasing and programming require separate commands.

       <b>configure</b> register [--suppress-validation] data
              Bootloaders for 8051 based controllers support writing certain configuration bytes.

       <b>dump</b>
              Reads all the available flash memory, and writes it as binary data to stdout.

       <b>dump-eeprom</b>
              Reads all the available eeprom memory, and writes it as binary data to stdout.

       <b>dump-user</b>
              Reads the user space flash on the AVR32 chips and writes it as binary data to stdout.

       <b>erase</b> [--suppress-validation]
              Erases all the flash memory.  This is required before the bootloader will perform other  commands.

       <b>flash</b> [--suppress-validation] [--suppress-bootloader-mem] [--serial=hexbytes:offset] file or STDIN
              Writes  flash  memory.  The input file (or stdin) must use the "ihex" file format convention for a
              memory image. --suppress-bootloader-mem ignores any data written to the  bootloader  memory  space
              when flashing the device.  This option is particularly useful for the AVR32 chips <b>trampoline</b> code.

       --serial provides a way to inject a serial number or other unique sequence of bytes into the memory image
       programmed  into the device. This allows using a single .ihex file to program multiple devices, and still
       give each device its own unique serial number. For example, --serial=ABCDEF01:0x6000  would  program  the
       byte  at  0x6000 with the hex value AB, the byte at 0x6001 with the value CD, and so on. There must be an
       even number of hex digits, but the sequence can be any length. The offset is assumed to be given  in  hex
       if it starts with a "0x" prefix, octal if it begins with a "0", otherwise is it assumed to be decimal.

       <b>flash-user</b> [--suppress-validation] [--serial=hexbytes:offset] file or STDIN
              Writes  to user space flash on the AVR32 chips.  This block of flash is out of the normal range of
              flash blocks and is designed to contain configuration parameters.  The input file (or stdin)  must
              use the "ihex" file format convention for a memory image.

       <b>flash-eeprom</b> [--suppress-validation] [--serial=hexbytes:offset] file or STDIN
              Writes to eeprom memory.  The input file (or stdin) must use the "ihex" file format convention for
              a memory image.

       <b>setsecure</b>
              Sets  the  security  bit on AVR32 chips.  This prevents the content being read back from the chip,
              except in the same session in which it was programmed.  When the  security  fuse  is  set,  almost
              nothing  will  work without first executing the erase command.  The only way to clear the security
              fuse once set is to use a JTAG chip erase, which will also erase the bootloader.

       <b>get</b> register
              Displays various product identifier bytes.

       <b>reset</b>
              Resets microcontroller using watchdog timer

       <b>start</b>
              Starts the application firmware by having the microcontroller jump to address zero.

   <b>Global</b> <b>Options</b>
       --quiet - minimizes the output

       --debug level - enables verbose output at the specified level

   <b>Configure</b> <b>Registers</b>
       The standard bootloader for 8051 based chips supports writing data bytes which are not relevant  for  the
       AVR based chips.

       BSB - boot status byte
       SBV - software boot vector
       SSB - software security byte
       EB  - extra byte
       HSB - hardware security byte

   <b>Get</b> <b>Register</b>
       bootloader-version - currently flashed bootloader version
       ID1 - device boot identification 1
       ID2 - device boot identification 2
       manufacturer - the hardware manufacturer code
       family - the product family code
       product-name - the product name
       product-revision - the product revision
       HSB - same as the configure_register version
       BSB - same as the configure_register version
       SBV - same as the configure_register version
       SSB - same as the configure_register version
       EB  - same as the configure_register version

</pre><h4><b>BUGS</b></h4><pre>
       None known.

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       The  at90usb series chips do not make available any read/write protect flags so the <b>dump</b> or <b>flash</b> command
       may fail with a less than helpful error message.

       To remove <b>any</b> write or read protection from any chips, a full chip erasure is required.  For AVR32  chips
       an erase operation over USB will remove protection until the device is rebooted. To remove the protection
       more permanently requires a JTAG erase (which will also erase the bootloader).

       You may need to be a member of the <b>uucp</b> group in order to have access to the device without needing to be
       root.

</pre><h4><b>AUTHOR</b></h4><pre>
       Weston Schmidt &lt;<a href="mailto:weston_schmidt@alumni.purdue.edu">weston_schmidt@alumni.purdue.edu</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
</pre>
 </div>
</div></section>
</div>
</body>
</html>