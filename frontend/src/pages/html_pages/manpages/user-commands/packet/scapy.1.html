<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scapy - Interactive packet manipulation tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/python3-scapy">python3-scapy_2.6.1+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       scapy - Interactive packet manipulation tool

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>scapy</b> [<u>options</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This manual page documents briefly the <b>Scapy</b> tool.

       <b>Scapy</b>  is  a  powerful  interactive  packet manipulation tool, packet generator, network scanner, network
       discovery, packet sniffer, etc. It can for the moment replace hping, parts  of  nmap,  arpspoof,  arp-sk,
       arping, tcpdump, tshark, p0f, ...

       <b>Scapy</b>  uses  the  Python  interpreter  as  a  command  board. That means that you can use directly Python
       language (assign variables, use loops, define functions, etc.) If you give a file a  parameter  when  you
       run  <b>Scapy</b>,  your  session  (variables,  functions,  instances,  ...)  will  be  saved when you leave the
       interpreter and restored the next time you launch <b>Scapy</b>.

       The idea is simple. Those kinds of tools do two things : sending packets and  receiving  answers.  That's
       what  <b>Scapy</b>  does  :  you define a set of packets, it sends them, receives answers, matches requests with
       answers and returns a list of packet couples (request, answer) and a list of unmatched packets. This  has
       the  big advantage over tools like nmap or hping that an answer is not reduced to (open/closed/filtered),
       but is the whole packet.

       On top of this can be used to build more high-level functions, for example, one that does traceroutes and
       give as a result only the start TTL of the request and the source IP of the  answer.  One  that  pings  a
       whole  network  and  gives  the  list of machines answering. One that does a portscan and returns a LaTeX
       report.

</pre><h4><b>OPTIONS</b></h4><pre>
       Options for Scapy are:

       <b>-h</b>     display usage

       <b>-H</b>     header-less mode, also reduces verbosity.

       <b>-d</b>     increase log verbosity. Can be used many times.

       <b>-s</b> FILE
              use FILE to save/load session values (variables, functions, instances, ...)

       <b>-p</b> PRESTART_FILE
              use PRESTART_FILE instead of $HOME/.config/scapy/prestart.py as pre-startup file

       <b>-P</b>     do not run prestart file

       <b>-c</b> STARTUP_FILE
              use STARTUP_FILE instead of $HOME/.config/scapy/startup.py as startup file

       <b>-C</b>     do not run startup file

</pre><h4><b>COMMANDS</b></h4><pre>
       Only the vital commands to begin are listed here for the moment.

       <b>ls()</b>   lists supported protocol layers.  If a protocol layer is given as parameter, lists its fields  and
              types of fields.  If a string is given as parameter, it is used to filter the layers.

       <b>lsc()</b>  lists scapy's main user commands.

       <b>conf</b>   this object contains the configuration.

</pre><h4><b>FILES</b></h4><pre>
       <b>$HOME/.config/scapy/prestart.py</b>  This  file  is  run before Scapy core is loaded. Only the <b>conf</b> object is
       available. This file can be used to configure the CLI, configure parameters such as the  <b>conf.load_layers</b>
       list to choose which layers will be loaded, or change the logging level (for instance):

       conf.interactive_shell = "bpython"
       log_loading.setLevel(logging.WARNING)
       conf.load_layers.remove("bluetooth")
       conf.load_layers.append("new_layer")

       <b>$HOME/.config/scapy/startup.py</b>  This  file is run after Scapy is loaded. It can be used to configure more
       of Scapy behaviors, like un-registering layers:

       conf.prog.pdfreader = "xpdf"
       split_layers(UDP,DNS)

</pre><h4><b>EXAMPLES</b></h4><pre>
       More verbose examples are available in the  documentation  at  <u>https://scapy.readthedocs.io/</u>.   Just  run
       <b>scapy</b> and try the following commands in the interpreter.

       Test the robustness of a network stack with invalid packets:
       sr(IP(dst="172.16.1.1", ihl=2, options=["verb$2"], version=3)/ICMP(), timeout=2)

       Packet sniffing and dissection (with a bpf filter or tshark-like output):
       a=sniff(filter="tcp port 110")
       a=sniff(prn = lambda x: x.show)

       Sniffed packet re-emission:
       a=sniff(filter="tcp port 110")
       sendp(a)

       Pcap file packet re-emission:
       sendp(rdpcap("file.cap"))

       Manual TCP traceroute:
       sr(IP(dst="www.google.com", ttl=(1,30))/TCP(seq=RandInt(), sport=RandShort(), dport=dport)

       Protocol scan:
       sr(IP(dst="172.16.1.28", proto=(1,254)))

       ARP ping:
       srp(Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst="172.16.1.1/24"))

       ACK scan:
       sr(IP(dst="172.16.1.28")/TCP(dport=(1,1024), flags="A"))

       Passive OS fingerprinting:
       sniff(prn=prnp0f)

       Active OS fingerprinting:
       nmap_fp("172.16.1.232")

       ARP cache poisoning:
       sendp(Ether(dst=tmac)/ARP(op="who-has", psrc=victim, pdst=target))

       Reporting:
       report_ports("192.168.2.34", (20,30))

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The official website: <u>https://scapy.net/</u>
       The GitHub Development repository: <u>https://github.com/secdev/scapy/</u>
       The official documentation: <u>https://scapy.readthedocs.io/en/latest/</u>

</pre><h4><b>BUGS</b></h4><pre>
       Does not give the right source IP for routes that use interface aliases.

       May miss packets under heavy load. This is a restriction from python itself

       Session  saving  is  limited by Python ability to marshal objects. As a consequence, lambda functions and
       generators can't be saved, which seriously reduce the usefulness of this feature.

       BPF filters don't work on Point-to-point interfaces.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philippe Biondi and the Scapy community.

                                                 March 24, 2024                                         <u><a href="../man1/SCAPY.1.html">SCAPY</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>