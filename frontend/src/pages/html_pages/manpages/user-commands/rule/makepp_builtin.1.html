<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>makepp_builtin -- Built in rules for makepp</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/makepp">makepp_2.0.98.5-2.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       makepp_builtin -- Built in rules for makepp

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Makepp may be able to figure out how to compile and link your program even if you specify no rules at all
       (or if you don't even have a Makeppfile).  After every Makeppfile is loaded, makepp also loads a set of
       default rules.  (These rules are special in that they do not override any other rules in the Makeppfile.)
       The default rule database is stored in the file "makepp_builtin_rules.mk" in the makepp distribution or
       library directory, so you can always look at that to see exactly what the default rules are.

       Makepp's builtin rules are almost the same as the rules in GNU make, except that it has no rules for some
       of the rare languages that GNU make has rules for.  (This is deliberate; I often ran into trouble with
       GNU make on several projects that accidentally reused some of the suffixes that GNU make assigned to
       those rare languages.)  The rules use the same variables as GNU make, with some possibly useful
       additions.  Makepp is smarter than GNU make about inferring which compiler to use, and which other
       objects and libraries to link in.

   <b>Default</b> <b>variable</b> <b>values</b>
       Makepp supplies default values for a number of variables.  Most of these are typically used in rules, and
       are indeed used in the default rules.  Their values can be overridden by assigning to these variables in
       your Makeppfile or on the command line.

       These variables are documented in "Predefined Variables" in makepp_variables.  If you have any questions
       about what any variable evaluates to, you can always put a line like either of these lines in your
       Makeppfile:

           dummy := $(print $(CC))
           &amp;echo -- $(CC)              # Must be indented less than previous rule.

       which simply prints the value of the "$(CC)" variable when the Makeppfile is loaded.  (Incidentally, this
       is a useful way to debug any expression that you're not sure is right.)

   <b>Compilation</b> <b>rules</b>
       In simplified form, here is approximately what the compilation rules look like.  If you change the values
       of any of the indicated variables, the compilation command is changed as expected.

           #
           # For C programs:
           #
           %.o: %.c
               $(CC) $(CFLAGS) $(CPPFLAGS) -c $(input) -o $(output)

           #
           # For C++ programs:
           #
           %.o: %.cxx # and also %.cc, %.cpp, %.c++, and %.C
               $(CXX) $(CXXFLAGS) $(CPPFLAGS) -c $(input) -o $(output)

           #
           # For Fortran programs:
           #
           %.o: %.f
               $(FC) $(FFLAGS) -c $(input) -o $(output)

           #
           # Yacc and lex:
           #
           %.c: %.y
               $(YACC) $(YFLAGS) $(input)
               &amp;mv -f y.tab.c $(output)

           %.c: %.l
               $(LEX) $(LFLAGS) -t $(input) -o $(output)

       If you're curious about the exact details, you can look in the file <u>makepp_builtin_rules.mk</u> in the makepp
       distribution.

   <b>Link</b> <b>rules</b>
       Makepp also knows how to link programs, too.  Makepp attempts to be more clever than the standard Unix
       make when it comes to figuring out a link command.  Suppose you are trying to build the target program
       "xyz".  Makepp will try to build this from "xyz.o", and (unlike the standard Unix make) it will also
       attempt to infer whether any other objects or libraries need to be linked in.

       The link rule looks something like this:

           xyz: $(infer_objects xyz.o, *.o)
               $(infer_linker $(inputs)) $(inputs) $(LDFLAGS) $(LDLIBS) $(LIBS) -o $(output)

       "$(infer_objects)" attempts to infer what other ".o" files need to be linked in based on what ".h" files
       are included.

       The "inferred linker" is a special bit of magic that turns into "$(CC)" if all the sources are C code,
       "$(CXX)" if any of the sources are C++, or "$(F77)" if any of the sources are Fortran.

   <b>Turning</b> <b>off</b> <b>the</b> <b>built-in</b> <b>rules</b>
       If you don't like the built-in rules, don't use them.  If they don't work for you, your built is probably
       sufficiently complicated that you need your own custom Makeppfile anyway.

       To turn off the builtin rules, you can add a line like this to your Makeppfile:

           makepp_no_builtin = 1

       If you do use them, but not the fairly expensive builtin linker rules, you can turn those off with:

           makepp_no_builtin_linker = 1

       For backward compatibility, makepp also turns off its default rules if you include this line somewhere in
       your Makeppfile:

           .SUFFIXES:

       You can turn off builtin rules for every Makeppfile in the entire build by specifying the
       "--no-builtin-rules" option on the command line.

perl v5.32.0                                       2021-01-06                                  <u><a href="../man1/MAKEPP_BUILTIN.1.html">MAKEPP_BUILTIN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>