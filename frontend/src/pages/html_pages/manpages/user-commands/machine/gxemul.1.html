<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gxemul — an experimental framework for full-system machine emulation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/gxemul">gxemul_0.7.0+dfsg-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gxemul — an experimental framework for full-system machine emulation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>gxemul</b> [machine, other, and general options] [file <u>...</u>]
       <b>gxemul</b> [general options] <u>@configfile</u>
       <b>gxemul</b> <b>-H</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>gxemul</b>  is  a framework for full-system computer architecture emulation.  Several processor architectures
       and machine types have been implemented.  It is working well enough to allow unmodified "guest" operating
       systems (e.g. NetBSD) to run inside the emulator, as if they were running on real hardware.

       The emulator emulates (networks of) real machines. The machines may consist of ARM, MIPS,  Motorola  88K,
       PowerPC, and SuperH processors, and various surrounding hardware components such as framebuffers, busses,
       interrupt controllers, ethernet controllers, disk controllers, and serial port controllers.

</pre><h4><b>RUNNING</b> <b>GUEST</b> <b>OPERATING</b> <b>SYSTEMS</b></h4><pre>
       Please read the HTML documentation for more details on how to run specific guest operating systems in the
       emulator.

</pre><h4><b>RUNNING</b> <b>THE</b> <b>EMULATOR</b></h4><pre>
       The emulator can be invoked in the following ways:

       1. When emulating a complete machine, configuration options can be supplied directly on the command line.

       2. Options can be read from a configuration file.

       The easiest way to use the emulator is to supply settings directly on the command line.

       The  most  important thing you need to supply is the file argument. This is the name of a binary file (an
       ELF, a.out, COFF/ECOFF, SREC, or a raw binary image) which you wish to run in  the  emulator.  This  file
       might be an operating system kernel, or perhaps a ROM image file.  If more than one filename is supplied,
       all files are loaded into memory, and the entry point (if available) is taken from the last file.

       Apart  from  the  name  of  a  binary  file,  you  must also use the <b>-E</b> and/or <b>-e</b> options to select which
       emulation mode to use. This is necessary because the emulator cannot in general deduce this from the file
       being executed.  For example, a MIPS-based machine from DEC (a DECstation) is very different from a MIPS-
       based machine from SGI. Use <b>gxemul</b> <b>-H</b> to get a list of available emulation modes.

       There are three exceptions to the normal invocation usage mentioned above.

       1. For DECstation emulation, if you have a  bootable  DECstation  harddisk  or  CDROM  image,  then  just
       supplying  the diskimage via the <b>-d</b> option is sufficient. The filename of the kernel can then be skipped,
       as the emulator runs the bootblocks from the diskimage directly and doesn't need the kernel as a separate
       file.

       2. If you supply an ISO9660 CDROM disk image, then using the <b>-j</b> option to indicate a file  on  the  CDROM
       filesystem to load is sufficient; no additional kernel filename needs to be supplied on the command line.

       3.  For Dreamcast emulation, when booting e.g. a NetBSD/dreamcast CDROM image, it is enough to supply the
       disk image (with the correct ISO partition start offset). Bootblocks will be read directly from the CDROM
       image, and there is no need to supply the name of an external kernel on the command line.

       Gzipped kernels are automatically unzipped, by calling the external gunzip program, both when  specifying
       a gzipped file directly on the command line and when loading such a file using the <b>-j</b> option.

       Machine selection options:

       <b>-E</b> <u>t</u>    Try  to  emulate  machine  type  <u>t</u>.   This option is not always needed, if the <b>-e</b> option uniquely
               selects a machine.  (Use <b>-H</b> to get a list of types.)

       <b>-e</b> <u>st</u>   Try to emulate machine subtype <u>st</u>.  Use this together  with  <b>-E</b>.   (This  option  is  not  always
               needed, if a machine type has no subtypes.)

       Other options:

       <b>-C</b> <u>x</u>    Try to emulate a specific CPU type, <u>x</u>.  This overrides the default CPU type for the machine being
               emulated.  (Use <b>-H</b> to get a list of available CPU types.)

       <b>-d</b> <u>[modifiers:]filename</u>
               Add <u>filename</u> as a disk image. By adding one or more modifier characters and then a colon (":") as
               a prefix to <u>filename,</u> you can modify the way the disk image is treated. Available modifiers are:

               b       Specifies that this is a boot device.

               c       CD-ROM.

               d       DISK (this is the default).

               f       FLOPPY.

               gH;S;   Override  the  default  geometry;  use  H  heads and S sectors-per-track.  (The number of
                       cylinders is calculated automatically.)

               i       IDE.

               oOFS;   Set the base offset for an ISO9660 filesystem on a  disk  image.  The  default  is  0.  A
                       suitable  offset  when booting from Dreamcast ISO9660 filesystem images, which are offset
                       by 11702 sectors, is 23965696.

               r       Read-only (don't allow changes to be written to the file).

               R       Don't allow changes to the file, but add a temporary overlay for the disk image to  allow
                       guest  operating  systems  to write to the disk.  (These changes are lost when the GXemul
                       process exits.)

               s       SCSI.

               t       Tape.

               V       Add an overlay filename to an already defined disk image.  (A  ID  number  must  also  be
                       specified  when  this  flag  is  used. See the documentation for an example of how to use
                       overlays.)

               0-7     Force a specific ID number.

               For SCSI devices, the ID number is the SCSI  ID.  For  IDE  harddisks,  the  ID  number  has  the
               following meaning:

               0       Primary master.

               1       Primary slave.

               2       Secondary master.

               3       Secondary slave.

               Unless  otherwise  specified,  filenames  ending  with  ".iso"  or ".cdr" are assumed to be CDROM
               images. Most others are assumed to be disks. Depending on which machine is  being  emulated,  the
               default  for disks can be either SCSI or IDE. Some disk images that are very small are assumed to
               be floppy disks. (If you are not happy with the way a disk image is detected, then  you  need  to
               use explicit prefixes to force a specific type.)

               For floppies, the gH;S; prefix is ignored. Instead, the number of heads and cylinders are assumed
               to  be  2  and 80, respectively, and the number of sectors per track is calculated automatically.
               (This works for 720KB, 1.2MB, 1.44MB, and 2.88MB floppies.)

       <b>-I</b> <u>hz</u>   Set the main CPU's frequency to <u>hz</u> Hz. This option does not work for all emulated machine  modes.
               It  affects  the  way  count/compare  interrupts are faked to simulate emulated time = real world
               time. If the guest operating system relies on RTC interrupts instead of count/compare interrupts,
               then this option has no effect.

               Setting the frequency to zero disables automatic synchronization of emulated time vs  real  world
               time, and the count/compare system runs at a fixed rate.

       <b>-i</b>      Enable instruction trace, i.e. display disassembly of each instruction as it is being executed.

       <b>-J</b>      Disable instruction combinations in the dynamic translator.

       <b>-j</b> <u>n</u>    Set  the name of the kernel to <u>n</u>.  When booting from an ISO9660 filesystem, the emulator will try
               to boot using this file. (In some emulation modes, eg. DECstation, this name is passed  along  to
               the boot program. Useful names are "bsd" for OpenBSD/pmax, "vmunix" for Ultrix, or "vmsprite" for
               Sprite.)

       <b>-L</b> <u>tapdev</u>
               Enable tap networking using device 'tapdev', on systems that support it.

       <b>-M</b> <u>m</u>    Emulate  <u>m</u> MBs of physical RAM. This overrides the default amount of RAM for the selected machine
               type.

       <b>-N</b>      Display the number of executed instructions per second on average, at regular intervals.

       <b>-n</b> <u>nr</u>   Set the number of processors in the machine, for SMP experiments.

               Note 1: The emulator allocates quite a lot of virtual memory for per-CPU translation  tables.  On
               64-bit  hosts,  this  is  normally  not a problem. On 32-bit hosts, this can use up all available
               virtual userspace memory. The solution is to either run the emulator on a 64-bit host,  or  limit
               the number of emulated CPUs to a reasonably low number.

               Note  2:  SMP  simulation  is  not  working very well yet; multiple processors are simulated, but
               synchronization between the processors does not map very well to how real-world SMP systems work.

       <b>-O</b>      Force a "netboot" (tftp instead of disk), even when a disk image is present (for DECstation, SGI,
               and ARC emulation).

       <b>-o</b> <u>arg</u>  Set the boot argument (mostly useful for DEC, ARC, or SGI emulation).  Default  <u>arg</u>  for  DEC  is
               "-a", for ARC/SGI it is "-aN", and for CATS it is "-A".

       <b>-p</b> <u>pc</u>   Add  a  breakpoint.  <u>pc</u> can be a symbol, or a numeric value. (Remember to use the "0x" prefix for
               hexadecimal values.)

       <b>-Q</b>      Disable the built-in (software-only) PROM emulation. This option is useful for experimenting with
               running raw ROM images from real machines. The default behaviour of the  emulator  is  to  "fake"
               certain  PROM  calls used by guest operating systems (e.g. NetBSD), so that no real PROM image is
               needed.

       <b>-R</b>      Use a random bootstrap cpu, instead of CPU nr 0. (This option is only  meaningful  together  with
               the <b>-n</b> option.)

       <b>-r</b>      Dump register contents for every executed instruction.

       <b>-S</b>      Initialize  emulated  RAM to random data, instead of zeroes. This option is useful when trying to
               trigger bugs in a program that occur  because  the  program  assumed  that  uninitialized  memory
               contains zeros. (Use with care.)

       <b>-s</b> <u>flags:filename</u>
               Gather  statistics  based  on  the  current  emulated  program  counter  value, while the program
               executes. The statistics is actually just a raw dump of all program counter values  in  sequence,
               suitable for post-analysis with separate tools. Output is appended to <u>filename.</u>

               The <u>flags</u> should include one or more of the following type specifiers:

               v       Virtual. This means that the program counter value is used.

               p       Physical.  This  means that the physical address of where the program is actually running
                       is used.

               i       Instruction call. This type of statistics gathering is  practically  only  useful  during
                       development of the emulator itself. The output is a list of addresses of instruction call
                       functions  (ic-&gt;f),  which after some post-processing can be used as a basis for deciding
                       when to implement instruction combinations.

               The <u>flags</u> may also include the following optional modifiers:

               d       Disabled at startup.

               o       Overwrite the file, instead of appending to it.

               Statistics gathering can be enabled/disabled at runtime by using the "statistics_enabled  =  yes"
               and "statistics_enabled = no" debugger commands.

               When  gathering  instruction  statistics using the <b>-s</b> option, instruction combinations are always
               disabled (i.e. an implicit <b>-J</b> flag is added to the command line).

       <b>-T</b>      Halt if the emulated program attempts to access non-existing memory.

       <b>-t</b>      Show a trace tree of all function calls being made.

       <b>-X</b>      Use X11. This option enables graphical framebuffers.

       <b>-Y</b> <u>n</u>    Scale down framebuffer windows by <u>n</u> x <u>n</u> times. This option is useful when emulating a very  large
               framebuffer,  and the actual display is of lower resolution. If <u>n</u> is negative, then there will be
               no scaledown, but emulation of certain graphic controllers will be scaled up by <u>-n</u> times instead.
               E.g. Using <u>-2</u> with VGA text mode emulation will result in 80x25 character  cells  rendered  in  a
               1280x800 window, instead of the normal resolution of 640x400.

       <b>-Z</b> <u>n</u>    Set  the  number  of graphics cards, for emulating a dual-head or tripple-head environment. (Only
               for DECstation emulation so far.)

       <b>-z</b> <u>disp</u>
               Add <u>disp</u> as an X11 display to use for framebuffers.

       General options:

       <b>-A</b>      Disable colorized output.

       <b>-c</b> <u>cmd</u>  Add <u>cmd</u> as a command to run before starting the simulation. A similar effect can be  achieved  by
               using the <b>-V</b> option, and entering the commands manually.

       <b>-D</b>      Causes  the  emulator  to  skip  a  call  to srandom(). This leads to somewhat more deterministic
               behaviour than running without this option.  However, if the emulated machine has clocks or timer
               interrupt sources, or if user interaction is taking  place  (e.g.  keyboard  input  at  irregular
               intervals), then this option is meaningless.

       <b>-G</b>      Enable  colorized  output.  If the environment variable CLICOLOR is set, then this is the default
               behavior.

       <b>-H</b>      Display a list of available CPU types and machine types.  (Most of these don't work. Please  read
               the  HTML  documentation  included  in  the  <b>gxemul</b>  distribution for details on which modes that
               actually work.)

       <b>-h</b>      Display a list of all available command line options.

       <b>-k</b> <u>n</u>    Set the size of the dyntrans cache (per emulated CPU) to <u>n</u> MB. The default size is 96 MB.

       <b>-K</b>      Show the debugger prompt instead of exiting, when a simulation ends.

       <b>-q</b>      Quiet mode; this suppresses startup messages.

       <b>-V</b>      Start up in the interactive debugger, paused. If this option is used, <b>-q</b> is ignored. This  option
               also sets <b>-K.</b>

       <b>-v</b>      Increase verbosity (show more debug messages). This option can be used multiple times.

       <b>-x</b>      Open  up separate terminal windows for emulated serial ports. The default behaviour is to open up
               new terminals when using configuration files with more than one machine specified, or if  X11  is
               enabled.  When  starting up a simple emulation session with settings directly on the command line
               (or when using configuration files with a single machine specification), and neither <b>-X</b> nor <b>-x</b> is
               used, then all output is confined to the terminal that <b>gxemul</b> started in.  The  default  terminal
               to use is 'xterm', but this can be overriden by the XTERM environment variable.

       Configuration file startup:

       @ <u>configfile</u>
               Start an emulation based on the contents of <u>configfile</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following command will start NetBSD/pmax on an emulated DECstation 5000/200 (3MAX):

             <b>gxemul</b> <b>-e</b> <b>3max</b> <b>-d</b> <b>nbsd_pmax.img</b>

       nbsd_pmax.img should be a raw disk image containing a bootable NetBSD/pmax filesystem.

       The  following  command  will  start  an  emulation  session  based on settings in the configuration file
       "mysession". The -v option tells gxemul to be verbose.

             <b>gxemul</b> <b>-v</b> <b>@mysession</b>

       If you have compiled the small Hello World program mentioned in the <b>gxemul</b> documentation,  the  following
       command will start up an emulated test machine in "paused" mode:

             <b>gxemul</b> <b>-E</b> <b>testmips</b> <b>-V</b> <b>hello_mips</b>

       Paused  mode  means  that  you enter the interactive single-step debugger directly at startup, instead of
       launching the Hello World program.

       The paused mode is also what should be used when running "unknown"  files  for  the  first  time  in  the
       emulator.  E.g. if you have a binary which you think is some kind of MIPS ROM image, then you can try the
       following:

             <b>gxemul</b> <b>-vv</b> <b>-E</b> <b>baremips</b> <b>-V</b> <b>0xbfc00000:image.raw</b>

       You can then use the single-stepping functionality of the built-in debugger to run the code  in  the  ROM
       image,  to  see how it behaves. Based on that, you can deduce what machine type it was actually from (the
       baremips machine is not a real machine), and perhaps try again with another emulation mode.

       In general, however, real ROM images require much more emulation detail than GXemul provides, so they can
       usually not run.

</pre><h4><b>BUGS</b></h4><pre>
       There are many bugs. Some of the known bugs  are  mentioned  in  the  TODO  file  in  the  <b>gxemul</b>  source
       distribution, some are marked as TODO in the source code itself.

       <b>gxemul</b>  is  in  general not cycle-accurate; it does not simulate individual pipe-line stages or penalties
       caused by branch-prediction misses or cache misses, so it cannot be used for accurate simulation  of  any
       actual real-world processor.

       <b>gxemul</b>  is  in general not timing-accurate. Many emulation modes try to make the guest operating system's
       clock run at the same speed as the host clock.  However, the number of instructions  executed  per  clock
       tick can obviously vary, depending on the current CPU load on the host.

       <b>gxemul</b> is in general not guaranteed to be secure; when used as a virtual machine to run untrusted code in
       the  form  of a guest OS, the untrusted code may be able to crash the emulator, or due to bugs, take over
       the host.

</pre><h4><b>AUTHOR</b></h4><pre>
       GXemul is Copyright (C) 2003-2021  Anders Gavare &lt;<a href="mailto:gavare@gmail.com">gavare@gmail.com</a>&gt;

       See <a href="http://gavare.se/gxemul/">http://gavare.se/gxemul/</a> for more information. For other Copyright messages,  see  the  corresponding
       parts of the source code and/or documentation.

Debian                                             MARCH 2021                                          <u><a href="../man1/GXEMUL.1.html">GXEMUL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>