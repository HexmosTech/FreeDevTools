<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fio - flexible I/O tester</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fio">fio_3.38-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fio - flexible I/O tester

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>fio</b> [<u>options</u>] [<u>jobfile</u>]...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>fio</b>  is  a tool that will spawn a number of threads or processes doing a particular type of I/O action as
       specified by the user.  The typical use of fio is to write a job file matching the I/O load one wants  to
       simulate.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--debug</b>=<u>type</u>
              Enable verbose tracing <u>type</u> of various fio actions. May be `all' for all <u>type</u>s or individual types
              separated  by a comma (e.g. `--debug=file,mem' will enable file and memory debugging). `help' will
              list all available tracing options.

       <b>--parse-only</b>
              Parse options only, don't start any I/O.

       <b>--merge-blktrace-only</b>
              Merge blktraces only, don't start any I/O.

       <b>--output</b>=<u>filename</u>
              Write output to <u>filename</u>.

       <b>--output-format</b>=<u>format</u>
              Set the reporting <u>format</u> to `normal',  `terse',  `json',  or  `json+'.  Multiple  formats  can  be
              selected,  separate  by  a comma. `terse' is a CSV based format. `json+' is like `json', except it
              adds a full dump of the latency buckets.

       <b>--bandwidth-log</b>
              Generate aggregate bandwidth logs.

       <b>--minimal</b>
              Print statistics in a terse, semicolon-delimited format.

       <b>--append-terse</b>
              Print statistics  in  selected  mode  AND  terse,  semicolon-delimited  format.   <b>Deprecated</b>,  use
              <b>--output-format</b> instead to select multiple formats.

       <b>--terse-version</b>=<u>version</u>
              Set terse <u>version</u> output format (default `3', or `2', `4', `5').

       <b>--version</b>
              Print version information and exit.

       <b>--help</b> Print a summary of the command line options and exit.

       <b>--cpuclock-test</b>
              Perform test and validation of internal CPU clock.

       <b>--crctest</b>=<u>[test]</u>
              Test  the  speed  of the built-in checksumming functions. If no argument is given, all of them are
              tested. Alternatively, a comma separated list can be passed, in which  case  the  given  ones  are
              tested.

       <b>--cmdhelp</b>=<u>command</u>
              Print help information for <u>command</u>. May be `all' for all commands.

       <b>--enghelp</b>=<u>[ioengine[,command]]</u>
              List  all  commands  defined  by  <u>ioengine</u>,  or  print help for <u>command</u> defined by <u>ioengine</u>. If no
              <u>ioengine</u> is given, list all available ioengines.

       <b>--showcmd</b>
              Convert given <u>jobfile</u>s to a set of command-line options.

       <b>--readonly</b>
              Turn on safety read-only checks, preventing writes and trims. The <b>--readonly</b> option  is  an  extra
              safety guard to prevent users from accidentally starting a write or trim workload when that is not
              desired.      Fio      will      only      modify      the      device      under      test     if
              `rw=write/randwrite/rw/randrw/trim/randtrim/trimwrite' is given. This safety net can be used as an
              extra precaution.

       <b>--eta</b>=<u>when</u>
              Specifies when real-time ETA estimate should be printed. <u>when</u> may be `always', `never' or  `auto'.
              `auto'  is  the  default, it prints ETA when requested if the output is a TTY. `always' disregards
              the output type, and prints ETA when requested. `never' never prints ETA.

       <b>--eta-interval</b>=<u>time</u>
              By default, fio requests client ETA status roughly every second. With this option, the interval is
              configurable. Fio imposes a minimum allowed time to avoid flooding the console, less than 250 msec
              is not supported.

       <b>--eta-newline</b>=<u>time</u>
              Force a new line for every <u>time</u> period passed. When the unit is omitted, the value is  interpreted
              in seconds.

       <b>--status-interval</b>=<u>time</u>
              Force a full status dump of cumulative (from job start) values at <u>time</u> intervals. This option does
              *not*  provide per-period measurements. So values such as bandwidth are running averages. When the
              time unit is omitted, <u>time</u> is interpreted in seconds. Note that using this option with  `--output-
              format=json'  will  yield  output  that  technically  isn't  valid  json, since the output will be
              collated sets of valid json. It will need to be split into valid sets of json after the run.

       <b>--section</b>=<u>name</u>
              Only run specified section <u>name</u> in job file. Multiple sections can be  specified.   The  <b>--section</b>
              option  allows  one  to combine related jobs into one file.  E.g. one job file could define light,
              moderate, and heavy sections. Tell fio to run only the "heavy" section by giving `--section=heavy'
              command line option. One can also specify the "write"  operations  in  one  section  and  "verify"
              operation  in  another  section.  The  <b>--section</b> option only applies to job sections. The reserved
              *global* section is always parsed and used.

       <b>--alloc-size</b>=<u>kb</u>
              Allocate additional internal smalloc pools of size <u>kb</u> in KiB. The  <b>--alloc-size</b>  option  increases
              shared memory set aside for use by fio.  If running large jobs with randommap enabled, fio can run
              out  of  memory.   Smalloc is an internal allocator for shared structures from a fixed size memory
              pool and  can  grow  to  16  pools.  The  pool  size  defaults  to  16MiB.   NOTE:  While  running
              `.fio_smalloc.*' backing store files are visible in `<a href="file:/tmp">/tmp</a>'.

       <b>--warnings-fatal</b>
              All fio parser warnings are fatal, causing fio to exit with an error.

       <b>--max-jobs</b>=<u>nr</u>
              Set the maximum number of threads/processes to support to <u>nr</u>.  NOTE: On Linux, it may be necessary
              to  increase  the  shared-memory  limit  (`<a href="file:/proc/sys/kernel/shmmax">/proc/sys/kernel/shmmax</a>') if fio runs into errors while
              creating jobs.

       <b>--server</b>=<u>args</u>
              Start a backend server, with <u>args</u> specifying what to listen to.  See <b>CLIENT/SERVER</b> section.

       <b>--daemonize</b>=<u>pidfile</u>
              Background a fio server, writing the pid to the given <u>pidfile</u> file.

       <b>--client</b>=<u>hostname</u>
              Instead of running the jobs locally, send and run them on the given <u>hostname</u> or set of  <u>hostname</u>s.
              See <b>CLIENT/SERVER</b> section.

       <b>--remote-config</b>=<u>file</u>
              Tell fio server to load this local <u>file</u>.

       <b>--idle-prof</b>=<u>option</u>
              Report CPU idleness. <u>option</u> is one of the following:

                     <b>calibrate</b>
                            Run unit work calibration only and exit.

                     <b>system</b> Show aggregate system idleness and unit work.

                     <b>percpu</b> As <b>system</b> but also show per CPU idleness.

       <b>--inflate-log</b>=<u>log</u>
              Inflate and output compressed <u>log</u>.

       <b>--trigger-file</b>=<u>file</u>
              Execute trigger command when <u>file</u> exists.

       <b>--trigger-timeout</b>=<u>time</u>
              Execute trigger at this <u>time</u>.

       <b>--trigger</b>=<u>command</u>
              Set this <u>command</u> as local trigger.

       <b>--trigger-remote</b>=<u>command</u>
              Set this <u>command</u> as remote trigger.

       <b>--aux-path</b>=<u>path</u>
              Use  the  directory  specified  by  <u>path</u>  for generated state files instead of the current working
              directory.

</pre><h4><b>JOB</b> <b>FILE</b> <b>FORMAT</b></h4><pre>
       Any parameters following the options will be assumed to be job  files,  unless  they  match  a  job  file
       parameter.  Multiple  job files can be listed and each job file will be regarded as a separate group. Fio
       will <b>stonewall</b> execution between each group.

       Fio accepts one or more job files describing what it is supposed to  do.  The  job  file  format  is  the
       classic  ini  file,  where the names enclosed in [] brackets define the job name. You are free to use any
       ASCII name you want, except *global* which has special meaning. Following the job name is a  sequence  of
       zero  or  more parameters, one per line, that define the behavior of the job. If the first character in a
       line is a ';' or a '#', the entire line is discarded as a comment.

       A *global* section sets defaults for the jobs described in that file.  A  job  may  override  a  *global*
       section  parameter,  and  a job file may even have several *global* sections if so desired. A job is only
       affected by a *global* section residing above it.

       The <b>--cmdhelp</b> option also lists all options. If used with an <u>command</u> argument, <b>--cmdhelp</b> will detail  the
       given <u>command</u>.

       See  the  `examples/' directory for inspiration on how to write job files. Note the copyright and license
       requirements currently apply to `examples/' files.

       Note that the maximum length of a line in the job file is 8192 bytes.

</pre><h4><b>JOB</b> <b>FILE</b> <b>PARAMETERS</b></h4><pre>
       Some parameters take an option of a given type, such as an integer or a string. Anywhere a numeric  value
       is  required,  an  arithmetic expression may be used, provided it is surrounded by parentheses. Supported
       operators are:

              <b>addition</b> <b>(+)</b>

              <b>subtraction</b> <b>(-)</b>

              <b>multiplication</b> <b>(*)</b>

              <b>division</b> <b>(/)</b>

              <b>modulus</b> <b>(%)</b>

              <b>exponentiation</b> <b>(^)</b>

       For time values in expressions, units are microseconds by default. This is different than for time values
       not in expressions (not enclosed in parentheses).

</pre><h4><b>PARAMETER</b> <b>TYPES</b></h4><pre>
       The following parameter types are used.

       <u>str</u>    String. A sequence of alphanumeric characters.

       <u>time</u>   Integer with possible time suffix. Without a unit value is interpreted as seconds unless otherwise
              specified. Accepts a suffix of 'd' for days, 'h' for hours, 'm' for minutes, 's' for seconds, 'ms'
              (or 'msec') for milliseconds and 'us' (or 'usec') for microseconds. For example, use  10m  for  10
              minutes.

       <u>int</u>    Integer. A whole number value, which may contain an integer prefix and an integer suffix.

                     [*integer prefix*] **number** [*integer suffix*]

              The  optional *integer prefix* specifies the number's base. The default is decimal. *0x* specifies
              hexadecimal.

              The optional *integer suffix* specifies the number's units, and includes an optional  unit  prefix
              and  an  optional unit. For quantities of data, the default unit is bytes. For quantities of time,
              the default unit is seconds unless otherwise specified.

              With `kb_base=1000', fio follows international standards for unit prefixes. To specify power-of-10
              decimal values defined in the International System of Units (SI):

                     K means kilo (K) or 1000
                     M means mega (M) or 1000**2
                     G means giga (G) or 1000**3
                     T means tera (T) or 1000**4
                     P means peta (P) or 1000**5

              To specify power-of-2 binary values defined in IEC 80000-13:

                     Ki means kibi (Ki) or 1024
                     Mi means mebi (Mi) or 1024**2
                     Gi means gibi (Gi) or 1024**3
                     Ti means tebi (Ti) or 1024**4
                     Pi means pebi (Pi) or 1024**5

              For Zone Block Device Mode:

                     z means Zone
              With `kb_base=1024' (the default), the unit prefixes are opposite from those specified in  the  SI
              and IEC 80000-13 standards to provide compatibility with old scripts. For example, 4k means 4096.

              For quantities of data, an optional unit of 'B' may be included (e.g., 'kB' is the same as 'k').

              The  *integer  suffix*  is  not case sensitive (e.g., m/mi mean mebi/mega, not milli). 'b' and 'B'
              both mean byte, not bit.

              Examples with `kb_base=1000':

                     4 KiB: 4096, 4096b, 4096B, 4k, 4kb, 4kB, 4K, 4KB
                     1 MiB: 1048576, 1m, 1024k
                     1 MB: 1000000, 1mi, 1000ki
                     1 TiB: 1073741824, 1t, 1024m, 1048576k
                     1 TB: 1000000000, 1ti, 1000mi, 1000000ki

              Examples with `kb_base=1024' (default):

                     4 KiB: 4096, 4096b, 4096B, 4k, 4kb, 4kB, 4K, 4KB
                     1 MiB: 1048576, 1m, 1024k
                     1 MB: 1000000, 1mi, 1000ki
                     1 TiB: 1073741824, 1t, 1024m, 1048576k
                     1 TB: 1000000000, 1ti, 1000mi, 1000000ki

              To specify times (units are not case sensitive):

                     D means days
                     H means hours
                     M mean minutes
                     s or sec means seconds (default)
                     ms or msec means milliseconds
                     us or usec means microseconds

              `z' suffix specifies that the value is measured  in  zones.   Value  is  recalculated  once  block
              device's zone size becomes known.

              If  the  option  accepts  an  upper and lower range, use a colon ':' or minus '-' to separate such
              values. See <u>irange</u> parameter type.  If the lower value specified happens to  be  larger  than  the
              upper value the two values are swapped.

       <u>bool</u>   Boolean. Usually parsed as an integer, however only defined for true and false (1 and 0).

       <u>irange</u> Integer  range with suffix. Allows value range to be given, such as 1024-4096. A colon may also be
              used as the separator, e.g. 1k:4k. If the option allows two sets of ranges, they can be  specified
              with a ',' or '/' delimiter: 1k-4k/8k-32k. Also see <u>int</u> parameter type.

       <u>float_list</u>
              A list of floating point numbers, separated by a ':' character.

</pre><h4><b>JOB</b> <b>PARAMETERS</b></h4><pre>
       With the above in mind, here follows the complete list of fio job parameters.

   <b>Units</b>
       <b>kb_base</b>=<u>int</u>
              Select the interpretation of unit prefixes in input parameters.

                     <b>1000</b>   Inputs comply with IEC 80000-13 and the International System of Units (SI). Use:

                            - power-of-2 values with IEC prefixes (e.g., KiB)
                            - power-of-10 values with SI prefixes (e.g., kB)

                     <b>1024</b>   Compatibility mode (default). To avoid breaking old scripts:

                            - power-of-2 values with SI prefixes
                            - power-of-10 values with IEC prefixes

              See <b>bs</b> for more details on input parameters.

              Outputs always use correct prefixes. Most outputs include both side-by-side, like:

                     bw=2383.3kB/s (2327.4KiB/s)

              If only one value is reported, then kb_base selects the one to use:

                     1000 -- SI prefixes
                     1024 -- IEC prefixes

       <b>unit_base</b>=<u>int</u>
              Base unit for reporting. Allowed values are:

                     <b>0</b>      Use auto-detection (default).

                     <b>8</b>      Byte based.

                     <b>1</b>      Bit based.

   <b>Job</b> <b>description</b>
       <b>name</b>=<u>str</u>
              ASCII  name  of  the  job.  This  may  be  used  to override the name printed by fio for this job.
              Otherwise the job name is used. On the command line this parameter has the special purpose of also
              signaling the start of a new job.

       <b>description</b>=<u>str</u>
              Text description of the job. Doesn't do anything except dump this text description when  this  job
              is run. It's not parsed.

       <b>loops</b>=<u>int</u>
              Run  the  specified  number  of  iterations  of this job. Used to repeat the same workload a given
              number of times. Defaults to 1.

       <b>numjobs</b>=<u>int</u>
              Create the specified number of clones of this job. Each clone of job is spawned as an  independent
              thread or process. May be used to setup a larger number of threads/processes doing the same thing.
              Each  thread  is  reported  separately;  to  see  statistics  for  all  clones  as  a  whole,  use
              <b>group_reporting</b> in conjunction with <b>new_group</b>.  See <b>--max-jobs</b>. Default: 1.

   <b>Time</b> <b>related</b> <b>parameters</b>
       <b>runtime</b>=<u>time</u>
              Limit runtime. The test will run until it completes the configured I/O workload or  until  it  has
              run  for  this specified amount of time, whichever occurs first. It can be quite hard to determine
              for how long a specified job will run, so this parameter is handy to cap the total  runtime  to  a
              given time.  When the unit is omitted, the value is interpreted in seconds.

       <b>time_based</b>
              If  set, fio will run for the duration of the <b>runtime</b> specified even if the file(s) are completely
              read or written. It will simply loop over the same workload as many times as the <b>runtime</b> allows.

       <b>startdelay</b>=<u>irange(int)</u>
              Delay the start of job for the specified amount of time. Can be a single value or  a  range.  When
              given  as  a  range,  each  thread will choose a value randomly from within the range. Value is in
              seconds if a unit is omitted.

       <b>ramp_time</b>=<u>time</u>
              If set, fio will run the specified workload for this amount of time before logging any performance
              numbers. Useful for letting performance settle before logging results, thus minimizing the runtime
              required for stable results. Note that the <b>ramp_time</b> is considered lead in time for a job, thus it
              will increase the total runtime if a special timeout or <b>runtime</b> is specified.  When  the  unit  is
              omitted, the value is given in seconds.

       <b>clocksource</b>=<u>str</u>
              Use the given clocksource as the base of timing. The supported options are:

                     <b>gettimeofday</b>
                            <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2)

                     <b>clock_gettime</b>
                            <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2)

                     <b>cpu</b>    Internal CPU clock source

              <b>cpu</b>  is  the preferred clocksource if it is reliable, as it is very fast (and fio is heavy on time
              calls). Fio will automatically use this clocksource if it's supported and considered  reliable  on
              the  system it is running on, unless another clocksource is specifically set. For x86/x86-64 CPUs,
              this means supporting TSC Invariant.

       <b>gtod_reduce</b>=<u>bool</u>
              Enable   all   of   the   <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2)   reducing    options    (<b>disable_clat</b>,    <b>disable_slat</b>,
              <b>disable_bw_measurement</b>)  plus  reduce  precision  of  the  timeout  somewhat  to really shrink the
              <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2) call count. With this option enabled, we only do about 0.4% of the <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2)
              calls we would have done if all time keeping was enabled.

       <b>gtod_cpu</b>=<u>int</u>
              Sometimes it's cheaper to dedicate a single thread of execution to just getting the current  time.
              Fio  (and  databases, for instance) are very intensive on <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2) calls. With this option,
              you can set one CPU aside for doing nothing but logging current time to a shared memory  location.
              Then  the  other  threads/processes that run I/O workloads need only copy that segment, instead of
              entering the kernel with a <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2) call. The CPU set aside for doing these time calls will
              be excluded from other uses. Fio will manually clear it from the CPU mask of other jobs.

       <b>job_start_clock_id</b>=<u>int</u>
              The clock_id passed to the call to <b>clock_gettime</b> used to  record  job_start  in  the  <b>json</b>  output
              format. Default is 0, or CLOCK_REALTIME.

   <b>Target</b> <b>file/device</b>
       <b>directory</b>=<u>str</u>
              Prefix  <b>filename</b>s  with this directory. Used to place files in a different location than `./'. You
              can specify a number  of  directories  by  separating  the  names  with  a  ':'  character.  These
              directories  will be assigned equally distributed to job clones created by <b>numjobs</b> as long as they
              are using generated filenames. If specific <b>filename</b>(s) are set  fio  will  use  the  first  listed
              directory,  and  thereby  matching the <b>filename</b> semantic (which generates a file for each clone if
              not specified, but lets all clones use the same file if set).

              See the <b>filename</b> option for information on how to escape ':' characters within the directory  path
              itself.

              Note: To control the directory fio will use for internal state files use <b>--aux-path</b>.

       <b>filename</b>=<u>str</u>
              Fio  normally  makes  up  a  <b>filename</b>  based  on the job name, thread number, and file number (see
              <b>filename_format</b>). If you want to share files between threads in a job or several jobs  with  fixed
              file  paths,  specify a <b>filename</b> for each of them to override the default. If the ioengine is file
              based, you can specify a number of files by separating the names with  a  ':'  colon.  So  if  you
              wanted  a  job  to  open  `/dev/sda'  and  `/dev/sdb'  as  the  two  working  files, you would use
              `filename=/dev/sda:/dev/sdb'. This also means that whenever this option is specified,  <b>nrfiles</b>  is
              ignored.  The  size  of  regular  files specified by this option will be <b>size</b> divided by number of
              files unless an explicit size is specified by <b>filesize</b>.

              Each colon in the wanted path must be escaped with a '\' character. For instance, if the  path  is
              `/dev/dsk/foo@3,0:c'  then  you  would  use  `filename=/dev/dsk/foo@3,0\:c'  and  if  the  path is
              `F:\filename' then you would use `filename=F\:\filename'.

              On  Windows,  disk  devices  are  accessed  as  `\\.\PhysicalDrive0'   for   the   first   device,
              `\\.\PhysicalDrive1'  for the second etc.  Note: Windows and FreeBSD prevent write access to areas
              of the disk containing in-use data (e.g. filesystems).

              For HTTP and S3 access, specify a valid URL path or S3 key, respectively.  A  filename  for  path-
              style  S3  includes  a  bucket  name  (`/bucket/k/e.y')  while  a virtual-hosted-style S3 filename
              (`/k/e.y') does not because its bucket name is specified in <b>http_host</b>.

              The filename `-' is a reserved name, meaning *stdin* or *stdout*. Which of the two depends on  the
              read/write direction set.

       <b>filename_format</b>=<u>str</u>
              If  sharing  multiple  files  between jobs, it is usually necessary to have fio generate the exact
              names that you want. By  default,  fio  will  name  a  file  based  on  the  default  file  format
              specification  of  `jobname.jobnumber.filenumber'.  With  this option, that can be customized. Fio
              will recognize and replace the following keywords in this string:

                     <b>$jobname</b>
                            The name of the worker thread or process.

                     <b>$clientuid</b>
                            IP of the fio process when using client/server mode.

                     <b>$jobnum</b>
                            The incremental number of the worker thread or process.

                     <b>$filenum</b>
                            The incremental number of the file for that worker thread or process.

              To have dependent jobs share a set of files, this option can be set to have fio generate filenames
              that are shared between the two. For instance, if `testfiles.$filenum' is specified, file number 4
              for any job will be named `testfiles.4'. The default of `$jobname.$jobnum.$filenum' will  be  used
              if no other format specifier is given.

              If  you specify a path then the directories will be created up to the main directory for the file.
              So for example if you specify `a/b/c/$jobnum` then the directories a/b/c will  be  created  before
              the  file  setup  part  of  the job.  If you specify <b>directory</b> then the path will be relative that
              directory, otherwise it is treated as the absolute path.

       <b>unique_filename</b>=<u>bool</u>
              To avoid collisions between networked clients, fio defaults to prefixing any  generated  filenames
              (with  a  directory specified) with the source of the client connecting. To disable this behavior,
              set this option to 0.

       <b>opendir</b>=<u>str</u>
              Recursively open any files below directory <u>str</u>. This accepts only a single  directory  and  unlike
              related options, colons appearing in the path must not be escaped.

       <b>lockfile</b>=<u>str</u>
              Fio  defaults to not locking any files before it does I/O to them. If a file or file descriptor is
              shared, fio can serialize I/O to that file to make the end result consistent. This  is  usual  for
              emulating real workloads that share files. The lock modes are:

                     <b>none</b>   No locking. The default.

                     <b>exclusive</b>
                            Only one thread or process may do I/O at a time, excluding all others.

                     <b>readwrite</b>
                            Read-write  locking  on the file. Many readers may access the file at the same time,
                            but writes get exclusive access.

       <b>nrfiles</b>=<u>int</u>
              Number of files to use for this job. Defaults to 1. The size of files will be <b>size</b> divided by this
              unless explicit size is specified by <b>filesize</b>. Files are created for each thread  separately,  and
              each file will have a file number within its name by default, as explained in <b>filename</b> section.

       <b>openfiles</b>=<u>int</u>
              Number of files to keep open at the same time. Defaults to the same as <b>nrfiles</b>, can be set smaller
              to limit the number simultaneous opens.

       <b>file_service_type</b>=<u>str</u>
              Defines how fio decides which file from a job to service next. The following types are defined:

                     <b>random</b> Choose a file at random.

                     <b>roundrobin</b>
                            Round robin over opened files. This is the default.

                     <b>sequential</b>
                            Finish  one  file  before  moving  on  to the next. Multiple files can still be open
                            depending on <b>openfiles</b>.

                     <b>zipf</b>   Use a Zipf distribution to decide what file to access.

                     <b>pareto</b> Use a Pareto distribution to decide what file to access.

                     <b>normal</b> Use a Gaussian (normal) distribution to decide what file to access.

                     <b>gauss</b>  Alias for normal.

              For <b>random</b>, <b>roundrobin</b>, and <b>sequential</b>, a postfix can be appended to tell fio  how  many  I/Os  to
              issue  before  switching to a new file. For example, specifying `file_service_type=random:8' would
              cause fio  to  issue  8  I/Os  before  selecting  a  new  file  at  random.  For  the  non-uniform
              distributions,  a floating point postfix can be given to influence how the distribution is skewed.
              See <b>random_distribution</b> for a description of how that would work.

       <b>ioscheduler</b>=<u>str</u>
              Attempt to switch the device hosting the file to the specified I/O scheduler  before  running.  If
              the file is a pipe, a character device file or if device hosting the file could not be determined,
              this option is ignored.

       <b>create_serialize</b>=<u>bool</u>
              If true, serialize the file creation for the jobs. This may be handy to avoid interleaving of data
              files,  which  may  greatly depend on the filesystem used and even the number of processors in the
              system. Default: true.

       <b>create_fsync</b>=<u>bool</u>
              <b><a href="../man2/fsync.2.html">fsync</a></b>(2) the data file after creation. This is the default.

       <b>create_on_open</b>=<u>bool</u>
              If true, don't pre-create files but allow the job's open() to create a file when it's time  to  do
              I/O. Default: false -- pre-create all necessary files when the job starts.

       <b>create_only</b>=<u>bool</u>
              If  true, fio will only run the setup phase of the job. If files need to be laid out or updated on
              disk, only that will be done -- the actual job contents are not executed. Default: false.

       <b>allow_file_create</b>=<u>bool</u>
              If true, fio is permitted to create files as part of its workload. If this option is  false,  then
              fio will error out if the files it needs to use don't already exist. Default: true.

       <b>allow_mounted_write</b>=<u>bool</u>
              If  this  isn't set, fio will abort jobs that are destructive (e.g. that write) to what appears to
              be a mounted device or partition. This should help catch creating inadvertently destructive tests,
              not realizing that the test will destroy data on the mounted file system. Note that some platforms
              don't allow writing against a mounted device regardless of this option. Default: false.

       <b>pre_read</b>=<u>bool</u>
              If this is given, files will be pre-read into memory before starting the given I/O operation. This
              will also clear the <b>invalidate</b> flag, since it is pointless to pre-read and then  drop  the  cache.
              This will only work for I/O engines that are seek-able, since they allow you to read the same data
              multiple times. Thus it will not work on non-seekable I/O engines (e.g. network, splice). Default:
              false.

       <b>unlink</b>=<u>bool</u>
              Unlink  (delete) the job files when done. Not the default, as repeated runs of that job would then
              waste time recreating the file set again and again. Default: false.

       <b>unlink_each_loop</b>=<u>bool</u>
              Unlink (delete) job files after each iteration or loop. Default: false.

       <b>zonemode</b>=<u>str</u>
              Accepted values are:

                     <b>none</b>   The <b>zonerange</b>, <b>zonesize</b> <b>zonecapacity</b> and <b>zoneskip</b> parameters are ignored.

                     <b>strided</b>
                            I/O happens in a single zone until <b>zonesize</b> bytes have been transferred.  After that
                            number of bytes has been  transferred  processing  of  the  next  zone  starts.  The
                            <b>zonecapacity</b> parameter is ignored.

                     <b>zbd</b>    Zoned  block  device mode. I/O happens sequentially in each zone, even if random I/O
                            has been selected. Random I/O happens across all zones instead of  being  restricted
                            to a single zone.  Trim is handled using a zone reset operation. Trim only considers
                            non-empty sequential write required and sequential write preferred zones.

       <b>zonerange</b>=<u>int</u>
              For <b>zonemode</b>=strided, this is the size of a single zone. See also <b>zonesize</b> and <b>zoneskip</b>.

              For <b>zonemode</b>=zbd, this parameter is ignored.

       <b>zonesize</b>=<u>int</u>
              For  <b>zonemode</b>=strided,  this is the number of bytes to transfer before skipping <b>zoneskip</b> bytes. If
              this parameter is smaller than <b>zonerange</b> then only a fraction of each zone  with  <b>zonerange</b>  bytes
              will  be  accessed.   If  this  parameter is larger than <b>zonerange</b> then each zone will be accessed
              multiple times before skipping to the next zone.

              For <b>zonemode</b>=zbd, this is the size of a single zone. The <b>zonerange</b> parameter is  ignored  in  this
              mode.  For  a job accessing a zoned block device, the specified <b>zonesize</b> must be 0 or equal to the
              device zone size. For a regular block device or file, the specified  <b>zonesize</b>  must  be  at  least
              512B.

       <b>zonecapacity</b>=<u>int</u>
              For  <b>zonemode</b>=zbd,  this  defines  the  capacity  of  a  single zone, which is the accessible area
              starting from the zone start address. This parameter  only  applies  when  using  <b>zonemode</b>=zbd  in
              combination  with  regular  block  devices.  If not specified it defaults to the zone size. If the
              target device is a zoned block device, the zone capacity is obtained from the  device  information
              and this option is ignored.

       <b>zoneskip</b>=<u>int[z]</u>
              For  <b>zonemode</b>=strided,  the  number  of  bytes  to  skip  after  <b>zonesize</b>  bytes of data have been
              transferred.

              For <b>zonemode</b>=zbd, the <b>zonesize</b> aligned number of bytes to skip once a zone is fully written (write
              workloads) or all written data in the zone have been read  (read  workloads).  This  parameter  is
              valid only for sequential workloads and ignored for random workloads. For read workloads, see also
              <b>read_beyond_wp</b>.

       <b>read_beyond_wp</b>=<u>bool</u>
              This parameter applies to <b>zonemode=zbd</b> only.

              Zoned  block  devices are block devices that consist of multiple zones. Each zone has a type, e.g.
              conventional or sequential. A conventional zone can be written at any offset that is a multiple of
              the block size. Sequential zones must be written sequentially. The position at which a write  must
              occur  is called the write pointer. A zoned block device can be either host managed or host aware.
              For host managed devices the host must ensure that writes happen sequentially. Fio recognizes host
              managed devices and serializes writes to sequential zones for these devices.

              If a read occurs in a sequential zone beyond the write pointer then the zoned  block  device  will
              complete  the  read  without  reading  any  data from the storage medium. Since such reads lead to
              unrealistically high bandwidth and IOPS numbers  fio  only  reads  beyond  the  write  pointer  if
              explicitly told to do so. Default: false.

       <b>max_open_zones</b>=<u>int</u>
              When  a  zone  of a zoned block device is partially written (i.e. not all sectors of the zone have
              been written), the zone is in one  of  three  conditions:  'implicit  open',  'explicit  open'  or
              'closed'.  Zoned  block  devices  may  have  a  limit  called  'max_open_zones'  (same name as the
              parameter) on the total number of zones that can simultaneously  be  in  the  'implicit  open'  or
              'explicit  open' conditions. Zoned block devices may have another limit called 'max_active_zones',
              on  the  total  number  of  zones  that  can  simultaneously  be  in  the  three  conditions.  The
              <b>max_open_zones</b>  parameter limits the number of zones to which write commands are issued by all fio
              jobs, that is, limits the number of zones that will be in the conditions. When the device has  the
              max_open_zones  limit  and  does not have the max_active_zones limit, the <b>max_open_zones</b> parameter
              limits the number of zones in the two open conditions up to the limit. In this case, fio  includes
              zones  in the two open conditions to the write target zones at fio start. When the device has both
              the max_open_zones and the max_active_zones limits, the <b>max_open_zones</b> parameter limits the number
              of zones in the three conditions up to the limit.  In this case, fio includes zones in  the  three
              conditions to the write target zones at fio start.

              This  parameter is relevant only if the <b>zonemode=zbd</b> is used. The default value is always equal to
              the max_open_zones limit of the target zoned block device and  a  value  higher  than  this  limit
              cannot   be   specified   by  users  unless  the  option  <b>ignore_zone_limits</b>  is  specified.  When
              <b>ignore_zone_limits</b> is specified or the target device  does  not  have  the  max_open_zones  limit,
              <b>max_open_zones</b>  can  specify  0  to  disable  any  limit  on  the  number  of  zones  that  can be
              simultaneously written to by all jobs.

       <b>job_max_open_zones</b>=<u>int</u>
              In the same manner as <b>max_open_zones</b>, limit the number of open zones per fio  job,  that  is,  the
              number of zones that a single job can simultaneously write to. A value of zero indicates no limit.
              Default: zero.

       <b>ignore_zone_limits</b>=<u>bool</u>
              If  this option is used, fio will ignore the maximum number of open zones limit of the zoned block
              device in use, thus allowing the option <b>max_open_zones</b> value to be larger than the device reported
              limit. Default: false.

       <b>zone_reset_threshold</b>=<u>float</u>
              A number between zero and one that indicates the ratio of written bytes in the  zones  with  write
              pointers  in  the  IO  range  to the size of the IO range. When current ratio is above this ratio,
              zones are reset periodically as <b>zone_reset_frequency</b> specifies. If there are  multiple  jobs  when
              using this option, the IO range for all write jobs has to be the same.

       <b>zone_reset_frequency</b>=<u>float</u>
              A  number  between zero and one that indicates how often a zone reset should be issued if the zone
              reset threshold has been exceeded. A zone reset is submitted after each (1 / zone_reset_frequency)
              write requests. This and the previous  parameter  can  be  used  to  simulate  garbage  collection
              activity.

   <b>I/O</b> <b>type</b>
       <b>direct</b>=<u>bool</u>
              If  value  is  true,  use non-buffered I/O. This is usually O_DIRECT. Note that OpenBSD and ZFS on
              Solaris don't support direct I/O. On Windows the synchronous ioengines don't support  direct  I/O.
              Default: false.

       <b>buffered</b>=<u>bool</u>
              If value is true, use buffered I/O. This is the opposite of the <b>direct</b> option. Defaults to true.

       <b>readwrite</b>=<u>str</u>, <b>rw</b>=<u>str</u>
              Type of I/O pattern. Accepted values are:

                     <b>read</b>   Sequential reads.

                     <b>write</b>  Sequential writes.

                     <b>trim</b>   Sequential trims (Linux block devices and SCSI character devices only).

                     <b>randread</b>
                            Random reads.

                     <b>randwrite</b>
                            Random writes.

                     <b>randtrim</b>
                            Random trims (Linux block devices and SCSI character devices only).

                     <b>rw,readwrite</b>
                            Sequential mixed reads and writes.

                     <b>randrw</b> Random mixed reads and writes.

                     <b>trimwrite</b>
                            Sequential  trim+write sequences. Blocks will be trimmed first, then the same blocks
                            will be written to. So if `io_size=64K' is specified, Fio will trim a total  of  64K
                            bytes  and  also  write 64K bytes on the same trimmed blocks. This behaviour will be
                            consistent with `number_ios' or other Fio options limiting the total bytes or number
                            of I/O's.

                     <b>randtrimwrite</b>
                            Like <b>trimwrite</b> <b>,</b> but uses random offsets rather than sequential writes.

              Fio defaults to read if the option is not specified. For the mixed I/O types, the  default  is  to
              split  them  50/50. For certain types of I/O the result may still be skewed a bit, since the speed
              may be different.

              It is possible to specify the number of I/Os to do  before  getting  a  new  offset  by  appending
              `:&lt;nr&gt;'  to the end of the string given. For a random read, it would look like `rw=randread:8' for
              passing in an offset modifier with a value of 8. If the suffix  is  used  with  a  sequential  I/O
              pattern,  then  the  `&lt;nr&gt;'  value  specified  will  be added to the generated offset for each I/O
              turning sequential I/O into sequential I/O with holes.  For  instance,  using  `rw=write:4k'  will
              skip 4k for every write. Also see the <b>rw_sequencer</b> option.

       <b>rw_sequencer</b>=<u>str</u>
              If  an  offset  modifier  is  given  by  appending a number to the `rw=<u>str</u>' line, then this option
              controls how that number modifies the I/O offset being generated. Accepted values are:

                     <b>sequential</b>
                            Generate sequential offset.

                     <b>identical</b>
                            Generate the same offset.

              <b>sequential</b> is only useful for random I/O, where fio would normally generate a  new  random  offset
              for  every  I/O. If you append e.g. 8 to randread, i.e. `rw=randread:8' you would get a new random
              offset for every 8 I/Os. The result would be a sequence of 8  sequential  offsets  with  a  random
              starting  point.  However this behavior may change if a sequential I/O reaches end of the file. As
              sequential I/O is already sequential,  setting  <b>sequential</b>  for  that  would  not  result  in  any
              difference.  <b>identical</b>  behaves  in a similar fashion, except it sends the same offset 8 number of
              times before generating a new offset.

              Example #1:

                     rw=randread:8
                     rw_sequencer=sequential
                     bs=4k

              The generated sequence of offsets will look like this: 4k, 8k, 12k, 16k, 20k, 24k, 28k, 32k,  92k,
              96k, 100k, 104k, 108k, 112k, 116k, 120k, 48k, 52k ...

              Example #2:

                     rw=randread:8
                     rw_sequencer=identical
                     bs=4k

              The  generated  sequence of offsets will look like this: 4k, 4k, 4k, 4k, 4k, 4k, 4k, 4k, 92k, 92k,
              92k, 92k, 92k, 92k, 92k, 92k, 48k, 48k, 48k ...

       <b>unified_rw_reporting</b>=<u>str</u>
              Fio normally reports statistics on a per data direction basis, meaning  that  reads,  writes,  and
              trims  are  accounted  and  reported  separately.  This  option determines whether fio reports the
              results normally, summed together, or as both options.  Accepted values are:

              <b>none</b>   Normal statistics reporting.

              <b>mixed</b>  Statistics are summed per data direction and reported together.

              <b>both</b>   Statistics are reported normally, followed by the mixed statistics.

              <b>0</b>      Backward-compatible alias for <b>none</b>.

              <b>1</b>      Backward-compatible alias for <b>mixed</b>.

              <b>2</b>      Alias for <b>both</b>.

       <b>randrepeat</b>=<u>bool</u>
              Seed all random number generators in a predictable way so the pattern is repeatable  across  runs.
              Default: true.

       <b>allrandrepeat</b>=<u>bool</u>
              Alias for <b>randrepeat</b>. Default: true.

       <b>randseed</b>=<u>int</u>
              Seed the random number generators based on this seed value, to be able to control what sequence of
              output is being generated. If not set, the random sequence depends on the <b>randrepeat</b> setting.

       <b>fallocate</b>=<u>str</u>
              Whether pre-allocation is performed when laying down files.  Accepted values are:

                     <b>none</b>   Do not pre-allocate space.

                     <b>native</b> Use  a  platform's  native  pre-allocation call but fall back to <b>none</b> behavior if it
                            fails/is not implemented.

                     <b>posix</b>  Pre-allocate via <b><a href="../man3/posix_fallocate.3.html">posix_fallocate</a></b>(3).

                     <b>keep</b>   Pre-allocate via <b><a href="../man2/fallocate.2.html">fallocate</a></b>(2) with FALLOC_FL_KEEP_SIZE set.

                     <b>truncate</b>
                            Extend file to final size using <b>ftruncate</b>|(2) instead of allocating.

                     <b>0</b>      Backward-compatible alias for <b>none</b>.

                     <b>1</b>      Backward-compatible alias for <b>posix</b>.

              May not be available on all supported platforms. <b>keep</b> is only available on Linux. If using ZFS  on
              Solaris this cannot be set to <b>posix</b> because ZFS doesn't support pre-allocation. Default: <b>native</b> if
              any pre-allocation methods except <b>truncate</b> are available, <b>none</b> if not.

              Note that using <b>truncate</b> on Windows will interact surprisingly with non-sequential write patterns.
              When writing to a file that has been extended by setting the end-of-file information, Windows will
              backfill  the  unwritten  portion of the file up to that offset with zeroes before issuing the new
              write. This means that a single small write to the end of an extended file will  stall  until  the
              entire file has been filled with zeroes.

       <b>fadvise_hint</b>=<u>str</u>
              Use  <b><a href="../man2/posix_fadvise.2.html">posix_fadvise</a></b>(2)  or <b><a href="../man2/posix_madvise.2.html">posix_madvise</a></b>(2) to advise the kernel what I/O patterns are likely to be
              issued. Accepted values are:

                     <b>0</b>      Backwards compatible hint for "no hint".

                     <b>1</b>      Backwards compatible hint for "advise with fio workload type". This uses FADV_RANDOM
                            for a random workload, and FADV_SEQUENTIAL for a sequential workload.

                     <b>sequential</b>
                            Advise using FADV_SEQUENTIAL.

                     <b>random</b> Advise using FADV_RANDOM.

                     <b>noreuse</b>
                            Advise using FADV_NOREUSE. This may be a no-op on older Linux kernels.  Since  Linux
                            6.3, it provides a hint to the LRU algorithm.  See the <b><a href="../man2/posix_fadvise.2.html">posix_fadvise</a></b>(2) man page.

       <b>write_hint</b>=<u>str</u>
              Use  <b><a href="../man2/fcntl.2.html">fcntl</a></b>(2) to advise the kernel what life time to expect from a write. Only supported on Linux,
              as of version 4.13. Accepted values are:

                     <b>none</b>   No particular life time associated with this file.

                     <b>short</b>  Data written to this file has a short life time.

                     <b>medium</b> Data written to this file has a medium life time.

                     <b>long</b>   Data written to this file has a long life time.

                     <b>extreme</b>
                            Data written to this file has a very long life time.

              The values are all relative to each other, and no absolute meaning should be associated with them.

       <b>offset</b>=<u>int[%|z]</u>
              Start I/O at the provided offset in the file, given as either a fixed size in bytes,  zones  or  a
              percentage.  If  a  percentage  is  given,  the  generated  offset  will be aligned to the minimum
              <b>blocksize</b> or to the value of <b>offset_align</b> if provided. Data before the given offset  will  not  be
              touched. This effectively caps the file size at `real_size - offset'. Can be combined with <b>size</b> to
              constrain  the start and end range of the I/O workload.  A percentage can be specified by a number
              between 1 and 100 followed by '%', for example, `offset=20%' to specify 20%. In  ZBD  mode,  value
              can be set as number of zones using 'z'.

       <b>offset_align</b>=<u>int</u>
              If  set  to non-zero value, the byte offset generated by a percentage <b>offset</b> is aligned upwards to
              this value. Defaults to 0 meaning that a percentage offset is aligned to the minimum block size.

       <b>offset_increment</b>=<u>int[%|z]</u>
              If this is provided, then the real offset becomes `<b>offset</b>  +  <b>offset_increment</b>  *  thread_number',
              where  the  thread  number is a counter that starts at 0 and is incremented for each sub-job (i.e.
              when <b>numjobs</b> option is specified). This option is useful if  there  are  several  jobs  which  are
              intended  to  operate  on  a  file  in  parallel  disjoint segments, with even spacing between the
              starting points. Percentages can be used for this option.  If a percentage is given, the generated
              offset will be aligned to the minimum <b>blocksize</b> or to the value of <b>offset_align</b> if provided.In ZBD
              mode, value can be set as number of zones using 'z'.

       <b>number_ios</b>=<u>int</u>
              Fio will normally perform I/Os until it has exhausted the size of the region set by <b>size</b>, or if it
              exhaust the allocated time (or hits an error condition). With this setting, the range/size can  be
              set  independently  of  the  number of I/Os to perform. When fio reaches this number, it will exit
              normally and report status. Note that this does not extend the amount of I/O that will be done, it
              will only stop fio if this condition is met before other end-of-job criteria.

       <b>fsync</b>=<u>int</u>
              If writing to a file, issue an <b><a href="../man2/fsync.2.html">fsync</a></b>(2) (or its equivalent) of the dirty data for every number  of
              blocks  given.  For  example, if you give 32 as a parameter, fio will sync the file after every 32
              writes issued. If fio is using non-buffered I/O, we may not sync the file. The exception is the sg
              I/O engine, which synchronizes the disk cache anyway. Defaults to 0,  which  means  fio  does  not
              periodically issue and wait for a sync to complete. Also see <b>end_fsync</b> and <b>fsync_on_close</b>.

       <b>fdatasync</b>=<u>int</u>
              Like  <b>fsync</b>  but  uses  <b><a href="../man2/fdatasync.2.html">fdatasync</a></b>(2)  to  only  sync  data  and  not  metadata blocks. In Windows,
              DragonFlyBSD or OSX there is no <b><a href="../man2/fdatasync.2.html">fdatasync</a></b>(2) so this falls back to using <b><a href="../man2/fsync.2.html">fsync</a></b>(2).  Defaults to 0,
              which means fio does not periodically issue and wait for a data-only sync to complete.

       <b>write_barrier</b>=<u>int</u>
              Make every N-th write a barrier write.

       <b>sync_file_range</b>=<u>str:int</u>
              Use <b><a href="../man2/sync_file_range.2.html">sync_file_range</a></b>(2) for every <u>int</u> number of write operations. Fio will track  range  of  writes
              that have happened since the last <b><a href="../man2/sync_file_range.2.html">sync_file_range</a></b>(2) call. <u>str</u> can currently be one or more of:

                     <b>wait_before</b>
                            SYNC_FILE_RANGE_WAIT_BEFORE

                     <b>write</b>  SYNC_FILE_RANGE_WRITE

                     <b>wait_after</b>
                            SYNC_FILE_RANGE_WRITE_AFTER

              So  if  you do `sync_file_range=wait_before,write:8', fio would use `SYNC_FILE_RANGE_WAIT_BEFORE |
              SYNC_FILE_RANGE_WRITE' for every 8 writes. Also see the <b><a href="../man2/sync_file_range.2.html">sync_file_range</a></b>(2) man page.  This  option
              is Linux specific.

       <b>overwrite</b>=<u>bool</u>
              If  true, writes to a file will always overwrite existing data. If the file doesn't already exist,
              it will be created before the write phase begins. If the file exists and is large enough  for  the
              specified write phase, nothing will be done. Default: false.

       <b>end_fsync</b>=<u>bool</u>
              If true, <b><a href="../man2/fsync.2.html">fsync</a></b>(2) file contents when a write stage has completed.  Default: false.

       <b>fsync_on_close</b>=<u>bool</u>
              If  true,  fio  will  <b><a href="../man2/fsync.2.html">fsync</a></b>(2)  a dirty file on close. This differs from <b>end_fsync</b> in that it will
              happen on every file close, not just at the end of the job. Default: false.

       <b>rwmixread</b>=<u>int</u>
              Percentage of a mixed workload that should be reads. Default: 50.

       <b>rwmixwrite</b>=<u>int</u>
              Percentage of a mixed workload that should be writes. If both <b>rwmixread</b> and  <b>rwmixwrite</b>  is  given
              and  the  values  do not add up to 100%, the latter of the two will be used to override the first.
              This may interfere with a given rate setting, if fio is asked  to  limit  reads  or  writes  to  a
              certain rate. If that is the case, then the distribution may be skewed. Default: 50.

       <b>random_distribution</b>=<u>str:float[:float][,str:float][,str:float]</u>
              By  default,  fio  will  use a completely uniform random distribution when asked to perform random
              I/O. Sometimes it is useful to skew the distribution in specific ways, ensuring that some parts of
              the data is more hot than others.  fio includes the following distribution models:

                     <b>random</b> Uniform random distribution

                     <b>zipf</b>   Zipf distribution

                     <b>pareto</b> Pareto distribution

                     <b>normal</b> Normal (Gaussian) distribution

                     <b>zoned</b>  Zoned random distribution <b>zoned_abs</b> Zoned absolute random distribution

              When using a <b>zipf</b> or <b>pareto</b> distribution, an input value is  also  needed  to  define  the  access
              pattern.  For <b>zipf</b>, this is the `Zipf theta'.  For <b>pareto</b>, it's the `Pareto power'. Fio includes a
              test program, <b>fio-genzipf</b>, that can be used visualize what the given input values  will  yield  in
              terms  of  hit  rates.  If  you  wanted  to  use  <b>zipf</b>  with  a  `theta'  of  1.2,  you  would use
              `random_distribution=zipf:1.2' as the option. If a non-uniform model is used, fio will disable use
              of the random map. For the <b>normal</b> distribution, a normal (Gaussian) deviation  is  supplied  as  a
              value between 0 and 100.

              The  second, optional float is allowed for <b>pareto</b>, <b>zipf</b> and <b>normal</b> distributions. It allows one to
              set base of distribution in non-default place, giving more control  over  most  probable  outcome.
              This  value  is  in  range [0-1] which maps linearly to range of possible random values.  Defaults
              are: random for <b>pareto</b> and <b>zipf</b>, and 0.5 for <b>normal</b>.  If you wanted to use <b>zipf</b> with a `theta`  of
              1.2 centered on 1/4 of allowed value range, you would use `random_distribution=zipf:1.2:0.25`.

              For  a  <b>zoned</b>  distribution,  fio  supports  specifying percentages of I/O access that should fall
              within what range of the file or device. For example, given a criteria of:

                     60% of accesses should be to the first 10%
                     30% of accesses should be to the next 20%
                     8% of accesses should be to the next 30%
                     2% of accesses should be to the next 40%

              we can define that through zoning of the random accesses. For the above example,  the  user  would
              do:

                     random_distribution=zoned:60/10:30/20:8/30:2/40

              A  <b>zoned_abs</b>  distribution  works  exactly like the<b>zoned</b>, except that it takes absolute sizes. For
              example, let's say you wanted to define access according to the following criteria:

                     60% of accesses should be to the first 20G
                     30% of accesses should be to the next 100G
                     10% of accesses should be to the next 500G

              we can define an absolute zoning distribution with:

                     random_distribution=zoned:60/10:30/20:8/30:2/40

              For both <b>zoned</b> and <b>zoned_abs</b>, fio supports defining up to 256 separate zones.

              Similarly to how <b>bssplit</b> works for setting ranges and percentages of block  sizes.  Like  <b>bssplit</b>,
              it's  possible  to  specify separate zones for reads, writes, and trims. If just one set is given,
              it'll apply to all of them.

       <b>percentage_random</b>=<u>int[,int][,int]</u>
              For a random workload, set how big a percentage should be random. This defaults to 100%, in  which
              case  the  workload  is  fully  random. It can be set from anywhere from 0 to 100. Setting it to 0
              would make the workload fully sequential. Any setting in between will result in a  random  mix  of
              sequential  and  random I/O, at the given percentages. Comma-separated values may be specified for
              reads, writes, and trims as described in <b>blocksize</b>.

       <b>norandommap</b>
              Normally fio will cover every block of the file when doing random I/O. If this  option  is  given,
              fio  will  just  get a new random offset without looking at past I/O history. This means that some
              blocks may not be read or written, and that some blocks may be read/written  more  than  once.  If
              this  option  is  used  with  <b>verify</b> and multiple blocksizes (via <b>bsrange</b>), only intact blocks are
              verified, i.e., partially-overwritten blocks are ignored.  With an async I/O  engine  and  an  I/O
              depth  &gt;  1,  it  is  possible  for the same block to be overwritten, which can cause verification
              errors.  Either do not use norandommap in this case, or also use the lfsr random generator.

       <b>softrandommap</b>=<u>bool</u>
              See <b>norandommap</b>. If fio runs with the random block map enabled and it fails to allocate  the  map,
              if  this  option  is  set  it will continue without a random block map. As coverage will not be as
              complete as with random maps, this option is disabled by default.

       <b>random_generator</b>=<u>str</u>
              Fio supports the following engines for generating I/O offsets for random I/O:

                     <b>tausworthe</b>
                            Strong 2^88 cycle random number generator.

                     <b>lfsr</b>   Linear feedback shift register generator.

                     <b>tausworthe64</b>
                            Strong 64-bit 2^258 cycle random number generator.

              <b>tausworthe</b> is a strong random number generator, but it requires tracking on the side if we want to
              ensure that blocks are only read or written once. <b>lfsr</b> guarantees that we never generate the  same
              offset  twice,  and  it's  also  less computationally expensive. It's not a true random generator,
              however, though for I/O purposes it's typically good enough. <b>lfsr</b> only  works  with  single  block
              sizes,  not  with  workloads  that use multiple block sizes. If used with such a workload, fio may
              read or write some blocks multiple times. The default value is  <b>tausworthe</b>,  unless  the  required
              space exceeds 2^32 blocks. If it does, then <b>tausworthe64</b> is selected automatically.

   <b>Block</b> <b>size</b>
       <b>blocksize</b>=<u>int[,int][,int]</u>, <b>bs</b>=<u>int[,int][,int]</u>
              The  block  size  in  bytes  used  for  I/O units. Default: 4096. A single value applies to reads,
              writes, and trims. Comma-separated values may be specified for reads, writes, and trims.  A  value
              not terminated in a comma applies to subsequent types. Examples:

                     bs=256k        means 256k for reads, writes and trims.
                     bs=8k,32k      means 8k for reads, 32k for writes and trims.
                     bs=8k,32k,     means 8k for reads, 32k for writes, and default for trims.
                     bs=,8k         means default for reads, 8k for writes and trims.
                     bs=,8k,        means default for reads, 8k for writes, and default for trims.

       <b>blocksize_range</b>=<u>irange[,irange][,irange]</u>, <b>bsrange</b>=<u>irange[,irange][,irange]</u>
              A  range  of  block sizes in bytes for I/O units. The issued I/O unit will always be a multiple of
              the minimum size, unless <b>blocksize_unaligned</b> is set.  Comma-separated ranges may be specified  for
              reads, writes, and trims as described in <b>blocksize</b>. Example:

                     bsrange=1k-4k,2k-8k or bsrange=1k:4k,2k:8k

       <b>bssplit</b>=<u>str[,str][,str]</u>
              Sometimes  you  want  even finer grained control of the block sizes issued, not just an even split
              between them. This option allows you to weight various block sizes, so that you are able to define
              a specific amount of block sizes issued. The format for this option is:

                     bssplit=blocksize/percentage:blocksize/percentage

              for as many block sizes as needed. So if you want to define a workload that has  50%  64k  blocks,
              10% 4k blocks, and 40% 32k blocks, you would write:

                     bssplit=4k/10:64k/50:32k/40

              Ordering  does  not matter. If the percentage is left blank, fio will fill in the remaining values
              evenly. So a bssplit option like this one:

                     bssplit=4k/50:1k/:32k/

              would have 50% 4k ios, and 25% 1k and 32k ios. The percentages always add up to 100, if bssplit is
              given a range that adds up to more, it will error out.

              Comma-separated values may be specified for reads, writes, and trims as described in <b>blocksize</b>.

              If you want a workload that has 50% 2k reads and 50% 4k reads, while having 90% 4k writes and  10%
              8k writes, you would specify:

                     bssplit=2k/50:4k/50,4k/90:8k/10

              Fio supports defining up to 64 different weights for each data direction.

       <b>blocksize_unaligned</b>, <b>bs_unaligned</b>
              If  set,  fio will issue I/O units with any size within <b>blocksize_range</b>, not just multiples of the
              minimum size. This typically won't  work  with  direct  I/O,  as  that  normally  requires  sector
              alignment.

       <b>bs_is_seq_rand</b>=<u>bool</u>
              If  this option is set, fio will use the normal read,write blocksize settings as sequential,random
              blocksize settings instead. Any random read or write will use the WRITE  blocksize  settings,  and
              any sequential read or write will use the READ blocksize settings.

       <b>blockalign</b>=<u>int[,int][,int]</u>, <b>ba</b>=<u>int[,int][,int]</u>
              Boundary  to  which  fio  will  align  random  I/O units. Default: <b>blocksize</b>. Minimum alignment is
              typically 512b for using direct I/O, though it usually depends on the hardware  block  size.  This
              option  is  mutually exclusive with using a random map for files, so it will turn off that option.
              Comma-separated values may be specified for reads, writes, and trims as described in <b>blocksize</b>.

   <b>Buffers</b> <b>and</b> <b>memory</b>
       <b>zero_buffers</b>
              Initialize buffers with all zeros. Default: fill buffers with random data.

       <b>refill_buffers</b>
              If this option is given, fio will refill the I/O buffers on every submit. The default is  to  only
              fill  it  at  init  time  and  reuse  that data. Only makes sense if zero_buffers isn't specified,
              naturally. If data verification is enabled, <b>refill_buffers</b> is also automatically enabled.

       <b>scramble_buffers</b>=<u>bool</u>
              If <b>refill_buffers</b> is too costly and the target is using  data  deduplication,  then  setting  this
              option will slightly modify the I/O buffer contents to defeat normal de-dupe attempts. This is not
              enough  to defeat more clever block compression attempts, but it will stop naive dedupe of blocks.
              Default: true.

       <b>buffer_compress_percentage</b>=<u>int</u>
              If this is set, then fio will attempt to provide I/O buffer content (on WRITEs) that compresses to
              the specified level. Fio does this by providing a mix of random data  followed  by  fixed  pattern
              data.  The  fixed  pattern  is  either  zeros,  or the pattern specified by <b>buffer_pattern</b>. If the
              <b>buffer_pattern</b>  option  is  used,  it  might  skew  the  compression   ratio   slightly.   Setting
              <b>buffer_compress_percentage</b>  to  a value other than 100 will also enable <b>refill_buffers</b> in order to
              reduce the likelihood that adjacent blocks are so  similar  that  they  over  compress  when  seen
              together.  See  <b>buffer_compress_chunk</b>  for  how  to  set  a  finer  or  coarser granularity of the
              random/fixed data regions. Defaults to unset i.e., buffer data will not adhere to any  compression
              level.

       <b>buffer_compress_chunk</b>=<u>int</u>
              This  setting  allows  fio  to  manage  how  big  the  random/fixed  data  region  is  when  using
              <b>buffer_compress_percentage</b>. When <b>buffer_compress_chunk</b> is set to some non-zero value smaller  than
              the  block size, fio can repeat the random/fixed region throughout the I/O buffer at the specified
              interval (which particularly useful when bigger block sizes are used for a job). When  set  to  0,
              fio  will  use  a chunk size that matches the block size resulting in a single random/fixed region
              within the I/O buffer. Defaults to 512. When the unit is omitted,  the  value  is  interpreted  in
              bytes.

       <b>buffer_pattern</b>=<u>str</u>
              If  set,  fio  will  fill the I/O buffers with this pattern or with the contents of a file. If not
              set, the contents of I/O buffers are defined by the other options related to buffer contents.  The
              setting  can be any pattern of bytes, and can be prefixed with 0x for hex values. It may also be a
              string, where the string must then be wrapped with "". Or it may also be  a  filename,  where  the
              filename  must be wrapped with '' in which case the file is opened and read. Note that not all the
              file contents will be read if that would cause the buffers to overflow. So, for example:

                     buffer_pattern='filename'
                     or:
                     buffer_pattern="abcd"
                     or:
                     buffer_pattern=-12
                     or:
                     buffer_pattern=0xdeadface

              Also you can combine everything together in any order:

                     buffer_pattern=0xdeadface"abcd"-12'filename'

       <b>dedupe_percentage</b>=<u>int</u>
              If set, fio will generate this percentage of identical buffers when writing. These buffers will be
              naturally dedupable. The contents of the buffers depend on what other buffer compression  settings
              have  been  set. It's possible to have the individual buffers either fully compressible, or not at
              all -- this option only controls the distribution of unique buffers. Setting this option will also
              enable <b>refill_buffers</b> to prevent every buffer being identical.

       <b>dedupe_mode</b>=<u>str</u>
              If <b>dedupe_percentage</b> is given, then this option controls how fio generates the dedupe buffers.

                     <b>repeat</b>

                            Generate dedupe buffers by repeating previous writes

                     <b>working_set</b>

                            Generate dedupe buffers from working set

              <b>repeat</b> is the default option for fio. Dedupe buffers are generated by  repeating  previous  unique
              write.

              <b>working_set</b>  is a more realistic workload.  With <b>working_set</b>, <b>dedupe_working_set_percentage</b> should
              be provided.  Given that, fio will use the initial unique write buffers as its working set.   Upon
              deciding  to  dedupe,  fio will randomly choose a buffer from the working set.  Note that by using
              <b>working_set</b> the dedupe percentage will converge to the desired over time  while  <b>repeat</b>  maintains
              the desired percentage throughout the job.

       <b>dedupe_working_set_percentage</b>=<u>int</u>
              If  <b>dedupe_mode</b>  is  set  to <b>working_set</b>, then this controls the percentage of size of the file or
              device used as the buffers fio will choose to generate the dedupe buffers from

              Note that <b>size</b> needs to be explicitly provided and only 1 file per job is supported

       <b>dedupe_global</b>=<u>bool</u>
              This controls whether the deduplication buffers will be shared amongst all  jobs  that  have  this
              option set. The buffers are spread evenly between participating jobs.

              Note  that  <b>dedupe_mode</b>  must  be set to <b>working_set</b> for this to work.  Can be used in combination
              with compression

              <b>invalidate</b>=<u>bool</u>
                     Invalidate the buffer/page cache parts of the files to be used prior to starting I/O if the
                     platform and file type support it. Defaults to true.  This will be ignored if  <b>pre_read</b>  is
                     also specified for the same job.

              <b>sync</b>=<u>str</u>
                     Whether, and what type, of synchronous I/O to use for writes.  The allowed values are:

                            <b>none</b>   Do not use synchronous IO, the default.

                            <b>0</b>      Same as <b>none</b>.

                            <b>sync</b>   Use  synchronous  file  IO. For the majority of I/O engines, this means using
                                   O_SYNC.

                            <b>1</b>      Same as <b>sync</b>.

                            <b>dsync</b>  Use synchronous data IO. For the majority of I/O engines,  this  means  using
                                   O_DSYNC.

              <b>iomem</b>=<u>str</u>, <b>mem</b>=<u>str</u>
                     Fio can use various types of memory as the I/O unit buffer. The allowed values are:

                            <b>malloc</b> Use memory from <b><a href="../man3/malloc.3.html">malloc</a></b>(3) as the buffers. Default memory type.

                            <b>shm</b>    Use shared memory as the buffers. Allocated through <b><a href="../man2/shmget.2.html">shmget</a></b>(2).

                            <b>shmhuge</b>
                                   Same as <b>shm</b>, but use huge pages as backing.

                            <b>mmap</b>   Use  <b><a href="../man2/mmap.2.html">mmap</a></b>(2)  to  allocate buffers. May either be anonymous memory, or can be
                                   file backed  if  a  filename  is  given  after  the  option.  The  format  is
                                   `mem=mmap:/path/to/file'.

                            <b>mmaphuge</b>
                                   Use  a  memory  mapped huge file as the buffer backing. Append filename after
                                   mmaphuge, ala `mem=mmaphuge:/hugetlbfs/file'.

                            <b>mmapshared</b>
                                   Same as <b>mmap</b>, but use a MMAP_SHARED mapping.

                            <b>cudamalloc</b>
                                   Use GPU memory as the buffers for GPUDirect  RDMA  benchmark.   The  <b>ioengine</b>
                                   must be <b>rdma</b>.

                     The  area allocated is a function of the maximum allowed bs size for the job, multiplied by
                     the I/O depth given. Note that for <b>shmhuge</b> and <b>mmaphuge</b> to work, the system must have  free
                     huge   pages   allocated.   This  can  normally  be  checked  and  set  by  reading/writing
                     `<a href="file:/proc/sys/vm/nr_hugepages">/proc/sys/vm/nr_hugepages</a>' on a Linux system. Fio assumes a huge page is 2 or 4MiB in size
                     depending on the platform. So to calculate the number of huge pages you need  for  a  given
                     job  file,  add  up  the  I/O  depth  of all jobs (normally one unless <b>iodepth</b> is used) and
                     multiply by the maximum bs set.  Then divide that number by the huge page size. You can see
                     the size of the huge pages in `<a href="file:/proc/meminfo">/proc/meminfo</a>'. If no huge pages are allocated by  having  a
                     non-zero  number  in  `nr_hugepages',  using  <b>mmaphuge</b>  or  <b>shmhuge</b>  will  fail.  Also  see
                     <b>hugepage-size</b>.

                     <b>mmaphuge</b> also needs to have hugetlbfs mounted and the file location should point there.  So
                     if it's mounted in `/huge', you would use `mem=mmaphuge:/huge/somefile'.

              <b>iomem_align</b>=<u>int</u>, <b>mem_align</b>=<u>int</u>
                     This  indicates  the  memory  alignment  of  the  I/O  memory  buffers. Note that the given
                     alignment is applied to the first I/O unit buffer, if using <b>iodepth</b> the  alignment  of  the
                     following  buffers  are  given  by  the  <b>bs</b>  used.  In other words, if using a <b>bs</b> that is a
                     multiple of the page sized in the system, all buffers will be aligned  to  this  value.  If
                     using  a <b>bs</b> that is not page aligned, the alignment of subsequent I/O memory buffers is the
                     sum of the <b>iomem_align</b> and <b>bs</b> used.

              <b>hugepage-size</b>=<u>int</u>
                     Defines the size of a huge page. Must  at  least  be  equal  to  the  system  setting,  see
                     `<a href="file:/proc/meminfo">/proc/meminfo</a>'  and  `<a href="file:/sys/kernel/mm/hugepages/">/sys/kernel/mm/hugepages/</a>'.  Defaults  to 2 or 4MiB depending on the
                     platform. Should probably always be a multiple of megabytes, so using `hugepage-size=Xm' is
                     the preferred way to set this to avoid setting a non-pow-2 bad value.

              <b>lockmem</b>=<u>int</u>
                     Pin the specified amount of memory with <b><a href="../man2/mlock.2.html">mlock</a></b>(2). Can be used to simulate a smaller  amount
                     of memory. The amount specified is per worker.

   <b>I/O</b> <b>size</b>
       <b>size</b>=<u>int[%|z]</u>
              The  total  size  of  file I/O for each thread of this job. Fio will run until this many bytes has
              been transferred, unless runtime is altered by other means such as (1) <b>runtime</b>, (2)  <b>io_size</b>,  (3)
              <b>number_ios</b>, (4) gaps/holes while doing I/O's such as `rw=read:16K', or (5) sequential I/O reaching
              end  of  the file which is possible when <b>percentage_random</b> is less than 100.  Fio will divide this
              size between the available files determined by options such as <b>nrfiles</b>, <b>filename</b>, unless  <b>filesize</b>
              is  specified  by  the  job.  If  the  result  of division happens to be 0, the size is set to the
              physical size of the given files or devices if they exist.  If this option is not  specified,  fio
              will  use  the  full  size  of the given files or devices. If the files do not exist, size must be
              given. It is also possible to give size as a percentage between 1 and 100. If `size=20%' is given,
              fio will use 20% of the full size of the given files or devices. In ZBD mode, size can be given in
              units of number of zones using 'z'. Can be combined with <b>offset</b> to constrain  the  start  and  end
              range that I/O will be done within.

       <b>io_size</b>=<u>int[%|z]</u>, <b>io_limit</b>=<u>int[%|z]</u>
              Normally  fio  operates  within the region set by <b>size</b>, which means that the <b>size</b> option sets both
              the region and size of I/O to be performed. Sometimes that is not what you want. With this option,
              it is possible to define just the amount of I/O that fio should do. For instance, if <b>size</b>  is  set
              to  20GiB  and  <b>io_size</b>  is set to 5GiB, fio will perform I/O within the first 20GiB but exit when
              5GiB have been done. The opposite is also possible -- if <b>size</b> is set to 20GiB, and <b>io_size</b> is  set
              to  40GiB,  then  fio  will  do  40GiB  of  I/O  within  the  0..20GiB region. Value can be set as
              percentage: <b>io_size</b>=N%.  In this case <b>io_size</b> multiplies <b>size</b>= value. In ZBD mode, value can  also
              be set as number of zones using 'z'.

       <b>filesize</b>=<u>irange(int)</u>
              Individual  file  sizes.  May  be a range, in which case fio will select sizes for files at random
              within the given range. If not given, each created file is the same size.  This  option  overrides
              <b>size</b> in terms of file size, i.e. <b>size</b> becomes merely the default for <b>io_size</b> (and has no effect it
              all if <b>io_size</b> is set explicitly).

       <b>file_append</b>=<u>bool</u>
              Perform  I/O  after  the  end of the file. Normally fio will operate within the size of a file. If
              this option is set, then fio will append to the file  instead.  This  has  identical  behavior  to
              setting <b>offset</b> to the size of a file. This option is ignored on non-regular files.

       <b>fill_device</b>=<u>bool</u>, <b>fill_fs</b>=<u>bool</u>
              Sets size to something really large and waits for ENOSPC (no space left on device) or EDQUOT (disk
              quota  exceeded)  as the terminating condition. Only makes sense with sequential write. For a read
              workload, the mount point will be filled first then I/O started on the result.

   <b>I/O</b> <b>engine</b>
       <b>ioengine</b>=<u>str</u>
              fio supports 2 kinds of performance measurement: I/O and file/directory operation.

              I/O engines define how the job issues I/O to the file. The following types are defined:

              <b>sync</b>   Basic <b><a href="../man2/read.2.html">read</a></b>(2) or <b><a href="../man2/write.2.html">write</a></b>(2) I/O. <b><a href="../man2/lseek.2.html">lseek</a></b>(2) is used to position the I/O  location.   See  <b>fsync</b>
                     and <b>fdatasync</b> for syncing write I/Os.

              <b>psync</b>  Basic  <b><a href="../man2/pread.2.html">pread</a></b>(2)  or  <b><a href="../man2/pwrite.2.html">pwrite</a></b>(2)  I/O.  Default on all supported operating systems except for
                     Windows.

              <b>vsync</b>  Basic <b><a href="../man2/readv.2.html">readv</a></b>(2) or <b><a href="../man2/writev.2.html">writev</a></b>(2) I/O. Will emulate queuing by coalescing adjacent  I/Os  into  a
                     single submission.

              <b>pvsync</b> Basic <b><a href="../man2/preadv.2.html">preadv</a></b>(2) or <b><a href="../man2/pwritev.2.html">pwritev</a></b>(2) I/O.

              <b>pvsync2</b>
                     Basic <b><a href="../man2/preadv2.2.html">preadv2</a></b>(2) or <b><a href="../man2/pwritev2.2.html">pwritev2</a></b>(2) I/O.

              <b>io_uring</b>
                     Fast  Linux  native  asynchronous  I/O.  Supports async IO for both direct and buffered IO.
                     This engine defines engine specific options.

              <b>io_uring_cmd</b>
                     Fast Linux native asynchronous I/O for passthrough commands.  This  engine  defines  engine
                     specific options.

              <b>libaio</b> Linux  native  asynchronous I/O. Note that Linux may only support queued behavior with non-
                     buffered I/O (set  `direct=1'  or  `buffered=0').   This  engine  defines  engine  specific
                     options.

              <b>posixaio</b>
                     POSIX asynchronous I/O using <b><a href="../man3/aio_read.3.html">aio_read</a></b>(3) and <b><a href="../man3/aio_write.3.html">aio_write</a></b>(3).

              <b>solarisaio</b>
                     Solaris native asynchronous I/O.

              <b>windowsaio</b>
                     Windows native asynchronous I/O. Default on Windows.

              <b>mmap</b>   File is memory mapped with <b><a href="../man2/mmap.2.html">mmap</a></b>(2) and data copied to/from using <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3).

              <b>splice</b> <b><a href="../man2/splice.2.html">splice</a></b>(2)  is used to transfer the data and <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2) to transfer data from user space to
                     the kernel.

              <b>sg</b>     SCSI generic sg v3 I/O. May either be synchronous using the SG_IO ioctl, or if  the  target
                     is  an  sg  character  device  we  use  <b><a href="../man2/read.2.html">read</a></b>(2) and <b><a href="../man2/write.2.html">write</a></b>(2) for asynchronous I/O. Requires
                     <b>filename</b> option to specify either block or character devices.  This  engine  supports  trim
                     operations. The sg engine includes engine specific options.

              <b>libzbc</b> Read,  write, trim and ZBC/ZAC operations to a zoned block device using <b>libzbc</b> library. The
                     target can be either an SG character device or a block device file.

              <b>null</b>   Doesn't transfer any data, just pretends to. This is mainly used to exercise fio itself and
                     for debugging/testing purposes.

              <b>net</b>    Transfer over the network to  given  `host:port'.  Depending  on  the  <b>protocol</b>  used,  the
                     <b>hostname</b>,  <b>port</b>, <b>listen</b> and <b>filename</b> options are used to specify what sort of connection to
                     make, while the <b>protocol</b> option determines which protocol will be used. This engine defines
                     engine specific options.

              <b>netsplice</b>
                     Like <b>net</b>, but uses <b><a href="../man2/splice.2.html">splice</a></b>(2) and <b><a href="../man2/vmsplice.2.html">vmsplice</a></b>(2) to map data  and  send/receive.   This  engine
                     defines engine specific options.

              <b>cpuio</b>  Doesn't  transfer  any  data,  but burns CPU cycles according to the <b>cpuload</b>, <b>cpuchunks</b> and
                     <b>cpumode</b> options.  A job never finishes unless there is at least one non-cpuio job.

                     <b>cpuload</b>=85 will cause that job to do nothing but burn 85% of  the  CPU.   In  case  of  SMP
                     machines,  use  <b>numjobs=&lt;nr_of_cpu&gt;</b> to  get  desired CPU usage, as the cpuload only loads a
                     single CPU at the desired rate.

                     <b>cpumode</b>=qsort replace the default noop instructions loop by a qsort  algorithm  to  consume
                     more energy.

              <b>rdma</b>   The  RDMA I/O engine supports both RDMA memory semantics (RDMA_WRITE/RDMA_READ) and channel
                     semantics (Send/Recv) for the InfiniBand, RoCE and iWARP  protocols.  This  engine  defines
                     engine specific options.
              <b>falloc</b> I/O engine that does regular fallocate to simulate data transfer as fio ioengine.
                     DDIR_READ      does fallocate(,mode = FALLOC_FL_KEEP_SIZE,).
                     DIR_WRITE      does fallocate(,mode = 0).
                     DDIR_TRIM      does fallocate(,mode = FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE).

              <b>ftruncate</b>
                     I/O  engine  that  sends  <b><a href="../man2/ftruncate.2.html">ftruncate</a></b>(2) operations in response to write (DDIR_WRITE) events.
                     Each ftruncate issued sets the file's size  to  the  current  block  offset.  <b>blocksize</b>  is
                     ignored.

              <b>e4defrag</b>
                     I/O  engine  that  does regular EXT4_IOC_MOVE_EXT ioctls to simulate defragment activity in
                     request to DDIR_WRITE event.

              <b>rados</b>  I/O engine supporting direct access to Ceph Reliable  Autonomic  Distributed  Object  Store
                     (RADOS) via librados. This ioengine defines engine specific options.

              <b>rbd</b>    I/O  engine  supporting  direct access to Ceph Rados Block Devices (RBD) via librbd without
                     the need to use the kernel rbd driver. This ioengine defines engine specific options.

              <b>http</b>   I/O engine supporting GET/PUT requests  over  HTTP(S)  with  libcurl  to  a  WebDAV  or  S3
                     endpoint.  This ioengine defines engine specific options.

                     This  engine  only  supports  direct  IO  of iodepth=1; you need to scale this via numjobs.
                     blocksize defines the size of the objects to be created.

                     TRIM is translated to object deletion.

              <b>gfapi</b>  Using GlusterFS libgfapi sync interface to  direct  access  to  GlusterFS  volumes  without
                     having to go through FUSE. This ioengine defines engine specific options.

              <b>gfapi_async</b>
                     Using  GlusterFS  libgfapi  async  interface  to direct access to GlusterFS volumes without
                     having to go through FUSE. This ioengine defines engine specific options.

              <b>libhdfs</b>
                     Read and write through Hadoop (HDFS). The <b>filename</b> option is used to specify  host,port  of
                     the  hdfs  name-node  to  connect.  This engine interprets offsets a little differently. In
                     HDFS, files once created cannot be modified so random writes are not possible.  To  imitate
                     this  the  libhdfs  engine  expects a bunch of small files to be created over HDFS and will
                     randomly pick a file from them based on the  offset  generated  by  fio  backend  (see  the
                     example  job  file  to  create  such  files, use `rw=write' option). Please note, it may be
                     necessary to set environment variables to work with HDFS/libhdfs properly.  Each  job  uses
                     its own connection to HDFS.

              <b>mtd</b>    Read,  write and erase an MTD character device (e.g., `/dev/mtd0'). Discards are treated as
                     erases. Depending on the underlying device type, the I/O  may  have  to  go  in  a  certain
                     pattern,  e.g.,  on  NAND,  writing  sequentially  to  erase  blocks  and discarding before
                     overwriting. The <b>trimwrite</b> mode works well for this constraint.

              <b>dev-dax</b>
                     Read and write using device DAX to a persistent memory device (e.g.,  /dev/dax0.0)  through
                     the PMDK libpmem library.

              <b>external</b>
                     Prefix  to  specify loading an external I/O engine object file. Append the engine filename,
                     e.g. `ioengine=external:/tmp/foo.o' to load ioengine `foo.o' in `<a href="file:/tmp">/tmp</a>'.  The  path  can  be
                     either  absolute  or  relative.  See  `engines/skeleton_external.c'  in  the fio source for
                     details of writing an external I/O engine.

              <b>libpmem</b>
                     Read and write using mmap I/O to a file on a filesystem mounted with DAX  on  a  persistent
                     memory device through the PMDK libpmem library.

              <b>ime_psync</b>
                     Synchronous  read  and  write using DDN's Infinite Memory Engine (IME). This engine is very
                     basic and issues calls to IME whenever an IO is queued.

              <b>ime_psyncv</b>
                     Synchronous read and write using DDN's Infinite  Memory  Engine  (IME).  This  engine  uses
                     iovecs  and  will try to stack as much IOs as possible (if the IOs are "contiguous" and the
                     IO depth is not exceeded) before issuing a call to IME.

              <b>ime_aio</b>
                     Asynchronous read and write using DDN's Infinite Memory Engine (IME). This engine will  try
                     to  stack  as much IOs as possible by creating requests for IME.  FIO will then decide when
                     to commit these requests.

              <b>libiscsi</b>
                     Read and write iscsi lun with libiscsi.

              <b>nbd</b>    Synchronous read and write a Network Block Device (NBD).

              <b>libcufile</b>
                     I/O engine supporting libcufile synchronous access to nvidia-fs and  a  GPUDirect  Storage-
                     supported  filesystem.  This engine performs I/O without transferring buffers between user-
                     space and the kernel, unless <b>verify</b>  is  set  or  <b>cuda_io</b>  is  <b>posix</b>.  <b>iomem</b>  must  not  be
                     <b>cudamalloc</b>. This ioengine defines engine specific options.

              <b>dfs</b>    I/O  engine supporting asynchronous read and write operations to the DAOS File System (DFS)
                     via libdfs.

              <b>nfs</b>    I/O engine supporting asynchronous read  and  write  operations  to  NFS  filesystems  from
                     userspace  via  libnfs. This is useful for achieving higher concurrency and thus throughput
                     than is possible via kernel NFS.

              <b>exec</b>   Execute 3rd party tools. Could be used to perform monitoring during jobs runtime.

              <b>xnvme</b>  I/O engine using the xNVMe C API, for NVMe devices. The xnvme engine  provides  flexibility
                     to  access GNU/Linux Kernel NVMe driver via libaio, IOCTLs, io_uring, the SPDK NVMe driver,
                     or your own custom NVMe driver. The xnvme engine includes  engine  specific  options.  (See
                     <u>https://xnvme.io/</u>).

              <b>libblkio</b>
                     Use the libblkio library (<u>https://gitlab.com/libblkio/libblkio</u>). The specific driver to use
                     must  be  set  using  <b>libblkio_driver</b>.  If <b>mem</b>/<b>iomem</b> is not specified, memory allocation is
                     delegated to libblkio (and so is guaranteed to work with the selected driver). One libblkio
                     instance is used per process, so all  jobs  setting  option  <b>thread</b>  will  share  a  single
                     instance  (with  one  queue per thread) and must specify compatible options. Note that some
                     drivers don't allow several instances to access the same device or file simultaneously, but
                     allow it for threads.

              File/directory operation engines define how the job operates file or directory.
              The following types are defined:

              <b>filecreate</b>
                     Simply create the files and do no I/O to them.  You still need to set  <b>filesize</b> so that all
                     the accounting still occurs, but no actual I/O will be done other than creating  the  file.
                     Example job file: filecreate-ioengine.fio.

              <b>filestat</b>
                     Simply  do  stat() and do no I/O to the file. You need to set <b>filesize</b> and <b>nrfiles</b>, so that
                     files will be created.  This engine is  to  measure  file  lookup  and  meta  data  access.
                     Example job file: filestat-ioengine.fio.

              <b>filedelete</b>
                     Simply  delete  the  files  by unlink() and do no I/O to them. You need to set <b>filesize</b> and
                     <b>nrfiles</b>, so that the files will be  created.   This  engine  is  to  measure  file  delete.
                     Example job file: filedelete-ioengine.fio.

              <b>dircreate</b>
                     Simply  create  the  directories and do no I/O to them.  You still need to set  <b>filesize</b> so
                     that all the accounting still occurs, but no actual I/O will be done  other  than  creating
                     the directories.  Example job file: dircreate-ioengine.fio.

              <b>dirstat</b>
                     Simply do stat() and do no I/O to the directories. You need to set <b>filesize</b> and <b>nrfiles</b>, so
                     that directories will be created.  This engine is to measure directory lookup and meta data
                     access.  Example job file: dirstat-ioengine.fio.

              <b>dirdelete</b>
                     Simply  delete  the  directories by rmdir() and do no I/O to them. You need to set <b>filesize</b>
                     and <b>nrfiles</b>, so that the directories will be created.  This engine is to measure  directory
                     delete.

              For file and directory operation engines, there is no I/O throughput, then the statistics
              data in report have different meanings. The meaningful output indexes are: <b>iops</b> and <b>clat</b>.
              <b>bw</b> is meaningless. Refer to section: "Interpreting the output" for more details.

   <b>I/O</b> <b>engine</b> <b>specific</b> <b>parameters</b>
       In addition, there are some parameters which are only valid when a specific <b>ioengine</b> is in use. These are
       used identically to normal parameters, with the caveat that when used on the command line, they must come
       after the <b>ioengine</b> that defines them is selected.

       <b>(io_uring,libaio)cmdprio_percentage</b>=<u>int[,int]</u>
              Set  the  percentage  of  I/O that will be issued with the highest priority.  Default: 0. A single
              value applies to reads and writes. Comma-separated values may be specified for reads  and  writes.
              For this option to be effective, NCQ priority must be supported and enabled, and `direct=1' option
              must  be  used.  fio  must  also be run as the root user. Unlike slat/clat/lat stats, which can be
              tracked and reported independently, per priority stats only track and  report  a  single  type  of
              latency.  By default, completion latency (clat) will be reported, if <b>lat_percentiles</b> is set, total
              latency (lat) will be reported.

       <b>(io_uring,libaio)cmdprio_class</b>=<u>int[,int]</u>
              Set the  I/O  priority  class  to  use  for  I/Os  that  must  be  issued  with  a  priority  when
              <b>cmdprio_percentage</b>  or  <b>cmdprio_bssplit</b>  is  set.   If  not  specified  when <b>cmdprio_percentage</b> or
              <b>cmdprio_bssplit</b> is set, this defaults to the highest priority class. A  single  value  applies  to
              reads and writes. Comma-separated values may be specified for reads and writes. See man <b><a href="../man1/ionice.1.html">ionice</a></b>(1).
              See also the <b>prioclass</b> option.

       <b>(io_uring,libaio)cmdprio_hint</b>=<u>int[,int]</u>
              Set  the  I/O  priority  hint  to  use  for  I/Os  that  must  be  issued  with  a  priority  when
              <b>cmdprio_percentage</b> or <b>cmdprio_bssplit</b>  is  set.   If  not  specified  when  <b>cmdprio_percentage</b>  or
              <b>cmdprio_bssplit</b>  is set, this defaults to 0 (no hint). A single value applies to reads and writes.
              Comma-separated values may be specified for reads and writes.  See also the <b>priohint</b> option.

       <b>(io_uring,libaio)cmdprio</b>=<u>int[,int]</u>
              Set the  I/O  priority  value  to  use  for  I/Os  that  must  be  issued  with  a  priority  when
              <b>cmdprio_percentage</b>  or  <b>cmdprio_bssplit</b>  is  set.   If  not  specified  when <b>cmdprio_percentage</b> or
              <b>cmdprio_bssplit</b> is set, this defaults to 0. Linux limits us to a positive value between 0  and  7,
              with  0 being the highest. A single value applies to reads and writes.  Comma-separated values may
              be specified for reads and writes. See man <b><a href="../man1/ionice.1.html">ionice</a></b>(1). Refer to an appropriate  manpage  for  other
              operating systems since the meaning of priority may differ. See also the <b>prio</b> option.

       <b>(io_uring,libaio)cmdprio_bssplit</b>=<u>str[,str]</u>
              To get a finer control over I/O priority, this option allows specifying the percentage of IOs that
              must  have  a  priority set depending on the block size of the IO. This option is useful only when
              used together with the option <b>bssplit</b>, that is, multiple different block sizes are used for  reads
              and writes.

              The first accepted format for this option is the same as the format of the <b>bssplit</b> option:

                     cmdprio_bssplit=blocksize/percentage:blocksize/percentage

              In  this case, each entry will use the priority class, priority hint and priority level defined by
              the options <b>cmdprio_class</b>, <b>cmdprio</b> and <b>cmdprio_hint</b> respectively.

              The second accepted format for this option is:

                     cmdprio_bssplit=blocksize/percentage/class/level:blocksize/percentage/class/level

              In this case, the priority class and priority level is defined inside each  entry.  In  comparison
              with  the  first accepted format, the second accepted format does not restrict all entries to have
              the same priority class and priority level.

              The third accepted format for this option is:

                     cmdprio_bssplit=blocksize/percentage/class/level/hint:...

              This is an extension of the second accepted format that allows one  to  also  specify  a  priority
              hint.

              For  all  formats,  only the read and write data directions are supported, values for trim IOs are
              ignored. This option is mutually exclusive with the <b>cmdprio_percentage</b> option.

       <b>(io_uring,io_uring_cmd)fixedbufs</b>
              If fio is asked to do direct IO, then Linux will map pages for each IO call, and release them when
              IO is done. If this option is set, the pages are pre-mapped before IO is started. This  eliminates
              the  need  to  map and release for each IO.  This is more efficient, and reduces the IO latency as
              well.

       <b>(io_uring,io_uring_cmd)nonvectored</b>=<u>int</u>
              With this option, fio will use non-vectored read/write commands, where address  must  contain  the
              address directly. Default is -1.

       <b>(io_uring,io_uring_cmd)force_async</b>
              Normal operation for io_uring is to try and issue an sqe as non-blocking first, and if that fails,
              execute it in an async manner. With this option set to N, then every N request fio will ask sqe to
              be issued in an async manner. Default is 0.

       <b>(io_uring,io_uring_cmd,xnvme)hipri</b>
              If  this  option  is  set,  fio  will  attempt to use polled IO completions. Normal IO completions
              generate interrupts to signal the completion of IO, polled completions  do  not.  Hence  they  are
              require  active  reaping  by  the  application.   The benefits are more efficient IO for high IOPS
              scenarios, and lower latencies for low queue depth IO.

       <b>(io_uring,io_uring_cmd)registerfiles</b>
              With this option, fio registers the set of files being used with  the  kernel.   This  avoids  the
              overhead  of  managing  file  counts in the kernel, making the submission and completion part more
              lightweight. Required for the below sqthread_poll option.

       <b>(io_uring,io_uring_cmd,xnvme)sqthread_poll</b>
              Normally fio will submit IO by issuing a system call to notify the kernel of  available  items  in
              the  SQ  ring. If this option is set, the act of submitting IO will be done by a polling thread in
              the kernel. This frees up cycles for fio, at the  cost  of  using  more  CPU  in  the  system.  As
              submission  is  just the time it takes to fill in the sqe entries and any syscall required to wake
              up the idle kernel thread, fio will not report submission latencies.

       <b>(io_uring,io_uring_cmd)sqthread_poll_cpu</b>=<u>int</u>
              When `sqthread_poll` is set, this option provides a way to define which CPU should be used for the
              polling thread.

       <b>(io_uring_cmd)cmd_type</b>=<u>str</u>
              Specifies the type of uring passthrough command to be used. Supported value is  nvme.  Default  is
              nvme.

       <b>(libaio)userspace_reap</b>
              Normally,  with  the  libaio  engine  in use, fio will use the <b><a href="../man3/io_getevents.3.html">io_getevents</a></b>(3) system call to reap
              newly returned events. With this flag turned on, the AIO ring will be  read  directly  from  user-
              space  to  reap  events.  The  reaping mode is only enabled when polling for a minimum of 0 events
              (e.g. when `iodepth_batch_complete=0').

       <b>(pvsync2)hipri</b>
              Set RWF_HIPRI on I/O, indicating to the kernel that it's of higher priority than normal.

       <b>(pvsync2)hipri_percentage</b>
              When hipri is set this determines the probability of  a  pvsync2  I/O  being  high  priority.  The
              default is 100%.

       <b>(pvsync2,libaio,io_uring,io_uring_cmd)nowait</b>=<u>bool</u>
              By  default  if  a  request  cannot  be executed immediately (e.g. resource starvation, waiting on
              locks) it is queued and the initiating process will be blocked until the required resource becomes
              free.  This option sets the RWF_NOWAIT flag (supported from the 4.14 Linux kernel)  and  the  call
              will return instantly with EAGAIN or a partial result rather than waiting.

              It  is useful to also use <b>ignore_error</b>=EAGAIN when using this option.  Note: glibc 2.27, 2.28 have
              a bug in syscall wrappers preadv2, pwritev2.  They return EOPNOTSUP instead of EAGAIN.

              For cached I/O, using this option  usually  means  a  request  operates  only  with  cached  data.
              Currently  the RWF_NOWAIT flag does not supported for cached write.  For direct I/O, requests will
              only succeed if cache invalidation isn't required, file blocks are fully allocated  and  the  disk
              request could be issued immediately.

       <b>(pvsync2,libaio,io_uring)atomic</b>=<u>bool</u>
              This option means that writes are issued with torn-write protection, meaning that for a power fail
              or kernel crash, all or none of the data from the write will be stored, but never a mix of old and
              new data. Torn-write protection is also known as atomic writes.

              This option sets the RWF_ATOMIC flag (supported from the 6.11 Linux kernel) on a per-IO basis.

              Writes  with  RWF_ATOMIC  set  will be rejected by the kernel when the file does not support torn-
              write protection. To learn a file's torn-write limits, issue statx with STATX_WRITE_ATOMIC.

       <b>(io_uring_cmd,xnvme)fdp</b>=<u>bool</u>
              Enable Flexible Data Placement mode for write commands.

       <b>(io_uring_cmd,xnvme)dataplacement</b>=<u>str</u>
              Specifies the data placement directive type to use for write commands.  The  following  types  are
              supported:

                     <b>none</b>   Do not use a data placement directive. This is the default.

                     <b>fdp</b>    Use  Flexible  Data  placement  directives for write commands. This is equivalent to
                            specifying <b>fdp</b>=1.

                     <b>streams</b>
                            Use Streams directives for write commands.

       <b>(io_uring_cmd,xnvme)plid_select=str,</b><u>fdp_pli_select</u>=<b>str</b>
              Defines how fio decides which placement ID to use next. The following types are defined:

                     <b>random</b> Choose a placement ID at random (uniform).

                     <b>roundrobin</b>
                            Round robin over available placement IDs. This is the default.

                     <b>scheme</b> Choose a placement ID (index) based  on  the  scheme  file  defined  by  the  option
                            <b>dp_scheme</b>.

              The available placement ID (indices) are defined by <b>plids</b> or <b>fdp_pli</b> option except for the case of
              <b>scheme</b>.

       <b>(io_uring_cmd,xnvme)plids=str,</b><u>fdp_pli</u>=<b>str</b>
              Select  which Placement ID Indices (FDP) or Placement IDs (streams) this job is allowed to use for
              writes. This option accepts a comma-separated list of values or ranges (e.g., 1,2-4,5,6-8).

              For FDP by default, the job will cycle through all available Placement IDs, so use this option  to
              be  selective.  The values specified here are array indices for the list of placement IDs returned
              by the nvme-cli command `nvme fdp status'. If you want fio to use FDP placement  identifiers  only
              at indices 0, 2 and 5, set `plids=0,2,5'.

              For streams this should be a list of Stream IDs.

       <b>(io_uring_cmd,xnvme)dp_scheme</b>=str
              Defines  which  placement  ID  (index) to be selected based on offset(LBA) range.  The file should
              contains one or more scheme entries in the following format:

                     0, 10737418240, 0
                     10737418240, 21474836480, 1
                     21474836480, 32212254720, 2
                     ...

              Each line, a scheme entry, contains start offset, end offset, and placement ID  (index)  separated
              by  comma(,).  If  the  write  offset is within the range of a certain scheme entry(start offset 
              offset &lt; end offset), the corresponding placement ID (index) will be selected. If the write offset
              belongs to multiple scheme entries, the first matched scheme entry will be applied. If the  offset
              is  not  within any range of scheme entry, dspec field will be set to 0, default RUH. (Caution: In
              case of multiple devices in a job, all devices of the job will be affected by the scheme. If  this
              option is specified, the option <b>plids</b> or <b>fdp_pli</b> will be ignored.)

       <b>(io_uring_cmd,xnvme)md_per_io_size</b>=<u>int</u>
              Size in bytes for separate metadata buffer per IO. Default: 0.

       <b>(io_uring_cmd,xnvme)pi_act</b>=<u>int</u>
              Action  to take when nvme namespace is formatted with protection information.  If this is set to 1
              and namespace is formatted with metadata size equal to protection information size, fio won't  use
              separate metadata buffer or extended logical block. If this is set to 1 and namespace is formatted
              with  metadata  size greater than protection information size, fio will not generate or verify the
              protection information portion of metadata for write or read case respectively. If this is set  to
              0, fio generates protection information for write case and verifies for read case. Default: 1.

              For 16 bit CRC generation fio will use isa-l if available otherwise it will use the default slower
              generator.  (see: https://github.com/intel/isa-l)

       <b>(io_uring_cmd,xnvme)pi_chk</b>=<u>str[,str][,str]</u>
              Controls  the  protection  information  check. This can take one or more of these values. Default:
              none.

                     <b>GUARD</b>  Enables protection information checking of guard field.

                     <b>REFTAG</b> Enables protection information checking of logical block reference tag field.

                     <b>APPTAG</b> Enables protection information checking of application tag field.

       <b>(io_uring_cmd,xnvme)apptag</b>=<u>int</u>
              Specifies logical block application tag value, if  namespace  is  formatted  to  use  end  to  end
              protection information. Default: 0x1234.

       <b>(io_uring_cmd,xnvme)apptag_mask</b>=<u>int</u>
              Specifies  logical  block  application tag mask value, if namespace is formatted to use end to end
              protection information. Default: 0xffff.

       <b>(io_uring_cmd)num_range</b>=<u>int</u>
              For trim command this will be the number of ranges to trim per I/O request.  The number of logical
              blocks per range is determined by the <b>bs</b> option which should be a multiple of logical block  size.
              This  cannot be used with read or write. Note that setting this option &gt; 1, <b>log_offset</b> will not be
              able to log all the offsets. Default: 1.

       <b>(cpuio)cpuload</b>=<u>int</u>
              Attempt to use the specified percentage of CPU cycles. This is a mandatory option when using cpuio
              I/O engine.

       <b>(cpuio)cpuchunks</b>=<u>int</u>
              Split the load into cycles of the given time. In microseconds.

       <b>(cpuio)cpumode</b>=<u>str</u>
              Specify how to stress the CPU. It can take these two values:

                     <b>noop</b>   This is the default and directs the CPU to execute noop instructions.

                     <b>qsort</b>  Replace the default noop instructions with a qsort algorithm to consume more energy.

       <b>(cpuio)exit_on_io_done</b>=<u>bool</u>
              Detect when I/O threads are done, then exit.

       <b>(libhdfs)namenode</b>=<u>str</u>
              The hostname or IP address of a HDFS cluster namenode to contact.

       <b>(libhdfs)port</b>=<u>int</u>
              The listening port of the HFDS cluster namenode.

       <b>(netsplice,net)port</b>=<u>int</u>
              The TCP or UDP port to bind to or connect to. If this is  used  with  <b>numjobs</b>  to  spawn  multiple
              instances  of  the  same job type, then this will be the starting port number since fio will use a
              range of ports.

       <b>(rdma)port</b>=<u>int</u>
              The port to use for RDMA-CM communication. This should be the same value on  the  client  and  the
              server side.

       <b>(netsplice,net,rdma)hostname</b>=<u>str</u>
              The hostname or IP address to use for TCP, UDP or RDMA-CM based I/O.  If the job is a TCP listener
              or  UDP  reader,  the  hostname is not used and must be omitted unless it is a valid UDP multicast
              address.

       <b>(netsplice,net)interface</b>=<u>str</u>
              The IP address of the network interface used to send or receive UDP multicast.

       <b>(netsplice,net)ttl</b>=<u>int</u>
              Time-to-live value for outgoing UDP multicast packets. Default: 1.

       <b>(netsplice,net)nodelay</b>=<u>bool</u>
              Set TCP_NODELAY on TCP connections.

       <b>(netsplice,net)protocol</b>=<u>str</u>, <b>proto</b>=<u>str</u>
              The network protocol to use. Accepted values are:

                     <b>tcp</b>    Transmission control protocol.

                     <b>tcpv6</b>  Transmission control protocol V6.

                     <b>udp</b>    User datagram protocol.

                     <b>udpv6</b>  User datagram protocol V6.

                     <b>unix</b>   UNIX domain socket.

                     <b>vsock</b>  VSOCK protocol.

              When the protocol is TCP, UDP or VSOCK, the port must also be given, as well as  the  hostname  if
              the  job  is  a  TCP or VSOCK listener or UDP reader. For unix sockets, the normal <b>filename</b> option
              should be used and the port is invalid.  When the protocol is VSOCK, the <b>hostname</b> is  the  CID  of
              the remote VM.

       <b>(netsplice,net)listen</b>
              For TCP network connections, tell fio to listen for incoming connections rather than initiating an
              outgoing connection. The <b>hostname</b> must be omitted if this option is used.

       <b>(netsplice,net)pingpong</b>
              Normally  a network writer will just continue writing data, and a network reader will just consume
              packages. If `pingpong=1' is set, a writer will send its normal payload to the reader,  then  wait
              for  the  reader  to send the same payload back. This allows fio to measure network latencies. The
              submission and completion latencies then measure local time spent sending or  receiving,  and  the
              completion  latency  measures how long it took for the other end to receive and send back. For UDP
              multicast traffic `pingpong=1' should only be set for a single reader when  multiple  readers  are
              listening to the same address.

       <b>(netsplice,net)window_size</b>=<u>int</u>
              Set the desired socket buffer size for the connection.

       <b>(netsplice,net)mss</b>=<u>int</u>
              Set the TCP maximum segment size (TCP_MAXSEG).

       <b>(e4defrag)donorname</b>=<u>str</u>
              File will be used as a block donor (swap extents between files).

       <b>(e4defrag)inplace</b>=<u>int</u>
              Configure donor file blocks allocation strategy:

                     <b>0</b>      Default. Preallocate donor's file on init.

                     <b>1</b>      Allocate space immediately inside defragment event, and free right after event.

       <b>(rbd,rados)clustername</b>=<u>str</u>
              Specifies the name of the Ceph cluster.

       <b>(rbd)rbdname</b>=<u>str</u>
              Specifies the name of the RBD.

       <b>(rbd,rados)pool</b>=<u>str</u>
              Specifies the name of the Ceph pool containing RBD or RADOS data.

       <b>(rbd,rados)clientname</b>=<u>str</u>
              Specifies  the  username  (without  the  'client.' prefix) used to access the Ceph cluster. If the
              <b>clustername</b> is specified, the <b>clientname</b> shall be the full *type.id* string. If no type. prefix is
              given, fio will add 'client.'  by default.

       <b>(rados)conf</b>=<u>str</u>
              Specifies  the  configuration  path  of  ceph  cluster,  so  conf  file  does  not  have   to   be
              /etc/ceph/ceph.conf.

       <b>(rbd,rados)busy_poll</b>=<u>bool</u>
              Poll  store  instead of waiting for completion. Usually this provides better throughput at cost of
              higher(up to 100%) CPU utilization.

       <b>(rados)touch_objects</b>=<u>bool</u>
              During initialization, touch (create if do not exist) all objects (files).  Touching  all  objects
              affects ceph caches and likely impacts test results.  Enabled by default.

       <b>(http)http_host</b>=<u>str</u>
              Hostname  to connect to.  HTTP port 80 is used automatically when the value of the <b>https</b> parameter
              is off, and HTTPS port 443 if it is A virtual-hosted-style S3 hostname starts with a bucket  name,
              while a path-style S3 hostname does not.  Default is <b>localhost</b>.

       <b>(http)http_user</b>=<u>str</u>
              Username for HTTP authentication.

       <b>(http)http_pass</b>=<u>str</u>
              Password for HTTP authentication.

       <b>(http)https</b>=<u>str</u>
              Whether  to  use  HTTPS  instead  of plain HTTP. on enables HTTPS; insecure will enable HTTPS, but
              disable SSL peer verification (use with caution!).  Default is <b>off</b>.

       <b>(http)http_mode</b>=<u>str</u>
              Which HTTP access mode to use: webdav, swift, or s3. Default is <b>webdav</b>.

       <b>(http)http_s3_region</b>=<u>str</u>
              The S3 region/zone to include in the request. Default is <b>us-east-1</b>.

       <b>(http)http_s3_key</b>=<u>str</u>
              The S3 secret key.

       <b>(http)http_s3_keyid</b>=<u>str</u>
              The S3 key/access id.

       <b>(http)http_s3_sse_customer_key</b>=<u>str</u>
              The encryption customer key in SSE server side.

       <b>(http)http_s3_sse_customer_algorithm</b>=<u>str</u>
              The encryption customer algorithm in SSE server side. Default is <b>AES256</b>

       <b>(http)http_s3_storage_class</b>=<u>str</u>
              Which storage class to access. User-customizable settings. Default is <b>STANDARD</b>

       <b>(http)http_swift_auth_token</b>=<u>str</u>
              The Swift auth token. See the example configuration file on how to retrieve this.

       <b>(http)http_verbose</b>=<u>int</u>
              Enable verbose requests from libcurl. Useful for  debugging.  1  turns  on  verbose  logging  from
              libcurl, 2 additionally enables HTTP IO tracing.  Default is <b>0</b>

       <b>(mtd)skip_bad</b>=<u>bool</u>
              Skip operations against known bad blocks.

       <b>(libhdfs)hdfsdirectory</b>
              libhdfs will create chunk in this HDFS directory.

       <b>(libhdfs)chunk_size</b>
              The size of the chunk to use for each file.

       <b>(rdma)verb</b>=<u>str</u>
              The  RDMA  verb to use on this side of the RDMA ioengine connection. Valid values are write, read,
              send and recv. These correspond to the equivalent RDMA verbs (e.g. write = rdma_write etc.).  Note
              that  this  only  needs  to  be  specified  on the client side of the connection. See the examples
              folder.

       <b>(rdma)bindname</b>=<u>str</u>
              The name to use to bind the local RDMA-CM connection to a local  RDMA  device.  This  could  be  a
              hostname  or  an  IPv4  or  IPv6  address.  On  the  server  side  this  will  be  passed into the
              rdma_bind_addr() function and on the client  site  it  will  be  used  in  the  rdma_resolve_add()
              function.  This  can  be  useful when multiple paths exist between the client and the server or in
              certain loopback configurations.

       <b>(filestat)stat_type</b>=<u>str</u>
              Specify stat system call type to measure lookup/getattr performance.  Default is <b>stat</b> for <b><a href="../man2/stat.2.html">stat</a></b>(2).

       <b>(sg)hipri</b>
              If this option is set, fio will attempt to use polled IO completions. This  will  have  a  similar
              effect  as  (io_uring)hipri.  Only  SCSI READ and WRITE commands will have the SGV4_FLAG_HIPRI set
              (not UNMAP (trim) nor VERIFY).  Older versions of the Linux sg driver that do  not  support  hipri
              will  simply  ignore this flag and do normal IO. The Linux SCSI Low Level Driver (LLD) that "owns"
              the device also needs to support hipri (also known as iopoll and mq_poll). The MegaRAID driver  is
              an example of a SCSI LLD.  Default: clear (0) which does normal (interrupted based) IO.

       <b>(sg,</b><u>io_uring_cmd)readfua</u>=<b>bool</b>
              With  readfua  option set to 1, read operations include the force unit access (fua) flag. Default:
              0.

       <b>(sg,</b><u>io_uring_cmd)writefua</u>=<b>bool</b>
              With writefua option set to 1, write operations include the force unit access (fua) flag. Default:
              0.

       <b>(io_uring_cmd)write_mode</b>=<u>str</u>
              Specifies the type of write operation.  Defaults to 'write'.

                     <b>write</b>  Use Write commands for write operations

                     <b>uncor</b>  Use Write Uncorrectable commands for write operations

                     <b>zeroes</b> Use Write Zeroes commands for write operations

                     <b>verify</b> Use Verify commands for write operations

       <b>(io_uring_cmd)verify_mode</b>=<u>str</u>
              Specifies the type of command to be used in the verification phase. Defaults to 'read'.

                     <b>read</b>   Use Read commands for data verification

                     <b>compare</b>
                            Use Compare commands for data verification

       <b>(sg)sg_write_mode</b>=<u>str</u>
              Specify the type of write commands to issue. This option can take multiple values:

                     <b>write</b> <b>(default)</b>
                            Write opcodes are issued as usual

                     <b>write_and_verify</b>
                            Issue WRITE AND VERIFY commands. The BYTCHK bit is set  to  00b.  This  directs  the
                            device  to carry out a medium verification with no data comparison for the data that
                            was written. The writefua option is ignored with this selection.

                     <b>verify</b> This option is deprecated. Use write_and_verify instead.

                     <b>write_same</b>
                            Issue WRITE SAME commands. This transfers a single block to the  device  and  writes
                            this  same block of data to a contiguous sequence of LBAs beginning at the specified
                            offset. fio's block size parameter specifies the amount of data  written  with  each
                            command.  However, the amount of data actually transferred to the device is equal to
                            the device's block (sector) size. For a device with 512 byte  sectors,  blocksize=8k
                            will write 16 sectors with each command. fio will still generate 8k of data for each
                            command  butonly the first 512 bytes will be used and transferred to the device. The
                            writefua option is ignored with this selection.

                     <b>same</b>   This option is deprecated. Use write_same instead.

                     <b>write_same_ndob</b>
                            Issue WRITE <a href="../man16/SAME.16.html">SAME</a>(16) commands as above but with the No Data Output Buffer (NDOB) bit
                            set. No data will be transferred to the device with this bit set. Data written  will
                            be a pre-determined pattern such as all zeroes.

                     <b>write_stream</b>
                            Issue  WRITE  <a href="../man16/STREAM.16.html">STREAM</a>(16)  commands.  Use  the stream_id option to specify the stream
                            identifier.

                     <b>verify_bytchk_00</b>
                            Issue VERIFY commands with BYTCHK set to 00. This directs the device to carry out  a
                            medium verification with no data comparison.

                     <b>verify_bytchk_01</b>
                            Issue  VERIFY commands with BYTCHK set to 01. This directs the device to compare the
                            data on the device with the data transferred to the device.

                     <b>verify_bytchk_11</b>
                            Issue VERIFY commands with BYTCHK set to 11. This transfers a single  block  to  the
                            device and compares the contents of this block with the data on the device beginning
                            at  the  specified  offset. fio's block size parameter specifies the total amount of
                            data compared with this command. However, only one block (sector) worth of  data  is
                            transferred  to  the  device.  This is similar to the WRITE SAME command except that
                            data is compared instead of written.

       <b>(sg)stream_id</b>=<u>int</u>
              Set the stream identifier for WRITE STREAM commands. If this is set to 0 (which  is  not  a  valid
              stream identifier) fio will open a stream and then close it when done. Default is 0.

       <b>(nbd)uri</b>=<u>str</u>
              Specify   the  NBD  URI  of  the  server  to  test.   The  string  is  a  standard  NBD  URI  (see
              <u>https://github.com/NetworkBlockDevice/nbd/tree/master/doc</u>).  Example URIs:

                     <u>nbd://localhost:10809</u>

                     <u>nbd+unix:///?socket=/tmp/socket</u>

                     <u>nbds://tlshost/exportname</u>

       <b>(libcufile)gpu_dev_ids</b>=<b>str</b>
              Specify the GPU IDs to use with CUDA. This is a colon-separated list of int.  GPUs are assigned to
              workers roundrobin. Default is 0.

       <b>(libcufile)cuda_io</b>=<b>str</b>
              Specify the type of I/O to use with CUDA. This option takes the following values:

                     <b>cufile</b> <b>(default)</b>
                            Use libcufile and nvidia-fs. This option performs I/O directly between  a  GPUDirect
                            Storage  filesystem  and  GPU buffers, avoiding use of a bounce buffer. If <b>verify</b> is
                            set,  cudaMemcpy  is  used  to  copy  verification  data  between  RAM  and  GPU(s).
                            Verification data is copied from RAM to GPU before a write and from GPU to RAM after
                            a read.  <b>direct</b> must be 1.

                     <b>posix</b>  Use  POSIX  to  perform  I/O  with a RAM buffer, and use cudaMemcpy to transfer data
                            between RAM and the GPU(s).  Data is copied from GPU  to  RAM  before  a  write  and
                            copied from RAM to GPU after a read. <b>verify</b> does not affect the use of cudaMemcpy.

       <b>(dfs)pool</b>
              Specify the label or UUID of the DAOS pool to connect to.

       <b>(dfs)cont</b>
              Specify the label or UUID of the DAOS container to open.

       <b>(dfs)chunk_size</b>
              Specify  a  different  chunk size (in bytes) for the dfs file.  Use DAOS container's chunk size by
              default.

       <b>(dfs)object_class</b>
              Specify a different object class for the dfs file.  Use DAOS container's object class by default.

       <b>(nfs)nfs_url</b>
              URL in libnfs format, eg nfs://&lt;server|ipv4|ipv6&gt;/path[?arg=val[&amp;arg=val]*] Refer  to  the  libnfs
              README for more details.

       <b>(exec)program</b>=<b>str</b>
              Specify  the program to execute.  Note the program will receive a SIGTERM when the job is reaching
              the time limit.  A SIGKILL is sent once the job is over. The delay  between  the  two  signals  is
              defined by <b>grace_time</b> option.

       <b>(exec)arguments</b>=<b>str</b>
              Specify  arguments  to  pass to program.  Some special variables can be expanded to pass fio's job
              details to the program :

                     <b>%r</b>     replaced by the duration of the job in seconds

                     <b>%n</b>     replaced by the name of the job

       <b>(exec)grace_time</b>=<b>int</b>
              Defines the time between the SIGTERM and SIGKILL signals. Default is 1 second.

       <b>(exec)std_redirect</b>=<b>bool</b>
              If set, stdout and stderr streams are redirected to files named from  the  job  name.  Default  is
              true.

       <b>(xnvme)xnvme_async</b>=<b>str</b>
              Select the xnvme async command interface. This can take these values.

                     <b>emu</b>    This  is  default  and  use  to emulate asynchronous I/O by using a single thread to
                            create a queue pair on top of a synchronous I/O  interface  using  the  NVMe  driver
                            IOCTL.

                     <b>thrpool</b>
                            Emulate  an  asynchronous I/O interface with a pool of userspace threads on top of a
                            synchronous I/O interface using the NVMe driver IOCTL. By default four  threads  are
                            used.

                     <b>io_uring</b>
                            Linux native asynchronous I/O interface which supports both direct and buffered I/O.

                     <b>libaio</b> Use Linux aio for Asynchronous I/O

                     <b>posix</b>  Use  the  posix  asynchronous  I/O  interface  to perform one or more I/O operations
                            asynchronously.

                     <b>vfio</b>   Use the user-space VFIO-based backend, implemented using libvfn instead of SPDK.

                     <b>nil</b>    Do not transfer any data; just pretend to. This is  mainly  used  for  introspective
                            performance evaluation.

       <b>(xnvme)xnvme_sync</b>=<b>str</b>
              Select the xnvme synchronous command interface. This can take these values.

                     <b>nvme</b>   This is default and uses Linux NVMe Driver ioctl() for synchronous I/O.

                     <b>psync</b>  This supports regular as well as vectored pread() and pwrite() commands.

                     <b>block</b>  This  is  the  same  as  psync except that it also supports zone management commands
                            using Linux block layer IOCTLs.

       <b>(xnvme)xnvme_admin</b>=<b>str</b>
              Select the xnvme admin command interface. This can take these values.

                     <b>nvme</b>   This is default and uses Linux NVMe Driver ioctl() for admin commands.

                     <b>block</b>  Use Linux Block Layer ioctl() and sysfs for admin commands.

       <b>(xnvme)xnvme_dev_nsid</b>=<b>int</b>
              xnvme namespace identifier for userspace NVMe driver SPDK or vfio.

       <b>(xnvme)xnvme_dev_subnqn</b>=<b>str</b>
              Sets the subsystem NQN for fabrics. This is for xNVMe to utilize a fabrics  target  with  multiple
              systems.

       <b>(xnvme)xnvme_mem</b>=<b>str</b>
              Select the xnvme memory backend. This can take these values.

                     <b>posix</b>  This is the default posix memory backend for linux NVMe driver.

                     <b>hugepage</b>
                            Use  hugepages,  instead  of  existing posix memory backend. The memory backend uses
                            hugetlbfs. This require users to allocate hugepages,  mount  hugetlbfs  and  set  an
                            environment variable for XNVME_HUGETLB_PATH.

                     <b>spdk</b>   Uses SPDK's memory allocator.

                     <b>vfio</b>   Uses  libvfn's  memory  allocator.  This  also  specifies  the use of libvfn backend
                            instead of SPDK.

       <b>(xnvme)xnvme_iovec</b>
              If this option is set, xnvme will use vectored read/write commands.

       <b>(libblkio)libblkio_driver</b>=<u>str</u>
              The libblkio driver  to  use.  Different  drivers  access  devices  through  different  underlying
              interfaces.  Available  drivers  depend  on  the  libblkio  version  in  use  and  are  listed  at
              <u>https://libblkio.gitlab.io/libblkio/blkio.html#drivers</u>

       <b>(libblkio)libblkio_path</b>=<u>str</u>
              Sets the value of the driver-specific "path" property before  connecting  the  libblkio  instance,
              which  identifies  the  target  device  or  file  on which to perform I/O. Its exact semantics are
              driver-dependent      and      not      all      drivers      may      support       it;       see
              <u>https://libblkio.gitlab.io/libblkio/blkio.html#drivers</u>

       <b>(libblkio)libblkio_pre_connect_props</b>=<u>str</u>
              A  colon-separated  list  of  additional  libblkio  properties to be set after creating but before
              connecting the libblkio instance. Each property must have the format <b>&lt;name&gt;=&lt;value&gt;</b>. Colons can be
              escaped as <b>\:</b>. These are set after  the  engine  sets  any  other  properties,  so  those  can  be
              overridden.   Available  properties  depend  on  the  libblkio  version  in  use and are listed at
              <u>https://libblkio.gitlab.io/libblkio/blkio.html#properties</u>

       <b>(libblkio)libblkio_num_entries</b>=<u>int</u>
              Sets the value  of  the  driver-specific  "num-entries"  property  before  starting  the  libblkio
              instance.  Its  exact  semantics  are  driver-dependent  and  not  all drivers may support it; see
              <u>https://libblkio.gitlab.io/libblkio/blkio.html#drivers</u>

       <b>(libblkio)libblkio_queue_size</b>=<u>int</u>
              Sets the value of the driver-specific "queue-size" property before starting the libblkio instance.
              Its  exact  semantics  are  driver-dependent  and  not   all   drivers   may   support   it;   see
              <u>https://libblkio.gitlab.io/libblkio/blkio.html#drivers</u>

       <b>(libblkio)libblkio_pre_start_props</b>=<u>str</u>
              A  colon-separated  list  of  additional libblkio properties to be set after connecting but before
              starting the libblkio instance. Each property must have the format <b>&lt;name&gt;=&lt;value&gt;</b>. Colons  can  be
              escaped  as  <b>\:</b>.  These  are  set  after  the  engine  sets  any other properties, so those can be
              overridden.  Available properties depend on  the  libblkio  version  in  use  and  are  listed  at
              <u>https://libblkio.gitlab.io/libblkio/blkio.html#properties</u>

       <b>(libblkio)hipri</b>
              Use     poll    queues.    This    is    incompatible    with    <b>libblkio_wait_mode=eventfd</b>    and
              <b>libblkio_force_enable_completion_eventfd</b>.

       <b>(libblkio)libblkio_vectored</b>
              Submit vectored read and write requests.

       <b>(libblkio)libblkio_write_zeroes_on_trim</b>
              Submit trims as "write zeroes" requests instead of discard requests.

       <b>(libblkio)libblkio_wait_mode</b>=<u>str</u>
              How to wait for completions:

                     <b>block</b> (default)
                            Use a blocking call to <b>blkioq_do_io()</b>.

                     <b>eventfd</b>
                            Use a blocking call to <b>read()</b> on the completion eventfd.

                     <b>loop</b>   Use a busy loop with a non-blocking call to <b>blkioq_do_io()</b>.

       <b>(libblkio)libblkio_force_enable_completion_eventfd</b>
              Enable the queue's completion eventfd even when unused. This may impact performance.  The  default
              is to enable it only if <b>libblkio_wait_mode=eventfd</b>.

       <b>(windowsaio)no_completion_thread</b>
              Avoid using a separate thread for completion polling.

   <b>I/O</b> <b>depth</b>
       <b>iodepth</b>=<u>int</u>
              Number of I/O units to keep in flight against the file. Note that increasing <b>iodepth</b> beyond 1 will
              not  affect  synchronous  ioengines  (except  for small degrees when <b>verify_async</b> is in use). Even
              async engines may impose OS restrictions causing the desired depth not to be  achieved.  This  may
              happen  on  Linux when using libaio and not setting `direct=1', since buffered I/O is not async on
              that OS. Keep an eye on the I/O depth distribution in the fio output to verify that  the  achieved
              depth is as expected. Default: 1.

       <b>iodepth_batch_submit</b>=<u>int</u>, <b>iodepth_batch</b>=<u>int</u>
              This defines how many pieces of I/O to submit at once. It defaults to 1 which means that we submit
              each  I/O  as  soon  as  it is available, but can be raised to submit bigger batches of I/O at the
              time. If it is set to 0 the <b>iodepth</b> value will be used.

       <b>iodepth_batch_complete_min</b>=<u>int</u>, <b>iodepth_batch_complete</b>=<u>int</u>
              This defines how many pieces of I/O to retrieve at once. It defaults to 1 which means  that  we'll
              ask  for a minimum of 1 I/O in the retrieval process from the kernel. The I/O retrieval will go on
              until we hit the limit set by <b>iodepth_low</b>. If this variable is set to  0,  then  fio  will  always
              check  for completed events before queuing more I/O. This helps reduce I/O latency, at the cost of
              more retrieval system calls.

       <b>iodepth_batch_complete_max</b>=<u>int</u>
              This defines maximum pieces of I/O to retrieve at once. This variable should be  used  along  with
              <b>iodepth_batch_complete_min</b>=<u>int</u>  variable,  specifying the range of min and max amount of I/O which
              should be retrieved. By default it is equal to <b>iodepth_batch_complete_min</b> value. Example #1:

                     iodepth_batch_complete_min=1
                     iodepth_batch_complete_max=&lt;iodepth&gt;

              which means that we will retrieve at least 1 I/O and up to the whole  submitted  queue  depth.  If
              none of I/O has been completed yet, we will wait.  Example #2:

                     iodepth_batch_complete_min=0
                     iodepth_batch_complete_max=&lt;iodepth&gt;

              which  means  that  we  can retrieve up to the whole submitted queue depth, but if none of I/O has
              been completed yet, we will NOT wait and immediately exit the system  call.  In  this  example  we
              simply do polling.

       <b>iodepth_low</b>=<u>int</u>
              The  low  water  mark  indicating  when  to start filling the queue again. Defaults to the same as
              <b>iodepth</b>, meaning that fio will attempt to keep the queue full at all times. If <b>iodepth</b> is  set  to
              e.g.  16  and <b>iodepth_low</b> is set to 4, then after fio has filled the queue of 16 requests, it will
              let the depth drain down to 4 before starting to fill it again.

       <b>serialize_overlap</b>=<u>bool</u>
              Serialize in-flight I/Os that might otherwise cause or suffer from data races.  When two  or  more
              I/Os  are  submitted  simultaneously,  there  is  no  guarantee that the I/Os will be processed or
              completed in the submitted order.  Further,  if  two  or  more  of  those  I/Os  are  writes,  any
              overlapping  region  between  them  can  become  indeterminate/undefined on certain storage. These
              issues can cause verification to fail erratically when at least one of the racing I/Os is changing
              data and the overlapping region has a non-zero size. Setting <b>serialize_overlap</b> tells fio to  avoid
              provoking  this  behavior  by  explicitly serializing in-flight I/Os that have a non-zero overlap.
              Note that setting this option can reduce both performance and the <b>iodepth</b> achieved.

              This option only applies to I/Os issued for a single job except when  it  is  enabled  along  with
              <b>io_submit_mode</b>=offload.  In  offload  mode, fio will check for overlap among all I/Os submitted by
              offload jobs with <b>serialize_overlap</b> enabled.

              Default: false.

       <b>io_submit_mode</b>=<u>str</u>
              This option controls how fio submits the I/O to the I/O engine. The  default  is  `inline',  which
              means  that the fio job threads submit and reap I/O directly. If set to `offload', the job threads
              will offload I/O submission to a dedicated pool of I/O threads. This  requires  some  coordination
              and  thus  has a bit of extra overhead, especially for lower queue depth I/O where it can increase
              latencies. The benefit is that fio  can  manage  submission  rates  independently  of  the  device
              completion  rates.  This  avoids skewed latency reporting if I/O gets backed up on the device side
              (the coordinated omission problem). Note that this option cannot reliably be used  with  async  IO
              engines.

   <b>I/O</b> <b>rate</b>
       <b>thinkcycles</b>=<u>int</u>
              Stall  the  job  for  the specified number of cycles after an I/O has completed before issuing the
              next. May be used to simulate processing being done by an application.  This  is  not  taken  into
              account  for the time to be waited on for <b>thinktime</b>.  Might not have any effect on some platforms,
              this can be checked by trying a setting a high enough amount of thinkcycles.

       <b>thinktime</b>=<u>time</u>
              Stall the job for the specified period of time after an I/O has completed before issuing the next.
              May be used to simulate processing being done by an application.  When the unit  is  omitted,  the
              value is interpreted in microseconds. See <b>thinktime_blocks</b>, <b>thinktime_iotime</b> and <b>thinktime_spin</b>.

       <b>thinktime_spin</b>=<u>time</u>
              Only valid if <b>thinktime</b> is set - pretend to spend CPU time doing something with the data received,
              before  falling  back to sleeping for the rest of the period specified by <b>thinktime</b>. When the unit
              is omitted, the value is interpreted in microseconds.

       <b>thinktime_blocks</b>=<u>int</u>
              Only valid if <b>thinktime</b> is set - control how many blocks to issue, before waiting <b>thinktime</b> usecs.
              If not set, defaults to 1 which will make  fio  wait  <b>thinktime</b>  usecs  after  every  block.  This
              effectively  makes  any  queue  depth  setting  redundant, since no more than 1 I/O will be queued
              before we have to complete it and do our <b>thinktime</b>. In other words, this setting effectively  caps
              the queue depth if the latter is larger.

       <b>thinktime_blocks_type</b>=<u>str</u>
              Only  valid  if  <b>thinktime</b>  is  set  -  control  how  <b>thinktime_blocks</b>  triggers.   The default is
              `complete', which triggers <b>thinktime</b> when fio completes <b>thinktime_blocks</b> blocks. If this is set to
              `issue', then the trigger happens at the issue side.

       <b>thinktime_iotime</b>=<u>time</u>
              Only valid if <b>thinktime</b> is set - control <b>thinktime</b> interval  by  time.   The  <b>thinktime</b>  stall  is
              repeated  after  IOs  are  executed  for  <b>thinktime_iotime</b>.  For  example,  `--thinktime_iotime=9s
              --thinktime=1s' repeat 10-second cycle with IOs for 9 seconds and stall for  1  second.  When  the
              unit  is  omitted, <b>thinktime_iotime</b> is interpreted as a number of seconds.  If this option is used
              together with <b>thinktime_blocks</b>, the <b>thinktime</b> stall is repeated after  <b>thinktime_iotime</b>  or  after
              <b>thinktime_blocks</b> IOs, whichever happens first.

       <b>rate</b>=<u>int[,int][,int]</u>
              Cap  the  bandwidth  used  by this job. The number is in bytes/sec, the normal suffix rules apply.
              Comma-separated values may be specified for reads, writes, and trims as described in <b>blocksize</b>.

              For example, using `rate=1m,500k' would limit reads to 1MiB/sec and writes to 500KiB/sec.  Capping
              only  reads  or  writes  can  be done with `rate=,500k' or `rate=500k,' where the former will only
              limit writes (to 500KiB/sec) and the latter will only limit reads.

       <b>rate_min</b>=<u>int[,int][,int]</u>
              Tell fio to do whatever it can  to  maintain  at  least  this  bandwidth.  Failing  to  meet  this
              requirement will cause the job to exit. Comma-separated values may be specified for reads, writes,
              and trims as described in <b>blocksize</b>.

       <b>rate_iops</b>=<u>int[,int][,int]</u>
              Cap the bandwidth to this number of IOPS. Basically the same as <b>rate</b>, just specified independently
              of  bandwidth. If the job is given a block size range instead of a fixed value, the smallest block
              size is used as the metric. Comma-separated values may be specified for reads, writes,  and  trims
              as described in <b>blocksize</b>.

       <b>rate_iops_min</b>=<u>int[,int][,int]</u>
              If  fio  doesn't meet this rate of I/O, it will cause the job to exit.  Comma-separated values may
              be specified for reads, writes, and trims as described in <b>blocksize</b>.

       <b>rate_process</b>=<u>str</u>
              This option controls how fio manages rated I/O submissions. The default is `linear', which submits
              I/O in a linear fashion with fixed delays between I/Os that gets adjusted based on I/O  completion
              rates.  If this is set to `poisson', fio will submit I/O based on a more real world random request
              flow, known as  the  Poisson  process  (<u>https://en.wikipedia.org/wiki/Poisson_point_process</u>).  The
              lambda will be 10^6 / IOPS for the given workload.

       <b>rate_ignore_thinktime</b>=<u>bool</u>
              By  default,  fio will attempt to catch up to the specified rate setting, if any kind of thinktime
              setting was used. If this option is set, then fio will ignore the thinktime and continue doing  IO
              at the specified rate, instead of entering a catch-up mode after thinktime is done.

       <b>rate_cycle</b>=<u>int</u>
              Average  bandwidth  for  <b>rate_min</b>  and <b>rate_iops_min</b> over this number of milliseconds. Defaults to
              1000.

   <b>I/O</b> <b>latency</b>
       <b>latency_target</b>=<u>time</u>
              If set, fio will attempt to find the max performance point that the given  workload  will  run  at
              while  maintaining a latency below this target. When the unit is omitted, the value is interpreted
              in microseconds. See <b>latency_window</b> and <b>latency_percentile</b>.

       <b>latency_window</b>=<u>time</u>
              Used with <b>latency_target</b> to specify the sample window that the job is run at varying queue  depths
              to test the performance. When the unit is omitted, the value is interpreted in microseconds.

       <b>latency_percentile</b>=<u>float</u>
              The  percentage  of  I/Os  that  must  fall  within  the  criteria specified by <b>latency_target</b> and
              <b>latency_window</b>. If not set, this defaults to 100.0, meaning that all I/Os must be equal  or  below
              to the value set by <b>latency_target</b>.

       <b>latency_run</b>=<u>bool</u>
              Used  with  <b>latency_target</b>.  If  false (default), fio will find the highest queue depth that meets
              <b>latency_target</b> and exit. If true, fio will continue running and  try  to  meet  <b>latency_target</b>  by
              adjusting queue depth.

       <b>max_latency</b>=<u>time[,time][,time]</u>
              If set, fio will exit the job with an ETIMEDOUT error if it exceeds this maximum latency. When the
              unit is omitted, the value is interpreted in microseconds. Comma-separated values may be specified
              for reads, writes, and trims as described in <b>blocksize</b>.

   <b>I/O</b> <b>replay</b>
       <b>write_iolog</b>=<u>str</u>
              Write  the  issued I/O patterns to the specified file. See <b>read_iolog</b>. Specify a separate file for
              each job, otherwise the iologs will be interspersed and the file may be corrupt. This file will be
              opened in append mode.

       <b>read_iolog</b>=<u>str</u>
              Open an iolog with the specified filename and replay the I/O patterns it  contains.  This  can  be
              used  to  store  a  workload  and replay it sometime later. The iolog given may also be a blktrace
              binary file, which allows fio to replay a workload captured by blktrace. See <b><a href="../man8/blktrace.8.html">blktrace</a></b>(8)  for  how
              to  capture  such  logging  data. For blktrace replay, the file needs to be turned into a blkparse
              binary data file first (`blkparse &lt;device&gt; -o /dev/null -d file_for_fio.bin').  You can specify  a
              number  of  files  by  separating  the  names  with  a ':' character.  See the <b>filename</b> option for
              information on how  to  escape  ':'  characters  within  the  file  names.  These  files  will  be
              sequentially  assigned to job clones created by <b>numjobs</b>. '-' is a reserved name, meaning read from
              stdin, notably if <b>filename</b> is set to '-' which means stdin as well, then this flag can't be set to
              '-'.

       <b>read_iolog_chunked</b>=<u>bool</u>
              Determines how iolog is read. If false (default) entire  <b>read_iolog</b>  will  be  read  at  once.  If
              selected true, input from iolog will be read gradually.  Useful when iolog is very large, or it is
              generated.

       <b>merge_blktrace_file</b>=<u>str</u>
              When  specified,  rather than replaying the logs passed to <b>read_iolog</b>, the logs go through a merge
              phase which aggregates them into a single blktrace.  The resulting file is then passed on  as  the
              <b>read_iolog</b>  parameter.  The  intention here is to make the order of events consistent. This limits
              the influence of the scheduler compared to replaying multiple blktraces via concurrent jobs.

       <b>merge_blktrace_scalars</b>=<u>float_list</u>
              This is a percentage based option  that  is  index  paired  with  the  list  of  files  passed  to
              <b>read_iolog</b>.  When  merging is performed, scale the time of each event by the corresponding amount.
              For example, `--merge_blktrace_scalars="50:100"' runs the first trace in halftime and  the  second
              trace  in  realtime. This knob is separately tunable from <b>replay_time_scale</b> which scales the trace
              during runtime and will not change the output of the merge unlike this option.

       <b>merge_blktrace_iters</b>=<u>float_list</u>
              This is a whole number option that is index paired with the list of files  passed  to  <b>read_iolog</b>.
              When  merging  is  performed,  run each trace for the specified number of iterations. For example,
              `--merge_blktrace_iters="2:1"' runs the first trace for two iterations and the  second  trace  for
              one iteration.

       <b>replay_no_stall</b>=<u>bool</u>
              When  replaying  I/O  with <b>read_iolog</b> the default behavior is to attempt to respect the timestamps
              within the log and replay them with the appropriate delay between IOPS. By setting  this  variable
              fio  will  not  respect  the timestamps and attempt to replay them as fast as possible while still
              respecting ordering. The result is the same I/O pattern to a given device, but different timings.

       <b>replay_time_scale</b>=<u>int</u>
              When replaying I/O with <b>read_iolog</b>, fio will honor the original timing in  the  trace.  With  this
              option,  it's  possible  to scale the time. It's a percentage option, if set to 50 it means run at
              50% the original IO rate in the trace. If set to 200, run at twice the original IO rate.  Defaults
              to 100.

       <b>replay_redirect</b>=<u>str</u>
              While  replaying I/O patterns using <b>read_iolog</b> the default behavior is to replay the IOPS onto the
              major/minor device that each IOP was recorded from. This is sometimes  undesirable  because  on  a
              different  machine  those  major/minor numbers can map to a different device. Changing hardware on
              the same system can also result in a different major/minor mapping.   <b>replay_redirect</b>  causes  all
              I/Os  to  be  replayed  onto  the single specified device regardless of the device it was recorded
              from. i.e. `replay_redirect=/dev/sdc' would cause all I/O in the blktrace or iolog to be  replayed
              onto  `/dev/sdc'.  This means multiple devices will be replayed onto a single device, if the trace
              contains multiple devices. If you want multiple devices to be replayed  concurrently  to  multiple
              redirected  devices  you  must  blkparse  your  trace  into  separate  traces and replay them with
              independent fio invocations.  Unfortunately this also breaks  the  strict  time  ordering  between
              multiple device accesses.

       <b>replay_align</b>=<u>int</u>
              Force alignment of the byte offsets in a trace to this value. The value must be a power of 2.

       <b>replay_scale</b>=<u>int</u>
              Scale  bye  offsets down by this factor when replaying traces. Should most likely use <b>replay_align</b>
              as well.

   <b>Threads,</b> <b>processes</b> <b>and</b> <b>job</b> <b>synchronization</b>
       <b>replay_skip</b>=<u>str</u>
              Sometimes it's useful to skip certain IO types in a replay trace. This  could  be,  for  instance,
              eliminating  the  writes in the trace. Or not replaying the trims/discards, if you are redirecting
              to a device that doesn't support them.  This option takes a comma separated list of  read,  write,
              trim, sync.

       <b>thread</b> Fio defaults to creating jobs by using fork, however if this option is given, fio will create jobs
              by using POSIX Threads' function <b><a href="../man3/pthread_create.3.html">pthread_create</a></b>(3) to create threads instead.

       <b>wait_for</b>=<u>str</u>
              If  set,  the current job won't be started until all workers of the specified waitee job are done.
              <b>wait_for</b> operates on the job name basis, so there are a few limitations. First, the waitee must be
              defined prior to the waiter job (meaning no  forward  references).  Second,  if  a  job  is  being
              referenced as a waitee, it must have a unique name (no duplicate waitees).

       <b>nice</b>=<u>int</u>
              Run  the job with the given nice value. See man <b><a href="../man2/nice.2.html">nice</a></b>(2).  On Windows, values less than -15 set the
              process class to "High"; -1 through -15 set "Above Normal"; 1 through 15 "Below Normal"; and above
              15 "Idle" priority class.

       <b>prio</b>=<u>int</u>
              Set the I/O priority value of this job. Linux limits us to a positive value between 0 and 7,  with
              0  being  the  highest.  See  man  <b><a href="../man1/ionice.1.html">ionice</a></b>(1).  Refer to an appropriate manpage for other operating
              systems since meaning of priority may differ. For per-command priority setting, see the I/O engine
              specific `cmdprio_percentage` and `cmdprio` options.

       <b>prioclass</b>=<u>int</u>
              Set the I/O priority class. See man <b><a href="../man1/ionice.1.html">ionice</a></b>(1). For  per-command  priority  setting,  see  the  I/O
              engine specific `cmdprio_percentage` and `cmdprio_class` options.

       <b>priohint</b>=<u>int</u>
              Set  the I/O priority hint. This is only applicable to platforms that support I/O priority classes
              and to devices with features controlled through priority  hints,  e.g.  block  devices  supporting
              command  duration  limits, or CDL. CDL is a way to indicate the desired maximum latency of I/Os so
              that the device can optimize its internal command  scheduling  according  to  the  latency  limits
              indicated by the user. For per-I/O priority hint setting, see the I/O engine specific <b>cmdprio_hint</b>
              <b>option.</b>

       <b>cpus_allowed</b>=<u>str</u>
              Controls  the  same  options as <b>cpumask</b>, but accepts a textual specification of the permitted CPUs
              instead and CPUs are indexed from 0. So to use CPUs 0 and 5 you would specify  `cpus_allowed=0,5'.
              This  option also allows a range of CPUs to be specified -- say you wanted a binding to CPUs 0, 5,
              and 8 to 15, you would set `cpus_allowed=0,5,8-15'.

              On Windows, when `cpus_allowed' is unset only CPUs from fio's current processor group will be used
              and affinity settings are inherited from the system. An fio build configured to target  Windows  7
              makes options that set CPUs processor group aware and values will set both the processor group and
              a  CPU  from  within  that group. For example, on a system where processor group 0 has 40 CPUs and
              processor group 1 has 32 CPUs, `cpus_allowed'  values  between  0  and  39  will  bind  CPUs  from
              processor  group 0 and `cpus_allowed' values between 40 and 71 will bind CPUs from processor group
              1. When using `cpus_allowed_policy=shared' all CPUs specified by a  single  `cpus_allowed'  option
              must  be  from the same processor group. For Windows fio builds not built for Windows 7, CPUs will
              only be selected from (and be relative to) whatever processor group fio happens to be  running  in
              and CPUs from other processor groups cannot be used.

       <b>cpus_allowed_policy</b>=<u>str</u>
              Set  the policy of how fio distributes the CPUs specified by <b>cpus_allowed</b> or <b>cpumask</b>. Two policies
              are supported:

                     <b>shared</b> All jobs will share the CPU set specified.

                     <b>split</b>  Each job will get a unique CPU from the CPU set.

              <b>shared</b> is the default behavior, if the option isn't specified. If <b>split</b>  is  specified,  then  fio
              will  assign  one  cpu  per  job.  If not enough CPUs are given for the jobs listed, then fio will
              roundrobin the CPUs in the set.

       <b>cpumask</b>=<u>int</u>
              Set the CPU affinity of this job. The parameter given is a bit mask of allowed CPUs  the  job  may
              run on. So if you want the allowed CPUs to be 1 and 5, you would pass the decimal value of (1 &lt;&lt; 1
              |  1  &lt;&lt;  5),  or  34.  See man <b><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></b>(2). This may not work on all supported operating
              systems or kernel versions. This option doesn't work well for a higher CPU count than what you can
              store in an integer mask, so it can only control cpus 1-32. For boxes with larger CPU counts,  use
              <b>cpus_allowed</b>.

       <b>numa_cpu_nodes</b>=<u>str</u>
              Set  this  job  running on specified NUMA nodes' CPUs. The arguments allow comma delimited list of
              cpu numbers, A-B ranges, or `all'. Note, to enable NUMA options support, fio must be  built  on  a
              system with libnuma-dev(el) installed.

       <b>numa_mem_policy</b>=<u>str</u>
              Set this job's memory policy and corresponding NUMA nodes. Format of the arguments:

                     &lt;mode&gt;[:&lt;nodelist&gt;]

              `mode'  is  one  of  the  following  memory policies: `default', `prefer', `bind', `interleave' or
              `local'. For `default' and `local' memory policies, no node needs to be specified.  For  `prefer',
              only  one  node  is allowed. For `bind' and `interleave' the `nodelist' may be as follows: a comma
              delimited list of numbers, A-B ranges, or `all'.

       <b>cgroup</b>=<u>str</u>
              Add job to this control group. If it doesn't exist, it will be created. The  system  must  have  a
              mounted cgroup blkio mount point for this to work. If your system doesn't have it mounted, you can
              do so with:

                     # mount -t cgroup -o blkio none /cgroup

       <b>cgroup_weight</b>=<u>int</u>
              Set  the  weight  of  the  cgroup to this value. See the documentation that comes with the kernel,
              allowed values are in the range of 100..1000.

       <b>cgroup_nodelete</b>=<u>bool</u>
              Normally fio will delete the cgroups it has created after the job  completion.  To  override  this
              behavior  and  to leave cgroups around after the job completion, set `cgroup_nodelete=1'. This can
              be useful if one wants to inspect various cgroup files after job completion. Default: false.

       <b>flow_id</b>=<u>int</u>
              The ID of the flow. If not specified, it defaults to being a global flow. See <b>flow</b>.

       <b>flow</b>=<u>int</u>
              Weight in token-based flow control. If this value is used, then fio regulates the activity between
              two or more jobs sharing the same flow_id.  Fio attempts to keep each job activity proportional to
              other jobs' activities in the same flow_id group, with respect to requested weight per job.   That
              is,  if  one job has `flow=3', another job has `flow=2' and another with `flow=1`, then there will
              be a roughly 3:2:1 ratio in how much one runs vs the others.

       <b>flow_sleep</b>=<u>int</u>
              The period of time, in microseconds, to wait after the flow counter has  exceeded  its  proportion
              before retrying operations.

       <b>stonewall</b>, <b>wait_for_previous</b>
              Wait  for  preceding jobs in the job file to exit, before starting this one. Can be used to insert
              serialization points in the job file. A stone wall also implies starting a  new  reporting  group,
              see  <b>group_reporting</b>.  Optionally  you can use `stonewall=0` to disable or `stonewall=1` to enable
              it.

       <b>exitall</b>
              By default, fio will continue running all other jobs when one job finishes.  Sometimes this is not
              the desired action. Setting <b>exitall</b> will instead make fio terminate all jobs in the same group, as
              soon as one job of that group finishes.

       <b>exit_what</b>=<u>str</u>
              By default, fio will continue running all other jobs when one job finishes.  Sometimes this is not
              the desired action. Setting <b>exitall</b> will instead make fio terminate all jobs in  the  same  group.
              The option <b>exit_what</b> allows you to control which jobs get terminated when <b>exitall</b> is enabled.  The
              default value is <b>group</b>.  The allowed values are:

                     <b>all</b>    terminates all jobs.

                     <b>group</b>  is the default and does not change the behaviour of <b>exitall</b>.

                     <b>stonewall</b>
                            terminates all currently running jobs across all groups and continues execution with
                            the next stonewalled group.

       <b>exec_prerun</b>=<u>str</u>
              Before  running this job, issue the command specified through <b><a href="../man3/system.3.html">system</a></b>(3). Output is redirected in a
              file called `jobname.prerun.txt'.

       <b>exec_postrun</b>=<u>str</u>
              After the job completes, issue the command specified though <b><a href="../man3/system.3.html">system</a></b>(3). Output is redirected  in  a
              file called `jobname.postrun.txt'.

       <b>uid</b>=<u>int</u>
              Instead  of  running as the invoking user, set the user ID to this value before the thread/process
              does any work.

       <b>gid</b>=<u>int</u>
              Set group ID, see <b>uid</b>.

   <b>Verification</b>
       <b>verify_only</b>
              Do not perform specified workload, only verify data still  matches  previous  invocation  of  this
              workload.  This option allows one to check data multiple times at a later date without overwriting
              it. This option makes sense only for workloads that write data, and  does  not  support  workloads
              with the <b>time_based</b> option set.

       <b>do_verify</b>=<u>bool</u>
              Run the verify phase after a write phase. Only valid if <b>verify</b> is set. Default: true.

       <b>verify</b>=<u>str</u>
              If  writing  to  a  file,  fio  can verify the file contents after each iteration of the job. Each
              verification method also implies verification of special header, which is written to the beginning
              of each block. This header also includes meta information, like offset of the block, block number,
              timestamp when block was written, etc. <b>verify</b> can be  combined  with  <b>verify_pattern</b>  option.  The
              allowed values are:

                     <b>md5</b>    Use an md5 sum of the data area and store it in the header of each block.

                     <b>crc64</b>  Use  an  experimental  crc64 sum of the data area and store it in the header of each
                            block.

                     <b>crc32c</b> Use a crc32c sum of the data area and store it in the header  of  each  block.  This
                            will  automatically  use  hardware acceleration (e.g. SSE4.2 on an x86 or CRC crypto
                            extensions on ARM64) but will fall  back  to  software  crc32c  if  none  is  found.
                            Generally the fastest checksum fio supports when hardware accelerated.

                     <b>crc32c-intel</b>
                            Synonym for crc32c.

                     <b>crc32</b>  Use a crc32 sum of the data area and store it in the header of each block.

                     <b>crc16</b>  Use a crc16 sum of the data area and store it in the header of each block.

                     <b>crc7</b>   Use a crc7 sum of the data area and store it in the header of each block.

                     <b>xxhash</b> Use  xxhash  as  the checksum function. Generally the fastest software checksum that
                            fio supports.

                     <b>sha512</b> Use sha512 as the checksum function.

                     <b>sha256</b> Use sha256 as the checksum function.

                     <b>sha1</b>   Use optimized sha1 as the checksum function.

                     <b>sha3-224</b>
                            Use optimized sha3-224 as the checksum function.

                     <b>sha3-256</b>
                            Use optimized sha3-256 as the checksum function.

                     <b>sha3-384</b>
                            Use optimized sha3-384 as the checksum function.

                     <b>sha3-512</b>
                            Use optimized sha3-512 as the checksum function.

                     <b>meta</b>   This option is deprecated,  since  now  meta  information  is  included  in  generic
                            verification   header  and  meta  verification  happens  by  default.  For  detailed
                            information see the description of the <b>verify</b> setting. This option is  kept  because
                            of compatibility's sake with old configurations. Do not use it.

                     <b>pattern</b>
                            Verify  a strict pattern. Normally fio includes a header with some basic information
                            and checksumming, but if this option is set, only  the  specific  pattern  set  with
                            <b>verify_pattern</b> is verified.

                     <b>null</b>   Only  pretend  to verify. Useful for testing internals with `ioengine=null', not for
                            much else.

              This option can be used for repeated burn-in tests of a system to make sure that the written  data
              is also correctly read back. If the data direction given is a read or random read, fio will assume
              that it should verify a previously written file. If the data direction includes any form of write,
              the verify will be of the newly written data.

              To  avoid  false  verification  errors, do not use the norandommap option when verifying data with
              async I/O engines and I/O depths &gt; 1.  Or use  the  norandommap  and  the  lfsr  random  generator
              together to avoid writing to the same offset with multiple outstanding I/Os.

       <b>verify_offset</b>=<u>int</u>
              Swap  the  verification header with data somewhere else in the block before writing. It is swapped
              back before verifying.

       <b>verify_interval</b>=<u>int</u>
              Write the verification header at a finer granularity than the <b>blocksize</b>. It will  be  written  for
              chunks the size of <b>verify_interval</b>. <b>blocksize</b> should divide this evenly.

       <b>verify_pattern</b>=<u>str</u>
              If  set,  fio  will  fill  the I/O buffers with this pattern. Fio defaults to filling with totally
              random bytes, but sometimes it's interesting to fill with a known  pattern  for  I/O  verification
              purposes.  Depending on the width of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the
              time (it can be either a decimal or a hex number). The <b>verify_pattern</b>  if  larger  than  a  32-bit
              quantity  has  to  be  a  hex  number that starts with either "0x" or "0X". Use with <b>verify</b>. Also,
              <b>verify_pattern</b> supports %o format, which means that for each block offset will be written and then
              verified back, e.g.:

                     verify_pattern=%o

              Or use combination of everything:

                     verify_pattern=0xff%o"abcd"-12

       <b>verify_fatal</b>=<u>bool</u>
              Normally fio will keep checking the entire  contents  before  quitting  on  a  block  verification
              failure.  If  this  option  is  set, fio will exit the job on the first observed failure. Default:
              false.

       <b>verify_dump</b>=<u>bool</u>
              If set, dump the contents of both the original data block and the data block we read off  disk  to
              files.  This  allows  later analysis to inspect just what kind of data corruption occurred. Off by
              default.

       <b>verify_async</b>=<u>int</u>
              Fio will normally verify I/O inline from the submitting  thread.  This  option  takes  an  integer
              describing  how  many async offload threads to create for I/O verification instead, causing fio to
              offload the duty of verifying I/O contents to one or more separate threads. If using this  offload
              option,  even  sync  I/O  engines  can  benefit from using an <b>iodepth</b> setting higher than 1, as it
              allows them to have I/O in flight while verifies are running.  Defaults to 0 async  threads,  i.e.
              verification is not asynchronous.

       <b>verify_async_cpus</b>=<u>str</u>
              Tell fio to set the given CPU affinity on the async I/O verification threads. See <b>cpus_allowed</b> for
              the format used.

       <b>verify_backlog</b>=<u>int</u>
              Fio  will  normally  verify  the  written contents of a job that utilizes verify once that job has
              completed. In other words, everything is written then everything is read back  and  verified.  You
              may  want  to  verify  continually  instead  for  a  variety  of reasons. Fio stores the meta data
              associated with an I/O block in memory, so for large verify workloads, quite a bit of memory would
              be used up holding this meta data. If this option is enabled, fio will write only N blocks  before
              verifying these blocks.

       <b>verify_backlog_batch</b>=<u>int</u>
              Control  how many blocks fio will verify if <b>verify_backlog</b> is set. If not set, will default to the
              value  of  <b>verify_backlog</b>  (meaning  the  entire  queue   is   read   back   and   verified).   If
              <b>verify_backlog_batch</b>  is  less  than  <b>verify_backlog</b>  then  not  all  blocks  will be verified, if
              <b>verify_backlog_batch</b> is larger than <b>verify_backlog</b>, some blocks will be verified more than once.

       <b>verify_state_save</b>=<u>bool</u>
              When a job exits during the write phase of a verify workload, save its current state. This  allows
              fio  to  replay  up until that point, if the verify state is loaded for the verify read phase. The
              format of the filename is, roughly:

                     &lt;type&gt;-&lt;jobname&gt;-&lt;jobindex&gt;-verify.state.

              &lt;type&gt; is "local" for a local  run,  "sock"  for  a  client/server  socket  connection,  and  "ip"
              (192.168.0.1, for instance) for a networked client/server connection. Defaults to true.

       <b>verify_state_load</b>=<u>bool</u>
              If  a verify termination trigger was used, fio stores the current write state of each thread. This
              can be used at verification time so that  fio  knows  how  far  it  should  verify.  Without  this
              information,  fio  will  run  a  full verification pass, according to the settings in the job file
              used. Default false.

       <b>experimental_verify</b>=<u>bool</u>
              Enable experimental verification. Standard verify records I/O metadata for later  use  during  the
              verification  phase.  Experimental  verify  instead resets the file after the write phase and then
              replays I/Os for the verification phase.

       <b>verify_write_sequence</b>=<u>bool</u>
              Verify the header write sequence number. In a scenario with multiple  jobs,  verification  of  the
              write  sequence  number  may  fail.  Disabling  this  option  will mean that write sequence number
              checking is skipped. Doing that can be useful for testing atomic writes, as it means that checksum
              verification can still be attempted. For when <b>atomic</b> is enabled, checksum verification is expected
              to succeed (while write sequence checking can still fail).

       <b>trim_percentage</b>=<u>int</u>
              Number of verify blocks to discard/trim.

       <b>trim_verify_zero</b>=<u>bool</u>
              Verify that trim/discarded blocks are returned as zeros.

       <b>trim_backlog</b>=<u>int</u>
              Verify that trim/discarded blocks are returned as zeros.

       <b>trim_backlog_batch</b>=<u>int</u>
              Trim this number of I/O blocks.

   <b>Steady</b> <b>state</b>
       <b>steadystate</b>=<u>str:float</u>, <b>ss</b>=<u>str:float</u>
              Define the criterion and limit  for  assessing  steady  state  performance.  The  first  parameter
              designates the criterion whereas the second parameter sets the threshold. When the criterion falls
              below  the threshold for the specified duration, the job will stop. For example, `iops_slope:0.1%'
              will direct fio to terminate the job when the least squares regression slope falls below  0.1%  of
              the  mean  IOPS.  If <b>group_reporting</b> is enabled this will apply to all jobs in the group. Below is
              the list of available steady state assessment criteria. All assessments are carried out using only
              data from the rolling collection window. Threshold limits can be expressed as a fixed value or  as
              a percentage of the mean in the collection window.

              When  using this feature, most jobs should include the <b>time_based</b> and <b>runtime</b> options or the <b>loops</b>
              option so that fio does not stop running after it has covered  the  full  size  of  the  specified
              file(s) or device(s).

                            <b>iops</b>   Collect  IOPS  data.  Stop  the  job  if all individual IOPS measurements are
                                   within the specified limit of the mean IOPS (e.g., `iops:2'  means  that  all
                                   individual  IOPS  values  must  be  within 2 of the mean, whereas `iops:0.2%'
                                   means that all individual IOPS values must be within 0.2% of the mean IOPS to
                                   terminate the job).

                            <b>iops_slope</b>
                                   Collect IOPS data and calculate the least squares regression slope. Stop  the
                                   job if the slope falls below the specified limit.

                            <b>bw</b>     Collect bandwidth data. Stop the job if all individual bandwidth measurements
                                   are within the specified limit of the mean bandwidth.

                            <b>bw_slope</b>
                                   Collect bandwidth data and calculate the least squares regression slope. Stop
                                   the job if the slope falls below the specified limit.

              <b>steadystate_duration</b>=<u>time</u>, <b>ss_dur</b>=<u>time</u>
                     A  rolling  window  of  this  duration  will be used to judge whether steady state has been
                     reached. Data will be collected every <b>ss_interval</b>. The default is 0 which  disables  steady
                     state detection. When the unit is omitted, the value is interpreted in seconds.

              <b>steadystate_ramp_time</b>=<u>time</u>, <b>ss_ramp</b>=<u>time</u>
                     Allow  the  job  to  run  for  the  specified duration before beginning data collection for
                     checking the steady state job termination criterion. The default is 0.  When  the  unit  is
                     omitted, the value is interpreted in seconds.

              <b>steadystate_check_interval</b>=<u>time</u>, <b>ss_interval</b>=<u>time</u>
                     The  values  suring  the  rolling  window will be collected with a period of this value. If
                     <b>ss_interval</b> is 30s and <b>ss_dur</b> is 300s, 10 measurements will be taken.  Default  is  1s  but
                     that  might  not converge, especially for slower devices, so set this accordingly. When the
                     unit is omitted, the value is interpreted in seconds.

   <b>Measurements</b> <b>and</b> <b>reporting</b>
       <b>per_job_logs</b>=<u>bool</u>
              If set to true, fio generates bw/clat/iops logs with per job unique filenames.  If set  to  false,
              jobs  with  identical  names will share a log filename. Note that when this option is set to false
              log files will be opened in append mode and if log files already exist the previous contents  will
              not be overwritten. Default: true.

       <b>group_reporting</b>
              It may sometimes be interesting to display statistics for groups of jobs as a whole instead of for
              each  individual  job.  This  is  especially  true  if  <b>numjobs</b>  is  used;  looking  at individual
              thread/process output quickly becomes unwieldy. To see the final report per-group instead of  per-
              job,  use  <b>group_reporting</b>.  Jobs  in  a  file will be part of the same reporting group, unless if
              separated by a <b>stonewall</b>, or by using <b>new_group</b>.

              NOTE: When <b>group_reporting</b> is used along with <b>json</b> output, there are  certain  per-job  properties
              which  can  be  different  between jobs but do not have a natural group-level equivalent. Examples
              include <b>kb_base</b>, <b>unit_base</b>, <b>sig_figs</b>, <b>thread_number</b>, <b>pid</b>, and <b>job_start</b>. For these properties, the
              values for the first job are recorded for the group.

       <b>new_group</b>
              Start a new reporting group. See: <b>group_reporting</b>. If not given, all jobs in a file will  be  part
              of the same reporting group, unless separated by a <b>stonewall</b>.

       <b>stats</b>=<u>bool</u>
              By  default,  fio collects and shows final output results for all jobs that run. If this option is
              set to 0, then fio will ignore it in the final stat output.

       <b>write_bw_log</b>=<u>str</u>
              If given, write a bandwidth log for this job. Can be used to store data of the  bandwidth  of  the
              jobs in their lifetime.

              If  no  str argument is given, the default filename of `jobname_type.x.log' is used. Even when the
              argument is given, fio will still append the type of log. So if one specifies:

                     write_bw_log=foo

              The actual log name will be `foo_bw.x.log' where `x' is the index of the job (1..N, where N is the
              number of jobs). If <b>per_job_logs</b> is false, then the filename will not include the `.x` job index.

              The included <b>fio_generate_plots</b> script uses gnuplot to turn these text files into nice graphs. See
              the <b>LOG</b> <b>FILE</b> <b>FORMATS</b> section for how data is structured within the file.

       <b>write_lat_log</b>=<u>str</u>
              Same as <b>write_bw_log</b>,  except  this  option  creates  I/O  submission  (e.g.,  `name_slat.x.log'),
              completion  (e.g.,  `name_clat.x.log'),  and total (e.g., `name_lat.x.log') latency files instead.
              See <b>write_bw_log</b> for details about the filename format and the <b>LOG</b> <b>FILE</b> <b>FORMATS</b>  section  for  how
              data is structured within the files.

       <b>write_hist_log</b>=<u>str</u>
              Same as <b>write_bw_log</b> but writes an I/O completion latency histogram file (e.g., `name_hist.x.log')
              instead.  Note  that  this  file  will  be  empty  unless  <b>log_hist_msec</b>  has  also been set.  See
              <b>write_bw_log</b> for details about the filename format and the <b>LOG</b> <b>FILE</b> <b>FORMATS</b> section for  how  data
              is structured within the file.

       <b>write_iops_log</b>=<u>str</u>
              Same  as  <b>write_bw_log</b>,  but  writes  an  IOPS file (e.g.  `name_iops.x.log`) instead. Because fio
              defaults to individual I/O logging, the value entry in the IOPS log  will  be  1  unless  windowed
              logging  (see  <b>log_avg_msec</b>)  has  been  enabled.  See <b>write_bw_log</b> for details about the filename
              format and <b>LOG</b> <b>FILE</b> <b>FORMATS</b> for how data is structured within the file.

       <b>log_entries</b>=<u>int</u>
              By default, fio will log an entry in the iops, latency, or bw log for every  I/O  that  completes.
              The initial number of I/O log entries is 1024.  When the log entries are all used, new log entries
              are  dynamically  allocated.  This dynamic log entry allocation may negatively impact time-related
              statistics such as I/O tail latencies (e.g. 99.9th percentile  completion  latency).  This  option
              allows  specifying  a larger initial number of log entries to avoid run-time allocation of new log
              entries, resulting in more precise time-related I/O statistics.  Also see  <b>log_avg_msec</b>  as  well.
              Defaults to 1024.

       <b>log_avg_msec</b>=<u>int</u>
              By  default,  fio  will log an entry in the iops, latency, or bw log for every I/O that completes.
              When writing to the disk log, that can quickly grow to a very  large  size.  Setting  this  option
              directs  fio to instead record an average over the specified duration for each log entry, reducing
              the resolution of the log.  When the job completes, fio will flush  any  accumulated  latency  log
              data,  so  the  final  log interval may not match the value specified by this option and there may
              even be duplicate timestamps. See <b>log_window_value</b> as well. Defaults to  0,  logging  entries  for
              each I/O. Also see <b>LOG</b> <b>FILE</b> <b>FORMATS</b> section.

       <b>log_hist_msec</b>=<u>int</u>
              Same  as  <b>log_avg_msec</b>,  but  logs  entries  for  completion latency histograms. Computing latency
              percentiles from averages of intervals using <b>log_avg_msec</b> is inaccurate. Setting this option makes
              fio log histogram entries over the specified period of time, reducing  log  sizes  for  high  IOPS
              devices  while  retaining percentile accuracy. See <b>log_hist_coarseness</b> and <b>write_hist_log</b> as well.
              Defaults to 0, meaning histogram logging is disabled.

       <b>log_hist_coarseness</b>=<u>int</u>
              Integer ranging from 0 to 6, defining the coarseness of  the  resolution  of  the  histogram  logs
              enabled  with  <b>log_hist_msec</b>.  For  each  increment  in coarseness, fio outputs half as many bins.
              Defaults to 0, for which histogram logs contain 1216 latency bins. See <b>LOG</b> <b>FILE</b> <b>FORMATS</b> section.

       <b>log_window_value</b>=<u>str</u>, <b>log_max_value</b>=<u>str</u>
              If <b>log_avg_msec</b> is set, fio by default logs the average over that window.  This option  determines
              whether  fio  logs  the average, maximum or both the values over the window. This only affects the
              latency logging, as both average and maximum values for iops or bw  log  will  be  same.  Accepted
              values are:

              <b>avg</b>    Log average value over the window. The default.

              <b>max</b>    Log maximum value in the window.

              <b>both</b>   Log both average and maximum value over the window.

              <b>0</b>      Backward-compatible alias for <b>avg</b>.

              <b>1</b>      Backward-compatible alias for <b>max</b>.

       <b>log_offset</b>=<u>bool</u>
              If  this  is  set, the iolog options will include the byte offset for the I/O entry as well as the
              other data values. Defaults to 0 meaning that offsets are not present in logs. Also see  <b>LOG</b>  <b>FILE</b>
              <b>FORMATS</b> section.

       <b>log_prio</b>=<u>bool</u>
              If  this is set, the `Command priority` field in <b>LOG</b> <b>FILE</b> <b>FORMATS</b> shows the priority value and the
              IO priority class of the command.  Otherwise, the field shows if the command has  the  highest  RT
              priority class or not. Also see <b>LOG</b> <b>FILE</b> <b>FORMATS</b> section.

       <b>log_issue_time</b>=<u>bool</u>
              If this is set, the iolog options will include the command issue time for the I/O entry as well as
              the  other  data  values.  Defaults to 0 meaning that command issue times are not present in logs.
              Also see <b>LOG</b> <b>FILE</b> <b>FORMATS</b> section.  This option shall  be  set  together  with  <b>write_lat_log</b>  and
              <b>log_offset</b>.

       <b>log_compression</b>=<u>int</u>
              If  this  is  set,  fio will compress the I/O logs as it goes, to keep the memory footprint lower.
              When a log reaches the specified size, that chunk is removed and  compressed  in  the  background.
              Given  that  I/O logs are fairly highly compressible, this yields a nice memory savings for longer
              runs. The downside is that the compression will consume some background  CPU  cycles,  so  it  may
              impact  the  run.  This, however, is also true if the logging ends up consuming most of the system
              memory. So pick your poison. The I/O logs are saved normally at the end of a run, by decompressing
              the chunks and storing them in the specified log file. This feature depends on the availability of
              zlib.

       <b>log_compression_cpus</b>=<u>str</u>
              Define the set of CPUs that are allowed to handle online log compression for the  I/O  jobs.  This
              can  provide better isolation between performance sensitive jobs, and background compression work.
              See <b>cpus_allowed</b> for the format used.

       <b>log_store_compressed</b>=<u>bool</u>
              If set, fio will store the log files in a compressed format. They can be  decompressed  with  fio,
              using the <b>--inflate-log</b> command line parameter. The files will be stored with a `.fz' suffix.

       <b>log_unix_epoch</b>=<u>bool</u>
              Backward-compatible alias for <b>log_alternate_epoch</b>.

       <b>log_alternate_epoch</b>=<u>bool</u>
              If  set,  fio  will  log  timestamps  based  on  the  epoch  used  by  the  clock specified in the
              <b>log_alternate_epoch_clock_id</b> option, to the log files produced by enabling write_type_log for each
              log type, instead of the default zero-based timestamps.

       <b>log_alternate_epoch_clock_id</b>=<u>int</u>
              Specifies  the  clock_id  to  be  used  by  clock_gettime  to  obtain  the  alternate   epoch   if
              <b>log_alternate_epoch</b> is true. Otherwise has no effect. Default value is 0, or CLOCK_REALTIME.

       <b>block_error_percentiles</b>=<u>bool</u>
              If  set,  record  errors in trim block-sized units from writes and trims and output a histogram of
              how many trims it took to get to errors, and what kind of error was encountered.

       <b>bwavgtime</b>=<u>int</u>
              Average the calculated bandwidth over the given time. Value is specified in milliseconds.  If  the
              job  also  does  bandwidth  logging  through  <b>write_bw_log</b>,  then  the  minimum of this option and
              <b>log_avg_msec</b> will be used. Default: 500ms.

       <b>iopsavgtime</b>=<u>int</u>
              Average the calculated IOPS over the given time. Value is specified in milliseconds.  If  the  job
              also  does  IOPS  logging through <b>write_iops_log</b>, then the minimum of this option and <b>log_avg_msec</b>
              will be used. Default: 500ms.

       <b>disk_util</b>=<u>bool</u>
              Generate disk utilization statistics, if the platform supports it.  Default: true.

       <b>disable_lat</b>=<u>bool</u>
              Disable measurements of total latency numbers. Useful only for cutting back the number of calls to
              <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2), as that does impact performance at really high IOPS rates. Note  that  to  really
              get  rid  of  a  large  amount  of  these  calls,  this  option must be used with <b>disable_slat</b> and
              <b>disable_bw_measurement</b> as well.

       <b>disable_clat</b>=<u>bool</u>
              Disable measurements of completion latency numbers. See <b>disable_lat</b>.

       <b>disable_slat</b>=<u>bool</u>
              Disable measurements of submission latency numbers. See <b>disable_lat</b>.

       <b>disable_bw_measurement</b>=<u>bool</u>, <b>disable_bw</b>=<u>bool</u>
              Disable measurements of throughput/bandwidth numbers. See <b>disable_lat</b>.

       <b>slat_percentiles</b>=<u>bool</u>
              Report submission  latency  percentiles.  Submission  latency  is  not  recorded  for  synchronous
              ioengines.

       <b>clat_percentiles</b>=<u>bool</u>
              Report completion latency percentiles.

       <b>lat_percentiles</b>=<u>bool</u>
              Report  total  latency  percentiles. Total latency is the sum of submission latency and completion
              latency.

       <b>percentile_list</b>=<u>float_list</u>
              Overwrite the default list of percentiles for latencies and the block error histogram. Each number
              is a floating point number in the range (0,100], and the maximum length of the list is 20. Use ':'
              to separate the numbers. For example, `--percentile_list=99.5:99.9' will cause fio to  report  the
              latency durations below which 99.5% and 99.9% of the observed latencies fell, respectively.

       <b>significant_figures</b>=<u>int</u>
              If  using  <b>--output-format</b>  of  `normal', set the significant figures to this value. Higher values
              will yield more precise IOPS and throughput units, while  lower  values  will  round.  Requires  a
              minimum value of 1 and a maximum value of 10. Defaults to 4.

   <b>Error</b> <b>handling</b>
       <b>exitall_on_error</b>
              When one job finishes in error, terminate the rest. The default is to wait for each job to finish.

       <b>continue_on_error</b>=<u>str</u>
              Normally  fio  will  exit  the  job on the first observed failure. If this option is set, fio will
              continue the job when there is a 'non-fatal error' (EIO or EILSEQ) until the runtime  is  exceeded
              or  the I/O size specified is completed. If this option is used, there are two more stats that are
              appended, the total error count and the first error. The error field given in  the  stats  is  the
              first error that was hit during the run.

              Note: a write error from the device may go unnoticed by fio when using buffered IO, as the write()
              (or  similar)  system  call  merely  dirties  the kernel pages, unless `sync' or `direct' is used.
              Device IO errors occur when the dirty data is actually written out to disk. If fully  sync  writes
              aren't desirable, `fsync' or `fdatasync' can be used as well. This is specific to writes, as reads
              are always synchronous.

                     The allowed values are:

                                   <b>none</b>   Exit on any I/O or verify errors.

                                   <b>read</b>   Continue on read errors, exit on all others.

                                   <b>write</b>  Continue on write errors, exit on all others.

                                   <b>io</b>     Continue on any I/O error, exit on all others.

                                   <b>verify</b> Continue on verify errors, exit on all others.

                                   <b>all</b>    Continue on all errors.

                                   <b>0</b>      Backward-compatible alias for 'none'.

                                   <b>1</b>      Backward-compatible alias for 'all'.

                     <b>ignore_error</b>=<u>str</u>
                            Sometimes  you  want  to ignore some errors during test in that case you can specify
                            error list for each error type, instead of only being able  to  ignore  the  default
                            'non-fatal               error'               using               <b>continue_on_error</b>.
                            `ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST' errors for  given  error
                            type  is  separated  with  ':'. Error may be symbol ('ENOSPC', 'ENOMEM') or integer.
                            Example:

                                   ignore_error=EAGAIN,ENOSPC:122

                            This option will ignore EAGAIN from READ, and ENOSPC  and  122(EDQUOT)  from  WRITE.
                            This  option  works by overriding <b>continue_on_error</b> with the list of errors for each
                            error type if any.

                     <b>error_dump</b>=<u>bool</u>
                            If set dump every error even if it is non fatal, true by default. If  disabled  only
                            fatal error will be dumped.

   <b>Running</b> <b>predefined</b> <b>workloads</b>
       Fio includes predefined profiles that mimic the I/O workloads generated by other tools.

       <b>profile</b>=<u>str</u>
              The predefined workload to run. Current profiles are:

                     <b>tiobench</b>
                            Threaded I/O bench (tiotest/tiobench) like workload.

                     <b>act</b>    Aerospike Certification Tool (ACT) like workload.

       To view a profile's additional options use <b>--cmdhelp</b> after specifying the profile. For example:

              $ fio --profile=act --cmdhelp

   <b>Act</b> <b>profile</b> <b>options</b>
       <b>device-names</b>=<u>str</u>
              Devices to use.

       <b>load</b>=<u>int</u>
              ACT load multiplier. Default: 1.

       <b>test-duration</b>=<b>time</b>
              How  long  the  entire test takes to run. When the unit is omitted, the value is given in seconds.
              Default: 24h.

       <b>threads-per-queue</b>=<b>int</b>
              Number of read I/O threads per device. Default: 8.

       <b>read-req-num-512-blocks</b>=<b>int</b>
              Number of 512B blocks to read at the time. Default: 3.

       <b>large-block-op-kbytes</b>=<b>int</b>
              Size of large block ops in KiB (writes). Default: 131072.

       <b>prep</b>   Set to run ACT prep phase.

   <b>Tiobench</b> <b>profile</b> <b>options</b>
       <b>size</b>=<b>str</b>
              Size in MiB.

       <b>block</b>=<b>int</b>
              Block size in bytes. Default: 4096.

       <b>numruns</b>=<b>int</b>
              Number of runs.

       <b>dir</b>=<b>str</b>
              Test directory.

       <b>threads</b>=<b>int</b>
              Number of threads.

</pre><h4><b>OUTPUT</b></h4><pre>
       Fio spits out a lot of output. While running, fio will display the status of the jobs created. An example
       of that would be:

                 Jobs: 1 (f=1): [<a href="../man1/_.1.html">_</a>(1),<a href="../man1/M.1.html">M</a>(1)][24.8%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 01m:31s]

       The characters inside the first set of square brackets denote the current  status  of  each  thread.  The
       first  character  is the first job defined in the job file, and so forth. The possible values (in typical
       life cycle order) are:

              <b>P</b>      Thread setup, but not started.
              <b>C</b>      Thread created.
              <b>I</b>      Thread initialized, waiting or generating necessary data.
              <b>p</b>      Thread running pre-reading file(s).
              <b>/</b>      Thread is in ramp period.
              <b>R</b>      Running, doing sequential reads.
              <b>r</b>      Running, doing random reads.
              <b>W</b>      Running, doing sequential writes.
              <b>w</b>      Running, doing random writes.
              <b>M</b>      Running, doing mixed sequential reads/writes.
              <b>m</b>      Running, doing mixed random reads/writes.
              <b>D</b>      Running, doing sequential trims.
              <b>d</b>      Running, doing random trims.
              <b>F</b>      Running, currently waiting for <b><a href="../man2/fsync.2.html">fsync</a></b>(2).
              <b>V</b>      Running, doing verification of written data.
              <b>f</b>      Thread finishing.
              <b>E</b>      Thread exited, not reaped by main thread yet.
              <b>-</b>      Thread reaped.
              <b>X</b>      Thread reaped, exited with an error.
              <b>K</b>      Thread reaped, exited due to signal.

       Fio will condense the thread string as not to take up more space on the command  line  than  needed.  For
       instance, if you have 10 readers and 10 writers running, the output would look like this:

                 Jobs: 20 (f=20): [<a href="../man10/R.10.html">R</a>(10),<a href="../man10/W.10.html">W</a>(10)][4.0%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 57m:36s]

       Note  that  the  status  string  is  displayed  in  order, so it's possible to tell which of the jobs are
       currently doing what. In the example above this means that jobs 1--10 are readers and 11--20 are writers.

       The other values are fairly self explanatory -- number of threads currently running and  doing  I/O,  the
       number  of  currently  open  files  (f=), the estimated completion percentage, the rate of I/O since last
       check (read speed listed first, then write speed and optionally trim speed) in  terms  of  bandwidth  and
       IOPS,  and  time  to completion for the current running group. It's impossible to estimate runtime of the
       following groups (if any).

       When fio is done (or interrupted by Ctrl-C), it will show the data for each thread, group of threads, and
       disks in that order. For each overall thread (or group) the output looks like:

                 Client1: (groupid=0, jobs=1): err= 0: pid=16109: Sat Jun 24 12:07:54 2017
                   write: IOPS=88, BW=623KiB/s (638kB/s)(30.4MiB/50032msec)
                     slat (nsec): min=500, max=145500, avg=8318.00, stdev=4781.50
                     clat (usec): min=170, max=78367, avg=4019.02, stdev=8293.31
                      lat (usec): min=174, max=78375, avg=4027.34, stdev=8291.79
                     clat percentiles (usec):
                      |  1.00th=[  302],  5.00th=[  326], 10.00th=[  343], 20.00th=[  363],
                      | 30.00th=[  392], 40.00th=[  404], 50.00th=[  416], 60.00th=[  445],
                      | 70.00th=[  816], 80.00th=[ 6718], 90.00th=[12911], 95.00th=[21627],
                      | 99.00th=[43779], 99.50th=[51643], 99.90th=[68682], 99.95th=[72877],
                      | 99.99th=[78119]
                    bw (  KiB/s): min=  532, max=  686, per=0.10%, avg=622.87, stdev=24.82, samples=  100
                    iops        : min=   76, max=   98, avg=88.98, stdev= 3.54, samples=  100
                   lat (usec)   : 250=0.04%, 500=64.11%, 750=4.81%, 1000=2.79%
                   lat (msec)   : 2=4.16%, 4=1.84%, 10=4.90%, 20=11.33%, 50=5.37%
                   lat (msec)   : 100=0.65%
                   cpu          : usr=0.27%, sys=0.18%, ctx=12072, majf=0, minf=21
                   IO depths    : 1=85.0%, 2=13.1%, 4=1.8%, 8=0.1%, 16=0.0%, 32=0.0%, &gt;=64=0.0%
                      submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%
                      complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%
                      issued rwt: total=0,4450,0, short=0,0,0, dropped=0,0,0
                      latency   : target=0, window=0, percentile=100.00%, depth=8

       The job name (or first job's name when using <b>group_reporting</b>) is printed, along with the group id,  count
       of  jobs  being  aggregated,  last  error  id seen (which is 0 when there are no errors), pid/tid of that
       thread and the time the job/group completed. Below  are  the  I/O  statistics  for  each  data  direction
       performed (showing writes in the example above). In the order listed, they denote:

              <b>read/write/trim</b>
                     The  string  before  the  colon shows the I/O direction the statistics are for. <u>IOPS</u> is the
                     average I/Os performed per second. <u>BW</u> is the average bandwidth  rate  shown  as:  value  in
                     power  of  2  format  (value  in  power of 10 format). The last two values show: (total I/O
                     performed in power of 2 format / <u>runtime</u> of that thread).

              <b>slat</b>   Submission latency (<u>min</u> being the minimum, <u>max</u> being the maximum, <u>avg</u>  being  the  average,
                     <u>stdev</u>  being  the standard deviation). This is the time it took to submit the I/O. For sync
                     I/O this row is not  displayed  as  the  slat  is  really  the  completion  latency  (since
                     queue/complete  is one operation there).  This value can be in nanoseconds, microseconds or
                     milliseconds --- fio will choose the most appropriate base and print that (in  the  example
                     above  nanoseconds  was  the  best  scale).  Note:  in  <b>--minimal</b> mode latencies are always
                     expressed in microseconds.

              <b>clat</b>   Completion latency. Same names as slat, this denotes the time from submission to completion
                     of the I/O pieces. For sync I/O, clat will usually be equal (or very close) to  0,  as  the
                     time  from  submit  to  complete is basically just CPU time (I/O has already been done, see
                     slat explanation).

                     For file and directory operation engines, <b>clat</b> denotes the time to  complete  one  file  or
                     directory operation.

                     <b>filecreate</b> <b>engine</b>:  the time cost to create a new file

                     <b>filestat</b> <b>engine</b>:    the time cost to look up an existing file

                     <b>filedelete</b> <b>engine</b>:  the time cost to delete a file

                     <b>dircreate</b> <b>engine</b>:   the time cost to create a new directory

                     <b>dirstat</b> <b>engine</b>:     the time cost to look up an existing directory

                     <b>dirdelete</b> <b>engine</b>:   the time cost to delete a directory

              <b>lat</b>    Total latency. Same names as slat and clat, this denotes the time from when fio created the
                     I/O unit to completion of the I/O operation.

              <b>bw</b>     Bandwidth  statistics  based  on  measurements  from  discrete  intervals.  Fio continuosly
                     monitors bytes  transferred  and  I/O  operations  completed.  By  default  fio  calculates
                     bandwidth  in  each half-second interval (see <b>bwavgtime</b>) and reports descriptive statistics
                     for the measurements here. Same names as the xlat stats, but also includes  the  number  of
                     samples  taken  (<u>samples</u>)  and  an approximate percentage of total aggregate bandwidth this
                     thread received in its group (<u>per</u>). This last value is only really useful if the threads in
                     this group are on the same disk, since they are then competing for disk access.

                     For file and directory operation engines, <b>bw</b> is meaningless.

              <b>iops</b>   IOPS statistics based on  measurements  from  discrete  intervals.   For  details  see  the
                     description  for  <b>bw</b> above. See <b>iopsavgtime</b> to control the duration of the intervals.  Same
                     values reported here as for <b>bw</b> except for percentage.

                     For file and directory operation engines, <b>iops</b> is the most fundamental index to denote  the
                     performance.  It means how many files or directories can be operated per second.

                     <b>filecreate</b> <b>engine</b>:  number of files can be created per second

                     <b>filestat</b> <b>engine</b>:    number of files can be looked up per second

                     <b>filedelete</b> <b>engine</b>:  number of files can be deleted per second

                     <b>dircreate</b> <b>engine</b>:   number of directories can be created per second

                     <b>dirstat</b> <b>engine</b>:     number of directories can be looked up per second

                     <b>dirdelete</b> <b>engine</b>:   number of directories can be deleted per second

              <b>lat</b> <b>(nsec/usec/msec)</b>
                     The distribution of I/O completion latencies. This is the time from when I/O leaves fio and
                     when  it  gets completed. Unlike the separate read/write/trim sections above, the data here
                     and in the remaining sections apply to all I/Os for the reporting  group.  250=0.04%  means
                     that  0.04%  of the I/Os completed in under 250us. 500=64.11% means that 64.11% of the I/Os
                     required 250 to 499us for completion.

              <b>cpu</b>    CPU usage. User and system time, along with the number of context switches this thread went
                     through, usage of system and user time, and finally the number  of  major  and  minor  page
                     faults.  The  CPU  utilization  numbers  are averages for the jobs in that reporting group,
                     while the context and fault counters are summed.

              <b>IO</b> <b>depths</b>
                     The distribution of I/O depths over the job lifetime. The numbers are divided  into  powers
                     of  2 and each entry covers depths from that value up to those that are lower than the next
                     entry -- e.g., 16= covers depths from 16 to 31. Note that the  range  covered  by  a  depth
                     distribution  entry can be different to the range covered by the equivalent <b>submit</b>/<b>complete</b>
                     distribution entry.

              <b>IO</b> <b>submit</b>
                     How many pieces of I/O were submitting in a single submit call.  Each  entry  denotes  that
                     amount  and  below,  until  the  previous  entry  --  e.g., 16=100% means that we submitted
                     anywhere between 9 to 16 I/Os per submit call. Note that the  range  covered  by  a  <b>submit</b>
                     distribution  entry  can  be  different  to  the  range  covered  by  the  equivalent depth
                     distribution entry.

              <b>IO</b> <b>complete</b>
                     Like the above <b>submit</b> number, but for completions instead.

              <b>IO</b> <b>issued</b> <b>rwt</b>
                     The number of <b>read/write/trim</b> requests issued, and how many of them were short or dropped.

              <b>IO</b> <b>latency</b>
                     These values are for <b>latency_target</b> and related options. When these  options  are  engaged,
                     this section describes the I/O depth required to meet the specified latency target.

       After each client has been listed, the group statistics are printed. They will look like this:

                 Run status group 0 (all jobs):
                    READ: bw=20.9MiB/s (21.9MB/s), 10.4MiB/s-10.8MiB/s (10.9MB/s-11.3MB/s), io=64.0MiB (67.1MB), run=2973-3069msec
                   WRITE: bw=1231KiB/s (1261kB/s), 616KiB/s-621KiB/s (630kB/s-636kB/s), io=64.0MiB (67.1MB), run=52747-53223msec

       For each data direction it prints:

              <b>bw</b>     Aggregate  bandwidth of threads in this group followed by the minimum and maximum bandwidth
                     of all the threads in this group.  Values outside of brackets  are  power-of-2  format  and
                     those within are the equivalent value in a power-of-10 format.

              <b>io</b>     Aggregate I/O performed of all threads in this group. The format is the same as <b>bw</b>.

              <b>run</b>    The smallest and longest runtimes of the threads in this group.

       And finally, the disk statistics are printed. This is Linux specific.  They will look like this:

                   Disk stats (read/write):
                     sda: ios=16398/16511, sectors=32321/65472, merge=30/162, ticks=6853/819634, in_queue=826487, util=100.00%

       Each value is printed for both reads and writes, with reads first. The numbers denote:

              <b>ios</b>    Number of I/Os performed by all groups.

              <b>merge</b>  Number of merges performed by the I/O scheduler.

              <b>ticks</b>  Number of ticks we kept the disk busy.

              <b>in_queue</b>
                     Total time spent in the disk queue.

              <b>util</b>   The  disk utilization. A value of 100% means we kept the disk busy constantly, 50% would be
                     a disk idling half of the time.

       It is also possible to get fio to dump the current output while it is running,  without  terminating  the
       job.  To  do  that,  send  fio  the  USR1  signal.  You  can  also get regularly timed dumps by using the
       <b>--status-interval</b> parameter, or by creating a file in `<a href="file:/tmp">/tmp</a>' named `fio-dump-status'. If  fio  sees  this
       file, it will unlink it and dump the current output status.

</pre><h4><b>TERSE</b> <b>OUTPUT</b></h4><pre>
       For  scripted  usage where you typically want to generate tables or graphs of the results, fio can output
       the results in a semicolon separated format. The format is one long line of values, such as:

                 2;card0;0;0;7139336;121836;60004;1;10109;27.932460;116.933948;220;126861;3495.446807;1085.368601;226;126864;3523.635629;1089.012448;24063;99944;50.275485%;59818.274627;5540.657370;7155060;122104;60004;1;8338;29.086342;117.839068;388;128077;5032.488518;1234.785715;391;128085;5061.839412;1236.909129;23436;100928;50.287926%;59964.832030;5644.844189;14.595833%;19.394167%;123706;0;7313;0.1%;0.1%;0.1%;0.1%;0.1%;0.1%;100.0%;0.00%;0.00%;0.00%;0.00%;0.00%;0.00%;0.01%;0.02%;0.05%;0.16%;6.04%;40.40%;52.68%;0.64%;0.01%;0.00%;0.01%;0.00%;0.00%;0.00%;0.00%;0.00%
                 A description of this job goes here.

       The job description (if provided) follows on a second line for terse v2.  It appears on the same line for
       other terse versions.

       To enable terse output, use the <b>--minimal</b> or `--output-format=terse'  command  line  options.  The  first
       value  is  the  version of the terse output format. If the output has to be changed for some reason, this
       number will be incremented by 1 to signify that change.

       Split up, the format is as follows (comments in brackets denote when a field was  introduced  or  whether
       it's specific to some terse version):

                      terse version, fio version [v3], jobname, groupid, error

              <b>READ</b> <b>status:</b>

                      Total IO (KiB), bandwidth (KiB/sec), IOPS, runtime (msec)
                      Submission latency: min, max, mean, stdev (usec)
                      Completion latency: min, max, mean, stdev (usec)
                      Completion latency percentiles: 20 fields (see below)
                      Total latency: min, max, mean, stdev (usec)
                      Bw (KiB/s): min, max, aggregate percentage of total, mean, stdev, number of samples [v5]
                      IOPS [v5]: min, max, mean, stdev, number of samples

              <b>WRITE</b> <b>status:</b>

                      Total IO (KiB), bandwidth (KiB/sec), IOPS, runtime (msec)
                      Submission latency: min, max, mean, stdev (usec)
                      Completion latency: min, max, mean, stdev (usec)
                      Completion latency percentiles: 20 fields (see below)
                      Total latency: min, max, mean, stdev (usec)
                      Bw (KiB/s): min, max, aggregate percentage of total, mean, stdev, number of samples [v5]
                      IOPS [v5]: min, max, mean, stdev, number of samples

              <b>TRIM</b> <b>status</b> <b>[all</b> <b>but</b> <b>version</b> <b>3]:</b>

                      Fields are similar to <b>READ/WRITE</b> status.

              <b>CPU</b> <b>usage:</b>

                      user, system, context switches, major faults, minor faults

              <b>I/O</b> <b>depths:</b>

                      &lt;=1, 2, 4, 8, 16, 32, &gt;=64

              <b>I/O</b> <b>latencies</b> <b>microseconds:</b>

                      &lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000

              <b>I/O</b> <b>latencies</b> <b>milliseconds:</b>

                      &lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000, 2000, &gt;=2000

              <b>Disk</b> <b>utilization</b> <b>[v3]:</b>

                      disk name, read ios, write ios, read merges, write merges, read ticks, write ticks, time spent in queue, disk utilization percentage

              <b>Additional</b> <b>Info</b> <b>(dependent</b> <b>on</b> <b>continue_on_error,</b> <b>default</b> <b>off):</b>

                      total # errors, first error code

              <b>Additional</b> <b>Info</b> <b>(dependent</b> <b>on</b> <b>description</b> <b>being</b> <b>set):</b>

                      Text description

       Completion latency percentiles can be a grouping of up to 20 sets, so for the terse output fio writes all
       of them. Each field will look like this:

                 1.00%=6112

       which is the Xth percentile, and the `usec' latency associated with it.

       For  <b>Disk</b> <b>utilization</b>, all disks used by fio are shown. So for each disk there will be a disk utilization
       section.

       Below is a single line containing short names for each of the fields in the minimal output v3,  separated
       by semicolons:

                 terse_version_3;fio_version;jobname;groupid;error;read_kb;read_bandwidth_kb;read_iops;read_runtime_ms;read_slat_min_us;read_slat_max_us;read_slat_mean_us;read_slat_dev_us;read_clat_min_us;read_clat_max_us;read_clat_mean_us;read_clat_dev_us;read_clat_pct01;read_clat_pct02;read_clat_pct03;read_clat_pct04;read_clat_pct05;read_clat_pct06;read_clat_pct07;read_clat_pct08;read_clat_pct09;read_clat_pct10;read_clat_pct11;read_clat_pct12;read_clat_pct13;read_clat_pct14;read_clat_pct15;read_clat_pct16;read_clat_pct17;read_clat_pct18;read_clat_pct19;read_clat_pct20;read_tlat_min_us;read_lat_max_us;read_lat_mean_us;read_lat_dev_us;read_bw_min_kb;read_bw_max_kb;read_bw_agg_pct;read_bw_mean_kb;read_bw_dev_kb;write_kb;write_bandwidth_kb;write_iops;write_runtime_ms;write_slat_min_us;write_slat_max_us;write_slat_mean_us;write_slat_dev_us;write_clat_min_us;write_clat_max_us;write_clat_mean_us;write_clat_dev_us;write_clat_pct01;write_clat_pct02;write_clat_pct03;write_clat_pct04;write_clat_pct05;write_clat_pct06;write_clat_pct07;write_clat_pct08;write_clat_pct09;write_clat_pct10;write_clat_pct11;write_clat_pct12;write_clat_pct13;write_clat_pct14;write_clat_pct15;write_clat_pct16;write_clat_pct17;write_clat_pct18;write_clat_pct19;write_clat_pct20;write_tlat_min_us;write_lat_max_us;write_lat_mean_us;write_lat_dev_us;write_bw_min_kb;write_bw_max_kb;write_bw_agg_pct;write_bw_mean_kb;write_bw_dev_kb;cpu_user;cpu_sys;cpu_csw;cpu_mjf;cpu_minf;iodepth_1;iodepth_2;iodepth_4;iodepth_8;iodepth_16;iodepth_32;iodepth_64;lat_2us;lat_4us;lat_10us;lat_20us;lat_50us;lat_100us;lat_250us;lat_500us;lat_750us;lat_1000us;lat_2ms;lat_4ms;lat_10ms;lat_20ms;lat_50ms;lat_100ms;lat_250ms;lat_500ms;lat_750ms;lat_1000ms;lat_2000ms;lat_over_2000ms;disk_name;disk_read_iops;disk_write_iops;disk_read_merges;disk_write_merges;disk_read_ticks;write_ticks;disk_queue_time;disk_util

       In  client/server mode terse output differs from what appears when jobs are run locally. Disk utilization
       data is omitted from the standard terse output and for v3 and later appears on its own separate  line  at
       the end of each terse reporting cycle.

</pre><h4><b>JSON</b> <b>OUTPUT</b></h4><pre>
       The  <b>json</b>  output  format is intended to be both human readable and convenient for automated parsing. For
       the most part its sections mirror those of the <b>normal</b> output. The <b>runtime</b> value is reported in  msec  and
       the <b>bw</b> value is reported in 1024 bytes per second units.

</pre><h4><b>JSON+</b> <b>OUTPUT</b></h4><pre>
       The  <b>json+</b>  output  format  is identical to the <b>json</b> output format except that it adds a full dump of the
       completion latency bins. Each <b>bins</b> object contains a set of (key, value) pairs  where  keys  are  latency
       durations  and  values  count  how  many I/Os had completion latencies of the corresponding duration. For
       example, consider:

              "bins" : { "87552" : 1, "89600" : 1, "94720" : 1, "96768" : 1, "97792" : 1, "99840" : 1,  "100864"
              : 2, "103936" : 6, "104960" : 534, "105984" : 5995, "107008" : 7529, ... }

       This  data indicates that one I/O required 87,552ns to complete, two I/Os required 100,864ns to complete,
       and 7529 I/Os required 107,008ns to complete.

       Also included with fio is a Python script <b>fio_jsonplus_clat2csv</b> that takes  json+  output  and  generates
       CSV-formatted latency data suitable for plotting.

       The  latency  durations  actually  represent  the  midpoints  of latency intervals.  For details refer to
       `stat.h' in the fio source.

</pre><h4><b>TRACE</b> <b>FILE</b> <b>FORMAT</b></h4><pre>
       There are two trace file format that you can encounter.  The  older  (v1)  format  is  unsupported  since
       version  1.20-rc3  (March  2008).  It will still be described below in case that you get an old trace and
       want to understand it.

       In any case the trace is a simple text file with a single action per line.

       <b>Trace</b> <b>file</b> <b>format</b> <b>v1</b>
              Each line represents a single I/O action in the following format:

                     rw, offset, length

              where `rw=0/1' for read/write, and the `offset' and `length' entries being in bytes.

              This format is not supported in fio versions &gt;= 1.20-rc3.

       <b>Trace</b> <b>file</b> <b>format</b> <b>v2</b>
              The second version of the trace file format was added in fio version 1.17. It allows one to access
              more than one file per trace and has a bigger set of possible file actions.

              The first line of the trace file has to be:

                     "fio version 2 iolog"

              Following this can be lines in two different formats, which are described below.

              <b>The</b> <b>file</b> <b>management</b> <b>format:</b>
                     filename action

                     The `filename' is given as an absolute path. The `action' can be one of these:

                            <b>add</b>    Add the given `filename' to the trace.

                            <b>open</b>   Open the file with the given `filename'. The  `filename'  has  to  have  been
                                   added with the <b>add</b> action before.

                            <b>close</b>  Close  the  file  with the given `filename'. The file has to have been <b>open</b>ed
                                   before.

              <b>The</b> <b>file</b> <b>I/O</b> <b>action</b> <b>format:</b>
                     filename action offset length

                     The `filename' is given as an absolute path, and has to have been <b>add</b>ed and  <b>open</b>ed  before
                     it can be used with this format. The `offset' and `length' are given in bytes. The `action'
                     can be one of these:

                            <b>wait</b>   Wait  for `offset' microseconds. Everything below 100 is discarded.  The time
                                   is relative to the previous `wait' statement. Note that action `wait` is  not
                                   allowed  as  of  version  3,  as  the  same  behavior  can  be achieved using
                                   timestamps.

                            <b>read</b>   Read `length' bytes beginning from `offset'.

                            <b>write</b>  Write `length' bytes beginning from `offset'.

                            <b>sync</b>   <b><a href="../man2/fsync.2.html">fsync</a></b>(2) the file.

                            <b>datasync</b>
                                   <b><a href="../man2/fdatasync.2.html">fdatasync</a></b>(2) the file.

                            <b>trim</b>   Trim the given file from the given `offset' for `length' bytes.

       <b>Trace</b> <b>file</b> <b>format</b> <b>v3</b>
              The third version of the trace file format was added in fio version 3.31. It forces each action to
              have a timestamp associated with it.

              The first line of the trace file has to be:

                     "fio version 3 iolog"

              Following this can be lines in two different formats, which are described below.

              <b>The</b> <b>file</b> <b>management</b> <b>format:</b>
                     timestamp filename action

              <b>The</b> <b>file</b> <b>I/O</b> <b>action</b> <b>format:</b>
                     timestamp filename action offset length

                     The `timestamp` is relative to the beginning of the run (ie starts at 0).  The  `filename`,
                     `action`, `offset` and `length`  are identical to version 2, except that version 3 does not
                     allow the `wait` action.

</pre><h4><b>I/O</b> <b>REPLAY</b> <b>-</b> <b>MERGING</b> <b>TRACES</b></h4><pre>
       Colocation  is  a  common  practice  used to get the most out of a machine.  Knowing which workloads play
       nicely with each other and which ones don't is a  much  harder  task.  While  fio  can  replay  workloads
       concurrently  via  multiple jobs, it leaves some variability up to the scheduler making results harder to
       reproduce. Merging is a way to make the order of events consistent.

       Merging is integrated into I/O replay and done when a <b>merge_blktrace_file</b> is specified. The list of files
       passed to <b>read_iolog</b> go through the merge process and output a single file stored to the specified  file.
       The  output  file  is  passed  on as if it were the only file passed to <b>read_iolog</b>. An example would look
       like:

              $ fio --read_iolog="&lt;file1&gt;:&lt;file2&gt;" --merge_blktrace_file="&lt;output_file&gt;"

       Creating only the merged file can be done by passing the command line argument <b>merge-blktrace-only</b>.

       Scaling traces can be done to see the relative impact of any particular trace being slowed down  or  sped
       up. <b>merge_blktrace_scalars</b> takes in a colon separated list of percentage scalars. It is index paired with
       the files passed to <b>read_iolog</b>.

       With  scaling,  it  may  be  desirable  to  match  the running time of all traces.  This can be done with
       <b>merge_blktrace_iters</b>. It is index paired with <b>read_iolog</b> just like <b>merge_blktrace_scalars</b>.

       In an example, given two traces, A and B, each 60s long. If we want to see the impact of trace A  issuing
       IOs twice as fast and repeat trace A over the runtime of trace B, the following can be done:

              $        fio        --read_iolog="&lt;trace_a&gt;:"&lt;trace_b&gt;"       --merge_blktrace_file"&lt;output_file&gt;"
              --merge_blktrace_scalars="50:100" --merge_blktrace_iters="2:1"

       This runs trace A at 2x the speed twice for approximately the same runtime as a single run of trace B.

</pre><h4><b>CPU</b> <b>IDLENESS</b> <b>PROFILING</b></h4><pre>
       In some cases, we want to understand CPU overhead in a  test.  For  example,  we  test  patches  for  the
       specific goodness of whether they reduce CPU usage.  Fio implements a balloon approach to create a thread
       per  CPU  that  runs  at  idle  priority,  meaning  that it only runs when nobody else needs the cpu.  By
       measuring the amount of work completed by the thread, idleness of each CPU can be derived accordingly.

       An unit work is defined as touching a full page of unsigned characters. Mean and  standard  deviation  of
       time  to  complete  an  unit  work  is  reported  in "unit work" section. Options can be chosen to report
       detailed percpu idleness or overall system idleness by aggregating percpu stats.

</pre><h4><b>VERIFICATION</b> <b>AND</b> <b>TRIGGERS</b></h4><pre>
       Fio is usually run in one of two ways, when data verification is done. The first is a normal write job of
       some sort with verify enabled. When the write phase has completed, fio switches  to  reads  and  verifies
       everything it wrote. The second model is running just the write phase, and then later on running the same
       job  (but  with reads instead of writes) to repeat the same I/O patterns and verify the contents. Both of
       these methods depend on the write phase being completed, as fio otherwise has no idea how much  data  was
       written.

       With  verification  triggers,  fio  supports  dumping  the  current  write  state  to local files. Then a
       subsequent read verify workload can load this state and know exactly where to stop. This  is  useful  for
       testing cases where power is cut to a server in a managed fashion, for instance.

       A verification trigger consists of two things:

              1) Storing the write state of each job.

              2) Executing a trigger command.

       The  write  state is relatively small, on the order of hundreds of bytes to single kilobytes. It contains
       information on the number of completions done, the last X completions, etc.

       A trigger is invoked either through creation ('touch') of a specified file in the system,  or  through  a
       timeout  setting.  If  fio is run with `--trigger-file=/tmp/trigger-file', then it will continually check
       for the existence of `/tmp/trigger-file'. When it sees this file, it will  fire  off  the  trigger  (thus
       saving state, and executing the trigger command).

       For  client/server  runs, there's both a local and remote trigger. If fio is running as a server backend,
       it will send the job states back to the client for safe storage, then  execute  the  remote  trigger,  if
       specified.  If  a  local  trigger  is specified, the server will still send back the write state, but the
       client will then execute the trigger.

       <b>Verification</b> <b>trigger</b> <b>example</b>
              Let's say we want to run a powercut test on the remote Linux machine 'server'.  Our write workload
              is in `write-test.fio'. We want to cut power to 'server' at some point during the run,  and  we'll
              run this test from the safety or our local machine, 'localbox'. On the server, we'll start the fio
              backend normally:

                     server# fio --server

              and on the client, we'll fire off the workload:

                     localbox$  fio  --client=server  --trigger-file=/tmp/my-trigger  --trigger-remote="bash  -c
                     "echo b &gt; /proc/sysrq-triger""

              We set `/tmp/my-trigger' as the trigger file, and we tell fio to execute:

                     echo b &gt; <a href="file:/proc/sysrq-trigger">/proc/sysrq-trigger</a>

              on the server once it has received the trigger and sent us the write state. This  will  work,  but
              it's  not  really  cutting  power  to  the server, it's merely abruptly rebooting it. If we have a
              remote way of cutting power to the server through IPMI or similar, we  could  do  that  through  a
              local  trigger  command  instead.  Let's  assume we have a script that does IPMI reboot of a given
              hostname, ipmi-reboot. On localbox, we could then have run fio with a local trigger instead:

                     localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger="ipmi-reboot server"

              For this case, fio would wait for the server to send us the write state, then execute `ipmi-reboot
              server' when that happened.

       <b>Loading</b> <b>verify</b> <b>state</b>
              To load stored write state, a read  verification  job  file  must  contain  the  <b>verify_state_load</b>
              option.  If  that  is  set, fio will load the previously stored state. For a local fio run this is
              done by loading the files directly, and on a client/server run, the server backend  will  ask  the
              client to send the files over and load them from there.

</pre><h4><b>LOG</b> <b>FILE</b> <b>FORMATS</b></h4><pre>
       Fio  supports a variety of log file formats, for logging latencies, bandwidth, and IOPS. The logs share a
       common format, which looks like this:

              time (msec), value, data direction, block size (bytes), offset (bytes),  command  priority,  issue
              time (nsec)

       `Time'  for  the  log  entry is always in milliseconds. The `value' logged depends on the type of log, it
       will be one of the following:

              <b>Latency</b> <b>log</b>
                     Value is latency in nsecs

              <b>Bandwidth</b> <b>log</b>
                     Value is in KiB/sec

              <b>IOPS</b> <b>log</b>
                     Value is IOPS

       `Data direction' is one of the following:

              <b>0</b>      I/O is a READ

              <b>1</b>      I/O is a WRITE

              <b>2</b>      I/O is a TRIM

       The entry's `block size' is always in bytes. The `offset' is the position in bytes from the start of  the
       file for that particular I/O. The logging of the offset can be toggled with <b>log_offset</b>.

       If  <b>log_prio</b>  is  not  set,  the  entry's  `Command priority` is 1 for an IO executed with the highest RT
       priority class (<b>prioclass</b>=1 or <b>cmdprio_class</b>=1) and 0 otherwise. This  is  controlled  by  the  <b>prioclass</b>
       option  and  the  ioengine  specific  <b>cmdprio_percentage</b>  <b>cmdprio_class</b>  options. If <b>log_prio</b> is set, the
       entry's `Command priority` is the priority set for the IO, as  a  16-bits  hexadecimal  number  with  the
       lowest 13 bits indicating the priority value (<b>prio</b> and <b>cmdprio</b> options) and the highest 3 bits indicating
       the IO priority class (<b>prioclass</b> and <b>cmdprio_class</b> options).

       The  entry's  `issue time` is the command issue time in nanoseconds. The logging of the issue time can be
       toggled with <b>log_issue_time</b>. This field has valid values in completion latency log file (clat), or submit
       latency log file (slat).  The field has value 0 in other log files.

       Fio defaults to logging every individual I/O but when  windowed  logging  is  set  through  <b>log_avg_msec</b>,
       either  the  average  (by  default),  the  maximum (<b>log_window_value</b> is set to max) `value' seen over the
       specified period of time, or both the average `value' and maximum `value1' (<b>log_window_value</b>  is  set  to
       both) is recorded. The log file format when both the values are reported takes this form:

              time  (msec), value, value1, data direction, block size (bytes), offset (bytes), command priority,
              issue time (nsec)

       Each `data direction' seen within the window period will aggregate its values in a separate row. Further,
       when using windowed logging the `block size', `offset' and `issue time` entries will always contain 0.

</pre><h4><b>CLIENT</b> <b>/</b> <b>SERVER</b></h4><pre>
       Normally fio is invoked as a stand-alone application on the machine where  the  I/O  workload  should  be
       generated.  However,  the  backend  and  frontend  of  fio can be run separately i.e., the fio server can
       generate an I/O workload on the "Device Under Test"  while  being  controlled  by  a  client  on  another
       machine.

       Start the server on the machine which has access to the storage DUT:

              $ fio --server=args

       where  `args'  defines  what  fio listens to. The arguments are of the form `type,hostname' or `IP,port'.
       `type' is either `ip' (or ip4) for TCP/IP v4, `ip6' for TCP/IP v6, or `sock'  for  a  local  unix  domain
       socket.   `hostname'  is either a hostname or IP address, and `port' is the port to listen to (only valid
       for TCP/IP, not a local socket). Some examples:

              1) <b>fio</b> <b>--server</b>
                     Start a fio server, listening on all interfaces on the default port (8765).

              2) <b>fio</b> <b>--server=ip:hostname,4444</b>
                     Start a fio server, listening on IP belonging to hostname and on port 4444.

              3) <b>fio</b> <b>--server=ip6:::1,4444</b>
                     Start a fio server, listening on IPv6 localhost ::1 and on port 4444.

              4) <b>fio</b> <b>--server=,4444</b>
                     Start a fio server, listening on all interfaces on port 4444.

              5) <b>fio</b> <b>--server=1.2.3.4</b>
                     Start a fio server, listening on IP 1.2.3.4 on the default port.

              6) <b>fio</b> <b>--server=sock:/tmp/fio.sock</b>
                     Start a fio server, listening on the local socket `/tmp/fio.sock'.

       Once a server is running, a "client" can connect to the fio server with:

              $ fio &lt;local-args&gt; --client=&lt;server&gt; &lt;remote-args&gt; &lt;job file(s)&gt;

       where `local-args' are arguments for the client where it is running, `server' is the connect string,  and
       `remote-args' and `job file(s)' are sent to the server. The `server' string follows the same format as it
       does on the server side, to allow IP/hostname/socket and port strings.

       Note  that  all  job  options  must be defined in job files when running fio as a client. Any job options
       specified in `remote-args' will be ignored.

       Fio can connect to multiple servers this way:

              $ fio --client=&lt;server1&gt; &lt;job file(s)&gt; --client=&lt;server2&gt; &lt;job file(s)&gt;

       If the job file is located on the fio server, then you can tell the server to load a local file as  well.
       This is done by using <b>--remote-config</b>:

              $ fio --client=server --remote-config /path/to/file.fio

       Then fio will open this local (to the server) job file instead of being passed one from the client.

       If  you  have  many  servers (example: 100 VMs/containers), you can input a pathname of a file containing
       host IPs/names as the parameter  value  for  the  <b>--client</b>  option.  For  example,  here  is  an  example
       `host.list' file containing 2 hostnames:

              host1.your.dns.domain
              host2.your.dns.domain

       The fio command would then be:

              $ fio --client=host.list &lt;job file(s)&gt;

       In  this  mode,  you cannot input server-specific parameters or job files -- all servers receive the same
       job file.

       In order to let `fio --client' runs use a shared filesystem  from  multiple  hosts,  `fio  --client'  now
       prepends  the  IP  address  of  the  server  to  the filename. For example, if fio is using the directory
       `/mnt/nfs/fio' and is writing filename `fileio.tmp', with a <b>--client</b> `hostfile' containing two  hostnames
       `h1' and `h2' with IP addresses 192.168.10.120 and 192.168.10.121, then fio will create two files:

              /mnt/nfs/fio/192.168.10.120.fileio.tmp
              /mnt/nfs/fio/192.168.10.121.fileio.tmp

       Terse  output  in client/server mode will differ slightly from what is produced when fio is run in stand-
       alone mode. See the terse output section for details.

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>fio</b> was written by Jens Axboe &lt;<a href="mailto:axboe@kernel.dk">axboe@kernel.dk</a>&gt;.
       This man page was written by Aaron Carroll &lt;<a href="mailto:aaronc@cse.unsw.edu.au">aaronc@cse.unsw.edu.au</a>&gt; based on documentation by Jens Axboe.
       This man page was rewritten by Tomohiro Kusumi &lt;<a href="mailto:tkusumi@tuxera.com">tkusumi@tuxera.com</a>&gt; based on documentation by Jens Axboe.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to the <b>fio</b> mailing list &lt;<a href="mailto:fio@vger.kernel.org">fio@vger.kernel.org</a>&gt;.
       See <b>REPORTING-BUGS</b>.

       <b>REPORTING-BUGS</b>: <u><a href="http://git.kernel.dk/cgit/fio/plain/REPORTING-BUGS">http://git.kernel.dk/cgit/fio/plain/REPORTING-BUGS</a></u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       For further documentation see <b>HOWTO</b> and <b>README</b>.
       Sample jobfiles are available in the `examples/' directory.
       These are typically located under `/usr/share/doc/fio'.

       <b>HOWTO</b>: <u><a href="http://git.kernel.dk/cgit/fio/plain/HOWTO">http://git.kernel.dk/cgit/fio/plain/HOWTO</a></u>
       <b>README</b>: <u><a href="http://git.kernel.dk/cgit/fio/plain/README">http://git.kernel.dk/cgit/fio/plain/README</a></u>

User Manual                                        August 2017                                            <u><a href="../man1/fio.1.html">fio</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>