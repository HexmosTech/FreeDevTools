<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>perlfaq8 - System Interaction</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/perl-doc">perl-doc_5.40.1-2ubuntu0.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       perlfaq8 - System Interaction

</pre><h4><b>VERSION</b></h4><pre>
       version 5.20240218

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This section of the Perl FAQ covers questions involving operating system interaction. Topics include
       interprocess communication (IPC), control over the user-interface (keyboard, screen and pointing
       devices), and most anything else not related to data manipulation.

       Read the FAQs and documentation specific to the port of perl to your operating system (eg, perlvms,
       perlplan9, ...). These should contain more detailed information on the vagaries of your perl.

   <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>out</b> <b>which</b> <b>operating</b> <b>system</b> <b>I'm</b> <b>running</b> <b>under?</b>
       The $^O variable ($OSNAME if you use "English") contains an indication of the name of the operating
       system (not its release number) that your perl binary was built for.

   <b>Why</b> <b>does</b> <b>exec()</b> <b>not</b> <b>return?</b>
       (contributed by brian d foy)

       The "exec" function's job is to turn your process into another command and never to return. If that's not
       what you want to do, don't use "exec". :)

       If you want to run an external command and still keep your Perl process going, look at a piped "open",
       "fork", or "system".

   <b>How</b> <b>do</b> <b>I</b> <b>do</b> <b>fancy</b> <b>stuff</b> <b>with</b> <b>the</b> <b>keyboard/screen/mouse?</b>
       How you access/control keyboards, screens, and pointing devices ("mice") is system-dependent. Try the
       following modules:

       Keyboard
               Term::Cap               Standard perl distribution
               Term::ReadKey           CPAN
               Term::ReadLine::Gnu     CPAN
               Term::ReadLine::Perl    CPAN
               Term::Screen            CPAN

       Screen
               Term::Cap               Standard perl distribution
               Curses                  CPAN
               Term::ANSIColor         CPAN

       Mouse
               Tk                      CPAN
               Wx                      CPAN
               Gtk2                    CPAN
               Qt4                     kdebindings4 package

       Some of these specific cases are shown as examples in other answers in this section of the perlfaq.

   <b>How</b> <b>do</b> <b>I</b> <b>print</b> <b>something</b> <b>out</b> <b>in</b> <b>color?</b>
       In  general, you don't, because you don't know whether the recipient has a color-aware display device. If
       you know that they have an ANSI terminal that understands color, you can use the  Term::ANSIColor  module
       from CPAN:

           use Term::ANSIColor;
           print color("red"), "Stop!\n", color("reset");
           print color("green"), "Go!\n", color("reset");

       Or like this:

           use Term::ANSIColor qw(:constants);
           print RED, "Stop!\n", RESET;
           print GREEN, "Go!\n", RESET;

   <b>How</b> <b>do</b> <b>I</b> <b>read</b> <b>just</b> <b>one</b> <b>key</b> <b>without</b> <b>waiting</b> <b>for</b> <b>a</b> <b>return</b> <b>key?</b>
       Controlling  input  buffering is a remarkably system-dependent matter.  On many systems, you can just use
       the <b>stty</b> command as shown in "getc" in perlfunc,  but  as  you  see,  that's  already  getting  you  into
       portability snags.

           open(TTY, "+&lt;/dev/tty") or die "no tty: $!";
           system "stty  cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1";
           $key = getc(TTY);        # perhaps this works
           # OR ELSE
           sysread(TTY, $key, 1);    # probably this does
           system "stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1";

       The  Term::ReadKey  module  from  CPAN offers an easy-to-use interface that should be more efficient than
       shelling out to <b>stty</b> for each key.  It even includes limited support for Windows.

           use Term::ReadKey;
           ReadMode('cbreak');
           $key = <a href="../man0/ReadKey.0.html">ReadKey</a>(0);
           ReadMode('normal');

       However, using the code requires that you have a working C compiler and can use it to build and install a
       CPAN module. Here's a solution using the standard POSIX module, which is already on your system (assuming
       your system supports POSIX).

           use HotKey;
           $key = readkey();

       And here's the "HotKey" module, which hides the somewhat mystifying calls to manipulate the POSIX termios
       structures.

           # HotKey.pm
           package HotKey;

           use strict;
           use warnings;

           use parent 'Exporter';
           our @EXPORT = qw(cbreak cooked readkey);

           use POSIX qw(:termios_h);
           my ($term, $oterm, $echo, $noecho, $fd_stdin);

           $fd_stdin = fileno(STDIN);
           $term     = POSIX::Termios-&gt;new();
           $term-&gt;getattr($fd_stdin);
           $oterm     = $term-&gt;getlflag();

           $echo     = ECHO | ECHOK | ICANON;
           $noecho   = $oterm &amp; ~$echo;

           sub cbreak {
               $term-&gt;setlflag($noecho);  # ok, so i don't want echo either
               $term-&gt;setcc(VTIME, 1);
               $term-&gt;setattr($fd_stdin, TCSANOW);
           }

           sub cooked {
               $term-&gt;setlflag($oterm);
               $term-&gt;setcc(VTIME, 0);
               $term-&gt;setattr($fd_stdin, TCSANOW);
           }

           sub readkey {
               my $key = '';
               cbreak();
               sysread(STDIN, $key, 1);
               cooked();
               return $key;
           }

           END { cooked() }

           1;

   <b>How</b> <b>do</b> <b>I</b> <b>check</b> <b>whether</b> <b>input</b> <b>is</b> <b>ready</b> <b>on</b> <b>the</b> <b>keyboard?</b>
       The easiest way to do this is to read a key in nonblocking mode with the Term::ReadKey module from  CPAN,
       passing it an argument of -1 to indicate not to block:

           use Term::ReadKey;

           ReadMode('cbreak');

           if (defined (my $char = ReadKey(-1)) ) {
               # input was waiting and it was $char
           } else {
               # no input was waiting
           }

           ReadMode('normal');                  # restore normal tty settings

   <b>How</b> <b>do</b> <b>I</b> <b>clear</b> <b>the</b> <b>screen?</b>
       (contributed by brian d foy)

       To  clear  the  screen,  you just have to print the special sequence that tells the terminal to clear the
       screen. Once you have that sequence, output it when you want to clear the screen.

       You can use the Term::ANSIScreen module to get the special sequence. Import the "cls"  function  (or  the
       ":screen" tag):

           use Term::ANSIScreen qw(cls);
           my $clear_screen = cls();

           print $clear_screen;

       The  Term::Cap module can also get the special sequence if you want to deal with the low-level details of
       terminal control. The "Tputs" method returns the string for the given capability:

           use Term::Cap;

           my $terminal = Term::Cap-&gt;Tgetent( { OSPEED =&gt; 9600 } );
           my $clear_screen = $terminal-&gt;Tputs('cl');

           print $clear_screen;

       On Windows, you can use the Win32::Console module. After creating an object for the output filehandle you
       want to affect, call the "Cls" method:

           Win32::Console;

           my $OUT = Win32::Console-&gt;new(STD_OUTPUT_HANDLE);
           my $clear_string = $OUT-&gt;Cls;

           print $clear_screen;

       If you have a command-line program that does the job, you can call it in backticks to capture whatever it
       outputs so you can use it later:

           my $clear_string = `clear`;

           print $clear_string;

   <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>the</b> <b>screen</b> <b>size?</b>
       If you have Term::ReadKey module installed from CPAN, you can use it to fetch the  width  and  height  in
       characters and in pixels:

           use Term::ReadKey;
           my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

       This is more portable than the raw "ioctl", but not as illustrative:

           require './sys/ioctl.ph';
           die "no TIOCGWINSZ " unless defined &amp;TIOCGWINSZ;
           open(my $tty_fh, "+&lt;/dev/tty")                     or die "No tty: $!";
           unless (ioctl($tty_fh, &amp;TIOCGWINSZ, $winsize='')) {
               die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &amp;TIOCGWINSZ;
           }
           my ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
           print "(row,col) = ($row,$col)";
           print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
           print "\n";

   <b>How</b> <b>do</b> <b>I</b> <b>ask</b> <b>the</b> <b>user</b> <b>for</b> <b>a</b> <b>password?</b>
       (This question has nothing to do with the web. See a different FAQ for that.)

       There's  an example of this in "crypt" in perlfunc. First, you put the terminal into "no echo" mode, then
       just read the password normally.  You may do this with an  old-style  ioctl()  function,  POSIX  terminal
       control  (see  POSIX  or  its  documentation the Camel Book), or a call to the <b>stty</b> program, with varying
       degrees of portability.

       You can also do this for most systems using the Term::ReadKey module from CPAN, which is  easier  to  use
       and in theory more portable.

           use Term::ReadKey;

           ReadMode('noecho');
           my $password = <a href="../man0/ReadLine.0.html">ReadLine</a>(0);

   <b>How</b> <b>do</b> <b>I</b> <b>read</b> <b>and</b> <b>write</b> <b>the</b> <b>serial</b> <b>port?</b>
       This  depends on which operating system your program is running on. In the case of Unix, the serial ports
       will be accessible through files in "<a href="file:/dev">/dev</a>";  on  other  systems,  device  names  will  doubtless  differ.
       Several problem areas common to all device interaction are the following:

       lockfiles
           Your  system may use lockfiles to control multiple access. Make sure you follow the correct protocol.
           Unpredictable behavior can result from multiple processes reading from one device.

       open mode
           If you expect to use both read and write operations on the device, you'll have to open it for  update
           (see "open" in perlfunc for details). You may wish to open it without running the risk of blocking by
           using  sysopen()  and  "O_RDWR|O_NDELAY|O_NOCTTY"  from  the  Fcntl module (part of the standard perl
           distribution). See "sysopen" in perlfunc for more on this approach.

       end of line
           Some devices will be expecting a "\r" at the end of each line rather than a "\n". In  some  ports  of
           perl,  "\r" and "\n" are different from their usual (Unix) ASCII values of "\015" and "\012". You may
           have to give the numeric values you want directly, using  octal  ("\015"),  hex  ("0x0D"),  or  as  a
           control-character specification ("\cM").

               print DEV "atv1\012";    # wrong, for some devices
               print DEV "atv1\015";    # right, for some devices

           Even  though  with  normal  text files a "\n" will do the trick, there is still no unified scheme for
           terminating a line that is portable between Unix, DOS/Win, and Macintosh,  except  to  terminate  <u>ALL</u>
           line ends with "\015\012", and strip what you don't need from the output.  This applies especially to
           socket I/O and autoflushing, discussed next.

       flushing output
           If  you  expect characters to get to your device when you print() them, you'll want to autoflush that
           filehandle. You can use select() and the $| variable to control autoflushing (see "$|" in perlvar and
           "select" in perlfunc, or perlfaq5, "How do I flush/unbuffer an  output  filehandle?  Why  must  I  do
           this?"):

               my $old_handle = select($dev_fh);
               $| = 1;
               select($old_handle);

           You'll also see code that does this without a temporary variable, as in

               select((select($deb_handle), $| = 1)[0]);

           Or  if  you don't mind pulling in a few thousand lines of code just because you're afraid of a little
           $| variable:

               use IO::Handle;
               $dev_fh-&gt;<a href="../man1/autoflush.1.html">autoflush</a>(1);

           As mentioned in the previous item, this still doesn't work when using socket  I/O  between  Unix  and
           Macintosh. You'll need to hard code your line terminators, in that case.

       non-blocking input
           If  you  are  doing  a  blocking  read() or sysread(), you'll have to arrange for an alarm handler to
           provide a timeout (see "alarm" in perlfunc). If you have a non-blocking open, you'll  likely  have  a
           non-blocking read, which means you may have to use a 4-arg select() to determine whether I/O is ready
           on that device (see "select" in perlfunc.

       While  trying  to  read  from his caller-id box, the notorious Jamie Zawinski "&lt;<a href="mailto:jwz@netscape.com">jwz@netscape.com</a>&gt;", after
       much gnashing of teeth and fighting with "sysread", "sysopen", POSIX's "tcgetattr" business, and  various
       other functions that go bump in the night, finally came up with this:

           sub open_modem {
               use IPC::Open2;
               my $stty = `<a href="file:/bin/stty">/bin/stty</a> -g`;
               open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2&gt;&amp;1");
               # starting cu hoses /dev/tty's stty settings, even when it has
               # been opened on a pipe...
               system("<a href="file:/bin/stty">/bin/stty</a> $stty");
               $_ = &lt;MODEM_IN&gt;;
               chomp;
               if ( !m/^Connected/ ) {
                   print STDERR "$0: cu printed `$_' instead of `Connected'\n";
               }
           }

   <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>encrypted</b> <b>password</b> <b>files?</b>
       You spend lots and lots of money on dedicated hardware, but this is bound to get you talked about.

       Seriously,  you  can't  if  they  are  Unix  password  files--the  Unix  password  system employs one-way
       encryption. It's more like hashing than encryption. The best you can do is check whether  something  else
       hashes  to  the same string. You can't turn a hash back into the original string. Programs like Crack can
       forcibly (and intelligently) try to guess passwords, but don't (can't) guarantee quick success.

       If you're worried about users selecting bad passwords, you should proactively  check  when  they  try  to
       change their password (by modifying <b><a href="../man1/passwd.1.html">passwd</a></b>(1), for example).

   <b>How</b> <b>do</b> <b>I</b> <b>start</b> <b>a</b> <b>process</b> <b>in</b> <b>the</b> <b>background?</b>
       (contributed by brian d foy)

       There's  not a single way to run code in the background so you don't have to wait for it to finish before
       your program moves on to other tasks. Process management depends on your particular operating system, and
       many of the techniques are covered in perlipc.

       Several CPAN modules may be able to help, including IPC::Open2 or IPC::Open3,  IPC::Run,  Parallel::Jobs,
       Parallel::ForkManager,  POE, Proc::Background, and Win32::Process. There are many other modules you might
       use, so check those namespaces for other options too.

       If you are on a Unix-like system, you might be able to get away with a system call where you put  an  "&amp;"
       on the end of the command:

           system("cmd &amp;")

       You can also try using "fork", as described in perlfunc (although this is the same thing that many of the
       modules will do for you).

       STDIN, STDOUT, and STDERR are shared
           Both the main process and the backgrounded one (the "child" process) share the same STDIN, STDOUT and
           STDERR  filehandles.  If  both try to access them at once, strange things can happen. You may want to
           close or reopen these for the child. You can get around this with "open"ing a  pipe  (see  "open"  in
           perlfunc) but on some systems this means that the child process cannot outlive the parent.

       Signals
           You'll  have  to  catch  the  SIGCHLD  signal,  and  possibly  SIGPIPE too.  SIGCHLD is sent when the
           backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has
           closed (an untrapped SIGPIPE can cause your program to silently die).  This  is  not  an  issue  with
           system("cmd&amp;").

       Zombies
           You have to be prepared to "reap" the child process when it finishes.

               $SIG{CHLD} = sub { wait };

               $SIG{CHLD} = 'IGNORE';

           You can also use a double fork. You immediately wait() for your first child, and the init daemon will
           wait() for your grandchild once it exits.

               unless ($pid = fork) {
                   unless (fork) {
                       exec "what you really wanna do";
                       die "exec failed!";
                   }
                   exit 0;
               }
               waitpid($pid, 0);

           See  "Signals"  in  perlipc  for  other  examples  of code to do this.  Zombies are not an issue with
           "system("prog &amp;")".

   <b>How</b> <b>do</b> <b>I</b> <b>trap</b> <b>control</b> <b>characters/signals?</b>
       You don't actually "trap" a control character. Instead, that character generates a signal which  is  sent
       to  your  terminal's  currently foregrounded process group, which you then trap in your process.  Signals
       are documented in "Signals" in perlipc and the section on "Signals" in the Camel.

       You can set the values of the %SIG hash to be the functions you want to handle  the  signal.  After  perl
       catches  the  signal,  it  looks  in  %SIG  for  a  key  with the same name as the signal, then calls the
       subroutine value for that key.

           # as an anonymous subroutine

           $SIG{INT} = sub { syswrite(STDERR, "ouch\n", 5 ) };

           # or a reference to a function

           $SIG{INT} = \&amp;ouch;

           # or the name of the function as a string

           $SIG{INT} = "ouch";

       Perl versions before 5.8 had in its C source code signal  handlers  which  would  catch  the  signal  and
       possibly run a Perl function that you had set in %SIG. This violated the rules of signal handling at that
       level  causing  perl  to  dump  core.  Since  version 5.8.0, perl looks at %SIG <b>after</b> the signal has been
       caught, rather than while it is being caught.  Previous versions of this answer were incorrect.

   <b>How</b> <b>do</b> <b>I</b> <b>modify</b> <b>the</b> <b>shadow</b> <b>password</b> <b>file</b> <b>on</b> <b>a</b> <b>Unix</b> <b>system?</b>
       If perl was installed correctly and your shadow library was written properly,  the  "getpw*()"  functions
       described in perlfunc should in theory provide (read-only) access to entries in the shadow password file.
       To  change  the  file,  make  a  new  shadow  password file (the format varies from system to system--see
       <b><a href="../man1/passwd.1.html">passwd</a></b>(1) for specifics) and use <a href="../man8/pwd_mkdb.8.html">pwd_mkdb</a>(8) to install it (see <b><a href="../man8/pwd_mkdb.8.html">pwd_mkdb</a></b>(8) for more details).

   <b>How</b> <b>do</b> <b>I</b> <b>set</b> <b>the</b> <b>time</b> <b>and</b> <b>date?</b>
       Assuming you're running under sufficient permissions, you should be able to set the system-wide date  and
       time  by  running the <a href="../man1/date.1.html">date</a>(1) program. (There is no way to set the time and date on a per-process basis.)
       This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is "set time".

       However, if all you want to do is change your time zone, you  can  probably  get  away  with  setting  an
       environment variable:

           $ENV{TZ} = "MST7MDT";           # Unixish
           $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
           system('trn', 'comp.lang.perl.misc');

   <b>How</b> <b>can</b> <b>I</b> <b>sleep()</b> <b>or</b> <b>alarm()</b> <b>for</b> <b>under</b> <b>a</b> <b>second?</b>
       If you want finer granularity than the 1 second that the sleep() function provides, the easiest way is to
       use  the select() function as documented in "select" in perlfunc. Try the Time::HiRes and the BSD::Itimer
       modules (available  from  CPAN,  and  starting  from  Perl  5.8  Time::HiRes  is  part  of  the  standard
       distribution).

   <b>How</b> <b>can</b> <b>I</b> <b>measure</b> <b>time</b> <b>under</b> <b>a</b> <b>second?</b>
       (contributed by brian d foy)

       The  Time::HiRes  module  (part  of  the  standard  distribution  as  of Perl 5.8) measures time with the
       gettimeofday() system call, which returns the time in microseconds since the epoch. If you can't  install
       Time::HiRes  for  older  Perls  and  you are on a Unixish system, you may be able to call <a href="../man2/gettimeofday.2.html">gettimeofday</a>(2)
       directly. See "syscall" in perlfunc.

   <b>How</b> <b>can</b> <b>I</b> <b>do</b> <b>an</b> <b>atexit()</b> <b>or</b> <b>setjmp()/longjmp()?</b> <b>(Exception</b> <b>handling)</b>
       You can use the "END" block to simulate atexit(). Each package's "END" block is called when  the  program
       or thread ends. See the perlmod manpage for more details about "END" blocks.

       For  example,  you  can  use  this  to make sure your filter program managed to finish its output without
       filling up the disk:

           END {
               close(STDOUT) || die "stdout close failed: $!";
           }

       The "END" block isn't called when untrapped signals kill the program, though, so if you use "END"  blocks
       you should also use

           use sigtrap qw(die normal-signals);

       Perl's  exception-handling  mechanism is its eval() operator. You can use eval() as "setjmp" and die() as
       "longjmp". For details of this, see the section  on  signals,  especially  the  time-out  handler  for  a
       blocking flock() in "Signals" in perlipc or the section on "Signals" in <u>Programming</u> <u>Perl</u>.

       If  exception  handling  is  all  you're  interested  in,  use  one  of the many CPAN modules that handle
       exceptions, such as Try::Tiny.

       If you want the atexit() syntax (and an rmexit() as well), try the "AtExit" module available from CPAN.

   <b>Why</b> <b>doesn't</b> <b>my</b> <b>sockets</b> <b>program</b> <b>work</b> <b>under</b> <b>System</b> <b>V</b> <b>(Solaris)?</b> <b>What</b>  <b>does</b>  <b>the</b>  <b>error</b>  <b>message</b>  <b>"Protocol</b>  <b>not</b>
       <b>supported"</b> <b>mean?</b>
       Some  Sys-V  based  systems,  notably Solaris 2.X, redefined some of the standard socket constants. Since
       these were constant across all architectures, they were often hardwired into perl code. The proper way to
       deal with this is to "use Socket" to get the correct values.

       Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.

   <b>How</b> <b>can</b> <b>I</b> <b>call</b> <b>my</b> <b>system's</b> <b>unique</b> <b>C</b> <b>functions</b> <b>from</b> <b>Perl?</b>
       In most cases, you write an external module to do it--see the answer to "Where can I learn about  linking
       C  with  Perl?  [h2xs,  xsubpp]".   However,  if  the function is a system call, and your system supports
       syscall(), you can use the "syscall" function (documented in perlfunc).

       Remember to check the modules that came with your distribution, and CPAN  as  well--someone  may  already
       have written a module to do it. On Windows, try Win32::API. On Macs, try Mac::Carbon. If no module has an
       interface to the C function, you can inline a bit of C in your Perl source with Inline::C.

   <b>Where</b> <b>do</b> <b>I</b> <b>get</b> <b>the</b> <b>include</b> <b>files</b> <b>to</b> <b>do</b> <b>ioctl()</b> <b>or</b> <b>syscall()?</b>
       Historically,  these  would  be  generated by the h2ph tool, part of the standard perl distribution. This
       program converts <a href="../man1/cpp.1.html">cpp</a>(1) directives in C header files to files  containing  subroutine  definitions,  like
       SYS_getitimer(),  which  you  can  use as arguments to your functions.  It doesn't work perfectly, but it
       usually gets most of the job done.  Simple files like <u>errno.h</u>, <u>syscall.h</u>, and <u>socket.h</u> were fine, but the
       hard ones like <u>ioctl.h</u> nearly always need to be hand-edited.  Here's how to install the *.ph files:

           1. Become the super-user
           2. cd <a href="file:/usr/include">/usr/include</a>
           3. h2ph *.h */*.h

       If your system supports dynamic loading, for reasons of portability and sanity you probably ought to  use
       h2xs (also part of the standard perl distribution). This tool converts C header files to Perl extensions.
       See perlxstut for how to get started with h2xs.

       If  your  system doesn't support dynamic loading, you still probably ought to use h2xs. See perlxstut and
       ExtUtils::MakeMaker for more information (in brief, just use <b>make</b> <b>perl</b> instead of a plain <b>make</b> to rebuild
       perl with a new static extension).

   <b>Why</b> <b>do</b> <b>setuid</b> <b>perl</b> <b>scripts</b> <b>complain</b> <b>about</b> <b>kernel</b> <b>problems?</b>
       Some operating systems have bugs in the kernel that make setuid scripts inherently insecure.  Perl  gives
       you a number of options (described in perlsec) to work around such systems.

   <b>How</b> <b>can</b> <b>I</b> <b>open</b> <b>a</b> <b>pipe</b> <b>both</b> <b>to</b> <b>and</b> <b>from</b> <b>a</b> <b>command?</b>
       The IPC::Open2 module (part of the standard perl distribution) is an easy-to-use approach that internally
       uses  pipe(),  fork(),  and  exec()  to  do  the  job.  Make  sure  you read the deadlock warnings in its
       documentation, though (see IPC::Open2). See "Bidirectional Communication with Another Process" in perlipc
       and "Bidirectional Communication with Yourself" in perlipc

       You may also use the IPC::Open3 module (part of the standard perl distribution), but be  warned  that  it
       has a different order of arguments from IPC::Open2 (see IPC::Open3).

   <b>Why</b> <b>can't</b> <b>I</b> <b>get</b> <b>the</b> <b>output</b> <b>of</b> <b>a</b> <b>command</b> <b>with</b> <b>system()?</b>
       You're  confusing  the  purpose  of system() and backticks (``). system() runs a command and returns exit
       status information (as a 16 bit value: the low 7 bits are the signal the process died from, if  any,  and
       the  high  8  bits  are  the  actual exit value). Backticks (``) run a command and return what it sent to
       STDOUT.

           my $exit_status   = system("mail-users");
           my $output_string = `ls`;

   <b>How</b> <b>can</b> <b>I</b> <b>capture</b> <b>STDERR</b> <b>from</b> <b>an</b> <b>external</b> <b>command?</b>
       There are three basic ways of running external commands:

           system $cmd;        # using system()
           my $output = `$cmd`;        # using backticks (``)
           open (my $pipe_fh, "$cmd |");    # using open()

       With system(), both STDOUT and STDERR will go the same place as the script's STDOUT  and  STDERR,  unless
       the system() command redirects them.  Backticks and open() read <b>only</b> the STDOUT of your command.

       You can also use the open3() function from IPC::Open3. Benjamin Goldberg provides some sample code:

       To capture a program's STDOUT, but discard its STDERR:

           use IPC::Open3;
           use File::Spec;
           my $in = '';
           open(NULL, "&gt;", File::Spec-&gt;devnull);
           my $pid = open3($in, \*PH, "&gt;&amp;NULL", "cmd");
           while( &lt;PH&gt; ) { }
           waitpid($pid, 0);

       To capture a program's STDERR, but discard its STDOUT:

           use IPC::Open3;
           use File::Spec;
           my $in = '';
           open(NULL, "&gt;", File::Spec-&gt;devnull);
           my $pid = open3($in, "&gt;&amp;NULL", \*PH, "cmd");
           while( &lt;PH&gt; ) { }
           waitpid($pid, 0);

       To capture a program's STDERR, and let its STDOUT go to our own STDERR:

           use IPC::Open3;
           my $in = '';
           my $pid = open3($in, "&gt;&amp;STDERR", \*PH, "cmd");
           while( &lt;PH&gt; ) { }
           waitpid($pid, 0);

       To  read  both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the
       command run, then read the temp files:

           use IPC::Open3;
           use IO::File;
           my $in = '';
           local *CATCHOUT = IO::File-&gt;new_tmpfile;
           local *CATCHERR = IO::File-&gt;new_tmpfile;
           my $pid = open3($in, "&gt;&amp;CATCHOUT", "&gt;&amp;CATCHERR", "cmd");
           waitpid($pid, 0);
           seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
           while( &lt;CATCHOUT&gt; ) {}
           while( &lt;CATCHERR&gt; ) {}

       But there's no real need for <b>both</b> to be tempfiles... the following should  work  just  as  well,  without
       deadlocking:

           use IPC::Open3;
           my $in = '';
           use IO::File;
           local *CATCHERR = IO::File-&gt;new_tmpfile;
           my $pid = open3($in, \*CATCHOUT, "&gt;&amp;CATCHERR", "cmd");
           while( &lt;CATCHOUT&gt; ) {}
           waitpid($pid, 0);
           seek CATCHERR, 0, 0;
           while( &lt;CATCHERR&gt; ) {}

       And  it'll  be  faster,  too, since we can begin processing the program's stdout immediately, rather than
       waiting for the program to finish.

       With any of these, you can change file descriptors before the call:

           open(STDOUT, "&gt;logfile");
           system("ls");

       or you can use Bourne shell file-descriptor redirection:

           $output = `$cmd 2&gt;some_file`;
           open (PIPE, "cmd 2&gt;some_file |");

       You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:

           $output = `$cmd 2&gt;&amp;1`;
           open (PIPE, "cmd 2&gt;&amp;1 |");

       Note that you <u>cannot</u> simply open STDERR to be a dup of STDOUT in your Perl program and avoid calling  the
       shell to do the redirection.  This doesn't work:

           open(STDERR, "&gt;&amp;STDOUT");
           $alloutput = `cmd args`;  # stderr still escapes

       This  fails  because  the open() makes STDERR go to where STDOUT was going at the time of the open(). The
       backticks then make STDOUT go to a string, but don't change STDERR (which still goes to the old STDOUT).

       Note that you <u>must</u> use Bourne shell (<a href="../man1/sh.1.html">sh</a>(1)) redirection syntax in backticks, not <a href="../man1/csh.1.html">csh</a>(1)!  Details on  why
       Perl's system() and backtick and pipe opens all use the Bourne shell are in the <u>versus/csh.whynot</u> article
       in      the     "Far     More     Than     You     Ever     Wanted     To     Know"     collection     in
       &lt;<a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz</a>&gt; . To capture a command's STDERR and STDOUT together:

           $output = `cmd 2&gt;&amp;1`;                       # either with backticks
           $pid = open(PH, "cmd 2&gt;&amp;1 |");              # or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To capture a command's STDOUT but discard its STDERR:

           $output = `cmd 2&gt;/dev/null`;                # either with backticks
           $pid = open(PH, "cmd 2&gt;/dev/null |");       # or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To capture a command's STDERR but discard its STDOUT:

           $output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;           # either with backticks
           $pid = open(PH, "cmd 2&gt;&amp;1 1&gt;/dev/null |");  # or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out
       our old STDERR:

           $output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;        # either with backticks
           $pid = open(PH, "cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-|");# or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To read both a command's STDOUT and its STDERR separately, it's easiest to redirect  them  separately  to
       files, and then read from those files when the program is done:

           system("program args 1&gt;program.stdout 2&gt;program.stderr");

       Ordering  is  important  in  all  these  examples.  That's  because  the  shell processes file descriptor
       redirections in strictly left to right order.

           system("prog args 1&gt;tmpfile 2&gt;&amp;1");
           system("prog args 2&gt;&amp;1 1&gt;tmpfile");

       The first command sends both standard out and standard error to the temporary file.  The  second  command
       sends only the old standard output there, and the old standard error shows up on the old standard out.

   <b>Why</b> <b>doesn't</b> <b>open()</b> <b>return</b> <b>an</b> <b>error</b> <b>when</b> <b>a</b> <b>pipe</b> <b>open</b> <b>fails?</b>
       If  the  second  argument  to  a piped open() contains shell metacharacters, perl fork()s, then exec()s a
       shell to decode the metacharacters and eventually run the desired program. If  the  program  couldn't  be
       run,  it's  the  shell that gets the message, not Perl. All your Perl program can find out is whether the
       shell itself could be successfully started. You can still capture the shell's STDERR  and  check  it  for
       error  messages.  See "How can I capture STDERR from an external command?" elsewhere in this document, or
       use the IPC::Open3 module.

       If there are no shell metacharacters in the argument of open(), Perl runs the command  directly,  without
       using the shell, and can correctly report whether the command started.

   <b>What's</b> <b>wrong</b> <b>with</b> <b>using</b> <b>backticks</b> <b>in</b> <b>a</b> <b>void</b> <b>context?</b>
       Strictly  speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl
       has several operators for running external commands. Backticks are one; they collect the output from  the
       command for use in your program. The "system" function is another; it doesn't do this.

       Writing  backticks  in  your program sends a clear message to the readers of your code that you wanted to
       collect the output of the command.  Why send a clear message that isn't true?

       Consider this line:

           `cat /etc/termcap`;

       You forgot to check $? to see whether the program even ran correctly. Even if you wrote

           print `cat /etc/termcap`;

       this code could and probably should be written as

           system("cat /etc/termcap") == 0
           or die "cat program failed!";

       which will echo the cat command's output as it is generated, instead of waiting  until  the  program  has
       completed to print it out. It also checks the return value.

       "system"  also  provides  direct  control  over whether shell wildcard processing may take place, whereas
       backticks do not.

   <b>How</b> <b>can</b> <b>I</b> <b>call</b> <b>backticks</b> <b>without</b> <b>shell</b> <b>processing?</b>
       This is a bit tricky. You can't simply write the command like this:

           @ok = `grep @opts '$search_string' @filenames`;

       As of Perl 5.8.0, you can use open() with multiple arguments.  Just like the list forms of  system()  and
       exec(), no shell escapes happen.

           open( GREP, "-|", 'grep', @opts, $search_string, @filenames );
           chomp(@ok = &lt;GREP&gt;);
           close GREP;

       You can also:

           my @ok = ();
           if (open(GREP, "-|")) {
               while (&lt;GREP&gt;) {
                   chomp;
                   push(@ok, $_);
               }
               close GREP;
           } else {
               exec 'grep', @opts, $search_string, @filenames;
           }

       Just  as  with  system(), no shell escapes happen when you exec() a list. Further examples of this can be
       found in "Safe Pipe Opens" in perlipc.

       Note that if you're using Windows, no solution to this vexing issue is even possible.  Even  though  Perl
       emulates fork(), you'll still be stuck, because Windows does not have an argc/argv-style API.

   <b>Why</b> <b>can't</b> <b>my</b> <b>script</b> <b>read</b> <b>from</b> <b>STDIN</b> <b>after</b> <b>I</b> <b>gave</b> <b>it</b> <b>EOF</b> <b>(^D</b> <b>on</b> <b>Unix,</b> <b>^Z</b> <b>on</b> <b>MS-DOS)?</b>
       This  happens  only  if  your perl is compiled to use stdio instead of perlio, which is the default. Some
       (maybe all?) stdios set error and eof flags that  you  may  need  to  clear.  The  POSIX  module  defines
       clearerr()  that  you  can use. That is the technically correct way to do it. Here are some less reliable
       workarounds:

       1.  Try keeping around the seekpointer and go there, like this:

               my $where = tell($log_fh);
               seek($log_fh, $where, 0);

       2.  If that doesn't work, try seeking to a different part of the file and then back.

       3.  If that doesn't work, try seeking to a different part  of  the  file,  reading  something,  and  then
           seeking back.

       4.  If that doesn't work, give up on your stdio package and use sysread.

   <b>How</b> <b>can</b> <b>I</b> <b>convert</b> <b>my</b> <b>shell</b> <b>script</b> <b>to</b> <b>perl?</b>
       Learn  Perl and rewrite it. Seriously, there's no simple converter.  Things that are awkward to do in the
       shell are easy to do in Perl, and this very awkwardness is what would make a shell-&gt;perl converter  nigh-
       on  impossible  to  write.  By  rewriting  it,  you'll  think  about what you're really trying to do, and
       hopefully will escape the shell's pipeline datastream paradigm, which while convenient for some  matters,
       causes many inefficiencies.

   <b>Can</b> <b>I</b> <b>use</b> <b>perl</b> <b>to</b> <b>run</b> <b>a</b> <b>telnet</b> <b>or</b> <b>ftp</b> <b>session?</b>
       Try     the    Net::FTP,    TCP::Client,    and    Net::Telnet    modules    (available    from    CPAN).
       &lt;<a href="http://www.cpan.org/scripts/netstuff/telnet.emul.shar">http://www.cpan.org/scripts/netstuff/telnet.emul.shar</a>&gt; will also help for emulating the telnet protocol,
       but Net::Telnet is quite probably easier to use.

       If all you want to do is pretend to be telnet but don't need the initial  telnet  handshaking,  then  the
       standard dual-process approach will suffice:

           use IO::Socket;             # new in 5.004
           my $handle = IO::Socket::INET-&gt;new('www.perl.com:80')
               or die "can't connect to port 80 on www.perl.com $!";
           $handle-&gt;<a href="../man1/autoflush.1.html">autoflush</a>(1);
           if (fork()) {               # XXX: undef means failure
               select($handle);
               print while &lt;STDIN&gt;;    # everything from stdin to socket
           } else {
               print while &lt;$handle&gt;;  # everything from socket to stdout
           }
           close $handle;
           exit;

   <b>How</b> <b>can</b> <b>I</b> <b>write</b> <b>expect</b> <b>in</b> <b>Perl?</b>
       Once  upon  a  time,  there was a library called <u>chat2.pl</u> (part of the standard perl distribution), which
       never really got finished. If you find it somewhere, <u>don't</u> <u>use</u> <u>it</u>. These days, your best bet is  to  look
       at  the  Expect  module available from CPAN, which also requires two other modules from CPAN, IO::Pty and
       IO::Stty.

   <b>Is</b> <b>there</b> <b>a</b> <b>way</b> <b>to</b> <b>hide</b> <b>perl's</b> <b>command</b> <b>line</b> <b>from</b> <b>programs</b> <b>such</b> <b>as</b> <b>"ps"?</b>
       First of all note that if you're doing this for security reasons (to avoid people seeing  passwords,  for
       example) then you should rewrite your program so that critical information is never given as an argument.
       Hiding the arguments won't make your program completely secure.

       To  actually  alter the visible command line, you can assign to the variable $0 as documented in perlvar.
       This won't work on all operating systems, though. Daemon programs like sendmail place their state  there,
       as in:

           $0 = "orcus [accepting connections]";

   <b>I</b>  <b>{changed</b>  <b>directory,</b>  <b>modified</b>  <b>my</b>  <b>environment}</b>  <b>in</b> <b>a</b> <b>perl</b> <b>script.</b> <b>How</b> <b>come</b> <b>the</b> <b>change</b> <b>disappeared</b> <b>when</b> <b>I</b>
       <b>exited</b> <b>the</b> <b>script?</b> <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>my</b> <b>changes</b> <b>to</b> <b>be</b> <b>visible?</b>
       Unix
           In the strictest sense, it can't be done--the script executes as a different process from  the  shell
           it  was  started  from.  Changes  to  a process are not reflected in its parent--only in any children
           created after the change. There is shell magic that may  allow  you  to  fake  it  by  eval()ing  the
           script's output in your shell; check out the comp.unix.questions FAQ for details.

   <b>How</b> <b>do</b> <b>I</b> <b>close</b> <b>a</b> <b>process's</b> <b>filehandle</b> <b>without</b> <b>waiting</b> <b>for</b> <b>it</b> <b>to</b> <b>complete?</b>
       Assuming  your system supports such things, just send an appropriate signal to the process (see "kill" in
       perlfunc). It's common to first send a TERM signal, wait a little bit, and then send  a  KILL  signal  to
       finish it off.

   <b>How</b> <b>do</b> <b>I</b> <b>fork</b> <b>a</b> <b>daemon</b> <b>process?</b>
       If  by  daemon  process  you  mean  one  that's detached (disassociated from its tty), then the following
       process is reported to work on most Unixish systems. Non-Unix users should check  their  Your_OS::Process
       module for other solutions.

       •   Open  /dev/tty and use the TIOCNOTTY ioctl on it. See <b><a href="../man1/tty.1.html">tty</a></b>(1) for details. Or better yet, you can just
           use the POSIX::setsid() function, so you don't have to worry about process groups.

       •   Change directory to /

       •   Reopen STDIN, STDOUT, and STDERR so they're not connected to the old tty.

       •   Background yourself like this:

               fork &amp;&amp; exit;

       The Proc::Daemon module, available from CPAN, provides a function to perform these actions for you.

   <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>out</b> <b>if</b> <b>I'm</b> <b>running</b> <b>interactively</b> <b>or</b> <b>not?</b>
       (contributed by brian d foy)

       This is a difficult question to answer, and the best answer is only a guess.

       What do you really want to know? If you merely want to know if one of your filehandles is connected to  a
       terminal, you can try the "-t" file test:

           if( -t STDOUT ) {
               print "I'm connected to a terminal!\n";
           }

       However, you might be out of luck if you expect that means there is a real person on the other side. With
       the  Expect  module,  another  program  can  pretend to be a person. The program might even come close to
       passing the Turing test.

       The IO::Interactive module does the best it can to give you  an  answer.  Its  "is_interactive"  function
       returns  an output filehandle; that filehandle points to standard output if the module thinks the session
       is interactive. Otherwise, the filehandle is a null handle that simply discards the output:

           use IO::Interactive;

           print { is_interactive } "I might go to standard output!\n";

       This still doesn't guarantee that a real person is answering your prompts or reading your output.

       If you want to know how to handle automated testing for your distribution, you can check the environment.
       The CPAN Testers, for instance, set the value of "AUTOMATED_TESTING":

           unless( $ENV{AUTOMATED_TESTING} ) {
               print "Hello interactive tester!\n";
           }

   <b>How</b> <b>do</b> <b>I</b> <b>timeout</b> <b>a</b> <b>slow</b> <b>event?</b>
       Use the alarm() function, probably in conjunction with a signal handler, as documented  in  "Signals"  in
       perlipc  and  the section on "Signals" in the Camel. You may instead use the more flexible Sys::AlarmCall
       module available from CPAN.

       The alarm() function is not implemented on all versions of Windows.  Check  the  documentation  for  your
       specific version of Perl.

   <b>How</b> <b>do</b> <b>I</b> <b>set</b> <b>CPU</b> <b>limits?</b>
       (contributed by Xho)

       Use the BSD::Resource module from CPAN. As an example:

           use BSD::Resource;
           setrlimit(RLIMIT_CPU,10,20) or die $!;

       This  sets  the  soft and hard limits to 10 and 20 seconds, respectively.  After 10 seconds of time spent
       running on the CPU (not "wall" time), the process will be sent a signal (XCPU on some systems) which,  if
       not  trapped,  will cause the process to terminate. If that signal is trapped, then after 10 more seconds
       (20 seconds in total) the process will be killed with a non-trappable signal.

       See the BSD::Resource and your systems documentation for the gory details.

   <b>How</b> <b>do</b> <b>I</b> <b>avoid</b> <b>zombies</b> <b>on</b> <b>a</b> <b>Unix</b> <b>system?</b>
       Use the reaper code from "Signals" in perlipc to call wait() when a SIGCHLD is received, or else use  the
       double-fork technique described in "How do I start a process in the background?" in perlfaq8.

   <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>an</b> <b>SQL</b> <b>database?</b>
       The  DBI module provides an abstract interface to most database servers and types, including Oracle, DB2,
       Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each  database  type  through  a
       database   driver,   or   DBD.   You   can   see   a   complete   list  of  available  drivers  on  CPAN:
       &lt;<a href="http://www.cpan.org/modules/by-module/DBD/">http://www.cpan.org/modules/by-module/DBD/</a>&gt; .  You can read more about DBI on &lt;<a href="http://dbi.perl.org/">http://dbi.perl.org/</a>&gt; .

       Other modules provide more specific access: Win32::ODBC,  Alzabo,  "iodbc",  and  others  found  on  CPAN
       Search: &lt;https://metacpan.org/&gt; .

   <b>How</b> <b>do</b> <b>I</b> <b>make</b> <b>a</b> <b>system()</b> <b>exit</b> <b>on</b> <b>control-C?</b>
       You  can't.  You  need  to imitate the system() call (see perlipc for sample code) and then have a signal
       handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:

           $rc = system($cmd);
           if ($rc &amp; 127) { die "signal death" }

   <b>How</b> <b>do</b> <b>I</b> <b>open</b> <b>a</b> <b>file</b> <b>without</b> <b>blocking?</b>
       If you're lucky enough to be using a system that supports non-blocking reads (most Unixish  systems  do),
       you  need  only  to  use  the "O_NDELAY" or "O_NONBLOCK" flag from the "Fcntl" module in conjunction with
       sysopen():

           use Fcntl;
           sysopen(my $fh, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
               or die "can't open /foo/somefile: $!":

   <b>How</b> <b>do</b> <b>I</b> <b>tell</b> <b>the</b> <b>difference</b> <b>between</b> <b>errors</b> <b>from</b> <b>the</b> <b>shell</b> <b>and</b> <b>perl?</b>
       (answer contributed by brian d foy)

       When you run a Perl script, something else is running the script for you, and  that  something  else  may
       output  error  messages.  The script might emit its own warnings and error messages. Most of the time you
       cannot tell who said what.

       You probably cannot fix the thing that runs perl, but you can change how perl  outputs  its  warnings  by
       defining a custom warning and die functions.

       Consider this script, which has an error you may not notice immediately.

           #!/usr/locl/bin/perl

           print "Hello World\n";

       I  get  an error when I run this from my shell (which happens to be bash). That may look like perl forgot
       it has a print() function, but my shebang line is not the path to perl, so the shell runs the script, and
       I get the error.

           $ ./test
           ./test: line 3: print: command not found

       A quick and dirty fix involves a little bit of code, but this may be all  you  need  to  figure  out  the
       problem.

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

           BEGIN {
               $SIG{__WARN__} = sub{ print STDERR "Perl: ", @_; };
               $SIG{__DIE__}  = sub{ print STDERR "Perl: ", @_; exit 1};
           }

           $a = 1 + undef;
           $x / 0;
           __END__

       The  perl  message  comes out with "Perl" in front. The "BEGIN" block works at compile time so all of the
       compilation errors and warnings get the "Perl:" prefix too.

           Perl: Useless use of division (/) in void context at ./test line 9.
           Perl: Name "main::a" used only once: possible typo at ./test line 8.
           Perl: Name "main::x" used only once: possible typo at ./test line 9.
           Perl: Use of uninitialized value in addition (+) at ./test line 8.
           Perl: Use of uninitialized value in division (/) at ./test line 9.
           Perl: Illegal division by zero at ./test line 9.
           Perl: Illegal division by zero at -e line 3.

       If I don't see that "Perl:", it's not from perl.

       You could also just know all the perl errors, and although there are some people  who  may  know  all  of
       them,  you  probably  don't.  However,  they all should be in the perldiag manpage. If you don't find the
       error in there, it probably isn't a perl error.

       Looking up every message is not the easiest way, so let perl to do it for you. Use the diagnostics pragma
       with turns perl's normal messages into longer discussions on the topic.

           use diagnostics;

       If you don't get a paragraph or two of expanded discussion, it might not be perl's message.

   <b>How</b> <b>do</b> <b>I</b> <b>install</b> <b>a</b> <b>module</b> <b>from</b> <b>CPAN?</b>
       (contributed by brian d foy)

       The easiest way is to have a module also named CPAN do it for you by using the "cpan" command that  comes
       with Perl. You can give it a list of modules to install:

           $ cpan IO::Interactive Getopt::Whatever

       If you prefer "CPANPLUS", it's just as easy:

           $ cpanp i IO::Interactive Getopt::Whatever

       If  you  want to install a distribution from the current directory, you can tell "CPAN.pm" to install "."
       (the full stop):

           $ cpan .

       See the documentation for either of those commands to see what else you can do.

       If you want to try to install a distribution by yourself, resolving all dependencies  on  your  own,  you
       follow one of two possible build paths.

       For distributions that use <u>Makefile.PL</u>:

           $ perl Makefile.PL
           $ make test install

       For distributions that use <u>Build.PL</u>:

           $ perl Build.PL
           $ ./Build test
           $ ./Build install

       Some  distributions  may  need  to  link  to  libraries  or  other  third-party  code and their build and
       installation sequences may be more complicated.  Check any <u>README</u> or <u>INSTALL</u> files that you may find.

   <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>require</b> <b>and</b> <b>use?</b>
       (contributed by brian d foy)

       Perl runs "require" statement at run-time. Once Perl loads, compiles, and runs the file,  it  doesn't  do
       anything  else.  The  "use" statement is the same as a "require" run at compile-time, but Perl also calls
       the "import" method for the loaded package. These two are the same:

           use MODULE qw(import list);

           BEGIN {
               require MODULE;
               MODULE-&gt;import(import list);
           }

       However, you can suppress the "import" by using an explicit, empty  import  list.  Both  of  these  still
       happen at compile-time:

           use MODULE ();

           BEGIN {
               require MODULE;
           }

       Since  "use"  will  also call the "import" method, the actual value for "MODULE" must be a bareword. That
       is, "use" cannot load files by name, although "require" can:

           require "$ENV{HOME}/lib/Foo.pm"; # no @INC searching!

       See the entry for "use" in perlfunc for more details.

   <b>How</b> <b>do</b> <b>I</b> <b>keep</b> <b>my</b> <b>own</b> <b>module/library</b> <b>directory?</b>
       When you build modules, tell Perl where to install the modules.

       If you want to install modules for your own use, the easiest way  might  be  local::lib,  which  you  can
       download  from  CPAN.  It sets various installation settings for you, and uses those same settings within
       your programs.

       If you want more flexibility, you need to configure your CPAN client for your particular situation.

       For "Makefile.PL"-based distributions, use the INSTALL_BASE option when generating Makefiles:

           perl Makefile.PL INSTALL_BASE=/mydir/perl

       You can set this in your "CPAN.pm" configuration so modules automatically install in your private library
       directory when you use the CPAN.pm shell:

           % cpan
           cpan&gt; o conf makepl_arg INSTALL_BASE=/mydir/perl
           cpan&gt; o conf commit

       For "Build.PL"-based distributions, use the --install_base option:

           perl Build.PL --install_base /mydir/perl

       You can configure "CPAN.pm" to automatically use this option too:

           % cpan
           cpan&gt; o conf mbuild_arg "--install_base /mydir/perl"
           cpan&gt; o conf commit

       INSTALL_BASE tells these tools to put your modules into  <u>/mydir/perl/lib/perl5</u>.  See  "How  do  I  add  a
       directory to my include path (@INC) at runtime?" for details on how to run your newly installed modules.

       There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings
       that  older  versions  of ExtUtils::MakeMaker advocated. INSTALL_BASE does not support installing modules
       for multiple versions of Perl or different architectures under the same directory.  You  should  consider
       whether  you  really  want  that  and,  if  you  do,  use  the  older  PREFIX  and  LIB settings. See the
       ExtUtils::Makemaker documentation for more details.

   <b>How</b> <b>do</b> <b>I</b> <b>add</b> <b>the</b> <b>directory</b> <b>my</b> <b>program</b> <b>lives</b> <b>in</b> <b>to</b> <b>the</b> <b>module/library</b> <b>search</b> <b>path?</b>
       (contributed by brian d foy)

       If you know the directory already, you can add it to @INC as you would for any other directory. You might
       "use lib" if you know the directory at compile time:

           use lib $directory;

       The trick in this task is to find the directory. Before  your  script  does  anything  else  (such  as  a
       "chdir"), you can get the current working directory with the "Cwd" module, which comes with Perl:

           BEGIN {
               use Cwd;
               our $directory = cwd;
           }

           use lib $directory;

       You  can do a similar thing with the value of $0, which holds the script name. That might hold a relative
       path, but "rel2abs" can turn it into an absolute path. Once you have the

           BEGIN {
               use File::Spec::Functions qw(rel2abs);
               use File::Basename qw(dirname);

               my $path   = rel2abs( $0 );
               our $directory = dirname( $path );
           }

           use lib $directory;

       The FindBin module, which comes with Perl, might work. It finds the directory of  the  currently  running
       script and puts it in $Bin, which you can then use to construct the right library path:

           use FindBin qw($Bin);

       You  can  also  use  local::lib to do much of the same thing. Install modules using local::lib's settings
       then use the module in your program:

            use local::lib; # sets up a local lib at <a href="file:~/perl5">~/perl5</a>

       See the local::lib documentation for more details.

   <b>How</b> <b>do</b> <b>I</b> <b>add</b> <b>a</b> <b>directory</b> <b>to</b> <b>my</b> <b>include</b> <b>path</b> <b>(@INC)</b> <b>at</b> <b>runtime?</b>
       Here are the suggested ways of modifying your include path,  including  environment  variables,  run-time
       switches, and in-code statements:

       the "PERLLIB" environment variable
               $ export PERLLIB=/path/to/my/dir
               $ perl program.pl

       the "PERL5LIB" environment variable
               $ export PERL5LIB=/path/to/my/dir
               $ perl program.pl

       the "perl -Idir" command line flag
               $ perl -I/path/to/my/dir program.pl

       the "lib" pragma:
               use lib "$ENV{HOME}/myown_perllib";

       the local::lib module:
               use local::lib;

               use local::lib "<a href="file:~/myown_perllib">~/myown_perllib</a>";

   <b>Where</b> <b>are</b> <b>modules</b> <b>installed?</b>
       Modules  are  installed  on  a  case-by-case  basis (as provided by the methods described in the previous
       section), and in the operating system. All of these paths are stored in @INC, which you can display  with
       the one-liner

           perl -e 'print join("\n",@INC,"")'

       The same information is displayed at the end of the output from the command

           perl -V

       To find out where a module's source code is located, use

           perldoc -l Encode

       to  display  the  path  to the module. In some cases (for example, the "AutoLoader" module), this command
       will show the path to a separate "pod" file; the module itself should be in the same  directory,  with  a
       'pm' file extension.

   <b>What</b> <b>is</b> <b>socket.ph</b> <b>and</b> <b>where</b> <b>do</b> <b>I</b> <b>get</b> <b>it?</b>
       It's  a  Perl  4  style file defining values for system networking constants. Sometimes it is built using
       h2ph when Perl is installed, but other times it is not. Modern programs should use "use Socket;" instead.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and  other  authors  as  noted.  All  rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.

       Irrespective  of  its  distribution,  all  code  examples  in this file are hereby placed into the public
       domain. You are permitted and encouraged to use this code in your own programs for fun or for  profit  as
       you see fit. A simple comment in the code giving credit would be courteous but is not required.

perl v5.40.1                                       2025-04-14                                        <u><a href="../man1/PERLFAQ8.1.html">PERLFAQ8</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>