<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.vect.stats  - Count points in areas, calculate statistics from point attributes.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.vect.stats</b>  - Count points in areas, calculate statistics from point attributes.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, attribute table, database, univariate statistics, zonal statistics

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.vect.stats</b>
       <b>v.vect.stats</b> <b>--help</b>
       <b>v.vect.stats</b>    [-<b>p</b>]    <b>points</b>=<u>name</u>    <b>areas</b>=<u>name</u>    [<b>type</b>=<u>string</u>[,<u>string</u>,...]]     [<b>points_layer</b>=<u>string</u>]
       [<b>points_cats</b>=<u>range</u>]        [<b>points_where</b>=<u>sql_query</u>]        [<b>areas_layer</b>=<u>string</u>]        [<b>areas_cats</b>=<u>range</u>]
       [<b>areas_where</b>=<u>sql_query</u>]          [<b>method</b>=<u>string</u>]         [<b>points_column</b>=<u>name</u>]         [<b>count_column</b>=<u>name</u>]
       [<b>stats_column</b>=<u>name</u>]   [<b>separator</b>=<u>character</u>]   [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-p</b>
           Print output to stdout, do not update attribute table
           First column is always area category

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>points</b>=<u>name</u> <b>[required]</b>
           Name of existing vector map with points
           Or data source for direct OGR access

       <b>areas</b>=<u>name</u> <b>[required]</b>
           Name of existing vector map with areas
           Or data source for direct OGR access

       <b>type</b>=<u>string[,string</u>,...]
           Feature type
           Input feature type
           Options: <u>point,</u> <u>centroid</u>
           Default: <u>point</u>

       <b>points_layer</b>=<u>string</u>
           Layer number for points map
           Vector features can have category values in different layers. This number determines which  layer  to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>points_cats</b>=<u>range</u>
           Category values for points map
           Example: 1,3,7-9,13

       <b>points_where</b>=<u>sql_query</u>
           WHERE conditions of SQL statement without ’where’ keyword for points map
           Example: income &lt; 1000 and population &gt;= 10000

       <b>areas_layer</b>=<u>string</u>
           Layer number for area map
           Vector  features  can have category values in different layers. This number determines which layer to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>areas_cats</b>=<u>range</u>
           Category values for area map
           Example: 1,3,7-9,13

       <b>areas_where</b>=<u>sql_query</u>
           WHERE conditions of SQL statement without ’where’ keyword for area map
           Example: income &lt; 1000 and population &gt;= 10000

       <b>method</b>=<u>string</u>
           Method for aggregate statistics
           Options: <u>sum,</u> <u>average,</u> <u>median,</u> <u>mode,</u> <u>minimum,</u> <u>min_cat,</u> <u>maximum,</u>  <u>max_cat,</u>  <u>range,</u>  <u>stddev,</u>  <u>variance,</u>
           <u>diversity</u>

       <b>points_column</b>=<u>name</u>
           Column name of points map to use for statistics
           Column of points map must be numeric

       <b>count_column</b>=<u>name</u>
           Column name to upload points count
           Column to hold points count, must be of type integer, will be created if not existing

       <b>stats_column</b>=<u>name</u>
           Column name to upload statistics
           Column to hold statistics, must be of type double, will be created if not existing

       <b>separator</b>=<u>character</u>
           Field separator
           Special characters: pipe, comma, space, tab, newline
           Default: <u>pipe</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.vect.stats</u> counts the number of points in vector map <u>points</u> falling into each area in vector map <u>areas</u>.
       Optionally  statistics on point attributes in <u>points</u> are calculated for each area. The results are either
       uploaded to the attribute table of the vector map <u>areas</u> or printed to stdout.

   <b>Statistical</b> <b>methods</b>
       Using numeric attribute values of all points falling into a given area, a new value  is  determined  with
       the selected method.  <u>v.vect.stats</u> can perform the following operations:

       <b>sum</b>
           The sum of values.

       <b>average</b>
           The average value of all point attributes (sum / count).

       <b>median</b>
           The  value  found half-way through a list of the attribute values, when these are ranged in numerical
           order.

       <b>mode</b>
           The most frequently occurring value.

       <b>minimum</b>
           The minimum observed value.

       <b>min_cat</b>
           The point category corresponding to the minimum observed value.

       <b>maximum</b>
           The maximum observed value.

       <b>max_cat</b>
           The point category corresponding to the maximum observed value.

       <b>range</b>
           The range of the observed values.

       <b>stddev</b>
           The statistical standard deviation of the attribute values.

       <b>variance</b>
           The statistical variance of the attribute values.

       <b>diversity</b>
           The number of different attribute values.

</pre><h4><b>NOTES</b></h4><pre>
       Points not falling into any area are ignored. Areas without category (no centroid  attached  or  centroid
       without  category)  are ignored.  If no points are falling into a given area, the point count is set to 0
       (zero) and the statistics result to "null".

       The columns <u>count_column</u> and <u>stats_column</u> are created if not yet existing. If they do already exist,  the
       <u>count_column</u> must be of type integer and the <u>stats_column</u> of type double precision.

       In  case  that  <u>v.vect.stats</u>  complains  about the <u>points_column</u> of the input points vector map not being
       numeric, the module <u>v.db.update</u> can be used to perform  type  casting,  i.e.  adding  and  populating  an
       additional  numeric  column  with  the  values  type  converted  from string attributes to floating point
       numbers.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Preparation</b> <b>for</b> <b>examples</b>
       The subsequent examples are based on randomly sampled elevation data (North Carolina sample database):
       # work on map copy for attribute editing
       g.copy vector=zipcodes_wake,myzipcodes_wake
       # set computational region: extent of ZIP code map, raster pixels
       # aligned to raster map
       g.region vector=myzipcodes_wake align=elev_state_500m -p
       #  generate random elevation points
       r.random elev_state_500m vector=rand5000 n=5000
       v.colors rand5000 color=elevation
       # visualization
       d.mon wx0
       d.vect myzipcodes_wake -c
       d.vect rand5000
       These vector maps are used for the examples below.

   <b>Count</b> <b>points</b> <b>per</b> <b>polygon</b> <b>with</b> <b>printed</b> <b>output</b>
       <u>See</u> <u>above</u> <u>for</u> <u>the</u> <u>creation</u> <u>of</u> <u>the</u> <u>input</u> <u>maps.</u>

       Counting points per polygon, print results to terminal:
       v.vect.stats points=rand5000 area=myzipcodes_wake -p

   <b>Count</b> <b>points</b> <b>per</b> <b>polygon</b> <b>with</b> <b>column</b> <b>update</b>
       <u>See</u> <u>above</u> <u>for</u> <u>the</u> <u>creation</u> <u>of</u> <u>the</u> <u>input</u> <u>maps.</u>

       Counting of points per polygon, with update of "num_points" column (will be automatically created):
       v.vect.stats points=rand5000 area=myzipcodes_wake count_column=num_points
       # verify result
       v.db.select myzipcodes_wake column=ZIPCODE_,ZIPNAME,num_points

   <b>Average</b> <b>values</b> <b>of</b> <b>points</b> <b>in</b> <b>polygon</b> <b>with</b> <b>printed</b> <b>output</b>
       <u>See</u> <u>above</u> <u>for</u> <u>the</u> <u>creation</u> <u>of</u> <u>the</u> <u>input</u> <u>maps.</u>

       Calculation of average point elevation per ZIP code polygon,  printed  to  terminal  in  comma  separated
       style:
       # check name of point map column:
       v.info -c rand5000
       v.vect.stats points=rand5000 area=myzipcodes_wake \
         method=average points_column=value separator=comma -p

   <b>Average</b> <b>values</b> <b>of</b> <b>points</b> <b>in</b> <b>polygon</b> <b>with</b> <b>column</b> <b>update</b>
       <u>See</u> <u>above</u> <u>for</u> <u>the</u> <u>creation</u> <u>of</u> <u>the</u> <u>input</u> <u>maps.</u>

       Calculation  of  average  point  elevation  per  ZIP  code  polygon, with update of "avg_elev" column and
       counting of points per polygon, with update of "num_points" column (new  columns  will  be  automatically
       created):
       # check name of point map column:
       v.info -c rand5000
       v.vect.stats points=rand5000 area=myzipcodes_wake count_column=num_points \
         method=average points_column=value stats_column=avg_elev
       # verify result
       v.db.select myzipcodes_wake column=ZIPCODE_,ZIPNAME,avg_elev

   <b>Point</b> <b>statistics</b> <b>in</b> <b>a</b> <b>hexagonal</b> <b>grid</b>
       The  grid  extent  and size is influenced by the current computational region. The extent is based on the
       vector map <u>points_of_interest</u> from the basic North Carolina sample dataset.
       g.region vector=points_of_interest res=2000 -pa
       The hexagonal grid is created using the <u>v.mkgrid</u> module as a vector map based on the previously  selected
       extent and size of the grid.
       v.mkgrid map=hexagons -h
       The  <u>v.vect.stats</u>  module counts the number of points and does one statistics on a selected column (here:
       <u>elev_m</u>).
       v.vect.stats points=points_of_interest areas=hexagons method=average \
         points_column=elev_m count_column=count stats_column=average
       User should note that some of the points may be outside the grid since the hexagons cannot cover all  the
       area  around  the  edges  (the  computational  region extent needs to be enlarged if all points should be
       considered).  The last command sets the vector map color table to viridis based on the count column.
       v.colors map=hexagons use=attr column=average color=viridis
       Point statistics in a hexagonal grid (count of points, average of values associated with point,  standard
       deviation)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
           •   <u>v.rast.stats</u>  for  zonal statistics of raster maps using vector zones (univariate statistics of a
               raster map),

           •   <u>r.stats.zonal</u> for zonal statistics of raster map using raster zones (univariate statistics  using
               two raster maps),

           •   <u>v.what.vect</u> for querying one vector map by another,

           •   <u>v.distance</u> for finding nearest features,

           •   <u>r.distance</u> for computing distances between objects in raster maps,

           •   <u>v.mkgrid</u> for creating vector grids to aggregate point data.

</pre><h4><b>AUTHOR</b></h4><pre>
       Markus Metz

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.vect.stats source code (history)

       Accessed: Friday Apr 04 01:20:40 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                 <u><a href="../man1grass/v.vect.stats.1grass.html">v.vect.stats</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>