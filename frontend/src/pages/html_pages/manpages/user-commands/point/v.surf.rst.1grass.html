<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>v.surf.rst  - Performs surface interpolation from vector points map by splines.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>v.surf.rst</b>  - Performs surface interpolation from vector points map by splines.
       Spatial  approximation  and  topographic  analysis  from  given point or isoline data in vector format to
       floating point raster format using regularized spline with tension.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, surface, interpolation, splines, RST, 3D, no-data filling, parallel

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>v.surf.rst</b>
       <b>v.surf.rst</b> <b>--help</b>
       <b>v.surf.rst</b> [-<b>ctd</b>]  <b>input</b>=<u>name</u>   [<b>layer</b>=<u>string</u>]    [<b>zcolumn</b>=<u>name</u>]    [<b>where</b>=<u>sql_query</u>]    [<b>elevation</b>=<u>name</u>]
       [<b>slope</b>=<u>name</u>]        [<b>aspect</b>=<u>name</u>]       [<b>pcurvature</b>=<u>name</u>]       [<b>tcurvature</b>=<u>name</u>]       [<b>mcurvature</b>=<u>name</u>]
       [<b>deviations</b>=<u>name</u>]    [<b>cvdev</b>=<u>name</u>]    [<b>treeseg</b>=<u>name</u>]    [<b>overwin</b>=<u>name</u>]    [<b>nprocs</b>=<u>integer</u>]     [<b>mask</b>=<u>name</u>]
       [<b>tension</b>=<u>float</u>]      [<b>smooth</b>=<u>float</u>]      [<b>smooth_column</b>=<u>string</u>]      [<b>segmax</b>=<u>integer</u>]     [<b>npmin</b>=<u>integer</u>]
       [<b>dmin</b>=<u>float</u>]   [<b>dmax</b>=<u>float</u>]   [<b>zscale</b>=<u>float</u>]   [<b>theta</b>=<u>float</u>]   [<b>scalex</b>=<u>float</u>]    [--<b>overwrite</b>]   [--<b>help</b>]
       [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-c</b>
           Perform cross-validation procedure without raster approximation

       <b>-t</b>
           Use scale dependent tension

       <b>-d</b>
           Output partial derivatives instead of topographic parameters

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name</u> <b>[required]</b>
           Name of input vector map
           Or data source for direct OGR access

       <b>layer</b>=<u>string</u>
           Layer number or name
           Vector  features  can have category values in different layers. This number determines which layer to
           use. When used with direct OGR access this is the layer name.
           Default: <u>1</u>

       <b>zcolumn</b>=<u>name</u>
           Name of the attribute column with values to be used for approximation
           If not given and input is 2D vector map then category values are used. If input is 3D vector map then
           z-coordinates are used.

       <b>where</b>=<u>sql_query</u>
           WHERE conditions of SQL statement without ’where’ keyword
           Example: income &lt; 1000 and population &gt;= 10000

       <b>elevation</b>=<u>name</u>
           Name for output surface elevation raster map

       <b>slope</b>=<u>name</u>
           Name for output slope raster map

       <b>aspect</b>=<u>name</u>
           Name for output aspect raster map

       <b>pcurvature</b>=<u>name</u>
           Name for output profile curvature raster map

       <b>tcurvature</b>=<u>name</u>
           Name for output tangential curvature raster map

       <b>mcurvature</b>=<u>name</u>
           Name for output mean curvature raster map

       <b>deviations</b>=<u>name</u>
           Name for output deviations vector point map

       <b>cvdev</b>=<u>name</u>
           Name for output cross-validation errors vector point map

       <b>treeseg</b>=<u>name</u>
           Name for output vector map showing quadtree segmentation

       <b>overwin</b>=<u>name</u>
           Name for output vector map showing overlapping windows

       <b>nprocs</b>=<u>integer</u>
           Number of threads for parallel computing
           Default: <u>1</u>

       <b>mask</b>=<u>name</u>
           Name of raster map used as mask

       <b>tension</b>=<u>float</u>
           Tension parameter
           Default: <u>40.</u>

       <b>smooth</b>=<u>float</u>
           Smoothing parameter
           Smoothing is by default 0.5 unless smooth_column is specified

       <b>smooth_column</b>=<u>string</u>
           Name of the attribute column with smoothing parameters

       <b>segmax</b>=<u>integer</u>
           Maximum number of points in a segment
           Default: <u>40</u>

       <b>npmin</b>=<u>integer</u>
           Minimum number of points for approximation in a segment (&gt;segmax)
           Default: <u>300</u>

       <b>dmin</b>=<u>float</u>
           Minimum distance between points (to remove almost identical points)

       <b>dmax</b>=<u>float</u>
           Maximum distance between points on isoline (to insert additional points)

       <b>zscale</b>=<u>float</u>
           Conversion factor for values used for approximation
           Default: <u>1.0</u>

       <b>theta</b>=<u>float</u>
           Anisotropy angle (in degrees counterclockwise from East)

       <b>scalex</b>=<u>float</u>
           Anisotropy scaling factor

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>v.surf.rst</u> program performs spatial approximation based on <u>z-values</u> (input vector map is 3D  and  <b>zcolumn</b>
       parameter  is  not  given),  <u>categories</u>  (input  vector map is 2D and <b>zcolumn</b> parameter is not given), or
       <u>attributes</u> (<b>zcolumn</b> parameter is given) of point or isoline data given in a vector  map  named  <b>input</b>  to
       grid cells in the output raster map <b>elevation</b> representing a surface.

       As  an option, simultaneously with approximation, topographic parameters slope, aspect, profile curvature
       (measured in the direction of the steepest slope), tangential curvature (measured in the direction  of  a
       tangent to contour line) or mean curvature are computed and saved as raster maps specified by the options
       <b>slope,</b>  <b>aspect,</b>  <b>pcurv,</b>  <b>tcurv,</b>  <b>mcurv</b>  respectively.  If  <b>-d</b>  flag  is  set,  <u>v.surf.rst</u> outputs partial
       derivatives fx,fy,fxx, fyy,fxy  instead  of  slope,  aspect,  profile,  tangential  and  mean  curvatures
       respectively.  If  the  input  vector  map have time stamp, the program creates time stamp for all output
       maps.

       User can either use <u>r.mask</u> to set a mask or specify a raster map in <b>mask</b> option, which will be used as  a
       mask.  The  approximation is skipped for cells which have zero or NULL value in mask. NULL values will be
       assigned to these cells in all output raster maps. Data points  are  checked  for  identical  points  and
       points  that are closer to each other than the given <b>dmin</b> are removed.  If sparsely digitized contours or
       isolines are used as input, additional points are computed between  each  2  points  on  a  line  if  the
       distance  between  them is greater than specified <b>dmax</b>. Parameter <b>zmult</b> allows user to rescale the values
       used for approximation (useful e.g. for transformation of elevations given in feet to meters, so that the
       proper values of slopes and curvatures can be computed).

       Regularized spline with tension is used for the approximation. The <b>tension</b> parameter tunes the  character
       of  the  resulting surface from thin plate to membrane. Smoothing parameter <b>smooth</b> controls the deviation
       between the given points and the resulting surface and it can be very effective in smoothing  noisy  data
       while  preserving  the  geometrical  properties of the surface.  With the smoothing parameter set to zero
       (<b>smooth=0</b>) the resulting surface passes  exactly  through  the  data  points  (spatial  interpolation  is
       performed). When smoothing parameter is used, it is also possible to output a vector point map <b>deviations</b>
       containing deviations of the resulting surface from the given data.

       If  the  number of given points is greater than <b>segmax</b>, segmented processing is used. The region is split
       into quadtree-based rectangular segments, each having  less  than  <b>segmax</b>  points  and  approximation  is
       performed  on  each  segment  of  the  region.  To ensure smooth connection of segments the approximation
       function for each segment is computed using the points in  the  given  segment  and  the  points  in  its
       neighborhood  which  are  in  the  rectangular window surrounding the given segment. The number of points
       taken for approximation is controlled by <b>npmin</b>, the value of which must be larger than <b>segmax</b>.  User  can
       choose  to output vector maps <b>treeseg</b> and <b>overwin</b> which represent the quad tree used for segmentation and
       overlapping neighborhoods from which additional points for approximation on each segment were taken.

       Predictive error of surface approximation for given parameters can be  computed  using  the  <b>-c</b>  flag.  A
       crossvalidation  procedure  is  then  performed  using  the  data  given  in the vector map <b>input</b> and the
       estimated predictive errors are stored in the vector point map <b>cvdev</b>. When using  this  flag,  no  raster
       output maps are computed.  Anisotropic surfaces can be interpolated by setting anisotropy angle <b>theta</b> and
       scaling factor <b>scalex</b>.  The program writes values of selected input and internally computed parameters to
       the history file of raster map <b>elevation</b>.

       The user must run <u>g.region</u> before the program to set the region and resolution for approximation.

</pre><h4><b>NOTES</b></h4><pre>
       <u>v.surf.rst</u>  uses  regularized spline with tension for approximation from vector data. The module does not
       require input data with topology, therefore both level1 (no topology) and level2 (with  topology)  vector
       point  data  are supported.  Additional points are used for approximation between each 2 points on a line
       if the distance between them is greater than specified <b>dmax</b>. If <b>dmax</b> is small (less than cell  size)  the
       number  of  added  data  points  can  be  vary  large  and  slow  down  approximation significantly.  The
       implementation has a segmentation procedure based on quadtrees which enhances the  efficiency  for  large
       data sets. Special color tables are created by the program for output raster maps.

       Topographic  parameters  are  computed  directly  from  the  approximation function so that the important
       relationships between these parameters are preserved. The equations for computation of  these  parameters
       and  their  interpretation  is  described  in Mitasova and Hofierka, 1993 or Neteler and Mitasova, 2004).
       Slopes and aspect are computed in degrees (0-90 and 1-360 respectively).  The aspect raster map has value
       0 assigned to flat areas (with slope less than 0.1%) and to singular points with undefined aspect. Aspect
       points downslope and is 90 to the North, 180 to the West, 270 to the South  and  360  to  the  East,  the
       values  increase  counterclockwise.  Curvatures  are  positive for convex and negative for concave areas.
       Singular points with undefined curvatures have assigned zero values.

       Tension and smoothing allow user to tune the surface character.  For most  landscape  scale  applications
       the  default  values  should  provide  adequate  results.   The  program  gives  warning when significant
       overshoots appear in the resulting surface and higher tension or smoothing should be used.

       To select parameters that will produce a surface with desired properties, it is useful to know  that  the
       method  is  scale  dependent  and the tension works as a rescaling parameter (high tension "increases the
       distances between the points" and reduces the range of impact of each point, low tension  "decreases  the
       distance"  and  the  points  influence  each  other over longer range). Surface with tension set too high
       behaves like a membrane (rubber sheet stretched over the data points) with peak or pit ("crater") in each
       given point and everywhere else the surface goes rapidly to trend. If  digitized  contours  are  used  as
       input data, high tension can cause artificial waves along contours. Lower tension and higher smoothing is
       suggested for such a case.

       Surface with <b>tension</b> set too low behaves like a stiff steel plate and overshoots can appear in areas with
       rapid change of gradient and segmentation can be visible. Increase in tension should solve the problems.

       There  are  two  options  how <b>tension</b> can be applied in relation to <b>dnorm</b> (dnorm rescales the coordinates
       depending on the average data density so that the size of segments with <b>segmax=</b>40 points is  around  1  -
       this ensures the numerical stability of the computation):

       <b>1</b>      Default:  the given <b>tension</b> is applied to normalized data (<u>x/dnorm</u>), that means that the distances
              are multiplied (rescaled) by <u>tension/dnorm</u>. If density of points is changed, e.g., by using higher
              <b>dmin</b>, the <b>dnorm</b> changes and <b>tension</b> needs to be changed too to get the same result.   Because  the
              <b>tension</b>  is  applied  to normalized data its suitable value is usually within the 10-100 range and
              does not depend on the actual scale (distances) of the original data (which can be km for regional
              applications or cm for field experiments).

       <b>2</b>      Flag<b>-t</b>: The given <b>tension</b> is applied to un-normalized data (rescaled <u>tension</u> <u>=</u>  <u>tension*dnorm/1000</u>
              is  applied  to  normalized  data (<u>x/dnorm</u>) and therefore <b>dnorm</b> cancels out) so here <b>tension</b> truly
              works as a rescaling parameter.  For regional applications with distances between points in km the
              suitable tension can be 500 or higher, for detailed field scale analysis it can be  0.1.  To  help
              select  how  much  the  data  need  to  be  rescaled the program writes <b>dnorm</b> and rescaled tension
              <u>fi=tension*dnorm/1000</u> at the beginning of the program run. This rescaled <b>tension</b> should be  around
              20-30. If it is lower or higher, the given <b>tension</b> parameter should be changed accordingly.

       The  default is a recommended choice, however for the applications where the user needs to change density
       of data and preserve the approximation character the <b>-t</b> flag can be helpful.

       Anisotropic data  (e.g.  geologic  phenomena)  can  be  interpolated  using  <b>theta</b>  and  <b>scalex</b>  defining
       orientation  and  ratio  of  the  perpendicular  axes  put  on  the longest/shortest side of the feature,
       respectively. <b>Theta</b> is measured in degrees from East, counterclockwise. <b>Scalex</b> is a ratio of axes  sizes.
       Setting <b>scalex</b> in the range 0-1, results in a pattern prolonged in the direction defined by <b>theta</b>. <b>Scalex</b>
       value  0.5  means  that modeled feature is approximately 2 times longer in the direction of <b>theta</b> than in
       the perpendicular direction.  <b>Scalex</b> value 2 means that axes ratio is  reverse  resulting  in  a  pattern
       perpendicular to the previous example. Please note that anisotropy option has not been extensively tested
       and  may  include bugs (for example, topographic parameters may not be computed correctly) - if there are
       problems, please report to GRASS bugtracker (accessible from https://grass.osgeo.org/).

       For data with values changing over several magnitudes (sometimes the concentration or density data) it is
       suggested to interpolate the log of the values rather than the original ones.

       <u>v.surf.rst</u> checks the numerical stability of the algorithm by computing the values in given  points,  and
       prints  the  root  mean  square  deviation (rms) found into the history file of raster map <b>elevation</b>. For
       computation with smoothing set to 0, rms should be 0. Significant increase in <b>tension</b> is suggested if the
       rms is unexpectedly high for this case. With smoothing parameter greater than zero the surface  will  not
       pass  exactly  through the data points and the higher the parameter the closer the surface will be to the
       trend. The rms then represents a measure of smoothing effect on data. More detailed analysis of smoothing
       effects can be performed using the output deviations option.

       <u>v.surf.rst</u> also writes the values of parameters used in computation into the comment part of history file
       <b>elevation</b> as well as the following values which help to evaluate the  results  and  choose  the  suitable
       parameters:  minimum and maximum z values in the data file (zmin_data, zmax_data) and in the interpolated
       raster map (zmin_int, zmax_int), rescaling parameter used for normalization (dnorm), which influences the
       tension.

       If visible connection of segments appears, the program should be rerun with  higher  <b>npmin</b>  to  get  more
       points from the neighborhood of given segment and/or with higher tension.

       When  the  number  of  points  in  a  vector  map  is  not  too  large (less than 800), the user can skip
       segmentation by setting <b>segmax</b> to the number of data points or <b>segmax=700</b>.

       <u>v.surf.rst</u> gives warning when user wants to interpolate  outside  the  rectangle  given  by  minimum  and
       maximum  coordinates  in the vector map, zoom into the area where the given data are is suggested in this
       case.

       When a <b>mask</b> is used, the program takes all points in the given region for approximation, including  those
       in  the  area  which  is  masked  out,  to  ensure  proper approximation along the border of the mask. It
       therefore does not mask out the data points, if this is desirable, it must be done outside <u>v.surf.rst</u>.

   <b>Cross</b> <b>validation</b> <b>procedure</b>
       The "optimal" approximation parameters for  given  data  can  be  found  using  a  cross-validation  (CV)
       procedure  (<b>-c</b>  flag).   The CV procedure is based on removing one input data point at a time, performing
       the approximation for the location of the removed point using the remaining data points  and  calculating
       the  difference  between  the  actual and approximated value for the removed data point. The procedure is
       repeated until every data point has been, in turn, removed.  This  form  of  CV  is  also  known  as  the
       "leave-one-out"  or  "jack-knife"  method  (Hofierka  et  al.,  2002;  Hofierka,  2005).  The differences
       (residuals) are then stored in the <b>cvdev</b> output vector map. Please note that during the CV  procedure  no
       other  output  maps  can be set, the approximation is performed only for locations defined by input data.
       To find "optimal parameters",  the  CV  procedure  must  be  iteratively  performed  for  all  reasonable
       combinations  of  the  approximation parameters with small incremental steps (e.g. tension, smoothing) in
       order to find a combination with minimal statistical error (also called predictive error) defined by root
       mean squared error (RMSE), mean absolute error (MAE) or other error characteristics.  A script with loops
       for tested RST parameters can do the job, necessary statistics can be calculated using e.g. <u>v.univar</u>.  It
       should  be noted that crossvalidation is a time-consuming procedure, usually reasonable for up to several
       thousands of points. For larger data sets, CV should be applied to a representative subset of  the  data.
       The  cross-validation  procedure  works  well  only  for  well-sampled  phenomena and when minimizing the
       predictive error is the goal.  The parameters found by minimizing the predictive (CV) error may  not  not
       be  the  best  for  for poorly sampled phenomena (result could be strongly smoothed with lost details and
       fluctuations) or when significant noise is present that needs to be smoothed out.

</pre><h4><b>EXAMPLE</b></h4><pre>
   <b>Setting</b> <b>for</b> <b>lidar</b> <b>point</b> <b>cloud</b>
       Lidar point clouds as well as UAS SfM-based (phodar) point clouds tend to be dense  in  relation  to  the
       desired raster resolution and thus a different set of parameters is more advantageous, e.g. in comparison
       to a typical temperature data interpolation.
       v.surf.rst input=points elevation=elevation npmin=100

   <b>Usage</b> <b>of</b> <b>the</b> <b>where</b> <b>parameter</b>
       Using the <b>where</b> parameter, the interpolation can be limited to use only a subset of the input vectors.

       North  Carolina  example  (we  simulate randomly distributed elevation measures which we interpolate to a
       gap-free elevation surface):
       g.region raster=elevation -p
       # random elevation extraction of 500 samplings
       r.random -s elevation vector=elevrand n=500
       v.info -c elevrand
       v.db.select elevrand
       # interpolation based on all points
       v.surf.rst elevrand zcol=value elevation=elev_full
       # apply the color table of the original raster map
       r.colors elev_full raster=elevation
       d.rast elev_full
       d.vect elevrand
       # compute univariate statistics with 1st/3rd quartiles
       v.db.univar -e elevrand column=value
       # interpolation based on subset of points (only those over 1st quartile)
       v.surf.rst input=elevrand zcolumn=value elevation=elev_partial npmin=100 where="value &gt; 94.9"
       r.colors map=elev_partial raster=elevation
       d.rast elev_partial
       d.vect elevrand where="value &gt; 94.9"

</pre><h4><b>REFERENCES</b></h4><pre>
           •   Mitasova, H., Mitas, L. and Harmon, R.S., 2005, Simultaneous spline approximation and topographic
               analysis for lidar elevation data in open source GIS, IEEE GRSL 2 (4), 375- 379.

           •   Hofierka, J., 2005, Interpolation of Radioactivity Data Using Regularized  Spline  with  Tension.
               Applied GIS, Vol. 1, No. 2, pp. 16-01 to 16-13. DOI: 10.2104/ag050016

           •   Hofierka J., Parajka J., Mitasova H., Mitas L., 2002, Multivariate Interpolation of Precipitation
               Using Regularized Spline with Tension.  Transactions in GIS <a href="../man2/6.2.html">6</a>(2), pp. 135-150.

           •   H.  Mitasova,  L.  Mitas,  B.M.  Brown,  D.P. Gerdes, I. Kosinovsky, 1995, Modeling spatially and
               temporally distributed phenomena: New methods and tools for GRASS GIS. International  Journal  of
               GIS, 9 (4), special issue on Integrating GIS and Environmental modeling, 433-446.

           •   Mitasova, H. and Mitas, L., 1993: Interpolation by Regularized Spline with Tension: I. Theory and
               Implementation, Mathematical Geology ,25, 641-655.

           •   Mitasova,  H.  and  Hofierka,  J.,  1993:  Interpolation  by Regularized Spline with Tension: II.
               Application to Terrain Modeling and Surface Geometry Analysis, Mathematical Geology 25, 657-667.

           •   Mitas, L., and Mitasova H., 1988,  General variational approach  to  the  approximation  problem,
               Computers and Mathematics with Applications, v.16, p. 983-992.

           •   Neteler, M. and Mitasova, H., 2008, Open Source GIS: A GRASS GIS Approach, 3rd Edition, Springer,
               New York, 406 pages.

           •   Talmi, A. and Gilat, G., 1977 : Method for Smooth Approximation of Data, Journal of Computational
               Physics, 23, p.93-123.

           •   Wahba,  G.,  1990, : Spline Models for Observational Data, CNMS-NSF Regional Conference series in
               applied mathematics, 59, SIAM, Philadelphia, Pennsylvania.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>v.vol.rst,</u> <u>v.surf.idw,</u> <u>v.surf.bspline,</u> <u>r.fillnulls,</u> <u>g.region</u>

       Overview: Interpolation and Resampling in GRASS GIS

       For examples of applications see GRASS4 implementation and GRASS5 and GRASS6 implementation.

</pre><h4><b>AUTHORS</b></h4><pre>
       <u>Original</u> <u>version</u> <u>of</u> <u>program</u> <u>(in</u> <u>FORTRAN)</u> <u>and</u> <u>GRASS</u> <u>enhancements</u>:
       Lubos Mitas, NCSA, University of Illinois at Urbana Champaign, Illinois, USA (1990-2000);  Department  of
       Physics, North Carolina State University, Raleigh
       Helena  Mitasova,  USA  CERL,  Department  of  Geography, University of Illinois at Urbana-Champaign, USA
       (1990-2001); MEAS, North Carolina State University, Raleigh

       <u>Modified</u> <u>program</u> <u>(translated</u> <u>to</u> <u>C,</u> <u>adapted</u> <u>for</u> <u>GRASS,</u> <u>new</u> <u>segmentation</u> <u>procedure):</u>
       Irina Kosinovsky, US Army CERL, Dave Gerdes, US Army CERL

       <u>Modifications</u> <u>for</u> <u>new</u> <u>sites</u> <u>format</u> <u>and</u> <u>timestamping:</u>
       Darrel McCauley, Purdue University, Bill Brown, US Army CERL

       <u>Update</u> <u>for</u> <u>GRASS5.7,</u> <u>GRASS6</u> <u>and</u> <u>addition</u> <u>of</u> <u>crossvalidation:</u>
       Jaroslav Hofierka, University of Presov; Radim Blazek, ITC-irst

       <u>Parallelization</u> <u>using</u> <u>OpenMP:</u>
       Stanislav Zubal, Czech Technical University in Prague
       Michal Lacko, Pavol Jozef Safarik University in Kosice

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: v.surf.rst source code (history)

       Accessed: Friday Apr 04 01:20:35 2025

       Main index | Vector index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                   <u><a href="../man1grass/v.surf.rst.1grass.html">v.surf.rst</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>