<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>csharp - Interactive C# Shell and Scripting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/mono-csharp-shell">mono-csharp-shell_6.12.0.199+dfsg-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       csharp - Interactive C# Shell and Scripting

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>csharp</b> <b>[--attach</b> <b>PID]</b> <b>[-e</b> <b>EXPRESSION]</b> <b>[file1</b> <b>[file2]]</b> [compiler-options] [--|-s script-options]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>csharp</u>  command  is  an  interactive  C#  shell and scripting host that allows the user to enter and
       evaluate C# statements and expressions from the command line or execute  C#  scripts.   The  regular  <u>mcs</u>
       command line options can be used in this version of the compiler.

       Files specified in the command line will be loaded and executed as scripts.

       Starting with Mono 2.10, the <u>csharp</u> command can be used as an interpreter executed by executables flagged
       with the Unix execute attribute.   To do this, make the first line of your C# source code look like this:

         #!/usr/bin/csharp
         Console.WriteLine ("Hello, World");

       Starting  with  Mono  5.0,  command  line arguments may now be passed to the <u>csharp</u> command by specifying
       either the <u>-s</u> or <u>--</u> (script) options.

       The <u>-s</u> option is ideal for interpreting executable scripts that utilize  shebang  syntax  (introduced  in
       Mono 2.10). This allows command line arguments to be passed to and consumed cleanly by the script:

         #!/usr/bin/csharp -s
         foreach (var arg in Args)
           Console.WriteLine ($"script argument: {arg}");

</pre><h4><b>OPTIONS</b></h4><pre>
       The  commands  accept  all  of  the  commands that are available to the <u>mcs</u> command, so you can reference
       assemblies, specify paths, language level and so on from the command line.   In addition,  the  following
       command line options are supported:

       <u>-s</u> <u>SCRIPT_FILE</u>
              This  option is ideal for authoring executable scripts that utilize the Unix shebang feature. Unix
              will implicitly append as an argument the path of the script to execute. When  the  executable  is
              invoked,  any  arguments  then  passed  to  it  will  be  available  in  the <u>Args</u> global. Example:
              <u>#!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?env">/usr/bin/env</a></u> <u>csharp</u> <u>-s</u>

       <u>--</u>     Any arguments that follow will not be passed to the compiler driver,  and  instead  will  be  made
              available  in the <u>Args</u> global. Example: <u>csharp</u> <u>--</u> <u>a</u> <u>b</u> <u>c</u> will result in Args = { "a", "b", "c" } in
              the interactive shell.

       <u>--attach</u>
              This is an advanced option and should only be used if you have  a  deep  understanding  of  multi-
              threading.      This  option  is  availble  on  the  <u>csharp</u>  command and allows the compiler to be
              injected into other processes.  This is done by injecting the C# shell in a separate  thread  that
              runs  concurrently with your application.  This means that you must take special measures to avoid
              crashing the target application while using it.  For example, you might have to  take  the  proper
              locks  before issuing any commands that might affect the target process state, or sending commands
              through a method dispatcher.

       <u>-e</u> <u>EXPRESSION</u>
              This will evaluate the specified C# EXPRESSION and exit

</pre><h4><b>OPERATION</b></h4><pre>
       Once you launch the csharp command, you will be greeted with the interactive prompt:

       $ csharp
       Mono C# Shell, type "help;" for help

       Enter statements below.
       csharp&gt;

       A number of namespaces are pre-defined with C# these include System, System.Linq, System.Collections  and
       System.Collections.Generic.   Unlike the compiled mode, it is possible to add new using statements as you
       type code, for example:

       csharp&gt; new XmlDocument ();
       &lt;interactive&gt;(1,6): error CS0246: The type or namespace name `XmlDocument' could not be found. Are you missing a using directive or an assembly reference?
       csharp&gt; using System.Xml;
       csharp&gt; new XmlDocument ();
       System.Xml.XmlDocument

       Every time a command is typed, the scope of that command is one of a class that derives  from  the  class
       Mono.CSharp.InteractiveBase.   This class defines a number of static properties and methods.   To display
       a list of available commands access the `help' property:
       csharp&gt; help;
       "Static methods:
         LoadPackage (pkg); - Loads the given Package (like -pkg:FILE)
         [...]
         ShowVars ();       - Shows defined local variables.
         ShowUsing ();      - Show active using decltions.
         help;
       "
       csharp&gt;

       When expressions are entered, the C# shell will display the result of executing the expression:

       csharp&gt; Math.Sin (Math.PI/4);
       0.707106781186547
       csharp&gt; 1+1;
       2
       csharp&gt; "Hello, world".IndexOf (',');
       5

       The  C# shell uses the ToString() method on the returned object to display the object, this sometimes can
       be limiting since objects that do not override the ToString() method will get the default  behavior  from
       System.Object which is merely to display their type name:

       csharp&gt; var a = new XmlDocument ();
       csharp&gt; a;
       System.Xml.Document
       csharp&gt; csharp&gt; a.Name;
       "#document"
       csharp&gt;

       A    few    datatypes    are   handled   specially   by   the   C#   interactive   shell   like   arrays,
       System.Collections.Hashtable, objects that implement System.Collections.IEnumerable and  IDictionary  and
       are rendered specially instead of just using ToString ():

       csharp&gt; var pages = new Hashtable () {
             &gt;  { "Mono",    "<a href="http://www.mono-project.com/">http://www.mono-project.com/</a>" },
             &gt;  { "Linux",   "<a href="http://kernel.org">http://kernel.org</a>" } };
       csharp&gt; pages;
       {{ "Mono", "<a href="http://www.mono-project.com/">http://www.mono-project.com/</a>" }, { "Linux", "<a href="http://kernel.org">http://kernel.org</a>" }}

       It  is possible to use LINQ directly in the C# interactive shell since the System.Linq namespace has been
       imported at startup.   The following sample gets a list of all the files that have not been accessed in a
       week from <a href="file:/tmp">/tmp</a>:

       csharp&gt; using System.IO;
       csharp&gt; var last_week = DateTime.Now - TimeSpan.FromDays (7);
       csharp&gt; var old_files = from f in Directory.GetFiles ("<a href="file:/tmp">/tmp</a>")
             &gt;   let fi = new FileInfo (f)
             &gt;   where fi.LastAccessTime &lt; LastWeek select f;
       csharp&gt;

       You can of course print the results in a single statement as well:

       csharp&gt; using System.IO;
       csharp&gt; var last_week = DateTime.Now - TimeSpan.FromDays (7);
       csharp&gt; from f in Directory.GetFiles ("<a href="file:/tmp">/tmp</a>")
             &gt;   let fi = new FileInfo (f)
             &gt;   where fi.LastAccessTime &lt; last_week select f;
       [...]
       csharp&gt;

       LINQ and its functional foundation produce on-demand code for IEnumerable return values.   For  instance,
       the  return  value  from  a  using  `from' is an IEnumerable that is evaluated on demand.   The automatic
       rendering of IEnumerables on the command line will trigger the IEnumerable pipeline to  execute  at  that
       point instead of having its execution delayed until a later point.

       If  you  want  to  avoid  having  the  IEnumerable  rendered  at this point, simply assign the value to a
       variable.

       Unlike compiled C#, the type of a variable can be changed if a new declaration is entered, for example:

       csharp&gt; var a = 1;
       csharp&gt; a.GetType ();
       System.Int32
       csharp&gt; var a = "Hello";
       csharp&gt; a.GetType ();
       System.String
       csharp&gt; ShowVars ();
       string a = "Hello"

       In the case that an expression or a statement is not completed in a single line, a continuation prompt is
       displayed, for example:

       csharp&gt; var protocols = new string [] {
             &gt;    "ftp",
             &gt;    "http",
             &gt;    "gopher"
             &gt; };
       csharp&gt; protocols;
       { "ftp", "http", "gopher" }

       Long running computations can be interrupted by using the Control-C sequence:

       csharp&gt; var done = false;
       csharp&gt; while (!done) { }
       Interrupted!
       System.Threading.ThreadAbortException: Thread was being aborted
         at Class1.Host (System.Object&amp; $retval) [0x00000]
         at Mono.CSharp.InteractiveShell.ExecuteBlock (Mono.CSharp.Class host, Mono.CSharp.Undo undo) [0x00000]
       csharp&gt;

</pre><h4><b>INTERACTIVE</b> <b>EDITING</b></h4><pre>
       The C# interactive shell contains a line-editor that  provides  a  more  advanced  command  line  editing
       functionality  than the operating system provides.   These are available in the command line version, the
       GUI versions uses the standard Gtk# key bindings.

       The command set is similar to many other applications (cursor keys) and incorporates some  of  the  Emacs
       commands for editing as well as a history mechanism too.

       The following keyboard input is supported:

       <u>Home</u> <u>Key,</u> <u>Control-a</u>
              Goes to the beginning of the line.

       <u>End</u> <u>Key,</u> <u>Control-e</u>
              Goes to the end of the line.

       <u>Left</u> <u>Arrow</u> <u>Key,</u> <u>Control-b</u>
              Moves the cursor back one character.

       <u>Right</u> <u>Arrow</u> <u>Key,</u> <u>Control-f</u>
              Moves the cursor forward one character.

       <u>Up</u> <u>Arrow</u> <u>Key,</u> <u>Control-p</u>
              Goes back in the history, replaces the current line with the previous line in the history.

       <u>Down</u> <u>Arrow</u> <u>Key,</u> <u>Control-n</u>
              Moves forward in the history, replaces the current line with the next line in the history.

       <u>Return</u> Executes the current line if the statement or expression is complete, or waits for further input.

       <u>Control-C</u>
              Cancel  the  current line being edited.  This will kill any currently in-progress edits or partial
              editing and go back to a toplevel definition.

       <u>Backspace</u> <u>Key</u>
              Deletes the character before the cursor

       <u>Delete</u> <u>Key,</u> <u>Control-d</u>
              Deletes the character at the current cursor position.

       <u>Control-k</u>
              Erases the contents of the line until the end of the line and places the result  in  the  cut  and
              paste buffer.

       <u>Alt-D</u>  Deletes  the word starting at the cursor position and appends into the cut and paste buffer.    By
              pressing Alt-d repeatedly, multiple words can be appended into the paste buffer.

       <u>Control-Y</u>
              Pastes the content of the kill buffer at the current cursor position.

       <u>Control-Q</u>
              This is the quote character.   It allows the user to enter control-characters that  are  otherwise
              taken  by  the  command  editing facility.   Press Control-Q followed by the character you want to
              insert, and it will be inserted verbatim into the command line.

       <u>Control-D</u>
              Terminates the program.   This terminates the input for the program.

</pre><h4><b>STATIC</b> <b>PROPERTIES</b> <b>AND</b> <b>METHODS</b></h4><pre>
       Since the methods and properties of the base class from where the statements and expressions are executed
       are static, they can be invoked directly from  the  shell.    These  are  the  available  properties  and
       methods:

       <u>Args</u>   An  easy  to  consume  array of any arguments specified after either <u>-s</u> or <u>--</u> on the command line.
              Ideal for self-executing scripts utilizing the <u>-s</u> option.

       <u>void</u> <u>LoadAssembly(string</u> <u>assembly)</u>
              Loads the given assembly.   This is equivalent to passing the  compiler  the  -r:  flag  with  the
              specified string.

       <u>void</u> <u>LoadPackage(string</u> <u>package)</u>
              Imports  the  package specified.   This is equivalent to invoking the compiler with the -pkg: flag
              with the specified string.

       <u>string</u> <u>Prompt</u> <u>{</u> <u>get;</u> <u>set</u> <u>}</u>
              The prompt used by the shell.  It defaults to the value "csharp&gt; ".  <u>string</u>  <u>ContinuationPrompt</u>  <u>{</u>
              <u>get;</u> <u>set;</u> <u>}</u> The prompt used by the shell when further input is required to complete the expression
              or statement.

       <u>void</u> <u>ShowVars()</u>
              Displays  all  the variables that have been defined so far and their types.    In the csharp shell
              declaring new variables will shadow previous variable declarations, this is different than C# when
              compiled.  <u>void</u> <u>ShowUsing()</u> Displays all the using statements in effect.  <u>TimeSpan</u> <u>Time</u> <u>(Action</u> <u>a)</u>
              Handy routine to time the time that some code takes to  execute.    The  parameter  is  an  Action
              delegate, and the return value is a TimeSpan.  For example:

       csharp&gt; Time (() =&gt; { for (int i = 0; i &lt; 5; i++) Console.WriteLine (i);});
       0
       1
       2
       3
       4
       00:00:00.0043230
       csharp&gt;

       The return value is a TimeSpan, that you can store in a variable for benchmarking purposes.

</pre><h4><b>GUI</b> <b>METHODS</b> <b>AND</b> <b>PROPERTIES</b></h4><pre>
       In  addition  to the methods and properties available in the console version there are a handful of extra
       properties available on the GUI version.   For example a "PaneContainer" Gtk.Container  is  exposed  that
       you  can use to host Gtk# widgets while prototyping or the "MainWindow" property that gives you access to
       the current toplevel window.

</pre><h4><b>STARTUP</b> <b>FILES</b></h4><pre>
       The C# shell will load all the Mono assemblies and  C#  script  files  located  in  the  <a href="file:~/.config/csharp">~/.config/csharp</a>
       directory on Unix.  The assemblies are loaded before the source files are loaded.

       C#  script  files  are  files  that  have  the  extension .cs and they should only contain statements and
       expressions, they can not contain full class definitions (at least not  as  of  Mono  2.0).   Full  class
       definitions should be compiled into dlls and stored in that directory.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  Mono  C#  Compiler  was written by Miguel de Icaza, Ravi Pratap, Martin Baulig, Marek Safar and Raja
       Harinath.  The development was funded by Ximian, Novell and Marek Safar.

</pre><h4><b>LICENSE</b></h4><pre>
       The Mono Compiler Suite is released under the terms of the GNU GPL or  the  MIT  X11.   Please  read  the
       accompanying  `COPYING'  file  for  details.   Alternative  licensing  for the compiler is available from
       Novell.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/gmcs.1.html">gmcs</a>(1), <a href="../man1/mcs.1.html">mcs</a>(1), <a href="../man1/mdb.1.html">mdb</a>(1), <a href="../man1/mono.1.html">mono</a>(1), <a href="../man1/pkg-config.1.html">pkg-config</a>(1)

</pre><h4><b>BUGS</b></h4><pre>
       To report bugs in the compiler, you must file them on  our  bug  tracking  system,  at:  <a href="http://www.mono">http://www.mono</a>-
       project.com/community/bugs/

</pre><h4><b>MAILING</b> <b>LIST</b></h4><pre>
       The Mono Mailing lists are listed at <a href="http://www.mono-project.com/community/help/mailing-lists/">http://www.mono-project.com/community/help/mailing-lists/</a>

</pre><h4><b>MORE</b> <b>INFORMATION</b></h4><pre>
       The  Mono C# compiler was developed by Novell, Inc (<a href="http://www.novell.com">http://www.novell.com</a>, http) and is based on the ECMA
       C# language standard available here: <a href="http://www.ecma.ch/ecma1/STAND/ecma-334.htm">http://www.ecma.ch/ecma1/STAND/ecma-334.htm</a>

       The   home   page   for   the   Mono   C#   compiler   is   at    <a href="http://www.mono-project.com/docs/about">http://www.mono-project.com/docs/about</a>-
       mono/languages/csharp/  information  about  the  interactive  mode  for  C#  is available in <a href="http://mono">http://mono</a>-
       project.com/docs/tools+libraries/tools/repl/

                                                  22 March 2017                                        <u><a href="../man1/csharp.1.html">csharp</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>