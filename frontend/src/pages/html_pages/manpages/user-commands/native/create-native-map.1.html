<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create-native-map - C/C# Mapping Creator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/noble/+package/mono-tools-devel">mono-tools-devel_4.2-3.2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       create-native-map - C/C# Mapping Creator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>create-native-map</b> [OPTIONS]* ASSEMBLY-FILE-NAME OUPUT-PREFIX

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>--autoconf-header=HEADER</u>
              <u>HEADER</u>  is  a  header  file  name in the syntax typically used with the C <u>#include</u> statement, e.g.
              <u>#include</u> <u>&lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;</u> or <u>#include</u> <u>"local.h"</u> .

              An Autoconf-formatted macro is generated from the  include  name,  and  a  <u>#include</u>  directive  is
              wrapped within a <u>#ifdef</u> block for the Autoconf macro within the generated <u>.c</u> file.

              For example, <u>--autoconf-header=&lt;stdio.h&gt;</u> would generate the code:

                   #ifndef HAVE_STDIO_H
                   #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
                   #endif /* ndef HAVE_STDIO_H */

       <u>--autoconf-member=MEMBER</u>
              Specify that any access to <u>MEMBER</u> should be wrapped within a <u>#ifdef</u> <u>HAVE_MEMBER</u> block.  <u>MEMBER</u> can
              be either a <u>field-name</u> or a <u>class-name</u> .  <u>field-name</u> combination.

              For example, given the C# declaration:

                   [Mono.Unix.Native.Map ("struct dirent")]
                   struct Dirent {
                        public long d_off;
                   }

              then <u>--autoconf-member=d_off</u> would generate the code similar to:

                   int
                   ToDirent (struct dirent *from, struct Dirent *to)
                   {
                   #ifdef HAVE_STRUCT_DIRENT_D_OFF
                        to-&gt;d_off = from-&gt;d_off;
                   #endif /* ndef HAVE_STRUCT_DIRENT_D_OFF */
                   }

       <u>--exclude-native-symbol=SYMBOL</u>
              <u>SYMBOL</u> is a <u>[DllImport]</u> -marked method that should <u>not</u> have a prototype generated for it.

       <u>--impl-header=HEADER</u>
              Insert a <u>#include</u> statement within the generated <u>.c</u> file for <u>HEADER</u> .

              For example, <u>--impl-header=&lt;stdlib.h&gt;</u> generates

                   #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       <u>--impl-macro=MACRO</u>
              Insert  a  <u>#define</u>  statement within the generated <u>.c</u> file.  <u>MACRO</u> can contain a <u>=</u> to separate the
              macro name from the macro value.

              For example, <u>--impl-macro=FOO=42</u> generates

                   #define FOO 42

       <u>--library=LIBRARY</u>
              Create prototypes for <u>[DllImport]</u> -marked methods which reference the native library <u>LIBRARY</u>  into
              the generated <u>.h</u> file.

       <u>--public-header=HEADER</u>
              Insert a <u>#include</u> statement within the generated <u>.h</u> file for <u>HEADER</u> .

              For example, <u>--public-header=&lt;stdlib.h&gt;</u> generates

                   #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       <u>--public-macro=MACRO</u>
              Insert  a  <u>#define</u>  statement within the generated <u>.h</u> file.  <u>MACRO</u> can contain a <u>=</u> to separate the
              macro name from the macro value.

              For example, <u>--public-macro=FOO=42</u> generates

                   #define FOO 42

       <u>--rename-member=FROM=TO</u>
              This is used when <u>FROM</u> is a C macro, and thus must be altered in order to  be  used  sanely.   All
              generated references to the managed representation will use <u>TO</u> instead of <u>FROM</u> .

              For example, given the C# declaration:

                   [Mono.Unix.Native.Map ("struct stat")]
                   struct Stat {
                        public long st_atime;
                   }

              and the argument <u>--rename-member=st_atime=st_atime</u><b>_</b> , the generated <u>.h</u> file would contain:

                   struct Stat {
                        gint64 st_atime_;
                   };

              (note the altered field name), while the generated <u>.c</u> file would contain:

                   ToStat (struct stat *from, struct Stat *to)
                   {
                        to-&gt;st_atime_ = from-&gt;st_atime;
                   }

       <u>--rename-namespace=FROM=TO</u>
              By  default,  the C "namespace" (symbol prefix) is the C# namespace; types within the C# namespace
              <u>Mono.Unix.Native</u> would be in the C  "namespace"  <u>Mono_Unix_Native</u>  .   Use  <u>--rename-namespace</u>  to
              modify the default, e.g.  <u>--rename-namespace=Mono.Unix.Native=Mono_Posix</u> .

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>create-native-map</u>  is  a program for a specific scenario: keeping code which is tightly coupled between C
       and C# in sync with each other, based upon the C# types.

       Platform Invoke is only useful if the managed code knows the exact types  and  layout  of  all  unmanaged
       structures  it  uses.  This is usually the case on Windows, but it is <u>not</u> the case on Unix.  For example,
       <u>struct</u> <u>stat</u> makes use of types with sizes that will vary from platform to platform (or even based on  the
       compiler macros defined!).  For example, <u>off_t</u> is usually a signed 32-bit integer on ILP32 platforms, but
       may  be  a  signed  64-bit  integer  on  LP64 platforms, but may also be a 64-bit signed integer on ILP32
       platforms if the <b>_</b><u>FILE_OFFSET_BITS</u> macro has the value 64.  In short, everything is flexible within Unix,
       and managed code can't deal with such flexibility.

       Thus, the niche for <u>create-native-map</u> : assume a fixed ABI that managed code  can  target,  and  generate
       code  to  "thunk" the managed representations to the corresponding native representations.  This needs to
       be done for <u>everything</u> that can vary between platforms and compiler  flags,  from  enumeration  values  (
       <u>SIGBUS</u> has the value 10 on FreeBSD but 7 on Linux) to structure members (how big is <u>off_t</u> ?).

       <u>create-native-map</u> will inspect <u>ASSEMBLY-FILE-NAME</u> and output the following files:

              <u>OUTPUT-PREFIX.h</u>
                     Contains  enumeration  values, class and structure declarations, delegate declarations, and
                     <u>[DllImport]</u> -marked methods (from the library specified by <u>--library</u> ) within the  assembly
                     <u>ASSEMBLY-FILE-NAME</u> .

              <u>OUTPUT-PREFIX.c</u>
                     Contains the implementation of enumeration and structure conversion functions.

              <u>OUTPUT-PREFIX.cs</u>
                     Contains a partial class <u>NativeConvert</u> containing enumeration translation methods.

              <u>OUTPUT-PREFIX.xml</u>
                     Generates  ECMA  XML documentation stubs for the enumeration translation methods in <u>OUTPUT-</u>
                     <u>PREFIX.cs</u> .

       <u>create-native-map</u> primarily looks for <u>MapAttribute</u> -decorated types, and makes use  of  two  <u>MapAttribute</u>
       properties:

              <u>NativeType</u>
                     Contains  the  corresponding  C  type.   Only useful if applied to classes, structures, and
                     fields.

              <u>SuppressFlags</u>
                     When specified on an enumeration member of a <u>[Flags]</u> -decorated enumeration type,  <u>disables</u>
                     the normal code generator support for bit-masking enumeration types.

                     This is useful when bitmask and non-bitmask information is stored within the same type, and
                     bitmask    checking   shouldn't   be   used   for   the   non-bitmask   values.    Example:
                     <u>Mono.Unix.Native.FilePermissions.S_IFREG</u> , which is not a  bitmask  value,  while  most  of
                     <u>FilePermissions</u>    consists    of    bitmask    values    (    <u>FilePermissions.S_IRUSR</u>    ,
                     <u>FilePermissions.S_IWUSR</u> , etc.).

       The <u>MapAttribute</u> attribute can be specified on classes, structures, delegates, fields, and enumerations.

       Delegates
              Code generation for delegates  ignores  the  <u>MapAttribute.NativeType</u>  property,  and  generates  a
              function pointer <u>typedef</u> that best matches the delegate declaration into the <u>.h</u> file.

              For example,

                   namespace Foo {
                        [Map]
                        delegate string MyCallback (string s);
                   }

              generates the <u>typedef</u> :

                   typedef char* (*Foo_MyCallback) (const char *s);

       Classes and Structures
              A <u>[Map]</u> -decorated class or structure will get a C structure declaration within the <u>.h</u> file:

                   [Map]
                   struct Foo {
                        public int i;
                   }

              becomes

                   struct Foo {
                        public int i;
                   };

              If  the <u>MapAttribute.NativeType</u> property is set, then conversion functions will be declared within
              the <u>.h</u> file and created within the <u>.c</u> file:

                   namespace Foo {
                        [Map ("struct stat")]
                        struct Stat {
                             public uint st_uid;
                        }
                   }

              becomes

                   /* The .h file */
                   struct Foo_Stat {
                        unsigned int st_uid;
                   };
                   int
                   Foo_FromStat (struct Foo_Stat *from, struct stat *to);
                   int
                   Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to);

                   /* The .c file */
                   int
                   Foo_FromStat (struct Foo_Stat *from, struct stat *to)
                   {
                        memset (to, 0, sizeof(*to);
                        to-&gt;st_uid = from-&gt;st_uid;
                        return 0;
                   }

                   int
                   Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to)
                   {
                        memset (to, 0, sizeof(*to);
                        to-&gt;st_uid = from-&gt;st_uid;
                        return 0;
                   }

              For classes, the conversion functions will only copy fields declared in the class  itself.  Fields
              declared  in  parent  classes will not be copied. (This is because <u>create-native-map</u> does not know
              how the inheritance is implemented in C. Therefore copying fields from parent classes is  left  to
              the caller of the conversion functions.)

       Fields If  a  field  (1) has the <u>MapAttribute</u> attribute, and (2) has the <u>MapAttribute.NativeType</u> property
              set, then the specified native type will be used for overflow checking.  For example:

                   namespace Foo {
                        [Map ("struct stat")]
                        struct Stat {
                             [Map ("off_t")] public long st_size;
                        }
                   }

              generates

                   /* The .h file */
                   struct Foo_Stat {
                        gint64 st_size;
                   };
                   int
                   Foo_FromStat (struct Foo_Stat *from, struct stat *to);
                   int
                   Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to);

                   /* The .c file */
                   int
                   Foo_FromStat (struct Foo_Stat *from, struct stat *to)
                   {
                        _cnm_return_val_if_overflow (off_t, from-&gt;st_size, -1);

                        memset (to, 0, sizeof(*to);
                        to-&gt;st_size = from-&gt;st_size;
                        return 0;
                   }

                   int
                   Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to)
                   {
                        _cnm_return_val_if_overflow (gint64, from-&gt;st_size, -1);

                        memset (to, 0, sizeof(*to);
                        to-&gt;st_size = from-&gt;st_size;
                        return 0;
                   }

              This is useful for better error checking within the conversion functions.  <u>MapAttribute.NativeType</u>
              is required for this as there is no other way to know what the native type is (without parsing the
              system header files...).

       Enumerations
              Generates a C enumeration and macros for each of the members within the enumeration.  <u>To</u> and  <u>From</u>
              functions are also declared in the <u>.h</u> file and implemented in the <u>.c</u> file.

              For example,

                   namespace Foo {
                        [Map]
                        enum Errno {
                             EINVAL
                        }
                   }

              would generate the following in the <u>.h</u> file:

                   enum Foo_Errno {
                        Foo_Errno_EINVAL          = 0,
                        #define Foo_Errno_EINVAL    Foo_Errno_EINVAL
                   };
                   int Foo_FromErrno (int from, int *to);
                   int Foo_ToErrno (int from, int *to);

              and generates the following in the the <u>.c</u> file:

                   int
                   Foo_FromErrno (int from, int *to)
                   {
                        *to = 0;
                        if (from == Foo_Errno_EPERM)
                   #ifdef EINVAL
                             {*to = EINVAL;}
                   #else
                             {errno = EINVAL; return -1;}
                   #endif
                        return 0;
                   }

                   int
                   Foo_ToErrno (int from, int *to)
                   {
                        *to = 0;
                   #ifdef EINVAL
                        if (from == EINVAL)
                             {*to = Foo_Errno_EPERM; return 0;}
                   #endif
                        return -1;
                   }

              Different  code  will  be  generated  if  the managed enum is a <u>[Flags]</u> -decorated enumeration (to
              account for bitwise flags), but this is the basic idea.

</pre><h4><b>MAILING</b> <b>LISTS</b></h4><pre>
       Visit <a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</a> for details.

</pre><h4><b>WEB</b> <b>SITE</b></h4><pre>
       Visit <a href="http://www.mono-project.com">http://www.mono-project.com</a> for details

                                                                                            <u><a href="../man1/create-native-map.1.html">create-native-map</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>