<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mp4h - Macro Processor for HTML Documents</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/mp4h">mp4h_1.3.1-17_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mp4h - Macro Processor for HTML Documents

</pre><h4><b>VERSION</b></h4><pre>
       This documentation describes mp4h version 1.3.1.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       The <b>mp4h</b> software is a macro-processor specifically designed to deal with HTML documents.  It allows
       powerful programming constructs, with a syntax familiar to HTML authors.

       This software is based on <b>Meta-HTML</b> "&lt;URL:<a href="http://www.metahtml.org/">http://www.metahtml.org/</a>&gt;", written by Brian J. Fox,  Even if
       both syntaxes look similar, source code is completely different.  Indeed, a subset of <b>Meta-HTML</b> was used
       as a part of a more complex program, <b>WML</b> (Website Meta Language "&lt;URL:<a href="http://www.thewml.org/">http://www.thewml.org/</a>&gt;") written
       by Ralf S. Engelschall and which I maintain since January 1999.  For licensing reasons, it was hard to
       hack <b>Meta-HTML</b> and so I decided to write my own macro-processor.

       Instead of rewriting it from scratch, I preferred using another macro-processor engine. I chose GNU <b>m4</b>
       "&lt;URL:<a href="http://www.gnu.org/software/m4/">http://www.gnu.org/software/m4/</a>&gt;", written by Rene Seindal, because of its numerous advantages :
       this software is stable, robust and very well documented.  This version of <b>mp4h</b> is derived from GNU <b>m4</b>
       version 1.4n, which is a development version.

       The <b>mp4h</b> software is not an HTML editor; its unique goal is to provide an easy way to define its own
       macros inside HTML documents.  There is no plan to add functionalities to automagically produce valid
       HTML documents, if you want to clean up your code or validate it, simply use a post-processor like tidy
       "&lt;URL:<a href="http://www.w3.org/People/Raggett/tidy/">http://www.w3.org/People/Raggett/tidy/</a>&gt;".

</pre><h4><b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b></h4><pre>
       Optional arguments are enclosed within square brackets.  All option synonyms have a similar syntax, so
       when a long option accepts an argument, short option do too.

       Syntax call is

          mp4h [options] [filename [filename] ...]

       Options are described below.  If no filename is specified, or if its name is "-", then characters are
       read on standard input.

   <b>Operation</b> <b>modes</b>
       <b>--help</b> display an help message and exit
       <b>--version</b> output <b>mp4h</b> version information and exit
       <b>-E</b> <b>--fatal-warnings</b> stop execution after first warning
       <b>-Q</b> <b>--quiet</b> <b>--silent</b> suppress some warnings for builtins
       <b>-S</b> <b>--safety-level="NUMBER"</b> disable risky functions; 0 means no filtering, 1 disable "execute" and 2
       disable this one too plus all filesystem related functions: "file-exists", "real-path",
       "get-file-properties", "directory-contents" and "include".

   <b>Preprocessor</b> <b>features</b>
       <b>-I</b> <b>--include="DIRECTORY"</b> search this directory for includes and packages
       <b>-D</b> <b>--define="NAME"[=VALUE]""</b> set variable NAME to VALUE, or empty
       <b>-U</b> <b>--undefine="COMMAND"</b> delete builtin COMMAND
       <b>-s</b> <b>--synclines</b> generate `#line NO "FILE"' lines

   <b>Parser</b> <b>features</b>
       <b>-c</b> <b>--caseless="NUMBER"</b> set case sensitiveness according to the bits of "NUMBER". A null bit means symbol
       is case sensitive, and bits are defined as followed: 0 for tags, 1 for variables and 2 for entities.
       Default value is 3, i.e. only entities are case sensitive.
       <b>-e</b> <b>--encoding="NAME"</b> specify document encoding.  Valid options are `8bit' (default) or `utf8'.
       <b>-X</b> <b>--expansion="NUMBER"</b> set parser behaviour according to the bits of "NUMBER"

       NUMBER is a combination of

       <b>1</b> do not parse unknown tags
       <b>2</b> unknown tags are assumed being simple
       <b>4</b> trailing star in tag name do not make this tag simple
       <b>8</b> an unmatched end tag closes all previous unmatched begin tags
       <b>16</b> interpret backslashes as printf
       <b>32</b> remove trailing slash in tag attributes
       <b>64</b> do not remove trailing star in tag name
       <b>128</b> do not remove leading star in tag name
       <b>256</b> do not add a space before trailing slash in tag attributes
       <b>1024</b> suppress warnings about bad nested tags
       <b>2048</b> suppress warnings about missing trailing slash

       In version 1.3.1, default value is 3114=2+8+32+1024+2048.

   <b>Limits</b> <b>control</b>
       <b>-H</b> <b>--hashsize="PRIME"</b> set symbol lookup hash table size (default 509)
       <b>-L</b> <b>-nesting-limit="NUMBER"</b> change artificial nesting limit (default 250)

   <b>Debugging</b>
       <b>-d</b> <b>--debug="FLAGS"</b> set debug level (no FLAGS implies `aeq')
       <b>-t</b> <b>--trace="NAME"</b> trace NAME when it will be defined
       <b>-l</b> <b>--arglength="NUMBER"</b> restrict macro tracing size
       <b>-o</b> <b>--error-output="FILE"</b> redirect debug and trace output

       Flags are any of:

       <b>t</b> trace for all macro calls, not only debugging-on'ed
       <b>a</b> show actual arguments
       <b>e</b> show expansion
       <b>c</b> show before collect, after collect and after call
       <b>x</b> add a unique macro call id, useful with c flag
       <b>f</b> say current input file name
       <b>l</b> say current input line number
       <b>p</b> show results of path searches
       <b>m</b> show results of module operations
       <b>i</b> show changes in input files
       <b>V</b> shorthand for all of the above flags

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>mp4h</b>  software  is  a  macro-processor,  which means that keywords are replaced by other text.  This
       chapter describes all primitives.  As <b>mp4h</b> has been specially designed for HTML documents, its syntax  is
       very  similar  to  HTML,  with  tags  and  attributes.   One important feature has no equivalent in HTML:
       comments until end of line.  All text following three colons is discarded until end of line, like

          ;;;  This is a comment

   <b>Function</b> <b>Macros</b>
       <b>Note:</b> All examples in this documentation are processed through <b>mp4h</b> with expansion flags set to zero (see
       a description of possible expansion flags at the end of document),  it  is  why  simple  tags  contain  a
       trailing slash. But <b>mp4h</b> can output plain HTML files with other expansion flags.

       The  definition of new tags is the most common task provided by <b>mp4h</b>.  As with HTML, macro names are case
       insensitive, unless "-c" option is used to change this default behaviour.  In  this  documentation,  only
       lowercase  letters  are  used.   There  are  two  kinds of tags: simple and complex. A simple tag has the
       following form:

          &lt;name [attributes] /&gt;

       whereas a complex tag looks like:

          &lt;name [attributes]&gt;
          body
          &lt;/name&gt;

       Since version 0.9.1, <b>mp4h</b> knows XHTML syntax too, so your input file may conform to HTML or XHTML syntax.
       In this manual, we adopt the latter, which is why simple tags have a trailing slash  in  attributes.   If
       you want to produce HTML files with this input file, you may either choose an adequate "--expansion" flag
       or use a post-processor like tidy "&lt;URL:<a href="http://www.w3.org/People/Raggett/tidy/">http://www.w3.org/People/Raggett/tidy/</a>&gt;".

       When  a  simple  tag  is defined by <b>mp4h</b>, it can be parsed even if the trailing slash is omitted, because
       <b>mp4h</b> knows that this tag is simple.  But it is a good practice to  always  append  a  trailing  slash  to
       simple tags.

       In  macro  descriptions  below,  a  slash indicates a simple tag, and a V letter that attributes are read
       verbatim (without expansion) (see the chapter on macro expansion for further details).

       â€¢ define-tag

         "<u>name</u>" "[attributes=verbatim]" "[endtag=required]" "[whitespace=delete]"

       This function lets you define your own tags.  First argument is the command name. Replacement text is the
       function body.

       Source:

          &lt;define-tag foo&gt;bar&lt;/define-tag&gt;
          &lt;foo/&gt;

       Output:

          bar

       Even if spaces have usually few incidence on HTML syntax, it is important to note that

          &lt;define-tag foo&gt;bar&lt;/define-tag&gt;

       and

          &lt;define-tag foo&gt;
          bar
          &lt;/define-tag&gt;

       are not equivalent, the latter form contains two newlines that were not present in the former.

       "whitespace=delete"
           Some spaces are suppressed in replacement text, in particular any leading  or  trailing  spaces,  and
           newlines not enclosed within angle brackets.

       "endtag=required"
           Define a complex tag

           Source:

              &lt;define-tag foo&gt;bar&lt;/define-tag&gt;
              &lt;foo/&gt;

           Output:

              bar

           Source:

              &lt;define-tag bar endtag=required&gt;;;;
              body is: %body&lt;/define-tag&gt;
              &lt;bar&gt;Here it is&lt;/bar&gt;

           Output:

              body is: Here it is

       "attributes=verbatim"
           By default attributes are expanded before text is replaced. If this attribute is used, attributes are
           inserted into replacement text without expansion.

           Source:

              &lt;define-tag foo&gt;quux&lt;/define-tag&gt;
              &lt;define-tag bar attributes=verbatim endtag=required&gt;
              Body: %Ubody
              Attributes: %Uattributes
              &lt;/define-tag&gt;
              &lt;bar txt="&lt;foo/&gt;"&gt;Here we go&lt;/bar&gt;

           Output:

              Body: Here we go
              Attributes: txt=&lt;foo/&gt;

       â€¢ provide-tag

         "<u>name</u>" "[attributes=verbatim]" "[endtag=required]" "[whitespace=delete]"

       This  command  is  similar to the previous one, except that no operation is performed if this command was
       already defined.

       â€¢ let "S"

         "<u>new</u>=<u>old</u>"

       Copy a function. This command is useful to save a macro definition before redefining it.

       Source:

          &lt;define-tag foo&gt;one&lt;/define-tag&gt;
          &lt;let bar=foo /&gt;
          &lt;define-tag foo&gt;two&lt;/define-tag&gt;
          &lt;foo/&gt;&lt;bar/&gt;

       Output:

          twoone

       â€¢ undef "S"

         "<u>name</u>"

       Delete a command definition.

       Source:

          &lt;define-tag foo&gt;one&lt;/define-tag&gt;
          &lt;undef foo /&gt;
          &lt;foo/&gt;

       Output:

          &lt;foo /&gt;

       â€¢ set-hook

         "<u>name</u>" "[position=before|after]" "[action=insert|append|replace]"

       Add text to a predefined macro. This mechanism allows modifications of existing macros without having  to
       worry about its type, whether it is complex or not.

       Source:

          &lt;let foo=add /&gt;
          &lt;set-hook foo position=before&gt;
          Before&lt;/set-hook&gt;
          &lt;set-hook foo position=after&gt;
          After&lt;/set-hook&gt;
          &lt;foo 1 2 3 4 /&gt;

       Output:

          Before10
          After

       â€¢ get-hook "S"

         "<u>name</u>" "[position=before|after]"

       Print current hooks of a macro.

       Source:

          Text inserted with position=before:&lt;get-hook foo position=before /&gt;!
          Text inserted with position=after:&lt;get-hook foo position=after /&gt;!

       Output:

          Text inserted with position=before:
          Before!
          Text inserted with position=after:
          After!

       â€¢ attributes-quote "S"

         "%attributes"

       Like  %attributes,  except  that  "attr=value" pairs are printed with double quotes surrounding attribute
       values, and a leading space is added if some text is printed.

       Source:

          &lt;define-tag foo&gt;;;;
          %attributes
          &lt;img&lt;attributes-quote %attributes /&gt;/&gt;
          &lt;/define-tag&gt;
          &lt;foo id="logo" src="logo.gif" name="Logo" alt="Our logo" /&gt;
          &lt;foo/&gt;

       Output:

          id=logo src=logo.gif name=Logo alt=Our logo
          &lt;img id="logo" src="logo.gif" name="Logo" alt="Our logo"/&gt;

          &lt;img/&gt;

       â€¢ attributes-extract "S"

         "<u>name1</u>" "[,<u>name2</u>[,<u>name3</u>...]]" "%attributes"

       Extract from %attributes the "attr=value" pairs for names matching any of <u>name1</u>, <u>name2</u>....

       Source:

          &lt;define-tag img whitespace=delete&gt;
          &lt;img* &lt;attributes-extract name,src,alt %attributes /&gt;  /&gt;
          &lt;/define-tag&gt;
          &lt;img id="logo" src="logo.gif" name="Logo" alt="Our logo"  /&gt;

       Output:

          &lt;img src=logo.gif name=Logo alt=Our logo    /&gt;

       â€¢ attributes-remove "S"

         "<u>name1</u>" "[,<u>name2</u>[,<u>name3</u>...]]" "%attributes"

       Remove from %attributes the "attr=value" pairs for names matching any of <u>name1</u>, <u>name2</u>....

       Source:

          &lt;define-tag img whitespace=delete&gt;
          &lt;img* &lt;attributes-quote &lt;attributes-remove name,src,alt %attributes /&gt;/&gt; /&gt;
          &lt;/define-tag&gt;
          &lt;img id="logo" src="logo.gif" name="Logo" alt="Our logo"  /&gt;

       Output:

          &lt;img  id="logo"   /&gt;

       <b>Note:</b> The two previous functions are special, because unlike all other macros,  their  expansion  do  not
       form a group.  This is necessary to parse the resulting list of attributes.

       In those two functions, names of attributes may be regular expressions.  Main goal of these primitives is
       to  help  writing  macros  accepting  any  kind of attributes without having to declare them. A canonical
       example is

       Source:

          &lt;define-tag href whitespace=delete&gt;
          &lt;preserve url name /&gt;
          &lt;set-var &lt;attributes-extract url,name %attributes /&gt;/&gt;
          &lt;a &lt;attributes-quote &lt;attributes-remove url,name %attributes /&gt;/&gt;
             href="&lt;get-var url /&gt;"&gt;&lt;get-var name /&gt;&lt;/a&gt;
          &lt;restore  url name /&gt;
          &lt;/define-tag&gt;
          &lt;href class=web url="<a href="http://www.foo.com">http://www.foo.com</a>" name="Welcome"  /&gt;

       Output:

          &lt;a  class="web"
             href="<a href="http://www.foo.com">http://www.foo.com</a>"&gt;Welcome&lt;/a&gt;

       But we want now to add an image attribute.  So we may write

       Source:

          &lt;define-tag href whitespace=delete&gt;
          &lt;preserve url name image /&gt;
          &lt;set-var &lt;attributes-extract url,name,image %attributes /&gt;/&gt;
          &lt;a &lt;attributes-quote &lt;attributes-remove url,name,image %attributes /&gt;/&gt;
             href="&lt;get-var url /&gt;"&gt;
          &lt;if &lt;get-var image /&gt;
             &lt;img &lt;attributes-quote &lt;attributes-remove url,name,image %attributes /&gt;/&gt;
                src="&lt;get-var image /&gt;" alt="&lt;get-var name /&gt;" border=0  /&gt;
            &lt;get-var name /&gt;
          /&gt;
          &lt;/a&gt;
          &lt;restore  url name image /&gt;
          &lt;/define-tag&gt;
          &lt;href class=web url="<a href="http://www.foo.com">http://www.foo.com</a>" name="Welcome" image="foo.png"/&gt;

       Output:

          &lt;a  class="web"
             href="<a href="http://www.foo.com">http://www.foo.com</a>"&gt;&lt;img  class="web"
                src="foo.png" alt="Welcome" border=0      /&gt;&lt;/a&gt;

       We need a mechanism to tell <b>mp4h</b> that some attributes refer to specific HTML  tags.   A  solution  is  to
       prepend attribute with tag name, e.g.

       Source:

          &lt;define-tag href whitespace=delete&gt;
          &lt;preserve url name image /&gt;
          &lt;set-var &lt;attributes-extract url,name,image %attributes /&gt;/&gt;
          &lt;a &lt;attributes-quote &lt;attributes-extract a:.* %attributes /&gt;/&gt;
             href="&lt;get-var url /&gt;"&gt;
          &lt;if &lt;get-var image /&gt;
             &lt;img &lt;attributes-quote &lt;attributes-extract img:.* %attributes /&gt;/&gt;
                src="&lt;get-var image /&gt;" alt="&lt;get-var name /&gt;"  /&gt;
            &lt;get-var name /&gt;
          /&gt;
          &lt;/a&gt;
          &lt;restore  url name image /&gt;
          &lt;/define-tag&gt;
          &lt;href a:class=web img:id=logo img:border=1
                url="<a href="http://www.foo.com">http://www.foo.com</a>" name="Welcome" image="foo.png" /&gt;

       Output:

          &lt;a  a:class="web"
             href="<a href="http://www.foo.com">http://www.foo.com</a>"&gt;&lt;img  img:id="logo" img:border="1"
                src="foo.png" alt="Welcome"      /&gt;&lt;/a&gt;

       This  example  shows  that  regular  expressions  may  be  used  within attributes names, but it is still
       incomplete, because we want to remove prefix from attributes.  One solution  is  with  "subst-in-string",
       but there is a more elegant one:

       Source:

          &lt;define-tag href whitespace=delete&gt;
          &lt;preserve url name image /&gt;
          &lt;set-var &lt;attributes-extract url,name,image %attributes /&gt;/&gt;
          &lt;a &lt;attributes-quote &lt;attributes-extract :a:(.*) %attributes /&gt;/&gt;
             href="&lt;get-var url /&gt;"&gt;
          &lt;if &lt;get-var image /&gt;
             &lt;img &lt;attributes-quote &lt;attributes-extract :img:(.*) %attributes /&gt;/&gt;
                src="&lt;get-var image /&gt;" alt="&lt;get-var name /&gt;"  /&gt;
            &lt;get-var name /&gt;
          /&gt;
          &lt;/a&gt;
          &lt;restore  url name image /&gt;
          &lt;/define-tag&gt;
          &lt;href :a:class=web :img:id=logo :img:border=1
                url="<a href="http://www.foo.com">http://www.foo.com</a>" name="Welcome" image="foo.png" /&gt;

       Output:

          &lt;a  class="web"
             href="<a href="http://www.foo.com">http://www.foo.com</a>"&gt;&lt;img  id="logo" border="1"
                src="foo.png" alt="Welcome"      /&gt;&lt;/a&gt;

       When  there  are  subexpressions  within  regular  expressions,  they  are  printed  instead of the whole
       expression.  Note also that I put a colon before the prefix in order not to mix them with XML namespaces.

   <b>Entities</b>
       Entities are macros in the same way as tags, but they  do  not  take  any  arguments.  Whereas  tags  are
       normally  used  to  mark  up  text, entities contain already marked up text.  Also note that unlike tags,
       entities are by default case sensitive.

       An entity has the following form:

          &amp;entity;

       â€¢ define-entity

         "<u>name</u>"

       This function lets you define your own entities.  First argument is the entity name. Replacement text  is
       the function body.

       Source:

          &lt;define-entity foo&gt;bar&lt;/define-entity&gt;
          &amp;foo;

       Output:

          bar

   <b>Variables</b>
       Variables  are a special case of simple tags, because they do not accept attributes. In fact their use is
       different, because variables contain text whereas macros act like operators.  A nice  feature  concerning
       variables  is  their  manipulation  as arrays.  Indeed variables can be considered like newline separated
       lists, which will allow powerful manipulation functions as we will see below.

       â€¢ set-var "S"

         "<u>name</u>[=<u>value</u>]" "[<u>name</u>[=<u>value</u>]] ..."

       This command sets variables.

       â€¢ set-var-verbatim "S""V"

         "<u>name</u>[=<u>value</u>]" "[<u>name</u>[=<u>value</u>]] ..."

       As above but attributes are read verbatim.

       â€¢ set-var-x

         "name=<u>variable-name</u>"

       This command assigns a variable the value of the body of the command. This is  particularly  useful  when
       variable values contain newlines and/or quotes.

       Note  that  the  variable  can not be indexed with this command.  Note also, that this command behaves as
       set-var-verbatim: The body is not expanded until the variable is shown with get-var.

       â€¢ get-var "S"

         "<u>name</u>" "[<u>name</u>] ..."

       Show variable contents. If a numeric value within square brackets is appended  to  a  variable  name,  it
       represents the index of an array.  The first index of arrays is 0 by convention.

       Source:

          &lt;set-var version="0.10.1" /&gt;
          This is version &lt;get-var version /&gt;
          &lt;set-var-x name="osversion"&gt;Operating system is
          "&lt;include command="uname" /&gt;"&lt;/set-var-x&gt;
          &lt;get-var osversion /&gt;

       Output:

          This is version 0.10.1

       Operating system is
          "Linux
          "

       Source:

          &lt;set-var foo="0
          1
          2
          3" /&gt;
          &lt;get-var foo[2] foo[0] foo /&gt;

       Output:

          200
          1
          2
          3

       â€¢ get-var-once "S""V"

         "<u>name</u>" "[<u>name</u>] ..."

       As above but attributes are not expanded.

       Source:

          &lt;define-tag foo&gt;0.10.1&lt;/define-tag&gt;
          &lt;set-var version="&lt;foo/&gt;" /&gt;;;;
          Here is version &lt;get-var version /&gt;
          &lt;set-var-verbatim version="&lt;foo/&gt;" /&gt;;;;
          Here is version &lt;get-var version /&gt;
          &lt;set-var-verbatim version="&lt;foo/&gt;" /&gt;;;;
          Here is version &lt;get-var-once version /&gt;

       Output:

          Here is version 0.10.1
          Here is version 0.10.1
          Here is version &lt;foo/&gt;

       â€¢ preserve "S"

         "<u>name</u>" "[<u>name</u>] ..."

       All  variables  are  global,  there  is  no  variable or macro scope.  For this reason a stack is used to
       preserve variables.  When this command is invoked, arguments are names of variables, whose values are put
       at the top of the stack and variables are reset to an empty string.

       â€¢ restore "S"

         "<u>name</u>" "[<u>name</u>] ..."

       This is the opposite: arguments are names of variables, which are set to the value found at  the  top  of
       the stack, and stack is popped down.

       <b>Note:</b> The "preserve" tag pushes its last argument first, whereas "restore" first pops its first argument.

       Source:

          &lt;define-tag foo whitespace=delete&gt;
          &lt;preserve src name text /&gt;
          &lt;set-var %attributes /&gt;
          Inside: src=&lt;get-var src /&gt; name=&lt;get-var name /&gt; text=&lt;get-var text /&gt;
          &lt;restore  src name text /&gt;
          &lt;/define-tag&gt;
          &lt;set-var src=foo.png text="Hello, World!" /&gt;
          Before: src=&lt;get-var src /&gt; name=&lt;get-var name /&gt; text=&lt;get-var text /&gt;
          &lt;foo src=bar name=quux /&gt;
          After: src=&lt;get-var src /&gt; name=&lt;get-var name /&gt; text=&lt;get-var text /&gt;

       Output:

          Before: src=foo.png name= text=Hello, World!
          Inside: src=bar name=quux text=
          After: src=foo.png name= text=Hello, World!

       â€¢ unset-var "S"

         "<u>name</u>" "[<u>name</u>] ..."

       Undefine variables.

       â€¢ var-exists "S"

         "<u>name</u>"

       Returns "true" when this variable exists.

       â€¢ increment "S"

         "<u>name</u>" "[by=<u>value</u>]"

       Increment the variable whose name is the first argument.  Default increment is one.

       "by=<u>value</u>"
           Change increment amount.

       Source:

          &lt;set-var i=10 /&gt;
          &lt;get-var i /&gt;
          &lt;increment i /&gt;&lt;get-var i /&gt;
          &lt;increment i by="-3" /&gt;&lt;get-var i /&gt;

       Output:

          10
          11
          8

       â€¢ decrement "S"

         "<u>name</u>" "[by=<u>value</u>]"

       Decrement the variable whose name is the first argument.  Default decrement is one.

       "by=<u>value</u>"
           Change decrement amount.

       Source:

          &lt;set-var i=10 /&gt;
          &lt;get-var i /&gt;
          &lt;decrement i /&gt;&lt;get-var i /&gt;
          &lt;decrement i by="3" /&gt;&lt;get-var i /&gt;

       Output:

          10
          9
          6

       â€¢ copy-var "S"

         "<u>src</u>" "<u>dest</u>"

       Copy a variable into another.

       Source:

          &lt;set-var i=10 /&gt;
          &lt;copy-var i j /&gt;
          &lt;get-var j /&gt;

       Output:

          10

       â€¢ defvar "S"

         "<u>name</u>" "<u>value</u>"

       If this variable is not defined or is defined to an empty string, then it is set to the second argument.

       Source:

          &lt;unset-var title /&gt;
          &lt;defvar title "Title" /&gt;&lt;get-var title /&gt;
          &lt;defvar title "New title" /&gt;&lt;get-var title /&gt;

       Output:

          Title
          Title

       â€¢ symbol-info "S"

         "<u>name</u>"

       Show  information  on  symbols.   If  it  is a variable name, the "STRING" word is printed as well as the
       number of lines contained within this variable.

       If it is a macro name, one of the following messages  is  printed:  "PRIM  COMPLEX",  "PRIM  TAG",  "USER
       COMPLEX" or "USER TAG"

       Source:

          &lt;set-var x="0\n1\n2\n3\n4" /&gt;
          &lt;define-tag foo&gt;bar&lt;/define-tag&gt;
          &lt;define-tag bar endtag=required&gt;quux&lt;/define-tag&gt;
          &lt;symbol-info x /&gt;
          &lt;symbol-info symbol-info /&gt;
          &lt;symbol-info define-tag /&gt;
          &lt;symbol-info foo /&gt;
          &lt;symbol-info bar /&gt;

       Output:

          STRING
          5
          PRIM TAG
          PRIM COMPLEX
          USER TAG
          USER COMPLEX

   <b>String</b> <b>Functions</b>
       â€¢ string-length "S"

         "<u>string</u>"

       Prints the length of the string.

       Source:

          &lt;set-var foo="0
          1
          2
          3" /&gt;;;;
          &lt;string-length &lt;get-var foo /&gt; /&gt;
          &lt;set-var foo="0 1 2 3" /&gt;;;;
          &lt;set-var l=&lt;string-length &lt;get-var foo /&gt; /&gt; /&gt;;;;
          &lt;get-var l /&gt;

       Output:

          7
          7

       â€¢ downcase "S"

         "<u>string</u>"

       Convert to lowercase letters.

       Source:

          &lt;downcase "Does it work?" /&gt;

       Output:

          does it work?

       â€¢ upcase "S"

         "<u>string</u>"

       Convert to uppercase letters.

       Source:

          &lt;upcase "Does it work?" /&gt;

       Output:

          DOES IT WORK?

       â€¢ capitalize "S"

         "<u>string</u>"

       Convert to a title, with a capital letter at the beginning of every word.

       Source:

          &lt;capitalize "Does it work?" /&gt;

       Output:

          Does It Work?

       â€¢ substring "S"

         "<u>string</u>" "[<u>start</u> [<u>end</u>]]"

       Extracts a substring from a string.  First argument is original string, second and third are respectively
       start and end indexes.  By convention first character has a null index.

       Source:

          &lt;set-var foo="abcdefghijk" /&gt;
          &lt;substring &lt;get-var foo /&gt; 4 /&gt;
          &lt;substring &lt;get-var foo /&gt; 4 6 /&gt;

       Output:

          efghijk
          ef

       â€¢ string-eq "S"

         "<u>string1</u>" "<u>string2</u>" "[caseless=true]"

       Returns "true" if first two arguments are equal.

       Source:

          1:&lt;string-eq "aAbBcC" "aabbcc" /&gt;
          2:&lt;string-eq "aAbBcC" "aAbBcC" /&gt;

       Output:

          1:
          2:true

       "caseless=true"
           Comparison is case insensitive.

       Source:

          1:&lt;string-eq "aAbBcC" "aabbcc" caseless=true /&gt;
          2:&lt;string-eq "aAbBcC" "aAbBcC" caseless=true /&gt;

       Output:

          1:true
          2:true

       â€¢ string-neq "S"

         "<u>string1</u>" "<u>string2</u>" "[caseless=true]"

       Returns "true" if the first two arguments are not equal.

       Source:

          1:&lt;string-neq "aAbBcC" "aabbcc" /&gt;
          2:&lt;string-neq "aAbBcC" "aAbBcC" /&gt;

       Output:

          1:true
          2:

       "caseless=true"
           Comparison is case insensitive.

       Source:

          1:&lt;string-neq "aAbBcC" "aabbcc" caseless=true /&gt;
          2:&lt;string-neq "aAbBcC" "aAbBcC" caseless=true /&gt;

       Output:

          1:
          2:

       â€¢ string-compare "S"

         "<u>string1</u>" "<u>string2</u>" "[caseless=true]"

       Compares two strings and returns one of the values less, greater or equal depending on this comparison.

       Source:

          1:&lt;string-compare "aAbBcC" "aabbcc" /&gt;
          2:&lt;string-compare "aAbBcC" "aAbBcC" /&gt;

       Output:

          1:less
          2:equal

       "caseless=true"
           Comparison is case insensitive.

       Source:

          1:&lt;string-compare "aAbBcC" "aabbcc" caseless=true /&gt;

       Output:

          1:equal

       â€¢ char-offsets "S"

         "<u>string</u>" "<u>character</u>" "[caseless=true]"

       Prints an array containing indexes where the character appear in the string.

       "caseless=true"
           Comparison is case insensitive.

       Source:

          1:&lt;char-offsets "abcdAbCdaBcD" a /&gt;
          2:&lt;char-offsets "abcdAbCdaBcD" a caseless=true /&gt;

       Output:

          1:0
          8
          2:0
          4
          8

       â€¢ printf "S"

         "<u>format</u>" "<u>string</u>" "[<u>string</u> ...]"

       Prints  according  to  a  given  format.  Currently  only  the  %s flag character is recognized, and  "$"
       extension is supported to change order of arguments.

       Source:

          1:&lt;printf "foo %s bar %s" baz 10 /&gt;
          2:&lt;printf "foo %2$s bar %1$s" baz 10 /&gt;

       Output:

          1:foo baz bar 10
          2:foo 10 bar baz

   <b>Regular</b> <b>Expressions</b>
       Regular expression support is provided by the PCRE (Perl Compatible Regular Expressions) library package,
       which is open source software, copyright by the University of Cambridge.  This is a very  nice  piece  of
       software, latest versions are available at
        "&lt;URL:<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a>&gt;".

       Before  version 1.0.6, POSIX regular expressions were implemented.  For this reason, the following macros
       recognize two attributes, "caseless=true" and "singleline=true|false".  But Perl  allows  a  much  better
       control  on regular expressions with so called modifiers, which are assed to the new "reflags" attribute.
       It may contain one or more modifiers:

       <b>i</b> Matching is case insensitive
       <b>m</b> Treat string as multiple lines. When set, a "^" matches any beginning of line, and "$" any end of line.
       By default, they match begin and end of string.
       <b>s</b> Treat string as single line. A dot (".") may also match a newline, whereas it does not by default.
       <b>x</b> Allow formatted regular expression, that means whitespaces, newlines and comments are removed from
       regular expression before processing.

       <b>Note:</b> Attribute "singleline=true" is a synonym for the "s"  modifier,  whereas  "singleline=false"  is  a
       synonym for the "m" modifier.  This behaviour was different up to <b>mp4h</b> 1.0.6.

       â€¢ subst-in-string "S"

         "<u>string</u>" "<u>regexp</u>" "[<u>replacement</u>]" "[caseless=true]" "[singleline=true|false]" "[reflags=[imsx]]"

       Replace a regular expression in a string by a replacement text.

       Source:

          &lt;set-var foo="abcdefghijk" /&gt;
          &lt;subst-in-string &lt;get-var foo /&gt; "[c-e]" /&gt;
          &lt;subst-in-string &lt;get-var foo /&gt; "([c-e])" "\\1 " /&gt;

       Output:

          abfghijk
          abc d e fghijk

       Source:

          &lt;set-var foo="abcdefghijk\nabcdefghijk\nabcdefghijk" /&gt;
          &lt;subst-in-string &lt;get-var foo /&gt; ".$" "" /&gt;
          &lt;subst-in-string &lt;get-var foo /&gt; ".$" "" singleline=false /&gt;
          &lt;subst-in-string &lt;get-var foo /&gt; "
             ([a-c]) | [0-9]
               " ":\\1:" reflags=x /&gt;

       Output:

          abcdefghijk
          abcdefghijk
          abcdefghij
          abcdefghij
          abcdefghij
          abcdefghij
          :a::b::c:defghijk
          :a::b::c:defghijk
          :a::b::c:defghijk

       â€¢ subst-in-var "S"

         "<u>name</u>" "<u>regexp</u>" "[<u>replacement</u>]" "[caseless=true]" "[singleline=true|false]" "[reflags=[imsx]]"

       Performs substitutions inside variable content.

       â€¢ match "S"

         "<u>string</u>"       "<u>regexp</u>"       "[caseless=true]"       "[singleline=true|false]"      "[reflags=[imsx]]"
         "[action=report|extract|delete|startpos|endpos|length]"

       "action=report"
           Prints "true" if string contains regexp.

       "action=extract"
           Prints the expression matching regexp in string.

       "action=delete"
           Prints the string without the expression matching regexp in string.

       "action=startpos"
           Prints the first char of the expression matching regexp in string.  If there  is  no  match,  returns
           "-1".

       "action=endpos"
           Prints  the  last  char  of  the expression matching regexp in string.  If there is no match, returns
           "-1".

       "action=length"
           Prints the length of the expression matching regexp in string.

       Source:

          1:&lt;match "abcdefghijk" "[c-e]+" /&gt;
          2:&lt;match "abcdefghijk" "[c-e]+" action=extract /&gt;
          3:&lt;match "abcdefghijk" "[c-e]+" action=delete /&gt;
          4:&lt;match "abcdefghijk" "[c-e]+" action=startpos /&gt;
          5:&lt;match "abcdefghijk" "[c-e]+" action=endpos /&gt;
          6:&lt;match "abcdefghijk" "[c-e]+" action=length /&gt;

       Output:

          1:true
          2:cde
          3:abfghijk
          4:2
          5:5
          6:3

   <b>Arrays</b>
       With <b>mp4h</b> one can easily deal with string arrays. Variables can be treated as a  single  value  or  as  a
       newline separated list of strings.  Thus after defining

       &lt;set-var digits="0
          1
          2
          3" /&gt;

       one can view its content or one of these values:

       Source:

          &lt;get-var digits /&gt;
          &lt;get-var digits[2] /&gt;

       Output:

          0
          1
          2
          3
          2

       â€¢ array-size "S"

         "<u>name</u>"

       Returns an array size which is the number of lines present in the variable.

       Source:

          &lt;array-size digits /&gt;

       Output:

          4

       â€¢ array-push "S"

         "<u>name</u>" "<u>value</u>"

       Add a value (or more if this value contains newlines) at the end of an array.

       Source:

          &lt;array-push digits "10\n11\n12" /&gt;
          &lt;get-var digits /&gt;

       Output:

          0
          1
          2
          3
          10
          11
          12

       â€¢ array-pop "S"

         "<u>name</u>"

       Remove the toplevel value of an array and returns this string.

       â€¢ array-topvalue "S"

         "<u>name</u>"

       Prints the last entry of an array.

       Source:

          &lt;array-topvalue digits /&gt;

       Output:

          12

       â€¢ array-add-unique "S"

         "<u>name</u>" "<u>value</u>" "[caseless=true]"

       Add a value at the end of an array if this value is not already present in this variable.

       Source:

          &lt;array-add-unique digits 2 /&gt;
          &lt;get-var digits /&gt;

       Output:

          0
          1
          2
          3
          10
          11
          12

       "caseless=true"
           Comparison is case insensitive.

       â€¢ array-concat "S"

         "<u>name1</u>" "[<u>name2</u>] ..."

       Concatenates all arrays into the first one.

       Source:

          &lt;set-var foo="foo" /&gt;
          &lt;set-var bar="bar" /&gt;
          &lt;array-concat foo bar /&gt;&lt;get-var foo /&gt;

       Output:

          foo
          bar

       â€¢ array-member "S"

         "<u>name</u>" "<u>value</u>" "[caseless=true]"

       If value is contained in array, returns its index otherwise returns -1.

       Source:

          &lt;array-member digits 11 /&gt;

       Output:

          5

       "caseless=true"
           Comparison is case insensitive.

       â€¢ array-shift "S"

         "<u>name</u>" "<u>offset</u>" "[start=<u>start</u>]"

       Shifts  an array.  If offset is negative, indexes below 0 are lost.  If offset is positive, first indexes
       are filled with empty strings.

       Source:

          &lt;array-shift digits 2 /&gt;
          Now: &lt;get-var digits /&gt;
          &lt;array-shift digits -4 /&gt;
          And: &lt;get-var digits /&gt;

       Output:

          Now:

       0
          1
          2
          3
          10
          11
          12

       And: 2
          3
          10
          11
          12

       "start=<u>start</u>"
           Change origin of shifts (default is 0).

           Source:

              &lt;array-shift digits -2 start=2 /&gt;&lt;get-var digits /&gt;

           Output:

              2
              3
              12

       â€¢ sort "S"

         "<u>name</u>" "[caseless=true]" "[numeric=true]" "[sortorder=reverse]"

       Sort lines of an array in place. Default is to sort lines alphabetically.

       Source:

          &lt;sort digits /&gt;&lt;get-var digits /&gt;

       Output:

          12
          2
          3

       "caseless=true"
           Comparison is case insensitive.

       "numeric=true"
           Sort lines numerically

           Source:

              &lt;sort digits numeric=true /&gt;&lt;get-var digits /&gt;

           Output:

              2
              3
              12

       "sortorder=reverse"
           Reverse sort order

           Source:

              &lt;sort digits numeric=true sortorder=reverse /&gt;;;;
              &lt;get-var digits /&gt;

           Output:

              12
              3
              2

   <b>Numerical</b> <b>operators</b>
       These operators perform basic arithmetic operations.  When all operands are integers result is an integer
       too, otherwise it is a float.  These operators are self-explanatory.

       â€¢ add "S"

         "<u>number1</u>" "<u>number2</u>" "[<u>number3</u>] ..."

       â€¢ substract "S"

         "<u>number1</u>" "<u>number2</u>" "[<u>number3</u>] ..."

       â€¢ multiply "S"

         "<u>number1</u>" "<u>number2</u>" "[<u>number3</u>] ..."

       â€¢ divide "S"

         "<u>number1</u>" "<u>number2</u>" "[<u>number3</u>] ..."

       â€¢ min "S"

         "<u>number1</u>" "<u>number2</u>" "[<u>number3</u>] ..."

       â€¢ max "S"

         "<u>number1</u>" "<u>number2</u>" "[<u>number3</u>] ..."

       Source:

          &lt;add 1 2 3 4 5 6 /&gt;
          &lt;add 1 2 3 4 5 6. /&gt;

       Output:

          21
          21.000000

       Source:

          &lt;define-tag factorial whitespace=delete&gt;
          &lt;ifeq %0 1 1 &lt;multiply %0 "&lt;factorial &lt;substract %0 1 /&gt; /&gt;" /&gt; /&gt;
          &lt;/define-tag&gt;
          &lt;factorial 6 /&gt;

       Output:

          720

       â€¢ modulo "S"

         "<u>number1</u>" "<u>number2</u>"

       Unlike functions listed above the modulo  function  cannot  handle  more  than  2  arguments,  and  these
       arguments must be integers.

       Source:

          &lt;modulo 345 7 /&gt;

       Output:

          2

       Those  functions compare two numbers and returns "true" when this comparison is true.  If one argument is
       not a number, comparison is false.

       â€¢ gt "S"

         "<u>number1</u>" "<u>number2</u>"

       Returns "true" if first argument is greater than second.

       â€¢ lt "S"

         "<u>number1</u>" "<u>number2</u>"

       Returns "true" if first argument is lower than second.

       â€¢ eq "S"

         "<u>number1</u>" "<u>number2</u>"

       Returns "true" if arguments are equal.

       â€¢ neq "S"

         "<u>number1</u>" "<u>number2</u>"

       Returns "true" if arguments are not equal.

   <b>Relational</b> <b>operators</b>
       â€¢ not "S"

         "<u>string</u>"

       Returns "true" if string is empty, otherwise returns an empty string.

       â€¢ and "S"

         "<u>string</u>" "[<u>string</u>] ..."

       Returns the last argument if all arguments are non empty.

       â€¢ or "S"

         "<u>string</u>" "[<u>string</u>] ..."

       Returns the first non empty argument.

   <b>Flow</b> <b>functions</b>
       â€¢ group "S""V"

         "<u>expression</u>" "[<u>expression</u>] ..." "[separator=<u>string</u>]"

       This function groups multiple statements into a single one.   Some  examples  will  be  seen  below  with
       conditional operations.

       A  less  intuitive but very helpful use of this macro is to preserve newlines when "whitespace=delete" is
       specified.

       Source:

          &lt;define-tag text1&gt;
          Text on
          3 lines without
          whitespace=delete
          &lt;/define-tag&gt;
          &lt;define-tag text2 whitespace=delete&gt;
          Text on
          3 lines with
          whitespace=delete
          &lt;/define-tag&gt;
          &lt;define-tag text3 whitespace=delete&gt;
          &lt;group "Text on
          3 lines with
          whitespace=delete" /&gt;
          &lt;/define-tag&gt;
          &lt;text1/&gt;
          &lt;text2/&gt;
          &lt;text3/&gt;

       Output:

          Text on
          3 lines without
          whitespace=delete

       Text on3 lines withwhitespace=delete
          Text on
          3 lines with
          whitespace=delete

       Note that newlines are suppressed in "text2" and result is certainly unwanted.

       â€¢ compound

         "<u>expression</u>" "[<u>expression</u>] ..." "[separator=<u>string</u>]"

       Like "group",  but this tag is complex.

       "separator=<u>string</u>"
           By default arguments are put aside.  This attribute define a separator inserted between arguments.

       â€¢ disjoin "S"

         "<u>expression</u>"

       Does the opposite job to "group", its argument is no more treated as a single object  when  processed  by
       another command.

       â€¢ noexpand "S""V"

         "<u>command</u>" "[<u>command</u>] ..."

       Prints  its  arguments without expansion.  They will never be expanded unless the "expand" tag is used to
       cancel this "noexpand" tag.

       â€¢ expand "S"

         "<u>command</u>" "[<u>command</u>] ..."

       Cancels the "noexpand" tag.

       Source:

          &lt;subst-in-string "=LT=define-tag foo&gt;bar=LT=/define-tag&gt;" "=LT=" "&lt;" /&gt;
          &lt;foo/&gt;
          &lt;subst-in-string "=LT=define-tag foo&gt;quux=LT=/define-tag&gt;" "=LT="
             "&lt;noexpand "&lt;" /&gt;" /&gt;
          &lt;foo/&gt;

       Output:

          bar
          &lt;define-tag foo&gt;quux&lt;/define-tag&gt;
          bar

       â€¢ if "S""V"

         "<u>string</u>" "<u>then-clause</u>" "[<u>else-clause</u>]"

       If string is non empty, second argument is evaluated otherwise third argument is evaluated.

       Source:

          &lt;define-tag test whitespace=delete&gt;
          &lt;if %0 "yes" "no" /&gt;
          &lt;/define-tag&gt;
          &lt;test "string" /&gt;
          &lt;test "" /&gt;

       Output:

          yes
          no

       â€¢ ifeq "S""V"

         "<u>string1</u>" "<u>string2</u>" "<u>then-clause</u>" "[<u>else-clause</u>]"

       If first two arguments are identical strings, third argument is evaluated otherwise  fourth  argument  is
       evaluated.

       â€¢ ifneq "S""V"

         "<u>string1</u>" "<u>string2</u>" "<u>then-clause</u>" "[<u>else-clause</u>]"

       If  first  two arguments are not identical strings, third argument is evaluated otherwise fourth argument
       is evaluated.

       â€¢ when

         "<u>string</u>"

       When argument is not empty, its body is evaluated.

       â€¢ while "V"

         "<u>cond</u>"

       While condition is true, body function is evaluated.

       Source:

          &lt;set-var i=10 /&gt;
          &lt;while &lt;gt &lt;get-var i /&gt; 0 /&gt;&gt;;;;
            &lt;get-var i /&gt; &lt;decrement i /&gt;;;;
          &lt;/while&gt;

       Output:

          10 9 8 7 6 5 4 3 2 1

       â€¢ foreach

         "<u>variable</u>" "<u>array</u>" "[start=<u>start</u>]" "[end=<u>end</u>]" "[step=<u>pas</u>]"

       This macro is similar to the "foreach" Perl's macro: a variable loops over array values and function body
       is evaluated for each value.

       first argument is a generic variable name, and second is the name of an array.

       Source:

          &lt;set-var x="1\n2\n3\n4\n5\n6" /&gt;
          &lt;foreach i x&gt;&lt;get-var i /&gt; &lt;/foreach&gt;

       Output:

          1 2 3 4 5 6

       "start=<u>start</u>"
           Skips first indexes.

           Source:

              &lt;set-var x="1\n2\n3\n4\n5\n6" /&gt;
              &lt;foreach i x start=3&gt;&lt;get-var i /&gt; &lt;/foreach&gt;

           Output:

              4 5 6

       "end=<u>end</u>"
           Stops after index has reached that value.

           Source:

              &lt;set-var x="1\n2\n3\n4\n5\n6" /&gt;
              &lt;foreach i x end=3&gt;&lt;get-var i /&gt; &lt;/foreach&gt;

           Output:

              1 2 3

       "step=<u>step</u>"
           Change index increment (default is 1).  If step is negative, array is treated in reverse order.

           Source:

              &lt;set-var x="1\n2\n3\n4\n5\n6" /&gt;
              &lt;foreach i x step=2&gt;&lt;get-var i /&gt; &lt;/foreach&gt;
              &lt;foreach i x step=-2&gt;&lt;get-var i /&gt; &lt;/foreach&gt;

           Output:

              1 3 5
              6 4 2

       â€¢ var-case "S""V"

         "<u>var1</u>=<u>value1</u> <u>action1</u>" "[<u>var2</u>=<u>value2</u> <u>action2</u> ..."

       This command performs multiple conditions with a single instruction.

       Source:

          &lt;set-var i=0 /&gt;
          &lt;define-tag test&gt;
          &lt;var-case
            x=1   &lt;group &lt;increment i /&gt; x&lt;get-var i /&gt; /&gt;
            x=2   &lt;group &lt;decrement i /&gt; x&lt;get-var i /&gt; /&gt;
            y=1   &lt;group &lt;increment i /&gt; y&lt;get-var i /&gt; /&gt;
            y=2   &lt;group &lt;decrement i /&gt; y&lt;get-var i /&gt; /&gt;
          /&gt;
          &lt;/define-tag&gt;
          &lt;set-var x=1 y=2 /&gt;&lt;test/&gt;
          &lt;set-var x=0 y=2 /&gt;&lt;test/&gt;

       Output:

          x1y0

          y-1

       â€¢ break "S"

       Breaks the innermost "while" loop.

       Source:

          &lt;set-var i=10 /&gt;
          &lt;while &lt;gt &lt;get-var i /&gt; 0 /&gt;&gt;;;;
            &lt;get-var i /&gt; &lt;decrement i /&gt;;;;
            &lt;ifeq &lt;get-var i /&gt; 5 &lt;break/&gt; /&gt;;;;
          &lt;/while&gt;

       Output:

          10 9 8 7 6

       â€¢ return "S"

         "[up=number]" "<u>string</u>"

       This command immediately exits from the innermost macro.  A message may also be inserted.  But this macro
       changes token parsing so its use may become very hazardous in some situations.

       "up=<u>number</u>"
           This attribute determines how much levels have to be exited.  By default only one level  is  skipped.
           With  a  null  value,  all  current  macros are exited from.  A negative value do the same, and stops
           processing current file.

       â€¢ warning "S"

         "<u>string</u>"

       Prints a warning on standard error.

       â€¢ exit "S"

         "[status=<u>rc</u>]" "[message=<u>string</u>]"

       Immediately exits program.

       "message=<u>string</u>"
           Prints a message to the standard error.

       "status=<u>rc</u>"
           Selects the code returned by the program (-1 by default).

       â€¢ at-end-of-file

       This is a special command: its content is stored and will be expanded after end of input.

   <b>File</b> <b>functions</b>
       â€¢ directory-contents "S"

         "<u>dirname</u>" "[matching=regexp]"

       Returns a newline separated list of files contained in a given directory.

       Source:

          &lt;directory-contents . matching=".*\\.mp4h$" /&gt;

       Output:

          mp4h.mp4h

       â€¢ real-path "S"

         "patname=<u>pathname</u>"

       Resolves all symbolic links, extra ``/'' characters and references to  <a href="file:/./">/./</a>  and  <a href="file:/../">/../</a>  in  pathname,  and
       expands  into  the  resulting  absolute pathname.  All but the last component of pathname must exist when
       real-path is called.

       This tag is particularly useful when comparing if file or directory names are identical.

       Source:

          &lt;real-path pathname=&lt;__file__/&gt; /&gt;

       Output:

          /build/mp4h-MsMTo_/mp4h-1.3.1/doc/mp4h.mp4h

       â€¢ file-exists "S"

         "<u>filename</u>"

       Returns "true" if file exists.

       â€¢ get-file-properties "S"

         "<u>filename</u>"

       Returns an array of information on this file.  These information are: size, type,  ctime,  mtime,  atime,
       owner and group.

       Source:

          &lt;get-file-properties &lt;__file__/&gt; /&gt;

       Output:

          68604
          FILE
          1530057894
          1530057894
          1530057894
          root
          root

       â€¢ include "S"

         "file=<u>filename</u> | command=<u>command-line</u>" "[alt=<u>action</u>]" "[verbatim=true]"

       Insert the contents of a file in the file system - if the "file" attribute is given -, or the output from
       executing  a system command - if the "command" attribute is given - into the input stream.  For backwards
       compatibility, if neither the "file" nor the "command" attributes are given, the first argument is  taken
       as a file to include.

       "file=<u>filename</u>"
           The  given  file  is read and inserted into the input stream.  This attribute cannot be combined with
           the command attribute.

           Files are first searched in current directory, then in directories specified on command-line with the
           "-I" option, next in directories listed  in  the  "MP4HLIB"  environment  variable  (it  used  to  be
           "MP4HPATH"   for   versions   prior   to   1.3),   and   last   under   the   compile-time   location
           ("/usr/local/lib/mp4h/1.3.1:/usr/local/share/mp4h" by default).

       "command=<u>command-line</u>"
           The given command line is executed on the operating system, and the output of it is inserted  in  the
           input stream. This attribute cannot be combined with the file attribute.

           The  given  command  line  is  executed using the <u><a href="../man3/popen.3.html">popen</a></u>(3) standard C library routine. The command is
           executed using the standard system shell, which on Posix compliant systems is <u><a href="../man1/sh.1.html">sh</a></u>(1).

       "alt=<u>action</u>"
           If file is not found, this alternate action is handled. If this attribute is not set and file is  not
           found, then an error is raised. This attribute has no effect when the command attribute is specified.

       "verbatim=true"
           File  content  is  included without expansion.  This is similar to using the <b>m4</b> undivert macro with a
           filename as argument.

       Source:

          &lt;include command="uname -s" /&gt;

       Output:

          Linux

       â€¢ use "S"

         "name=<u>package</u>"

       Load definitions from a package file.

       â€¢ comment

       This tag does nothing, its body is simply discarded.

       â€¢ set-eol-comment "S"

         "[<u>string</u>]"

       Change comment characters.

       â€¢ set-quotes "S"

         "[<u>string</u> <u>string</u>]" "[display=visible]"

       By default, all characters between "&lt;@[" and "]@"&gt; pairs are read without parsing.  When  called  without
       argument,  this macro inhibates this feature.  When called with two arguments, it redefines begin and end
       delimiters.  Begin delimiter must begin with a left-angle bracket, and end  delimiter  must  end  with  a
       right-angle bracket.

       "display=visible"
           Delimiters are also written into output.

   <b>Diversion</b> <b>functions</b>
       Diversions  are  a way of temporarily saving output.  The output of <b>mp4h</b> can at any time be diverted to a
       temporary file, and be reinserted into the output stream, undiverted, again at a later time.

       Numbered diversions are counted from 0 upwards, diversion number 0 being the normal output  stream.   The
       number  of  simultaneous  diversions  is limited mainly by the memory used to describe them, because <b>mp4h</b>
       tries to keep diversions in memory.  However, there is a limit  to  the  overall  memory  usable  by  all
       diversions  taken  altogether.  When  this maximum is about to be exceeded, a temporary file is opened to
       receive the contents of the biggest diversion still in memory, freeing this memory for other  diversions.
       So, it is theoretically possible that the number of diversions be limited by the number of available file
       descriptors.

       â€¢ divert "S"

         "[ divnum=<u>diversion-number</u> ]"

       Output  is  diverted  using  this  tag, where diversion-number is the diversion to be used. If the divnum
       attribute is left out, diversion-number is assumed to be zero.  If output is diverted to  a  non-existent
       diversion, it is simply discarded.  This can be used to suppress unwanted output. See the example below.

       When  all  <b>mp4h</b>  input will have been processed, all existing diversions are automatically undiverted, in
       numerical order.

       Several calls of divert with the same argument do not overwrite the previous diverted text, but append to
       it.

       Source:

          &lt;divert divnum="-1"/&gt;
          This is sent nowhere...
          &lt;divert/&gt;
          This is output.

       Output:

          This is sent nowhere...

       This is output.

       â€¢ undivert "S"

         "[ divnum=<u>diversion-number</u> ]"

       This tag explicitly undiverts diverted text saved in the diversion with  the  specified  number.  If  the
       divnum attribute is not given, all diversions are undiverted, in numerical order.

       When  diverted  text  is  undiverted, it is not reread by <b>mp4h</b>, but rather copied directly to the current
       output. It is therefore not an error to undivert into a diversion.

       Unlike <b>m4</b>, the <b>mp4h</b> undivert tag does not allow a file name as argument. The  same  can  be  accomplished
       with the include tag with the verbatim="true" attribute.

       Source:

          &lt;divert divnum="1"/&gt;
          This text is diverted.
          &lt;divert/&gt;
          This text is not diverted.
          &lt;undivert divnum="1"/&gt;

       Output:

          This text is diverted.

       This text is not diverted.

       â€¢ divnum "S"

       This tag expands to the number of the current diversion.

       Source:

          Initial &lt;divnum/&gt;
          &lt;divert divnum="1"/&gt;
          Diversion one: &lt;divnum/&gt;
          &lt;divert divnum="2"/&gt;
          Diversion two: &lt;divnum/&gt;
          &lt;divert/&gt;

       Output:

          Initial 0

       Diversion one: 1

       Diversion two: 2

   <b>Debugging</b> <b>functions</b>
       When  constructs  become  complex it could be hard to debug them.  Functions listed below are very useful
       when you could not figure what is wrong.  These functions are not perfect yet and  must  be  improved  in
       future releases.

       â€¢ function-def "S"

         "<u>name</u>"

       Prints  the  replacement  text  of  a  user  defined  macro. For instance, the macro used to generate all
       examples of this documentation is

       Source:

          &lt;function-def example /&gt;

       Output:

          &lt;set-var-verbatim verb-body=%ubody /&gt;&lt;subst-in-var verb-body "&lt;" "&lt;" /&gt;
          &lt;subst-in-var verb-body "&gt;" "&gt;" /&gt;&lt;subst-in-var verb-body "^\n*" "" /&gt;&lt;subst-in-var verb-body "^" "   " reflags=m /&gt;&lt;set-var body=%body /&gt;&lt;subst-in-var body "&lt;three-colon/&gt;[^;\n]*\n[ \t]*" "" /&gt;&lt;subst-in-var body "&lt;three-colon/&gt;$" "" reflags=m /&gt;&lt;subst-in-var body "^\n*" "" /&gt;&lt;subst-in-var body "^" "   " reflags=m /&gt;&lt;group "Source:

       &lt;get-var-once verb-body /&gt;

       Output:

       &lt;get-var-once body /&gt;

       " /&gt;

       â€¢ debugmode "S"

         "<u>string</u>"

       This command acts like the "-d" flag but can be ynamically changed.

       â€¢ debugfile "S"

         "<u>filename</u>"

       Selects a file where debugging messages are diverted.  If this filename is empty, debugging messages  are
       sent back to standard error, and if it is set to "-" these messages are discarded.

       <b>Note:</b> There is no way to print these debugging messages into the document being processed.

       â€¢ debugging-on "S"

         "<u>name</u>" "[<u>name</u>] ..."

       Declare  these  macros  traced,  i.e.  information  about  these  macros  will be printed if "-d" flag or
       "debugmode" macro are used.

       â€¢ debugging-off "S"

         "<u>name</u>" "[<u>name</u>] ..."

       These macros are no more traced.

   <b>Miscellaneous</b>
       â€¢ __file__ "S"

         "[<u>name</u>]"

       Without argument this macro prints current input filename.  With an argument, this macro sets the  string
       returned by future invocation of this macro.

       â€¢ __line__ "S"

         "[<u>number</u>]"

       Without  argument this macro prints current number line in input file.  With an argument, this macro sets
       the number returned by future invocation of this macro.

       Source:

          This is &lt;__file__/&gt;, line &lt;__line__/&gt;.

       Output:

          This is ./mp4h.mp4h, line 2201.

       If you closely look at source code you will see that this number is wrong. Indeed the number line is  the
       end of the entire block containing this instruction.

       â€¢ __version__ "S"

       Prints the version of <b>mp4h</b>.

       â€¢ dnl "S"

       Discard  all  characters  until newline is reached. This macro ensures that following string is a comment
       and does not depend of the value of comment characters.

       Source:

          &lt;dnl/&gt;This is a comment
          foo
          &lt;dnl/&gt;This is a comment
          bar

       Output:

          foo
          bar

       â€¢ date "S"

         "[epoch]"

       Prints local time according to the epoch passed on argument.  If there is no argument, current local time
       is printed.

       "time"
           An epoch time specification.

       "format"
           A format specification as used with the <u><a href="../man3/strftime.3.html">strftime</a></u>(3) C library routine.

       Source:

          &lt;date/&gt;
          &lt;set-var info=&lt;get-file-properties &lt;__file__/&gt; /&gt; /&gt;
          &lt;date &lt;get-var info[2] /&gt; /&gt;
          &lt;date time="&lt;get-var info[2] /&gt;" format="%Y-%m-%d %H:%M:%S" /&gt;

       Output:

          Wed Jun 27 00:04:54 2018

       Wed Jun 27 00:04:54 2018
          2018-06-27 00:04:54

       â€¢ timer "S"

       Prints the time spent since last call to this macro.  The printed value is the number of clock ticks, and
       so is dependent of your CPU.

       Source:

          &lt;timer/&gt;
          The number of clock ticks since the beginning of the parsing of
          this example by &amp;mp4h; is:
          &lt;timer/&gt;

       Output:

          user 23
          sys 23

       The number of clock ticks since the beginning of the parsing of
          this example by <b>mp4h</b> is:
          user 23
          sys 23

       â€¢ mp4h-l10n "S"

         "<u>name</u>=<u>value</u>"

       Set locale-specific variables.  By default,  the  portable  "C"  locale  is  selected.  As  locales  have
       different  names on different platforms, you must refer to your system documentation to find which values
       are adapted to your system.

       â€¢ mp4h-output-radix "S"

         "<u>number</u>"

       Change the output format of floats by setting the number of digits after the decimal point. Default is to
       print numbers in the "%6.f" format.

       Source:

          &lt;add 1.2 3.4 /&gt;
          &lt;mp4h-output-radix 2 /&gt;
          &lt;add 1.2 3.4 /&gt;

       Output:

          4.600000

       4.60

</pre><h4><b>EXTERNAL</b> <b>PACKAGES</b></h4><pre>
       It is possible to include external files with the "include" command.  Files are first searched in current
       directory, then in directories specified on command-line with the "-I" option, next in directories listed
       in the "MP4HLIB" environment variable (it used to be "MP4HPATH" for versions  prior  to  1.3),  and  last
       under the compile-time location ("/usr/local/lib/mp4h/1.3.1:/usr/local/share/mp4h" by default).

       Another  way  to include packages is with the "use" command.  There are two differences between "use" and
       "include": first, package name has no suffix; and more important, a package cannot be  loaded  more  than
       once.

</pre><h4><b>MACRO</b> <b>EXPANSION</b></h4><pre>
       This  part  describes  internal  mechanism  of  macro expansion.  It must be as precise and exhaustive as
       possible so contact me "&lt;URL:<a href="mailto:barbier@linuxfr.org">mailto:barbier@linuxfr.org</a>&gt;" if you have any suggestion.

   <b>Basics</b>
       Let us begin with some examples:

       Source:

          &lt;define-tag foo&gt;
          This is a simple tag
          &lt;/define-tag&gt;
          &lt;define-tag bar endtag=required&gt;
          This is a complex tag
          &lt;/define-tag&gt;
          &lt;foo/&gt;
          &lt;bar&gt;Body function&lt;/bar&gt;

       Output:

          This is a simple tag

          This is a complex tag

       User defined macros may have attributes like HTML tags. To handle these attributes in  replacement  text,
       following conventions have been adopted (mostly derived from <b>Meta-HTML</b>):

       â€¢ Sequence %name is replaced by the command name.

       â€¢ Attributes  are  numbered from 0. In replacement text, %0 is replaced by first argument, %1 by the 2nd,
         etc.  As there is no limitation on the number of arguments, %20 is the 21st argument and not the  third
         followed by the 0 letter.

         Source:

            &lt;define-tag href&gt;
            &lt;a href="%0"&gt;%1&lt;/a&gt;
            &lt;/define-tag&gt;
            &lt;href <a href="http://www.gimp.org">http://www.gimp.org</a> "The Gimp" /&gt;

         Output:

            &lt;a href="<a href="http://www.gimp.org">http://www.gimp.org</a>"&gt;The Gimp&lt;/a&gt;

       â€¢ Sequence "%#" prints number of attributes.

       â€¢ Sequence "%%" is replaced by "%", which is useful in nested definitions.

         Source:

            &lt;define-tag outer&gt;;;;
            outer, # attributes: %#
            &lt;define-tag inner1&gt;;;;
            inner1, # attributes: %#;;;
            &lt;/define-tag&gt;;;;
            &lt;define-tag inner2&gt;;;;
            inner2, # attributes: %%#;;;
            &lt;/define-tag&gt;;;;
            &lt;inner1 %attributes and some others /&gt;
            &lt;inner2 %attributes and some others /&gt;
            &lt;/define-tag&gt;
            &lt;outer list attributes /&gt;

         Output:

            outer, # attributes: 2
            inner1, # attributes: 2
            inner2, # attributes: 5

       â€¢ Sequence %attributes is replaced by the space separated list of attributes.

         Source:

            &lt;define-tag mail1&gt;
            &lt;set-var %attributes /&gt;
            &lt;get-var name /&gt;
            &lt;get-var mail /&gt;
            &lt;/define-tag&gt;
            &lt;set-var name="" mail="" /&gt;
            &lt;mail1 name="Dr. Foo" mail="<a href="mailto:hello@foo.com">hello@foo.com</a>" /&gt;

         Output:

            Dr. Foo
            <a href="mailto:hello@foo.com">hello@foo.com</a>

       â€¢ Sequence %body is replaced by the body of a complex macro.

         Source:

            &lt;define-tag mail2 endtag=required whitespace=delete&gt;
            &lt;set-var %attributes /&gt;
            &lt;a href="mailto:&lt;get-var mail /&gt;"&gt;%body&lt;/a&gt;
            &lt;/define-tag&gt;
            &lt;mail2 mail="<a href="mailto:hello@foo.com">hello@foo.com</a>"&gt;
            &lt;img src="photo.png" alt="Dr. Foo" border=0    /&gt;
            &lt;/mail2&gt;

         Output:

            &lt;a href="<a href="mailto:hello@foo.com">mailto:hello@foo.com</a>"&gt;
            &lt;img src="photo.png" alt="Dr. Foo" border=0      /&gt;
            &lt;/a&gt;

       â€¢ The  two forms above accept modifiers. When %Aattributes or %Abody is used, a newline separated list of
         attributes is printed.

         Source:

            &lt;define-tag show-attributes whitespace=delete&gt;
            &lt;set-var list="%Aattributes" i=0 /&gt;
            &lt;foreach attr list&gt;
            &lt;group "%&lt;get-var i /&gt;: &lt;get-var attr /&gt;" /&gt;
            &lt;increment i /&gt;
            &lt;/foreach&gt;
            &lt;/define-tag&gt;
            &lt;show-attributes name="Dr. Foo" mail="<a href="mailto:hello@foo.com">hello@foo.com</a>" /&gt;

         Output:

            %0: name=Dr. Foo%1: mail=<a href="mailto:hello@foo.com">hello@foo.com</a>

       â€¢ Another alternate form is obtained by replacing "A" by "U", in which case text is replaced but will not
         be expanded.  This does make sense  only  when  macro  has  been  defined  with  "attributes=verbatim",
         otherwise attributes are expanded before replacement.

         Source:

            &lt;define-tag show1&gt;
            Before expansion: %Uattributes
            After expansion: %attributes
            &lt;/define-tag&gt;
            &lt;define-tag show2 attributes=verbatim&gt;
            Before expansion: %Uattributes
            After expansion: %attributes
            &lt;/define-tag&gt;
            &lt;define-tag bar&gt;and here %attributes&lt;/define-tag&gt;
            &lt;show1 &lt;bar we go /&gt; /&gt;
            &lt;show2 &lt;bar we go /&gt; /&gt;

         Output:

            Before expansion: and here we go
            After expansion: and here we go

            Before expansion: &lt;bar we go /&gt;
            After expansion: and here we go

       â€¢ Modifiers "A" and "U" can be combined.

       <b>Note:</b>  Input  expansion is completely different in <b>Meta-HTML</b> and in <b>mp4h</b>.  With <b>Meta-HTML</b> it is sometimes
       necessary to use other constructs like %xbody and %qbody.  In order to  improve  compatibity  with  <b>Meta-</b>
       <b>HTML</b>,  these  constructs  are  recognized  and  are interpreted like %body.  Another feature provided for
       compatibility reason is the fact that for simple  tags  %body  and  %attributes  are  equivalent.   These
       features are in the current <b>mp4h</b> version but may disappear in future releases.

   <b>Attributes</b>
       Attributes  are  separated  by  spaces,  tabulations or newlines, and each attribute must be a valid <b>mp4h</b>
       entity. For instance with the definitions above, "&lt;bar&gt;" can  not  be  an  attribute  since  it  must  be
       finished by "&lt;/bar&gt;".  But this is valid:

          &lt;foo &lt;foo/&gt; /&gt;

       or even

          &lt;foo &lt;foo name=src url=ici /&gt; /&gt;

       In these examples, the "foo" tag has only one argument.

       Under  certain  circumstances it is necessary to group multiple statements into a single one. This can be
       done with double quotes or with the "group" primitive, e.g.

          &lt;foo "This is the 1st attribute"
                     &lt;group and the second /&gt; /&gt;

       <b>Note:</b> Unlike HTML single quotes can not replace doube quotes for this purpose.

       If double quotes appear in an argument, they must be escaped by a backslash "\".

       Source:

            &lt;set-var text="Text with double quotes \" inside" /&gt;
            &lt;get-var text /&gt;

       Output:

            Text with double quotes " inside

   <b>Macro</b> <b>evaluation</b>
       Macros are characterized by

       â€¢ name

       â€¢ container status (simple or complex)

       â€¢ if attributes are expanded or not

       â€¢ function type (primitive or user defined macro)

       â€¢ for primitives, address of corresponding code in memory and for user  defined  macros  the  replacement
         text

       Characters  are  read  on input until a left angle bracket is found.  Then macro name is read. After that
       attributes are read, verbatim or not depending on how this macro as been defined. And if  this  macro  is
       complex, its body is read verbatim. When this is finished, some special sequences in replacement text are
       replaced  (like %body, %attributes, %0, %1, etc.) and resulting text is put on input stack in order to be
       rescanned.

       <b>Note:</b> By default attributes are evaluated before any replacement.

       Consider the following example, to change text in typewriter font:

       &lt;define-tag text-tt endtag=required whitespace=delete&gt;
          &lt;tt&gt;%body&lt;/tt&gt;
          &lt;/define-tag&gt;

       This definition has a major drawback:

       Source:

          &lt;text-tt&gt;This is an &lt;text-tt&gt;example&lt;/text-tt&gt;&lt;/text-tt&gt;

       Output:

          &lt;tt&gt;This is an &lt;tt&gt;example&lt;/tt&gt;&lt;/tt&gt;

       We would like the inner tags be removed.

       First idea is to use an auxiliary variable to know whether we still are inside such an environment:

       &lt;set-var _text:tt=0 /&gt;
          &lt;define-tag text-tt endtag=required whitespace=delete&gt;
          &lt;increment _text:tt /&gt;
          &lt;ifeq &lt;get-var _text:tt /&gt; 1 "&lt;tt*&gt;" /&gt;
          %body
          &lt;ifeq &lt;get-var _text:tt /&gt; 1 "&lt;/tt*&gt;" /&gt;
          &lt;decrement _text:tt /&gt;
          &lt;/define-tag&gt;

       (the presence of asterisks in HTML tags is explained in next section).

       Source:

          &lt;text-tt&gt;This is an &lt;text-tt&gt;example&lt;/text-tt&gt;&lt;/text-tt&gt;

       Output:

          &lt;tt&gt;This is an example&lt;/tt&gt;

       But if we use simple tags, as in the example below, our definition does not seem to work. It  is  because
       attributes are expanded before they are put into replacement text.

       Source:

          &lt;define-tag opt&gt;&lt;text-tt&gt;%attributes&lt;/text-tt&gt;&lt;/define-tag&gt;
          &lt;opt "This is an &lt;opt example /&gt;" /&gt;

       Output:

          &lt;tt&gt;This is an &lt;tt&gt;example&lt;/tt&gt;&lt;/tt&gt;

       If we want to prevent this problem we have to forbid attributes expansion with

       Source:

          &lt;define-tag opt attributes=verbatim&gt;;;;
          &lt;text-tt&gt;%attributes&lt;/text-tt&gt;;;;
          &lt;/define-tag&gt;
          &lt;opt "This is an &lt;opt example /&gt;" /&gt;

       Output:

          &lt;tt&gt;This is an example&lt;/tt&gt;

   <b>Expansion</b> <b>flags</b>
       When  you  want  to  embed  some  server-side  scripting  language  in your pages, you face up some weird
       problems, like in

       &lt;a href=&lt;%= $url %&gt;&gt;Hello&lt;/a&gt;

       The question is how do <b>mp4h</b> know that this input has some extra  delimiters?  The  answer  is  that  <b>mp4h</b>
       should  not  try  to handle some special delimiters, because it cannot handle all of them (there are ASP,
       ePerl, PHP,... and some of them are customizable). Now, remember that <b>mp4h</b> is a macro-processor,  not  an
       XML  parser.  So  we  must focus on macros,and format our input file so that it can be parsed without any
       problem.  Previous example may be written

       &lt;a href="&lt;%= $url %&gt;"&gt;Hello&lt;/a&gt;

       because quotes prevent inner right-angle bracket from closing the "a" tag.

       Another common problem is when we need to print only a begin or an end tag alone.   For  instance  it  is
       very desirable to define its own headers and footers with

       &lt;define-tag header&gt;
          &lt;html*&gt;
          &lt;head&gt;
          ... put here some information ....
          &lt;/head&gt;
          &lt;body* bgcolor="#ffffff" text="#000000"&gt;
          &lt;/define-tag&gt;
          &lt;define-tag footer&gt;
          &lt;/body*&gt;
          &lt;/html*&gt;
          &lt;/define-tag&gt;

       Asterisks mark these tags as pseudo-simple tags, which means that they are complex HTML tags, but used as
       simple tags within <b>mp4h</b> because tags would not be well nested otherwise.

       This asterisk is called ``trailing star'', it appears at the end of the tag name.

       Sometimes HTML tags are not parsable, as in this javascript code:

         ...
              document.write('&lt;*img src="foo.gif"');
              if (text) document.write(' alt="'+text+'"');
              document.write('&gt;');
            ...

       The ``leading star'' is an asterisk between left-angle bracket and tag name, which prevents this tag from
       being parsed.

       That  said  we  can  now  understand  what  the  "--expansion" flag is for.  It controls how expansion is
       performed by mp4h.  It is followed by an integer, which is a bit sum of the following values

       <b>1</b> do not parse unknown tags.
         When set, HTML tags are not parsed.  When unset, HTML tags are parsed, i.e. that attributes and/or body
         is collected.

       <b>2</b> unknown tags are assumed being simple.
         When set, HTML tags are simple by default.  When unset, HTML tags are complex by default, unless  their
         attribute contain a trailing slash or a trailing star appear just after tag name (see below).

       <b>4</b> trailing star in tag name do not make this tag simple.
         When  set,  trailing  star  in tag name has no special effect.  When unset, it causes an HTML tag to be
         simple.

       <b>8</b> an unmatched end tag closes all previous unmatched begin tags.
         When set, all missing end closing tags are automatically inserted.  When unset, an unmatched end tag is
         discarded and interpreted as normal text, so processing goes on until matching and tag is found.

       <b>16</b> interpret backslashes as printf.
         When set, backslashes before non special characters are removed.  When unset, they are preserved.

       <b>32</b> remove trailing slash in tag attributes.
         When set, remove trailing slash in tag attributes on output.  When unset, they are preserved.

       <b>64</b> do not remove trailing star in tag name.
         When set, trailing star after tag name are preserved on output.  When unset, they are removed.

       <b>128</b> do not remove leading star in tag name.
         When set, leading star before tag name are preserved on output.  When unset, they are removed.

       <b>256</b> do not add a space before trailing slash in tag attributes
         By default, a space is inserted before trailing slash in tag attributes.  When set, this space  is  not
         prepended.

       <b>1024</b> suppress warnings about bad nested tags.
         When  set,  warnings about bad nested tags are not displayed.  When unset, they are printed on standard
         error.

       <b>2048</b> suppress warnings about missing trailing slash.
         When set, warnings about missing trailing slash are not displayed.  When unset,  they  are  printed  on
         standard error.

       Run

         mp4h -h

       to  find  default  value.  Current  value matches HTML syntax, and it will tend to zero when XHTML syntax
       becomes more familiar.

</pre><h4><b>AUTHOR</b></h4><pre>
       Denis Barbier "&lt;URL:<a href="mailto:barbier@linuxfr.org">mailto:barbier@linuxfr.org</a>&gt;"

       Mp4h has its own homepage "&lt;URL:<a href="http://mp4h.tuxfamily.org/">http://mp4h.tuxfamily.org/</a>&gt;".

</pre><h4><b>THANKS</b></h4><pre>
       Sincere thanks to Brian J. Fox for writing <b>Meta-HTML</b> and Rene  Seindal  for  maintaining  this  wonderful
       macro parser called GNU <b>m4</b>.

HTML Tools                                         2018-06-27                                            <u><a href="../man1/MP4H.1.html">MP4H</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>