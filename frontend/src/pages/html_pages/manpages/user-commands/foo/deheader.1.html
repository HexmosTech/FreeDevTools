<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>deheader - report which includes in C or C++ compiles can be removed</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/deheader">deheader_1.11-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       deheader - report which includes in C or C++ compiles can be removed

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>deheader</b> [-h] [-m <u>command</u>] [-b <u>builddir</u>] [-i <u>pattern</u>] [-q] [-r] [-v] [-x <u>pattern</u>] [-V] [<u>file-or-dir</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This tool takes a list of C or C++ sourcefiles and generates a report on which #includes can be omitted
       from them; also, what standard inclusions may be required for portability. The test, for each foo.c or
       foo.cc or foo.cpp, is simply whether "rm foo.o; make foo.o" returns a zero status (but the build command
       may be overridden).

       Exception: Under cmake, foo.o is a phony target. Therefore, when a "CMakeList.txt" is detected, "make
       clean" is done rather than "rm foo.o".

       Optionally, with the <b>-r</b> switch, the unneeded headers are removed from the sourcefiles. Don't use this
       option unless you have your sourcefiles safely under version control and can revert!

       If a sourcefile argument is a directory, the report is generated on all source files beneath it.
       Subdirectories beginning with a dot are assumed to be repository directories for version-control systems
       and ignored. If no arguments are given, the program runs as if the name of the current directory had been
       passed to it.

       Inclusions within the scope of #if/#ifdef/#else/#endif directives are left alone, because trying to
       reason about potential combinations of -D and U options would be too complicated and prone to weird
       errors. One exception: headers protected only by S_SPLINT_S, the conditional for blocking scanning by the
       static analysis tool <b><a href="../man1/splint.1.html">splint</a></b>(1), are scanned normally.

       The tool will also emit warnings about duplicate inclusions, and inclusions required for portability but
       not present.

       It is recommended that you arrange to compile with options that will stop the compiler on warnings when
       using this tool; otherwise it will report headers that only declare prototypes and return types (and thus
       throw only warnings) as being not required. Under gcc the compiler options to accomplish this are -Werror
       -Wfatal-errors. If your makefile follows normal conventions, running with <b>-m</b> <b>"make</b> <b>CFLAGS='-Werror</b>
       <b>-Wfatal-errors'</b> <b>%s"</b> may do the right thing; you can check this by running with -v -v -v to see what
       compilation commands are actually emitted.

       On each test compile, the original sourcefile is moved to a name with an .orig suffix and restored on
       interrupt or after processing with its original timestamp, unless the <b>-r</b> option was given and headers
       removed.

       If the -b option is given, it tells the program that generated .o files live in a file tree parallel to
       the source tree but rooted at the specified argument. If the argument is a relative path, it is
       interpreted relative to the directory in which deheader is run.

       If the first test compilation from the top-level directory fails, deheader descends into the subdirectory
       of the source file and retries compiling inside there.

       At verbosity level 0, only messages indicating removable headers are issued. At verbosity 1, test
       compilations are timed and progress indicated with a twirling-baton prompt. At verbosity level 2, you get
       verbose progress messages on the analysis. At verbosity level 3, you see the output from the make and
       compilation commands.

       If the -q (--quiet) option flag was not set, the last line of the output will be a statistical summary.

       Running deheader will leave a lot of binaries in your directory that were compiled in ways possibly not
       invoked by your normal build process. Running "make clean" afterwards (or the equivalent under whatever
       build system you are using) is strongly recommended.

</pre><h4><b>OPTIONS</b></h4><pre>
       -h
           Display some help and exit.

       -m
           Set the build command used for test compiles. Defaults to 'make %s'. A %s in the build command is
           replaced with the make target. Targetless builders such as meson can be supported with, e.g. "-m
           'ninja -C build'"

       -b
           Set the build directory for object files.

       -i
           Set a pattern for includes to be ignored. Takes a Python regular expression.

       -q
           Suppress statistical summary.

       -r
           Remove header inclusions from sourcefiles where they are not required.

       -v
           Set verbosity.

       -x
           Exclude files with names matching the specified Python regexp.

       -V
           Show version of program and exit.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Returns 1 if unneeded includes were found, 0 otherwise. Thus, you can use it for pre-release sanity
       checking in Makefile.

</pre><h4><b>BUGS</b></h4><pre>
       Very rarely, test-compiling after running with <b>-r</b> may show that this tool removed some headers that are
       actually required for your build. This can happen because <b>deheader</b> doesn't know about all the strange
       things your build system gets up to, and the problem of analyzing your build to understand them would be
       Turing-complete. Simply revert the altered files and continue.

       Due to minor variations in system headers, it is possible your program may not port correctly in older
       Unix variants after being deheadered. This is normally not a problem with the portion of the API
       specified by POSIX and ANSI C, but may be for headers that are not standardized or only weakly
       standardized. The sockets API (sys/select.h, sys/sockets.h, and friends such as sys/types.h and
       sys.stat.h) is perhaps the most serious trouble spot.  <b>deheader</b> has an internal table of rules that heads
       off the most common problems by suppressing deletion of headers that are required for portability, but
       your mileage may vary.

       The dependency scanner does not ignore the text of comments. This, e.g, a reference to "log10" in a
       comment will produce a spurious warning that &lt;math.h&gt; is required for portability.

       Sufficiently perverse C++ can silently invalidate the brute-force algorithm this tool uses. Example: if
       an overloaded function has different overloads from two different files, removing one may expose the
       other, changing runtime semantics without a compile-time warning. Similarly, removing a later file
       containing a template specialization may lead to undefined behavior from a template defined in an earlier
       file. Use this with caution near such features, and test carefully.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eric S. Raymond &lt;<a href="mailto:esr@snark.thyrsus.com">esr@snark.thyrsus.com</a>&gt;; (home page at <b><a href="http://www.catb.org/~esr/">http://www.catb.org/~esr/</a></b>).

deheader                                           10/06/2024                                        <u><a href="../man1/DEHEADER.1.html">DEHEADER</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>