<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gunicorn - Event-based HTTP/WSGI server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/gunicorn">gunicorn_23.0.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gunicorn - Event-based HTTP/WSGI server

</pre><h4><b>SYNOPSIS</b></h4><pre>
       gunicorn [OPTIONS] APP_MODULE

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-c</b> <u>CONFIG</u>, <b>--config</b>=<u>CONFIG</u>
         Config file. [none]

       <b>-b</b> <u>BIND</u>, <b>--bind</b>=<u>BIND</u>
         Address to listen on. Ex. 127.0.0.1:8000 or unix:/tmp/gunicorn.sock

       <b>-w</b> <u>WORKERS</u>, <b>--workers</b>=<u>WORKERS</u>
         Number of workers to spawn. [1]

       <b>-a</b> <u>ARBITER</u>, <b>--arbiter</b>=<u>ARBITER</u>
         gunicorn arbiter entry point or module [egg:gunicorn#main]

       <b>-p</b> <u>PIDFILE</u>, <b>--pid</b>=<u>PIDFILE</u>
         Set the background PID FILE

       <b>-D</b>, <b>--daemon</b>
         Run daemonized in the background.

       <b>-m</b> <u>UMASK</u>, <b>--umask</b>=<u>UMASK</u>
         Define umask of daemon process

       <b>-u</b> <u>USER</u>, <b>--user</b>=<u>USER</u>
         Change worker user

       <b>-g</b> <u>GROUP</u>, <b>--group</b>=<u>GROUP</u>
         Change worker group

       <b>-n</b> <u>PROC_NAME</u>, <b>--name</b>=<u>PROC_NAME</u>
         Process name

       <b>--log-level</b>=<u>LOGLEVEL</u>
         Log level below which to silence messages. [info]

       <b>--log-file</b>=<u>LOGFILE</u>
         Log to a file. - equals stdout. [-]

       <b>d</b>, <b>--debug</b>
         Debug mode. only 1 worker.

       <b>--version</b>
         Show program's version number and exit

       <b>-h</b>, <b>--help</b>
         show this help message and exit

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Green  Unicorn  (gunicorn)  is an HTTP/WSGI server designed to serve fast clients or sleepy applications.
       That is to say; behind a buffering front-end server such as nginx or lighttpd.

        * Optional support for Eventlet and Gevent to provide asynchronous
          long-polling ("Comet") connections.
        * Process management: Gunicorn reaps and restarts workers that die.
        * Easy integration with Django and Paster compatible applications (Pylons,
          TurboGears 2, etc.
        * Load balancing via pre-fork and a shared socket
        * Graceful worker process restarts
        * Upgrading without losing connections
        * Decode chunked transfers on-the-fly, allowing upload progress notifications
          or stream-based protocols over HTTP

</pre><h4><b>TUNING</b></h4><pre>
   <b>KERNEL</b> <b>PARAMETERS</b>
       There are various kernel parameters that you might want to tune in order to deal with a large  number  of
       simultaneous  connections.  Generally  these  should  only affect sites with a large number of concurrent
       requests and apply to any sort of network server you may be running. They're  listed  here  for  ease  of
       reference.

       The commands listed are tested under Mac OS X 10.6. Your flavor of Unix may use slightly different flags.
       Always reference the appropriate man pages if uncertain.

   <b>INCREASING</b> <b>THE</b> <b>FILE</b> <b>DESCRIPTOR</b> <b>LIMIT</b>
       One  of the first settings that usually needs to be bumped is the maximum number of open file descriptors
       for a given process. For the confused out there, remember that Unices treat sockets as files.

        $ sudo ulimit -n 1024

   <b>INCREASING</b> <b>THE</b> <b>LISTEN</b> <b>QUEUE</b> <b>SIZE</b>
       Listening sockets have an associated queue of incoming connections that are waiting to  be  accepted.  If
       you  happen  to  have a stampede of clients that fill up this queue new connections will eventually start
       getting dropped.

        $ sudo sysctl -w kern.ipc.somaxconn="1024"

   <b>WIDENING</b> <b>THE</b> <b>EPHEMERAL</b> <b>PORT</b> <b>RANGE</b>
       After a socket is closed it eventually enters the TIME_WAIT state. This  can  become  an  issue  after  a
       prolonged  burst  of  client activity. Eventually the ephemeral port range is used up which can cause new
       connections to stall while they wait for a valid port.

       This setting is generally only required on machines that are being used to test a network server.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/gunicorn_paster.1.html">gunicorn_paster</a></b>(1)

perl v5.38.2                                       2024-08-14                                        <u><a href="../man1/GUNICORN.1.html">GUNICORN</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>