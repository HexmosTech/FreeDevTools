<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pypy3 - fast, compliant alternative implementation of the Python 3 language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/pypy3">pypy3_7.3.19+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pypy3 - fast, compliant alternative implementation of the Python 3 language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>pypy3</b> [<u>options</u>] [<b>-c</b> <u>cmd</u>|<b>-m</b> <u>mod</u>|<u>file.py</u>|<b>-</b>] [<u>arg</u>...]

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-i</b>     Inspect interactively after running script.

       <b>-O</b>     Skip assert statements.

       <b>-O</b><u>O</u>    Remove docstrings when importing modules in addition to <b>-O</b>.

       <b>-c</b> <u>CMD</u> Program passed in as <b>CMD</b> (terminates option list).

       <b>-S</b>     Do not <b>import</b> <b>site</b> on initialization.

       <b>-s</b>     Don't add the user site directory to <u>sys.path</u>.

       <b>-u</b>     Unbuffered binary <b>stdout</b> and <b>stderr</b>.

       <b>-h</b>, <b>--help</b>
              Show a help message and exit.

       <b>-m</b> <u>MOD</u> Library module to be run as a script (terminates option list).

       <b>-W</b> <u>ARG</u> Warning control (<u>arg</u> is <u>action</u>:<u>message</u>:<u>category</u>:<u>module</u>:<u>lineno</u>).

       <b>-E</b>     Ignore environment variables (such as <b>PYTHONPATH</b>).

       <b>-B</b>     Disable writing bytecode (<b>.pyc</b>) files.

       <b>-X</b> <u>track-resources</u>
              Produce a <b>ResourceWarning</b> whenever a file or socket is closed by the garbage collector.

       <b>--version</b>
              Print the PyPy version.

       <b>--info</b> Print translation information about this PyPy executable.

       <b>--jit</b> <u>ARG</u>
              Low level JIT parameters.  Mostly internal.  Run <b>--jit</b> <b>help</b> for more information.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>PYTHONPATH</b>
              Add directories to pypy3's module search path.  The format is the same as shell's <b>PATH</b>.

       <b>PYTHONSTARTUP</b>
              A  script  referenced  by  this variable will be executed before the first prompt is displayed, in
              interactive mode.

       <b>PYTHONDONTWRITEBYTECODE</b>
              If set to a non-empty value, equivalent to the <b>-B</b> option.  Disable writing <b>.pyc</b> files.

       <b>PYTHONINSPECT</b>
              If set to a non-empty value, equivalent to the <b>-i</b> option.  Inspect interactively after running the
              specified script.

       <b>PYTHONIOENCODING</b>
              If this  is  set,  it  overrides  the  encoding  used  for  <u>stdin</u>/<u>stdout</u>/<u>stderr</u>.   The  syntax  is
              <u>encodingname</u>:<u>errorhandler</u>  The  <u>errorhandler</u>  part  is  optional  and  has  the same meaning as in
              <u>str.encode</u>.

       <b>PYTHONNOUSERSITE</b>
              If set to a non-empty value, equivalent to the <b>-s</b> option.  Don't add the user  site  directory  to
              <u>sys.path</u>.

       <b>PYTHONWARNINGS</b>
              If set, equivalent to the <b>-W</b> option (warning control).  The value should be a comma-separated list
              of <b>-W</b> parameters.

       <b>PYPYLOG</b>
              If set to a non-empty value, enable logging, the format is:

              <u>fname</u> <b>or</b> <u>+fname</u>
                     logging  for profiling: includes all <b>debug_start</b>/<b>debug_stop</b> but not any nested <b>debug_print</b>.
                     <u>fname</u> can be <b>-</b> to log to <u>stderr</u>.  The <u>+fname</u> form can be used if there is a <u>:</u> in fname

              <b>:</b><u>fname</u> Full logging, including <b>debug_print</b>.

              <u>prefix</u><b>:</b><u>fname</u>
                     Conditional logging.  Multiple prefixes can be specified, comma-separated.   Only  sections
                     whose name match the prefix will be logged.

              <b>PYPYLOG=jit-log-opt,jit-backend:logfile</b>  will  generate  a  log suitable for <u>jitviewer</u>, a tool for
              debugging performance issues under PyPy.

       <b>PYPY_IRC_TOPIC</b>
              If set to a non-empty value, print a random #pypy IRC topic at startup of interactive mode.

       PyPy's default garbage collector is  called  incminimark  -  it's  an  incremental,  generational  moving
       collector. Here we hope to explain a bit how it works and how it can be tuned to suit the workload.

       Incminimark  first  allocates objects in so called <u>nursery</u> - place for young objects, where allocation is
       very cheap, being just a pointer bump. The nursery size is a very crucial variable -  depending  on  your
       workload (one or many processes) and cache sizes you might want to experiment with it via <u>PYPY_GC_NURSERY</u>
       environment  variable.  When  the  nursery is full, a minor collection is performed. Freed objects are no
       longer referenceable and just die, just by not being referenced any more;  on  the  other  hand,  objects
       found  to  still  be  alive must survive and are copied from the nursery to the old generation. Either to
       arenas, which are collections of objects of the same size, or directly allocated with malloc  if  they're
       larger.  (A third category, the very large objects, are initially allocated outside the nursery and never
       move.)

       Since  Incminimark is an incremental GC, the major collection is incremental: the goal is not to have any
       pause longer than 1ms, but in  practice  it  depends  on  the  size  and  characteristics  of  the  heap:
       occasionally, there can be pauses between 10-100ms.

   <b>Semi-manual</b> <b>GC</b> <b>management</b>
       If  there are parts of the program where it is important to have a low latency, you might want to control
       precisely when the GC runs, to avoid unexpected  pauses.   Note  that  this  has  effect  only  on  major
       collections, while minor collections continue to work as usual.

       As explained above, a full major collection consists of <b>N</b> steps, where <b>N</b> depends on the size of the heap;
       generally speaking, it is not possible to predict how many steps will be needed to complete a collection.

       <b>gc.enable()</b>  and <b>gc.disable()</b> control whether the GC runs collection steps automatically.  When the GC is
       disabled  the  memory  usage  will  grow  indefinitely,  unless  you  manually  call   <b>gc.collect()</b>   and
       <b>gc.collect_step()</b>.

       <b>gc.collect()</b> runs a full major collection.

       <b>gc.collect_step()</b>  runs  a  single  collection step. It returns an object of type <u>GcCollectStepStats</u>, the
       same which is passed to the corresponding <u>GC</u> <u>Hooks</u>.  The  following  code  is  roughly  equivalent  to  a
       <b>gc.collect()</b>:

          while True:
              if gc.collect_step().major_is_done:
                  break

       For  a real-world example of usage of this API, you can look at the 3rd-party module <u>pypytools.gc.custom</u>,
       which also provides a <b>with</b> <b>customgc.nogc()</b> context manager to mark sections where the GC is forbidden.

   <b>Fragmentation</b>
       Before we discuss issues of "fragmentation", we need a bit of precision.  There are two kinds of  related
       but distinct issues:

       • If  the program allocates a lot of memory, and then frees it all by dropping all references to it, then
         we might expect to see the RSS to drop.  (RSS = Resident Set Size on Linux, as seen by "top"; it is  an
         approximation  of  the actual memory usage from the OS's point of view.)  This might not occur: the RSS
         may remain at its highest value.  This issue is more precisely caused  by  the  process  not  returning
         "free" memory to the OS.  We call this case "unreturned memory".

       • After doing the above, if the RSS didn't go down, then at least future allocations should not cause the
         RSS to grow more.  That is, the process should reuse unreturned memory as long as it has got some left.
         If this does not occur, the RSS grows even larger and we have real fragmentation issues.

   <b>gc.get_stats</b>
       There is a special function in the <b>gc</b> module called <b>get_stats(memory_pressure=False)</b>.

       <b>memory_pressure</b>  controls  whether or not to report memory pressure from objects allocated outside of the
       GC, which requires walking the entire heap, so it's disabled by default due to its cost. Enable  it  when
       debugging mysterious memory disappearance.

       Example call looks like that:

          &gt;&gt;&gt; gc.get_stats(True)
          Total memory consumed:
          GC used:            4.2MB (peak: 4.2MB)
             in arenas:            763.7kB
             rawmalloced:          383.1kB
             nursery:              3.1MB
          raw assembler used: 0.0kB
          memory pressure:    0.0kB
          -----------------------------
          Total:              4.2MB

          Total memory allocated:
          GC allocated:            4.5MB (peak: 4.5MB)
             in arenas:            763.7kB
             rawmalloced:          383.1kB
             nursery:              3.1MB
          raw assembler allocated: 0.0kB
          memory pressure:    0.0kB
          -----------------------------
          Total:                   4.5MB

       In this particular case, which is just at startup, GC consumes relatively little memory and there is even
       less  unused,  but allocated memory. In case there is a lot of unreturned memory or actual fragmentation,
       the "allocated" can be much higher than "used".  Generally speaking, "peak" will  more  closely  resemble
       the  actual  memory  consumed  as  reported by RSS.  Indeed, returning memory to the OS is a hard and not
       solved problem.  In PyPy, it occurs only if an arena is entirely free---a contiguous block of 64 pages of
       4 or 8 KB  each.   It  is  also  rare  for  the  "rawmalloced"  category,  at  least  for  common  system
       implementations of <b>malloc()</b>.

       The details of various fields:

       • GC  in  arenas  -  small  old objects held in arenas. If the amount "allocated" is much higher than the
         amount "used", we have  unreturned  memory.   It  is  possible  but  unlikely  that  we  have  internal
         fragmentation  here.   However, this unreturned memory cannot be reused for any <b>malloc()</b>, including the
         memory from the "rawmalloced" section.

       • GC rawmalloced - large objects allocated with malloc.  This is gives the current (first block of  text)
         and  peak  (second  block  of text) memory allocated with <b>malloc()</b>.  The amount of unreturned memory or
         fragmentation caused by <b>malloc()</b> cannot easily be reported.  Usually you can guess there is some if the
         RSS is much larger than the total memory reported for "GC allocated", but do keep  in  mind  that  this
         total  does  not  include  malloc'ed memory not known to PyPy's GC at all.  If you guess there is some,
         consider using <u>jemalloc</u> as opposed to system malloc.

       • nursery - amount of memory allocated for nursery, fixed  at  startup,  controlled  via  an  environment
         variable

       • raw assembler allocated - amount of assembler memory that JIT feels responsible for

       • memory pressure, if asked for - amount of memory we think got allocated via external malloc (eg loading
         cert store in SSL contexts) that is kept alive by GC objects, but not accounted in the GC

   <b>GC</b> <b>Hooks</b>
       GC  hooks are user-defined functions which are called whenever a specific GC event occur, and can be used
       to monitor GC activity and pauses.  You can install the hooks by setting the following attributes:

       <b>gc.hooks.on_gc_minor</b>
              Called whenever a minor collection occurs. It corresponds to <b>gc-minor</b> sections inside <b>PYPYLOG</b>.

       <b>gc.hooks.on_gc_collect_step</b>
              Called  whenever  an  incremental  step  of  a  major  collection  occurs.   It   corresponds   to
              <b>gc-collect-step</b> sections inside <b>PYPYLOG</b>.

       <b>gc.hooks.on_gc_collect</b>
              Called  after  the last incremental step, when a major collection is fully done. It corresponds to
              <b>gc-collect-done</b> sections inside <b>PYPYLOG</b>.

       To uninstall a hook, simply set the corresponding attribute to <b>None</b>.  To install all hooks at  once,  you
       can  call  <b>gc.hooks.set(obj)</b>,  which will look for methods <b>on_gc_*</b> on <b>obj</b>.  To uninstall all the hooks at
       once, you can call <b>gc.hooks.reset()</b>.

       The functions called by the hooks receive a single <b>stats</b>  argument,  which  contains  various  statistics
       about the event.

       Note  that PyPy cannot call the hooks immediately after a GC event, but it has to wait until it reaches a
       point in which the interpreter is in a known state and calling user-defined code is harmless.   It  might
       happen  that  multiple  events  occur before the hook is invoked: in this case, you can inspect the value
       <b>stats.count</b> to know how many times  the  event  occurred  since  the  last  time  the  hook  was  called.
       Similarly,  <b>stats.duration</b> contains the <b>total</b> time spent by the GC for this specific event since the last
       time the hook was called.

       On the other hand, all the other fields of the <b>stats</b> object are relative only to the <b>last</b>  event  of  the
       series.

       The attributes for <b>GcMinorStats</b> in the <b>on_gc_minor</b> hook are:

       <b>count</b>  The number of minor collections occurred since the last hook call.

       <b>duration</b>
              The total time spent inside minor collections since the last hook call, in seconds.

       <b>duration_min</b>
              The duration of the fastest minor collection since the last hook call.

       <b>duration_max</b>
                 The duration of the slowest minor collection since the last hook call.

              <b>total_memory_used</b>
                     The  amount  of  memory used at the end of the minor collection, in bytes. This include the
                     memory used in arenas (for GC-managed memory) and raw-malloced memory (e.g., the content of
                     numpy arrays).

       <b>pinned_objects</b>
              the number of pinned objects.

       The attributes for <b>GcCollectStepStats</b> in the <b>on_gc_collect_step</b> hook are:

       <b>count,</b> <b>duration,</b> <b>duration_min,</b> <b>duration_max</b>
              See above.

       <b>oldstate,</b> <b>newstate</b>
              Integers which indicate the state of the GC before and after the step.

       <b>major_is_done</b>
              Boolean which indicate whether this was the last step of the major collection

       The value of <b>oldstate</b> and <b>newstate</b> is one  of  these  constants,  defined  inside  <b>gc.GcCollectStepStats</b>:
       <b>STATE_SCANNING</b>,  <b>STATE_MARKING</b>, <b>STATE_SWEEPING</b>, <b>STATE_FINALIZING</b>, <b>STATE_USERDEL</b>.  It is possible to get a
       string representation of it by indexing the <b>GC_STATES</b> tuple.

       The attributes for <b>GcCollectStats</b> in the <b>on_gc_collect</b> hook are:

       <b>count</b>  See above.

       <b>num_major_collects</b>
              The total number of major collections which have been done since the start. Contrarily  to  <b>count</b>,
              this is an always-growing counter and it's not reset between invocations.

       <b>arenas_count_before,</b> <b>arenas_count_after</b>
              Number of arenas used before and after the major collection.

       <b>arenas_bytes</b>
              Total number of bytes used by GC-managed objects.

       <b>rawmalloc_bytes_before,</b> <b>rawmalloc_bytes_after</b>
              Total number of bytes used by raw-malloced objects, before and after the major collection.

       <b>pinned_objects</b>
              the number of pinned objects.

       Note  that  <b>GcCollectStats</b> does <b>not</b> have a <b>duration</b> field. This is because all the GC work is done inside
       <b>gc-collect-step</b>: <b>gc-collect-done</b> is used only to give additional stats, but doesn't do any actual work.

       Here is an example of GC hooks in use:

          import sys
          import gc

          class MyHooks(object):
              done = False

              def on_gc_minor(self, stats):
                  print 'gc-minor:        count = %02d, duration = %d' % (stats.count,
                                                                          stats.duration)

              def on_gc_collect_step(self, stats):
                  old = gc.GcCollectStepStats.GC_STATES[stats.oldstate]
                  new = gc.GcCollectStepStats.GC_STATES[stats.newstate]
                  print 'gc-collect-step: %s --&gt; %s' % (old, new)
                  print '                 count = %02d, duration = %d' % (stats.count,
                                                                          stats.duration)

              def on_gc_collect(self, stats):
                  print 'gc-collect-done: count = %02d' % stats.count
                  self.done = True

          hooks = MyHooks()
          gc.hooks.set(hooks)

          # simulate some GC activity
          lst = []
          while not hooks.done:
              lst = [lst, 1, 2, 3]

   <b>Environment</b> <b>variables</b>
       PyPy's default <b>incminimark</b> garbage collector is configurable through several environment variables:

       <b>PYPY_GC_NURSERY</b>
              The nursery size.  Defaults to 1/2 of  your  last-level  cache,  <b>4M</b>  if  unknown,  or  <b>4M</b>  if  the
              last-level cache is too small.  Small values (like 1 or 1KB) are useful for debugging.

       <b>PYPY_GC_NURSERY_DEBUG</b>
              If set to non-zero, will fill nursery with garbage, to help debugging.

       <b>PYPY_GC_INCREMENT_STEP</b>
              The  size  of  memory  marked during the marking step.  Default is size of nursery times 2. If you
              mark it too high your GC is not incremental at all.  The minimum is  set  to  size  that  survives
              minor collection times 1.5 so we reclaim anything all the time.

       <b>PYPY_GC_MAJOR_COLLECT</b>
              Major  collection memory factor.  Default is <b>1.82</b>, which means trigger a major collection when the
              memory consumed equals 1.82 times the memory  really  used  at  the  end  of  the  previous  major
              collection.

       <b>PYPY_GC_GROWTH</b>
              Major  collection threshold's max growth rate.  Default is <b>1.4</b>.  Useful to collect more often than
              normally on sudden memory growth, e.g. when there is a temporary peak in memory usage.

       <b>PYPY_GC_MAX</b>
              The max heap size.  If coming near this limit, it will first collect more  often,  then  raise  an
              RPython  MemoryError, and if that is not enough, crash the program with a fatal error.  Try values
              like <b>1.6GB</b>.

       <b>PYPY_GC_MAX_DELTA</b>
              The major collection threshold will never be set to more than <b>PYPY_GC_MAX_DELTA</b> the amount  really
              used  after  a collection.  Defaults to 1/8th of the total RAM size (which is constrained to be at
              most 2/3/4GB on 32-bit systems).  Try values like <b>200MB</b>.

       <b>PYPY_GC_MIN</b>
              Don't collect while the memory size is below this limit.  Useful to avoid spending all the time in
              the GC in very small programs.  Defaults to 8 times the nursery.

       <b>PYPY_GC_DEBUG</b>
              Enable extra checks around collections that are too slow for normal use.  Values are  <b>0</b>  (off),  <b>1</b>
              (on major collections) or <b>2</b> (also on minor collections).

       <b>PYPY_GC_MAX_PINNED</b>
              The  maximal  number  of  pinned  objects  at any point in time.  Defaults to a conservative value
              depending on nursery size and maximum object size inside the nursery.   Useful  for  debugging  by
              setting it to 0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/python3.1.html">python3</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       The PyPy Project

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, The PyPy Project

7.3                                               Feb 26, 2025                                          <u><a href="../man1/PYPY3.1.html">PYPY3</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>