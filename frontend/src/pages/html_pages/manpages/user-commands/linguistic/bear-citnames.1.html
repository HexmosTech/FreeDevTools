<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bear-citnames - deduce command semantic</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/bear">bear_3.1.5-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bear-citnames - deduce command semantic

</pre><h4><b>SYNOPSIS</b></h4><pre>
       bear citnames [<u>options</u>] --input &lt;file&gt; --output &lt;file&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The name citnames comes from to reverse the word “semantic”.

       Because  when you type a command, you know your intent.  The command execution is just a thing to achieve
       your goal.  This program takes the command which was executed, and try to find out what the intent was to
       run that command.  It deduces the semantic of the command.

       This is useful to generate a compilation database.  Citnames get a list of commands,  and  it  creates  a
       JSON compilation database.  (This is currently the only output of the tool.)

</pre><h4><b>OPTIONS</b></h4><pre>
       --version
              Print version number.

       --help Print help message.

       --verbose
              Enable verbose logging.

       --input <u>file</u>
              Specify  input  file.   (Default  file name provided.) The input is a command execution list, with
              some extra information.  The syntax is detailed in a separate section.

       --output <u>file</u>
              Specify output file.  (Default file name provided.) The output is  currently  a  JSON  compilation
              database.

       --append
              Use  previously generated output file and append the new entries to it.  This way you can run con‐
              tinuously during work, and it keeps the compilation database up to date.  File deletion and  addi‐
              tion  are both considered.  But build process change (compiler flags change) might cause duplicate
              entries.

       --run-checks
              Allow the program to verify file location checks on the current machine it runs.   (Default  value
              provided.   Run help to query it.) This is important if the execution list is not from the current
              host.

       --config <u>file</u>
              Specify a configuration file.  The configuration file captures how the output should be  formatted
              and which entries it shall contain.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       Citnames  exit  status is non-zero in case of IO problems, otherwise it’s zero.  The exit status is inde‐
       pendent of how many command it recognized or was it recognized at all.

</pre><h4><b>OBSERVABILITY</b></h4><pre>
       Any insight about the command recognition logic can be observed with --verbose flag on the  standard  er‐
       ror.  Otherwise, the command is silent.

</pre><h4><b>INPUT</b> <b>FILE</b></h4><pre>
       It’s  a JSON file, with the command execution history.  (Plus some metadata, that is useful for debugging
       the application which was produced it.) This file can be produced by the bear  intercept  command,  which
       records the process executions of a build.

       Read more about the syntax of the file in the <a href="../man1/bear-intercept.1.html">bear-intercept</a>(1) man page.

</pre><h4><b>OUTPUT</b> <b>FILE</b></h4><pre>
       Currently,  the  only output format is the JSON compilation database.  Read more about the syntax of that
       in the <a href="../man1/bear.1.html">bear</a>(1) man page.

</pre><h4><b>CONFIG</b> <b>FILE</b></h4><pre>
       The config file influences the command recognition (by the section “compilation”) and the  output  format
       (by the section “output”).

       The config file is optional.  The program will use default values, which can be dumped with the --verbose
       flags.

       Some parts of the file has overlap with the command line arguments.  If both present the command line ar‐
       gument overrides the config file values.

              {
                "compilation": {
                  "compilers_to_recognize": [
                    {
                      "executable": "/usr/bin/mpicc",
                      "flags_to_add": ["-I/opt/MPI/include"],
                      "flags_to_remove": ["-Wall"]
                    }
                  ],
                  "compilers_to_exclude": []
                },
                "output": {
                  "content": {
                    "include_only_existing_source": true,
                    "paths_to_include": [],
                    "paths_to_exclude": [],
                    "duplicate_filter_fields": "file_output"
                  },
                  "format": {
                    "command_as_array": true,
                    "drop_output_field": false
                  }
                }
              }

       <b>compilation.compilers_to_recognize</b>
              where  compiler  can  be specified, which are not yet recognized by default.  The executable is an
              absolute path to the compiler.  The flags_to_add is an optional attribute,  which  contains  flags
              which will append to the final output.  (It’s a good candidate to use this for adding OpenMPI com‐
              piler  wrapper  flags  from the mpicc --showme:compile output.) The flags_to_remove is an optional
              attribute, where the given flags will be removed for the final argument list.  (The flags  checked
              for  equality only, no regex match.  Flags with arguments are not good candidates to put here, be‐
              cause the removal logic is too simple for that.)

       <b>compilation.compilers_to_exclude</b>
              this is an optional list of executables (with absolute path) which needs to be  removed  from  the
              output.

       <b>output.content</b>
              The paths_to_include and paths_to_exclude are for filter out entries from these directories.  (Di‐
              rectory  names  can  be  absolute paths or relative to the current working directory if the --run-
              checks flag passed.) The include_only_existing_source allows or disables file check for  the  out‐
              put.   The  --run-checks flag overrides this config value.  The duplicate_filter_fields select the
              method how duplicate entries are detected in the output.  The possible values for this field  are:
              all, file and file_output.

       <b>output.format</b>
              The  command_as_array  controls which command field is emitted in the output.  True produces argu‐
              ments, false produces command field.  The drop_output_field will disable the output field from the
              output.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/bear.1.html">bear</a>(1), <a href="../man1/bear-intercept.1.html">bear-intercept</a>(1)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2012-2024 by László Nagy &lt;https://github.com/rizsotto/Bear&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       László Nagy.

Bear User Manuals                                 Jan 02, 2023                                  <u><a href="../man1/BEAR-CITNAMES.1.html">BEAR-CITNAMES</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>