<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gvpr - graph pattern scanning and processing language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/graphviz">graphviz_2.42.4-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gvpr - graph pattern scanning and processing language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>gvpr</b> [<b>-icnqV?</b>]  [ <b>-o</b> <u>outfile</u> ] [ <b>-a</b> <u>args</u> ] [ <u>'prog'</u> | <b>-f</b> <u>progfile</u> ] [ <u>files</u> ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>gvpr</b>  (previously  known as <b>gpr</b>) is a graph stream editor inspired by <b>awk</b>.  It copies input graphs to its
       output, possibly transforming their structure and attributes, creating new graphs, or printing  arbitrary
       information.   The  graph  model  is that provided by <u><a href="../man3/libcgraph.3.html">libcgraph</a></u>(3).  In particular, <b>gvpr</b> reads and writes
       graphs using the dot language.

       Basically, <b>gvpr</b> traverses each input graph, denoted by <b>$G</b>, visiting each node and edge, matching it  with
       the  predicate‐action  rules  supplied in the input program.  The rules are evaluated in order.  For each
       predicate evaluating to true, the corresponding action is performed.  During the traversal,  the  current
       node or edge being visited is denoted by <b>$</b>.

       For  each  input graph, there is a target subgraph, denoted by <b>$T</b>, initially empty and used to accumulate
       chosen entities, and an output graph, <b>$O</b>, used for final processing  and  then  written  to  output.   By
       default,  the  output  graph  is  the  target graph.  The output graph can be set in the program or, in a
       limited sense, on the command line.

</pre><h4><b>OPTIONS</b></h4><pre>
       The following options are supported:

       <b>-a</b> <u>args</u>
              The string <u>args</u> is split into whitespace‐separated tokens, with the individual tokens available as
              strings in the <b>gvpr</b> program as <b>ARGV[</b><u>0</u><b>],...,ARGV[ARGC-1]</b>.  Whitespace characters within  single  or
              double  quoted  substrings,  or preceded by a backslash, are ignored as separators.  In general, a
              backslash character turns off any special meaning of  the  following  character.   Note  that  the
              tokens derived from multiple <b>-a</b> flags are concatenated.

       <b>-c</b>     Use the source graph as the output graph.

       <b>-i</b>     Derive the node‐induced subgraph extension of the output graph in the context of its root graph.

       <b>-o</b> <u>outfile</u>
              Causes  the  output  stream  to be written to the specified file; by default, output is written to
              <b>stdout</b>.

       <b>-f</b> <u>progfile</u>
              Use the contents of the specified file as the  program  to  execute  on  the  input.  If  <u>progfile</u>
              contains  a  slash  character, the name is taken as the pathname of the file. Otherwise, <b>gvpr</b> will
              use the directories specified in the environment variable <b>GVPRPATH</b> to look for the file. If <b>-f</b>  is
              not given, <b>gvpr</b> will use the first non‐option argument as the program.

       <b>-q</b>     Turns off warning messages.

       <b>-n</b>     Turns off graph read-ahead. By default, the variable <b>$NG</b> is set to the next graph to be processed.
              This requires a read of the next graph before processing the current graph, which may block if the
              next  graph  is  only  generated  in  response  to some action pertaining to the processing of the
              current graph.

       <b>-V</b>     Causes the program to print version information and exit.

       <b>-?</b>     Causes the program to print usage information and exit.

</pre><h4><b>OPERANDS</b></h4><pre>
       The following operand is supported:

       <u>files</u>   Names of files containing 1 or more graphs in the dot language.  If no <b>-f</b> option  is  given,  the
               first name is removed from the list and used as the input program. If the list of files is empty,
               <b>stdin</b> will be used.

</pre><h4><b>PROGRAMS</b></h4><pre>
       A <b>gvpr</b> program consists of a list of predicate‐action clauses, having one of the forms:

              <b>BEGIN</b> <b>{</b> <u>action</u> <b>}</b>

              <b>BEG_G</b> <b>{</b> <u>action</u> <b>}</b>

              <b>N</b> <b>[</b> <u>predicate</u> <b>]</b> <b>{</b> <u>action</u> <b>}</b>

              <b>E</b> <b>[</b> <u>predicate</u> <b>]</b> <b>{</b> <u>action</u> <b>}</b>

              <b>END_G</b> <b>{</b> <u>action</u> <b>}</b>

              <b>END</b> <b>{</b> <u>action</u> <b>}</b>

       A  program  can contain at most one of each of the <b>BEGIN</b>, <b>END_G</b> and <b>END</b> clauses.  There can be any number
       of <b>BEG_G</b>, <b>N</b> and <b>E</b> statements, the first applied to graphs, the second  to  nodes,  the  third  to  edges.
       These  are  separated  into  blocks,  a  block  consisting of an optional <b>BEG_G</b> statement and all <b>N</b> and <b>E</b>
       statements up to the next <b>BEG_G</b> statement, if any.  The top‐level semantics of a <b>gvpr</b> program are:

              Evaluate the <b>BEGIN</b> clause, if any.
              For each input graph <u>G</u> {
                  For each block {
                      Set <u>G</u> as the current graph and current object.
                      Evaluate the <b>BEG_G</b> clause, if any.
                      For each node and edge in <u>G</u> {
                          Set the node or edge as the current object.
                          Evaluate the <b>N</b> or <b>E</b> clauses, as appropriate.
                      }
                  }
                  Set <u>G</u> as the current object.
                  Evaluate the <b>END_G</b> clause, if any.
              }
              Evaluate the <b>END</b> clause, if any.

       The actions of the <b>BEGIN</b>, <b>BEG_G</b>, <b>END_G</b> and <b>END</b> clauses are performed when the clauses are evaluated.  For
       <b>N</b> or <b>E</b> clauses, either the predicate or action may be omitted.  If there is no predicate with an  action,
       the  action  is performed on every node or edge, as appropriate.  If there is no action and the predicate
       evaluates to true, the associated node or edge is added to the target graph.

       The blocks are evaluated in the order in which they occur.  Within a block, the  <b>N</b>  clauses  (<b>E</b>  clauses,
       respectively)  are  evaluated  in the order in which the occur. Note, though, that within a block, <b>N</b> or <b>E</b>
       clauses may be interlaced, depending on the traversal order.

       Predicates and actions are sequences of statements in the C dialect supported  by  the  <u><a href="../man3/expr.3.html">expr</a></u>(3)  library.
       The  only  difference  between  predicates  and  actions  is  that  the  former must have a type that may
       interpreted as either true or false.  Here the usual C convention is followed, in which a non‐zero  value
       is  considered  true. This would include non‐empty strings and non‐empty references to nodes, edges, etc.
       However, if a string can be converted to an integer, this value is used.

       In addition to the usual C base types (<b>void</b>, <b>int</b>, <b>char</b>, <b>float</b>, <b>long</b>, <b>unsigned</b> and <b>double</b>), <b>gvpr</b>  provides
       <b>string</b>  as  a  synonym for <b>char*</b>, and the graph‐based types <b>node_t</b>, <b>edge_t</b>, <b>graph_t</b> and <b>obj_t</b>.  The <b>obj_t</b>
       type can be viewed as a supertype of the other 3 concrete types; the  correct  base  type  is  maintained
       dynamically.   Besides  these  base  types,  the  only other supported type expressions are (associative)
       arrays.

       Constants follow C syntax, but strings may be quoted with  either  <b>"..."</b>  or  <b>'...'</b>.   <b>gvpr</b>  accepts  C++
       comments  as  well as cpp‐type comments.  For the latter, if a line begins with a '#' character, the rest
       of the line is ignored.

       A statement can be a declaration of a function, a variable or an array, or an executable  statement.  For
       declarations, there is a single scope. Array declarations have the form:

               <u>type</u> <u>array</u> <b>[</b> <u>type0</u> <b>]</b>

       where   <u>type0</u>  is optional. If it is supplied, the parser will enforce that all array subscripts have the
       specified type. If it is not supplied, objects of all  types  can  be  used  as  subscripts.   As  in  C,
       variables  and  arrays must be declared. In particular, an undeclared variable will be interpreted as the
       name of an attribute of a node, edge or graph, depending on the context.

       Executable statements can be one of the following:
              <b>{</b> [ <u>statement</u> <u>...</u> ] <b>}</b>
              <u>expression</u>                                              // commonly <u>var</u> <b>=</b> <u>expression</u>
              <b>if(</b> <u>expression</u> <b>)</b> <u>statement</u> [ <b>else</b> <u>statement</u> ]
              <b>for(</b> <u>expression</u> <b>;</b> <u>expression</u> <b>;</b> <u>expression</u> <b>)</b> <u>statement</u>
              <b>for(</b> <u>array</u> <b>[</b> <u>var</u> <b>])</b> <u>statement</u>
              <b>forr(</b> <u>array</u> <b>[</b> <u>var</u> <b>])</b> <u>statement</u>
              <b>while(</b> <u>expression</u> <b>)</b> <u>statement</u>
              <b>switch(</b> <u>expression</u> <b>)</b> <u>case</u> <u>statements</u>
              <b>break</b> <b>[</b> <u>expression</u> <b>]</b>
              <b>continue</b> <b>[</b> <u>expression</u> <b>]</b>
              <b>return</b> <b>[</b> <u>expression</u> <b>]</b>
       Items in brackets are optional.

       In the second form of the <b>for</b> statement and the <b>forr</b> statement, the variable <u>var</u> is  set  to  each  value
       used  as  an index in the specified array and then the associated <u>statement</u> is evaluated. For numeric and
       string indices, the indices are returned in increasing (decreasing) numeric or  lexicographic  order  for
       <b>for</b> (<b>forr</b>, respectively). This can be used for sorting.

       Function definitions can only appear in the <b>BEGIN</b> clause.

       Expressions  include  the  usual  C expressions.  String comparisons using <b>==</b> and <b>!=</b> treat the right hand
       operand as a pattern for the purpose of regular expression matching.   Patterns  use  <u><a href="../man1/ksh.1.html">ksh</a></u>(1)  file  match
       pattern syntax.  (For simple string equality, use the <b>strcmp</b> function.

       <b>gvpr</b> will attempt to use an expression as a string or numeric value as appropriate. Both C-like casts and
       function templates will cause conversions to be performed, if possible.

       Expressions of graphical type (i.e., <b>graph_t,</b> <b>node_t,</b> <b>edge_t,</b> <b>obj_t</b>) may be followed by a field reference
       in  the  form of <b>.</b><u>name</u>. The resulting value is the value of the attribute named <u>name</u> of the given object.
       In addition, in certain contexts an undeclared, unmodified identifier is taken to be an  attribute  name.
       Specifically,  such  identifiers  denote attributes of the current node or edge, respectively, in <b>N</b> and <b>E</b>
       clauses, and the current graph in <b>BEG_G</b> and <b>END_G</b> clauses.

       As usual in the <u><a href="../man3/libcgraph.3.html">libcgraph</a></u>(3) model, attributes are string‐valued.  In  addition,  <b>gvpr</b>  supports  certain
       pseudo‐attributes  of graph objects, not necessarily string‐valued. These reflect intrinsic properties of
       the graph objects and cannot be set by the user.

       <b>head</b> : <b>node_t</b>
              the head of an edge.

       <b>tail</b> : <b>node_t</b>
              the tail of an edge.

       <b>name</b> : <b>string</b>
              the name of an edge, node or graph. The name of an edge has the  form  "<u>&lt;tail‐name&gt;&lt;edge‐op&gt;&lt;head‐</u>
              <u>name&gt;</u><b>[</b><u>&lt;key&gt;</u><b>]</b>",  where <u>&lt;edge‐op&gt;</u> is "<b>-&gt;</b>" or "<b>--</b>" depending on whether the graph is directed or not.
              The bracket part <b>[</b><u>&lt;key&gt;</u><b>]</b> only appears if the edge has a non‐trivial key.

       <b>indegree</b> : <b>int</b>
              the indegree of a node.

       <b>outdegree</b> : <b>int</b>
              the outdegree of a node.

       <b>degree</b> : <b>int</b>
              the degree of a node.

       <b>X</b> : <b>double</b>
              the X coordinate of a node. (Assumes the node has a <u>pos</u> attribute.)

       <b>Y</b> : <b>double</b>
              the Y coordinate of a node. (Assumes the node has a <u>pos</u> attribute.)

       <b>root</b> : <b>graph_t</b>
              the root graph of an object. The root of a root graph is itself.

       <b>parent</b> : <b>graph_t</b>
              the parent graph of a subgraph. The parent of a root graph is <b>NULL</b>

       <b>n_edges</b> : <b>int</b>
              the number of edges in the graph

       <b>n_nodes</b> : <b>int</b>
              the number of nodes in the graph

       <b>directed</b> : <b>int</b>
              true (non‐zero) if the graph is directed

       <b>strict</b> : <b>int</b>
              true (non‐zero) if the graph is strict

</pre><h4><b>BUILT‐IN</b> <b>FUNCTIONS</b></h4><pre>
       The following functions are built into <b>gvpr</b>. Those functions returning references to graph objects return
       <b>NULL</b> in case of failure.

   <b>Graphs</b> <b>and</b> <b>subgraph</b>
       <b>graph</b>(<u>s</u> : <b>string</b>, <u>t</u> : <b>string</b>) : <b>graph_t</b>
              creates a graph whose name is <u>s</u> and whose type is specified by the string <u>t</u>.  Ignoring  case,  the
              characters  <b>U,</b>  <b>D,</b>  <b>S,</b>  <b>N</b>  have  the  interpretation undirected, directed, strict, and non‐strict,
              respectively. If <u>t</u> is empty, a directed, non‐strict graph is generated.

       <b>subg</b>(<u>g</u> : <b>graph_t</b>, <u>s</u> : <b>string</b>) : <b>graph_t</b>
              creates a subgraph in graph <u>g</u> with name <u>s</u>. If the subgraph already exists, it is returned.

       <b>isSubg</b>(<u>g</u> : <b>graph_t</b>, <u>s</u> : <b>string</b>) : <b>graph_t</b>
              returns the subgraph in graph <u>g</u> with name <u>s</u>, if it exists, or <b>NULL</b> otherwise.

       <b>fstsubg</b>(<u>g</u> : <b>graph_t</b>) : <b>graph_t</b>
              returns the first subgraph in graph <u>g</u>, or <b>NULL</b> if none exists.

       <b>nxtsubg</b>(<u>sg</u> : <b>graph_t</b>) : <b>graph_t</b>
              returns the next subgraph after <u>sg</u>, or <b>NULL</b>.

       <b>isDirect</b>(<u>g</u> : <b>graph_t</b>) : <b>int</b>
              returns true if and only if <u>g</u> is directed.

       <b>isStrict</b>(<u>g</u> : <b>graph_t</b>) : <b>int</b>
              returns true if and only if <u>g</u> is strict.

       <b>nNodes</b>(<u>g</u> : <b>graph_t</b>) : <b>int</b>
              returns the number of nodes in <u>g</u>.

       <b>nEdges</b>(<u>g</u> : <b>graph_t</b>) : <b>int</b>
              returns the number of edges in <u>g</u>.

   <b>Nodes</b>
       <b>node</b>(<u>sg</u> : <b>graph_t</b>, <u>s</u> : <b>string</b>) : <b>node_t</b>
              creates a node in graph <u>g</u> of name <u>s</u>. If such a node already exists, it is returned.

       <b>subnode</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>node_t</b>
              inserts the node <u>n</u> into the subgraph <u>g</u>. Returns the node.

       <b>fstnode</b>(<u>g</u> : <b>graph_t</b>) : <b>node_t</b>
              returns the first node in graph <u>g</u>, or <b>NULL</b> if none exists.

       <b>nxtnode</b>(<u>n</u> : <b>node_t</b>) : <b>node_t</b>
              returns the next node after <u>n</u> in the root graph, or <b>NULL</b>.

       <b>nxtnode_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>node_t</b>
              returns the next node after <u>n</u> in <u>sg</u>, or <b>NULL</b>.

       <b>isNode</b>(<u>sg</u> : <b>graph_t</b>, <u>s</u> : <b>string</b>) : <b>node_t</b>
              looks for a node in (sub)graph <u>sg</u> of name <u>s</u>. If such a node exists,  it  is  returned.  Otherwise,
              <b>NULL</b> is returned.

       <b>isSubnode</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>int</b>
              returns non-zero if node <u>n</u> is in (sub)graph <u>sg</u>, or zero otherwise.

       <b>indegreeOf</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>int</b>
              returns the indegree of node <u>n</u> in (sub)graph <u>sg</u>.

       <b>outdegreeOf</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>int</b>
              returns the outdegree of node <u>n</u> in (sub)graph <u>sg</u>.

       <b>degreeOf</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>int</b>
              returns the degree of node <u>n</u> in (sub)graph <u>sg</u>.

   <b>Edges</b>
       <b>edge</b>(<u>t</u> : <b>node_t</b>, <u>h</u> : <b>node_t</b>, <u>s</u> : <b>string</b>) : <b>edge_t</b>
              creates  an  edge  with  tail  node  <u>t</u>,  head node <u>h</u> and name <u>s</u> in the root graph. If the graph is
              undirected, the distinction between head and tail nodes is unimportant.  If such an  edge  already
              exists, it is returned.

       <b>edge_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>t</u> : <b>node_t</b>, <u>h</u> : <b>node_t</b>, <u>s</u> : <b>string</b>) : <b>edge_t</b>
              creates an edge with tail node <u>t</u>, head node <u>h</u> and name <u>s</u> in (sub)graph <u>sg</u> (and all parent graphs).
              If  the  graph is undirected, the distinction between head and tail nodes is unimportant.  If such
              an edge already exists, it is returned.

       <b>subedge</b>(<u>g</u> : <b>graph_t</b>, <u>e</u> : <b>edge_t</b>) : <b>edge_t</b>
              inserts the edge <u>e</u> into the subgraph <u>g</u>. Returns the edge.

       <b>isEdge</b>(<u>t</u> : <b>node_t</b>, <u>h</u> : <b>node_t</b>, <u>s</u> : <b>string</b>) : <b>edge_t</b>
              looks for an edge with tail node <u>t</u>, head node <u>h</u> and name  <u>s</u>.  If  the  graph  is  undirected,  the
              distinction  between  head and tail nodes is unimportant.  If such an edge exists, it is returned.
              Otherwise, <b>NULL</b> is returned.

       <b>isEdge_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>t</u> : <b>node_t</b>, <u>h</u> : <b>node_t</b>, <u>s</u> : <b>string</b>) : <b>edge_t</b>
              looks for an edge with tail node <u>t</u>, head node <u>h</u> and name <u>s</u> in  (sub)graph  <u>sg</u>.  If  the  graph  is
              undirected,  the  distinction between head and tail nodes is unimportant.  If such an edge exists,
              it is returned. Otherwise, <b>NULL</b> is returned.

       <b>isSubedge</b>(<u>g</u> : <b>graph_t</b>, <u>e</u> : <b>edge_t</b>) : <b>int</b>
              returns non-zero if edge <u>e</u> is in (sub)graph <u>sg</u>, or zero otherwise.

       <b>fstout</b>(<u>n</u> : <b>node_t</b>) : <b>edge_t</b>
              returns the first outedge of node <u>n</u> in the root graph.

       <b>fstout_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>edge_t</b>
              returns the first outedge of node <u>n</u> in (sub)graph <u>sg</u>.

       <b>nxtout</b>(<u>e</u> : <b>edge_t</b>) : <b>edge_t</b>
              returns the next outedge after <u>e</u> in the root graph.

       <b>nxtout_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>e</u> : <b>edge_t</b>) : <b>edge_t</b>
              returns the next outedge after <u>e</u> in graph <u>sg</u>.

       <b>fstin</b>(<u>n</u> : <b>node_t</b>) : <b>edge_t</b>
              returns the first inedge of node <u>n</u> in the root graph.

       <b>fstin_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>edge_t</b>
              returns the first inedge of node <u>n</u> in graph <u>sg</u>.

       <b>nxtin</b>(<u>e</u> : <b>edge_t</b>) : <b>edge_t</b>
              returns the next inedge after <u>e</u> in the root graph.

       <b>nxtin_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>e</u> : <b>edge_t</b>) : <b>edge_t</b>
              returns the next inedge after <u>e</u> in graph <u>sg</u>.

       <b>fstedge</b>(<u>n</u> : <b>node_t</b>) : <b>edge_t</b>
              returns the first edge of node <u>n</u> in the root graph.

       <b>fstedge_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>edge_t</b>
              returns the first edge of node <u>n</u> in graph <u>sg</u>.

       <b>nxtedge</b>(<u>e</u> : <b>edge_t</b>, <b>node_t</b>) : <b>edge_t</b>
              returns the next edge after <u>e</u> in the root graph.

       <b>nxtedge_sg</b>(<u>sg</u> : <b>graph_t</b>, <u>e</u> : <b>edge_t</b>, <b>node_t</b>) : <b>edge_t</b>
              returns the next edge after <u>e</u> in the graph <u>sg</u>.

       <b>opp</b>(<u>e</u> : <b>edge_t</b>, <b>node_t</b>) : <b>node_t</b>
              returns the node on the edge <u>e</u> not equal to <u>n</u>.  Returns NULL if <u>n</u> is not a node of <u>e</u>.  This can be
              useful when using <b>fstedge</b> and <b>nxtedge</b> to enumerate the neighbors of <u>n</u>.

   <b>Graph</b> <b>I/O</b>
       <b>write</b>(<u>g</u> : <b>graph_t</b>) : <b>void</b>
              prints <u>g</u> in dot format onto the output stream.

       <b>writeG</b>(<u>g</u> : <b>graph_t</b>, <u>fname</u> : <b>string</b>) : <b>void</b>
              prints <u>g</u> in dot format into the file <u>fname</u>.

       <b>fwriteG</b>(<u>g</u> : <b>graph_t</b>, <u>fd</u> : <b>int</b>) : <b>void</b>
              prints <u>g</u> in dot format onto the open stream denoted by the integer <u>fd</u>.

       <b>readG</b>(<u>fname</u> : <b>string</b>) : <b>graph_t</b>
              returns a graph read from the file <u>fname</u>. The graph should be in dot format. If no  graph  can  be
              read, <b>NULL</b> is returned.

       <b>freadG</b>(<u>fd</u> : <b>int</b>) : <b>graph_t</b>
              returns the next graph read from the open stream <u>fd</u>.  Returns <b>NULL</b> at end of file.

   <b>Graph</b> <b>miscellany</b>
       <b>delete</b>(<u>g</u> : <b>graph_t</b>, <u>x</u> : <b>obj_t</b>) : <b>void</b>
              deletes  object  <u>x</u>  from graph <u>g</u>.  If <u>g</u> is <b>NULL</b>, the function uses the root graph of <u>x</u>.  If <u>x</u> is a
              graph or subgraph, it is closed unless <u>x</u> is locked.

       <b>isIn</b>(<u>g</u> : <b>graph_t</b>, <u>x</u> : <b>obj_t</b>) : <b>int</b>
              returns true if <u>x</u> is in subgraph <u>g</u>.

       <b>cloneG</b>(<u>g</u> : <b>graph_t</b>, <u>s</u> : <b>string</b>) : <b>graph_t</b>
              creates a clone of graph <u>g</u> with name of <u>s</u>.  If <u>s</u> is "", the created graph has the same name as <u>g</u>.

       <b>clone</b>(<u>g</u> : <b>graph_t</b>, <u>x</u> : <b>obj_t</b>) : <b>obj_t</b>
              creates a clone of object <u>x</u> in graph <u>g</u>.  In particular, the new object  has  the  same  name/value
              attributes  and  structure  as  the  original object.  If an object with the same key as <u>x</u> already
              exists, its attributes are overlaid by those of <u>x</u> and the object  is  returned.   If  an  edge  is
              cloned,  both  endpoints  are  implicitly  cloned.   If  a  graph  is cloned, all nodes, edges and
              subgraphs are implicitly cloned.  If <u>x</u> is a graph, <u>g</u> may be <b>NULL</b>, in which case the cloned  object
              will be a new root graph. In this case, the call is equivalent to <b>cloneG(</b><u>x</u><b>,"")</b>.

       <b>copy</b>(<u>g</u> : <b>graph_t</b>, <u>x</u> : <b>obj_t</b>) : <b>obj_t</b>
              creates  a copy of object <u>x</u> in graph <u>g</u>, where the new object has the same name/value attributes as
              the original object.  If an object with the same key as  <u>x</u>  already  exists,  its  attributes  are
              overlaid  by  those  of <u>x</u> and the object is returned.  Note that this is a shallow copy. If <u>x</u> is a
              graph, none of its nodes, edges or subgraphs are copied into the new graph. If <u>x</u> is an  edge,  the
              endpoints  are  created if necessary, but they are not cloned.  If <u>x</u> is a graph, <u>g</u> may be <b>NULL</b>, in
              which case the cloned object will be a new root graph.

       <b>copyA</b>(<u>src</u> : <b>obj_t</b>, <u>tgt</u> : <b>obj_t</b>) : <b>int</b>
              copies the attributes of object <u>src</u> to object  <u>tgt</u>,  overwriting  any  attribute  values  <u>tgt</u>  may
              initially have.

       <b>induce</b>(<u>g</u> : <b>graph_t</b>) : <b>void</b>
              extends <u>g</u> to its node‐induced subgraph extension in its root graph.

       <b>hasAttr</b>(<u>src</u> : <b>obj_t</b>, <u>name</u> : <b>string</b>) : <b>int</b>
              returns non-zero if object <u>src</u> has an attribute whose name is <u>name</u>. It returns 0 otherwise.

       <b>isAttr</b>(<u>g</u> : <b>graph_t</b>, <u>kind</u> : <b>string</b>, <u>name</u> : <b>string</b>) : <b>int</b>
              returns  non-zero  if  an  attribute <u>name</u> has been defined in <u>g</u> for objects of the given <u>kind</u>. For
              nodes, edges, and graphs, <u>kind</u> should be "N", "E", and "G", respectively.  It returns 0 otherwise.

       <b>aget</b>(<u>src</u> : <b>obj_t</b>, <u>name</u> : <b>string</b>) : <b>string</b>
              returns the value of attribute <u>name</u> in object <u>src</u>. This  is  useful  for  those  cases  when  <u>name</u>
              conflicts  with  one  of  the  keywords  such  as "head" or "root".  If the attribute has not been
              declared in the graph, the function will initialize it with a default value of "". To avoid  this,
              one should use the <b>hasAttr</b> or <b>isAttr</b> function to check that the attribute exists.

       <b>aset</b>(<u>src</u> : <b>obj_t</b>, <u>name</u> : <b>string</b>, <u>value</u> : <b>string</b>) : <b>int</b>
              sets  the  value  of  attribute  <u>name</u>  in  object <u>src</u> to <u>value</u>.  Returns 0 on success, non‐zero on
              failure. See <b>aget</b> above.

       <b>getDflt</b>(<u>g</u> : <b>graph_t</b>, <u>kind</u> : <b>string</b>, <u>name</u> : <b>string</b>) : <b>string</b>
              returns the default value of attribute <u>name</u> in objects in <u>g</u> of the given <u>kind</u>. For  nodes,  edges,
              and  graphs,  <u>kind</u>  should  be  "N",  "E",  and  "G", respectively.  If the attribute has not been
              declared in the graph, the function will initialize it with a default value of "". To avoid  this,
              one should use the <b>isAttr</b> function to check that the attribute exists.

       <b>setDflt</b>(<u>g</u> : <b>graph_t</b>, <u>kind</u> : <b>string</b>, <u>name</u> : <b>string</b>, <u>value</u> : <b>string</b>) : <b>int</b>
              sets  the  default  value of attribute <u>name</u> to <u>value</u> in objects in <u>g</u> of the given <u>kind</u>. For nodes,
              edges, and graphs, <u>kind</u> should be "N", "E", and "G", respectively.  Returns 0 on success, non‐zero
              on failure. See <b>getDflt</b> above.

       <b>fstAttr</b>(<u>g</u> : <b>graph_t</b>, <u>kind</u> : <b>string</b>) : <b>string</b>
              returns the name of the first attribute of objects in <u>g</u> of the given <u>kind</u>. For nodes,  edges,  and
              graphs, <u>kind</u> should be "N", "E", and "G", respectively.  If there are no attributes, the string ""
              is returned.

       <b>nxtAttr</b>(<u>g</u> : <b>graph_t</b>, <u>kind</u> : <b>string</b>, <u>name</u> : <b>string</b>) : <b>string</b>
              returns the name of the next attribute of objects in <u>g</u> of the given <u>kind</u> after the attribute <u>name</u>.
              The argument <u>name</u> must be the name of an existing attribute; it will typically be the return value
              of an previous call to <b>fstAttr</b> or <b>nxtAttr</b>.  For nodes, edges, and graphs, <u>kind</u> should be "N", "E",
              and "G", respectively.  If there are no attributes left, the string "" is returned.

       <b>compOf</b>(<u>g</u> : <b>graph_t</b>, <u>n</u> : <b>node_t</b>) : <b>graph_t</b>
              returns the connected component of the graph <u>g</u> containing node <u>n</u>, as a subgraph of <u>g</u>. The subgraph
              only  contains the nodes. One can use <u>induce</u> to add the edges. The function fails and returns <b>NULL</b>
              if <u>n</u> is not in <u>g</u>. Connectivity is based on the underlying undirected graph of <u>g</u>.

       <b>kindOf</b>(<u>obj</u> : <b>obj_t</b>) : <b>string</b>
              returns an indication of the type of <u>obj</u>.  For nodes, edges, and graphs, it returns "N", "E",  and
              "G", respectively.

       <b>lock</b>(<u>g</u> : <b>graph_t</b>, <u>v</u> : <b>int</b>) : <b>int</b>
              implements  graph  locking  on root graphs. If the integer <u>v</u> is positive, the graph is set so that
              future calls to <b>delete</b> have no immediate effect.  If <u>v</u> is zero, the graph is  unlocked.  If  there
              has  been  a call to delete the graph while it was locked, the graph is closed.  If <u>v</u> is negative,
              nothing is done.  In all cases, the previous lock value is returned.

   <b>Strings</b>
       <b>sprintf</b>(<u>fmt</u> : <b>string</b>, <u>...</u>) : <b>string</b>
              returns the string resulting from formatting the values of the  expressions  occurring  after  <u>fmt</u>
              according to the <u><a href="../man3/printf.3.html">printf</a></u>(3) format <u>fmt</u>

       <b>gsub</b>(<u>str</u> : <b>string</b>, <u>pat</u> : <b>string</b>) : <b>string</b>

       <b>gsub</b>(<u>str</u> : <b>string</b>, <u>pat</u> : <b>string</b>, <u>repl</u> : <b>string</b>) : <b>string</b>
              returns <u>str</u> with all substrings matching <u>pat</u> deleted or replaced by <u>repl</u>, respectively.

       <b>sub</b>(<u>str</u> : <b>string</b>, <u>pat</u> : <b>string</b>) : <b>string</b>

       <b>sub</b>(<u>str</u> : <b>string</b>, <u>pat</u> : <b>string</b>, <u>repl</u> : <b>string</b>) : <b>string</b>
              returns  <u>str</u>  with  the leftmost substring matching <u>pat</u> deleted or replaced by <u>repl</u>, respectively.
              The characters '^' and '$' may be used at the beginning and end, respectively, of  <u>pat</u>  to  anchor
              the pattern to the beginning or end of <u>str</u>.

       <b>substr</b>(<u>str</u> : <b>string</b>, <u>idx</u> : <b>int</b>) : <b>string</b>

       <b>substr</b>(<u>str</u> : <b>string</b>, <u>idx</u> : <b>int</b>, <u>len</u> : <b>int</b>) : <b>string</b>
              returns  the  substring of <u>str</u> starting at position <u>idx</u> to the end of the string or of length <u>len</u>,
              respectively.  Indexing starts at 0. If <u>idx</u> is negative or <u>idx</u> is greater than the length of  <u>str</u>,
              a  fatal  error  occurs. Similarly, in the second case, if <u>len</u> is negative or <u>idx</u> + <u>len</u> is greater
              than the length of <u>str</u>, a fatal error occurs.

       <b>strcmp</b>(<u>s1</u> : <b>string</b>, <u>s2</u> : <b>string</b>) : <b>int</b>
              provides the standard C function <u><a href="../man3/strcmp.3.html">strcmp</a></u>(3).

       <b>length</b>(<u>s</u> : <b>string</b>) : <b>int</b>
              returns the length of string <u>s</u>.

       <b>index</b>(<u>s</u> : <b>string</b>, <u>t</u> : <b>string</b>) : <b>int</b>

       <b>rindex</b>(<u>s</u> : <b>string</b>, <u>t</u> : <b>string</b>) : <b>int</b>
              returns the index of the character in string <u>s</u> where the leftmost (rightmost) copy of string <u>t</u> can
              be found, or -1 if <u>t</u> is not a substring of <u>s</u>.

       <b>match</b>(<u>s</u> : <b>string</b>, <u>p</u> : <b>string</b>) : <b>int</b>
              returns the index of the character in string <u>s</u> where the leftmost match of pattern <u>p</u> can be found,
              or -1 if no substring of <u>s</u> matches <u>p</u>.

       <b>toupper</b>(<u>s</u> : <b>string</b>) : <b>string</b>
              returns a version of <u>s</u> with the alphabetic characters converted to upper-case.

       <b>tolower</b>(<u>s</u> : <b>string</b>) : <b>string</b>
              returns a version of <u>s</u> with the alphabetic characters converted to lower-case.

       <b>canon</b>(<u>s</u> : <b>string</b>) : <b>string</b>
              returns a version of <u>s</u> appropriate to be used as an identifier in a dot file.

       <b>html</b>(<u>g</u> : <b>graph_t</b>, <u>s</u> : <b>string</b>) : <b>string</b>
              returns a ``magic'' version  of <u>s</u> as an HTML string. This will typically  be  used  to  attach  an
              HTML-like  label  to  a  graph object. Note that the returned string lives in <u>g</u>. In particular, it
              will be freed when <u>g</u> is closed, and to act as an HTML string, it has to be used with an object  of
              <u>g</u>. In addition, note that the angle bracket quotes should not be part of <u>s</u>. These will be added if
              <u>g</u> is written in concrete DOT format.

       <b>ishtml</b>(<u>s</u> : <b>string</b>) : <b>int</b>
              returns non-zero if and only if <u>s</u> is an HTML string.

       <b>xOf</b>(<u>s</u> : <b>string</b>) : <b>string</b>
              returns the string "<u>x</u>" if <u>s</u> has the form "<u>x</u>,<u>y</u>", where both <u>x</u> and <u>y</u> are numeric.

       <b>yOf</b>(<u>s</u> : <b>string</b>) : <b>string</b>
              returns the string "<u>y</u>" if <u>s</u> has the form "<u>x</u>,<u>y</u>", where both <u>x</u> and <u>y</u> are numeric.

       <b>llOf</b>(<u>s</u> : <b>string</b>) : <b>string</b>
              returns  the string "<u>llx</u>,<u>lly</u>" if <u>s</u> has the form "<u>llx</u>,<u>lly</u>,<u>urx</u>,<u>ury</u>", where all of <u>llx</u>, <u>lly</u>, <u>urx</u>, and
              <u>ury</u> are numeric.

       <b>urOf(</b><u>s</u><b>)</b>
              <b>urOf</b>(<u>s</u> : <b>string</b>) : <b>string</b> returns the string "<u>urx</u>,<u>ury</u>" if <u>s</u> has the form "<u>llx</u>,<u>lly</u>,<u>urx</u>,<u>ury</u>",  where
              all of <u>llx</u>, <u>lly</u>, <u>urx</u>, and <u>ury</u> are numeric.

       <b>sscanf</b>(<u>s</u> : <b>string</b>, <u>fmt</u> : <b>string</b>, <u>...</u>) : <b>int</b>
              scans  the  string  <u>s</u>,  extracting  values  according to the <u><a href="../man3/sscanf.3.html">sscanf</a></u>(3) format <u>fmt</u>.  The values are
              stored in the addresses following <u>fmt</u>, addresses having the form <b>&amp;</b><u>v</u>,  where  <u>v</u>  is  some  declared
              variable of the correct type.  Returns the number of items successfully scanned.

       <b>split</b>(<u>s</u> : <b>string</b>, <u>arr</u> : <b>array</b>, <u>seps</u> : <b>string</b>) : <b>int</b>

       <b>split</b>(<u>s</u> : <b>string</b>, <u>arr</u> : <b>array</b>) : <b>int</b>

       <b>tokens</b>(<u>s</u> : <b>string</b>, <u>arr</u> : <b>array</b>, <u>seps</u> : <b>string</b>) : <b>int</b>

       <b>tokens</b>(<u>s</u> : <b>string</b>, <u>arr</u> : <b>array</b>) : <b>int</b>
              The  <b>split</b>  function  breaks the string <u>s</u> into fields, while the <b>tokens</b> function breaks the string
              into tokens.  A field consists of all non-separator characters between two separator characters or
              the beginning or end of the string. Thus, a field may be the empty string. A token is  a  maximal,
              non-empty  substring  not  containing  a  separator character.  The separator characters are those
              given in the <u>seps</u> argument.  If <u>seps</u> is not provided, the default value is " \t\n".  The functions
              return the number of fields or tokens.

              The fields and tokens are stored in the argument array. The array must be <b>string</b>-valued  and  have
              <b>int</b>  as its index type. The entries are indexed by consecutive integers, starting at 0. Any values
              already stored in the array will be either overwritten, or still be  present  after  the  function
              returns.

   <b>I/O</b>
       <b>print</b>(<u>...</u>) : <b>void</b>
              <b>print(</b>  <u>expr</u><b>,</b>  <u>...</u> <b>)</b> prints a string representation of each argument in turn onto <b>stdout</b>, followed
              by a newline.

       <b>printf</b>(<u>fmt</u> : <b>string</b>, <u>...</u>) : <b>int</b>

       <b>printf</b>(<u>fd</u> : <b>int</b>, <u>fmt</u> : <b>string</b>, <u>...</u>) : <b>int</b>
              prints the string resulting from formatting the values of the expressions following <u>fmt</u>  according
              to  the  <u><a href="../man3/printf.3.html">printf</a></u>(3)  format  <u>fmt</u>.   Returns 0 on success.  By default, it prints on <b>stdout</b>.  If the
              optional integer <u>fd</u> is given, output is written on the open stream associated with <u>fd</u>.

       <b>scanf</b>(<u>fmt</u> : <b>string</b>, <u>...</u>) : <b>int</b>

       <b>scanf</b>(<u>fd</u> : <b>int</b>, <u>fmt</u> : <b>string</b>, <u>...</u>) : <b>int</b>
              scans in values from an input stream according to the <u><a href="../man3/scanf.3.html">scanf</a></u>(3) format <u>fmt</u>.  The values are  stored
              in the addresses following <u>fmt</u>, addresses having the form <b>&amp;</b><u>v</u>, where <u>v</u> is some declared variable of
              the correct type.  By default, it reads from <b>stdin</b>.  If the optional integer <u>fd</u> is given, input is
              read from the open stream associated with <u>fd</u>.  Returns the number of items successfully scanned.

       <b>openF</b>(<u>s</u> : <b>string</b>, <u>t</u> : <b>string</b>) : <b>int</b>
              opens  the  file  <u>s</u>  as an I/O stream. The string argument <u>t</u> specifies how the file is opened. The
              arguments are the same as for the C function <u><a href="../man3/fopen.3.html">fopen</a></u>(3).  It returns an integer denoting the stream,
              or -1 on error.

              As usual, streams 0, 1 and 2 are already open as <b>stdin</b>, <b>stdout</b>, and  <b>stderr</b>,  respectively.  Since
              <b>gvpr</b> may use <b>stdin</b> to read the input graphs, the user should avoid using this stream.

       <b>closeF</b>(<u>fd</u> : <b>int</b>) : <b>int</b>
              closes  the open stream denoted by the integer <u>fd</u>.  Streams  0, 1 and 2 cannot be closed.  Returns
              0 on success.

       <b>readL</b>(<u>fd</u> : <b>int</b>) : <b>string</b>
              returns the next line read from the input stream <u>fd</u>. It returns the empty  string  ""  on  end  of
              file. Note that the newline character is left in the returned string.

   <b>Math</b>
       <b>exp</b>(<u>d</u> : <b>double</b>) : <b>double</b>
              returns e to the <u>d</u>th power.

       <b>log</b>(<u>d</u> : <b>double</b>) : <b>double</b>
              returns the natural log of <u>d</u>.

       <b>sqrt</b>(<u>d</u> : <b>double</b>) : <b>double</b>
              returns the square root of the double <u>d</u>.

       <b>pow</b>(<u>d</u> : <b>double</b>, <u>x</u> : <b>double</b>) : <b>double</b>
              returns <u>d</u> raised to the <u>x</u>th power.

       <b>cos</b>(<u>d</u> : <b>double</b>) : <b>double</b>
              returns the cosine of <u>d</u>.

       <b>sin</b>(<u>d</u> : <b>double</b>) : <b>double</b>
              returns the sine of <u>d</u>.

       <b>atan2</b>(<u>y</u> : <b>double</b>, <u>x</u> : <b>double</b>) : <b>double</b>
              returns the arctangent of <u>y/x</u> in the range -pi to pi.

       <b>MIN</b>(<u>y</u> : <b>double</b>, <u>x</u> : <b>double</b>) : <b>double</b>
              returns the minimum of <u>y</u> and <u>x</u>.

       <b>MAX</b>(<u>y</u> : <b>double</b>, <u>x</u> : <b>double</b>) : <b>double</b>
              returns the maximum of <u>y</u> and <u>x</u>.

   <b>Associative</b> <b>Arrays</b>
       <b>#</b> <u>arr</u> : <b>int</b>
              returns the number of elements in the array <u>arr</u>.

       <u>idx</u> <b>in</b> <u>arr</u> : <b>int</b>
              returns 1 if a value has been set for index <u>idx</u> in the array <u>arr</u>.  It returns 0 otherwise.

       <b>unset</b>(<u>v</u> : <b>array</b>, <u>idx</u>) : <b>int</b>
              removes the item indexed by <u>idx</u>. It returns 1 if the item existed, 0 otherwise.

       <b>unset</b>(<u>v</u> : <b>array</b>) : <b>void</b>
              re-initializes the array.

   <b>Miscellaneous</b>
       <b>exit</b>(<u>v</u> : <b>int</b>) : <b>void</b>
              causes <b>gvpr</b> to exit with the exit code <u>v</u>.

       <b>system</b>(<u>cmd</u> : <b>string</b>) : <b>int</b>
              provides  the standard C function <u><a href="../man3/system.3.html">system</a></u>(3).  It executes <u>cmd</u> in the user's shell environment, and
              returns the exit status of the shell.

       <b>rand</b>() : <b>double</b>
              returns a pseudo‐random double between 0 and 1.

       <b>srand</b>() : <b>int</b>

       <b>srand</b>(<u>v</u> : <b>int</b>) : <b>int</b>
              sets a seed for the random number generator. The optional  argument  gives  the  seed;  if  it  is
              omitted,  the  current  time  is used. The previous seed value is returned. <b>srand</b> should be called
              before any calls to <b>rand</b>.

       <b>colorx</b>(<u>color</u> : <b>string</b>, <u>fmt</u> : <b>string</b>) : <b>string</b>
              translates a color from one format to another. The <u>color</u> argument should be a color in one of  the
              recognized string representations. The <u>fmt</u> value should be one of "RGB", "RGBA", "HSV", or "HSVA".
              An empty string is returned on error.

</pre><h4><b>BUILT‐IN</b> <b>VARIABLES</b></h4><pre>
       <b>gvpr</b>  provides  certain special, built‐in variables, whose values are set automatically by <b>gvpr</b> depending
       on the context. Except as noted, the user cannot modify their values.

       <b>$</b> : <b>obj_t</b>
              denotes the current object (node, edge, graph) depending on the context.  It is not  available  in
              <b>BEGIN</b> or <b>END</b> clauses.

       <b>$F</b> : <b>string</b>
              is the name of the current input file.

       <b>$G</b> : <b>graph_t</b>
              denotes the current graph being processed. It is not available in <b>BEGIN</b> or <b>END</b> clauses.

       <b>$NG</b> : <b>graph_t</b>
              denotes  the  next  graph to be processed. If <b>$NG</b> is NULL, the current graph <b>$G</b> is the last graph.
              Note that if the input comes from stdin, the last graph cannot be determined until the input  pipe
              is closed.  It is not available in <b>BEGIN</b> or <b>END</b> clauses, or if the <b>-n</b> flag is used.

       <b>$O</b> : <b>graph_t</b>
              denotes  the  output  graph.  Before graph traversal, it is initialized to the target graph. After
              traversal and any <b>END_G</b> actions, if it refers to a non‐empty graph, that graph is printed onto the
              output stream.  It is only valid in <b>N</b>, <b>E</b> and <b>END_G</b> clauses.  The output graph may be  set  by  the
              user.

       <b>$T</b> : <b>graph_t</b>
              denotes  the  current target graph. It is a subgraph of <b>$G</b> and is available only in <b>N</b>, <b>E</b> and <b>END_G</b>
              clauses.

       <b>$tgtname</b> : <b>string</b>
              denotes the name of the target graph.  By default, it is set to <b>"gvpr_result"</b>.  If  used  multiple
              times  during the execution of <b>gvpr</b>, the name will be appended with an integer.  This variable may
              be set by the user.

       <b>$tvroot</b> : <b>node_t</b>
              indicates the starting node for a (directed or undirected) depth‐first or breadth‐first  traversal
              of  the  graph  (cf.  <b>$tvtype</b>  below).  The default value is <b>NULL</b> for each input graph.  After the
              traversal at the given root, if the value of <b>$tvroot</b> has changed, a new traversal will begin  with
              the new value of <b>$tvroot</b>. Also, set <b>$tvnext</b> below.

       <b>$tvnext</b> : <b>node_t</b>
              indicates  the  next  starting  node  for  a (directed or undirected) depth‐first or breadth‐first
              traversal of the graph (cf. <b>$tvtype</b> below).  If a traversal finishes and the <b>$tvroot</b> has not  been
              reset  but  the  <b>$tvnext</b>  has been set but not used, this node will be used as the next choice for
              <b>$tvroot</b>.  The default value is <b>NULL</b> for each input graph.

       <b>$tvedge</b> : <b>edge_t</b>
              For BFS and DFS traversals, this is set to the edge used to arrive at the current node or edge. At
              the beginning of a traversal, or for other traversal types, the value is <b>NULL</b>.

       <b>$tvtype</b> : <b>tvtype_t</b>
              indicates how <b>gvpr</b> traverses a graph. It can only take one of the constant values with the  prefix
              "TV_" described below.  <b>TV_flat</b> is the default.

              In  the  underlying  graph  library  <u><a href="../man3/cgraph.3.html">cgraph</a></u>(3),  edges in undirected graphs are given an arbitrary
              direction. This is used for traversals, such as <b>TV_fwd</b>, requiring directed edges.

       <b>ARGC</b> : <b>int</b>
              denotes the number of arguments specified by the <b>-a</b> <u>args</u> command‐line argument.

       <b>ARGV</b> : <b>string</b> <b>array</b>
              denotes the array of arguments specified by the <b>-a</b> <u>args</u> command‐line argument. The <u>i</u>th argument is
              given by <b>ARGV[</b><u>i</u><b>]</b>.

</pre><h4><b>BUILT‐IN</b> <b>CONSTANTS</b></h4><pre>
       There are several symbolic constants defined by <b>gvpr</b>.

       <b>NULL</b> : <u>obj_t</u>
              a null object reference, equivalent to 0.

       <b>TV_flat</b> : <u>tvtype_t</u>
              a simple, flat traversal, with graph objects visited in seemingly arbitrary order.

       <b>TV_ne</b> : <u>tvtype_t</u>
              a traversal which first visits all of the nodes, then all of the edges.

       <b>TV_en</b> : <u>tvtype_t</u>
              a traversal which first visits all of the edges, then all of the nodes.

       <b>TV_dfs</b> : <u>tvtype_t</u>
       <b>TV_postdfs</b> : <u>tvtype_t</u>
       <b>TV_prepostdfs</b> : <u>tvtype_t</u>
              a traversal of the graph using a depth‐first search on the underlying undirected graph.  To do the
              traversal, <b>gvpr</b> will check the value of <b>$tvroot</b>. If this has the same value that it had previously
              (at the start, the previous value is initialized  to  <b>NULL</b>.),  <b>gvpr</b>  will  simply  look  for  some
              unvisited  node  and  traverse its connected component. On the other hand, if <b>$tvroot</b> has changed,
              its connected component will be toured, assuming it has not been previously visited or, if <b>$tvroot</b>
              is <b>NULL</b>, the traversal will stop. Note that using <b>TV_dfs</b> and <b>$tvroot</b>, it is possible to create  an
              infinite loop.

              By  default,  the  traversal  is  done  in pre-order. That is, a node is visited before all of its
              unvisited edges. For <b>TV_postdfs</b>, all of a node's unvisited edges are visited before the node.  For
              <b>TV_prepostdfs</b>, a node is visited twice, before and after all of its unvisited edges.

       <b>TV_fwd</b> : <u>tvtype_t</u>
       <b>TV_postfwd</b> : <u>tvtype_t</u>
       <b>TV_prepostfwd</b> : <u>tvtype_t</u>
              A traversal of the graph using a depth‐first search on the graph following only forward arcs.  The
              choice  of roots for the traversal is the same as described for <b>TV_dfs</b> above.  The different order
              of visitation specified by <b>TV_fwd</b>, <b>TV_postfwd</b> and <b>TV_prepostfwd</b> are the same as those specified by
              the analogous traversals <b>TV_dfs</b>, <b>TV_postdfs</b> and <b>TV_prepostdfs</b>.

       <b>TV_rev</b> : <u>tvtype_t</u>
       <b>TV_postrev</b> : <u>tvtype_t</u>
       <b>TV_prepostrev</b> : <u>tvtype_t</u>
              A traversal of the graph using a depth‐first search on the graph following only reverse arcs.  The
              choice of roots for the traversal is the same as described for <b>TV_dfs</b> above.  The different  order
              of visitation specified by <b>TV_rev</b>, <b>TV_postrev</b> and <b>TV_prepostrev</b> are the same as those specified by
              the analogous traversals <b>TV_dfs</b>, <b>TV_postdfs</b> and <b>TV_prepostdfs</b>.

       <b>TV_bfs</b> : <u>tvtype_t</u>
              A  traversal  of the graph using a breadth‐first search on the graph ignoring edge directions. See
              the item on <b>TV_dfs</b> above for the role of <b>$tvroot</b>.

</pre><h4><b>EXAMPLES</b></h4><pre>
              <b>gvpr</b> <b>-i</b> <b>'N[color=="blue"]'</b> <b>file.gv</b>

       Generate the node‐induced subgraph of all nodes with color blue.

              <b>gvpr</b> <b>-c</b> <b>'N[color=="blue"]{color</b> <b>=</b> <b>"red"}'</b> <b>file.gv</b>

       Make all blue nodes red.

              <b>BEGIN</b> <b>{</b> <b>int</b> <b>n,</b> <b>e;</b> <b>int</b> <b>tot_n</b> <b>=</b> <b>0;</b> <b>int</b> <b>tot_e</b> <b>=</b> <b>0;</b> <b>}</b>
              <b>BEG_G</b> <b>{</b>
                <b>n</b> <b>=</b> <b>nNodes($G);</b>
                <b>e</b> <b>=</b> <b>nEdges($G);</b>
                <b>printf</b> <b>("%d</b> <b>nodes</b> <b>%d</b> <b>edges</b> <b>%s\n",</b> <b>n,</b> <b>e,</b> <b>$G.name);</b>
                <b>tot_n</b> <b>+=</b> <b>n;</b>
                <b>tot_e</b> <b>+=</b> <b>e;</b>
              <b>}</b>
              <b>END</b> <b>{</b> <b>printf</b> <b>("%d</b> <b>nodes</b> <b>%d</b> <b>edges</b> <b>total\n",</b> <b>tot_n,</b> <b>tot_e)</b> <b>}</b>

       Version of the program <b>gc</b>.

              <b>gvpr</b> <b>-c</b> <b>""</b>

       Equivalent to <b>nop</b>.

              <b>BEG_G</b> <b>{</b> <b>graph_t</b> <b>g</b> <b>=</b> <b>graph</b> <b>("merge",</b> <b>"S");</b> <b>}</b>
              <b>E</b> <b>{</b>
                <b>node_t</b> <b>h</b> <b>=</b> <b>clone(g,$.head);</b>
                <b>node_t</b> <b>t</b> <b>=</b> <b>clone(g,$.tail);</b>
                <b>edge_t</b> <b>e</b> <b>=</b> <b>edge(t,h,"");</b>
                <b>e.weight</b> <b>=</b> <b>e.weight</b> <b>+</b> <b>1;</b>
              <b>}</b>
              <b>END_G</b> <b>{</b> <b>$O</b> <b>=</b> <b>g;</b> <b>}</b>

       Produces a strict version of the input graph, where the weight attribute of an edge  indicates  how  many
       edges from the input graph the edge represents.

              <b>BEGIN</b> <b>{node_t</b> <b>n;</b> <b>int</b> <b>deg[]}</b>
              <b>E{deg[head]++;</b> <b>deg[tail]++;</b> <b>}</b>
              <b>END_G</b> <b>{</b>
                <b>for</b> <b>(deg[n])</b> <b>{</b>
                  <b>printf</b> <b>("deg[%s]</b> <b>=</b> <b>%d\n",</b> <b>n.name,</b> <b>deg[n]);</b>
                <b>}</b>
              <b>}</b>

       Computes the degrees of nodes with edges.

              <b>BEGIN</b> <b>{</b>
                <b>int</b> <b>i,</b> <b>indent;</b>
                <b>int</b> <b>seen[string];</b>
                <b>void</b> <b>prInd</b> <b>(int</b> <b>cnt)</b> <b>{</b>
                  <b>for</b> <b>(i</b> <b>=</b> <b>0;</b> <b>i</b> <b>&lt;</b> <b>cnt;</b> <b>i++)</b> <b>printf</b> <b>("</b>  <b>");</b>
                <b>}</b>
              <b>}</b>
              <b>BEG_G</b> <b>{</b>

                 <b>$tvtype</b> <b>=</b> <b>TV_prepostfwd;</b>
                 <b>$tvroot</b> <b>=</b> <b>node($,ARGV[0]);</b>
              <b>}</b>
              <b>N</b> <b>{</b>
                <b>if</b> <b>(seen[$.name])</b> <b>indent--;</b>
                <b>else</b> <b>{</b>
                  <b>prInd(indent);</b>
                    <b>print</b> <b>($.name);</b>
                  <b>seen[$.name]</b> <b>=</b> <b>1;</b>
                  <b>indent++;</b>
                <b>}</b>
              <b>}</b>

       Prints  the  depth-first  traversal  of  the  graph,  starting with the node whose name is <b>ARGV[0]</b>, as an
       indented list.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       <b>GVPRPATH</b>
              Colon‐separated list of directories to be searched to find the file specified by  the  -f  option.
              <b>gvpr</b>  has  a  default  list  built  in.  If  <b>GVPRPATH</b> is not defined, the default list is used. If
              <b>GVPRPATH</b> starts with colon, the list is formed by appending  <b>GVPRPATH</b>  to  the  default  list.  If
              <b>GVPRPATH</b> ends with colon, the list is formed by appending the default list to <b>GVPRPATH</b>. Otherwise,
              <b>GVPRPATH</b> is used for the list.

       On Windows systems, replace ``colon'' with ``semicolon'' in the previous paragraph.

</pre><h4><b>BUGS</b> <b>AND</b> <b>WARNINGS</b></h4><pre>
       Scripts  should be careful deleting nodes during <b>N{}</b> and <b>E{}</b> blocks using BFS and DFS traversals as these
       rely on stacks and queues of nodes.

       When the program is given as a command line argument, the usual shell interpretation takes  place,  which
       may  affect  some  of  the special names in <b>gvpr</b>. To avoid this, it is best to wrap the program in single
       quotes.

       If string constants contain pattern metacharacters that you want to escape to avoid pattern matching, two
       backslashes will probably be necessary, as a single backslash will be lost when the string is  originally
       scanned. Usually, it is simpler to use <b>strcmp</b> to avoid pattern matching.

       As of 24 April 2008, <b>gvpr</b> switched to using a new, underlying graph library, which uses the simpler model
       that there is only one copy of a node, not one copy for each subgraph logically containing it. This means
       that  iterators  such  as <u>nxtnode</u> cannot traverse a subgraph using just a node argument. For this reason,
       subgraph traversal requires new functions ending in "_sg", which  also  take  a  subgraph  argument.  The
       versions without that suffix will always traverse the root graph.

       There  is a single global scope, except for formal function parameters, and even these can interfere with
       the type system. Also, the extent of all variables is the entire  life  of  the  program.   It  might  be
       preferable  for scope to reflect the natural nesting of the clauses, or for the program to at least reset
       locally declared variables.  For now, it is advisable to use distinct names for all variables.

       If a function ends with a complex statement, such as an IF statement, with each branch  doing  a  return,
       type checking may fail.  Functions should use a return at the end.

       The  expr library does not support string values of (char*)0.  This means we can't distinguish between ""
       and (char*)0 edge keys.  For the purposes of looking up  and  creating  edges,  we  translate  ""  to  be
       (char*)0,  since  this  latter  value  is necessary in order to look up any edge with a matching head and
       tail.

       Related to this, strings converted to integers act like char pointers, getting the value 0 or 1 depending
       on whether the string consists solely of zeroes or not. Thus, the ((int)"2") evaluates to 1.

       The language inherits the usual C problems such as dangling references and the confusion between '='  and
       '=='.

</pre><h4><b>AUTHOR</b></h4><pre>
       Emden R. Gansner &lt;<a href="mailto:erg@research.att.com">erg@research.att.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/awk.1.html">awk</a>(1), <a href="../man1/gc.1.html">gc</a>(1), <a href="../man1/dot.1.html">dot</a>(1), <a href="../man1/nop.1.html">nop</a>(1), <a href="../man3/expr.3.html">expr</a>(3), <a href="../man3/cgraph.3.html">cgraph</a>(3)

                                                 29 August 2013                                          <u><a href="../man1/GVPR.1.html">GVPR</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>