<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jgraph - filter for graph plotting to postscript</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/jgraph">jgraph_83-25_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jgraph - filter for graph plotting to postscript

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>jgraph</b> [-<u>p</u>] [-<u>P</u>] [-<u>L</u>] [-<u>comments</u>] [<u>filename</u> ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Jgraph</b>  takes the description of a graph or graphs and produces a postscript file on the standard output.
       <b>Jgraph</b> is ideal for plotting any mixture of scatter point graphs, line graphs,  and/or  bar  graphs,  and
       embedding the output into LaTeX, or any other text processing system which can read postscript.

       <b>Jgraph</b>  reads its input from the specified files.  If no files are specified, then it reads from standard
       input.

       The graph description language is simple enough to get nice looking graphs with a minimum of effort,  yet
       powerful  enough  to  give  the  user the flexibility to tailor the appearance of the graph to his or her
       individual preferences.  This includes plotting multiple graphs and laying them  out  separately  on  the
       page (or pages).

       As  an  example, if the user wanted to simply plot the points (2,3), (4,5), (1,6), the following would be
       enough of a specification file:

            newgraph
            newcurve pts 2 3 4 5 1 6

       Now, if the user wanted to spruce the graph up by adding labels to the axes, connecting the  points,  and
       titling the graph, then the input could change to:

            newgraph
            newcurve pts 2 3 4 5 1 6 linetype solid
            xaxis label : X axis
            yaxis label : Y axis
            title : This is an example graph

       If  the  user  instead  wanted  this to be a bar graph with different endpoints on the axes, he/she could
       simply change the input to:

            newgraph
            xaxis min 0 max 5 label : X axis
            yaxis min 0 max 6 label : Y axis
            newcurve pts 2 3 4 5 1 6 marktype xbar
            title : This is an example bar graph

       There are many more features of the description language, which are described below in the next  section.
       Features  which  are  not  embedded within the description language are: line and function interpolation,
       function plotting, and pie graphs.  The latter is impossible to do with the aid of <b>jgraph</b>,  however,  the
       others  can  be  effected  with <b>jgraph</b> mixed with awk or c.  See FUNCTION PLOTTING AND OTHER NON-INHERENT
       FEATURES below.

       Also below is a section HINTS AND EXAMPLE GRAPHS, which may give good ideas on how  to  use  <b>jgraph</b>  more
       effectively.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-P</b>     The <b>-P</b> option produces postscript which can be piped directly to <b>lpr,</b> which can be displayed in an
              Xwindows  environment  with  <b>gs</b> (ghostscript).  Without this option, the output should be embedded
              within <b>LaTeX</b> or a similar text processing system.

       <b>-L</b>     The <b>-L</b> option produces a landscape plot.

       <b>-p</b>     The <b>-p</b> option re-prints the input on  the  standard  output,  only  with  all  the  defaults  made
              explicit.   This is useful for letting the user do his/her own special formatting, as it shows the
              explicit values that the defaults assume, so that they can be manipulated.

       <b>-comments</b>
              This option makes jgraph put comments into the output postscript.  These make it  easier  for  the
              user to wade through the final postscript if necessary.

</pre><h4><b>THE</b> <b>DESCRIPTION</b> <b>LANGUAGE</b></h4><pre>
       The  description  language  is  essentially keywords followed by attributes.  All keywords and attributes
       except for string attributes are tokens -- non-white-space characters surrounded by white-space.  Special
       tokens are ``(*'', ``*)'',  ``include'',  ``:'',  and  ``shell'',  which  denote  comments,  include-file
       statements, string identifiers, and shell-include statements:

       <b>Comments</b>
              Comments  are  surrounded by the tokens ``(*'' ``*)'' as in Modula-2 (except that here, the tokens
              must be surrounded by white-space).  Comments may be nested.  If the comment runs to the end of  a
              file, the last ``*)'' may be omitted.

       <b>Include-file</b> <b>statements</b>
              The  token  following  an  ``include''  token  is  expected  to be a file name.  The result of the
              statement is to include the contents of the file at that point.  Include-file  statements  can  be
              nested within included files, and within shell includes.

       <b>Strings</b>
              In places where strings are required (as in graph and curve labels), they are denoted by the token
              ``:''.   The  second  character  after the ``:'' starts the string, and the next newline character
              terminates it.  Thus, the string ``Graph #1'' can be denoted as:

                   : Graph #1&lt;newline&gt;

              or

                   :&lt;newline&gt;
                   Graph #1&lt;newline&gt;

              One can get multiline strings by making a backslash the last character before the newline  on  all
              but  the  last  line.   Notice  that  in strings white-space is not ignored.  This way of denoting
              strings allows the user to embed leading and trailing spaces, as well as  the  null  string.   For
              example, the null string ``'' is represented by:

                   : &lt;newline&gt;

              Once  a  string  has been started, it may contain any character.  Specifically, it may contain the
              sequence ``(*'', ``shell'', or ``include'' without starting a comment or including a  file.   Each
              line  of a string must contain less than 1000 characters.  Otherwise string sizes are limited only
              by the size of memory.

       <b>Shell-include</b> <b>statements</b>
              Shell include statements are of the form ``shell'', ``:'', and then a string.  The result  of  the
              statement  is  that  the  string is executed (using popen, which passes the string to sh), and the
              standard  output  is  included  at  that  point.   Shell-includes  can  be  freely  nested  within
              include-files  and  other  shell-includes.  Shell commands may be more than one line, but must not
              exceed 1000 characters.  The shell statement is not (yet) available on VMS.

       <b>Notation</b>
              In the descriptions below:

              <b>tk</b> <b>{</b><u>integer</u><b>}</b>
                     means that token <b>tk</b> must be followed by an integer.

              <b>tk</b> <b>[</b><u>integer</u><b>]</b>
                     means that <b>tk</b> may be followed by an integer, but doesn't have to.  In most cases, if <b>tk</b>  is
                     not followed by an integer, then the command denoted by <b>tk</b> is ignored.

              <b>tk</b> <b>[{</b><u>integer</u><b>}</b> <b>{</b><u>integer</u><b>}]*</b>
                     means that <b>tk</b> must be followed by an even number of integers.

              Supported types other than integer are: <b>{</b><u>float</u><b>}</b> for floating point entries, <b>{</b><u>token</u><b>}</b> for any token,
              and <b>{</b><u>string</u><b>}</b> for a string as defined above.

       <b>TOP-LEVEL</b> <b>DESCRIPTION</b> <b>COMMANDS</b>

              <b>newgraph</b>
                     This  starts  editing  a new graph (see GRAPH EDITING COMMANDS).  Note that multiple graphs
                     may be drawn on the same page.

              <b>graph</b> <b>{</b><u>integer</u><b>}</b>
                     This edits the graph denoted by <b>{</b><u>integer</u><b>}.</b>  If the graph doesn't exist, then  this  command
                     creates it and starts editing it.  <b>Newgraph</b> is simply an abbreviation for <u>graph</u> <u>n</u> where n=0
                     if  this is the first graph, otherwise n=m+1, where m is the largest number of any graph so
                     far.

              <b>copygraph</b> <b>[</b><u>integer</u><b>]</b>
                     This creates a new graph, and copies all the attributes from the graph <b>[</b><u>integer</u><b>]'s</b> x and  y
                     axes, as well as its <u>x_translate</u> and <u>y_translate</u> values, the clipping, the legend defaults,
                     and  the  title defaults.   If the <b>[</b><u>integer</u><b>]</b> is omitted, then it copies its values from the
                     ``previous'' graph, which is defined to be the graph with the largest number less than  the
                     currrent  graph's  number.  If the current graph has the smallest number, then it will take
                     the last graph from the previous page of graphs.  If there is no  previous  page,  then  an
                     error  will  be flagged.  (copygraph does not copy the values of the <u>hash_at</u>, <u>mhash_at</u>, and
                     <u>hash_label</u> attributes).

              <b>newpage</b>
                     This command is for plotting graphs on multiple pages.  After a <b>newpage,</b>  the  graphs  that
                     the  user  enters  will  be plotted on a new page.  New graphs and strings will be numbered
                     starting with 0.  Essentially, <u>newpage</u> is the same as  appending  together  the  output  of
                     separate calls of jgraph on the text before the <u>newpage</u>, and on the text after the <u>newpage.</u>
                     <u>Newpage</u> will most likely produce bizarre results if the <b>-P</b> option is not specified.

              <b>X</b> <b>[</b><u>float</u><b>]</b>
              <b>Y</b> <b>[</b><u>float</u><b>]</b>
                     Postscript  files  to  be  embedded in LaTeX (and some other programs) contain a ``bounding
                     box'' which defines the area which LaTeX will allocate for the postscript.  Other  programs
                     use  this  bounding  box as well, sometimes using it to define where to clip the postscript
                     image.  <b>Jgraph</b> uses the axis lines and labels, and the title to generate its bounding  box.
                     Most of the time that's good enough to work in LaTeX.  The <u>Y</u> and <u>X</u> commands say to make the
                     height and width of the bounding box at least <u>Y</u> and <u>X</u> inches, respectively, but to maintain
                     the  current  centering  of the graph.  If you still need further control over the bounding
                     box (e.g. to change the centering), try the <u>bbox</u> command.  If there's more than one page in
                     the jgraph file, <u>Y</u>, <u>X</u> and <u>bbox</u> values can be given for each graph.

              <b>bbox</b> <u>float</u> <u>float</u> <u>float</u> <u>float</u>
                     If the <u>Y</u> and <u>X</u> commands aren't enough to help you define a good bounding box, this  command
                     lets you explicitly enter one which will go directly into the jgraph output.  Its units are
                     the  final  postscript  units.   It's  probably  best  to use the <b>-p</b> option to see what the
                     bounding box is that jgraph produces, and then alter that accordingly with <u>bbox.</u>  The  main
                     use for this is to change the automatic centering that jgraph performs:  Usually the center
                     of  the  bounding  box that jgraph computes is put at the center of the page.  Changing the
                     bbox changes this center.

              <b>preamble</b> <b>:</b> <b>{</b><u>string</u><b>}</b>
              <b>preamble</b> <b>{</b><u>token</u><b>}</b>
              <b>epilogue</b> <b>:</b> <b>{</b><u>string</u><b>}</b>
              <b>epilogue</b> <b>{</b><u>token</u><b>}</b>
                     These two commands allow the user to include strings or  files  (the  token  specifies  the
                     filename)  which will be copied directly into jgraph's output.  The <u>preamble</u> is included at
                     the beginning of the output (after some initial postscript to set things  up  for  jgraph),
                     and  the  <u>epilogue</u>  is  included  at  the  end.  A good use for the <u>preamble</u> is to set up a
                     postscript dictionary if you're using postscript marks.

       <b>GRAPH</b> <b>EDITING</b> <b>COMMANDS</b>
              These commands act on the current graph.  Graph editing is terminated when one  of  the  top-level
              description commands is given.

              <b>xaxis</b>
              <b>yaxis</b>  Edit the x or y axis (see AXIS EDITING COMMANDS)

              <b>newcurve</b>
                     This starts editing a new curve of the graph (see CURVE EDITING COMMANDS).

              <b>curve</b> <b>{</b><u>integer</u><b>}</b>
                     This  edits  the curve denoted by <b>{</b><u>integer</u><b>}.</b>  If the curve doesn't exist, then this command
                     creates it and starts editing it.  <u>Newcurve</u> and <u>curve</u> interact as <u>newgraph</u> and <u>graph</u> do.

              <b>newline</b>
                     This is an abbreviation for:

                     newcurve marktype none linetype solid

              <b>copycurve</b> <b>[</b><u>integer</u><b>]</b>
                     This starts editing a new curve of the graph, and copies all  its  values  except  for  the
                     points  from  curve  <b>[</b><u>integer.</u><b>]</b> If the <b>[</b><u>integer</u><b>]</b> is omitted, then it copies its values from
                     the last curve in this graph.  If this graph currently has  no  curves,  then  it  searches
                     backwards from the previous graph.

              <b>title</b>  This  edits  the  title  of  the  graph (see LABEL EDITING COMMANDS).  The title is given a
                     default location centered beneath the graph, and a default font size  of  12,  however,  as
                     with all labels, this can be changed.

              <b>legend</b> This  edits the legend of the graph (see LEGEND EDITING COMMANDS).  As a default, the graph
                     will contain a legend if any of its curves have labels.

              <b>newstring</b>
                     This edits a new text string (see LABEL EDITING COMMANDS).  This is useful as it allows the
                     user to plot text on the graph as well as curves.

              <b>string</b> <b>{</b><u>integer</u><b>}</b>
              <b>copystring</b> <b>[</b><u>integer</u><b>]</b>
                     <u>String</u> and <u>copystring</u> are to <u>newstring</u> as <u>curve</u> and <u>copycurve</u> are to <u>newcurve</u>.

              <b>border</b>
              <b>noborder</b>
                     <u>Border</u> draws a square border around the area defined by the axes.   <u>Noborder</u>  specifies  no
                     border.  <u>Noborder</u> is the default.

              <b>clip</b>
              <b>noclip</b> <u>Clip</u>  specifies  that all curves in the graph will be clipped -- that is, no points outside
                     of the axes will be plotted.  Clipping can also be specified on  a  per-curve  basis.   The
                     default is <u>noclip</u>.

              <b>inherit_axes</b>
                     This is an old command which is kept for backward compatibility.  <u>Copycurve</u>.  is equivalent
                     to:

                     newgraph inherit_axes

              <b>x_translate</b> <b>[</b><u>float</u><b>]</b>
              <b>y_translate</b> <b>[</b><u>float</u><b>]</b>
                     By  default,  the bottom left-hand corner of each graph is at point (0,0) (final postscript
                     units).  <u>X_translate</u> and <u>Y_translate</u> translate the bottom left-hand  corner  of  the  graph
                     <b>[</b><u>float</u><b>]</b>  inches.  The main use of this is to draw more than one graph on a page.  Note that
                     jgraph considers all the graphs drawn on the page when it computes  its  bounding  box  for
                     centering.   Thus,  if  only  one  graph  is drawn, it will always be centered on the page,
                     regardless of its <u>X_translate</u> and <u>Y_translate</u> values.  These values are used  for  relative
                     placement of the graphs.
                        To change the centering of the graphs, use <u>bbox.</u>

              <b>X</b> <b>[</b><u>float</u><b>]</b>
              <b>Y</b> <b>[</b><u>float</u><b>]</b>
                     These  are  the  same  as  <u>X</u> and <u>Y</u> in the Top-level commands, except that they let the user
                     continue editing the current graph.

       <b>SIMPLE</b> <b>AXIS</b> <b>EDITING</b> <b>COMMANDS</b>
              These commands act on the current axis as chosen by <u>xaxis</u> or <u>yaxis</u> (see GRAPH  EDITING  COMMANDS).
              Axis  editing terminates when a graph or top-level command is given.  There are more advanced axis
              editing commands given below which have to do with moving the hash marks, adding  new  hash  marks
              and labels, etc.  See ADVANCED AXIS EDITING COMMANDS.

              <b>linear</b>
              <b>log</b>    Set  the axis to be linear or logarithmic. The default is linear.  If the axis is set to be
                     logarithmic, then values &lt;= 0.0 will be disallowed, as they are at negative infinity on the
                     axis. If you are using logarithmic axes and the labels shows 0 0 1 10 instead of 0.01 0.1 1
                     10, then you should read "hash_format" in this section. Hint: xaxis log hash_format g

              <b>min</b> <b>[</b><u>float</u><b>]</b>
              <b>max</b> <b>[</b><u>float</u><b>]</b>
                     Set the minimum and maximum values of this axis.  Defaults  depend  on  the  points  given.
                     They  can  be  seen  by  using  the <b>-p</b> option.  Unless stated, all units (for example point
                     plotting, string plotting, etc.) will be in terms of the <u>min</u> and <u>max</u> values of the x and  y
                     axes.

              <b>size</b> <b>[</b><u>float</u><b>]</b>
                     Set the size of this axis in inches.

              <b>log_base</b> <b>[</b><u>float</u><b>]</b>
                     Set  the  base  of  the logarithmic axis. Default = 10.  This is the value which determines
                     which hash marks and hash labels are automatically produced.

              <b>hash</b> <b>[</b><u>float</u><b>]</b>
                     Hash marks will be <b>[</b><u>float</u><b>]</b> units apart.  Default = -1.  If this value equals 0, then  there
                     will  be  no  hash  marks.   If  this  value  is  less  than 0, then the hash marks will be
                     automatically set by <b>jgraph</b> (see <b>-p</b> for the value).  By default, each  hash  mark  will  be
                     labeled with its value.  <u>Hash</u> and <u>shash</u> are ignored if the axes are logarithmic.

              <b>shash</b> <b>[</b><u>float</u><b>]</b>
                     Make  sure there is a hash mark at the point <b>[</b><u>float</u><b>]</b> along the axis.  The default is set by
                     <b>jgraph</b> if <b>hash</b> = -1.  If <u>hash</u> is set by the user, <u>shash</u> is defaulted to the  <u>min</u>  value  of
                     the axis.

              <b>mhash</b> <b>[</b><u>integer</u><b>]</b>
                     Put  <b>[</b><u>integer</u><b>]</b> minor hash marks between the above hash marks.  Default = -1.  If this value
                     equals 0, then there will be no minor hash marks.  If this  value  is  negative,  then  the
                     value will be chosen by <b>jgraph</b> (see <b>-p</b> for the value).

              <b>precision</b> <b>[</b><u>integer</u><b>]</b>

              <b>hash_format</b> <u>token</u>
                     These  control  how  jgraph  formats the automatic hash labels.  The user shouldn't have to
                     worry about these values, except in extreme  cases.   Jgraph  uses  <b>printf</b>  to  format  the
                     labels.   If  <b>hash_format</b> is ``f'' (the default), then the value of a hash label is printed
                     with

                   printf("%.*f", precision, value).

              Other valid <b>hash_format</b> values are ``G'', ``g'', ``E'', and ``e''.  ``G'' is a good generic format
              which converts to scientific notation if the value becomes too big or too small.  If the precision
              is negative, then jgraph chooses a default:  For ``g'' and ``G'', the default is 6.  For ``e'' and
              ``E'', the default is 0, and for ``f'', jgraph tries to determine a  reasonable  default.   Please
              read the man page of <b><a href="../man1/prinf.1.html">prinf</a>(1)</b> for a complete description of how it formats floating point numbers.

              <b>label</b>  Edit the label of this axis (see LABEL EDITING COMMANDS).  By default, the label is in font
                     ``Times-Bold'',  and has a font size of 10.  If the user doesn't change any of the plotting
                     attributes of the label, <b>jgraph</b> chooses an appropriate place for the axis label.

              <b>draw_at</b> <b>[</b><u>float</u><b>]</b>
                     Draw the axis line at this point on the other axis.   The  default  is  usually  the  other
                     axis's <u>min</u>, however if <u>hash_scale</u> is positive (see <u>hash_scale</u> under ADVANCED AXIS EDITING),
                     it will be the other axis's <u>max</u>.

              <b>nodraw</b> Do  not  draw  the  axis, the hash marks or any labels.  This is useful for plotting points
                     with no axes, and for overlaying graphs on top of one another with  no  clashes.   This  is
                     equivalent     to     <u>no_draw_axis</u>,     <u>no_draw_axis_label</u>,     <u>no_draw_hash_marks</u>,     and
                     <u>no_draw_hash_labels</u>.

              <b>draw</b>   Cancels  the  effect  of  <u>nodraw</u>.   Default  =  <u>draw</u>  This  is  equivalent  to   <u>draw_axis</u>,
                     <u>draw_axis_label</u>, <u>draw_hash_marks</u>, and <u>draw_hash_labels</u>.

              <b>grid_lines</b>
              <b>no_grid_lines</b>
                     <u>Grid_lines</u> specifies to plot a grid line at each major hash mark on this axis.  The default
                     is <u>no_grid_lines.</u>

              <b>mgrid_lines</b>
              <b>no_mgrid_lines</b>
                     <u>Mgrid_lines</u>  specifies  to  plot  a  grid  line  at each minor hash mark on this axis.  The
                     default is <u>no_mgrid_lines</u>.

       <b>CURVE</b> <b>EDITING</b> <b>COMMANDS</b>
              These commands act on the current curve  as  chosen  by  <u>newcurve</u>  or  <u>curve</u>  (see  GRAPH  EDITING
              COMMANDS).  Curve editing terminates when a graph or top-level command is given.

              <b>pts</b> <b>[{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}]*</b>
                     This sets the points to plot in this curve.  The first <u>float</u> is the x value, and the second
                     <u>float</u>  is  the  y  value  of  the  point.  Points are plotted in the order specified.  This
                     command stops reading points when a non-float is given.  The user can specify this  command
                     multiple times within a curve -- each time, simply more points are added to the curve.

              <b>x_epts</b> <b>[{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}]*</b>
              <b>y_epts</b> <b>[{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}]*</b>
                     This  allows  the  user  to  specify  points  and ``confidence values'' (otherwise known as
                     ``error bars'').  The first two <u>floats</u> specify the x and y values of the point,  as  above.
                     If  <b>x_epts</b> is specified,  then the second two <u>floats</u> specify range or confidence values for
                     the x value of the point.  Error bars will be printed to each of these x values (using  the
                     original  point's  y  value) from the original point.  Similarly, <u>y_epts</u> specifies range or
                     confidence values for the y value  of  the  point.   <u>pts</u>  <u>x_epts</u>  and  <u>y_epts</u>  can  all  be
                     intermixed.

              <b>marktype</b>
                     This  sets  the kind of mark that is plotted for this curve.  Valid marks are: <u>circle</u>, <u>box</u>,
                     <u>diamond</u>, <u>triangle</u>, <u>x</u>, <u>cross</u>, <u>ellipse</u>, <u>xbar</u>, <u>ybar</u>, <u>text</u>, <u>postscript</u>, <u>eps</u>, <u>none</u>, and variants
                     of <u>general</u>.  Most of these are self-explanatory, except for the last few:
                       <u>Xbar</u> makes the curve into a bar graph with the bars going to the x axis.   <u>Ybar</u>  has  the
                     bars going to the y axis.
                       <u>Text</u> lets the user plot text instead of a mark.  The text is edited as a label (see LABEL
                     EDITING  COMMANDS) immediately following the <u>text</u> command.  The x and y fields of the label
                     have special meanings here:  They define where the label is to be printed  in  relation  to
                     the  curve  points.  For example, if they are both 0, the label will be printed directly on
                     the curve points.  If x is 1.0 and y is -1.0, then the label will be printed  one  unit  to
                     the  right  and  one  unit  below  the  curve points (units are units of the x and y axes).
                     Default label values are 0 for x and y, and center justification.
                       <u>Postscript</u>: See the <u>postscript</u> token below.
                       <u>Eps</u>: See the <u>eps</u> token below.
                       <u>None</u> means that no mark will be plotted (this is useful for drawing lines).
                       There are four types of <u>general</u> marks, which work  using  the  <u>gmarks</u>  command  described
                     below.  The four marktypes are <u>general</u>, <u>general_nf</u>, <u>general_bez</u>, and <u>general_bez_nf</u>.
                       By default, a new mark is chosen for each curve.

              <b>marksize</b> <b>[</b><u>float</u><b>]</b> <b>[</b><u>float</u><b>]</b>
                     This sets the size of the mark.  The first <b>[</b><u>float</u><b>]</b> is the width of the mark, and the second
                     is  the  height.   Units  are  those  of the x and y axes respectively, unless that axis is
                     logarithmic, in which case the units are inches.  Negative marksizes are allowed  (e.g.   a
                     negative  height will flip a <u>triangle</u> mark).  The default mark size can be determined using
                     the <b>-p</b> option of <b>jgraph</b>

              <b>mrotate</b> <b>[</b><u>float</u><b>]</b>
                     This allows the user to rotate the mark <b>[</b><u>float</u><b>]</b> degrees.  Default is zero.

              <b>gray</b> <b>[</b><u>float</u><b>]</b>
              <b>color</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
                     These specify either the grayness of the curve or its color.  Values  for  <u>gray</u>  should  be
                     from  0  (black)  to 1 (white).  Values for <u>color</u> should also be from 0 to 1.  They are RGB
                     values, and thus define the amount of red,  green  and  blue  in  the  curve  respectively.
                     Specifying color nullifies the gray value, and vice versa.  The default is <u>gray</u> <u>0</u>

              <b>fill</b> <b>[</b><u>float</u><b>]</b>
              <b>cfill</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
                     This  sets  the  filling  of  marks which define an area to fill (e.g.  <u>box</u>, <u>circle</u>, <u>xbar</u>).
                     <u>fill</u> defines a gray value, and <u>cfill</u> defines a color value (see <u>gray</u> and <u>color</u> above for  a
                     description of the units).  The default is <u>fill</u> <u>0</u> (black).

              <b>pattern</b> <u>token</u> <b>[</b><u>float</u><b>]</b>
                     This  defines  the how the mark is to be filled.  <u>Token</u> may be <u>solid</u> (the default), <u>stripe</u>,
                     or <u>estripe</u>.  If <u>solid</u>, then the <u>float</u> is ignored, and the mark is completely filled in with
                     either the gray value defined by <u>fill</u> or the color value defined by <u>cfill</u>.  If <u>stripe</u>, then
                     the mark will be filled with stripes of either the gray value defined by <u>fill</u> or the  color
                     defined  by  <u>cfill</u>.   The  stripes  will be rotated by <u>float</u> degrees.  <u>Estripe</u> differs from
                     <u>stripe</u> only in that <u>stripe</u> draws stripes on a white background, while <u>estripe</u> simply  draws
                     the stripes on an empty background.

              <b>poly</b>
              <b>nopoly</b>
              <b>pfill</b> <b>[</b><u>float</u><b>]</b>
              <b>pcfill</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
              <b>ppattern</b> <u>token</u> <b>[</b><u>float</u><b>]</b>
                     <u>Poly</u>  allows the user to make jgraph treat the curve as a closed polygon (or in the case of
                     a bezier, a closed bezier curve).  <u>pfill</u>, <u>pcfill</u> and <u>ppattern</u>  specify the filling  of  the
                     polygon, and work like <u>fill</u>, <u>cfill</u> and <u>pattern</u> above.  The default is <u>nopoly</u>.

              <b>gmarks</b> <b>[{</b><u>float</u><b>}</b> <b>{</b><u>float</u><b>}]*</b>
                     <u>Gmarks</u>  is a way for the user to define custom marks.  For each mark on <u>(x,y)</u>, Each pair of
                     <b>{</b><u>float_x</u><b>},</b> <b>{</b><u>float_y</u><b>},</b> will define a point on the mark (x + <b>(</b><u>float_x</u> <b>*</b> <u>marksize_x</u> <b>/</b> <b>2),</b> <b>y</b>  <b>+</b>
                     <b>(</b><u>float_y</u> <b>*</b> <u>marksize_y</u> <b>/</b> <b>2)).</b>
                       Thus, for example, the <u>box</u> mark could be defined as

                   gmarks -1 -1 -1 1 1 1 1 -1
                   marktype general

              The  marktypes  <u>general</u>,  <u>general_nf</u>,  <u>general_bez</u>, and <u>general_bez_nf</u>, allow the gmarks points to
              define a closed polygon, a line, a closed bezier curve and a  regular  bezier  curve  respectively
              (the ``nf'' stands for ``non-filled'').

              <b>postscript</b> <b>:</b> <b>{</b><u>string</u><b>}</b>
              <b>postscript</b> <b>{</b><u>token</u><b>}</b>
                     This  allows  the  user  to  enter  direct postscript as a mark.  It automatically sets the
                     marktype to <u>postscript</u>.  If a string is entered, then that string is used as  the  mark  in
                     the jgraph output.  If a token is entered, then that token must stand for a filename, which
                     will  be  copied  to the output once for every mark.  The postscript will be set up so that
                     when the string or file is put to the output, (0, 0) of the the axes is in  the  middle  of
                     the  mark,  it  is rotated by <u>mrotate</u> degrees, and scaled by (<u>marksize_x</u> / 2), <u>marksize_y</u> /
                     2).  Thus, the <u>box</u> mark could be defined as:

                   postscript : 1 setlinewidth -1 -1 moveto -1 1 lineto \
                                1 1 lineto 1 -1 lineto -1 -1 lineto stroke

              If the <u>marksize_x</u> is defined to be (0, 0), then jgraph does no scaling.  This is useful  when  the
              postscript has strings, and the user does not want the strings to be scaled.

              <b>eps</b> <b>{</b><u>token</u><b>}</b>
                     This allows the user to include an encapsulated postscript file and treat it as a mark.  It
                     automatically  sets  the marktype to <u>eps</u>.  The file will be scaled so that the bounding box
                     is <u>marksize</u> units.  Among other things, this allows the user to include whole jgraph  files
                     as marks.  Please see ad.jgr, explained in HINTS AND EXAMPLE GRAPHS below for an example of
                     this feature.

              <b>larrows</b>
              <b>rarrows</b>
              <b>nolarrows</b>
              <b>norarrows</b>
                     <u>Rarrows</u>  specifies to draw an arrow at the end of every line segment in the curve.  <u>Larrows</u>
                     specifies to draw an arrow at the beginning of every line segment.  The size of the  arrows
                     can be changed by using <u>asize.</u>  The default is <u>nolarrows</u> and <u>norarrows</u>.
                       Arrows  always go exactly to the point specified, with the exception of when the marktype
                     is ``circle''.  In this case, the arrow goes to the edge of the circle.

              <b>larrow</b>
              <b>rarrow</b>
              <b>nolarrow</b>
              <b>norarrow</b>
                     This is analgous to the above, except that with <u>larrow</u>, the only  arrow  drawn  is  to  the
                     beginning  of  the  first segment in the curve, and with <u>rarrow</u>, the only arrow drawn is to
                     the end of the last segment.

              <b>asize</b> <b>[</b><u>float</u><b>]</b> <b>[</b><u>float</u><b>]</b>
                     This sets the size of the arrows.  The first <b>[</b><u>float</u><b>]</b> controls the arrow's width.  Its units
                     are those of the x-axis.  The second <b>[</b><u>float</u><b>]</b> controls the arrow's height.   It  is  in  the
                     units of the y-axis.  Use the -p option of jgraph to see the default values.

              <b>afill</b> <b>[</b><u>float</u><b>]</b>
              <b>afill</b> <b>[</b><u>float</u><b>]</b>
              <b>apattern</b> <u>token</u> <b>[</b><u>float</u><b>]</b>
                     These  control the grayness or color of arrowheads.  <u>Afill</u>, <u>acfill</u> and <u>apattern</u> work in the
                     same way as <u>fill</u>, <u>cfill</u> and <u>pattern</u> described above.  The default is <u>afill</u> <u>0</u> (black).

              <b>linetype</b> <b>[</b><u>token</u><b>]</b>
                     This defines the type of the line connecting the points.  Valid entries are <u>solid</u>,  <u>dotted</u>,
                     <u>dashed</u>,  <u>longdash</u>,  <u>dotdash</u>, <u>dotdotdash</u>, <u>dotdotdashdash</u>, <u>general</u>, and <u>none</u>.  The default is
                     <u>none</u>.  <u>General</u> lets the user define his own linetype using  the  <u>glines</u>  command  described
                     below.  Points are connected in the order in which they are inserted using the <u>pts</u> command.

              <b>glines</b> <b>[</b><u>float</u><b>]*</b>
                     This  lets the user specify the exact dashing of a line.  The format is as in postscript --
                     the first number is the length of the first dash, the second is the  length  of  the  space
                     after the first dash, etc.  For example, <u>dotdash</u> could be defined as ``<u>glines</u> 5 3 1 3''.

              <b>linethickness</b> <b>[</b><u>float</u><b>]</b>
                     This  defines  the  line  thickness  (in absolute postscript units) of the connecting line.
                     Default = 1.0.

              <b>bezier</b>
              <b>nobezier</b>
                     <u>Bezier</u> specifies to use the curve's points to define successive bezier curves.   The  first
                     point  is the starting point.  The next two are control points for the bezier curve and the
                     next point is the ending point.  If there is another bezier, this ending point is also  the
                     beginning  point  of the next curve.  The next two points are again control points, and the
                     next point is the ending point.  Thus, a bezier must have a total of (3n + 1) points, where
                     n is at least 1.
                       In bezier curves, marks and arrows only apply to every  third  point.   <u>Nobezier</u>  is  the
                     default.

              <b>clip</b>   This specifies that this curve will be clipped -- that is, no points outside of the of axes
                     will be plotted.

              <b>noclip</b> This  turns  off clipping.  If clipping was specified for the entire graph, then <u>noclip</u> has
                     no effect.  <u>Noclip</u> is the default.

              <b>label</b>  This edits the label of this curve for the purpose of drawing a legend.  (see LABEL EDITING
                     COMMANDS and LEGEND EDITING COMMANDS).  Unless the legend  entry  is  <u>custom</u>,  setting  any
                     label attribute except for the text itself will have no effect.

       <b>LABEL</b> <b>EDITING</b> <b>COMMANDS</b>
              The  following  commands  are  used for editing labels.  Unless stated otherwise, the defaults are
              written with each command.  Label editing terminates when one of these tokens is not given.

              <b>:</b> <b>{</b><u>string</u><b>}</b>
                     This sets the string of the label.  If no string is set, the label will not be printed.

              <b>x</b> <b>[</b><u>float</u><b>]</b>
              <b>y</b> <b>[</b><u>float</u><b>]</b>
                     This sets the x or y coordinate of the label.  Units are the units of  the  x  and  y  axes
                     respectively.

              <b>font</b> <b>[</b><u>token</u><b>]</b>
                     This sets the font.  Default is usually ``Times-Roman''.

              <b>fontsize</b> <b>[</b><u>float</u><b>]</b>
                     This sets the fontsize in points.  Default is usually 9.

              <b>linesep</b> <b>[</b><u>float</u><b>]</b>
                     This  sets the distance between lines in multilined labels.  Units are points.  The default
                     is the fontsize.

              <b>hjl</b>
              <b>hjc</b>
              <b>hjr</b>    These set the horizontal justification to left, center, and right, respectively.  Default =
                     <u>hjc.</u>

              <b>vjt</b>
              <b>vjc</b>
              <b>vjb</b>    These set the vertical justification to top center, and bottom,  respectively.   Default  =
                     <u>vjb.</u>

              <b>rotate</b> <b>[</b><u>float</u><b>]</b>
                     This  will  rotate  the string <b>[</b><u>float</u><b>]</b> degrees.  The point of rotation is defined by the <u>vj</u>
                     and <u>hj</u> commands.  For example, to rotate 90 degrees about the center of a string, one would
                     use <u>vjc</u> <u>hjc</u> <u>rotate</u> <u>90.</u>

              <b>lgray</b> <b>[</b><u>float</u><b>]</b>
              <b>lcolor</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
                     These control the color or the grayness of the label.  It works just as <u>gray</u> and  <u>color</u>  do
                     for curves and axes.  The default depends on the context.  For example, for strings and the
                     title,  the default is black.  For axis labels and hash labels, the default is the color of
                     the axis.  For text as marks, the default is the curve color.

       <b>LEGEND</b> <b>EDITING</b> <b>COMMANDS</b>
              These commands allow the user to alter the appearance of the legend.  Legends are printed out  for
              each  curve having a non-null label.  The legend entries are printed out in the order of ascending
              curve numbers.  Legend editing terminates when a graph command or top level command is issued.

              In earlier versions of jgraph (before version 8.0), the characteristics of each legend entry  were
              set  in  the  label  portion  of the entry's curve.  Thus, for example, if you wanted each entry's
              fontsize to be 18, you  had  to  set  it  in  each  entry's  curve.   Now,  default  legend  entry
              characteristics  are  set  using the <u>defaults</u> keyword.  Unless a <u>custom</u> legend is specified, these
              default values override any values set in the entry's curve.  Thus, to get all entries to  have  a
              fontsize of 18, it must be set using <u>defaults</u> <u>fontsize</u> <u>18</u>.

              If legend editing seems cryptic, try the following example:

            newgraph
            newcurve marktype box linetype solid label : Solid box
                 pts 0 0 1 1 2 1 3 1
            newcurve marktype circle linetype dotted label : Dotted circle
                 pts 0 1 1 2 2 2 3 2
            newcurve marktype x linetype dashed label : Dashed x
                 pts 0 2 1 3 2 3 3 3
               legend defaults
                 font Times-Italic fontsize 14 x 1.5 y 3.5 hjc vjb

       The  legend  of this graph should be centered over the top of the graph, and all legend entries should be
       14pt Times-Italic.

              <b>on</b>
              <b>off</b>    These turn printing of the legend on and off.  The default is on (but, of course, if  there
                     are no curve labels defined, there will be no legend).

              <b>linelength</b> <b>[</b><u>float</u><b>]</b>
                     This sets the length of the line printed in front of legend entries corresponding to curves
                     which  have  lines.   Units  are  those of the x axis, unless the x axis is logarithmic, in
                     which case the units are inches.  The default may be gotten using the <b>-p</b> option.

              <b>linebreak</b> <b>[</b><u>float</u><b>]</b>
                     This sets the vertical distance between individual legend entries.  Units are those of  the
                     y  axis, unless the y axis is logarithmic, in which case the units are inches.  The default
                     may be gotten using the <b>-p</b> option.

              <b>midspace</b> <b>[</b><u>float</u><b>]</b>
                     This sets one of two things.  If any of the legend entries have lines in  them,  then  this
                     sets  the  distance between the end of the line and the legend entry text.  Otherwise, this
                     sets the distance between center of the mark and the legend entry text.  Units are those of
                     the x axis, unless the x axis is logarithmic, in which case  the  units  are  inches.   The
                     default may be gotten using the <b>-p</b> option.

              <b>defaults</b>
                     This lets the user change the attributes of all legend entries.  The defaults are edited as
                     a  label  (see  LABEL  EDITING COMMANDS).  A few of the label fields have special meanings:
                     The <u>:</u> field is ignored.  The <u>x</u> and <u>y</u> fields define where the label will be printed.  The <u>hj</u>
                     and <u>vj</u> fields define the justification of the legend about the <u>x</u> and <u>y</u> point.  Thus,  if  <u>x</u>
                     is  10  and  <u>y</u>  is  15,  and  <u>hjc</u>   <u>vjb</u>  are  specified,  then  the legend will be centered
                     horizontally about x=10, and the bottom of the legend will be  placed  on  y=15.   This  is
                     analagous to label plotting.  The <u>rotate</u> field is also analagous to label plotting.

                     Defaults  are  as  follows.   <u>Rotate</u> is 0.  <u>font</u> is ``Times-Roman'' and <u>fontsize</u> is 9.  The
                     color is black.  Default justification is <u>hjl</u> and <u>vjc</u>.  The default <u>x</u> and <u>y</u> values are  set
                     according to the <u>hj</u> and <u>vj</u> fields.  See the <b>-p</b> option.

              <b>left</b>
              <u>right</u>  These  will  automatically produce a legend to the left or the right of the graph.  <u>Left</u> is
                     equivalent to <u>defaults</u> <u>hjr</u> <u>vjc</u> and <u>right</u> is equivalent to <u>defaults</u> <u>hjl</u> <u>vjc</u>.

              <b>top</b>
              <b>bottom</b> These will automatically produce a legend on the top or the bottom of the  graph.   <u>Top</u>  is
                     equivalent to <u>defaults</u> <u>hjl</u> <u>vjb</u>
                      and <u>bottom</u> is equivalent to <u>defaults</u> <u>hjl</u> <u>vjt</u>.

              <b>x</b> <b>[</b><u>float</u><b>]</b>
              <b>y</b> <b>[</b><u>float</u><b>]</b>
                     These  are  included  mainly  for  backward  compatability  to  earlier versions of jgraph.
                     Setting <u>x</u> and <u>y</u> is equivalent to ``defaults x <u>float</u> y <u>float</u> hjl vjt''

              <b>custom</b> This lets the user control where each individual legend entry  goes.   The  values  of  the
                     <u>defaults</u>  fields  are ignored, and instead, the values of the curve's labels are used.  All
                     justifications have defined results, except for <u>hjc</u>.  Similarly, rotation other than  0  is
                     likely to produce bad effects.

       <b>ADVANCED</b> <b>AXIS</b> <b>EDITING</b>
              These  are  more advanced commands for editing an axis.  This includes drawing explicit hash marks
              and labels, moving the hash marks, axes, and labels, not drawing the  hash  marks,  labels,  axes,
              etc.

              <b>gray</b> <b>[</b><u>float</u><b>]</b>
              <b>color</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
                     These specify either the grayness of the axis or its color.  Values for <u>gray</u> should be from
                     0 (black) to 1 (white).  Values for <u>color</u> should also be from 0 to 1.  They are RGB values,
                     and  thus  define  the  amount of red, green and blue in the axis respectively.  Specifying
                     color nullifies the gray value, and vice versa.  The  default  is  <u>gray</u>  <u>0</u>.   These  values
                     affect every part of the axis:  the label, the hash marks and labels, the axis line and the
                     grid lines.

              <b>grid_gray</b> <b>[</b><u>float</u><b>]</b>
              <b>grid_color</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
              <b>mgrid_gray</b> <b>[</b><u>float</u><b>]</b>
              <b>mgrid_color</b> <b>[</b><u>float</u> <u>float</u> <u>float</u><b>]</b>
                     These allow the user to define the grayness or color of the gridlines and the mgridlines to
                     be  different  from  those  of the axis lines.  The default <u>grid_gray</u> and <u>grid_color</u> is the
                     same as the axis's <u>gray</u> and <u>color</u>.  The default <u>mgrid_gray</u> and <u>mgrid_color</u> is the  same  as
                     <u>grid_gray</u> and <u>grid_color</u>.

              <b>hash_at</b> <b>[</b><u>float</u><b>]</b>
                     Draw a hash mark at this point.  No label is made for this hash mark.

              <b>mhash_at</b> <b>[</b><u>float</u><b>]</b>
                     Draw a minor hash mark at this point.

              <b>hash_label</b>
                     Edit a hash label (see HASH LABEL EDITING COMMANDS).

              <b>hash_labels</b>
                     Edit  the  default characteristics of the hash labels.  This is so that the user can change
                     the fontsize, justification, etc., of the hash labels.  Editing <u>hash_labels</u>  is  just  like
                     editing  normal labels (see LABEL EDITING COMMANDS), except that the <u>:</u>, <u>x</u>, and <u>y</u> values are
                     all ignored. Defaults for hash labels are  as  follows:  Fontsize=9,  Font=``Times-Roman'',
                     Justification  is  dependent  on  whether  it  is the x or y axis and whether <u>hash_scale</u> is
                     positive or negative.

              <b>hash_scale</b> <b>[</b><u>float</u><b>]</b>
                     This is to change the size and orientation of the hash marks.  Default  =  -1.0.   Changing
                     this to -2.0 will double the length of the hash marks.  Changing this to +1.0 will make the
                     hash marks come above or to the right of the axis.

              <b>draw_hash_marks_at</b> <b>[</b><u>float</u><b>]</b>
                     By  default, the hash marks are drawn either above or below the axis.  This command changes
                     where they are drawn.  <u>Hash_scale</u> still determines whether they are drawn  above  or  below
                     this point, and their size.

              <b>draw_hash_labels_at</b> <b>[</b><u>float</u><b>]</b>
                     By  default, the hash labels are drawn either above or below the hash marks (again, this is
                     dependent on <u>hash_scale</u>).  This command changes where they are  drawn.   Justification  and
                     fontsize, etc., can be changed with the <u>hash_labels</u> command.

              <b>auto_hash_marks</b>
              <b>no_auto_hash_marks</b>
                     This  toggles whether or not <b>jgraph</b> will automatically create hash marks according to <u>hash</u>,
                     <u>mhash</u>  and  <u>shash</u>  (or  <u>log_base</u>  and  <u>mhash</u>  for  logarithmic  axes).   The   default   is
                     <u>auto_hash_marks</u>.

              <b>auto_hash_labels</b>
              <b>no_auto_hash_labels</b>
                     This  toggles  whether  or  not  <b>jgraph</b>  will  automatically  create  hash  labels  for the
                     <u>auto_hash_marks</u>.  Default = <u>auto_hash_labels</u>.

              <b>draw_axis</b>
              <b>no_draw_axis</b>
                     This toggles whether or not the axis line is drawn.  Default = <u>draw_axis</u>.

              <b>draw_axis_label</b>
              <b>no_draw_axis_label</b>
                     This toggles whether or not the axis label (as edited  by  the  <u>label</u>  command)  is  drawn.
                     Default = <u>draw_axis_label</u>.

              <b>draw_hash_marks</b>
              <b>no_draw_hash_marks</b>
                     This  toggles  whether or not the hash marks (both automatic and those created with <u>hash_at</u>
                     and <u>mhash_at</u>) are drawn.  Default = <u>draw_hash_marks</u>.

              <b>draw_hash_labels</b>
              <b>no_draw_hash_labels</b>
                     This toggles whether or not the hash labels are drawn.  Default = <u>draw_hash_labels</u>.

       <b>HASH</b> <b>LABEL</b> <b>EDITING</b> <b>COMMANDS</b>
              Hash labels are simply strings printed along the appropriate axis.  As a default, they are printed
              at the place denoted by the most recent <u>hash_at</u> or <u>mhash_at</u> for this axis, but this can be changed
              by the <u>at</u> command.  If there has been no <u>hash_at</u> or <u>mhash_at</u>, then an <u>at</u> command must be given, or
              there will be an error.  Hash editing terminates when either one of these commands is not given.

              <b>:</b> <b>{</b><u>string</u><b>}</b>
                     This sets the string of the hash label (see <b>Strings</b> above under THE DESCRIPTION LANGUAGE).

              <b>at</b> <b>[</b><u>float</u><b>]</b>
                     This sets the location of the hash label along the current axis.

</pre><h4><b>FUNCTION</b> <b>PLOTTING</b> <b>AND</b> <b>OTHER</b> <b>NON-INHERENT</b> <b>FEATURES</b></h4><pre>
       Although <b>jgraph</b> doesn't have any built-in functions for interpolation or function plotting, both  can  be
       effected in <b>jgraph</b> with a little outside help:

       <b>Function</b> <b>plotting</b>
              With  the <u>include</u> and <u>shell</u> statement, it's easy to create a file of points of a function with a c
              or awk program, and include it into a graph.  See the section HINTS  AND  EXAMPLE  GRAPHS  for  an
              example of a sin graph produced in this manner.

       <b>Point</b> <b>interpolation</b>
              Point  interpolation  is  essentially  the same as function plotting, and therefore is left out of
              <b>jgraph.</b>  The UNIX <a href="../man1/spline.1.html">spline</a>(1) routine is a simple way to  get  interpolation  between  points.   See
              bailey.jgr described below.  Maybe in a future release.

</pre><h4><b>HINTS</b> <b>AND</b> <b>EXAMPLE</b> <b>GRAPHS</b></h4><pre>
       <b>Jgraph</b>  should  be able to draw any kind of scatter/line/bar graph that a user desires.  To embellish the
       graph with extra text, axes, lines, etc., it is helpful to use <u>copygraph.</u>  The following  example  graphs
       show   a   few   examples   of   different   features  of  jgraph.   They  should  be  in  the  directory
       /usr/share/doc/examples/jgraph.

       - acc.jgr is a simple bar graph.  Acc.tex is also included to show how one  can  include  the  output  of
       jgraph  in  a  LaTeX  file.  To get this to work, you might have to substitute the entire pathname of the
       file acc.jps in the acc.tex file.

       - g8.jgr is a simple graph with some plotted text.  - g8col.jgr shows how to produce a  color  background
       -- it is
         the  same as g8.jgr only all on a yellow background.  - ebars.jgr is a simple graph with error bars.  -
       sin.jgr shows how a sin function can be plotted using a  simple  c  program  to  produce  the  sin  wave.
       Moreover, this file shows a use of <u>copygraph</u> to plot an extra x and y axis at the 0 point.

       - sin1.jgr is a further extension of sin.jgr only with one x and y axis at 0, but with the axis labels at
       the left and the bottom of the graph.

       - sin2.jgr is a different sin wave with a logarithmic x axis.

       - sin3.jgr shows how a bizarre effect can be gotten by sorting the points in a different manner.

       - bailey.jgr shows how to use the UNIX <a href="../man1/spline.1.html">spline</a>(1) routine to get interpolation between points.

       - gpaper.jgr shows how you can get jgraph to easily produce graph paper.

       -  g9n10.jgr  contains  two graphs with complicated legends.  It contains a description of how the legend
       was created.

       - ex1.jgr and ex2.jgr are two examples which were figures 1 and two in an extended abstract for  a  paper
       about jgraph.

       -  mab2.jgr  is  a  graph  created  by Matt Blaze which shows how a complicated output graph can be quite
       concisely and simply stated.  In this graph, the x axis is a time line.  It shows usage of the <u>hash_label</u>
       and <u>hash_labels</u> commands, as well as displaying how jgraph lets you extract data from output  files  with
       awk.

       -  nr.jgr  is  an  example  of a rather complicated bar graph with stripe-filled bars.  It was created by
       Norman Ramsey.

       - hypercube.jgr shows an interesting use of jgraph for picture-drawing.

       - ad.jgr is an example which shows how one can include jgraph output as jgraph input.  The file uses  the
       <u>eps</u>  token to include cube.jgr, a jgraph drawing of an Intel hypercube, and disk.jgr, a jgraph drawing of
       a disk, in a picture.

       - alb.jgr is another use of jgraph for picture drawing.  This file was created by  an  awk  script  which
       Adam Buchsbaum wrote to draw trees and graphs.

       -  wortman.jgr  is a neat graph of processor utilization written by Dave Wortman for SIGPLAN '92.  It was
       created by an awk script, which processed the data and emitted the jgraph.

       To view these graphs, use jgraph -P, and view the resulting output file with <u>gs</u>, or a similar  postscript
       viewer.  To make a hard copy of these graphs, pipe the output of jgraph -P directly to <u>lpr</u>.

</pre><h4><b>USING</b> <b>JGRAPH</b> <b>TO</b> <b>DRAW</b> <b>PICTURES</b></h4><pre>
       As  hypercube.jgr  and  alb.jgr  show,  jgraph can be used as a postscript preprocessor to make drawings.
       There are two advantages using jgraph to draw pictures instead of using standard drawing tools like <u>xfig</u>,
       <u>figtool</u>, or <u>idraw</u>.  The first is that with jgraph, you know exactly where  strings,  lines,  boxes,  etc,
       will end up, because you plot them explicitly.  The second advantage is that for iterative drawings, with
       lots  of  patterns, you can combine jgraph with awk or c or any other programming language to get complex
       output in a simple way.  Most what-you-see-is-what-you-get (WYSIWYG) drawing tools cannot do this.

       The major disadvantage of using jgraph to draw pictures is that jgraph is not WYSIWYG.  You have  to  set
       up axes and plot points, lines and strings.  It's all a matter of taste.

       If  you'd  like  to  see  some  more  complex  pictures  drawn with jgraph, as well as some hints to make
       picture-drawing easier, send me email (<a href="mailto:plank@cs.utk.edu">plank@cs.utk.edu</a>).

</pre><h4><b>SUPPORT</b> <b>FOR</b> <b>OTHER</b> <b>FONT</b> <b>ENCODINGS</b></h4><pre>
       If  you  want  to  use  non-english  characters  to  set  labels  or  titles,  set  enviroment   variable
       JGRAPH_ENCODING  with  the  font  encoding  that  you  need.  This  value  will be passed directly to the
       postscript.

       Ex. to use ISO-8859-1 characters, try:

          export JGRAPH_ENCODING=ISOLatin1Encoding

       Note: that only works with default fonts. if you use 'font' in stdin to specify another  font,  it  won't
       work.

       You  also  have  the  possibility  to expand the bounding box if jgraph cuts some acute, tilde or special
       chars near the border; try:

          export JGRAPH_BORDER=5

       This support is currently 'testing' code. Send bugs about it to <a href="mailto:pzn@debian.org">pzn@debian.org</a>

</pre><h4><b>INTEGRATION</b> <b>WITH</b> <b>LATEX</b></h4><pre>
       1. At the top, say
          \usepackage{graphics}

       2. The floating object is done using:

          \begin{figure}
          \begin{center}
          \includegraphics{a.eps}
          \end{center}
          \end{figure}

       3. Now go through dvips as usual and the .ps file will work.

</pre><h4><b>INTEGRATION</b> <b>WITH</b> <b>PDFLATEX</b></h4><pre>
       If you are using pdflatex, it requires .pdf files and not .eps files. In  that  case,  you  have  to  run
       epstopdf on the .eps file to get a .pdf file. After that,
          \includegraphics{a.pdf}
       does the trick.

</pre><h4><b>SCALING</b> <b>THE</b> <b>INCLUDED</b> <b>GRAPHICS</b> <b>OBJECT</b></h4><pre>
       Sometimes you need to change the size of the included object at LaTeX time. In that case, you need
          \usepackage{graphicx}
       instead of graphics, and then say something like

           \includegraphics[width=7cm]{a.eps}
        or
           \includegraphics[height=7cm]{a.eps}

       you can also omit the .eps/.pdf suffix:
           \includegraphics[height=7cm]{a}

       a.eps  and  a.pdf  can  both  exist,  and  includegraphics  will automatically choose the correct one for
       postscript or pdf output, depending if you are using latex of pdflatex.

</pre><h4><b>AUTOMATION</b> <b>USING</b> <b>MAKE</b></h4><pre>
       You can automate the mapping from .jgr -&gt; .eps or .jgr -&gt; .pdf in your Makefile using these rules:

       --------- cut here ---------
       %.eps : %.jgr
            jgraph $&lt; &gt; $@
       %.pdf : %.jgr
            jgraph $&lt; | epstopdf --filter &gt; $@
       --------- cut here ---------

       jgraph can also return the exit status correctly, so it is also a good idea to use it in your scripts  to
       prevent bad .eps files if the .jgr source is bad. The following Makefile can handle its exit status.

       --------- cut here ---------
       %.eps : %.jgr
            jgraph $&lt; &gt; $@; \
            if [ "$$?" != "0" ]; then \
              rm -f $@; \
              exit 1; \
            fi
       %.pdf : %.jgr
            TMP=`tempfile`; jgraph $&lt; &gt; $${TMP}; \
            if [ "$$?" == "0" ]; then \
              cat $${TMP} | epstopdf --filter &gt; $@; \
              rm -f $${TMP}; \
            else \
              rm -f $${TMP} $@; \
              exit 1; \
            fi;
       --------- cut here ---------

</pre><h4><b>BUGS</b></h4><pre>
       Logarithmic  axes  cannot contain points &lt;= 0.  If I have enough complaints to convince me that this is a
       bug, I'll try to fix it.

       There is no real way to make the axes such that they decrease from left to right or low to high -- or  at
       least not without writing your own hash labels.

       There may well be loads of other bugs.  Send to <a href="mailto:plank@cs.utk.edu">plank@cs.utk.edu</a>.

       This is $Revision: 8.3 $.

                                                                                                       <u><a href="../man1/jgraph.1.html">jgraph</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>