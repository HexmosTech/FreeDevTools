<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rgs - a shell command to manipulate a remote SBC's GPIO.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/rgpio-tools">rgpio-tools_0.2.0.0-0ubuntu4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rgs - a shell command to manipulate a remote SBC's GPIO.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>rgpiod</b> <b>&amp;</b>

       then

       <b>rgs</b> <b>{command}+</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       rgs is a program which allows remote control of the GPIO and other functions of Linux SBCs running the
       rgpiod daemon.

       The rgpiod daemon must be running on the SBCs you wish to control.

   <b>Features</b>
       o reading and writing GPIO singly and in groups

       o software timed PWM and waves

       o GPIO callbacks

       o pipe notification of GPIO events

       o I2C wrapper

       o SPI wrapper

       o serial link wrapper

       o simple file handling

       o creating and running scripts on the rgpiod daemon

   <b>Usage</b>
       rgs {command}+

       rgs will show the result of the command on screen.

       The rgs process returns an exit status (which can be displayed with the command echo $?).

       RGS_OK            0
       RGS_CONNECT_ERR 255
       RGS_OPTION_ERR  254
       RGS_SCRIPT_ERR  253

       If an error was detected a message will have been written to stderr.  This is likely to be more
       informative than the message returned by rgs.

       Several commands may be entered on a line.  If present PROC and PARSE must be the last command on a line.

   <b>Notes</b>
       rgs does not show the status of successful commands unless the command itself returns data.  The status
       (0) will be returned to rgs but will be discarded.

       When a command takes a number as a parameter it may be entered as hex (precede by 0x), octal (precede by
       0), or decimal.

       E.g. 23 is 23 decimal, 0x100 is 256 decimal, 070 is 56 decimal.

       Some commands can return a variable number of data bytes.  By default this data is displayed as decimal.
       The rgs -a option can be used to force the display as ASCII and the rgs -x option can be used to force
       the display as hex.

       E.g. assuming the transmitted serial data is the letters ABCDEONM

       $ rgs serr 4 100 # assumes serial data available from handle 4
       8 65 66 67 68 69 79 78 77

       $ rgs -a serr 4 100
       8 ABCDEONM

       $ rgs -x serr 4 100
       8 41 42 43 44 45 4f 4e 4d

   <b>Permissions</b>
       Generally objects created on the rgpiod daemon exist for the duration of the socket connection.

       For a Python script this will be for the duration of the script.  For a program linked with rgpio this
       will be for the duration of the program.

       For rgs it is the command line.

       This means that the following command will achieve little

       rgs go 0 # get handle to gpiochip 0

       The daemon will delete the handle as soon as the rgs command has finished.

       To preserve the handle it must be shared.

       A lot of the examples will show the command c 1 (use share id 1).  This means the handle is preserved and
       may be used in subsequent commands.

       rgs c 1 go 0 # get and preserve handle to gpiochip 0

       If the LG_SHARE environment variable exists that share will be automatically used in rgs commands.

       E.g. <b>export</b> <b>LG_SHARE=12</b> will automatically use share id 12.

       If a command is privileged it is indicated in the notes for the command.  The examples given here assume
       the daemon access control system is not active (so any user can use privileged commands).

       If the LG_USER environment variable exists that user will be automatically used in rgs commands.  This
       only has an effect if the rgpiod daemon is running with access control enabled.

       E.g. <b>export</b> <b>LG_USER=joan</b> will automatically use user joan.

</pre><h4><b>OVERVIEW</b></h4><pre>
   <b>FILES</b>
       <b>FO</b> <b>file</b> <b>mode</b> File open

       <b>FC</b> <b>h</b> File close

       <b>FR</b> <b>h</b> <b>num</b> File read

       <b>FW</b> <b>h</b> <b>bvs</b> File write

       <b>FS</b> <b>h</b> <b>num</b> <b>from</b> File seek

       <b>FL</b> <b>pat</b> <b>num</b> File list

   <b>GPIO</b>
       <b>GO</b> <b>gc</b> gpiochip open device

       <b>GC</b> <b>h</b> gpiochip close device

       <b>GIC</b> <b>h</b> gpiochip information

       <b>GIL</b> <b>h</b> <b>g</b> gpiochip line information

       <b>GMODE</b> <b>h</b> <b>g</b> GPIO get mode

       <b>GSI</b> <b>h</b> <b>g</b> GPIO claim for input (simple)

       <b>GSIX</b> <b>h</b> <b>lf</b> <b>g</b> GPIO claim for input

       <b>GSO</b> <b>h</b> <b>g</b> GPIO claim for output (simple)

       <b>GSOX</b> <b>h</b> <b>lf</b> <b>g</b> <b>v</b> GPIO claim for output

       <b>GSA</b> <b>h</b> <b>g</b> <b>nfyh</b> GPIO claim for alerts (simple)

       <b>GSAX</b> <b>h</b> <b>lf</b> <b>ef</b> <b>g</b> <b>nfyh</b> GPIO claim for alerts

       <b>GSF</b> <b>h</b> <b>g</b> GPIO free

       <b>GSGI</b> <b>h</b> <b>g*</b> GPIO group claim for inputs (simple)

       <b>GSGIX</b> <b>h</b> <b>lf</b> <b>g*</b> GPIO group claim for inputs

       <b>GSGO</b> <b>h</b> <b>g*</b> GPIO group claim for outputs (simple)

       <b>GSGOX</b> <b>h</b> <b>lf</b> <b>g*</b> <b>v*</b> GPIO group claim for outputs

       <b>GSGF</b> <b>h</b> <b>g</b> GPIO group free

       <b>GR</b> <b>h</b> <b>g</b> GPIO read

       <b>GW</b> <b>h</b> <b>g</b> <b>v</b> GPIO write

       <b>GGR</b> <b>h</b> <b>g</b> GPIO group read

       <b>GGW</b> <b>h</b> <b>g</b> <b>gbits</b> GPIO group write (simple)

       <b>GGWX</b> <b>h</b> <b>g</b> <b>gbits</b> <b>gmask</b> GPIO group write

       <b>GP</b> <b>h</b> <b>g</b> <b>mon</b> <b>moff</b> GPIO tx pulse (simple)

       <b>GPX</b> <b>h</b> <b>g</b> <b>mon</b> <b>moff</b> <b>off</b> <b>cyc</b> GPIO tx pulse

       <b>P</b> <b>h</b> <b>g</b> <b>pf</b> <b>pdc</b> GPIO tx PWM (simple)

       <b>PX</b> <b>h</b> <b>g</b> <b>pf</b> <b>pdc</b> <b>off</b> <b>cyc</b> GPIO tx PWM

       <b>S</b> <b>h</b> <b>g</b> <b>spw</b> GPIO tx servo pulses (simple)

       <b>SX</b> <b>h</b> <b>g</b> <b>spw</b> <b>sf</b> <b>off</b> <b>cyc</b> GPIO tx servo pulses

       <b>GWAVE</b> <b>h</b> <b>g</b> <b>p*</b> GPIO group tx wave

       <b>GBUSY</b> <b>h</b> <b>g</b> <b>k</b> GPIO or group tx busy

       <b>GROOM</b> <b>h</b> <b>g</b> <b>k</b> GPIO or group tx entries

       <b>GDEB</b> <b>h</b> <b>g</b> <b>us</b> GPIO debounce time

       <b>GWDOG</b> <b>h</b> <b>g</b> <b>us</b> GPIO watchdog time

   <b>I2C</b>
       <b>I2CO</b> <b>ib</b> <b>id</b> <b>if</b> I2C open device

       <b>I2CC</b> <b>h</b> I2C close device

       <b>I2CWQ</b> <b>h</b> <b>bit</b> SMB Write Quick: write bit

       <b>I2CRS</b> <b>h</b> SMB Read Byte: read byte

       <b>I2CWS</b> <b>h</b> <b>bv</b> SMB Write Byte: write byte

       <b>I2CRB</b> <b>h</b> <b>r</b> SMB Read Byte Data: read byte from register

       <b>I2CWB</b> <b>h</b> <b>r</b> <b>bv</b> SMB Write Byte Data: write byte to register

       <b>I2CRW</b> <b>h</b> <b>r</b> SMB Read Word Data: read word from register

       <b>I2CWW</b> <b>h</b> <b>r</b> <b>wv</b> SMB Write Word Data: write word to register

       <b>I2CRK</b> <b>h</b> <b>r</b> SMB Read Block Data: read data from register

       <b>I2CWK</b> <b>h</b> <b>r</b> <b>bvs</b> SMB Write Block Data: write data to register

       <b>I2CWI</b> <b>h</b> <b>r</b> <b>bvs</b> SMB Write I2C Block Data

       <b>I2CRI</b> <b>h</b> <b>r</b> <b>num</b> SMB Read I2C Block Data: read bytes from register

       <b>I2CRD</b> <b>h</b> <b>num</b> I2C read device

       <b>I2CWD</b> <b>h</b> <b>bvs</b> I2C write device

       <b>I2CPC</b> <b>h</b> <b>r</b> <b>wv</b> SMB Process Call: exchange register with word

       <b>I2CPK</b> <b>h</b> <b>r</b> <b>bvs</b> SMB Block Process Call: exchange data bytes with register

       <b>I2CZ</b> <b>h</b> <b>bvs</b> I2C zip

   <b>NOTIFICATIONS</b>
       <b>NO</b> Notification open

       <b>NC</b> <b>h</b> Notification close

       <b>NP</b> <b>h</b> Notification pause

       <b>NR</b> <b>h</b> Notification resume

   <b>SCRIPTS</b>
       <b>PROC</b> <b>t</b> Script store

       <b>PROCR</b> <b>h</b> <b>pars</b> Script run

       <b>PROCU</b> <b>h</b> <b>pars</b> Script update parameters

       <b>PROCP</b> <b>h</b> Script get status and parameters

       <b>PROCS</b> <b>h</b> Script stop

       <b>PROCD</b> <b>h</b> Script delete

       <b>PARSE</b> <b>t</b> Script validate

   <b>SERIAL</b>
       <b>SERO</b> <b>dev</b> <b>b</b> <b>sef</b> Serial open device

       <b>SERC</b> <b>h</b> Serial close device

       <b>SERRB</b> Serial read byte

       <b>SERWB</b> <b>h</b> <b>bv</b> Serial write byte

       <b>SERR</b> <b>h</b> <b>num</b> Serial read bytes

       <b>SERW</b> <b>h</b> <b>bvs</b> Serial write bytes

       <b>SERDA</b> <b>h</b> Serial data available

   <b>SHELL</b>
       <b>SHELL</b> <b>name</b> <b>str</b> Execute a shell command

   <b>SPI</b>
       <b>SPIO</b> <b>spd</b> <b>spc</b> <b>b</b> <b>spf</b> SPI open device

       <b>SPIC</b> <b>h</b> SPI close device

       <b>SPIR</b> <b>h</b> <b>num</b> SPI read bytes

       <b>SPIW</b> <b>h</b> <b>bvs</b> SPI write bytes

       <b>SPIX</b> <b>h</b> <b>bvs</b> SPI transfer bytes

   <b>UTILITIES</b>
       <b>LGV</b> Get lg library version

       <b>SBC</b> Get SBC's host name

       <b>CGI</b> <b>cid</b> Get internal configuration setting

       <b>CSI</b> <b>cid</b> <b>v</b> Set internal configuration setting

       <b>T/TICK</b> Get nanoseconds since the epoch

       <b>MICS</b> <b>v</b> Microseconds delay

       <b>MILS</b> <b>v</b> Milliseconds delay

       <b>U/USER</b> Set user

       <b>C/SHARE</b> Set share

       <b>LCFG</b> Reload permits configuration file

       <b>PCD</b> Print daemon configuration directory

       <b>PWD</b> Print daemon working directory

</pre><h4><b>COMMANDS</b></h4><pre>
   <b>FILES</b>
       <b>FO</b> <b>file</b> <b>mode</b> - File open

           This is a privileged command.  See <b>permits</b>.

           This function returns a handle to a file opened in a specified mode.

           Upon success a handle (&gt;=0) is returned.  On error a negative status code will be returned.

           The mode may have the following values.

                   Value   Meaning
           READ      1     open file for reading
           WRITE     2     open file for writing
           RW        3     open file for reading and writing

           The following values may be or'd into the mode.

                    Value   Meaning
           APPEND     4     All writes append data to the end of the file
           CREATE     8     The file is created if it doesn't exist
           TRUNC     16     The file is truncated

           Newly  created  files  are owned by the user that launched the daemon with permissions owner read and
           write.

           <b>Example</b>

           ls /ram/*.c
           /ram/q.c     /ram/qdhtxx.c  /ram/q-errcod.c  /ram/q_t1.c
           /ram/q-c1.c  /ram/Q-err.c   /ram/q-group.c   /ram/q_t2.c

           $ rgs c 1 fo /ram/q.c 1  # read access
           1

           $ rgs c 1 fo /ram/new.c 1 # file does not exist
           -58
           ERROR: file open failed

           $rgs c 1 fo /ram/new.c 9 # can not create file
           -67
           ERROR: no permission to access file

       <b>FC</b> <b>h</b> - File close

           This command closes a file previously opened by <b>FO</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 fc 1 # First close okay.

           $ rgs c 1 fc 1 # Second fails.
           -5
           ERROR: unknown handle

       <b>FR</b> <b>h</b> <b>num</b> - File read

           This command returns up to <b>num</b> bytes of data read from the file.

           Upon success the count of returned bytes followed by the bytes themselves is returned.   On  error  a
           negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 fr 0 10
           5 48 49 128 144 255

           $ rgs c 1 fr 0 10
           0

       <b>FW</b> <b>h</b> <b>bvs</b> - File write

           This command writes <b>bvs</b> bytes to the file.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 fw 0 23 45 67 89

       <b>FS</b> <b>h</b> <b>num</b> <b>from</b> - File seek

           This command seeks to a position within the file.

           The  number of bytes to move is <b>num</b>.  Positive offsets move forward, negative offsets backwards.  The
           move start position is determined by <b>from</b> as follows.

               From
           0   start
           1   current position
           2   end

           Upon success the new byte position within the file (&gt;=0) is returned.  On  error  a  negative  status
           code will be returned.

           <b>Example</b>

           $ rgs c 1 fs 0 200 0 # Seek to start of file plus 200
           200

           $ rgs c 1 fs 0 0 1 # Return current position
           200

           $ rgs c 1 fs 0 0 2 # Seek to end of file, return size
           296235

       <b>FL</b> <b>pat</b> <b>num</b> - File list

           This command returns a list of the files matching <b>pat</b>. Up to <b>num</b> bytes may be returned.

           Upon  success  the  count  of  returned bytes followed by the matching files is returned.  On error a
           negative status code will be returned.

           A newline (0x0a) character separates each file name.

           This is a privileged command.  See <b>permits</b>.

           <b>Example</b>

           $ rgs -a fl "/sys/bus/w1/devices/28*/w1_slave" 5000
           90 /sys/bus/w1/devices/28-000005d34cd2/w1_slave
           /sys/bus/w1/devices/28-001414abbeff/w1_slave

           $ rgs -a fl "<a href="file:/sys/bus/">/sys/bus/</a>*" 5000
           ERROR: no permission to access file
           -67

   <b>GPIO</b>
       <b>GO</b> <b>gc</b> - gpiochip open device

           This is a privileged command.  See <b>permits</b>.

           This command opens a gpiochip.

           <b>Example</b>

           $ rgs c 1 go 0 # open /dev/gpiochip0
           1
           $ rgs c 1 go 23 # try to open /dev/gpiochip23
           -78
           ERROR: can not open gpiochip

       <b>GC</b> <b>h</b> - gpiochip close device

           This command closes a gpiochip previously opened by <b>GO</b>.

           <b>Example</b>

           $ rgs c 1 gc 1 # first close ok
           $ rgs c 1 gc 1 # already closed
           -5
           ERROR: unknown handle

       <b>GIC</b> <b>h</b> - gpiochip information

           This command gets information for an opened gpiochip.  In particular it gets the number  of  GPIO  on
           the gpiochip, its name, and its usage.

           <b>Example</b>

           $ rgs c 1 gic 1
           54 "gpiochip0" "pinctrl-bcm2835"

       <b>GIL</b> <b>h</b> <b>g</b> - gpiochip line information

           This  command  gets  information  for  GPIO  <b>g</b> of an opened gpiochip.  In particular it gets the GPIO
           number, line flags, its user, and its purpose.

           The meaning of the line flags bits are as given for the mode by <b>GMODE</b>.

           The user and purpose fields are filled in by the software which has  claimed  the  GPIO  and  may  be
           blank.

           <b>Example</b>

           $ for ((i=2; i&lt;10; i++)); do rgs c 1 gil 1 $i; done
           2 65536 "SDA1" ""
           3 65536 "SCL1" ""
           4 65536 "GPIO_GCLK" ""
           5 65536 "GPIO5" ""
           6 65536 "GPIO6" ""
           7 7 "SPI_CE1_N" "spi0 CS1"
           8 7 "SPI_CE0_N" "spi0 CS0"
           9 65536 "SPI_MISO" ""

       <b>GMODE</b> <b>h</b> <b>g</b> - GPIO get mode

           This command gets the mode for GPIO <b>g</b> of an opened gpiochip.

           Bit   Value   Meaning
           0      1      Kernel: In use by the kernel
           1      2      Kernel: Output
           2      4      Kernel: Active low
           3      8      Kernel: Open drain
           4     16      Kernel: Open source
           5     32      Kernel: Pull up set
           6     64      Kernel: Pull down set
           7     128     Kernel: Pulls off set
           8     256     LG: Input
           9     512     LG: Output
           10    1024    LG: Alert
           11    2048    LG: Group
           12    4096    LG: ---
           13    8192    LG: ---
           14    16384   LG: ---
           15    32768   LG: ---
           16    65536   Kernel: Input
           17    1&lt;&lt;17   Kernel: Rising edge alert
           18    1&lt;&lt;18   Kernel: Falling edge alert
           19    1&lt;&lt;19   Kernel: Realtime clock alert

           The LG bits are only set if the query was made by the process that owns the GPIO.

       <b>GSI</b> <b>h</b> <b>g</b> - GPIO claim for input (simple)

           This command claims GPIO <b>g</b> for input.

           <b>Example</b>

           $ rgs c 1 gsi 1 23 # claim GPIO 23 for input.

       <b>GSIX</b> <b>h</b> <b>lf</b> <b>g</b> - GPIO claim for input

           This command claims GPIO <b>g</b> for input.

           The  line  flags <b>lf</b> may be used to set the GPIO as active low, open drain, open source, pull up, pull
           down, pull off.

           <b>Example</b>

           $ rgs c 1 gsi 1 0 23 # claim GPIO 23 for input.

       <b>GSO</b> <b>h</b> <b>g</b> - GPIO claim for output (simple)

           This command claims GPIO <b>g</b> for output.

           The GPIO will be initialised low.

           <b>Example</b>

           $ rgs c 1 gso 1 25 # claim GPIO 25 for low output.

       <b>GSOX</b> <b>h</b> <b>lf</b> <b>g</b> <b>v</b> - GPIO claim for output

           This command claims GPIO <b>g</b> for output.

           The line flags <b>lf</b> may be used to set the GPIO as active low, open drain, open source, pull  up,  pull
           down, pull off.

           If  <b>v</b>  is  zero  the  GPIO  will  be  initialised  low.   If any other value is used the GPIO will be
           initialised high.

           <b>Example</b>

           $ rgs c 1 gso 1 0 25 # claim GPIO 25 for high output.

       <b>GSA</b> <b>h</b> <b>g</b> <b>nfyh</b> - GPIO claim for alerts (simple)

           This command claims GPIO <b>g</b> for alerts.

           Alerts will be generated for both edges.

           The alerts will be sent to a previously opened notification pipe <b>nfyh</b>.

       <b>GSAX</b> <b>h</b> <b>lf</b> <b>ef</b> <b>g</b> <b>nfyh</b> - GPIO claim for alerts

           This command claims GPIO <b>g</b> for alerts.

           The line flags <b>lf</b> may be used to set the GPIO as active low, open drain, open source, pull  up,  pull
           down, pull off.

           The event flags <b>ef</b> specify whether alerts should be generated on a rising edge, falling edge, or both
           edges.

           The alerts will be sent to a previously opened notification pipe <b>nfyh</b>.

       <b>GSF</b> <b>h</b> <b>g</b> - GPIO free

           This  command  releases  GPIO  <b>g</b>.   The  GPIO  may  now be claimed by another user or for a different
           purpose.

       <b>GSGI</b> <b>h</b> <b>g*</b> - GPIO group claim for inputs (simple)

           This command claims a group of GPIO for inputs.

           <b>g*</b> is a list of one or more GPIO.  The first GPIO in the list is called the group leader and is  used
           to reference the group as a whole.

           <b>Example</b>

           $ rgs c 1 gsgi 1 16 17 18 19 20 21

       <b>GSGIX</b> <b>h</b> <b>lf</b> <b>g*</b> - GPIO group claim for inputs

           This command claims a group of GPIO for inputs.  All the GPIO share the same line flag setting.

           The  line  flags <b>lf</b> may be used to set the GPIO as active low, open drain, open source, pull up, pull
           down, pull off.

           <b>g*</b> is a list of one or more GPIO.  The first GPIO in the list is called the group leader and is  used
           to reference the group as a whole.

           <b>Example</b>

           $ rgs c 1 gsgix 1 0 16 17 18 19 20 21

       <b>GSGO</b> <b>h</b> <b>g*</b> - GPIO group claim for outputs (simple)

           This command claims a group of GPIO for outputs.

           <b>g*</b>  is a list of one or more GPIO.  The first GPIO in the list is called the group leader and is used
           to reference the group as a whole.

           The GPIO will be initialised low.

           <b>Example</b>

           $ rgs c 1 gsgo 1 22 23 24 25

       <b>GSGOX</b> <b>h</b> <b>lf</b> <b>g*</b> <b>v*</b> - GPIO group claim for outputs

           This command claims a group of GPIO for outputs.  All the GPIO and share the same line flag setting.

           The line flags <b>lf</b> may be used to set the GPIO as active low, open drain, open source, pull  up,  pull
           down, pull off.

           <b>g*</b>  is a list of one or more GPIO.  The first GPIO in the list is called the group leader and is used
           to reference the group as a whole.

           <b>v*</b> is a list of initialisation values for the GPIO. If a value is zero the corresponding GPIO will be
           initialised low.  If any other value is used the corresponding GPIO will be initialised high.

           <b>Example</b>

           $ rgs c 1 gsgox 1 0 22 23 24 25 1 1 1 1

       <b>GSGF</b> <b>h</b> <b>g</b> - GPIO group free

           This command releases the group of GPIO identified by the group  leader  <b>g</b>.   The  GPIO  may  now  be
           claimed by another user or for a different purpose.

           <b>Example</b>

           rgs c 1 gsgf 1 22

       <b>GR</b> <b>h</b> <b>g</b> - GPIO read

           This command returns the current value (0 or 1) of GPIO <b>g</b>.

           This  command  will  work for any claimed GPIO (even if a member of a group).  For an output GPIO the
           value returned will be that last written to the GPIO.

           <b>Example</b>

           $ rgs c 1 gr 1 22
           1

       <b>GW</b> <b>h</b> <b>g</b> <b>v</b> - GPIO write

           This command sets the  value (0 or 1) of GPIO <b>g</b>.

           This command will work for any GPIO claimed as an output (even if a member of a group).

           If <b>v</b> is zero the GPIO will be set low.  If any other value is used the GPIO will be set high.

       <b>GGR</b> <b>h</b> <b>g</b> - GPIO group read

           This command reads a group of GPIO identified by group leader <b>g</b>.

           This command will work for an output group as well as an input group.  For an output group the  value
           returned  will  be  that last written to the group GPIO.  Note that this command will also work on an
           individual GPIO claimed as an input or output as that is treated as a group with one member.

           Two values are returned.  The first is the group size (the number of GPIO in the group).  The  second
           is the group bits as a decimal value.

           Bit 0 is the level of the group leader.
           Bit 1 is the level of the second GPIO in the group.
           Bit g is the level of GPIO g+1 in the group.

           <b>Example</b>

           $ rgs c 1 gsgi 1 0 16 17 18 19 20 21
           $ rgs c 1 ggr 1 16
           6 49 # six GPIO, group leader (16) high, 17-19 low, 20-21 high

       <b>GGW</b> <b>h</b> <b>g</b> <b>gbits</b> - GPIO group write (simple)

           This command writes a group of GPIO identified by group leader <b>g</b>.

           The values of each GPIO of the group are set according to the bits
           of <b>gbits</b>.

           Bit 0 sets the level of the group leader.
           Bit 1 sets the level of the second GPIO in the group.
           Bit g sets the level of GPIO g+1 in the group.

           <b>Example</b>

           $ rgs c 1 ggr 1 22
           4 15
           $ rgs c 1 ggw 1 22 5
           $ rgs c 1 ggr 1 22
           4 5
           $ rgs c 1 ggw 1 22 10
           $ rgs c 1 ggr 1 22
           4 10

       <b>GGWX</b> <b>h</b> <b>g</b> <b>gbits</b> <b>gmask</b> - GPIO group write

           This command writes a group of GPIO identified by group leader <b>g</b>.

           The values of each GPIO of the group are set according to the bits
           of <b>gbits</b>.

           Bit 0 sets the level of the group leader.
           Bit 1 sets the level of the second GPIO in the group.
           Bit g sets the level of GPIO g+1 in the group.

           However  this  may  be modified by the <b>gmask</b>.  A GPIO is only updated if the corresponding bit in the
           mask is 1.

           <b>Example</b>

           $ rgs c 1 ggr 1 22
           4 15
           $ rgs c 1 ggw 1 22 5 15
           $ rgs c 1 ggr 1 22
           4 5
           $ rgs c 1 ggw 1 22 10 0
           $ rgs c 1 ggr 1 22
           4 5
           $ rgs c 1 ggw 1 22 10 15
           $ rgs c 1 ggr 1 22
           4 10

       <b>GP</b> <b>h</b> <b>g</b> <b>mon</b> <b>moff</b> - GPIO tx pulse (simple)

           This command starts software timed pulses on GPIO <b>g</b> .

           Each cycle consists of <b>mon</b> microseconds of GPIO high followed by <b>moff</b> microseconds of GPIO low.

           PWM is characterised by two values, its frequency (number of cycles per second) and  its  duty  cycle
           (percentage of high time per cycle).

           The set frequency will be 1000000 / (mon + moff) Hz.

           The set duty cycle will be mon / (mon + moff) * 100 %.

           E.g.  if  mon is 50 and moff is 100 the frequency will be 6666.67 Hz and the duty cycle will be 33.33
           %.

       <b>GPX</b> <b>h</b> <b>g</b> <b>mon</b> <b>moff</b> <b>off</b> <b>cyc</b> - GPIO tx pulse

           This command starts software timed pulses on GPIO <b>g</b> .

           <b>cyc</b> cycles are transmitted (0 means infinite).  Each cycle consists of <b>mon</b> microseconds of GPIO  high
           followed by <b>moff</b> microseconds of GPIO low.

           PWM  is  characterised  by two values, its frequency (number of cycles per second) and its duty cycle
           (percentage of high time per cycle).

           The set frequency will be 1000000 / (mon + moff) Hz.

           The set duty cycle will be mon / (mon + moff) * 100 %.

           E.g. if mon is 50 and moff is 100 the frequency will be 6666.67 Hz and the duty cycle will  be  33.33
           %.

           <b>off</b> is a microsecond offset from the natural start of the PWM cycle.

           For instance if the PWM frequency is 10 Hz the natural start of each cycle is at seconds 0, then 0.1,
           0.2, 0.3 etc.  In this case if the offset is 20000 microseconds the cycle will start at seconds 0.02,
           0.12, 0.22, 0.32 etc.

           Another command may be issued to the GPIO before the last has finished.

           If  the  last  command had infinite cycles (<b>cyc</b> of 0) then it will be replaced by the new settings at
           the end of the current cycle.  Otherwise it will be replaced by the new settings at the  end  of  <b>cyc</b>
           cycles.

           Multiple pulse settings may be queued in this way.

       <b>P</b> <b>h</b> <b>g</b> <b>pf</b> <b>pdc</b> - GPIO tx PWM (simple)

           This command starts software timed PWM on GPIO <b>g</b> .

           PWM  is  characterised  by two values, its frequency (number of cycles per second) and its duty cycle
           (percentage of high time per cycle).

       <b>PX</b> <b>h</b> <b>g</b> <b>pf</b> <b>pdc</b> <b>off</b> <b>cyc</b> - GPIO tx PWM

           This command starts software timed PWM on GPIO <b>g</b> .

           PWM is characterised by two values, its frequency (number of cycles per second) and  its  duty  cycle
           (percentage of high time per cycle).

           <b>off</b> is a microsecond offset from the natural start of the PWM cycle.

           For instance if the PWM frequency is 10 Hz the natural start of each cycle is at seconds 0, then 0.1,
           0.2, 0.3 etc.  In this case if the offset is 20000 microseconds the cycle will start at seconds 0.02,
           0.12, 0.22, 0.32 etc.

           Another PWM command may be issued to the GPIO before the last has finished.

           If  the  last  PWM had infinite cycles (<b>cyc</b> of 0) then it will be replaced by the new settings at the
           end of the current cycle.  Otherwise it will be replaced by the  new  settings  at  the  end  of  <b>cyc</b>
           cycles.

           Multiple PWM settings may be queued in this way.

       <b>S</b> <b>h</b> <b>g</b> <b>spw</b> - GPIO tx servo pulses (simple)

           This command starts software timed servo pulses on GPIO <b>g</b> .

           I  would only use software timed servo pulses for testing purposes.  The timing jitter will cause the
           servo to fidget.  This may cause it to overheat and wear out prematurely.

       <b>SX</b> <b>h</b> <b>g</b> <b>spw</b> <b>sf</b> <b>off</b> <b>cyc</b> - GPIO tx servo pulses

           This command starts software timed servo pulses on GPIO <b>g</b> .

           I would only use software timed servo pulses for testing purposes.  The timing jitter will cause  the
           servo to fidget.  This may cause it to overheat and wear out prematurely.

           Another servo command may be issued to the GPIO before the last has finished.

           If  the  last  command had infinite cycles (<b>cyc</b> of 0) then it will be replaced by the new settings at
           the end of the current cycle.  Otherwise it will be replaced by the new settings at the  end  of  <b>cyc</b>
           cycles.

           Multiple servo settings may be queued in this way.

       <b>GWAVE</b> <b>h</b> <b>g</b> <b>p*</b> - GPIO group tx wave

           This command starts a wave on GPIO group <b>g</b> .

           <b>p</b> is a series of pulses to be transmitted on the GPIO group.

           Each pulse is defined by the following triplet:

           <b>gbits</b> the levels to set for the selected GPIO
           <b>gmask</b> the GPIO to select
           <b>us</b>    the delay in microseconds before the next pulse

           Another wave command may be issued to the GPIO group before the last has finished transmission.

           Multiple waves may be queued in this way.

       <b>GBUSY</b> <b>h</b> <b>g</b> <b>k</b> - GPIO or group tx busy

           This command checks to see if a specified kind <b>k</b> of transmission is ongoing on a GPIO or GPIO group <b>g</b>
           .

           The command returns 1 if transmission is ongoing, otherwise 0.

       <b>GROOM</b> <b>h</b> <b>g</b> <b>k</b> - GPIO or group tx entries

           This  returns  the  number of slots there are to queue further transmissions of a specified kind <b>k</b> in
           the tx queue for GPIO or GPIO group <b>g</b>.

           The command returns the number of free slots (0 for no free slots).

       <b>GDEB</b> <b>h</b> <b>g</b> <b>us</b> - GPIO debounce time

           This command sets the debounce time for GPIO <b>g</b> to <b>us</b> microseconds.

           This command is only effective when the GPIO is being used as a source of alerts.

           Any level changes shorter than the debounce setting will be discarded, i.e. they will not generate an
           alert.

           Reported level changes will be timestamped <b>us</b> microseconds after the level change.

       <b>GWDOG</b> <b>h</b> <b>g</b> <b>us</b> - GPIO watchdog time

           This command sets the watchdog time for GPIO <b>g</b>
            to <b>us</b> microseconds.

           This only affects alerts.

           A watchdog alert will be sent if no edge alert has been issued for that GPIO in the previous watchdog
           microseconds.

           Note that only one watchdog alert will be sent per stream of edge alerts.  The watchdog is  reset  by
           the sending of a new edge alert.

           The level is set to 2 for a watchdog alert.

   <b>I2C</b>
       <b>I2CO</b> <b>ib</b> <b>id</b> <b>if</b> - I2C open device

           This is a privileged command.  See <b>permits</b>.

           This command returns a handle to access device <b>id</b> on I2C bus <b>ib</b>.  The device is opened with flags <b>if</b>.

           No flags are currently defined.  The parameter <b>if</b> should be 0.

           Upon  success  the  next  free  handle  (&gt;=0)  is  returned.  On error a negative status code will be
           returned.

           <b>Example</b>

           $ rgs c 1 i2co 1 0x70 0 # Bus 1, device 0x70, flags 0.
           0

           $ rgs c 1 i2co 1 0x53 0 # Bus 1, device 0x53, flags 0.
           1

       <b>I2CC</b> <b>h</b> - I2C close device

           This command closes an I2C device previously opened by <b>I2CO</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cc 0 # First close okay.

           $ rgs c 1 i2cc 0 # Second fails.
           -25
           ERROR: unknown handle

       <b>I2CWQ</b> <b>h</b> <b>bit</b> - SMB Write Quick: write bit

           This command writes a single <b>bit</b> to the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cwq 0 1

       <b>I2CRS</b> <b>h</b> - SMB Read Byte: read byte

           This command returns a single byte read from the I2C device.

           Upon success a value between 0 and 255 will be returned.  On error a negative  status  code  will  be
           returned.

           <b>Example</b>

           $ rgs c 1 i2crs 0
           0

       <b>I2CWS</b> <b>h</b> <b>bv</b> - SMB Write Byte: write byte

           This command writes a single byte <b>bv</b> to the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cws 0 0x12

           $ rgs c 1 i2cws 0 0xff
           -82
           ERROR: I2C write failed

       <b>I2CRB</b> <b>h</b> <b>r</b> - SMB Read Byte Data: read byte from register

           This command returns a single byte read from register <b>r</b> of the I2C device.

           Upon  success  a  value  between 0 and 255 will be returned.  On error a negative status code will be
           returned.

           <b>Example</b>

           $ rgs c 1 i2crb 0 0
           6

       <b>I2CWB</b> <b>h</b> <b>r</b> <b>bv</b> - SMB Write Byte Data: write byte to register

           This command writes a single byte <b>bv</b> to register <b>r</b> of the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cwb 0 10 0x54

       <b>I2CRW</b> <b>h</b> <b>r</b> - SMB Read Word Data: read word from register

           This command returns a single 16 bit word read from register <b>r</b> of the I2C device.

           Upon success a value between 0 and 65535 will be returned.  On error a negative status code  will  be
           returned.

           <b>Example</b>

           $ rgs c 1 i2crw 0 0
           6150

       <b>I2CWW</b> <b>h</b> <b>r</b> <b>wv</b> - SMB Write Word Data: write word to register

           This command writes a single 16 bit word <b>wv</b> to register <b>r</b> of the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cww 0 0 0xffff

       <b>I2CRK</b> <b>h</b> <b>r</b> - SMB Read Block Data: read data from register

           This command returns between 1 and 32 bytes read from register <b>r</b> of the I2C device.

           Upon  success  the  count of returned bytes followed by the bytes themselves is returned.  On error a
           negative status code will be returned.

           The number of bytes of returned data is specific to the device and register.

           <b>Example</b>

           $ rgs c 1 i2crk 0 0
           6 0 0 0 0 0 0

           $ rgs c 1 i2crk 0 1
           24 0 0 0 0 0 0 0 0 0 0 0 0 120 222 105 215 128 87 195 217 0 0 0 0

       <b>I2CWK</b> <b>h</b> <b>r</b> <b>bvs</b> - SMB Write Block Data: write data to register

           This command writes between 1 and 32 bytes <b>bvs</b> to register <b>r</b> of the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           rgs c 1 i2cwk 0 4 0x01 0x04 0xc0

       <b>I2CRI</b> <b>h</b> <b>r</b> <b>num</b> - SMB Read I2C Block Data: read bytes from register

           This command returns <b>num</b> bytes from register <b>r</b> of the I2C device.

           Upon success the count of returned bytes followed by the bytes themselves is returned.   On  error  a
           negative status code will be returned.

           The parameter <b>num</b> may be 1-32.

           <b>Example</b>

           $ rgs c 1 i2cri 0 0 16
           16 237 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155

       <b>I2CWI</b> <b>h</b> <b>r</b> <b>bvs</b> - SMB Write I2C Block Data

           This command writes between 1 and 32 bytes <b>bvs</b> to register <b>r</b> of the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cwi 0 4 0x01 0x04 0xc0

       <b>I2CRD</b> <b>h</b> <b>num</b> - I2C read device

           This command returns <b>num</b> bytes read from the I2C device.

           Upon  success  the  count of returned bytes followed by the bytes themselves is returned.  On error a
           negative status code will be returned.

           This command operates on the raw I2C device.  The maximum value of the parameter <b>num</b> is dependent  on
           the I2C drivers and the device itself. rgs imposes a limit of about 8000 bytes.

           <b>Example</b>

           $ rgs c 1 i2crd 0 16
           16 6 24 0 0 0 0 0 0 0 0 0 0 0 0 32 78

       <b>I2CWD</b> <b>h</b> <b>bvs</b> - I2C write device

           This command writes a block of bytes <b>bvs</b> to the I2C device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           The  number  of bytes which may be written in one transaction is dependent on the I2C drivers and the
           device itself.  rgs imposes a limit of about 500 bytes.

           This command operates on the raw I2C device.

           <b>Example</b>

           $ rgs c 1 i2cwd 0 0x01 0x02 0x03 0x04

       <b>I2CPC</b> <b>h</b> <b>r</b> <b>wv</b> - SMB Process Call: exchange register with word

           This command writes <b>wv</b> to register <b>r</b> of the I2C device and  returns  a  16-bit  word  read  from  the
           device.

           Upon  success  a value between 0 and 65535 will be returned.  On error a negative status code will be
           returned.

           <b>Example</b>

           $ rgs c 1 i2cpc 0 37 43210
           39933

           $ rgs c 1 i2cpc 0 256 43210
           ERROR: bad i2c/spi/ser parameter
           -81

       <b>I2CPK</b> <b>h</b> <b>r</b> <b>bvs</b> - SMB Block Process Call: exchange data bytes with register

           This command writes the data bytes <b>bvs</b> to register <b>r</b> of the I2C device and returns a device  specific
           number of bytes.

           Upon  success  the  count of returned bytes followed by the bytes themselves is returned.  On error a
           negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 i2cpk 0 0 0x11 0x12
           6 0 0 0 0 0 0

       <b>I2CZ</b> <b>h</b> <b>bvs</b> - I2C zip

           This command executes a sequence of I2C operations.  The operations to be performed are specified  by
           the contents of <b>bvs</b> which contains the concatenated command codes and associated data.

           The following command codes are supported:

           Name      Cmd &amp; Data   Meaning
           End       0            No more commands
           Escape    1            Next P is two bytes
           Address   2 P          Set I2C address to P
           Flags     3 lsb msb    Set I2C flags to lsb + (msb &lt;&lt; 8)
           Read      4 P          Read P bytes of data
           Write     5 P ...      Write P bytes of data

           The  address,  read,  and write commands take a parameter P.  Normally P is one byte (0-255).  If the
           command is preceded by the Escape command then P  is  two  bytes  (0-65535,  least  significant  byte
           first).

           The  address defaults to that associated with the handle <b>h</b>.  The flags default to 0.  The address and
           flags maintain their previous value until updated.

           <b>Example</b>

           Set address 0x53, write 0x32, read 6 bytes
           Set address 0x1E, write 0x03, read 6 bytes
           Set address 0x68, write 0x1B, read 8 bytes
           End

           2 0x53  5 1 0x32  4 6
           2 0x1E  5 1 0x03  4 6
           2 0x68  5 1 0x1B  4 8
           0

   <b>NOTIFICATIONS</b>
       <b>NO</b>  - Notification open

           This is a privileged command.  See <b>permits</b>.

           This command requests a free notification handle.

           A notification is a method for being notified of GPIO state changes via a pipe.

           Upon success the command returns a handle greater than or equal to zero.  On error a negative  status
           code will be returned.

           The  pipes  are  created  in  the  daemon's  working directory (the command <b>pwd</b> will show the working
           directory).

           Notifications for handle x will be available at the pipe named  .lgd-nfyx  (where  x  is  the  handle
           number).

           E.g. if the command returns 15 then the notifications must be read from .lgd-nfy15.

           <b>Example</b>

           $ rgs c 1 no
           0

       <b>NC</b> <b>h</b> - Notification close

           This command closes a notification previously opened by <b>NO</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 nc 0 # First call succeeds.

           $ rgs c 1 nc 1 # Second call fails.
           -5
           ERROR: unknown handle

       <b>NP</b> <b>h</b> - Notification pause

           This command pauses notifications.

           Upon success nothing is returned.  On error a negative status code will be returned.

           Notifications for the handle are paused until a <b>NR</b> command.

           <b>Example</b>

           $ rgs c 1 np 0

       <b>NR</b> <b>h</b> - Notification resume

           This command resumes notifications.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs c 1 nr 0

           $ rgs c 1 nr 1
           -5
           ERROR: unknown handle

   <b>SCRIPTS</b>
       <b>PROC</b> <b>t</b> - Script store

           This is a privileged command.  See <b>permits</b>.

           This command stores a script <b>t</b> for later execution.

           If  the  script  is valid a handle (&gt;=0) is returned which is passed to the other script commands. On
           error a negative status code will be returned.

           <b>Example</b>

           $ rgs proc tag 123 w 4 0 mils 200 w 4 1 mils 300 dcr p0 jp 123
           0

           $ rgs proc tag 123 w 4 0 mils 5 w 4 1 mils 5 jmp 12
           ERROR: script has unresolved tag
           -63

       <b>PROCR</b> <b>h</b> <b>pars</b> - Script run

           This command runs stored script <b>h</b> passing it up to 10 optional parameters.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs proc tag 123 w 4 0 mils 200 w 4 1 mils 300 dcr p0 jp 123
           0

           $ rgs procr 0 50 # Run script 0 with parameter 0 of 50.

           $ rgs procp 0
           2 44 0 0 0 0 0 0 0 0 0
           $ rgs procp 0
           2 37 0 0 0 0 0 0 0 0 0
           $ rgs procp 0
           2 10 0 0 0 0 0 0 0 0 0
           $ rgs procp 0
           2 5 0 0 0 0 0 0 0 0 0
           $ rgs procp 0
           2 2 0 0 0 0 0 0 0 0 0
           $ rgs procp 0
           1 -1 0 0 0 0 0 0 0 0 0

       <b>PROCU</b> <b>h</b> <b>pars</b> - Script update parameters

           This command sets the parameters of a stored script <b>h</b> passing it up to 10 parameters.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs proc tag 0 hp 18 p0 p1 mils 1000 jmp 0
           0
           $ rgs procu 0 50 500000
           $ rgs procr 0
           $ rgs procu 0 100
           $ rgs procu 0 200
           $ rgs procu 0 200 100000

       <b>PROCP</b> <b>h</b> - Script get status and parameters

           This command returns the status of script <b>h</b> as well as the current value of its 10 parameters.

           Upon success the script status and parameters are  returned.  On error a negative status code will be
           returned.

           The script status may be one of

           0   being initialised
           1   ready
           2   running
           3   waiting
           4   ended
           5   halted
           6   failed

           <b>Example</b>

           $ rgs procp 0
           1 0 0 0 0 0 0 0 0 0 0

       <b>PROCS</b> <b>h</b> - Script stop

           This command stops a running script <b>h</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs procs 0

           $ rgs procs 1
           -5
           ERROR: unknown handle

       <b>PROCD</b> <b>h</b> - Script delete

           This command deletes script <b>h</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs procd 1

           $ rgs procd 1
           ERROR: unknown handle
           -5

       <b>PARSE</b> <b>t</b> - Script validate

           Validates the text <b>t</b> of a script without storing the script.

           Upon success nothing is returned.  On error a list of detected script errors will be given.

           This command may be used to find script syntax faults.

           <b>Example</b>

           $ rgs parse tag 100 w 22 1 mils 200 w 22 0 mils 800 jmp 100

           $ rgs parse tag 0 w 22 1 mills 50 w 22 0 dcr p10 jp 99
           Unknown command: mills
           Unknown command: 50
           Bad parameter to dcr
           Can't resolve tag 99

   <b>SERIAL</b>
       <b>SERO</b> <b>dev</b> <b>b</b> <b>sef</b> - Serial open device

           This is a privileged command.  See <b>permits</b>.

           This command opens the serial <b>dev</b> at <b>b</b> bits per second.

           No flags are currently defined.  <b>sef</b> should be set to zero.

           Upon success a handle (&gt;=0) is returned.  On error a negative status code will be returned.

           The baud rate must be one of 50, 75, 110, 134, 150, 200, 300, 600,  1200,  1800,  2400,  4800,  9600,
           19200, 38400, 57600, 115200, or 230400.

           <b>Example</b>

           $ rgs sero /dev/ttyAMA0 9600 0
           0

           $ rgs sero /dev/tty1 38400 0
           1

       <b>SERC</b> <b>h</b> - Serial close device

           This command closes a serial device previously opened by <b>SERO</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs serc 0 # First close okay.

           $ rgs serc 0 # Second close gives error.
           -25
           ERROR: unknown handle

       <b>SERRB</b>  - Serial read byte

           This command returns a byte of data read from the serial device.

           Upon  success  a  number  between  0  and  255  is returned.  On error a negative status code will be
           returned.

           <b>Example</b>

           $ rgs serrb 0
           23
           $ rgs serrb 0
           45

       <b>SERWB</b> <b>h</b> <b>bv</b> - Serial write byte

           This command writes a single byte <b>bv</b> to the serial device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs serwb 0 23
           $ rgs serwb 0 0xf0

       <b>SERR</b> <b>h</b> <b>num</b> - Serial read bytes

           This command returns up to <b>num</b> bytes of data read from the serial device.

           Upon success the count of returned bytes followed by the bytes themselves is returned.   On  error  a
           negative status code will be returned.

           <b>Example</b>

           $ rgs serr 0 10
           5 48 49 128 144 255

           $ rgs serr 0 10
           0

       <b>SERW</b> <b>h</b> <b>bvs</b> - Serial write bytes

           This command writes bytes <b>bvs</b> to the serial device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs serw 0 23 45 67 89

       <b>SERDA</b> <b>h</b> - Serial data available

           This command returns the number of bytes of data available to be read from the serial device.

           Upon  success  the  count  of  bytes  available  to be read is returned (which may be 0).  On error a
           negative status code will be returned.

           <b>Example</b>

           $ rgs serda 0
           0

   <b>SHELL</b>
       <b>SHELL</b> <b>name</b> <b>str</b> - Execute a shell command

           This is a privileged command.  See <b>permits</b>.

           This command uses the system call to execute a shell script <b>name</b> with the given  string  <b>str</b>  as  its
           parameter.

           Upon success the exit status of the system call is returned.  On error a negative status code will be
           returned.

           <b>name</b>  must  exist  in  a  directory  named  cgi  in  the daemon's configuration directory and must be
           executable.

           The returned exit status is normally 256 times that set by the shell script exit  function.   If  the
           script can't be found 32512 will be returned.

           The following table gives some example returned statuses.

           Script exit status   Returned system call status
           1                    256
           5                    1280
           10                   2560
           200                  51200
           script not found     32512

           <b>Example</b>

           # pass two parameters, hello and world
           $ rgs shell scr1 hello world
           256

           # pass three parameters, hello, string with spaces, and world
           $ rgs shell scr1 "hello 'string with spaces' world"
           256

           # pass one parameter, hello string with spaces world
           $ rgs shell scr1 "
           256

           # non-existent script
           $ rgs shell scr78 par1
           32512

   <b>SPI</b>
       <b>SPIO</b> <b>spd</b> <b>spc</b> <b>b</b> <b>spf</b> - SPI open device

           This is a privileged command.  See <b>permits</b>.

           Upon success a handle is returned.  On error a negative status code will be returned.

           Data  will  be  transferred  at  <b>b</b>  bits per second.  The flags <b>spf</b> may be used to modify the default
           behaviour.

           The flags consists of the least significant 2 bits.

           1  0
           m  m

           mm defines the SPI mode.

           Mode POL PHA
            0    0   0
            1    0   1
            2    1   0
            3    1   1

       <b>SPIC</b> <b>h</b> - SPI close device

           This command closes a SPI device previously opened by <b>SPIO</b>.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs spic 1

           $ rgs spic 1
           -25
           ERROR: unknown handle

       <b>SPIR</b> <b>h</b> <b>num</b> - SPI read bytes

           This command returns <b>num</b> bytes read from the SPI device.

           Upon success the count of returned bytes followed by the bytes themselves is returned.   On  error  a
           negative status code will be returned.

           <b>Example</b>

           $ rgs spir 0 10 # Read 10 bytes from the SPI device.
           10 0 0 0 0 0 0 0 0 0 0

       <b>SPIW</b> <b>h</b> <b>bvs</b> - SPI write bytes

           This command writes bytes <b>bvs</b> to the SPI device.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs spiw 0 0x22 0x33 0xcc 0xff

       <b>SPIX</b> <b>h</b> <b>bvs</b> - SPI transfer bytes

           This command writes bytes <b>bvs</b> to the SPI device.

           It returns the same number of bytes read from the device.

           Upon  success  the  count of returned bytes followed by the bytes themselves is returned.  On error a
           negative status code will be returned.

           <b>Example</b>

           $ rgs spix 0 0x22 0x33 0xcc 0xff
           4 0 0 0 0

   <b>UTILITIES</b>
       <b>LGV</b>  - Get lg library version

           This command returns the lg library version.

           <b>Example</b>

           $ rgs lgv
           lg_0.1.0.0

       <b>SBC</b>  - Get SBC's host name

           This command returns the rgpiod daemon server name.

           <b>Example</b>

           $ rgs sbc
           venus

       <b>CGI</b> <b>cid</b> - Get internal configuration setting

           This is a privileged command.  See <b>permits</b>.

           This command returns the value of an internal library configuration setting <b>cid</b>.

           <b>Example</b>

           $ rgs cgi 0
           1

       <b>CSI</b> <b>cid</b> <b>v</b> - Set internal configuration setting

           This is a privileged command.  See <b>permits</b>.

           This command sets the value of the internal library configuration setting <b>cid</b> to <b>v</b>.

           <b>Example</b>

           $ rgs csi 0 3
           $ rgs cgi 0
           3

       <b>T/TICK</b>  - Get nanoseconds since the epoch

           T and TICK are synonyms.

           This command returns the number of nanoseconds since the epoch (start of 1970).

           <b>Example</b>

           $ rgs t
           1601838936723095901
           $ rgs tick
           1601838940792322758

       <b>MICS</b> <b>v</b> - Microseconds delay

           This command delays execution for <b>v</b> microseconds.

           Upon success nothing is returned.  On error a negative status code will be returned.

           The main use of this command is expected to be within scripts.

           <b>Example</b>

           $ rgs mics 20      # Delay 20 microseconds.
           $ rgs mics 1000000 # Delay 1 second.
           $ rgs mics 5100000 # Delay 5.1 seconds.
           -24
           ERROR: bad MICS delay (too large)

       <b>MILS</b> <b>v</b> - Milliseconds delay

           This command delays execution for <b>v</b> milliseconds.

           Upon success nothing is returned.  On error a negative status code will be returned.

           <b>Example</b>

           $ rgs mils   2000 # Delay 2 seconds.
           $ rgs mils 301000 # Delay 301 seconds.
           -25
           ERROR: bad MILS delay (too large)

       <b>U/USER</b>  - Set user

           U and USER are synonyms.

           This command sets the current user and associated permissions.

           <b>Example</b>

           $ rgs u test1   # set user test1
           $ rgs user test1 # set user test1
           $ rgs u testx    # unknown user
           -95
           ERROR: bad secret for user

       <b>C/SHARE</b>  - Set share

           C and SHARE are synonyms.

           This command sets the share for handles.

           The command has two uses.  Firstly it sets the share id for any subsequently created handles  on  the
           current  command line.  Secondly it sets the share id to use to access any previously created handles
           on this or earlier command lines.

           <b>Example</b>

           rgs c 1       # use share id 1
           rgs share 1   # use share id 1
           rgs c 0       # switch off sharing
           rgs share 867 # use share id 867

       <b>LCFG</b>  - Reload permits configuration file

           This is a privileged command.  See <b>permits</b>.

           This command reloads the permits configuration file

           <b>Example</b>

           $ rgs lcfg
           $ rgs lcfg
           -93
           ERROR: no permission to perform action
           $ rgs lcfg
           -93
           ERROR: no permission to perform action

       <b>PCD</b>  - Print daemon configuration directory

           This command prints the daemon configuration directory

           <b>Example</b>

           rgs pcd
           /home/joan/LG/TEST

       <b>PWD</b>  - Print daemon working directory

           This command prints the daemon working directory

           <b>Example</b>

           rgs pwd
           /home/joan/LG

</pre><h4><b>PARAMETERS</b></h4><pre>
       <b>b</b>: baud
       The command expects the baud rate in bits per second for the transmission of serial data  (I2C/SPI/serial
       link, waves).

       <b>bit</b>: bit value (0-1)
       The command expects 0 or 1.

       <b>bv</b>: a byte value (0-255)
       The command expects a byte value.

       <b>bvs</b>: byte values (0-255)
       The command expects one or more byte values.

       <b>cid</b>:
       A number identifying an internal configuration item.

       cid   meaning
       0     debug level
       1     minimum transmission period for PWM and waves

       <b>cyc</b>: &gt;= 0
       The number of PWM pulses to generate.  A value of 0 means infinite.

       <b>dev</b>: a tty serial device
       The command expects the name of a serial device, e.g.

       /dev/ttyAMA0
       /dev/ttyUSB0
       /dev/tty0
       /dev/serial0

       <b>ef</b>: GPIO event flags

       The following values may be or'd to form the event flags.

       Value   Meaning
       1       Rising edge
       2       Falling edge
       3       Both edges

       <b>file</b>: a file name
       The file name must match an entry in the [files] section of the permits file.

       <b>from</b>: 0-2
       Position to seek from <b>FS</b>.

           From
       0   start
       1   current position
       2   end

       <b>g</b>: GPIO
       The command expects a GPIO.

       <b>g*</b>:
       A list of one or more GPIO

       <b>gbits</b>:
       This value is used to set the levels of a GPIO group.

       Bit 0 represents the level of the group leader.
       Bit 1 represents the level of the second GPIO in the group.
       Bit g represents the level of GPIO g+1 in the group.

       <b>gc</b>: gpiochip (&gt;=0)
       The command expects a gpiochip number.

       <b>gmask</b>:
       This value is used to select GPIO from a GPIO group.

       Bit 0 of the mask indicates item 1
       Bit 1 of the mask indicates item 2
       Bit g of the mask indicates item g+1

       For example suppose the items are GPIO 5, 10, 23, 25, 11.

       Bit 0 of the mask indicates GPIO 5
       Bit 1 of the mask indicates GPIO 10
       Bit 2 of the mask indicates GPIO 23
       Bit 3 of the mask indicates GPIO 25
       Bit 4 of the mask indicates GPIO 11

       If a bit of the mask is high the corresponding GPIO will be selected.

       E.g. in the above example if the mask has the value 17 GPIO 5 and GPIO 11 will be selected.

       <b>h</b>: handle (&gt;=0)
       The command expects a handle.

       A handle is a number referencing an object opened by one of <b>FO</b>, <b>I2CO</b>, <b>NO</b>, <b>PROC</b>, <b>SERO</b>, <b>SPIO</b>, <b>GO</b>.

       <b>ib</b>: I2C bus (&gt;=0)
       The command expects an I2C bus number.

       <b>id</b>: I2C device (0-0x7F)
       The command expects the address of an I2C device.

       <b>if</b>: I2C flags (0)
       The command expects an I2C flags value.  No flags are currently defined.

       <b>k</b>:
       A kind of transmission.

       0 = PWM
       1 = WAVE

       <b>lf</b>: GPIO line flags

       The following values may be or'd to form the line flags.

       Value   Meaning
       4       Active low
       8       Open drain
       16      Open source
       32      Pull up
       64      Pull down
       128     Pull none

       <b>mode</b>: lgFile open mode
       One of the following values.

               Value   Meaning
       READ      1     open file for reading
       WRITE     2     open file for writing
       RW        3     open file for reading and writing

       The following values can be or'd into the mode.

                Value   Meaning
       APPEND   4       All writes append data to the end of the file
       CREATE   8       The file is created if it doesn't exist
       TRUNC    16      The file is truncated

       <b>moff</b>: &gt;= 0
       The off period for a PWM pulse in microseconds.

       <b>mon</b>: &gt;= 0
       The on period for a PWM pulse in microseconds.

       <b>name</b>: the name of a script

       Only alphanumeric characters, '-' and '_' are allowed in the name.

       <b>nfyh</b>: &gt;= 0

       This associates a notification with a GPIO event.

       <b>num</b>: maximum number of bytes to return (1-)
       The command expects the maximum number of bytes to return.

       For the I2C and SPI commands the requested number of bytes will always be returned.

       For  the  serial  and file commands the smaller of the number of bytes available to be read (which may be
       zero) and <b>num</b> bytes will be returned.

       <b>off</b>: &gt;= 0

       The offset in microseconds from the nominal PWM pulse start.

       <b>p*</b>:
       One or more triplets of <b>gbits</b>, <b>gmask</b>, and <b>us</b> microsecond delay.

       <b>pars</b>: script parameters
       The command expects 0 to 10 numbers as parameters to be passed to the script.

       <b>pat</b>: a file name pattern
       A file path which may contain wildcards.  To be accessible the path must match an entry  in  the  [files]
       section of the permits file.

       <b>pdc</b>: %
       PWM duty cycle between 0.0 % and 100 % inclusive.

       <b>pf</b>: Hz
       PWM frequency between 0.1 Hz and 10000 Hz inclusive.  Use  0 for off.

       <b>r</b>: register (0-255)
       The command expects an I2C register number.

       <b>sef</b>: serial flags (32 bits)
       The command expects a flag value.  No serial flags are currently defined.

       <b>sf</b>: Hz (40-500)
       Servo frequency

       <b>spc</b>: SPI channel (&gt;= 0)
       The command expects a SPI channel.

       <b>spd</b>: SPI device (&gt;= 0)
       The command expects a SPO device.

       <b>spf</b>: SPI flags
       See <b>SPIO</b>.

       <b>spw</b>: 0=off, 500-2500 microseconds
       Servo pulse width

       <b>str</b>: a string
       The command expects a string.

       <b>t</b>: a string
       The command expects a string.

       <b>us</b>:
       The command expects a time interval measured in microseconds.

       <b>v</b>: value
       The command expects a number.

       <b>v*</b>:
       A list of one or more values.

       <b>wv</b>: word value (0-65535)
       The command expects a word value.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/rgpiod.1.html">rgpiod</a>(1), <a href="../man3/lgpio.3.html">lgpio</a>(3), <a href="../man3/rgpio.3.html">rgpio</a>(3)

Linux                                               2020-2021                                             <u><a href="../man1/rgs.1.html">rgs</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>