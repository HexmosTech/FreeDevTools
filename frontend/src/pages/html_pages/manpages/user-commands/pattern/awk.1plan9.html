<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>awk - pattern-directed scanning and processing language</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/9base">9base_6-14_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       awk - pattern-directed scanning and processing language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>awk</b> [ <b>-F</b><u>fs</u> ] [ <b>-v</b> <u>var=value</u> ] [ <b>-mr</b><u>n</u> ] [ <b>-mf</b><u>n</u> ] [ <b>-f</b> <u>prog</u> [ <u>prog</u> ] [ <u>file</u> <u>...</u>  ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Awk</u> scans each input <u>file</u> for lines that match any of a set of patterns specified literally in <u>prog</u> or in
       one or more files specified as <b>-f</b> <u>file</u>.  With each pattern there can be an associated action that will be
       performed when a line of a <u>file</u> matches the pattern.  Each line is matched against the pattern portion of
       every  pattern-action  statement;  the associated action is performed for each matched pattern.  The file
       name means the standard input.  Any <u>file</u> of the form <u>var=value</u> is treated as an assignment,  not  a  file
       name,  and  is  executed  at  the  time  it would have been opened if it were a file name.  The option <b>-v</b>
       followed by <u>var=value</u> is an assignment to be done before <u>prog</u> is executed; any number of <b>-v</b>  options  may
       be present.  <b>-F</b> <u>fs</u> option defines the input field separator to be the regular expression <u>fs</u>.

       An  input  line is normally made up of fields separated by white space, or by regular expression <b>FS</b>.  The
       fields are denoted <b>$1</b>, <b>$2</b>, ..., while <b>$0</b> refers to the entire line.  If <b>FS</b> is null,  the  input  line  is
       split into one field per character.

       To  compensate for inadequate implementation of storage management, the <b>-mr</b> option can be used to set the
       maximum size of the input record, and the <b>-mf</b> option to set the maximum number of fields.

       A pattern-action statement has the form

              <u>pattern</u> <b>{</b> <u>action</u> <b>}</b>

       A missing <b>{</b> <u>action</u> <b>}</b> means print the line; a missing pattern always matches.   Pattern-action  statements
       are separated by newlines or semicolons.

       An action is a sequence of statements.  A statement can be one of the following:

       if( <u>expression</u> ) <u>statement</u> [ else <u>statement</u> ]
       while( <u>expression</u> ) <u>statement</u>
       for( <u>expression</u> ; <u>expression</u> ; <u>expression</u> ) <u>statement</u>
       for( <u>var</u> in <u>array</u> ) <u>statement</u>
       do <u>statement</u> while( <u>expression</u> )
       break
       continue
       { [ <u>statement</u> <u>...</u> ] }
       <u>expression</u>              # commonly <u>var</u> <u>=</u> <u>expression</u>
       print [ <u>expression-list</u> ] [ &gt; <u>expression</u> ]
       printf <u>format</u> [ , <u>expression-list</u> ] [ &gt; <u>expression</u> ]
       return [ <u>expression</u> ]
       next                    # skip remaining patterns on this input line
       nextfile                # skip rest of this file, open next, start at top
       delete <u>array</u>[ <u>expression</u> ]# delete an array element
       delete <u>array</u>            # delete all elements of array
       exit [ <u>expression</u> ]     # exit immediately; status is <u>expression</u>

       Statements  are  terminated by semicolons, newlines or right braces.  An empty <u>expression-list</u> stands for
       <b>$0</b>.  String constants are quoted " ", with the usual C escapes recognized within.   Expressions  take  on
       string  or numeric values as appropriate, and are built using the operators <b>+</b> <b>-</b> <b>*</b> <b>/</b> <b>%</b> <b>^</b> (exponentiation),
       and concatenation (indicated by white space).  The operators <b>!</b> <b>++</b> <b>--</b> <b>+=</b> <b>-=</b> <b>*=</b> <b>/=</b> <b>%=</b> <b>^=</b> <b>&gt;</b> <b>&gt;=</b> <b>&lt;</b> <b>&lt;=</b> <b>==</b> <b>!=</b> <b>?:</b>
       are also available in expressions.  Variables may be scalars, array elements (denoted  <u>x</u><b>[</b><u>i</u><b>]</b><u>)</u>  or  fields.
       Variables  are  initialized  to  the  null  string.   Array subscripts may be any string, not necessarily
       numeric; this allows for a  form  of  associative  memory.   Multiple  subscripts  such  as  <b>[i,j,k]</b>  are
       permitted; the constituents are concatenated, separated by the value of <b>SUBSEP</b>.

       The  <b>print</b>  statement  prints  its  arguments  on the standard output (or on a file if <b>&gt;</b><u>file</u> or <b>&gt;&gt;</b><u>file</u> is
       present or on a pipe if <b>|</b><u>cmd</u> is present), separated by the current output field separator, and terminated
       by the output record separator.  <u>file</u>  and  <u>cmd</u>  may  be  literal  names  or  parenthesized  expressions;
       identical  string values in different statements denote the same open file.  The <b>printf</b> statement formats
       its expression list according to the format (see <u><a href="../man2/fprintf.2.html">fprintf</a></u>(2))<u>.</u>  The built-in function  <b>close(</b><u>expr</u><b>)</b>  closes
       the  file  or  pipe <u>expr</u>.  The built-in function <b>fflush(</b><u>expr</u><b>)</b> flushes any buffered output for the file or
       pipe <u>expr</u>.

       The mathematical functions <b>exp</b>, <b>log</b>, <b>sqrt</b>, <b>sin</b>, <b>cos</b>, and <b>atan2</b> are built in.  Other built-in functions:

       <b>length</b> the length of its argument taken as a string, or of <b>$0</b> if no argument.

       <b>rand</b>   random number on (0,1)

       <b>srand</b>  sets seed for <b>rand</b> and returns the previous seed.

       <b>int</b>    truncates to an integer value

       <b>utf</b>    converts its numerical argument, a character number, to a UTF string

       <b>substr(</b><u>s</u><b>,</b> <u>m</u><b>,</b> <u>n)</u>
              the <u>n</u>-character substring of <u>s</u> that begins at position <u>m</u> counted from 1.

       <b>index(</b><u>s</u><b>,</b> <u>t</u><b>)</b>
              the position in <u>s</u> where the string <u>t</u> occurs, or 0 if it does not.

       <b>match(</b><u>s</u><b>,</b> <u>r</u><b>)</b>
              the position in <u>s</u> where the regular expression <u>r</u> occurs, or 0  if  it  does  not.   The  variables
              <b>RSTART</b> and <b>RLENGTH</b> are set to the position and length of the matched string.

       <b>split(</b><u>s</u><b>,</b> <u>a</u><b>,</b> <u>fs)</u>
              splits  the  string <u>s</u> into array elements <u>a</u><b>[1]</b>, <u>a</u><b>[2]</b>, ..., <u>a</u><b>[</b><u>n</u><b>]</b>, and returns <u>n</u>.  The separation is
              done with the regular expression <u>fs</u> or with the field separator <b>FS</b> if <u>fs</u> is not given.   An  empty
              string as field separator splits the string into one array element per character.

       <b>sub(</b><u>r</u><b>,</b> <u>t</u><b>,</b> <u>s)</u>
              substitutes  <u>t</u>  for the first occurrence of the regular expression <u>r</u> in the string <u>s</u>.  If <u>s</u> is not
              given, <b>$0</b> is used.

       <b>gsub</b>   same as <b>sub</b> except that all occurrences of the regular  expression  are  replaced;  <b>sub</b>  and  <b>gsub</b>
              return the number of replacements.

       <b>sprintf(</b><u>fmt</u><b>,</b> <u>expr</u><b>,</b> <u>...)</u>
              the string resulting from formatting <u>expr</u> <u>...</u>  according to the <u>printf</u> format <u>fmt</u>

       <b>system(</b><u>cmd</u><b>)</b>
              executes <u>cmd</u> and returns its exit status

       <b>tolower(</b><u>str</u><b>)</b>
              returns  a copy of <u>str</u> with all upper-case characters translated to their corresponding lower-case
              equivalents.

       <b>toupper(</b><u>str</u><b>)</b>
              returns a copy of <u>str</u> with all lower-case characters translated to their corresponding  upper-case
              equivalents.

       The ``function'' <b>getline</b> sets <b>$0</b> to the next input record from the current input file; <b>getline</b> <b>&lt;</b><u>file</u> sets
       <b>$0</b>  to  the  next record from <u>file</u>.  <b>getline</b> <u>x</u> sets variable <u>x</u> instead.  Finally, <u>cmd</u> <b>|</b> <b>getline</b> pipes the
       output of <u>cmd</u> into <b>getline</b>; each call of <b>getline</b> returns the next line of output from <u>cmd</u>.  In all cases,
       <b>getline</b> returns 1 for a successful input, 0 for end of file, and -1 for an error.

       Patterns are arbitrary Boolean combinations  (with  <b>!</b>  <b>||</b>  <b>&amp;&amp;</b>)  of  regular  expressions  and  relational
       expressions.   Regular  expressions are as in <u><a href="../man6/regexp.6.html">regexp</a></u>(6).  Isolated regular expressions in a pattern apply
       to the entire line.  Regular expressions may also occur in relational expressions, using the operators  <b>~</b>
       and  <b>!~</b>.   <b>/</b><u>re</u><b>/</b>  is  a  constant  regular  expression; any string (constant or variable) may be used as a
       regular expression, except in the position of an isolated regular expression in a pattern.

       A pattern may consist of two patterns separated by a comma; in this case, the action is performed for all
       lines from an occurrence of the first pattern though an occurrence of the second.

       A relational expression is one of the following:

              <u>expression</u> <u>matchop</u> <u>regular-expression</u>
              <u>expression</u> <u>relop</u> <u>expression</u>
              <u>expression</u> <b>in</b> <u>array-name</u>
              <b>(</b><u>expr</u><b>,</b><u>expr,...</u><b>)</b> <b>in</b> <u>array-name</u>

       where a <u>relop</u> is any of the six relational operators in C, and a <u>matchop</u> is  either  <b>~</b>  (matches)  or  <b>!~</b>
       (does  not  match).   A  conditional  is  an arithmetic expression, a relational expression, or a Boolean
       combination of these.

       The special patterns <b>BEGIN</b> and <b>END</b> may be used to capture control before the first input line is read and
       after the last.  <b>BEGIN</b> and <b>END</b> do not combine with other patterns.

       Variable names with special meanings:

       <b>CONVFMT</b>
              conversion format used when converting numbers (default <b>%.6g</b>)

       <b>FS</b>     regular expression used to separate fields; also settable by option <b>-F</b><u>fs</u>.

       <b>NF</b>     number of fields in the current record

       <b>NR</b>     ordinal number of the current record

       <b>FNR</b>    ordinal number of the current record in the current file

       <b>FILENAME</b>
              the name of the current input file

       <b>RS</b>     input record separator (default newline)

       <b>OFS</b>    output field separator (default blank)

       <b>ORS</b>    output record separator (default newline)

       <b>OFMT</b>   output format for numbers (default <b>%.6g</b>)

       <b>SUBSEP</b> separates multiple subscripts (default 034)

       <b>ARGC</b>   argument count, assignable

       <b>ARGV</b>   argument array, assignable; non-null members are taken as file names

       <b>ENVIRON</b>
              array of environment variables; subscripts are names.

       Functions may be defined (at the position of a pattern-action statement) thus:

              function foo(a, b, c) { ...; return x }

       Parameters are passed by value if scalar and  by  reference  if  array  name;  functions  may  be  called
       recursively.  Parameters are local to the function; all other variables are global.  Thus local variables
       may be created by providing excess parameters in the function definition.

</pre><h4><b>EXAMPLES</b></h4><pre>
       length($0) &gt; 72
              Print lines longer than 72 characters.

       { print $2, $1 }
              Print first two fields in opposite order.

       BEGIN { FS = ",[ \t]*|[ \t]+" }
             { print $2, $1 }
              Same, with input fields separated by comma and/or blanks and tabs.

            { s += $1 }
       END  { print "sum is", s, " average is", s/NR }
              Add up first column, print sum and average.

       /start/, /stop/
              Print all lines between start/stop pairs.

       BEGIN     {    # Simulate <a href="../man1/echo.1.html">echo</a>(1)
            for (i = 1; i &lt; ARGC; i++) printf "%s ", ARGV[i]
            printf "\n"
            exit }

</pre><h4><b>SOURCE</b></h4><pre>
       <b>/sys/src/cmd/awk</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/sed.1.html">sed</a></u>(1), <u><a href="../man6/regexp.6.html">regexp</a></u>(6),
       A.  V.  Aho, B. W. Kernighan, P. J. Weinberger, <u>The</u> <u>AWK</u> <u>Programming</u> <u>Language,</u> Addison-Wesley, 1988.  ISBN
       0-201-07981-X

</pre><h4><b>BUGS</b></h4><pre>
       There are no explicit conversions between numbers and strings.  To force an expression to be treated as a
       number add 0 to it; to force it to be treated as a string concatenate "" to it.
       The scope rules for variables in functions are a botch; the syntax is worse.

                                                                                                     <u><a href="../man1plan9/AWK.1plan9.html">AWK</a></u>(1plan9)
</pre>
 </div>
</div></section>
</div>
</body>
</html>