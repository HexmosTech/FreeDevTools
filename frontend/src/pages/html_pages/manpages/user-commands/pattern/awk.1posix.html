<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix">manpages-posix_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       awk — pattern scanning and processing language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       awk <b>[</b>-F <u>sepstring</u><b>]</b> <b>[</b>-v <u>assignment</u><b>]</b>... <u>program</u> <b>[</b><u>argument</u>...<b>]</b>

       awk <b>[</b>-F <u>sepstring</u><b>]</b> -f <u>progfile</u> <b>[</b>-f <u>progfile</u><b>]</b>... <b>[</b>-v <u>assignment</u><b>]</b>...
            <b>[</b><u>argument</u>...<b>]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>awk</u> utility shall execute programs written in the <u>awk</u> programming language, which is specialized for
       textual data manipulation. An <u>awk</u> program is a sequence of patterns and corresponding actions. When input
       is read that matches a pattern, the action associated with that pattern is carried out.

       Input shall be interpreted as a sequence of records. By default, a record is a line, less its terminating
       &lt;newline&gt;, but this can be changed by using the <b>RS</b> built-in variable.  Each  record  of  input  shall  be
       matched  in  turn  against  each  pattern in the program. For each pattern matched, the associated action
       shall be executed.

       The <u>awk</u> utility shall interpret each input record as a sequence of fields where, by default, a field is a
       string of non-&lt;blank&gt; non-&lt;newline&gt; characters. This default &lt;blank&gt; and &lt;newline&gt; field delimiter can be
       changed by using the <b>FS</b> built-in variable or the <b>-F</b> <u>sepstring</u> option. The <u>awk</u> utility  shall  denote  the
       first  field  in  a  record $1, the second $2, and so on. The symbol $0 shall refer to the entire record;
       setting any other field causes the re-evaluation of $0. Assigning to $0 shall reset  the  values  of  all
       other fields and the <b>NF</b> built-in variable.

</pre><h4><b>OPTIONS</b></h4><pre>
       The  <u>awk</u>  utility  shall  conform  to  the Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>12.2</u>, <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>.

       The following options shall be supported:

       <b>-F</b> <u>sepstring</u>
                 Define the input field separator. This option shall be equivalent to:

                     -v FS=<u>sepstring</u>

                 except that if <b>-F</b> <u>sepstring</u> and <b>-v</b> FS=<u>sepstring</u> are both used, it is unspecified whether the <b>FS</b>
                 assignment resulting from <b>-F</b> <u>sepstring</u> is processed in command line order or is processed after
                 the last <b>-v</b> FS=<u>sepstring</u>.  See the description of the <b>FS</b> built-in variable, and how it is used,
                 in the EXTENDED DESCRIPTION section.

       <b>-f</b> <u>progfile</u>
                 Specify the pathname of the file <u>progfile</u> containing an <u>awk</u> program. A pathname  of  <b>'-'</b>  shall
                 denote   the  standard  input.  If  multiple  instances  of  this  option  are  specified,  the
                 concatenation of the files specified as <u>progfile</u> in  the  order  specified  shall  be  the  <u>awk</u>
                 program.  The  <u>awk</u>  program  can  alternatively  be  specified  in the command line as a single
                 argument.

       <b>-v</b> <u>assignment</u>
                 The application shall ensure that the <u>assignment</u> argument is in the same form as an  <u>assignment</u>
                 operand.  The  specified  variable  assignment  shall occur prior to executing the <u>awk</u> program,
                 including the actions associated with <b>BEGIN</b> patterns (if any).  Multiple  occurrences  of  this
                 option can be specified.

</pre><h4><b>OPERANDS</b></h4><pre>
       The following operands shall be supported:

       <u>program</u>   If  no  <b>-f</b>  option is specified, the first operand to <u>awk</u> shall be the text of the <u>awk</u> program.
                 The application shall supply the <u>program</u> operand as a single argument to <u>awk</u>.  If the text does
                 not end in a &lt;newline&gt;, <u>awk</u> shall interpret the text as if it did.

       <u>argument</u>  Either of the following two types of <u>argument</u> can be intermixed:

                 <u>file</u>      A pathname of a file that contains the input to be read, which is matched against the
                           set of patterns in the program. If no <u>file</u> operands  are  specified,  or  if  a  <u>file</u>
                           operand is <b>'-'</b>, the standard input shall be used.

                 <u>assignment</u>
                           An operand that begins with an &lt;underscore&gt; or alphabetic character from the portable
                           character  set (see the table in the Base Definitions volume of POSIX.1‐2017, <u>Section</u>
                           <u>6.1</u>, <u>Portable</u> <u>Character</u> <u>Set</u>), followed by a  sequence  of  underscores,  digits,  and
                           alphabetics  from  the  portable  character set, followed by the <b>'='</b> character, shall
                           specify a variable assignment rather than a pathname.  The characters before the  <b>'='</b>
                           represent  the  name  of  an  <u>awk</u> variable; if that name is an <u>awk</u> reserved word (see
                           <u>Grammar</u>) the behavior is undefined. The characters following the &lt;equals-sign&gt;  shall
                           be  interpreted  as  if  they  appeared in the <u>awk</u> program preceded and followed by a
                           double-quote (<b>'"'</b>) character, as a <b>STRING</b> token (see <u>Grammar</u>),  except  that  if  the
                           last  character  is  an  unescaped  &lt;backslash&gt;, it shall be interpreted as a literal
                           &lt;backslash&gt; rather than as the first character of the sequence  <b>"\""</b>.   The  variable
                           shall  be  assigned  the  value  of  that  <b>STRING</b> token and, if appropriate, shall be
                           considered a <u>numeric</u> <u>string</u> (see <u>Expressions</u> <u>in</u> <u>awk</u>),  the  variable  shall  also  be
                           assigned  its  numeric value. Each such variable assignment shall occur just prior to
                           the processing of the following <u>file</u>, if any. Thus, an assignment  before  the  first
                           <u>file</u> argument shall be executed after the <b>BEGIN</b> actions (if any), while an assignment
                           after  the  last  <u>file</u> argument shall occur before the <b>END</b> actions (if any). If there
                           are no <u>file</u> arguments, assignments shall be executed before processing  the  standard
                           input.

</pre><h4><b>STDIN</b></h4><pre>
       The  standard input shall be used only if no <u>file</u> operands are specified, or if a <u>file</u> operand is <b>'-'</b>, or
       if a <u>progfile</u> option-argument is <b>'-'</b>; see the INPUT FILES section. If the <u>awk</u> program contains no actions
       and no patterns, but is otherwise a valid <u>awk</u> program, standard input and any <u>file</u> operands shall not  be
       read and <u>awk</u> shall exit with a return status of zero.

</pre><h4><b>INPUT</b> <b>FILES</b></h4><pre>
       Input files to the <u>awk</u> program from any of the following sources shall be text files:

        *  Any <u>file</u> operands or their equivalents, achieved by modifying the <u>awk</u> variables <b>ARGV</b> and <b>ARGC</b>

        *  Standard input in the absence of any <u>file</u> operands

        *  Arguments to the <b>getline</b> function

       Whether the variable <b>RS</b> is set to a value other than a &lt;newline&gt; or not, for these files, implementations
       shall  support  records  terminated  with  the specified separator up to {LINE_MAX} bytes and may support
       longer records.

       If <b>-f</b> <u>progfile</u> is specified, the application shall ensure that the files named by each  of  the  <u>progfile</u>
       option-arguments  are  text  files  and  their  concatenation,  in  the  same order as they appear in the
       arguments, is an <u>awk</u> program.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       The following environment variables shall affect the execution of <u>awk</u>:

       <u>LANG</u>      Provide a default value for the internationalization variables that are unset or null. (See the
                 Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>8.2</u>, <u>Internationalization</u>  <u>Variables</u>  for  the
                 precedence   of   internationalization  variables  used  to  determine  the  values  of  locale
                 categories.)

       <u>LC_ALL</u>    If set to a non-empty string value, override the values of all the  other  internationalization
                 variables.

       <u>LC_COLLATE</u>
                 Determine  the  locale  for  the  behavior  of ranges, equivalence classes, and multi-character
                 collating elements within regular expressions and in comparisons of string values.

       <u>LC_CTYPE</u>  Determine the locale for the interpretation of sequences of bytes of text  data  as  characters
                 (for  example,  single-byte  as opposed to multi-byte characters in arguments and input files),
                 the behavior of character classes within regular expressions, the identification of  characters
                 as  letters,  and the mapping of uppercase and lowercase characters for the <b>toupper</b> and <b>tolower</b>
                 functions.

       <u>LC_MESSAGES</u>
                 Determine the locale that should be used to  affect  the  format  and  contents  of  diagnostic
                 messages written to standard error.

       <u>LC_NUMERIC</u>
                 Determine  the  radix  character  used  when interpreting numeric input, performing conversions
                 between numeric and string values, and formatting numeric output.  Regardless  of  locale,  the
                 &lt;period&gt;  character  (the  decimal-point  character  of  the POSIX locale) is the decimal-point
                 character recognized  in  processing  <u>awk</u>  programs  (including  assignments  in  command  line
                 arguments).

       <u>NLSPATH</u>   Determine the location of message catalogs for the processing of <u>LC_MESSAGES</u>.

       <u>PATH</u>      Determine  the  search  path  when  looking for commands executed by <u>system</u>(<u>expr</u>), or input and
                 output pipes;  see  the  Base  Definitions  volume  of  POSIX.1‐2017,  <u>Chapter</u>  <u>8</u>,  <u>Environment</u>
                 <u>Variables</u>.

       In addition, all environment variables shall be visible via the <u>awk</u> variable <b>ENVIRON</b>.

</pre><h4><b>ASYNCHRONOUS</b> <b>EVENTS</b></h4><pre>
       Default.

</pre><h4><b>STDOUT</b></h4><pre>
       The nature of the output files depends on the <u>awk</u> program.

</pre><h4><b>STDERR</b></h4><pre>
       The standard error shall be used only for diagnostic messages.

</pre><h4><b>OUTPUT</b> <b>FILES</b></h4><pre>
       The nature of the output files depends on the <u>awk</u> program.

</pre><h4><b>EXTENDED</b> <b>DESCRIPTION</b></h4><pre>
   <b>Overall</b> <b>Program</b> <b>Structure</b>
       An <u>awk</u> program is composed of pairs of the form:

           <u>pattern</u> { <u>action</u> }

       Either the pattern or the action (including the enclosing brace characters) can be omitted.

       A missing pattern shall match any record of input, and a missing action shall be equivalent to:

           { print }

       Execution  of  the  <u>awk</u>  program  shall  start  by  first executing the actions associated with all <b>BEGIN</b>
       patterns in the order they occur in the program. Then each <u>file</u> operand (or standard input  if  no  files
       were specified) shall be processed in turn by reading data from the file until a record separator is seen
       (&lt;newline&gt;  by  default).  Before  the  first reference to a field in the record is evaluated, the record
       shall be split into fields, according to the rules in <u>Regular</u> <u>Expressions</u>, using the value of <b>FS</b> that was
       current at the time the record was read. Each pattern in the program then shall be evaluated in the order
       of occurrence, and the action associated with each pattern that matches the current record executed.  The
       action  for  a  matching  pattern  shall  be executed before evaluating subsequent patterns. Finally, the
       actions associated with all <b>END</b> patterns shall be executed in the order they occur in the program.

   <b>Expressions</b> <b>in</b> <b>awk</b>
       Expressions describe computations used in <u>patterns</u> and <u>actions</u>.  In the following table, valid expression
       operations are given in groups from highest precedence first  to  lowest  precedence  last,  with  equal-
       precedence  operators  grouped  between  horizontal lines. In expression evaluation, where the grammar is
       formally ambiguous, higher precedence operators shall be evaluated before lower precedence operators.  In
       this  table  <u>expr</u>,  <u>expr1</u>,  <u>expr2</u>, and <u>expr3</u> represent any expression, while lvalue represents any entity
       that can be assigned to (that is, on the left side of an assignment operator).   The  precise  syntax  of
       expressions is given in <u>Grammar</u>.

                                <b>Table</b> <b>4-1:</b> <b>Expressions</b> <b>in</b> <b>Decreasing</b> <b>Precedence</b> <b>in</b> <u>awk</u>
                  ┌──────────────────────┬─────────────────────────┬────────────────┬──────────────┐
                  │        <b>Syntax</b>        │          <b>Name</b>           │ <b>Type</b> <b>of</b> <b>Result</b> │<b>Associativity</b> │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ ( <u>expr</u> )             │Grouping                 │Type of <u>expr</u>    │N/A           │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ $<u>expr</u>                │Field reference          │String          │N/A           │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ lvalue ++            │Post-increment           │Numeric         │N/A           │
                  │ lvalue --            │Post-decrement           │Numeric         │N/A           │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ ++ lvalue            │Pre-increment            │Numeric         │N/A           │
                  │ -- lvalue            │Pre-decrement            │Numeric         │N/A           │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> ^ <u>expr</u>          │Exponentiation           │Numeric         │Right         │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ ! <u>expr</u>               │Logical not              │Numeric         │N/A           │
                  │ + <u>expr</u>               │Unary plus               │Numeric         │N/A           │
                  │ - <u>expr</u>               │Unary minus              │Numeric         │N/A           │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> * <u>expr</u>          │Multiplication           │Numeric         │Left          │
                  │ <u>expr</u> / <u>expr</u>          │Division                 │Numeric         │Left          │
                  │ <u>expr</u> % <u>expr</u>          │Modulus                  │Numeric         │Left          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> + <u>expr</u>          │Addition                 │Numeric         │Left          │
                  │ <u>expr</u> - <u>expr</u>          │Subtraction              │Numeric         │Left          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> <u>expr</u>            │String concatenation     │String          │Left          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> &lt; <u>expr</u>          │Less than                │Numeric         │None          │
                  │ <u>expr</u> &lt;= <u>expr</u>         │Less than or equal to    │Numeric         │None          │
                  │ <u>expr</u> != <u>expr</u>         │Not equal to             │Numeric         │None          │
                  │ <u>expr</u> == <u>expr</u>         │Equal to                 │Numeric         │None          │
                  │ <u>expr</u> &gt; <u>expr</u>          │Greater than             │Numeric         │None          │
                  │ <u>expr</u> &gt;= <u>expr</u>         │Greater than or equal to │Numeric         │None          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> ~ <u>expr</u>          │ERE match                │Numeric         │None          │
                  │ <u>expr</u> !~ <u>expr</u>         │ERE non-match            │Numeric         │None          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> in array        │Array membership         │Numeric         │Left          │
                  │ ( <u>index</u> ) in <u>array</u>   │Multi-dimension array    │Numeric         │Left          │
                  │                      │membership               │                │              │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> &amp;&amp; <u>expr</u>         │Logical AND              │Numeric         │Left          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr</u> || <u>expr</u>         │Logical OR               │Numeric         │Left          │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ <u>expr1</u> ? <u>expr2</u> : <u>expr3</u>│Conditional expression   │Type of selected│Right         │
                  │                      │                         │<u>expr2</u> or <u>expr3</u>  │              │
                  ├──────────────────────┼─────────────────────────┼────────────────┼──────────────┤
                  │ lvalue ^= <u>expr</u>       │Exponentiation assignment│Numeric         │Right         │
                  │ lvalue %= <u>expr</u>       │Modulus assignment       │Numeric         │Right         │
                  │ lvalue *= <u>expr</u>       │Multiplication assignment│Numeric         │Right         │
                  │ lvalue /= <u>expr</u>       │Division assignment      │Numeric         │Right         │
                  │ lvalue += <u>expr</u>       │Addition assignment      │Numeric         │Right         │
                  │ lvalue -= <u>expr</u>       │Subtraction assignment   │Numeric         │Right         │
                  │ lvalue = <u>expr</u>        │Assignment               │Type of <u>expr</u>    │Right         │
                  └──────────────────────┴─────────────────────────┴────────────────┴──────────────┘

       Each expression shall have either a string value, a numeric value, or both. Except as stated for specific
       contexts,  the value of an expression shall be implicitly converted to the type needed for the context in
       which it is used. A string value shall be converted to a numeric value either by the  equivalent  of  the
       following calls to functions defined by the ISO C standard:

           setlocale(LC_NUMERIC, "");
           <u>numeric_value</u> = atof(<u>string_value</u>);

       or by converting the initial portion of the string to type <b>double</b> representation as follows:

              The input string is decomposed into two parts: an initial, possibly empty, sequence of white-space
              characters  (as  specified  by  <u>isspace</u>())  and a subject sequence interpreted as a floating-point
              constant.

              The expected form of the subject sequence is an  optional  <b>'+'</b>  or  <b>'-'</b>  sign,  then  a  non-empty
              sequence  of  digits optionally containing a &lt;period&gt;, then an optional exponent part. An exponent
              part consists of <b>'e'</b> or <b>'E'</b>, followed by an optional sign, followed by one or more decimal digits.

              The sequence starting with the first digit or the &lt;period&gt; (whichever occurs first) is interpreted
              as a floating constant of the C language, and if neither an exponent part nor a &lt;period&gt;  appears,
              a  &lt;period&gt; is assumed to follow the last digit in the string. If the subject sequence begins with
              a &lt;hyphen-minus&gt;, the value resulting from the conversion is negated.

       A numeric value that is exactly equal to the value of an integer (see  <u>Section</u>  <u>1.1.2</u>,  <u>Concepts</u>  <u>Derived</u>
       <u>from</u>  <u>the</u>  <u>ISO</u>  <u>C</u>  <u>Standard</u>)  shall  be  converted to a string by the equivalent of a call to the <b>sprintf</b>
       function (see <u>String</u> <u>Functions</u>) with the string <b>"%d"</b> as the <u>fmt</u> argument  and  the  numeric  value  being
       converted  as the first and only <u>expr</u> argument. Any other numeric value shall be converted to a string by
       the equivalent of a call to the <b>sprintf</b> function with the value  of  the  variable  <b>CONVFMT</b>  as  the  <u>fmt</u>
       argument  and  the  numeric  value being converted as the first and only <u>expr</u> argument. The result of the
       conversion is unspecified if the value of <b>CONVFMT</b> is not  a  floating-point  format  specification.  This
       volume  of POSIX.1‐2017 specifies no explicit conversions between numbers and strings. An application can
       force an expression to be treated as a number by adding zero to it, or can force it to be  treated  as  a
       string by concatenating the null string (<b>""</b>) to it.

       A string value shall be considered a <u>numeric</u> <u>string</u> if it comes from one of the following:

        1. Field variables

        2. Input from the <u>getline</u>() function

        3. <b>FILENAME</b>

        4. <b>ARGV</b> array elements

        5. <b>ENVIRON</b> array elements

        6. Array elements created by the <u>split</u>() function

        7. A command line variable assignment

        8. Variable assignment from another numeric string variable

       and an implementation-dependent condition corresponding to either case (a) or (b) below is met.

        a. After   the  equivalent  of  the  following  calls  to  functions  defined  by  the  ISO C  standard,
           <u>string_value_end</u> would differ from <u>string_value</u>, and  any  characters  before  the  terminating  null
           character in <u>string_value_end</u> would be &lt;blank&gt; characters:

               char *string_value_end;
               setlocale(LC_NUMERIC, "");
               numeric_value = strtod (string_value, &amp;string_value_end);

        b. After  all  the  following  conversions  have  been  applied, the resulting string would lexically be
           recognized as a <b>NUMBER</b> token as described by the lexical conventions in <u>Grammar</u>:

           --  All leading and trailing &lt;blank&gt; characters are discarded.

           --  If the first non-&lt;blank&gt; is <b>'+'</b> or <b>'-'</b>, it is discarded.

           --  Each occurrence of the decimal point character from the current locale is changed to a &lt;period&gt;.
       In case (a) the numeric value of the <u>numeric</u> <u>string</u> shall be the value that  would  be  returned  by  the
       <u>strtod</u>() call. In case (b) if the first non-&lt;blank&gt; is <b>'-'</b>, the numeric value of the <u>numeric</u> <u>string</u> shall
       be  the negation of the numeric value of the recognized <b>NUMBER</b> token; otherwise, the numeric value of the
       <u>numeric</u> <u>string</u> shall be the numeric value of the recognized <b>NUMBER</b> token. Whether or not a  string  is  a
       <u>numeric</u> <u>string</u> shall be relevant only in contexts where that term is used in this section.

       When  an  expression  is  used  in a Boolean context, if it has a numeric value, a value of zero shall be
       treated as false and any other value shall be treated as true. Otherwise, a  string  value  of  the  null
       string  shall  be treated as false and any other value shall be treated as true.  A Boolean context shall
       be one of the following:

        *  The first subexpression of a conditional expression

        *  An expression operated on by logical NOT, logical AND, or logical OR

        *  The second expression of a <b>for</b> statement

        *  The expression of an <b>if</b> statement

        *  The expression of the <b>while</b> clause in either a <b>while</b> or <b>do</b>...<b>while</b> statement

        *  An expression used as a pattern (as in Overall Program Structure)

       All arithmetic shall follow the semantics of floating-point arithmetic as specified by the ISO C standard
       (see <u>Section</u> <u>1.1.2</u>, <u>Concepts</u> <u>Derived</u> <u>from</u> <u>the</u> <u>ISO</u> <u>C</u> <u>Standard</u>).

       The value of the expression:

           <u>expr1</u> ^ <u>expr2</u>

       shall be equivalent to the value returned by the ISO C standard function call:

           pow(<u>expr1</u>, <u>expr2</u>)

       The expression:

           lvalue ^= <u>expr</u>

       shall be equivalent to the ISO C standard expression:

           lvalue = pow(lvalue, <u>expr</u>)

       except that lvalue shall be evaluated only once. The value of the expression:

           <u>expr1</u> % <u>expr2</u>

       shall be equivalent to the value returned by the ISO C standard function call:

           fmod(<u>expr1</u>, <u>expr2</u>)

       The expression:

           lvalue %= <u>expr</u>

       shall be equivalent to the ISO C standard expression:

           lvalue = fmod(lvalue, <u>expr</u>)

       except that lvalue shall be evaluated only once.

       Variables and fields shall be set by the assignment statement:

           lvalue = <u>expression</u>

       and the type of <u>expression</u> shall determine the resulting  variable  type.  The  assignment  includes  the
       arithmetic  assignments  (<b>"+="</b>,  <b>"-="</b>,  <b>"*="</b>,  <b>"/="</b>, <b>"%="</b>, <b>"^="</b>, <b>"++"</b>, <b>"--"</b>) all of which shall produce a
       numeric result. The left-hand side of an assignment and the target of increment and  decrement  operators
       can be one of a variable, an array with index, or a field selector.

       The  <u>awk</u>  language  supplies  arrays  that  are  used for storing numbers or strings.  Arrays need not be
       declared. They shall initially be empty, and their sizes shall change  dynamically.  The  subscripts,  or
       element  identifiers,  are  strings,  providing  a  type  of  associative array capability. An array name
       followed by a subscript within square brackets can be used as an lvalue and thus  as  an  expression,  as
       described  in  the  grammar;  see  <u>Grammar</u>.   Unsubscripted array names can be used in only the following
       contexts:

        *  A parameter in a function definition or function call

        *  The <b>NAME</b> token following any use of the keyword <b>in</b> as specified in the grammar (see <u>Grammar</u>); if  the
           name used in this context is not an array name, the behavior is undefined

       A  valid  array  <u>index</u>  shall consist of one or more &lt;comma&gt;-separated expressions, similar to the way in
       which multi-dimensional arrays are indexed in some programming languages. Because <u>awk</u> arrays  are  really
       one-dimensional, such a &lt;comma&gt;-separated list shall be converted to a single string by concatenating the
       string  values  of  the  separate  expressions,  each separated from the other by the value of the <b>SUBSEP</b>
       variable. Thus, the following two index operations shall be equivalent:

           <u>var</u><b>[</b><u>expr1</u>, <u>expr2</u>, ... <u>exprn</u><b>]</b>

           <u>var</u><b>[</b><u>expr1</u> SUBSEP <u>expr2</u> SUBSEP ... SUBSEP <u>exprn</u><b>]</b>

       The application shall ensure that a multi-dimensioned <u>index</u> used with the <b>in</b> operator  is  parenthesized.
       The  <b>in</b>  operator,  which  tests  for  the  existence of a particular array element, shall not cause that
       element to exist. Any other reference to a nonexistent array element shall automatically create it.

       Comparisons (with the <b>'&lt;'</b>, <b>"&lt;="</b>, <b>"!="</b>, <b>"=="</b>, <b>'&gt;'</b>, and <b>"&gt;="</b> operators) shall be made numerically  if  both
       operands  are numeric, if one is numeric and the other has a string value that is a numeric string, or if
       one is numeric and the other has the uninitialized value.  Otherwise,  operands  shall  be  converted  to
       strings as required and a string comparison shall be made as follows:

        *  For  the  <b>"!="</b>  and <b>"=="</b> operators, the strings should be compared to check if they are identical but
           may be compared using the locale-specific collation sequence to check if they collate equally.

        *  For the other operators, the strings shall be compared using the locale-specific collation sequence.

       The value of the comparison expression shall be 1 if the relation is true, or 0 if the relation is false.

   <b>Variables</b> <b>and</b> <b>Special</b> <b>Variables</b>
       Variables can be used in an <u>awk</u> program by referencing them. With the exception  of  function  parameters
       (see  <u>User-Defined</u>  <u>Functions</u>), they are not explicitly declared. Function parameter names shall be local
       to the function; all other variable names shall be global. The same name shall not  be  used  as  both  a
       function  parameter name and as the name of a function or a special <u>awk</u> variable. The same name shall not
       be used both as a variable name with global scope and as the name of a function. The same name shall  not
       be  used  within  the  same  scope  both  as a scalar variable and as an array.  Uninitialized variables,
       including scalar variables, array elements, and field variables, shall have an  uninitialized  value.  An
       uninitialized  value  shall  have  both  a  numeric value of zero and a string value of the empty string.
       Evaluation of variables with an uninitialized value, to either string or numeric, shall be determined  by
       the context in which they are used.

       Field  variables shall be designated by a <b>'$'</b> followed by a number or numerical expression. The effect of
       the field number <u>expression</u> evaluating to anything other than  a  non-negative  integer  is  unspecified;
       uninitialized  variables  or  string  values need not be converted to numeric values in this context. New
       field variables can be created by assigning a value to them. References to nonexistent fields  (that  is,
       fields  after  $<b>NF</b>),  shall  evaluate  to  the  uninitialized value. Such references shall not create new
       fields. However, assigning to a nonexistent field (for example, $(<b>NF</b>+2)=5) shall increase  the  value  of
       <b>NF</b>;  create  any  intervening  fields  with  the  uninitialized  value;  and  cause the value of $0 to be
       recomputed, with the fields being separated by the value of <b>OFS</b>.  Each field variable shall have a string
       value or an uninitialized value when created. Field variables shall have  the  uninitialized  value  when
       created  from  $0  using  <b>FS</b>  and the variable does not contain any characters. If appropriate, the field
       variable shall be considered a numeric string (see <u>Expressions</u> <u>in</u> <u>awk</u>).

       Implementations shall support the following other special variables that are set by <u>awk</u>:

       <b>ARGC</b>      The number of elements in the <b>ARGV</b> array.

       <b>ARGV</b>      An array of command line arguments, excluding options and the <u>program</u> argument,  numbered  from
                 zero to <b>ARGC</b>-1.

                 The  arguments  in  <b>ARGV</b>  can  be modified or added to; <b>ARGC</b> can be altered. As each input file
                 ends, <u>awk</u> shall treat the next non-null element of <b>ARGV</b>, up to the  current  value  of  <b>ARGC</b>-1,
                 inclusive,  as  the name of the next input file. Thus, setting an element of <b>ARGV</b> to null means
                 that it shall not be treated as an input file. The name <b>'-'</b> indicates the standard input. If an
                 argument matches the format of an <u>assignment</u> operand, this argument  shall  be  treated  as  an
                 <u>assignment</u> rather than a <u>file</u> argument.

       <b>CONVFMT</b>   The  <b>printf</b>  format for converting numbers to strings (except for output statements, where <b>OFMT</b>
                 is used); <b>"%.6g"</b> by default.

       <b>ENVIRON</b>   An array representing the value of the environment, as described in the <u>exec</u> functions  defined
                 in  the  System  Interfaces  volume  of POSIX.1‐2017. The indices of the array shall be strings
                 consisting of the names of the environment variables, and the value of each array element shall
                 be a string consisting of the value of that variable. If appropriate, the environment  variable
                 shall  be  considered  a  <u>numeric</u> <u>string</u> (see <u>Expressions</u> <u>in</u> <u>awk</u>); the array element shall also
                 have its numeric value.

                 In all cases where the behavior of <u>awk</u> is affected  by  environment  variables  (including  the
                 environment  of  any  commands  that  <u>awk</u>  executes  via  the  <b>system</b>  function or via pipeline
                 redirections with the <b>print</b> statement, the <b>printf</b> statement,  or  the  <b>getline</b>  function),  the
                 environment   used   shall  be  the  environment  at  the  time  <u>awk</u>  began  executing;  it  is
                 implementation-defined whether any modification of <b>ENVIRON</b> affects this environment.

       <b>FILENAME</b>  A pathname of the current input file. Inside a <b>BEGIN</b> action the value is undefined.  Inside  an
                 <b>END</b> action the value shall be the name of the last input file processed.

       <b>FNR</b>       The  ordinal  number of the current record in the current file. Inside a <b>BEGIN</b> action the value
                 shall be zero. Inside an <b>END</b> action the value shall be the number of the last record  processed
                 in the last file processed.

       <b>FS</b>        Input field separator regular expression; a &lt;space&gt; by default.

       <b>NF</b>        The  number  of fields in the current record. Inside a <b>BEGIN</b> action, the use of <b>NF</b> is undefined
                 unless a <b>getline</b> function without a <u>var</u> argument is executed previously. Inside an <b>END</b>  action,
                 <b>NF</b>  shall  retain  the  value it had for the last record read, unless a subsequent, redirected,
                 <b>getline</b> function without a <u>var</u> argument is performed prior to entering the <b>END</b> action.

       <b>NR</b>        The ordinal number of the current record from the start of input.  Inside a  <b>BEGIN</b>  action  the
                 value  shall  be  zero.  Inside  an <b>END</b> action the value shall be the number of the last record
                 processed.

       <b>OFMT</b>      The <b>printf</b>  format  for  converting  numbers  to  strings  in  output  statements  (see  <u>Output</u>
                 <u>Statements</u>);  <b>"%.6g"</b>  by  default.  The result of the conversion is unspecified if the value of
                 <b>OFMT</b> is not a floating-point format specification.

       <b>OFS</b>       The <b>print</b> statement output field separator; &lt;space&gt; by default.

       <b>ORS</b>       The <b>print</b> statement output record separator; a &lt;newline&gt; by default.

       <b>RLENGTH</b>   The length of the string matched by the <b>match</b> function.

       <b>RS</b>        The first character of the string value of <b>RS</b> shall be the input record separator; a  &lt;newline&gt;
                 by default. If <b>RS</b> contains more than one character, the results are unspecified. If <b>RS</b> is null,
                 then records are separated by sequences consisting of a &lt;newline&gt; plus one or more blank lines,
                 leading  or  trailing  blank lines shall not result in empty records at the beginning or end of
                 the input, and a &lt;newline&gt; shall always be a field separator, no matter what the  value  of  <b>FS</b>
                 is.

       <b>RSTART</b>    The starting position of the string matched by the <b>match</b> function, numbering from 1. This shall
                 always be equivalent to the return value of the <b>match</b> function.

       <b>SUBSEP</b>    The   subscript   separator   string   for  multi-dimensional  arrays;  the  default  value  is
                 implementation-defined.

   <b>Regular</b> <b>Expressions</b>
       The <u>awk</u> utility shall make use of the extended regular expression  notation  (see  the  Base  Definitions
       volume  of POSIX.1‐2017, <u>Section</u> <u>9.4</u>, <u>Extended</u> <u>Regular</u> <u>Expressions</u>) except that it shall allow the use of
       C-language conventions for escaping special characters within the EREs, as specified in the table in  the
       Base  Definitions  volume of POSIX.1‐2017, <u>Chapter</u> <u>5</u>, <u>File</u> <u>Format</u> <u>Notation</u> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>,
       <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>) and the following table; these escape sequences shall be  recognized  both  inside  and
       outside  bracket  expressions. Note that records need not be separated by &lt;newline&gt; characters and string
       constants can contain &lt;newline&gt; characters, so even the <b>"\n"</b> sequence is  valid  in  <u>awk</u>  EREs.  Using  a
       &lt;slash&gt; character within an ERE requires the escaping shown in the following table.

                                          <b>Table</b> <b>4-2:</b> <b>Escape</b> <b>Sequences</b> <b>in</b> <u>awk</u>
                ┌──────────┬────────────────────────────────────┬────────────────────────────────────┐
                │  <b>Escape</b>  │                                    │                                    │
                │ <b>Sequence</b> │            <b>Description</b>             │              <b>Meaning</b>               │
                ├──────────┼────────────────────────────────────┼────────────────────────────────────┤
                │ \"       │ &lt;backslash&gt; &lt;quotation-mark&gt;       │ &lt;quotation-mark&gt; character         │
                ├──────────┼────────────────────────────────────┼────────────────────────────────────┤
                │ \/       │ &lt;backslash&gt; &lt;slash&gt;                │ &lt;slash&gt; character                  │
                ├──────────┼────────────────────────────────────┼────────────────────────────────────┤
                │ \ddd     │ A &lt;backslash&gt; character followed   │ The character whose encoding is    │
                │          │ by the longest sequence of one,    │ represented by the one, two, or    │
                │          │ two, or three octal-digit          │ three-digit octal integer. Multi-  │
                │          │ characters (01234567). If all of   │ byte characters require multiple,  │
                │          │ the digits are 0 (that is,         │ concatenated escape sequences of   │
                │          │ representation of the NUL          │ this type, including the leading   │
                │          │ character), the behavior is        │ &lt;backslash&gt; for each byte.         │
                │          │ undefined.                         │                                    │
                ├──────────┼────────────────────────────────────┼────────────────────────────────────┤
                │ \c       │ A &lt;backslash&gt; character followed   │ Undefined                          │
                │          │ by any character not described in  │                                    │
                │          │ this table or in the table in the  │                                    │
                │          │ Base Definitions volume of         │                                    │
                │          │ POSIX.1‐2017, <u>Chapter</u> <u>5</u>, <u>File</u>      │                                    │
                │          │ <u>Format</u> <u>Notation</u> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, │                                    │
                │          │ <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>).     │                                    │
                └──────────┴────────────────────────────────────┴────────────────────────────────────┘

       A  regular  expression  can be matched against a specific field or string by using one of the two regular
       expression matching operators, <b>'~'</b> and <b>"!~"</b>.  These operators shall interpret their right-hand operand as
       a regular expression and their left-hand operand as a string.  If  the  regular  expression  matches  the
       string,  the  <b>'~'</b>  expression shall evaluate to a value of 1, and the <b>"!~"</b> expression shall evaluate to a
       value of 0. (The regular expression matching operation is as defined by the  term  matched  in  the  Base
       Definitions  volume of POSIX.1‐2017, <u>Section</u> <u>9.1</u>, <u>Regular</u> <u>Expression</u> <u>Definitions</u>, where a match occurs on
       any part of the string unless the regular expression is limited with the  &lt;circumflex&gt;  or  &lt;dollar-sign&gt;
       special  characters.)  If  the  regular  expression  does  not match the string, the <b>'~'</b> expression shall
       evaluate to a value of 0, and the <b>"!~"</b> expression shall evaluate to a  value  of  1.  If  the  right-hand
       operand  is  any expression other than the lexical token <b>ERE</b>, the string value of the expression shall be
       interpreted as an extended regular expression, including the escape conventions  described  above.   Note
       that  these  same  escape  conventions shall also be applied in determining the value of a string literal
       (the lexical token <b>STRING</b>), and thus shall be applied a second time when a string literal is used in this
       context.

       When an <b>ERE</b> token appears as an expression in any context other than as the right-hand of the <b>'~'</b> or <b>"!~"</b>
       operator or as one of the built-in function  arguments  described  below,  the  value  of  the  resulting
       expression shall be the equivalent of:

           $0 ~ /<u>ere</u>/

       The <u>ere</u> argument to the <b>gsub</b>, <b>match</b>, <b>sub</b> functions, and the <u>fs</u> argument to the <b>split</b> function (see <u>String</u>
       <u>Functions</u>)  shall  be  interpreted  as  extended  regular  expressions. These can be either <b>ERE</b> tokens or
       arbitrary expressions, and shall be interpreted in the same manner as the right-hand side of the  <b>'~'</b>  or
       <b>"!~"</b> operator.

       An  extended  regular  expression  can  be  used  to separate fields by assigning a string containing the
       expression to the built-in variable <b>FS</b>, either directly or as a consequence of  using  the  <b>-F</b>  <u>sepstring</u>
       option.   The  default  value  of  the <b>FS</b> variable shall be a single &lt;space&gt;.  The following describes <b>FS</b>
       behavior:

        1. If <b>FS</b> is a null string, the behavior is unspecified.

        2. If <b>FS</b> is a single character:

            a. If <b>FS</b> is &lt;space&gt;, skip leading and trailing &lt;blank&gt; and &lt;newline&gt;  characters;  fields  shall  be
               delimited by sets of one or more &lt;blank&gt; or &lt;newline&gt; characters.

            b. Otherwise, if <b>FS</b> is any other character <u>c</u>, fields shall be delimited by each single occurrence of
               <u>c</u>.

        3. Otherwise,  the  string  value  of  <b>FS</b> shall be considered to be an extended regular expression. Each
           occurrence of a sequence matching the extended regular expression shall delimit fields.

       Except for the <b>'~'</b> and <b>"!~"</b> operators, and in the <b>gsub</b>, <b>match</b>, <b>split</b>, and  <b>sub</b>  built-in  functions,  ERE
       matching  shall  be  based on input records; that is, record separator characters (the first character of
       the value of the variable <b>RS</b>, &lt;newline&gt; by  default)  cannot  be  embedded  in  the  expression,  and  no
       expression  shall  match  the  record  separator  character.  If  the  record separator is not &lt;newline&gt;,
       &lt;newline&gt; characters embedded in the expression can be matched. For the <b>'~'</b> and <b>"!~"</b>  operators,  and  in
       those  four  built-in  functions,  ERE  matching  shall  be based on text strings; that is, any character
       (including &lt;newline&gt; and the record separator) can be embedded in the pattern, and an appropriate pattern
       shall match any character. However, in all <u>awk</u> ERE matching, the use of one or more NUL characters in the
       pattern, input record, or text string produces undefined results.

   <b>Patterns</b>
       A <u>pattern</u> is any valid <u>expression</u>, a range specified by two expressions separated by a comma, or  one  of
       the two special patterns <b>BEGIN</b> or <b>END</b>.

   <b>Special</b> <b>Patterns</b>
       The <u>awk</u> utility shall recognize two special patterns, <b>BEGIN</b> and <b>END</b>.  Each <b>BEGIN</b> pattern shall be matched
       once  and  its associated action executed before the first record of input is read—except possibly by use
       of the <b>getline</b> function (see <u>Input/Output</u> <u>and</u> <u>General</u> <u>Functions</u>)  in  a  prior  <b>BEGIN</b>  action—and  before
       command  line  assignment  is  done.  Each  <b>END</b>  pattern  shall be matched once and its associated action
       executed after the last record of input has been read. These two patterns shall have associated actions.

       <b>BEGIN</b> and <b>END</b> shall not combine with other patterns. Multiple <b>BEGIN</b> and <b>END</b> patterns  shall  be  allowed.
       The  actions  associated with the <b>BEGIN</b> patterns shall be executed in the order specified in the program,
       as are the <b>END</b> actions. An <b>END</b> pattern can precede a <b>BEGIN</b> pattern in a program.

       If an <u>awk</u> program consists of only actions with the pattern <b>BEGIN</b>,  and  the  <b>BEGIN</b>  action  contains  no
       <b>getline</b>  function,  <u>awk</u>  shall  exit  without reading its input when the last statement in the last <b>BEGIN</b>
       action is executed. If an <u>awk</u> program consists of only actions with the pattern <b>END</b> or only actions  with
       the  patterns  <b>BEGIN</b>  and  <b>END</b>,  the  input  shall  be  read before the statements in the <b>END</b> actions are
       executed.

   <b>Expression</b> <b>Patterns</b>
       An expression pattern shall be evaluated as if it were an expression in a Boolean context. If the  result
       is  true, the pattern shall be considered to match, and the associated action (if any) shall be executed.
       If the result is false, the action shall not be executed.

   <b>Pattern</b> <b>Ranges</b>
       A pattern range consists of two expressions separated by a comma; in  this  case,  the  action  shall  be
       performed  for  all records between a match of the first expression and the following match of the second
       expression, inclusive. At this point, the pattern  range  can  be  repeated  starting  at  input  records
       subsequent to the end of the matched range.

   <b>Actions</b>
       An  action  is  a sequence of statements as shown in the grammar in <u>Grammar</u>.  Any single statement can be
       replaced by a statement list enclosed in curly braces. The application shall ensure that statements in  a
       statement list are separated by &lt;newline&gt; or &lt;semicolon&gt; characters. Statements in a statement list shall
       be executed sequentially in the order that they appear.

       The  <u>expression</u>  acting as the conditional in an <b>if</b> statement shall be evaluated and if it is non-zero or
       non-null, the following statement shall be  executed;  otherwise,  if  <b>else</b>  is  present,  the  statement
       following the <b>else</b> shall be executed.

       The  <b>if</b>,  <b>while</b>,  <b>do</b>...<b>while</b>,  <b>for</b>,  <b>break</b>,  and <b>continue</b> statements are based on the ISO C standard (see
       <u>Section</u> <u>1.1.2</u>, <u>Concepts</u> <u>Derived</u> <u>from</u> <u>the</u> <u>ISO</u> <u>C</u> <u>Standard</u>), except that the Boolean  expressions  shall  be
       treated as described in <u>Expressions</u> <u>in</u> <u>awk</u>, and except in the case of:

           for (<u>variable</u> in <u>array</u>)

       which  shall  iterate,  assigning each <u>index</u> of <u>array</u> to <u>variable</u> in an unspecified order. The results of
       adding new elements to <u>array</u> within such a <b>for</b> loop are undefined.  If  a  <b>break</b>  or  <b>continue</b>  statement
       occurs outside of a loop, the behavior is undefined.

       The <b>delete</b> statement shall remove an individual array element. Thus, the following code deletes an entire
       array:

           for (index in array)
               delete array[index]

       The  <b>next</b>  statement  shall cause all further processing of the current input record to be abandoned. The
       behavior is undefined if a <b>next</b> statement appears or is invoked in a <b>BEGIN</b> or <b>END</b> action.

       The <b>exit</b> statement shall invoke all <b>END</b> actions in the order in which they occur in  the  program  source
       and  then  terminate  the  program  without reading further input. An <b>exit</b> statement inside an <b>END</b> action
       shall terminate the program without further execution of <b>END</b> actions. If an expression is specified in an
       <b>exit</b> statement, its numeric value shall  be  the  exit  status  of  <u>awk</u>,  unless  subsequent  errors  are
       encountered or a subsequent <b>exit</b> statement with an expression is executed.

   <b>Output</b> <b>Statements</b>
       Both  <b>print</b>  and <b>printf</b> statements shall write to standard output by default. The output shall be written
       to the location specified by <u>output_redirection</u> if one is supplied, as follows:

           &gt; <u>expression</u>
           &gt;&gt; <u>expression</u>
           | <u>expression</u>

       In all cases, the <u>expression</u> shall be evaluated to produce a string that is used as a pathname into which
       to write (for <b>'&gt;'</b> or <b>"&gt;&gt;"</b>) or as a command to be executed (for <b>'|'</b>).  Using the first two forms,  if  the
       file of that name is not currently open, it shall be opened, creating it if necessary and using the first
       form,  truncating  the  file.  The output then shall be appended to the file. As long as the file remains
       open, subsequent calls in which <u>expression</u> evaluates to the same string value shall simply append  output
       to  the  file. The file remains open until the <b>close</b> function (see <u>Input/Output</u> <u>and</u> <u>General</u> <u>Functions</u>) is
       called with an expression that evaluates to the same string value.

       The third form shall write output onto a stream piped to the input of a  command.  The  stream  shall  be
       created  if  no  stream  is  currently  open with the value of <u>expression</u> as its command name. The stream
       created shall be equivalent to one created by a call to  the  <u>popen</u>()  function  defined  in  the  System
       Interfaces  volume  of POSIX.1‐2017 with the value of <u>expression</u> as the <u>command</u> argument and a value of <u>w</u>
       as the <u>mode</u> argument. As long as the stream remains open, subsequent calls in which <u>expression</u>  evaluates
       to  the  same  string value shall write output to the existing stream. The stream shall remain open until
       the <b>close</b> function (see <u>Input/Output</u> <u>and</u> <u>General</u> <u>Functions</u>) is called with an expression  that  evaluates
       to  the  same  string  value.   At  that time, the stream shall be closed as if by a call to the <u>pclose</u>()
       function defined in the System Interfaces volume of POSIX.1‐2017.

       As described in detail by the grammar in <u>Grammar</u>, these output statements shall take a  &lt;comma&gt;-separated
       list of <u>expression</u>s referred to in the grammar by the non-terminal symbols <b>expr_list</b>, <b>print_expr_list</b>, or
       <b>print_expr_list_opt</b>.   This  list is referred to here as the <u>expression</u> <u>list</u>, and each member is referred
       to as an <u>expression</u> <u>argument</u>.

       The <b>print</b> statement shall write the value of each expression argument onto the  indicated  output  stream
       separated  by  the  current output field separator (see variable <b>OFS</b> above), and terminated by the output
       record separator (see variable <b>ORS</b> above). All expression arguments shall  be  taken  as  strings,  being
       converted  if  necessary; this conversion shall be as described in <u>Expressions</u> <u>in</u> <u>awk</u>, with the exception
       that the <b>printf</b> format in <b>OFMT</b> shall be used instead of the value in <b>CONVFMT</b>.  An empty  expression  list
       shall stand for the whole input record ($0).

       The <b>printf</b> statement shall produce output based on a notation similar to the File Format Notation used to
       describe  file  formats  in this volume of POSIX.1‐2017 (see the Base Definitions volume of POSIX.1‐2017,
       <u>Chapter</u> <u>5</u>, <u>File</u> <u>Format</u> <u>Notation</u>).  Output shall be  produced  as  specified  with  the  first  <u>expression</u>
       argument as the string <u>format</u> and subsequent <u>expression</u> arguments as the strings <u>arg1</u> to <u>argn</u>, inclusive,
       with the following exceptions:

        1. The  <u>format</u> shall be an actual character string rather than a graphical representation. Therefore, it
           cannot contain empty character positions. The &lt;space&gt; in the <u>format</u> string, in any context other than
           a <u>flag</u> of a conversion specification, shall be treated as an ordinary character that is copied to the
           output.

        2. If the character set contains a <b>'</b>' character and that character appears  in  the  <u>format</u>  string,  it
           shall be treated as an ordinary character that is copied to the output.

        3. The <u>escape</u> <u>sequences</u> beginning with a &lt;backslash&gt; character shall be treated as sequences of ordinary
           characters  that  are  copied  to  the  output.  Note  that these same sequences shall be interpreted
           lexically by <u>awk</u> when they appear in literal strings, but they shall not be treated specially by  the
           <b>printf</b> statement.

        4. A  <u>field</u>  <u>width</u> or <u>precision</u> can be specified as the <b>'*'</b> character instead of a digit string. In this
           case the next argument from the expression list shall be fetched and its numeric value taken  as  the
           field width or precision.

        5. The implementation shall not precede or follow output from the <b>d</b> or <b>u</b> conversion specifier characters
           with &lt;blank&gt; characters not specified by the <u>format</u> string.

        6. The  implementation  shall  not precede output from the <b>o</b> conversion specifier character with leading
           zeros not specified by the <u>format</u> string.

        7. For the <b>c</b> conversion specifier character: if the argument has a numeric value,  the  character  whose
           encoding  is that value shall be output. If the value is zero or is not the encoding of any character
           in the character set, the behavior is undefined. If the argument does not have a numeric  value,  the
           first  character  of the string value shall be output; if the string does not contain any characters,
           the behavior is undefined.

        8. For each conversion specification that consumes an argument, the next expression  argument  shall  be
           evaluated.  With  the exception of the <b>c</b> conversion specifier character, the value shall be converted
           (according to the rules specified in <u>Expressions</u> <u>in</u> <u>awk</u>) to the appropriate type for  the  conversion
           specification.

        9. If  there  are  insufficient expression arguments to satisfy all the conversion specifications in the
           <u>format</u> string, the behavior is undefined.

       10. If any character sequence in the <u>format</u> string begins with a <b>'%'</b> character, but does not form a valid
           conversion specification, the behavior is unspecified.

       Both <b>print</b> and <b>printf</b> can output at least {LINE_MAX} bytes.

   <b>Functions</b>
       The <u>awk</u> language has a variety of built-in functions: arithmetic, string, input/output, and general.

   <b>Arithmetic</b> <b>Functions</b>
       The arithmetic functions, except for <b>int</b>, shall be based  on  the  ISO C  standard  (see  <u>Section</u>  <u>1.1.2</u>,
       <u>Concepts</u>  <u>Derived</u>  <u>from</u> <u>the</u> <u>ISO</u> <u>C</u> <u>Standard</u>).  The behavior is undefined in cases where the ISO C standard
       specifies that an error be returned or that the behavior is undefined. Although the grammar (see <u>Grammar</u>)
       permits built-in functions to appear with no arguments or parentheses, unless the argument or parentheses
       are indicated as optional in the following list (by displaying them within the <b>"[]"</b> brackets),  such  use
       is undefined.

       <b>atan2</b>(<u>y</u>,<u>x</u>)
                 Return arctangent of <u>y</u>/<u>x</u> in radians in the range [-π,π].

       <b>cos</b>(<u>x</u>)    Return cosine of <u>x</u>, where <u>x</u> is in radians.

       <b>sin</b>(<u>x</u>)    Return sine of <u>x</u>, where <u>x</u> is in radians.

       <b>exp</b>(<u>x</u>)    Return the exponential function of <u>x</u>.

       <b>log</b>(<u>x</u>)    Return the natural logarithm of <u>x</u>.

       <b>sqrt</b>(<u>x</u>)   Return the square root of <u>x</u>.

       <b>int</b>(<u>x</u>)    Return the argument truncated to an integer. Truncation shall be toward 0 when <u>x</u>&gt;0.

       <b>rand</b>()    Return a random number <u>n</u>, such that 0≤<u>n</u>&lt;1.

       <b>srand</b>(<b>[</b><u>expr</u><b>]</b>)
                 Set  the  seed  value  for <u>rand</u> to <u>expr</u> or use the time of day if <u>expr</u> is omitted. The previous
                 seed value shall be returned.

   <b>String</b> <b>Functions</b>
       The string functions in the following list shall  be  supported.   Although  the  grammar  (see  <u>Grammar</u>)
       permits built-in functions to appear with no arguments or parentheses, unless the argument or parentheses
       are  indicated  as optional in the following list (by displaying them within the <b>"[]"</b> brackets), such use
       is undefined.

       <b>gsub</b>(<u>ere</u>, <u>repl</u><b>[</b>, <u>in</u><b>]</b>)
                 Behave like <b>sub</b> (see below), except that it  shall  replace  all  occurrences  of  the  regular
                 expression (like the <u>ed</u> utility global substitute) in $0 or in the <u>in</u> argument, when specified.

       <b>index</b>(<u>s</u>, <u>t</u>)
                 Return  the position, in characters, numbering from 1, in string <u>s</u> where string <u>t</u> first occurs,
                 or zero if it does not occur at all.

       <b>length[</b>(<b>[</b><u>s</u><b>]</b>)<b>]</b>
                 Return the length, in characters, of its argument taken as a string, or of  the  whole  record,
                 $0, if there is no argument.

       <b>match</b>(<u>s</u>, <u>ere</u>)
                 Return  the  position,  in characters, numbering from 1, in string <u>s</u> where the extended regular
                 expression <u>ere</u> occurs, or zero if it does not occur at all. RSTART shall be set to the starting
                 position (which is the same as the returned value), zero if no match is found; RLENGTH shall be
                 set to the length of the matched string, -1 if no match is found.

       <b>split</b>(<u>s</u>, <u>a</u><b>[</b>, <u>fs</u> <b>]</b>)
                 Split the string <u>s</u> into array elements <u>a</u>[1], <u>a</u>[2], ..., <u>a</u>[<u>n</u>], and return <u>n</u>.   All  elements  of
                 the array shall be deleted before the split is performed. The separation shall be done with the
                 ERE  <u>fs</u>  or  with  the  field  separator <b>FS</b> if <u>fs</u> is not given. Each array element shall have a
                 string value when created and, if appropriate, the array element shall be considered a  numeric
                 string  (see  <u>Expressions</u>  <u>in</u>  <u>awk</u>).   The  effect  of  a  null  string  as  the value of <u>fs</u> is
                 unspecified.

       <b>sprintf</b>(<u>fmt</u>, <u>expr</u>, <u>expr</u>, ...)
                 Format the expressions according to the <b>printf</b> format given by <u>fmt</u>  and  return  the  resulting
                 string.

       <b>sub(</b><u>ere</u>, <u>repl</u><b>[</b>, <u>in</u> <b>]</b>)
                 Substitute  the  string  <u>repl</u> in place of the first instance of the extended regular expression
                 <u>ERE</u> in string <u>in</u> and return the number of substitutions. An &lt;ampersand&gt; (<b>'&amp;'</b>) appearing in  the
                 string  <u>repl</u>  shall  be  replaced  by  the  string from <u>in</u> that matches the ERE. An &lt;ampersand&gt;
                 preceded with a &lt;backslash&gt; shall be interpreted  as  the  literal  &lt;ampersand&gt;  character.  An
                 occurrence  of  two  consecutive  &lt;backslash&gt;  characters shall be interpreted as just a single
                 literal &lt;backslash&gt; character. Any other occurrence of a &lt;backslash&gt;  (for  example,  preceding
                 any  other character) shall be treated as a literal &lt;backslash&gt; character. Note that if <u>repl</u> is
                 a string literal (the lexical token <b>STRING</b>; see  <u>Grammar</u>),  the  handling  of  the  &lt;ampersand&gt;
                 character  occurs  after  any  lexical  processing,  including  any  lexical &lt;backslash&gt;-escape
                 sequence processing. If <u>in</u> is specified and it is not an lvalue (see <u>Expressions</u> <u>in</u>  <u>awk</u>),  the
                 behavior is undefined. If <u>in</u> is omitted, <u>awk</u> shall use the current record ($0) in its place.

       <b>substr</b>(<u>s</u>, <u>m</u><b>[</b>, <u>n</u> <b>]</b>)
                 Return the at most <u>n</u>-character substring of <u>s</u> that begins at position <u>m</u>, numbering from 1. If <u>n</u>
                 is  omitted,  or  if <u>n</u> specifies more characters than are left in the string, the length of the
                 substring shall be limited by the length of the string <u>s</u>.

       <b>tolower</b>(<u>s</u>)
                 Return a string based on the string <u>s</u>.  Each  character  in  <u>s</u>  that  is  an  uppercase  letter
                 specified  to  have  a  <b>tolower</b> mapping by the <u>LC_CTYPE</u> category of the current locale shall be
                 replaced in the returned string by  the  lowercase  letter  specified  by  the  mapping.  Other
                 characters in <u>s</u> shall be unchanged in the returned string.

       <b>toupper</b>(<u>s</u>)
                 Return  a  string  based  on  the  string  <u>s</u>.   Each  character in <u>s</u> that is a lowercase letter
                 specified to have a <b>toupper</b> mapping by the <u>LC_CTYPE</u> category of the current locale is  replaced
                 in  the returned string by the uppercase letter specified by the mapping. Other characters in <u>s</u>
                 are unchanged in the returned string.

       All of the preceding functions that take <u>ERE</u>  as  a  parameter  expect  a  pattern  or  a  string  valued
       expression that is a regular expression as defined in <u>Regular</u> <u>Expressions</u>.

   <b>Input/Output</b> <b>and</b> <b>General</b> <b>Functions</b>
       The input/output and general functions are:

       <b>close</b>(<u>expression</u>)
                 Close the file or pipe opened by a <b>print</b> or <b>printf</b> statement or a call to <b>getline</b> with the same
                 string-valued   <u>expression</u>.    The  limit  on  the  number  of  open  <u>expression</u>  arguments  is
                 implementation-defined. If the close was successful, the function shall return zero; otherwise,
                 it shall return non-zero.

       <u>expression</u> <u>|</u> <b>getline</b> <b>[</b><u>var</u><b>]</b>
                 Read a record of input from a stream piped from the output of a command. The  stream  shall  be
                 created  if  no  stream is currently open with the value of <u>expression</u> as its command name. The
                 stream created shall be equivalent to one created by a call to the <u>popen</u>()  function  with  the
                 value  of  <u>expression</u> as the <u>command</u> argument and a value of <u>r</u> as the <u>mode</u> argument. As long as
                 the stream remains open, subsequent calls in which <u>expression</u>  evaluates  to  the  same  string
                 value  shall  read  subsequent  records from the stream. The stream shall remain open until the
                 <b>close</b> function is called with an expression that evaluates to the same string  value.  At  that
                 time,  the  stream shall be closed as if by a call to the <u>pclose</u>() function. If <u>var</u> is omitted,
                 $0 and <b>NF</b> shall be set; otherwise, <u>var</u> shall be set and, if appropriate, it shall be considered
                 a numeric string (see <u>Expressions</u> <u>in</u> <u>awk</u>).

                 The <b>getline</b> operator can form ambiguous constructs when  there  are  unparenthesized  operators
                 (including  concatenate)  to the left of the <b>'|'</b> (to the beginning of the expression containing
                 <b>getline</b>).  In the context of the <b>'$'</b> operator, <b>'|'</b> shall behave as if it had a lower precedence
                 than <b>'$'</b>.  The result of evaluating other operators is unspecified, and conforming applications
                 shall parenthesize properly all such usages.

       <b>getline</b>   Set $0 to the next input record from the current input file. This form of <b>getline</b> shall set the
                 <b>NF</b>, <b>NR</b>, and <b>FNR</b> variables.

       <b>getline</b> <u>var</u>
                 Set variable <u>var</u> to the next input record from the current input file and, if appropriate,  <u>var</u>
                 shall  be considered a numeric string (see <u>Expressions</u> <u>in</u> <u>awk</u>).  This form of <b>getline</b> shall set
                 the <b>FNR</b> and <b>NR</b> variables.

       <b>getline</b> <b>[</b><u>var</u><b>]</b> &lt; <u>expression</u>
                 Read the next record of input from a named file. The <u>expression</u> shall be evaluated to produce a
                 string that is used as a pathname.  If the file of that name is not currently open, it shall be
                 opened. As long as the stream remains open, subsequent calls in which <u>expression</u>  evaluates  to
                 the  same  string value shall read subsequent records from the file. The file shall remain open
                 until the <b>close</b> function is called with an expression that evaluates to the same string  value.
                 If  <u>var</u> is omitted, $0 and <b>NF</b> shall be set; otherwise, <u>var</u> shall be set and, if appropriate, it
                 shall be considered a numeric string (see <u>Expressions</u> <u>in</u> <u>awk</u>).

                 The <b>getline</b> operator can form  ambiguous  constructs  when  there  are  unparenthesized  binary
                 operators  (including  concatenate)  to  the  right of the <b>'&lt;'</b> (up to the end of the expression
                 containing the <b>getline</b>).  The result  of  evaluating  such  a  construct  is  unspecified,  and
                 conforming applications shall parenthesize properly all such usages.

       <b>system</b>(<u>expression</u>)
                 Execute the command given by <u>expression</u> in a manner equivalent to the <u>system</u>() function defined
                 in the System Interfaces volume of POSIX.1‐2017 and return the exit status of the command.

       All forms of <b>getline</b> shall return 1 for successful input, zero for end-of-file, and -1 for an error.

       Where  strings  are used as the name of a file or pipeline, the application shall ensure that the strings
       are textually identical. The terminology ``same string value'' implies that ``equivalent strings'',  even
       those that differ only by &lt;space&gt; characters, represent different files.

   <b>User-Defined</b> <b>Functions</b>
       The <u>awk</u> language also provides user-defined functions. Such functions can be defined as:

           function <u>name</u>(<b>[</b><u>parameter</u>, ...<b>]</b>) { <u>statements</u> }

       A  function  can  be  referred  to  anywhere  in  an  <u>awk</u> program; in particular, its use can precede its
       definition. The scope of a function is global.

       Function parameters, if present, can be either scalars or arrays; the behavior is undefined if  an  array
       name  is passed as a parameter that the function uses as a scalar, or if a scalar expression is passed as
       a parameter that the function uses as an array. Function parameters shall be passed by  value  if  scalar
       and by reference if array name.

       The  number  of  parameters  in  the  function  definition need not match the number of parameters in the
       function call. Excess formal parameters can be used as local variables. If fewer arguments  are  supplied
       in  a  function  call  than  are  in  the  function definition, the extra parameters that are used in the
       function body as scalars shall evaluate to the uninitialized value until they are otherwise  initialized,
       and  the  extra parameters that are used in the function body as arrays shall be treated as uninitialized
       arrays where each element evaluates to the uninitialized value until otherwise initialized.

       When invoking a function, no white space can  be  placed  between  the  function  name  and  the  opening
       parenthesis.  Function  calls  can  be nested and recursive calls can be made upon functions. Upon return
       from any nested or recursive function call, the values of all of the calling function's parameters  shall
       be unchanged, except for array parameters passed by reference. The <b>return</b> statement can be used to return
       a value. If a <b>return</b> statement appears outside of a function definition, the behavior is undefined.

       In the function definition, &lt;newline&gt; characters shall be optional before the opening brace and after the
       closing  brace.  Function  definitions  can appear anywhere in the program where a <u>pattern-action</u> pair is
       allowed.

   <b>Grammar</b>
       The grammar in this section and the lexical conventions in the following section shall together  describe
       the  syntax  for <u>awk</u> programs. The general conventions for this style of grammar are described in <u>Section</u>
       <u>1.3</u>, <u>Grammar</u> <u>Conventions</u>.  A valid program can be represented as the non-terminal symbol <u>program</u>  in  the
       grammar. This formal syntax shall take precedence over the preceding text syntax description.

           %token NAME NUMBER STRING ERE
           %token FUNC_NAME   /* Name followed by '(' without white space. */

           /* Keywords */
           %token       Begin   End
           /*          'BEGIN' 'END'                            */

           %token       Break   Continue   Delete   Do   Else
           /*          'break' 'continue' 'delete' 'do' 'else'  */

           %token       Exit   For   Function   If   In
           /*          'exit' 'for' 'function' 'if' 'in'        */

           %token       Next   Print   Printf   Return   While
           /*          'next' 'print' 'printf' 'return' 'while' */

           /* Reserved function names */
           %token BUILTIN_FUNC_NAME
                       /* One token for the following:
                        * atan2 cos sin exp log sqrt int rand srand
                        * gsub index length match split sprintf sub
                        * substr tolower toupper close system
                        */
           %token GETLINE
                       /* Syntactically different from other built-ins. */

           /* Two-character tokens. */
           %token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
           /*     '+='       '-='       '*='       '/='       '%='       '^=' */

           %token OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
           /*     '||' '&amp;&amp;' '!~' '==' '&lt;=' '&gt;=' '!=' '++'  '--'  '&gt;&gt;'   */

           /* One-character tokens. */
           %token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
           %token '+' '-' '*' '%' '^' '!' '&gt;' '&lt;' '|' '?' ':' '~' '$' '='

           %start program
           %%

           program          : item_list
                            | item_list item
                            ;

           item_list        : /* empty */
                            | item_list item terminator
                            ;

           item             : action
                            | pattern action
                            | normal_pattern
                            | Function NAME      '(' param_list_opt ')'
                                  newline_opt action
                            | Function FUNC_NAME '(' param_list_opt ')'
                                  newline_opt action
                            ;

           param_list_opt   : /* empty */
                            | param_list
                            ;

           param_list       : NAME
                            | param_list ',' NAME
                            ;

           pattern          : normal_pattern
                            | special_pattern
                            ;

           normal_pattern   : expr
                            | expr ',' newline_opt expr
                            ;

           special_pattern  : Begin
                            | End
                            ;

           action           : '{' newline_opt                             '}'
                            | '{' newline_opt terminated_statement_list   '}'
                            | '{' newline_opt unterminated_statement_list '}'
                            ;

           terminator       : terminator NEWLINE
                            |            ';'
                            |            NEWLINE
                            ;

           terminated_statement_list : terminated_statement
                            | terminated_statement_list terminated_statement
                            ;

           unterminated_statement_list : unterminated_statement
                            | terminated_statement_list unterminated_statement
                            ;

           terminated_statement : action newline_opt
                            | If '(' expr ')' newline_opt terminated_statement
                            | If '(' expr ')' newline_opt terminated_statement
                                  Else newline_opt terminated_statement
                            | While '(' expr ')' newline_opt terminated_statement
                            | For '(' simple_statement_opt ';'
                                 expr_opt ';' simple_statement_opt ')' newline_opt
                                 terminated_statement
                            | For '(' NAME In NAME ')' newline_opt
                                 terminated_statement
                            | ';' newline_opt
                            | terminatable_statement NEWLINE newline_opt
                            | terminatable_statement ';'     newline_opt
                            ;

           unterminated_statement : terminatable_statement
                            | If '(' expr ')' newline_opt unterminated_statement
                            | If '(' expr ')' newline_opt terminated_statement
                                 Else newline_opt unterminated_statement
                            | While '(' expr ')' newline_opt unterminated_statement
                            | For '(' simple_statement_opt ';'
                             expr_opt ';' simple_statement_opt ')' newline_opt
                                 unterminated_statement
                            | For '(' NAME In NAME ')' newline_opt
                                 unterminated_statement
                            ;

           terminatable_statement : simple_statement
                            | Break
                            | Continue
                            | Next
                            | Exit expr_opt
                            | Return expr_opt
                            | Do newline_opt terminated_statement While '(' expr ')'
                            ;

           simple_statement_opt : /* empty */
                            | simple_statement
                            ;

           simple_statement : Delete NAME '[' expr_list ']'
                            | expr
                            | print_statement
                            ;

           print_statement  : simple_print_statement
                            | simple_print_statement output_redirection
                            ;

           simple_print_statement : Print  print_expr_list_opt
                            | Print  '(' multiple_expr_list ')'
                            | Printf print_expr_list
                            | Printf '(' multiple_expr_list ')'
                            ;

           output_redirection : '&gt;'    expr
                            | APPEND expr
                            | '|'    expr
                            ;

           expr_list_opt    : /* empty */
                            | expr_list
                            ;

           expr_list        : expr
                            | multiple_expr_list
                            ;

           multiple_expr_list : expr ',' newline_opt expr
                            | multiple_expr_list ',' newline_opt expr
                            ;

           expr_opt         : /* empty */
                            | expr
                            ;

           expr             : unary_expr
                            | non_unary_expr
                            ;

           unary_expr       : '+' expr
                            | '-' expr
                            | unary_expr '^'      expr
                            | unary_expr '*'      expr
                            | unary_expr '/'      expr
                            | unary_expr '%'      expr
                            | unary_expr '+'      expr
                            | unary_expr '-'      expr
                            | unary_expr          non_unary_expr
                            | unary_expr '&lt;'      expr
                            | unary_expr LE       expr
                            | unary_expr NE       expr
                            | unary_expr EQ       expr
                            | unary_expr '&gt;'      expr
                            | unary_expr GE       expr
                            | unary_expr '~'      expr
                            | unary_expr NO_MATCH expr
                            | unary_expr In NAME
                            | unary_expr AND newline_opt expr
                            | unary_expr OR  newline_opt expr
                            | unary_expr '?' expr ':' expr
                            | unary_input_function
                            ;

           non_unary_expr   : '(' expr ')'
                            | '!' expr
                            | non_unary_expr '^'      expr
                            | non_unary_expr '*'      expr
                            | non_unary_expr '/'      expr
                            | non_unary_expr '%'      expr
                            | non_unary_expr '+'      expr
                            | non_unary_expr '-'      expr
                            | non_unary_expr          non_unary_expr
                            | non_unary_expr '&lt;'      expr
                            | non_unary_expr LE       expr
                            | non_unary_expr NE       expr
                            | non_unary_expr EQ       expr
                            | non_unary_expr '&gt;'      expr
                            | non_unary_expr GE       expr
                            | non_unary_expr '~'      expr
                            | non_unary_expr NO_MATCH expr
                            | non_unary_expr In NAME
                            | '(' multiple_expr_list ')' In NAME
                            | non_unary_expr AND newline_opt expr
                            | non_unary_expr OR  newline_opt expr
                            | non_unary_expr '?' expr ':' expr
                            | NUMBER
                            | STRING
                            | lvalue
                            | ERE
                            | lvalue INCR
                            | lvalue DECR
                            | INCR lvalue
                            | DECR lvalue
                            | lvalue POW_ASSIGN expr
                            | lvalue MOD_ASSIGN expr
                            | lvalue MUL_ASSIGN expr
                            | lvalue DIV_ASSIGN expr
                            | lvalue ADD_ASSIGN expr
                            | lvalue SUB_ASSIGN expr
                            | lvalue '=' expr
                            | FUNC_NAME '(' expr_list_opt ')'
                                 /* no white space allowed before '(' */
                            | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                            | BUILTIN_FUNC_NAME
                            | non_unary_input_function
                            ;

           print_expr_list_opt : /* empty */
                            | print_expr_list
                            ;

           print_expr_list  : print_expr
                            | print_expr_list ',' newline_opt print_expr
                            ;

           print_expr       : unary_print_expr
                            | non_unary_print_expr
                            ;

           unary_print_expr : '+' print_expr
                            | '-' print_expr
                            | unary_print_expr '^'      print_expr
                            | unary_print_expr '*'      print_expr
                            | unary_print_expr '/'      print_expr
                            | unary_print_expr '%'      print_expr
                            | unary_print_expr '+'      print_expr
                            | unary_print_expr '-'      print_expr
                            | unary_print_expr          non_unary_print_expr
                            | unary_print_expr '~'      print_expr
                            | unary_print_expr NO_MATCH print_expr
                            | unary_print_expr In NAME
                            | unary_print_expr AND newline_opt print_expr
                            | unary_print_expr OR  newline_opt print_expr
                            | unary_print_expr '?' print_expr ':' print_expr
                            ;

           non_unary_print_expr : '(' expr ')'
                            | '!' print_expr
                            | non_unary_print_expr '^'      print_expr
                            | non_unary_print_expr '*'      print_expr
                            | non_unary_print_expr '/'      print_expr
                            | non_unary_print_expr '%'      print_expr
                            | non_unary_print_expr '+'      print_expr
                            | non_unary_print_expr '-'      print_expr
                            | non_unary_print_expr          non_unary_print_expr
                            | non_unary_print_expr '~'      print_expr
                            | non_unary_print_expr NO_MATCH print_expr
                            | non_unary_print_expr In NAME
                            | '(' multiple_expr_list ')' In NAME
                            | non_unary_print_expr AND newline_opt print_expr
                            | non_unary_print_expr OR  newline_opt print_expr
                            | non_unary_print_expr '?' print_expr ':' print_expr
                            | NUMBER
                            | STRING
                            | lvalue
                            | ERE
                            | lvalue INCR
                            | lvalue DECR
                            | INCR lvalue
                            | DECR lvalue
                            | lvalue POW_ASSIGN print_expr
                            | lvalue MOD_ASSIGN print_expr
                            | lvalue MUL_ASSIGN print_expr
                            | lvalue DIV_ASSIGN print_expr
                            | lvalue ADD_ASSIGN print_expr
                            | lvalue SUB_ASSIGN print_expr
                            | lvalue '=' print_expr
                            | FUNC_NAME '(' expr_list_opt ')'
                                /* no white space allowed before '(' */
                            | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                            | BUILTIN_FUNC_NAME
                            ;

           lvalue           : NAME
                            | NAME '[' expr_list ']'
                            | '$' expr
                            ;

           non_unary_input_function : simple_get
                            | simple_get '&lt;' expr
                            | non_unary_expr '|' simple_get
                            ;

           unary_input_function : unary_expr '|' simple_get
                            ;

           simple_get       : GETLINE
                            | GETLINE lvalue
                            ;

           newline_opt      : /* empty */
                            | newline_opt NEWLINE
                            ;

       This grammar has several ambiguities that shall be resolved as follows:

        *  Operator  precedence  and associativity shall be as described in <u>Table</u> <u>4-1,</u> <u>Expressions</u> <u>in</u> <u>Decreasing</u>
           <u>Precedence</u> <u>in</u> <u>awk</u>.

        *  In case of ambiguity, an <b>else</b> shall be associated with the most immediately preceding <b>if</b>  that  would
           satisfy the grammar.

        *  In  some  contexts,  a  &lt;slash&gt;  (<b>'/'</b>)  that  is  used  to surround an ERE could also be the division
           operator.  This shall be resolved in such a way that wherever the division operator could  appear,  a
           &lt;slash&gt; is assumed to be the division operator. (There is no unary division operator.)

       Each expression in an <u>awk</u> program shall conform to the precedence and associativity rules, even when this
       is  not  needed  to  resolve  an ambiguity. For example, because <b>'$'</b> has higher precedence than <b>'++'</b>, the
       string <b>"$x++--"</b> is not a valid <u>awk</u> expression, even though it is unambiguously parsed by the  grammar  as
       <b>"$(x++)--"</b>.

       One  convention  that  might  not  be  obvious  from the formal grammar is where &lt;newline&gt; characters are
       acceptable. There are several obvious placements such as terminating a statement, and a  &lt;backslash&gt;  can
       be  used  to  escape  &lt;newline&gt;  characters between any lexical tokens. In addition, &lt;newline&gt; characters
       without &lt;backslash&gt; characters can follow a comma, an open brace, logical AND operator (<b>"&amp;&amp;"</b>), logical OR
       operator (<b>"||"</b>), the <b>do</b> keyword, the <b>else</b> keyword, and the closing parenthesis of an <b>if</b>,  <b>for</b>,  or  <b>while</b>
       statement. For example:

           { print  $1,
                    $2 }

   <b>Lexical</b> <b>Conventions</b>
       The lexical conventions for <u>awk</u> programs, with respect to the preceding grammar, shall be as follows:

        1. Except  as  noted,  <u>awk</u>  shall recognize the longest possible token or delimiter beginning at a given
           point.

        2. A comment shall consist of any characters beginning with the &lt;number-sign&gt; character  and  terminated
           by,  but  excluding  the  next  occurrence of, a &lt;newline&gt;.  Comments shall have no effect, except to
           delimit lexical tokens.

        3. The &lt;newline&gt; shall be recognized as the token <b>NEWLINE</b>.

        4. A &lt;backslash&gt; character immediately followed by a &lt;newline&gt; shall have no effect.

        5. The token <b>STRING</b> shall represent a string constant. A string constant shall begin with the  character
           <b>'"'</b>.   Within  a  string  constant,  a  &lt;backslash&gt;  character shall be considered to begin an escape
           sequence as specified in the table in the Base Definitions volume of POSIX.1‐2017,  <u>Chapter</u>  <u>5</u>,  <u>File</u>
           <u>Format</u>  <u>Notation</u> (<b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b>).  In addition, the escape sequences
           in <u>Table</u> <u>4-2,</u> <u>Escape</u> <u>Sequences</u> <u>in</u> <u>awk</u> shall be recognized. A  &lt;newline&gt;  shall  not  occur  within  a
           string  constant.  A  string  constant  shall  be terminated by the first unescaped occurrence of the
           character <b>'"'</b> after the one that begins the string constant. The value of the  string  shall  be  the
           sequence  of  all unescaped characters and values of escape sequences between, but not including, the
           two delimiting <b>'"'</b> characters.

        6. The token <b>ERE</b> represents an extended regular expression constant. An ERE constant  shall  begin  with
           the  &lt;slash&gt;  character. Within an ERE constant, a &lt;backslash&gt; character shall be considered to begin
           an escape sequence as specified in the table in the Base Definitions volume of POSIX.1‐2017,  <u>Chapter</u>
           <u>5</u>,  <u>File</u>  <u>Format</u>  <u>Notation</u>.   In addition, the escape sequences in <u>Table</u> <u>4-2,</u> <u>Escape</u> <u>Sequences</u> <u>in</u> <u>awk</u>
           shall be recognized. The application shall ensure that a &lt;newline&gt;  does  not  occur  within  an  ERE
           constant.  An  ERE  constant  shall  be  terminated  by the first unescaped occurrence of the &lt;slash&gt;
           character after the one that begins the ERE constant. The extended regular expression represented  by
           the  ERE  constant  shall  be the sequence of all unescaped characters and values of escape sequences
           between, but not including, the two delimiting &lt;slash&gt; characters.

        7. A &lt;blank&gt; shall have no effect, except to delimit lexical tokens or within <b>STRING</b> or <b>ERE</b> tokens.

        8. The token <b>NUMBER</b> shall represent a numeric constant. Its form  and  numeric  value  shall  either  be
           equivalent  to the <b>decimal-floating-constant</b> token as specified by the ISO C standard, or it shall be
           a sequence of decimal digits and shall be evaluated as an integer constant in decimal.  In  addition,
           implementations  may  accept  numeric  constants  with  the  form and numeric value equivalent to the
           <b>hexadecimal-constant</b> and <b>hexadecimal-floating-constant</b> tokens as specified by the ISO C standard.

           If the value is too large or too small to be representable (see <u>Section</u> <u>1.1.2</u>, <u>Concepts</u> <u>Derived</u>  <u>from</u>
           <u>the</u> <u>ISO</u> <u>C</u> <u>Standard</u>), the behavior is undefined.

        9. A  sequence  of  underscores,  digits,  and alphabetics from the portable character set (see the Base
           Definitions volume  of  POSIX.1‐2017,  <u>Section</u>  <u>6.1</u>,  <u>Portable</u>  <u>Character</u>  <u>Set</u>),  beginning  with  an
           &lt;underscore&gt; or alphabetic character, shall be considered a word.

       10. The following words are keywords that shall be recognized as individual tokens; the name of the token
           is the same as the keyword:
           <b>BEGIN</b>      <b>delete</b>     <b>END</b>        <b>function</b>   <b>in</b>         <b>printf</b>
           <b>break</b>      <b>do</b>         <b>exit</b>       <b>getline</b>    <b>next</b>       <b>return</b>
           <b>continue</b>   <b>else</b>       <b>for</b>        <b>if</b>         <b>print</b>      <b>while</b>

       11. The  following  words  are  names  of  built-in  functions  and  shall  be  recognized  as  the token
           <b>BUILTIN_FUNC_NAME</b>:
           <b>atan2</b>     <b>gsub</b>      <b>log</b>       <b>split</b>     <b>sub</b>       <b>toupper</b>
           <b>close</b>     <b>index</b>     <b>match</b>     <b>sprintf</b>   <b>substr</b>
           <b>cos</b>       <b>int</b>       <b>rand</b>      <b>sqrt</b>      <b>system</b>
           <b>exp</b>       <b>length</b>    <b>sin</b>       <b>srand</b>     <b>tolower</b>

           The above-listed keywords and names of built-in functions are considered reserved words.

       12. The token <b>NAME</b> shall consist of a word that is not a keyword or a name of a built-in function and  is
           not followed immediately (without any delimiters) by the <b>'('</b> character.

       13. The  token  <b>FUNC_NAME</b> shall consist of a word that is not a keyword or a name of a built-in function,
           followed immediately (without any delimiters) by the <b>'('</b> character. The <b>'('</b> character  shall  not  be
           included as part of the token.

       14. The following two-character sequences shall be recognized as the named tokens:
                                    ┌────────────┬──────────┬────────────┬──────────┐
                                    │ <b>Token</b> <b>Name</b> │ <b>Sequence</b> │ <b>Token</b> <b>Name</b> │ <b>Sequence</b> │
                                    ├────────────┼──────────┼────────────┼──────────┤
                                    │ <b>ADD_ASSIGN</b> │    +=    │ <b>NO_MATCH</b>   │    !~    │
                                    │ <b>SUB_ASSIGN</b> │    -=    │ <b>EQ</b>         │    ==    │
                                    │ <b>MUL_ASSIGN</b> │    *=    │ <b>LE</b>         │    &lt;=    │
                                    │ <b>DIV_ASSIGN</b> │    /=    │ <b>GE</b>         │    &gt;=    │
                                    │ <b>MOD_ASSIGN</b> │    %=    │ <b>NE</b>         │    !=    │
                                    │ <b>POW_ASSIGN</b> │    ^=    │ <b>INCR</b>       │    ++    │
                                    │ <b>OR</b>         │    ||    │ <b>DECR</b>       │    --    │
                                    │ <b>AND</b>        │    &amp;&amp;    │ <b>APPEND</b>     │    &gt;&gt;    │
                                    └────────────┴──────────┴────────────┴──────────┘

       15. The following single characters shall be recognized as tokens whose names are the character:

               &lt;newline&gt; { } ( ) [ ] , ; + - * % ^ ! &gt; &lt; | ? : ~ $ =

       There  is  a  lexical  ambiguity  between the token <b>ERE</b> and the tokens <b>'/'</b> and <b>DIV_ASSIGN</b>.  When an input
       sequence begins with a &lt;slash&gt; character in any syntactic context where the token <b>'/'</b> or <b>DIV_ASSIGN</b> could
       appear as the next token in a valid program, the longer of those two tokens that can be recognized  shall
       be  recognized.  In  any  other syntactic context where the token <b>ERE</b> could appear as the next token in a
       valid program, the token <b>ERE</b> shall be recognized.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The following exit values shall be returned:

        0    All input files were processed successfully.

       &gt;0    An error occurred.

       The exit status can be altered within the program by using an <b>exit</b> expression.

</pre><h4><b>CONSEQUENCES</b> <b>OF</b> <b>ERRORS</b></h4><pre>
       If any <u>file</u> operand is specified and the named file cannot be accessed,  <u>awk</u>  shall  write  a  diagnostic
       message to standard error and terminate without any further action.

       If  the  program specified by either the <u>program</u> operand or a <u>progfile</u> operand is not a valid <u>awk</u> program
       (as specified in the EXTENDED DESCRIPTION section), the behavior is undefined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The <b>index</b>, <b>length</b>, <b>match</b>, and <b>substr</b> functions should not be confused with similar functions in the ISO C
       standard; the <u>awk</u> versions deal with characters, while the ISO C standard deals with bytes.

       Because the concatenation operation is represented  by  adjacent  expressions  rather  than  an  explicit
       operator, it is often necessary to use parentheses to enforce the proper evaluation precedence.

       When  using <u>awk</u> to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE,
       are set to POSIX or C in the environment, since pathnames can contain byte sequences  that  do  not  form
       valid  characters  in some locales, in which case the utility's behavior would be undefined. In the POSIX
       locale each byte is a valid single-byte character, and therefore this problem is avoided.

       On implementations where the <b>"=="</b> operator checks if strings collate  equally,  applications  needing  to
       check whether strings are identical can use:

           length(a) == length(b) &amp;&amp; index(a,b) == 1

       On implementations where the <b>"=="</b> operator checks if strings are identical, applications needing to check
       whether strings collate equally can use:

           a &lt;= b &amp;&amp; a &gt;= b

</pre><h4><b>EXAMPLES</b></h4><pre>
       The <u>awk</u> program specified in the command line is most easily specified within single-quotes (for example,
       '<u>program</u>')  for  applications using <u>sh</u>, because <u>awk</u> programs commonly contain characters that are special
       to the shell,  including  double-quotes.  In  the  cases  where  an  <u>awk</u>  program  contains  single-quote
       characters,  it  is  usually  easiest  to  specify  most  of  the program as strings within single-quotes
       concatenated by the shell with quoted single-quote characters. For example:

           awk '/'\''/ { print "quote:", $0 }'

       prints all lines from the standard input containing a single-quote character, prefixed with <u>quote</u>:.

       The following are examples of simple <u>awk</u> programs:

        1. Write to the standard output all input lines for which field 3 is greater than 5:

               $3 &gt; 5

        2. Write every tenth line:

               (NR % 10) == 0

        3. Write any line with a substring matching the regular expression:

               /(G|D)(2[0-9][[:alpha:]]*)/

        4. Print any line with a substring containing a <b>'G'</b> or  <b>'D'</b>,  followed  by  a  sequence  of  digits  and
           characters.  This  example uses character classes <b>digit</b> and <b>alpha</b> to match language-independent digit
           and alphabetic characters respectively:

               /(G|D)([[:digit:][:alpha:]]*)/

        5. Write any line in which the second field matches the regular expression and  the  fourth  field  does
           not:

               $2 ~ /xyz/ &amp;&amp; $4 !~ /xyz/

        6. Write any line in which the second field contains a &lt;backslash&gt;:

               $2 ~ /\\/

        7. Write  any  line in which the second field contains a &lt;backslash&gt;.  Note that &lt;backslash&gt;-escapes are
           interpreted twice; once in lexical processing of the  string  and  once  in  processing  the  regular
           expression:

               $2 ~ "\\\\"

        8. Write the second to the last and the last field in each line. Separate the fields by a &lt;colon&gt;:

               {OFS=":";print $(NF-1), $NF}

        9. Write  the  line  number  and  number of fields in each line. The three strings representing the line
           number, the &lt;colon&gt;, and the number of fields are concatenated and that string is written to standard
           output:

               {print NR ":" NF}

       10. Write lines longer than 72 characters:

               length($0) &gt; 72

       11. Write the first two fields in opposite order separated by <b>OFS</b>:

               { print $2, $1 }

       12. Same, with input fields separated by a &lt;comma&gt; or &lt;space&gt; and &lt;tab&gt; characters, or both:

               BEGIN { FS = ",[ \t]*|[ \t]+" }
                     { print $2, $1 }

       13. Add up the first column, print sum, and average:

                     {s += $1 }
               END   {print "sum is ", s, " average is", s/NR}

       14. Write fields in reverse order, one per line (many lines out for each line in):

               { for (i = NF; i &gt; 0; --i) print $i }

       15. Write all lines between occurrences of the strings <b>start</b> and <b>stop</b>:

               /start/, /stop/

       16. Write all lines whose first field is different from the previous one:

               $1 != prev { print; prev = $1 }

       17. Simulate <u>echo</u>:

               BEGIN  {
                       for (i = 1; i &lt; ARGC; ++i)
                       printf("%s%s", ARGV[i], i==ARGC-1?"\n":" ")
               }

       18. Write the path prefixes contained in the <u>PATH</u> environment variable, one per line:

               BEGIN  {
                       n = split (ENVIRON["PATH"], path, ":")
                       for (i = 1; i &lt;= n; ++i)
                       print path[i]
               }

       19. If there is a file named <b>input</b> containing page headers of the form: Page #

           and a file named <b>program</b> that contains:

               /Page/   { $2 = n++; }
                        { print }

           then the command line:

               awk -f program n=5 input

           prints the file <b>input</b>, filling in page numbers starting at 5.

</pre><h4><b>RATIONALE</b></h4><pre>
       This description is based on the new <u>awk</u>, ``nawk'', (see the referenced <u>The</u>  <u>AWK</u>  <u>Programming</u>  <u>Language</u>),
       which introduced a number of new features to the historical <u>awk</u>:

        1. New keywords: <b>delete</b>, <b>do</b>, <b>function</b>, <b>return</b>

        2. New built-in functions: <b>atan2</b>, <b>close</b>, <b>cos</b>, <b>gsub</b>, <b>match</b>, <b>rand</b>, <b>sin</b>, <b>srand</b>, <b>sub</b>, <b>system</b>

        3. New predefined variables: <b>FNR</b>, <b>ARGC</b>, <b>ARGV</b>, <b>RSTART</b>, <b>RLENGTH</b>, <b>SUBSEP</b>

        4. New expression operators: <b>?</b>, <b>:</b>, <b>,</b>, <b>^</b>

        5. The <b>FS</b> variable and the third argument to <b>split</b>, now treated as extended regular expressions.

        6. The  operator  precedence,  changed  to more closely match the C language.  Two examples of code that
           operate differently are:

               while ( n /= 10 &gt; 1) ...
               if (!"wk" ~ /bwk/) ...

       Several features have been added based on newer implementations of <u>awk</u>:

        *  Multiple instances of <b>-f</b> <u>progfile</u> are permitted.

        *  The new option <b>-v</b> <u>assignment.</u>

        *  The new predefined variable <b>ENVIRON</b>.

        *  New built-in functions <b>toupper</b> and <b>tolower</b>.

        *  More formatting capabilities are added to <b>printf</b> to match the ISO C standard.

       Earlier versions of this standard required implementations to  support  multiple  adjacent  &lt;semicolon&gt;s,
       lines  with  one  or  more  &lt;semicolon&gt;  before  a  rule  (<u>pattern-action</u>  pairs),  and  lines  with only
       &lt;semicolon&gt;(s).  These are not required by this standard and are considered  poor  programming  practice,
       but can be accepted by an implementation of <u>awk</u> as an extension.

       The  overall  <u>awk</u>  syntax  has  always  been  based on the C language, with a few features from the shell
       command language and other sources. Because of this, it is  not  completely  compatible  with  any  other
       language,  which  has caused confusion for some users. It is not the intent of the standard developers to
       address such issues. A few relatively minor changes toward making the language more compatible  with  the
       ISO C  standard  were made; most of these changes are based on similar changes in recent implementations,
       as described above. There remain several C-language conventions that are not in <u>awk</u>.  One of the  notable
       ones  is  the  &lt;comma&gt; operator, which is commonly used to specify multiple expressions in the C language
       <b>for</b> statement. Also, there are various places where <u>awk</u> is more restrictive than the C language regarding
       the type of expression that can be used in a given context. These limitations are due  to  the  different
       features that the <u>awk</u> language does provide.

       Regular  expressions  in  <u>awk</u>  have been extended somewhat from historical implementations to make them a
       pure superset of extended regular expressions, as defined  by  POSIX.1‐2008  (see  the  Base  Definitions
       volume   of   POSIX.1‐2017,  <u>Section</u>  <u>9.4</u>,  <u>Extended</u>  <u>Regular</u>  <u>Expressions</u>).   The  main  extensions  are
       internationalization features and interval expressions.  Historical  implementations  of  <u>awk</u>  have  long
       supported  &lt;backslash&gt;-escape  sequences  as  an  extension  to  extended  regular  expressions, and this
       extension has been retained despite inconsistency with other utilities. The number  of  escape  sequences
       recognized  in  both extended regular expressions and strings has varied (generally increasing with time)
       among implementations. The set specified by POSIX.1‐2008 includes most sequences known to be supported by
       popular implementations and by the ISO C standard. One sequence that  is  not  supported  is  hexadecimal
       value  escapes  beginning  with  <b>'\x'</b>.   This would allow values expressed in more than 9 bits to be used
       within <u>awk</u> as in the ISO C standard. However, because this syntax has a non-deterministic length, it does
       not permit the subsequent character to be a hexadecimal digit. This limitation can be dealt with in the C
       language by the use of lexical string concatenation. In the <u>awk</u> language, concatenation could also  be  a
       solution for strings, but not for extended regular expressions (either lexical ERE tokens or strings used
       dynamically  as  regular  expressions).  Because  of  this  limitation, the feature has not been added to
       POSIX.1‐2008.

       When a string variable is used in a context where an extended regular expression normally appears  (where
       the lexical token ERE is used in the grammar) the string does not contain the literal &lt;slash&gt; characters.

       Some versions of <u>awk</u> allow the form:

           func name(args, ... ) { statements }

       This has been deprecated by the authors of the language, who asked that it not be specified.

       Historical implementations of <u>awk</u> produce an error if a <b>next</b> statement is executed in a <b>BEGIN</b> action, and
       cause  <u>awk</u>  to  terminate  if  a  <b>next</b> statement is executed in an <b>END</b> action. This behavior has not been
       documented, and it was not believed that it was necessary to standardize it.

       The specification of conversions between string and numeric values is much  more  detailed  than  in  the
       documentation  of  historical implementations or in the referenced <u>The</u> <u>AWK</u> <u>Programming</u> <u>Language</u>. Although
       most of the behavior is designed to be intuitive, the details are necessary to ensure compatible behavior
       from different implementations. This is especially important in relational expressions since the types of
       the operands determine whether a string or numeric comparison is performed. From the  perspective  of  an
       application developer, it is usually sufficient to expect intuitive behavior and to force conversions (by
       adding  zero or concatenating a null string) when the type of an expression does not obviously match what
       is needed. The intent has been to specify historical practice in almost all cases. The one  exception  is
       that,  in  historical  implementations,  variables  and constants maintain both string and numeric values
       after their original value is converted by any use. This means that referencing a  variable  or  constant
       can have unexpected side-effects. For example, with historical implementations the following program:

           {
               a = "+2"
               b = 2
               if (NR % 2)
                   c = a + b
               if (a == b)
                   print "numeric comparison"
               else
                   print "string comparison"
           }

       would  perform  a  numeric  comparison  (and  output  numeric comparison) for each odd-numbered line, but
       perform a string comparison (and output string comparison)  for  each  even-numbered  line.  POSIX.1‐2008
       ensures  that  comparisons  will  be numeric if necessary. With historical implementations, the following
       program:

           BEGIN {
               OFMT = "%e"
               print 3.14
               OFMT = "%f"
               print 3.14
           }

       would output <b>"3.140000e+00"</b> twice, because in the second <b>print</b> statement the constant <b>"3.14"</b> would have a
       string value from the previous conversion. POSIX.1‐2008 requires that the  output  of  the  second  <b>print</b>
       statement  be  <b>"3.140000"</b>.   The  behavior  of historical implementations was seen as too unintuitive and
       unpredictable.

       It was pointed out that with the rules contained in  early  drafts,  the  following  script  would  print
       nothing:

           BEGIN {
               y[1.5] = 1
               OFMT = "%e"
               print y[1.5]
           }

       Therefore,  a  new  variable,  <b>CONVFMT</b>,  was introduced. The <b>OFMT</b> variable is now restricted to affecting
       output conversions of numbers  to  strings  and  <b>CONVFMT</b>  is  used  for  internal  conversions,  such  as
       comparisons  or  array  indexing.  The  default  value  is the same as that for <b>OFMT</b>, so unless a program
       changes <b>CONVFMT</b> (which no  historical  program  would  do),  it  will  receive  the  historical  behavior
       associated with internal string conversions.

       The  POSIX <u>awk</u> lexical and syntactic conventions are specified more formally than in other sources. Again
       the intent has been to specify historical practice. One convention that  may  not  be  obvious  from  the
       formal  grammar  as  in other verbal descriptions is where &lt;newline&gt; characters are acceptable. There are
       several obvious placements such as terminating a statement, and a  &lt;backslash&gt;  can  be  used  to  escape
       &lt;newline&gt;  characters  between  any lexical tokens. In addition, &lt;newline&gt; characters without &lt;backslash&gt;
       characters can follow a comma, an open brace, a logical  AND  operator  (<b>"&amp;&amp;"</b>),  a  logical  OR  operator
       (<b>"||"</b>),  the <b>do</b> keyword, the <b>else</b> keyword, and the closing parenthesis of an <b>if</b>, <b>for</b>, or <b>while</b> statement.
       For example:

           { print $1,
                   $2 }

       The requirement that <u>awk</u> add a trailing &lt;newline&gt; to  the  program  argument  text  is  to  simplify  the
       grammar,  making  it  match  a  text  file  in  form. There is no way for an application or test suite to
       determine whether a literal &lt;newline&gt; is added or whether <u>awk</u> simply acts as if it did.

       POSIX.1‐2008  requires  several  changes  from   historical   implementations   in   order   to   support
       internationalization.  Probably  the  most  subtle  of  these  is the use of the decimal-point character,
       defined by the <u>LC_NUMERIC</u> category of the locale, in representations  of  floating-point  numbers.   This
       locale-specific character is used in recognizing numeric input, in converting between strings and numeric
       values,  and  in  formatting  output. However, regardless of locale, the &lt;period&gt; character (the decimal-
       point character of the POSIX locale) is the decimal-point character recognized in processing <u>awk</u> programs
       (including assignments in command line arguments). This is essentially the same  convention  as  the  one
       used  in  the  ISO C  standard.  The difference is that the C language includes the <u>setlocale</u>() function,
       which permits an application to modify its locale. Because of this capability,  a  C  application  begins
       executing  with  its  locale  set  to the C locale, and only executes in the environment-specified locale
       after an explicit call to <u>setlocale</u>().  However, adding such an elaborate new feature to the <u>awk</u> language
       was seen as inappropriate for POSIX.1‐2008. It is possible to execute an <u>awk</u> program  explicitly  in  any
       desired locale by setting the environment in the shell.

       The  undefined  behavior resulting from NULs in extended regular expressions allows future extensions for
       the GNU <u>gawk</u> program to process binary data.

       The behavior in the case of invalid <u>awk</u> programs (including lexical, syntactic, and semantic  errors)  is
       undefined  because  it  was  considered overly limiting on implementations to specify. In most cases such
       errors can be expected to produce a diagnostic and a non-zero exit status. However, some  implementations
       may  choose  to  extend  the  language in ways that make use of certain invalid constructs. Other invalid
       constructs might be deemed worthy of a warning, but otherwise cause some reasonable behavior. Still other
       constructs may be very difficult to detect in  some  implementations.   Also,  different  implementations
       might  detect  a  given  error  during an initial parsing of the program (before reading any input files)
       while others might detect it when executing the program after reading some input. Implementors should  be
       aware  that diagnosing errors as early as possible and producing useful diagnostics can ease debugging of
       applications, and thus make an implementation more usable.

       The unspecified behavior from using multi-character <b>RS</b> values is  to  allow  possible  future  extensions
       based  on  extended  regular  expressions used for record separators. Historical implementations take the
       first character of the string and ignore the others.

       Unspecified behavior when <u>split</u>(<u>string</u>,<u>array</u>,&lt;null&gt;) is used is to allow a proposed future extension that
       would split up a string into an array of individual characters.

       In the context of the <b>getline</b> function, equally good arguments for different precedences of the <b>|</b>  and  <b>&lt;</b>
       operators can be made. Historical practice has been that:

           getline &lt; "a" "b"

       is parsed as:

           ( getline &lt; "a" ) "b"

       although many would argue that the intent was that the file <b>ab</b> should be read. However:

           getline &lt; "x" + 1

       parses as:

           getline &lt; ( "x" + 1 )

       Similar problems occur with the <b>|</b> version of <b>getline</b>, particularly in combination with <b>$</b>.  For example:

           $"echo hi" | getline

       (This situation is particularly problematic when used in a <b>print</b> statement, where the <b>|getline</b> part might
       be a redirection of the <b>print</b>.)

       Since in most cases such constructs are not (or at least should not) be used (because they have a natural
       ambiguity  for  which  there  is  no conventional parsing), the meaning of these constructs has been made
       explicitly unspecified. (The effect is that a conforming application that  runs  into  the  problem  must
       parenthesize to resolve the ambiguity.)  There appeared to be few if any actual uses of such constructs.

       Grammars  can  be  written  that  would  cause  an  error  under  these  circumstances.  Where backwards-
       compatibility is not a large consideration, implementors may wish to use such grammars.

       Some historical implementations have allowed some built-in functions to be  called  without  an  argument
       list,  the  result  being  a  default argument list chosen in some ``reasonable'' way. Use of <b>length</b> as a
       synonym for <b>length($0)</b> is the only one of these forms that is thought to be widely known or widely  used;
       this  particular  form is documented in various places (for example, most historical <u>awk</u> reference pages,
       although not in the  referenced  <u>The</u>  <u>AWK</u>  <u>Programming</u>  <u>Language</u>)  as  legitimate  practice.   With  this
       exception, default argument lists have always been undocumented and vaguely defined, and it is not at all
       clear  how (or if) they should be generalized to user-defined functions. They add no useful functionality
       and preclude possible future extensions that might need to  name  functions  without  calling  them.  Not
       standardizing  them  seems  the  simplest  course. The standard developers considered that <b>length</b> merited
       special treatment, however, since it has been documented in the past and sees possibly substantial use in
       historical programs.  Accordingly,  this  usage  has  been  made  legitimate,  but  Issue 5  removed  the
       obsolescent  marking for XSI-conforming implementations and many otherwise conforming applications depend
       on this feature.

       In <b>sub</b> and <b>gsub</b>, if <u>repl</u> is a string literal (the lexical token <b>STRING</b>), then two consecutive &lt;backslash&gt;
       characters should be used in the string to ensure a single &lt;backslash&gt; will precede the &lt;ampersand&gt;  when
       the  resultant  string is passed to the function. (For example, to specify one literal &lt;ampersand&gt; in the
       replacement string, use <b>gsub</b>(<b>ERE</b>, <b>"\\&amp;"</b>).)

       Historically, the only special character in the <u>repl</u> argument of <b>sub</b> and <b>gsub</b> string  functions  was  the
       &lt;ampersand&gt;  (<b>'&amp;'</b>)  character  and  preceding  it with the &lt;backslash&gt; character was used to turn off its
       special meaning.

       The description in the ISO POSIX‐2:1993 standard introduced behavior such that the &lt;backslash&gt;  character
       was  another  special  character  and it was unspecified whether there were any other special characters.
       This description introduced several portability problems, some of which are described below,  and  so  it
       has been replaced with the more historical description. Some of the problems include:

        *  Historically,  to  create  the  replacement string, a script could use <b>gsub</b>(<b>ERE</b>, <b>"\\&amp;"</b>), but with the
           ISO POSIX‐2:1993 standard wording, it was necessary  to  use  <b>gsub</b>(<b>ERE</b>,  <b>"\\\\&amp;"</b>).   The  &lt;backslash&gt;
           characters  are doubled here because all string literals are subject to lexical analysis, which would
           reduce each pair of &lt;backslash&gt; characters to a single &lt;backslash&gt; before being passed to <b>gsub</b>.

        *  Since it was unspecified what the special characters were, for portable  scripts  to  guarantee  that
           characters  are  printed  literally,  each  character  had  to  be preceded with a &lt;backslash&gt;.  (For
           example, a portable script had to use <b>gsub</b>(<b>ERE</b>, <b>"\\h\\i"</b>) to produce a replacement string of <b>"hi"</b>.)

       The description for comparisons in the ISO POSIX‐2:1993 standard did  not  properly  describe  historical
       practice  because  of  the  way  numeric  strings  are  compared  as numbers. The current rules cause the
       following code:

           if (0 == "000")
               print "strange, but true"
           else
               print "not true"

       to do a numeric comparison, causing the <b>if</b> to succeed. It should be  intuitively  obvious  that  this  is
       incorrect behavior, and indeed, no historical implementation of <u>awk</u> actually behaves this way.

       To  fix this problem, the definition of <u>numeric</u> <u>string</u> was enhanced to include only those values obtained
       from specific circumstances (mostly external sources) where it is not possible to determine unambiguously
       whether the value is intended to be a string or a numeric.

       Variables that are assigned to a numeric string shall also be treated as a numeric string. (For  example,
       the  notion  of  a  numeric  string  can be propagated across assignments.) In comparisons, all variables
       having the uninitialized value are to be treated as a numeric operand evaluating  to  the  numeric  value
       zero.

       Uninitialized variables include all types of variables including scalars, array elements, and fields. The
       definition  of  an  uninitialized  value  in <u>Variables</u> <u>and</u> <u>Special</u> <u>Variables</u> is necessary to describe the
       value placed on uninitialized variables and on fields that are valid (for example, <b>&lt;</b>  <b>$NF</b>)  but  have  no
       characters in them and to describe how these variables are to be used in comparisons. A valid field, such
       as  <b>$1</b>,  that  has  no  characters  in  it  can  be  obtained  from an input line of <b>"\t\t"</b> when <b>FS='\t'</b>.
       Historically, the comparison (<b>$1&lt;</b>10) was done numerically after evaluating <b>$1</b> to the value zero.

       The phrase ``... also shall have the numeric value of the  numeric  string''  was  removed  from  several
       sections  of  the ISO POSIX‐2:1993 standard because is specifies an unnecessary implementation detail. It
       is not necessary for POSIX.1‐2008 to specify that these objects be assigned two different values.  It  is
       only necessary to specify that these objects may evaluate to two different values depending on context.

       Historical  implementations of <u>awk</u> did not parse hexadecimal integer or floating constants like <b>"0xa"</b> and
       <b>"0xap0"</b>.  Due to an oversight, the 2001 through 2004 editions  of  this  standard  required  support  for
       hexadecimal  floating  constants.  This was due to the reference to <u>atof</u>().  This version of the standard
       allows but does not require implementations to use <u>atof</u>() and includes a  description  of  how  floating-
       point  numbers  are recognized as an alternative to match historic behavior. The intent of this change is
       to allow implementations to recognize floating-point constants according to either the  ISO/IEC 9899:1990
       standard  or  ISO/IEC 9899:1999  standard,  and  to  allow (but not require) implementations to recognize
       hexadecimal integer constants.

       Historical implementations of <u>awk</u> did not support floating-point infinities and NaNs in <u>numeric</u>  <u>strings</u>;
       e.g.,  <b>"-INF"</b>  and  <b>"NaN"</b>.   However, implementations that use the <u>atof</u>() or <u>strtod</u>() functions to do the
       conversion picked up support for these values if they used a ISO/IEC 9899:1999 standard  version  of  the
       function  instead  of  a  ISO/IEC 9899:1990  standard version. Due to an oversight, the 2001 through 2004
       editions of this standard did not allow support for infinities and NaNs, but in this revision support  is
       allowed  (but not required). This is a silent change to the behavior of <u>awk</u> programs; for example, in the
       POSIX locale the expression:

           ("-INF" + 0 &lt; 0)

       formerly had the value 0 because <b>"-INF"</b> converted to 0, but now it may have the value 0 or 1.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       A future version of this standard may require the <b>"!="</b> and <b>"=="</b> operators to perform  string  comparisons
       by checking if the strings are identical (and not by checking if they collate equally).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>1.3</u>, <u>Grammar</u> <u>Conventions</u>, <u>grep</u>, <u>lex</u>, <u>sed</u>

       The  Base  Definitions  volume  of  POSIX.1‐2017,  <u>Chapter</u> <u>5</u>, <u>File</u> <u>Format</u> <u>Notation</u>, <u>Section</u> <u>6.1</u>, <u>Portable</u>
       <u>Character</u> <u>Set</u>, <u>Chapter</u> <u>8</u>, <u>Environment</u> <u>Variables</u>, <u>Chapter</u> <u>9</u>, <u>Regular</u> <u>Expressions</u>,  <u>Section</u>  <u>12.2</u>,  <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>

       The System Interfaces volume of POSIX.1‐2017, <u>atof</u>(), <u>exec</u>, <u>isspace</u>(), <u>popen</u>(), <u>setlocale</u>(), <u>strtod</u>()

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                           <u><a href="../man1POSIX/AWK.1POSIX.html">AWK</a></u>(1POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>