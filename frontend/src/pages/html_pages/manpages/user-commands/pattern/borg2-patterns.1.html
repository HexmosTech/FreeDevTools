<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>borg-patterns - Details regarding patterns</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/borgbackup2">borgbackup2_2.0.0b14-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       borg-patterns - Details regarding patterns

</pre><h4><b>DESCRIPTION</b></h4><pre>
       When specifying one or more file paths in a Borg command that supports patterns for the respective option
       or  argument,  you  can  apply  the  patterns described here to include only desired files and/or exclude
       unwanted ones. Patterns can be used

       • for <b>--exclude</b> option,

       • in the file given with <b>--exclude-from</b> option,

       • for <b>--pattern</b> option,

       • in the file given with <b>--patterns-from</b> option and

       • for <b>PATH</b> arguments that explicitly support them.

       Borg always stores all file paths normalized and relative to the current recursion  root.  The  recursion
       root is also named <b>PATH</b> in Borg commands like <u>borg</u> <u>create</u> that do a file discovery, so do not confuse the
       root with the <b>PATH</b> argument of e.g. <u>borg</u> <u>extract</u>.

       Starting  with  Borg  1.2,  paths  that  are matched against patterns always appear relative. If you give
       <b>/absolute/</b> as root,  the  paths  going  into  the  matcher  will  start  with  <b>absolute/</b>.   If  you  give
       <b>../../relative</b> as root, the paths will be normalized as <b>relative/</b>.

       Borg  supports  different pattern styles. To define a non-default style for a specific pattern, prefix it
       with two characters followed by a colon ':' (i.e. <b>fm:path/*</b>, <b>sh:path/**</b>).

       <b>Fnmatch</b> <b>&lt;https://docs.python.org/3/library/fnmatch.html&gt;</b>
              , selector <b>fm:</b> This is the default style for <b>--exclude</b> and <b>--exclude-from</b>.  These patterns  use  a
              variant  of  shell  pattern  syntax,  with '*' matching any number of characters, '?' matching any
              single character, '[...]' matching any single character specified, including ranges, and  '[!...]'
              matching  any  character  not  specified.  For  the  purpose of these patterns, the path separator
              (backslash for Windows and '/' on other systems) is not treated specially. Wrap meta-characters in
              brackets for a literal match (i.e. <b>[?]</b> to match the literal character '?'). For a path to match  a
              pattern, the full path must match, or it must match from the start of the full path to just before
              a  path  separator.  Except  for  the  root  path, paths will never end in the path separator when
              matching is attempted.  Thus, if a given pattern ends in a  path  separator,  a  '*'  is  appended
              before matching is attempted. A leading path separator is always removed.

       <b>Shell-style</b> <b>patterns,</b> <b>selector</b> <b>sh:</b>
              This  is  the  default  style  for <b>--pattern</b> and <b>--patterns-from</b>.  Like fnmatch patterns these are
              similar to shell patterns. The difference is that the pattern may include <b>**/</b> for matching zero or
              more directory levels, <b>*</b> for matching zero or more arbitrary characters with the exception of  any
              path  separator,  <b>{}</b>  containing comma-separated alternative patterns. A leading path separator is
              always removed.

       <b>Regular</b> <b>expressions</b> <b>&lt;https://docs.python.org/3/library/re.html&gt;</b>
              , selector <b>re:</b> Unlike shell patterns, regular expressions are not required to match the full  path
              and  any substring match is sufficient. It is strongly recommended to anchor patterns to the start
              ('^'), to the end ('$') or both. Path separators (backslash for Windows and '/' on other  systems)
              in paths are always normalized to a forward slash '/' before applying a pattern.

       <b>Path</b> <b>prefix,</b> <b>selector</b> <b>pp:</b>
              This  pattern  style is useful to match whole sub-directories. The pattern <b>pp:root/somedir</b> matches
              <b>root/somedir</b> and everything therein.  A leading path separator is always removed.

       <b>Path</b> <b>full-match,</b> <b>selector</b> <b>pf:</b>
              This pattern style is (only) useful to match full paths.  This is kind of a pseudo pattern  as  it
              can  not  have  any  variable or unspecified parts - the full path must be given. <b>pf:root/file.ext</b>
              matches <b>root/file.ext</b> only. A leading path separator is always removed.

              Implementation note: this is implemented via very  time-efficient  <a href="../man1/O.1.html">O</a>(1)  hashtable  lookups  (this
              means  you  can  have  huge  amounts of such patterns without impacting performance much).  Due to
              that, this kind of pattern does not respect any context or order.  If you use such  a  pattern  to
              include  a  file,  it  will  always be included (if the directory recursion encounters it).  Other
              include/exclude patterns that would normally match  will  be  ignored.   Same  logic  applies  for
              exclude.

       <b>NOTE:</b>
          <b>re:</b>,  <b>sh:</b>  and  <b>fm:</b>  patterns  are all implemented on top of the Python SRE engine. It is very easy to
          formulate patterns for each of these types which requires an inordinate amount of time to match paths.
          If untrusted users are able to supply patterns, ensure  they  cannot  supply  <b>re:</b>  patterns.  Further,
          ensure that <b>sh:</b> and <b>fm:</b> patterns only contain a handful of wildcards at most.

       Exclusions  can  be  passed  via  the  command  line option <b>--exclude</b>. When used from within a shell, the
       patterns should be quoted to protect them from expansion.

       The <b>--exclude-from</b> option permits loading exclusion patterns from a text file with one pattern per  line.
       Lines  empty  or  starting with the hash sign '#' after removing whitespace on both ends are ignored. The
       optional style selector prefix is also supported for patterns loaded  from  a  file.  Due  to  whitespace
       removal, paths with whitespace at the beginning or end can only be excluded using regular expressions.

       To  test  your  exclusion  patterns  without  performing  an actual backup you can run <b>borg</b> <b>create</b> <b>--list</b>
       <b>--dry-run</b> <b>...</b>.

       Examples:

          # Exclude '/home/user/file.o' but not '/home/user/file.odt':
          $ borg create -e '*.o' archive /

          # Exclude '/home/user/junk' and '/home/user/subdir/junk' but
          # not '/home/user/importantjunk' or '/etc/junk':
          $ borg create -e 'home/*/junk' archive /

          # Exclude the contents of '/home/user/cache' but not the directory itself:
          $ borg create -e home/user/cache/ archive /

          # The file '/home/user/cache/important' is *not* backed up:
          $ borg create -e home/user/cache/ archive / /home/user/cache/important

          # The contents of directories in '<a href="file:/home">/home</a>' are not backed up when their name
          # ends in '.tmp'
          $ borg create --exclude 're:^home/[^/]+\.tmp/' archive /

          # Load exclusions from file
          $ cat &gt;exclude.txt &lt;&lt;EOF
          # Comment line
          home/*/junk
          *.tmp
          fm:aa:something/*
          re:^home/[^/]+\.tmp/
          sh:home/*/.thumbnails
          # Example with spaces, no need to escape as it is processed by borg
          some file with spaces.txt
          EOF
          $ borg create --exclude-from exclude.txt archive /

       A more general and easier to use way to define filename matching patterns exists with the  <b>--pattern</b>  and
       <b>--patterns-from</b>  options.  Using  these,  you  may  specify  the backup roots, default pattern styles and
       patterns for inclusion and exclusion.

       <b>Root</b> <b>path</b> <b>prefix</b> <b>R</b>
              A recursion root path starts with the prefix <b>R</b>, followed by a path  (a  plain  path,  not  a  file
              pattern).  Use this prefix to have the root paths in the patterns file rather than as command line
              arguments.

       <b>Pattern</b> <b>style</b> <b>prefix</b> <b>P</b>
              To change the default pattern style, use the <b>P</b> prefix, followed by the pattern style  abbreviation
              (<b>fm</b>, <b>pf</b>, <b>pp</b>, <b>re</b>, <b>sh</b>).  All patterns following this line will use this style until another style is
              specified.

       <b>Exclude</b> <b>pattern</b> <b>prefix</b> <b>-</b>
              Use  the prefix <b>-</b>, followed by a pattern, to define an exclusion.  This has the same effect as the
              <b>--exclude</b> option.

       <b>Exclude</b> <b>no-recurse</b> <b>pattern</b> <b>prefix</b> <b>!</b>
              Use the prefix <b>!</b>, followed by a pattern, to  define  an  exclusion  that  does  not  recurse  into
              subdirectories.   This   saves  time,  but  prevents  include  patterns  to  match  any  files  in
              subdirectories.

       <b>Include</b> <b>pattern</b> <b>prefix</b> <b>+</b>
              Use the prefix <b>+</b>, followed by a pattern, to define inclusions.  This is useful  to  include  paths
              that are covered in an exclude pattern and would otherwise not be backed up.

       The  first matching pattern is used, so if an include pattern matches before an exclude pattern, the file
       is backed up. Note that a no-recurse exclude  stops  examination  of  subdirectories  so  that  potential
       includes will not match - use normal excludes for such use cases.

       Example:

          # Define the recursion root
          R /
          # Exclude all iso files in any directory
          - **/*.iso
          # Explicitly include all inside etc and root
          + etc/**
          + root/**
          # Exclude a specific directory under each user's home directories
          - home/*/.cache
          # Explicitly include everything in <a href="file:/home">/home</a>
          + home/**
          # Explicitly exclude some directories without recursing into them
          ! re:^(dev|proc|run|sys|tmp)
          # Exclude all other files and directories
          # that are not specifically included earlier.
          - **

       <b>Tip:</b> <b>You</b> <b>can</b> <b>easily</b> <b>test</b> <b>your</b> <b>patterns</b> <b>with</b> <b>--dry-run</b> <b>and</b>  <b>--list</b>:

          $ borg create --dry-run --list --patterns-from patterns.txt archive

       This  will  list  the  considered files one per line, prefixed with a character that indicates the action
       (e.g. 'x' for excluding, see <b>Item</b> <b>flags</b> in <u>borg</u> <u>create</u> usage docs).

       <b>NOTE:</b>
          It's possible that a sub-directory/file is matched while parent directories are  not.  In  that  case,
          parent directories are not backed up and thus their user, group, permission, etc. cannot be restored.

       Patterns (<b>--pattern</b>) and excludes (<b>--exclude</b>) from the command line are considered first (in the order of
       appearance).  Then  patterns from <b>--patterns-from</b> are added. Exclusion patterns from <b>--exclude-from</b> files
       are appended last.

       Examples:

          # back up pics, but not the ones from 2018, except the good ones:
          # note: using = is essential to avoid cmdline argument parsing issues.
          borg create --pattern=+pics/2018/good --pattern=-pics/2018 archive pics

          # back up only JPG/JPEG files (case insensitive) in all home directories:
          borg create --pattern '+ re:\.jpe?g(?i)$' archive <a href="file:/home">/home</a>

          # back up homes, but exclude big downloads (like .ISO files) or hidden files:
          borg create --exclude 're:\.iso(?i)$' --exclude 'sh:home/**<a href="file:/.">/.</a>*' archive <a href="file:/home">/home</a>

          # use a file with patterns (recursion root '/' via command line):
          borg create --patterns-from patterns.lst archive /

       The patterns.lst file could look like that:

          # "sh:" pattern style is the default
          # exclude caches
          - home/*/.cache
          # include susans home
          + home/susan
          # also back up this exact file
          + pf:home/bobby/specialfile.txt
          # don't back up the other home directories
          - home/*
          # don't even look in <a href="file:/dev">/dev</a>, <a href="file:/proc">/proc</a>, <a href="file:/run">/run</a>, <a href="file:/sys">/sys</a>, <a href="file:/tmp">/tmp</a> (note: would exclude files like /device, too)
          ! re:^(dev|proc|run|sys|tmp)

       You can specify recursion roots either on the command line or in a patternfile:

          # these two commands do the same thing
          borg create --exclude home/bobby/junk archive /home/bobby /home/susan
          borg create --patterns-from patternfile.lst archive

       patternfile.lst:

          # note that excludes use fm: by default and patternfiles use sh: by default.
          # therefore, we need to specify fm: to have the same exact behavior.
          P fm
          R /home/bobby
          R /home/susan
          - home/bobby/junk

       This allows you to share the same patterns between multiple repositories without needing to specify  them
       on the command line.

</pre><h4><b>AUTHOR</b></h4><pre>
       The Borg Collective

                                                   2025-01-03                                   <u><a href="../man1/BORG-PATTERNS.1.html">BORG-PATTERNS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>