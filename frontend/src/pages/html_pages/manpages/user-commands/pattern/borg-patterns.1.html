<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>borg-patterns - Details regarding patterns</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/borgbackup">borgbackup_1.2.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       borg-patterns - Details regarding patterns

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The path/filenames used as input for the pattern matching start from the currently active recursion root.
       You  usually  give  the recursion root(s) when invoking borg and these can be either relative or absolute
       paths.

       So,  when  you  give  <u>relative/</u>  as  root,  the  paths  going   into   the   matcher   will   look   like
       <u>relative/.../file.ext</u>. When you give <u>/absolute/</u> as root, they will look like <u>/absolute/.../file.ext</u>.

       File  paths in Borg archives are always stored normalized and relative.  This means that e.g. <b>borg</b> <b>create</b>
       <b>/path/to/repo</b> <b>../some/path</b> will store all files as <u>some/path/.../file.ext</u> and <b>borg</b>  <b>create</b>  <b>/path/to/repo</b>
       <b>/home/user</b> will store all files as <u>home/user/.../file.ext</u>.

       A  directory  exclusion  pattern  can end either with or without a slash ('/').  If it ends with a slash,
       such as <u>some/path/</u>, the directory will be included but not its content. If it does not end with a  slash,
       such as <u>some/path</u>, both the directory and content will be excluded.

       File  patterns  support  these  styles:  fnmatch,  shell,  regular  expressions,  path  prefixes and path
       full-matches. By default, fnmatch is used  for  <b>--exclude</b>  patterns  and  shell-style  is  used  for  the
       <b>--pattern</b> option. For commands that support patterns in their <b>PATH</b> argument like (<b>borg</b> <b>list</b>), the default
       pattern is path prefix.

       Starting  with Borg 1.2, for all but regular expression pattern matching styles, all paths are treated as
       relative, meaning that a leading path separator is removed after normalizing and  before  matching.  This
       allows you to use absolute or relative patterns arbitrarily.

       If followed by a colon (':') the first two characters of a pattern are used as a style selector. Explicit
       style  selection is necessary when a non-default style is desired or when the desired pattern starts with
       two alphanumeric characters followed by a colon (i.e. <u>aa:something/*</u>).

       <u>Fnmatch</u><b>,</b> <b>selector</b> <u>fm:</u>
              This is the default style for <b>--exclude</b> and <b>--exclude-from</b>.  These patterns use a variant of shell
              pattern syntax, with '*' matching any number of characters, '?'  matching  any  single  character,
              '[...]'  matching  any  single  character  specified,  including ranges, and '[!...]' matching any
              character not specified. For the purpose of these patterns,  the  path  separator  (backslash  for
              Windows and '/' on other systems) is not treated specially. Wrap meta-characters in brackets for a
              literal match (i.e. <u>[?]</u> to match the literal character <u>?</u>). For a path to match a pattern, the full
              path must match, or it must match from the start of the full path to just before a path separator.
              Except  for  the root path, paths will never end in the path separator when matching is attempted.
              Thus, if a given pattern ends in a path separator, a '*' is appended before matching is attempted.
              A leading path separator is always removed.

       <b>Shell-style</b> <b>patterns,</b> <b>selector</b> <u>sh:</u>
              This is the default style for <b>--pattern</b> and <b>--patterns-from</b>.   Like  fnmatch  patterns  these  are
              similar to shell patterns. The difference is that the pattern may include <u>**/</u> for matching zero or
              more  directory levels, <u>*</u> for matching zero or more arbitrary characters with the exception of any
              path separator. A leading path separator is always removed.

       <b>Regular</b> <b>expressions,</b> <b>selector</b> <u>re:</u>
              Regular expressions similar to those found in Perl are supported. Unlike  shell  patterns  regular
              expressions  are  not required to match the full path and any substring match is sufficient. It is
              strongly recommended to anchor patterns to the start  ('^'),  to  the  end  ('$')  or  both.  Path
              separators  (backslash  for  Windows and '/' on other systems) in paths are always normalized to a
              forward slash ('/') before applying a pattern. The regular expression syntax is described  in  the
              <u>Python</u> <u>documentation</u> <u>for</u> <u>the</u> <u>re</u> <u>module</u>.

       <b>Path</b> <b>prefix,</b> <b>selector</b> <u>pp:</u>
              This  pattern  style is useful to match whole sub-directories. The pattern <u>pp:root/somedir</u> matches
              <u>root/somedir</u> and everything therein. A leading path separator is always removed.

       <b>Path</b> <b>full-match,</b> <b>selector</b> <u>pf:</u>
              This pattern style is (only) useful to match full paths.  This is kind of a pseudo pattern  as  it
              can  not  have  any  variable or unspecified parts - the full path must be given. <u>pf:root/file.ext</u>
              matches <u>root/file.ext</u> only. A leading path separator is always removed.

              Implementation note: this is implemented via very  time-efficient  <a href="../man1/O.1.html">O</a>(1)  hashtable  lookups  (this
              means  you  can  have  huge  amounts of such patterns without impacting performance much).  Due to
              that, this kind of pattern does not respect any context or order.  If you use such  a  pattern  to
              include  a  file,  it  will  always be included (if the directory recursion encounters it).  Other
              include/exclude patterns that would normally match  will  be  ignored.   Same  logic  applies  for
              exclude.

       <b>NOTE:</b>
          <u>re:</u>,  <u>sh:</u>  and  <u>fm:</u>  patterns  are all implemented on top of the Python SRE engine. It is very easy to
          formulate patterns for each of these types which requires an inordinate amount of time to match paths.
          If untrusted users are able to supply patterns, ensure they  cannot  supply  <u>re:</u>  patterns.   Further,
          ensure that <u>sh:</u> and <u>fm:</u> patterns only contain a handful of wildcards at most.

       Exclusions  can  be  passed  via  the  command  line option <b>--exclude</b>. When used from within a shell, the
       patterns should be quoted to protect them from expansion.

       The <b>--exclude-from</b> option permits loading exclusion patterns from a text file with one pattern per  line.
       Lines  empty  or  starting with the number sign ('#') after removing whitespace on both ends are ignored.
       The optional style selector prefix is also supported for patterns loaded from a file. Due  to  whitespace
       removal, paths with whitespace at the beginning or end can only be excluded using regular expressions.

       To  test  your  exclusion  patterns  without  performing  an actual backup you can run <b>borg</b> <b>create</b> <b>--list</b>
       <b>--dry-run</b> <b>...</b>.

       Examples:

          # Exclude '/home/user/file.o' but not '/home/user/file.odt':
          $ borg create -e '*.o' backup /

          # Exclude '/home/user/junk' and '/home/user/subdir/junk' but
          # not '/home/user/importantjunk' or '/etc/junk':
          $ borg create -e '<a href="file:/home/">/home/</a>*/junk' backup /

          # Exclude the contents of '/home/user/cache' but not the directory itself:
          $ borg create -e home/user/cache/ backup /

          # The file '/home/user/cache/important' is *not* backed up:
          $ borg create -e /home/user/cache/ backup / /home/user/cache/important

          # The contents of directories in '<a href="file:/home">/home</a>' are not backed up when their name
          # ends in '.tmp'
          $ borg create --exclude 're:^<a href="file:/home/">/home/</a>[^/]+\.tmp/' backup /

          # Load exclusions from file
          $ cat &gt;exclude.txt &lt;&lt;EOF
          # Comment line
          <a href="file:/home/">/home/</a>*/junk
          *.tmp
          fm:aa:something/*
          re:^<a href="file:/home/">/home/</a>[^/]+\.tmp/
          sh:<a href="file:/home/">/home/</a>*/.thumbnails
          # Example with spaces, no need to escape as it is processed by borg
          some file with spaces.txt
          EOF
          $ borg create --exclude-from exclude.txt backup /

       A more general and easier to use way to define filename matching patterns exists with the  <b>--pattern</b>  and
       <b>--patterns-from</b> options. Using these, you may specify the backup roots (starting points) and patterns for
       inclusion/exclusion.   A root path starts with the prefix <u>R</u>, followed by a path (a plain path, not a file
       pattern). An include rule starts with the prefix +,  an  exclude  rule  starts  with  the  prefix  -,  an
       exclude-norecurse rule starts with !, all followed by a pattern.

       <b>NOTE:</b>
          Via  <b>--pattern</b>  or  <b>--patterns-from</b> you can define BOTH inclusion and exclusion of files using pattern
          prefixes <b>+</b> and <b>-</b>. With <b>--exclude</b> and <b>--exclude-from</b> ONLY excludes are defined.

       Inclusion patterns are useful to include paths that are contained in an excluded path. The first matching
       pattern is used so if an include pattern matches before an exclude pattern, the file is backed up. If  an
       exclude-norecurse  pattern matches a directory, it won't recurse into it and won't discover any potential
       matches for include rules below that directory.

       <b>NOTE:</b>
          It's possible that a sub-directory/file is matched while parent directories are not.   In  that  case,
          parent directories are not backed up thus their user, group, permission, etc. can not be restored.

       Note  that  the  default  pattern  style for <b>--pattern</b> and <b>--patterns-from</b> is shell style (<u>sh:</u>), so those
       patterns behave similar to rsync include/exclude patterns. The pattern style can be set via the <u>P</u> prefix.

       Patterns (<b>--pattern</b>) and excludes (<b>--exclude</b>) from the command line are considered first (in the order of
       appearance). Then patterns from <b>--patterns-from</b> are added. Exclusion patterns from  <b>--exclude-from</b>  files
       are appended last.

       Examples:

          # backup pics, but not the ones from 2018, except the good ones:
          # note: using = is essential to avoid cmdline argument parsing issues.
          borg create --pattern=+pics/2018/good --pattern=-pics/2018 repo::arch pics

          # use a file with patterns:
          borg create --patterns-from patterns.lst repo::arch

       The patterns.lst file could look like that:

          # "sh:" pattern style is the default, so the following line is not needed:
          P sh
          R /
          # can be rebuild
          - <a href="file:/home/">/home/</a>*/.cache
          # they're downloads for a reason
          - <a href="file:/home/">/home/</a>*/Downloads
          # susan is a nice person
          # include susans home
          + /home/susan
          # also back up this exact file
          + pf:/home/bobby/specialfile.txt
          # don't backup the other home directories
          - <a href="file:/home/">/home/</a>*
          # don't even look in <a href="file:/proc">/proc</a>
          ! <a href="file:/proc">/proc</a>

       You can specify recursion roots either on the command line or in a patternfile:

          # these two commands do the same thing
          borg create --exclude /home/bobby/junk repo::arch /home/bobby /home/susan
          borg create --patterns-from patternfile.lst repo::arch

       The patternfile:

          # note that excludes use fm: by default and patternfiles use sh: by default.
          # therefore, we need to specify fm: to have the same exact behavior.
          P fm
          R /home/bobby
          R /home/susan

          - /home/bobby/junk

       This  allows you to share the same patterns between multiple repositories without needing to specify them
       on the command line.

</pre><h4><b>AUTHOR</b></h4><pre>
       The Borg Collective

                                                   2022-02-19                                   <u><a href="../man1/BORG-PATTERNS.1.html">BORG-PATTERNS</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>