<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fvwm3styles - fvwm styles</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/fvwm3">fvwm3_1.1.2+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fvwm3styles - fvwm styles

</pre><h4><b>CONTROLLING</b> <b>WINDOW</b> <b>STYLES</b></h4><pre>
       For readability, the commands in this section are not sorted alphabetically. The description of the <b>Style</b>
       command can be found at the end of this section.

       The commands: <b>FocusStyle</b>, <b>Style</b>, and <b>WindowStyle</b> can accept optional conditional components to match some
       properties of a window.

       For example:

           Style (Name mc) Sticky

       Will make a window whose name matched 'mc' <u>Sticky</u>.

           Style (Name mc, Class XTerm) StartIconic

       This example will start an <a href="../man1/xterm.1.html">xterm</a>(1) window whose WM_CLASS matches 'XTerm' and name is 'mc'.

       A valid list of properties to test against are:

       •   Resource

       •   Class

       •   Name

       •   Icon

       •   WindowID

       The matching of the properties specified for any <b>Style</b> line are ANDed together, and for styles to be
       applied, <b>all</b> properties must match.

       <b>NOTE</b>: To destroy a style line with window properties, <b>DestroyStyle</b> should be used. For example:

           DestroyStyle (Name mc, Class XTerm)

       It is not required to specify the style arguments when destroying a style, only the property components
       are required.

       Existing <b>Style</b> lines in the form:

           Style Application* Sticky, StartIconic

       are still supported, and their behaviour remains unchanged.

                                             ∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼

       <b>FocusStyle</b> <u>stylename</u> <u>options</u>
           works exactly like the <b>Style</b> command, but accepts only the focus policy related styles beginning with
           "FP". The prefix can be removed, but at the cost of a little bit of time. <b>FocusStyle</b> is meant to make
           the configuration file more readable. Example:

               FocusStyle * EnterToFocus, !LeaveToUnfocus

           is equivalent to

               Style * FPEnterToFocus, !FPLeaveToUnfocus

       <b>DestroyStyle</b> <u>style</u>
           deletes the style named <u>style</u>. The changes take effect immediately. Note that <u>style</u> is not a
           wild-carded search string, but rather a case-sensitive string that should exactly match the original
           <b>Style</b> command.

           Destroying style "*" can be done, but isn’t really to be recommended. For example:

               DestroyStyle Application*

           This removes all settings for the style named "Application*", NOT all styles starting with
           "Application".

       <b>DestroyWindowStyle</b>
           deletes the styles set by the <b>WindowStyle</b> command on the selected window. The changes take effect
           immediately.

       <b>UpdateStyles</b>
           All pending updates of all windows' styles and looks are applied immediately. E.g. if <b>Style</b>,
           <u>WindowStyle</u> or <u>TitleStyle</u> commands were issued inside a fvwm function.

       <b>Style</b> <u>stylename</u> <u>options</u> ...
           The <b>Style</b> command is used to set attributes of a window to values other than the default or to set
           the window manager default styles.

           <u>stylename</u> can be a window’s name, class, visible name, or resource string. It may contain the
           wildcards '*' and '?', which are matched in the usual Unix filename manner. Multiple style options in
           a single <b>Style</b> command are read from left to right as if they were issued one after each other in
           separate commands. A given style always overrides all conflicting styles that have been issued
           earlier (or further left on the same style line).

           Note: windows that have no name (WM_NAME) are given a name of "Untitled", and windows that do not
           have a class (WM_CLASS, res_class) are given class "NoClass" and those that do not have a resource
           (WM_CLASS, res_name) are given resource "NoResource".

           If a window has the resource "fvwmstyle" set, the value of that resource is used in addition to any
           window names when selecting the style.

           <u>options</u> is a comma separated list containing one or more of the following keywords. Each group of
           style names is separated by slashes ('/'). The last style in these groups is the default.
           <u>BorderWidth</u>, <u>HandleWidth</u>, <u>CornerLength</u>, <u>!Icon</u> / <u>Icon</u>, <u>MiniIcon</u>, <u>IconBox</u>, <u>IconGrid</u>, <u>IconFill</u>,
           <u>IconSize</u>, <u>!Title</u> / <u>Title</u>, <u>TitleAtBottom</u> / <u>TitleAtLeft</u> / <u>TitleAtRight</u> / <u>TitleAtTop</u>, <u>LeftTitleRotatedCW</u>
           / <u>LeftTitleRotatedCCW</u>, <u>RightTitleRotatedCCW</u> / <u>RightTitleRotatedCW</u>, <u>TopTitleRotated</u> /
           <u>TopTitleNotRotated</u>, <u>BottomTitleRotated</u> / <u>BottomTitleNotRotated</u>, <u>!UseTitleDecorRotation</u> /
           <u>UseTitleDecorRotation</u>, <u>StippledTitle</u> / <u>!StippledTitle</u>, <u>StippledIconTitle</u> / <u>!StippledIconTitle</u>,
           <u>IndexedWindowName</u> / <u>ExactWindowName</u>, <u>IndexedIconName</u> / <u>ExactIconName</u>, <u>TitleFormat</u> / <u>IconTitleFormat</u> /
           <u>!Borders</u> / <u>Borders</u>, <u>!Handles</u> / <u>Handles</u>, <u>WindowListSkip</u> / <u>WindowListHit</u>, <u>CirculateSkip</u> / <u>CirculateHit</u>,
           <u>CirculateSkipShaded</u> / <u>CirculateHitShaded</u>, <u>CirculateSkipIcon</u> / <u>CirculateHitIcon</u>, <u>Layer</u>, <u>StaysOnTop</u> /
           <u>StaysOnBottom</u> / <u>StaysPut</u>, <u>Sticky</u> / <u>Slippery</u>, <u>StickyAcrossPages</u> / <u>!StickyAcrossPages</u>,
           <u>StickyAcrossDesks</u> / <u>!StickyAcrossDesks</u>, <u>!StickyStippledTitle</u> / <u>StickyStippledTitle</u>,
           <u>!StickyStippledIconTitle</u> / <u>StickyStippledIconTitle</u>, <u>StartIconic</u> / <u>StartNormal</u>,  <u>Colorset</u>,
           <u>HilightColorset</u>, <u>BorderColorset</u>, <u>HilightBorderColorset</u>, <u>IconTitleColorset</u>, <u>HilightIconTitleColorset</u>,
           <u>IconBackgroundColorset</u>, <u>IconTitleRelief</u>, <u>IconBackgroundRelief</u>, <u>IconBackgroundPadding</u>, <u>Font</u>, <u>IconFont</u>,
           <u>StartsOnDesk</u> / <u>StartsOnPage</u> / <u>StartsAnyWhere</u>, <u>StartsOnScreen</u>, <u>StartShaded</u> / <u>!StartShaded</u>,
           <u>ManualPlacementHonorsStartsOnPage</u> / <u>ManualPlacementIgnoresStartsOnPage</u>, <u>CaptureHonorsStartsOnPage</u> /
           <u>CaptureIgnoresStartsOnPage</u>, <u>RecaptureHonorsStartsOnPage</u> / <u>RecaptureIgnoresStartsOnPage</u>,
           <u>StartsOnPageIncludesTransients</u> / <u>StartsOnPageIgnoresTransients</u>, <u>IconTitle</u> / <u>!IconTitle</u>, <u>MwmButtons</u> /
           <u>FvwmButtons</u>, <u>MwmBorder</u> / <u>FvwmBorder</u>, <u>MwmDecor</u> / <u>!MwmDecor</u>, <u>MwmFunctions</u> / <u>!MwmFunctions</u>, <u>HintOverride</u>
           / <u>!HintOverride</u>, <u>!Button</u> / <u>Button</u>, <u>ResizeHintOverride</u> / <u>!ResizeHintOverride</u>, <u>OLDecor</u> / <u>!OLDecor</u>,
           <u>StickyIcon</u> / <u>SlipperyIcon</u>, <u>StickyAcrossPagesIcon</u> / <u>!StickyAcrossPagesIcon</u>, <u>StickyAcrossDesksIcon</u> /
           <u>!StickyAcrossDesksIcon</u>, <u>ManualPlacement</u> / <u>CascadePlacement</u> / <u>MinOverlapPlacement</u> /
           <u>MinOverlapPercentPlacement</u> / <u>TileManualPlacement</u> / <u>TileCascadePlacement</u> / <u>PositionPlacement</u>,
           <u>MinOverlapPlacementPenalties</u>, <u>MinOverlapPercentPlacementPenalties</u>, <u>DecorateTransient</u> /
           <u>NakedTransient</u>, <u>DontRaiseTransient</u> / <u>RaiseTransient</u>, <u>DontLowerTransient</u> / <u>LowerTransient</u>,
           <u>DontStackTransientParent</u> / <u>StackTransientParent</u>, <u>SkipMapping</u> / <u>ShowMapping</u>, <u>ScatterWindowGroups</u> /
           <u>KeepWindowGroupsOnDesk</u>, <u>UseDecor</u>, <u>UseStyle</u>, <u>!UsePPosition</u> / <u>NoPPosition</u> / <u>UsePPosition</u>,
           <u>!UseUSPosition</u>, <u>NoUSPosition</u> / <u>UseUSPosition</u>, <u>!UseTransientPPosition</u>, <u>NoTransientPPosition</u> /
           <u>UseTransientPPosition</u>, <u>!UseTransientUSPosition</u> / <u>NoTransientUSPosition</u> / <u>UseTransientUSPosition</u>,
           <u>!UseIconPosition</u> / <u>NoIconPosition</u> / <u>UseIconPosition</u>, <u>Lenience</u> / <u>!Lenience</u>, <u>ClickToFocus</u> / <u>SloppyFocus</u>
           / <u>MouseFocus</u>|<u>FocusFollowsMouse</u> / <u>NeverFocus</u>, <u>ClickToFocusPassesClickOff</u> / <u>ClickToFocusPassesClick</u>,
           <u>ClickToFocusRaisesOff</u> / <u>ClickToFocusRaises</u>, <u>MouseFocusClickRaises</u> / <u>MouseFocusClickRaisesOff</u>,
           <u>GrabFocus</u> / <u>GrabFocusOff</u>, <u>GrabFocusTransientOff</u> / <u>GrabFocusTransient</u>, <u>FPFocusClickButtons</u>,
           <u>FPFocusClickModifiers</u>, <u>!FPSortWindowlistByFocus</u> / <u>FPSortWindowlistByFocus</u>, <u>FPClickRaisesFocused</u> /
           <u>!FPClickRaisesFocused</u>, <u>FPClickDecorRaisesFocused</u> / <u>!FPClickDecorRaisesFocused</u>,
           <u>FPClickIconRaisesFocused</u> / <u>!FPClickIconRaisesFocused</u>, <u>!FPClickRaisesUnfocused</u> /
           <u>FPClickRaisesUnfocused</u>, <u>FPClickDecorRaisesUnfocused</u> / <u>!FPClickDecorRaisesUnfocused</u>,
           <u>FPClickIconRaisesUnfocused</u> / <u>!FPClickIconRaisesUnfocused</u>, <u>FPClickToFocus</u> / <u>!FPClickToFocus</u>,
           <u>FPClickDecorToFocus</u> / <u>!FPClickDecorToFocus</u>, <u>FPClickIconToFocus</u> / <u>!FPClickIconToFocus</u>, <u>!FPEnterToFocus</u>
           / <u>FPEnterToFocus</u>, <u>!FPLeaveToUnfocus</u> / <u>FPLeaveToUnfocus</u>, <u>!FPFocusByProgram</u> / <u>FPFocusByProgram</u>,
           <u>!FPFocusByFunction</u> / <u>FPFocusByFunction</u>, <u>FPFocusByFunctionWarpPointer</u> / <u>!FPFocusByFunctionWarpPointer</u>,
           <u>FPLenient</u> / <u>!FPLenient</u>, <u>!FPPassFocusClick</u> / <u>FPPassFocusClick</u>, <u>!FPPassRaiseClick</u> / <u>FPPassRaiseClick</u>,
           <u>FPIgnoreFocusClickMotion</u> / <u>!FPIgnoreFocusClickMotion</u>, <u>FPIgnoreRaiseClickMotion</u> /
           <u>!FPIgnoreRaiseClickMotion</u>, <u>!FPAllowFocusClickFunction</u> / <u>FPAllowFocusClickFunction</u>,
           <u>!FPAllowRaiseClickFunction</u> / <u>FPAllowRaiseClickFunction</u>, <u>FPGrabFocus</u> / <u>!FPGrabFocus</u>,
           <u>!FPGrabFocusTransient</u> / <u>FPGrabFocusTransient</u>, <u>FPOverrideGrabFocus</u> / <u>!FPOverrideGrabFocus</u>,
           <u>FPReleaseFocus</u> / <u>!FPReleaseFocus</u>, <u>!FPReleaseFocusTransient</u> / <u>FPReleaseFocusTransient</u>,
           <u>FPOverrideReleaseFocus</u> / <u>!FPOverrideReleaseFocus</u>, <u>StartsLowered</u> / <u>StartsRaised</u>, <u>IgnoreRestack</u> /
           <u>AllowRestack</u>, <u>FixedPosition</u> / <u>VariablePosition</u>, <u>FixedUSPosition</u> / <u>VariableUSPosition</u>, <u>FixedPPosition</u>
           / <u>VariablePPosition</u>, <u>FixedSize</u> / <u>VariableSize</u>, <u>FixedUSSize</u> / <u>VariableUSSize</u>, <u>FixedPSize</u> /
           <u>VariablePSize</u>, <u>!Closable</u> / <u>Closable</u>, <u>!Iconifiable</u> / <u>Iconifiable</u>, <u>!Maximizable</u> / <u>Maximizable</u>,
           <u>!AllowMaximizeFixedSize</u> / <u>AllowMaximizeFixedSize</u>, <u>IconOverride</u> / <u>NoIconOverride</u> /
           <u>NoActiveIconOverride</u>, <u>DepressableBorder</u> / <u>FirmBorder</u>, <u>MinWindowSize</u>, <u>MaxWindowSize</u>,
           <u>IconifyWindowGroups</u> / <u>IconifyWindowGroupsOff</u>, <u>ResizeOpaque</u> / <u>ResizeOutline</u>, <u>BackingStore</u> /
           <u>BackingStoreOff</u> / <u>BackingStoreWindowDefault</u>, <u>Opacity</u> / <u>ParentalRelativity</u>, <u>SaveUnder</u> / <u>SaveUnderOff</u>,
           <u>WindowShadeShrinks</u> / <u>WindowShadeScrolls</u>, <u>WindowShadeSteps</u>, <u>WindowShadeAlwaysLazy</u> / <u>WindowShadeBusy</u> /
           <u>WindowShadeLazy,</u> <u>EWMHDonateIcon</u> / <u>EWMHDontDonateIcon</u>, <u>EWMHDonateMiniIcon</u> / <u>EWMHDontDonateMiniIcon</u>,
           <u>EWMHMiniIconOverride</u> / <u>EWMHNoMiniIconOverride</u>, <u>EWMHUseStackingOrderHints</u> /
           <u>EWMHIgnoreStackingOrderHints</u>, <u>EWMHIgnoreStateHints</u> / <u>EWMHUseStateHints</u>, <u>EWMHIgnoreStrutHints</u> /
           <u>EWMHUseStrutHints</u>, <u>EWMHIgnoreWindowType</u> / <u>!EWMHIgnoreWindowType</u>, <u>EWMHMaximizeIgnoreWorkingArea</u> /
           <u>EWMHMaximizeUseWorkingArea</u> / <u>EWMHMaximizeUseDynamicWorkingArea</u>, <u>EWMHPlacementIgnoreWorkingArea</u> /
           <u>EWMHPlacementUseWorkingArea</u> / <u>EWMHPlacementUseDynamicWorkingArea</u>, <u>MoveByProgramMethod</u>, <u>Unmanaged</u>,
           <u>State</u>, <u>SnapGrid</u>, <u>SnapAttraction</u>, <u>EdgeMoveDelay</u>, <u>EdgeResizeDelay</u>. <u>EdgeMoveResistance</u>,
           <u>InitialMapCommand</u>

           In the above list some options are listed as style-option/opposite-style-option. The
           opposite-style-option for entries that have them describes the fvwm default behavior and can be used
           if you want to change the fvwm default behavior.

           <b>Focus</b> <b>policy</b>
               <u>ClickToFocus</u> instructs fvwm to give the focus to a window when it is clicked in. The default
               <u>MouseFocus</u> (or its alias <u>FocusFollowsMouse</u>) tells fvwm to give a window the focus as soon as the
               pointer enters the window, and take it away when the pointer leaves the window. <u>SloppyFocus</u> is
               similar, but doesn’t give up the focus if the pointer leaves the window to pass over the root
               window or a ClickToFocus window (unless you click on it, that is), which makes it possible to
               move the mouse out of the way without losing focus. A window with the style <u>NeverFocus</u> never
               receives the focus. This is useful for modules like <b>FvwmButtons</b>. for example. Note: Once any of
               the "FP..." styles has been used, the defaults that come with the basic focus policies are not
               restored when the latter are used again. For example, once !FPGrabFocus has been used, using
               ClickToFocus does not restore FPGrabFocus.

               The focus model can be augmented with several additional options. In fvwm-2.5.3 and later, there
               are a large number of advanced options beginning with "FP" or "!FP". These options shall replace
               the older options one day and are described first. Using any of these new options may limit
               compatibility with older releases. In general, options beginning with "FP" turn a feature on,
               while those beginning with "!FP" turn it off.

           <b>Focusing</b> <b>the</b> <b>window</b>
               With <u>FPEnterToFocus</u>, when the pointer enters a window it receives focus.

               With <u>FPLeaveToUnfocus</u> a window loses focus when the pointer leaves it.

               With <u>FPClickToFocus</u>, <u>FPClickDecorToFocus</u> or <u>FPClickIconToFocus</u>, a window receives focus when the
               inside of the window or the decorations or its icon is clicked.

               The <u>FPFocusByProgram</u> style allows windows to take the focus themselves.

               The !<u>FPFocusByFunction</u> style forbids that a window receives the focus via the <b>Focus</b> and <b>FlipFocus</b>
               commands.

               The <u>FPFocusByFunctionWarpPointer</u> style controls if the pointer is warped to a selected window
               when the <b>Focus</b> command is used.

               <u>FPLenient</u> allows focus on windows that do not want it, like <b>FvwmPager</b> or xclock.

               The <u>FPFocusClickButtons</u> style takes a list of mouse buttons that can be clicked to focus or raise
               a window when the appropriate style is used. The default is to use the first three buttons
               ("123").

               The <u>FPFocusClickModifiers</u> style takes a list of modifier keys just like the <b>Key</b> command. The
               exact combination of modifier keys must be pressed for the click to focus or raise a window to
               work. The default is to use no modifiers ("N").

               With the <u>FPPassFocusClick</u> style, the click that was used to focus a window is passed to the
               application.

               With the <u>FPAllowFocusClickFunction</u> style, the click that was used to focus a window can also
               trigger a normal action that was bound to the window with the <b>Mouse</b> command).

               If the <u>FPIgnoreFocusClickMotion</u> style is used, clicking in a window and then dragging the pointer
               with the button held down does not count as the click to focus the window. Instead, the
               application processes these events normally. This is useful to select text in a terminal window
               with the mouse without raising the window. However, mouse bindings on the client window are not
               guaranteed to work anymore (see <b>Mouse</b> command). This style forces the initial click to be passed
               to the application. The distance that the pointer must be moved to trigger this is controlled by
               the <b>MoveThreshold</b> command.

               The <u>FPSortWindowlistByFocus</u> and !<u>FPSortWindowlistByFocus</u> styles control whether the internal
               window list is sorted in the order the windows were focused or in the order they were created.
               The latter is the default for <u>ClickToFocus</u> and <u>SloppyFocus</u>.

               <b>Clicking</b> <b>the</b> <b>window</b> <b>to</b> <b>raise</b>

               The styles <u>FPClickRaisesFocused</u>, <u>FPClickDecorRaisesFocused</u> and <u>FPClickIconRaisesFocused</u> allow one
               to raise the window when the interior or the decorations or the icon of the window is clicked
               while the window is already focused.

               The styles <u>FPClickRaisesUnfocused</u>, <u>FPClickDecorRaisesUnfocused</u> and <u>FPClickIconRaisesUnfocused</u>
               allow one to raise the window when the interior or the decorations or the icon of the window is
               clicked while the window is not yet focused.

               With the <u>FPPassRaiseClick</u> style, the click that was used to raise the window is passed to the
               application.

               With the <u>FPAllowRaiseClickFunction</u> style, the click that was used to raise the window can also
               trigger a normal action that was bound to the window with the <b>Mouse</b> command.

               If the <u>FPIgnoreRaiseClickMotion</u> style is used, clicking in a window and then dragging the pointer
               with the button held down does not count as the click to raise the window. Instead, the
               application processes these events normally. This is useful to select text in a terminal window
               with the mouse without raising the window. However, mouse bindings on the client window are not
               guaranteed to work anymore (see <b>Mouse</b> command. Note that this style forces that the initial click
               is passed to the application. The distance that the pointer must be moved to trigger this is
               controlled by the <b>MoveThreshold</b> command.

               <b>Grabbing</b> <b>the</b> <b>focus</b> <b>when</b> <b>a</b> <b>new</b> <b>window</b> <b>is</b> <b>created</b>

               New normal or transient windows with the <u>FPGrabFocus</u> or <u>FPGrabFocusTransient</u> style automatically
               receive the focus when they are created. <u>FPGrabFocus</u> is the default for windows with the
               <u>ClickToFocus</u> style. Note that even if these styles are disabled, the application may take the
               focus itself. Fvwm can not prevent this.

               The <u>OverrideGrabFocus</u> style instructs fvwm to never take away the focus from such a window via
               the <u>GrabFocus</u> or <u>GrabFocusTransient</u> styles. This can be useful if you like to have transient
               windows receive the focus immediately, for example in a web browser, but not while you are
               working in a terminal window or a text processor.

               The above three styles are accompanied by <u>FPReleaseFocus</u>, <u>FPReleaseFocusTransient</u> and
               <u>FPOverrideReleaseFocus</u>. These control if the focus is returned to another window when the window
               is closed. Otherwise no window or the window under the pointer receives the focus.

               <u>ClickToFocusPassesClickOff</u> and <u>ClickToFocusPassesClick</u> controls whether a mouse click to focus a
               window is sent to the application or not. Similarly,
               <u>ClickToFocusRaisesOff</u>/<u>MouseFocusClickRaisesOff</u> and <u>ClickToFocusRaises</u>/<u>MouseFocusClickRaises</u>
               control if the window is raised (but depending on the focus model).

               Note: in fvwm versions prior to 2.5.3, the "Click..." options applied only to windows with
               <u>ClickToFocus</u> while the "Mouse..." options applied to windows with a different focus policy. This
               is no longer the case.

               The old <u>GrabFocus</u> style is equivalent to using <u>FPGrabFocus</u>
               <u>FPReleaseFocus</u>.

               The old <u>GrabFocusTransient</u> style is equivalent to using <u>FPGrabFocusTransient</u> +
               <u>FPReleaseFocusTransient</u>.

               <u>Lenience</u> is equivalent to the new style <u>FPLenient</u>.

       <b>Window</b> <b>title</b>
           The <u>Title</u> and !Title options determine whether the window is decorated with a title-bar. By default
           all windows have a title-bar. <u>NoTitle</u> is equivalent to <u>!Title</u> but is deprecated.

           Windows with the <u>TitleAtBottom</u>, <u>TitleAtLeft</u> or <u>TitleAtRight</u> style have a title-bar below, to the left
           or to the right of the window instead of above as usual. The <u>TitleAtTop</u> style restores the default
           placement. Even if the window has the <u>!Title</u> style set, this affects the <b>WindowShade</b> command. Please
           check the <b>WindowShade</b> command for interactions between that command and these styles. Titles on the
           left or right side of the windows are augmented by the following styles:

           Normally, the text in titles on the left side of a window is rotated counterclockwise by 90 degrees
           from the normal upright position and 90 degrees clockwise for titles on the right side. It can also
           be rotated in the opposite directions with <u>LeftTitleRotatedCW</u> if <u>TitleAtLeft</u> is used, and with
           <u>RightTitleRotatedCCW</u> if <u>TitleAtRight</u> is used. The defaults can be restored with <u>LeftTitleRotatedCCW</u>
           and <u>RightTitleRotatedCW</u>. A normal horizontal text may be rotated as well with <u>TopTitleRotated</u> if
           <u>TitleAtTop</u> is used, and with <u>BottomTitleRotated</u> if <u>TitleAtBottom</u> is used. The defaults can be
           restored with <u>TopTitleNotRotated</u> and <u>BottomTitleNotRotated</u>.

           By default the title bar decoration defined using the <b>TitleStyle</b> command is rotated following the
           title text rotation (see the previous paragraph). This can be disabled by using the
           !<u>UseTitleDecorRotation</u> style. <u>UseTitleDecorRotation</u> reverts back to the default.

           With the <u>StippledTitle</u> style, titles are drawn with the same effect that is usually reserved for
           windows with the <u>Sticky</u>, <u>StickyAcrossPages</u> or <u>StickyAcrossDesks</u> style. <u>!StippledTitle</u> reverts back to
           normal titles. <u>StippledTitleOff</u> is equivalent to <u>!StippledTitle</u> but is deprecated.

           <b>Colorset</b> takes the colorset number as its sole argument and overrides the colors set by <u>Color</u>.
           Instead, the corresponding colors from the given colorset are used. Note that all other features of a
           colorset are not used. Use the <b>Colorset</b> decoration style in the <b>TitleStyle</b> and <u>ButtonStyle</u> command
           for that. To stop using the colorset, the colorset number is omitted.

           <u>BorderColorset</u> takes eight positive integers as its arguments and will apply the given colorsets to
           the eight individual components of the window border.

           For backwards compatibility, if one integer is supplied, that is applied to all window border
           components.

           The border is split up into the following definitions, and is the same order as the colorsets which
           will be applied to the border.

               BorderColorset North, North East, East, South East, South, South West, West, North West

           <u>North</u>, <u>East</u>, <u>South</u>, and <u>West</u> refer to the top, left, bottom, and right sides of the window border.

           <u>NE</u>, <u>SE</u>, <u>SW</u>, and <u>NW</u> refer to the window handles.

           <b>NOTE</b>: due to how window handles are rendered, there is no way to make one complete edge of a window
           the same color as defined by either <u>North</u>, <u>South</u>, <u>East</u>, or <u>West</u>.

           The <u>HilightBorderColorset</u> style option works the same as <u>BorderColorset</u> but is used when the window
           has the focus.

           !<u>IconTitle</u> disables displaying icon labels while the opposite style <u>IconTitle</u> enables icon labels
           (default behaviour). <u>NoIconTitle</u> is equivalent to <u>!IconTitle</u> but is deprecated.

           <u>IconTitleColorset</u> takes the colorset number as its sole argument and overrides the colors set by
           <u>Color</u> or <u>Colorset</u>. To stop using this colorset, the argument is omitted.

           <u>HilightIconTitleColorset</u> takes the colorset number as its sole argument and overrides the colors set
           by <u>HilightColorset</u>. To stop using this colorset, the argument is omitted.

           <u>IconBackgroundColorset</u> takes the colorset number as its sole argument and uses it to set a background
           for the icon picture. By default the icon picture is not drawn onto a background image. To restore
           the default, the argument is omitted.

           <u>IconTitleRelief</u> takes one numeric argument that may be between -50 and +50 pixels and defines the
           thickness of the 3D relief drawn around the icon title. With negative values the icon title gets a
           pressed in look. The default is 2 and it is restored if the argument is omitted.

           <u>IconBackgroundRelief</u> takes one numeric argument that may be between -50 and +50 pixels and defines
           the thickness of the 3D relief drawn around the icon picture background (if any). With negative
           values the icon background gets a pressed in look. The default is 2 and it is restored if the
           argument is omitted.

           <u>IconBackgroundPadding</u> takes one numeric argument that may be between 0 and 50 pixels and defines the
           amount of free space between the relief of the icon background picture (if any) and the icon picture.
           The default is 2 and it is restored if the argument is omitted.

           The <u>Font</u> and <u>IconFont</u> options take the name of a font as their sole argument. This font is used in
           the window or icon title. By default the font given in the <b>DefaultFont</b> command is used. To revert
           back to the default, use the style without the name argument.

           The deprecated <u>IndexedWindowName</u> style causes fvwm to use window titles in the form

               name (i)

           where <u>name</u> is the exact window name and <u>i</u> is an integer which represents the <u>i</u> <u>th</u> window with <u>name</u> as
           window name. This has been replaced with:

               TitleFormat %n (%t)

           <u>ExactWindowName</u> restores the default which is to use the exact window name. Deprecated in favour of:

               TitleFormat %n

           <u>IndexedIconName</u> and <u>ExactIconName</u> work the same as <u>IndexedWindowName</u> and <u>ExactWindowName</u> styles but
           for the icon titles. Both are deprecated in favour of:

               IconTitleFormat %n (%t)
               IconTitleFormat %n

           <u>TitleFormat</u> describes what the visible name of a window should look like, with the following
           placeholders being valid:

           <b>%n</b>
               Insert the window’s name.

           <b>%i</b>
               Insert the window’s icon name.

           <b>%c</b>
               Insert the window’s class name.

           <b>%r</b>
               Insert the window’s resource name.

           <b>%t</b>
               Insert the window count.

           <b>%I</b>
               Insert the window ID.

           <b>%%</b>
               Insert a literal '%' character.

               Any amount of whitespace may be used, along with other characters to make up the string — but a
               valid <u>TitleFormat</u> string must contain at least one of the placeholders mentioned. No quote
               stripping is performed on the string, so for example the following is printed verbatim:

                   TitleFormat " %n " -&gt; [%t] -&gt;      [%c]

               Note: It’s perfectly possible to use a <u>TitleFormat</u> which can result in wiping out the visible
               title altogether. For example:

                   TitleFormat %z

               Simply because the placeholder '%z' isn’t supported. This is not a bug but rather a facet of how
               the formatting parser works.

           <u>IconTitleFormat</u> describes what the visible icon name of a window should look like, with the options
           being the same as <u>TitleFormat</u>.

       <b>Title</b> <b>buttons</b>
           <u>Button</u> and !<u>Button</u> take a numeric argument which is the number of the title-bar button which is to be
           shown or omitted. <u>NoButton</u> is equivalent to <u>!Button</u> but is deprecated.

           <u>MwmButtons</u> makes the <b>Maximize</b> button look pressed-in when the window is maximized. See the
           <u>MwmDecorMax</u> flag in <b>ButtonStyle</b> for more information. To switch this style off again, use the
           <b>FvwmButtons</b> style.

       <b>Borders</b>
           !<u>Borders</u> suppresses the window border (but not the title) completely. The <u>Borders</u> style enables them
           again. Without borders, all other styles affecting window borders are meaningless.

           <u>MwmBorder</u> makes the 3D bevel more closely match Mwm’s. <u>FvwmBorder</u> turns off the previous option.

           With the !<u>Handles</u> style, the window does not get the handles in the window corners that are commonly
           used to resize it. With <u>!Handles</u>, the width from the <u>BorderWidth</u> style is used. By default, or if
           <u>Handles</u> is specified, the width from the <u>HandleWidth</u> style is used. <u>NoHandles</u> is equivalent to
           <u>!Handles</u> but is deprecated.

           <u>HandleWidth</u> takes a numeric argument which is the width of the border to place the window if it does
           have resize-handles. Using <u>HandleWidth</u> without an argument restores the default.

           <u>CornerLength</u> takes a single numeric argument which is the length, in pixels, of the corner handles.
           The default is the title height. Using <u>CornerLength</u> without an argument restores the default.

           <u>BorderWidth</u> takes a numeric argument which is the width of the border to place the window if it does
           not have resize-handles. It is used only if the <u>!Handles</u> style is specified too. Using <u>BorderWidth</u>
           without an argument restores the default.

           <u>DepressableBorder</u> makes the border parts of the window decoration look sunken in when a button is
           pressed over them. This can be disabled again with the <u>FirmBorder</u> style.

       <b>Icons,</b> <b>shading,</b> <b>maximizing,</b> <b>movement,</b> <b>resizing</b>
           <u>Icon</u> takes an (optional) unquoted string argument which is the icon bitmap or pixmap to use. Icons
           specified this way override pixmap icons, but not icon windows or the ewmh icon, provided by the
           client in the application (with the WM_HINTS property or with the ewmh _NET_WM_ICON property). The
           <u>IconOverride</u> style changes the behavior to override any client-provided icons; the <u>NoIconOverride</u>
           style changes the behavior to not override any client-provided icons; the default overriding behavior
           can be activated with the <u>NoActiveIconOverride</u> style. With this style, fvwm uses application provided
           icons if the icon is changed but uses the icon provided in the configuration file until then.

           There is one exception to these rules, namely

               Style * Icon unknown.xpm

           doesn’t force the unknown.xpm icon on every window, it just sets the default icon like the
           DefaultIcon command. If you really want all windows to have the same icon, you can use

               Style ** Icon unknown.xpm

           If the <u>NoIcon</u> attribute is set then the specified window simply disappears when it is iconified. The
           window can be recovered through the window-list. If <u>Icon</u> is set without an argument then the <u>NoIcon</u>
           attribute is cleared but no icon is specified. An example which allows only the <b>FvwmPager</b> module icon
           to exist:

               Style * NoIcon
               Style FvwmPager Icon

           <u>IconBox</u> takes no argument, four numeric arguments (plus optionally a screen specification), an X11
           geometry string or the string "none":

               IconBox [screen scr-spec] l t r b

           or

               IconBox geometry

           Where <u>l</u> is the left coordinate, <u>t</u> is the top, <u>r</u> is right and <u>b</u> is bottom. Negative coordinates
           indicate distance from the right or bottom of the screen. If the first argument is the word <u>screen</u>,
           the <u>scr-spec</u> argument specifies the RandR screen on which the IconBox is defined ´or the additional
           'w' for the screen where the window center is located. This is only useful with multiple screens. The
           "l t r b" specification is more flexible than an X11 geometry. For example:

               IconBox -80 240 -1 -1

           defines a box that is 80 pixels wide from the right edge, 240 pixels down from the top, and continues
           to the bottom of the screen.

           Perhaps it is easier to use is an X11 geometry string though:

               IconBox 1000x70-1-1

           places an 1000 by 70 pixel icon box on the bottom of the screen starting in the lower right hand
           corner of the screen. One way to figure out a geometry like this is to use a window that resizes in
           pixel increments, for example, xv. Then resize and place the xv window where you want the iconbox.
           Then use FvwmIdent to read the windows geometry. The icon box is a region of the screen where fvwm
           attempts to put icons for any matching window, as long as they do not overlap other icons. Multiple
           icon boxes can be defined as overflow areas. When the first icon box is full, the second one is
           filled. All the icon boxes for one style must be defined in one <b>Style</b> command. For example:

               Style * IconBox -80 240 -1 -1, \
                 IconBox 1000x70-1-1

           A Style command with the IconBox option replaces any icon box defined previously by another Style
           command for the same style. That’s why the backslash in the previous example is required.

           Note: The geometry for the icon box command takes the additional screen specifier "@w" in case RandR
           is used. This designates the screen where the window center is located. The additional screen
           specifier is not allowed anywhere else.

           If you never define an icon box, or you fill all the icon boxes, fvwm has a default icon box that
           covers the screen, it fills top to bottom, then left to right, and has an 80x80 pixel grid. To
           disable all but the default icon box you can use IconBox without arguments in a separate <b>Style</b>
           command. To disable all icon boxes including the default icon box, the argument "none" can be
           specified.

           Hint: You can auto arrange your icons in the icon box with a simple fvwm function. Put the
           "DeiconifyAndRearrange" function below in your configuration file:

               AddToFunc DeiconifyAndRearrange
                + C Iconify off
                + C All (CurrentPage, Iconic) PlaceAgain Icon

           And then replace all places where you call the <b>Iconify</b> command to de-iconify an icon with a call to
           the new function. For example replace

               AddToFunc IconFunc
                + C Iconify off
                + M Raise
                + M Move
                + D Iconify off

               Mouse 1 I A Iconify off

           with

               AddToFunc IconFunc
                + C DeiconifyAndRearrange
                + M Raise
                + M Move
                + D DeiconifyAndRearrange

               Mouse 1 I A DeiconifyAndRearrange

           <u>IconGrid</u> takes 2 numeric arguments greater than zero.

               IconGrid x y

           Icons are placed in an icon box by stepping through the icon box using the <u>x</u> and <u>y</u> values for the
           icon grid, looking for a free space. The default grid is 3 by 3 pixels which gives a tightly packed
           appearance. To get a more regular appearance use a grid larger than your largest icon. Use the
           <u>IconSize</u> argument to clip or stretch an icon to a maximum size. An <u>IconGrid</u> definition must follow
           the <b>IconBox</b> definition that it applies to:

               Style * IconBox -80x240-1-1, IconGrid 90 90

           <u>IconFill</u> takes 2 arguments.

               IconFill Bottom Right

           Icons are placed in an icon box by stepping through the icon box using these arguments to control the
           direction the box is filled in. By default the direction is left to right, then top to bottom. This
           would be expressed as:

               IconFill left top

           To fill an icon box in columns instead of rows, specify the vertical direction (top or bottom) first.
           The directions can be abbreviated or spelled out as follows: "t", "top", "b", "bot", "bottom", "l",
           "lft", "left", "r", "rgt", "right". An <b>IconFill</b> definition must follow the <b>IconBox</b> definition that it
           applies to:

               Style * IconBox -80x240-1-1, IconFill b r

           <u>IconSize</u> sets limits on the size of an icon image. Both user-provided and application-provided icon
           images are affected.

               IconSize [ width height [ maxwidth maxheight ] ]

           All arguments are measured in pixels. When all four arguments are passed to <u>IconSize,</u> <u>width</u> and
           <u>height</u> represent the minimum size of an icon, and <u>maxwidth</u> and <u>maxheight</u> represent the maximum size
           of an icon. Icon images that are smaller than the minimum size are padded. Icon images that are
           bigger than the maximum size are clipped.

           If only two arguments are passed to <u>IconSize,</u> <u>width</u> and <u>height</u> represent the absolute size of an
           icon. Icons covered by this style are padded or clipped to achieve the given size.

           If no arguments are specified, the default values are used for each dimension. This effectively
           places no limits on the size of an icon.

           The value of "-1" can be used in place of any of the arguments to specify the default value for that
           dimension.

           In addition to the numeric arguments, 1 additional argument can be "Stretched", "Adjusted", or
           "Shrunk".

           Note that module provided icon managers are not affected by this style.

           <u>MiniIcon</u> specifies a pixmap to use as the miniature icon for the window. This miniature icon can be
           drawn in a title-bar button (see <b>ButtonStyle</b>), and can be used by various fvwm modules (<b>FvwmIconMan</b>
           and <b>FvwmPager</b>). It takes the name of a pixmap as an argument.

           <u>WindowShadeShrinks</u> and <u>WindowShadeScrolls</u> control if the contents of a window that is being shaded
           with the <b>WindowShade</b> command are scrolled (default) or if they stay in place. The shrinking mode is a
           bit faster

           The <u>WindowShadeSteps</u> option selects the number of steps for animation when shading a window with
           <b>WindowShade</b>. It takes one number as its argument. If the number has a trailing '<u>p</u>' it sets the number
           of pixels to use as the step size instead of a fixed number of steps. 0 disables the animation. This
           happens too if the argument is omitted or invalid.

           The <b>WindowShade</b> command has two modes of operation: busy and lazy shading. Busy shading can be 50%
           slower than lazy shading, but the latter can look strange under some conditions, for example, if the
           window borders, buttons or the title are filled with a tiled pixmap. Also, the window handles are not
           drawn in lazy mode and the border relief may only be drawn partially right before the window reaches
           the shaded state or tight after leaves the unshaded state. By default, fvwm uses lazy mode if there
           are no bad visual effects (not counting the window handles) and busy mode otherwise. Use the
           <u>WindowShadeAlwaysLazy</u> <u>or</u> <u>WindowShadeBusy</u> to force using the lazy or busy mode. The default setting is
           restored with <u>WindowShadeLazy</u>.

           <u>ResizeOpaque</u> instructs fvwm to resize the corresponding windows with their contents visible instead
           of using an outline. Since this causes the application to redraw frequently it can be quite slow and
           make the window flicker excessively, depending on the amount of graphics the application redraws. The
           <u>ResizeOutline</u> style (default) negates the <u>ResizeOpaque</u> style. Many applications do not like their
           windows being resized opaque, e.g. XEmacs, Netscape or terminals with a pixmap background. If you do
           not like the result, do not use the <u>ResizeOpaque</u> style for these windows. To exempt certain windows
           from opaque resizing you could use these lines in your configuration file:

               Style * ResizeOpaque
               Style rxvt ResizeOutline
               Style emacs ResizeOutline

           <u>Sticky</u> makes the window sticky, i.e. it is always visible on each page and each desk. The opposite
           style, <u>Slippery</u> reverts back to the default.

           <u>StickyIcon</u> makes the window sticky when it’s iconified. It de-iconifies on top the active desktop.
           <u>SlipperyIcon</u> reverts back to the default.

           <u>StickyAcrossPages</u> and <u>StickyAcrossPagesIcon</u> work like <u>Sticky</u> and <u>StickyIcon</u>, but stick the window
           only across pages, not desks while <u>StickyAcrossDesks</u> <u>and</u> <u>StickyAcrossDesksIcon</u> works the other way
           round.

           Windows that have been marked as <u>Sticky</u> or <u>StickyAcrossDesks</u> or <u>StickyAcrossPages</u> will have stipples
           drawn on the titlebar. This can be negated with the !<u>StickyStippledTitle</u> style. The style
           <u>StickyStippledTitle</u> puts back the stipples where that window has also been marked as <u>Sticky</u>. Note
           that this is the default style for <u>Sticky</u> windows. Sticky icons will have stipples drawn on the icon
           title. This can be disabled in the same way with the !<u>StickyStippledIconTitle</u> style.

           Windows with the <u>StartIconic</u> style are shown as icons initially. Note that some applications
           counteract that by deiconifying themselves. The default is to not iconify windows and can be set with
           the <u>StartNormal</u> style.

           <u>StickyIcon</u> makes the window sticky when it’s iconified. It de-iconifies on top the active desktop.
           <u>SlipperyIcon</u> reverts back to the default.

           <u>StickyIconPage</u> works like <u>StickyIcon</u>, but sticks the icon only across pages, not desks while
           <u>StickyIconDesk</u> works the other way round.

           <u>StippledIconTitle</u> works like <u>StippledTitle</u> in that it draws stipples on the titles of icons but
           doesn’t make the icon sticky.

           <u>IgnoreRestack</u> makes fvwm ignore attempts of clients to raise or lower their own windows. By default,
           the opposite style, <u>AllowRestack</u> is active.

           <u>FixedPosition</u> and <u>FixedUSPosition</u> make fvwm ignore attempts of the user to move the window. It is
           still possible to move the window by resizing it. To allow the user to move windows, use the
           <u>VariablePosition</u> or <u>VariableUSPosition</u> style.

           <u>FixedSize</u> and <u>FixedUSSize</u> make fvwm ignore attempts of the user to resize the window. To allow the
           user to resize windows, use the <u>VariableSize</u> or <u>VariableUSSize</u> style.

           <u>FixedPPosition</u> and <u>FixedPSize</u> make fvwm ignore attempts of the program to move or resize its windows.
           To allow this kind of actions, use the <u>VariablePPosition</u> or <u>VariablePSize</u> style. These styles may
           sometimes affect the initial placement and dimensions of new windows (depending on the application).
           If windows are created at strange places, try either the <u>VariablePPosition</u> or <u>!UsePPosition</u> styles.
           The <u>FixedPSize</u> style may screw up window dimensions for some applications. Do Not use this style in
           this case.

           <u>MoveByProgramMethod</u> affects how fvwm reacts to requests by the application to move its windows. By
           default, fvwm tries to detect which method to use, but it sometimes detects the wrong method. You may
           come across a window that travels across the screen by a few pixels when the application resizes it,
           moves to a screen border with the frame decorations off screen, that remembers its position for the
           next time it starts but appears in a slighly shifted position, or that attepmts to become full screen
           but has the. Try out both options, <u>UseGravity</u> and <u>IgnoreGravity</u> on the window (and that window only)
           and see if that helps. By default, fvwm uses the <u>AutoDetect</u> method. Once the method was detected, it
           is never changed again. As long as fvwm can not detect the proper method, it uses <u>IgnoreGravity</u>. To
           force fvwm to retry the detection, use one of the other two options first and then use <u>AutoDetect</u>
           again.

           Note: This option was introduced to alleviate a problem with the ICCCM specification. The ICCCM
           clearly states that the <u>UseGravity</u> option should be used, but traditionally applications ignored this
           rule.

           <u>Closable</u> enables the functions <b>Close</b>, <b>Delete</b> and <b>Destroy</b> to be performed on the windows. This is on
           by default. The opposite, <u>!Closable</u>, inhibits the window to be closed.

           <u>Iconifiable</u> enables the function <b>Iconify</b> to be performed on the windows. This is on by default. The
           opposite, <u>!Iconifiable</u>, inhibits the window from being iconified.

           <u>Maximizable</u> enables the function <b>Maximize</b> to be performed on the windows. This is on by default. The
           opposite, <u>!Maximizable</u>, inhibits the window from being maximized.

           <u>AllowMaximizeFixedSize</u> enables the function <b>Maximize</b> to be performed on windows that are not
           resizable, unless maximization has been disabled either using the style <u>!Maximizable</u> or through WM
           hints. This is on by default. The opposite, <u>!AllowMaximizeFixedSize</u>, inhibits all windows that are
           not resizable from being maximized.

           <u>ResizeHintOverride</u> instructs fvwm to ignore the program supplied minimum and maximum size as well as
           the resize step size (the character size in many applications). This can be handy for broken
           applications that refuse to be resized. Do not use it if you do not need it. The default (opposite)
           style is <u>NoResizeOverride</u>.

           <u>MinWindowSize</u> <u>[</u> <u>width</u> <u>[</u> <u>p</u> <u>|</u> <u>c</u> <u>]</u> <u>height</u> <u>[</u> <u>p</u> <u>|</u> <u>c</u> <u>]</u> <u>]</u> Tells fvwm the minimum width and height of a
           window. The values are the percentage of the total screen area. If the letter '<u>p</u>' is appended to
           either of the values, the numbers are interpreted as pixels. If the letter '<u>c</u>' is appended to either
           of the values, the numbers are in terms of the client window’s size hints, which can be useful for
           windows such as terminals to specify the number of rows or columns. This command is useful to deal
           with windows that freak out if their window becomes too small. If you omit the parameters or their
           values are invalid, both limits are set to 0 pixels (which is the default value).

           <u>MaxWindowSize</u> <u>[</u> <u>width</u> <u>[</u> <u>p</u> <u>|</u> <u>c</u> <u>]</u> <u>height</u> <u>[</u> <u>p</u> <u>|</u> <u>c</u> <u>]</u> <u>]</u> Tells fvwm the maximum width and height of a
           window. The values are the percentage of the total screen area. If the letter '<u>p</u>' is appended to
           either of the values, the numbers are interpreted as pixels. If the letter '<u>c</u>' is appended to either
           of the values, the numbers are in terms of the client window’s size hints, which can be useful for
           windows such as terminals to specify the number of rows or columns. This command is useful to force
           large application windows to be fully visible. Neither <u>height</u> nor <u>width</u> may be less than 100 pixels.
           If you omit the parameters or their values are invalid, both limits are set to 32767 pixels (which is
           the default).

           With <u>IconifyWindowGroups</u> all windows in the same window group are iconified and deiconified at once
           when any window in the group is (de)iconified. The default is <u>IconifyWindowGroupsOff</u>, which disables
           this behavior. Although a number of applications use the window group hint, it is rarely used in a
           proper way, so it is probably best to use <u>IconifyWindowGroups</u> only for selected applications.

           The option <u>SnapAttraction</u> affects interactive window movement: If during an interactive move the
           window or icon comes within <u>proximity</u> pixels of another the window or icon, it is moved to make the
           borders adjoin. The default of 0 means that no snapping happens. Calling this command without
           arguments turns off snap attraction and restores the default behavior. Please refer also to the
           <u>SnapGrid</u> option.

           The second argument optional and may be set to one of the five following values: With <u>All</u> both icons
           and windows snap to other windows and other icons. <u>SameType</u> lets windows snap only to windows, and
           icons snap only to icons. With <u>Windows</u> windows snap only to other windows. Similarly with <u>Icons</u> icons
           snap only to other icons. With <u>None</u> no snapping takes place. This option can be useful in conjunction
           with the thirs argument if you only want to snap against the screen edges. The default behavior is
           <u>All</u>.

           The third and last optional argument may be set to one of the four following values:

           •   With <u>Screen</u> the already snapping icons or windows, which is controlled by the second argument,
               will snap now also to the screen edges.

           •   <u>ScreenWindows</u> snaps only windows to the screen edges.

           •   <u>ScreenIcons</u> snaps only icons to the screen edges.

           •   <u>ScreenAll</u> snaps windows and icons to the screen edges.

           The option <u>SnapGrid</u> defines an invisible grid on the screen. During an interactive move a window or
           icon is positioned such that its location (top left corner) is coincident with the nearest grid
           point. The default <u>x-grid-size</u> and <u>y-grid-size</u> setting are both 1, which is effectively no grid all.

           An interactive move with both <u>SnapGrid</u> and <u>SnapAttraction</u> results in the window being moved to be
           adjacent to the nearest window border (if within snap proximity) or grid position. The window moves
           the shortest distance possible to satisfy both <u>SnapGrid</u> and <u>SnapAttraction</u>. Note that the x and y
           coordinates are not coupled. For example, a window may snap to another window on the x axis while
           snapping to a grid point on the y axis. Using this style without arguments reinstates the default
           settings.

           The styles <u>EdgeMoveDelay</u> and <u>EdgeResizeDelay</u> define how hard it is to change the desktop viewport by
           moving or resizing a window over the edge of the screen. The parameter tells how many milliseconds
           the pointer must spend on the screen edge before fvwm moves the viewport. The command <b>EdgeScroll</b>
           determines how far the viewport is scrolled. If -1 is given as the delay, page flipping is disabled
           completely. The defaults are no delay for moving (0) and no flipping for resizing (-1). Using these
           styles without any argument restores the default settings. Note that, with

               EdgeScroll 0 0

           it is still possible to move or resize windows across the edge of the current screen. See also
           <b>EdgeThickness</b>.

           The option <u>EdgeMoveResistance</u> makes it easier to place a window directly adjacent to a RandR screen’s
           edge. It takes one or two parameters. The first parameter tells how many pixels over an outside edge
           of the screen a window’s edge must move before it actually moves partially off the screen. The
           optional second parameter does the same as the first, but for inside edges (shared edge between two
           RandR monitors). If omitted, there is no resistance between inside edges. Note that the center of the
           window being moved determines the screen on which the window should be kept. Both values are 0 (no
           resistance) by default. To restore the defaults, the option <u>EdgeMoveResistance</u> can be used without
           any parameters.

           The option <u>InitialMapCommand</u> allows for any valid fvwm command or function to run when the window is
           initially mapped by fvwm. Example:

               Style MyWindow StartsOnPage 0 0, InitialMapCommand Iconify

           This would hence place the window called <u>MyWindow</u> on page 0 0 for the current desk, and immediately
           run the <b>Iconify</b> command on that window.

           Note that should <u>InitialMapCommand</u> be used as a global option for all windows, but there is a need
           that some windows should not have this command applied, then an action of <b>Nop</b> can be used on those
           windows, as in the following example:

               Style * InitialMapCommand Iconify
               Style XTeddy InitialMapCommand Nop

       <b>Window</b> <b>Manager</b> <b>placement</b>
           Applications can place windows at a particular spot on the screen either by window manager hints or a
           geometry specification. When they do neither, then the window manager steps in to find a place for
           the window. Fvwm knows several ways to deal with this situation. The default is <u>TileCascadePlacement</u>.

           <u>PositionPlacement</u> [<u>Center</u>|<u>UnderMouse</u>|<u>move-arguments</u>] When used without an argument, new windows are
           placed in the top left corner of the display. With the argument <u>Center</u>, all new window appear at the
           center of the screen, and with <u>UnderMouse</u>, windows are centered under the mouse pointer where
           possible. If the window is unable to fit on the screen because the pointer is at the edge of the
           screen, then the window is forced on-screen using this option. If any other <u>move-arguments</u> are given,
           they are interpreted exactly as the <b>Move</b> command does (with the exception that references to the
           current window position do not work as the window has not been placed yet).

           <u>CascadePlacement</u> automatically place new windows in a cascading fashion.

           <u>TileCascadePlacement</u> automatically places new windows in a smart location - a location in which they
           do not overlap any other windows on the screen. If no such position can be found <u>CascadePlacement</u> is
           used as a fall-back method.

           <u>TileManualPlacement</u> This is the same as <u>TileCascadePlacement</u>, but uses <u>ManualPlacement</u> as the
           fall-back method.

           <u>MinOverlapPlacement</u> automatically places new windows in a location in which the overlapping area in
           pixels of other windows is minimized. By default this placement policy tries to avoid overlapping
           icons and windows on higher layers. This can be configured with the <u>MinOverlapPlacementPenalties</u>
           style.

           <u>MinOverlapPercentPlacement</u> is similar to <u>MinOverlapPlacement</u> but tries to minimize the overlapped
           percentages of other windows instead of the overlapped area in pixels. This placement policy tries to
           avoid covering other windows completely and tries even harder not to cover small windows. This can be
           configured with the <u>MinOverlapPlacementPenalties</u> and <u>MinOverlapPercentPlacementPenalties</u> styles.

           <u>MinOverlapPlacementPenalties</u> takes at most 6 positive or null decimal arguments:

               normal ontop icon sticky below strut

           if trailing arguments are missing the default is used which is:

               1 5 10 1 0.05 50

           To reset this style to the default values, prefix it with a '!'. This style configures the
           <u>MinOverlapPlacement</u> and <u>MinOverlapPercentPlacement</u> placement policy. The <u>normal</u> factor affects normal
           windows, the <u>ontop</u> factor affects windows with a greater layer than the window being placed, the <u>icon</u>
           factor affects icons, the <u>sticky</u> factor affects sticky windows, the <u>below</u> factor affects windows with
           a smaller layer than the window being placed, the <u>strut</u> factor affects the complement of the EWMH
           working area if the window being placed has the <u>EWMHPlacementUseWorkingArea</u> style and windows with an
           EWMH strut hint (i.e., a "please do not cover me" hint) if the window being placed has the
           <u>EWMHPlacementUseDynamicWorkingArea</u> style. These factors represent the amount of area that these types
           of windows (or area) are counted as, when a new window is placed. For example, by default the area of
           ontop windows is counted 5 times as much as normal windows. So <u>MinOverlapPlacement</u> and
           <u>MinOverlapPercentPlacement</u> covers 5 times as much area of another window before it will cover an
           ontop window. To treat ontop windows the same as other windows, set this to 1. To really, really
           avoid putting windows under ontop windows, set this to a high value, say 1000. This style affects the
           window already mapped and not the window which is currently placed. There is one exception to this
           rule: in the case of the window being placed has the <u>EWMHPlacementUseWorkingArea</u> style the <u>strut</u>
           factor affects the placed window.

           <u>MinOverlapPercentPlacementPenalties</u> takes at most 4 positive or null integer arguments:

               cover_100 cover_95 cover_85 cover_75

           if trailing arguments are missing the defaults are used which are:

               12 6 4 1

           To reset this style to the default values, prefix it with a '!'. This style affects the
           <u>MinOverlapPercentPlacement</u> placement policy and is similar to the <u>MinOverlapPlacementPenalties</u> style.
           The <u>cover_xx</u> factor is used when the window being placed covers at least <u>xx</u> percent of the window.
           This factor is added to the factor determined by the <u>MinOverlapPlacementPenalties</u> style.

           <u>ManualPlacement</u> (aka active placement). The user is required to place every new window manually. The
           window only shows as a rubber band until a place is selected manually. The window is placed when a
           mouse button or any key except <u>Escape</u> is pressed. Escape aborts manual placement which places the
           window in the top left corner of the screen. If mouse button 2 is pressed during the initial
           placement of a window (respectively <u>Shift</u> and mouse button 1 in case Mwm emulation has been enabled
           with the <b>Emulate</b> command), the user is asked to resize the window too.

           It is possible to define buttons usable to place windows with the <b>Move</b> command and the special
           context 'P' for placement (see <b>Move</b> command). However, you can’t redefine the way to also resize the
           window other than the way it is affected by the <b>Emulate</b> command. The button used for placing the
           window can be checked with the <u>PlacedByButton</u> condition (see <b>Current</b> command).

           Example:

               Style * ManualPlacement

               *FvwmEvent: PassID
               *FvwmEvent: add_window GrowDownFunc
               AddToFunc StartFunction
               + I FvwmEvent

               AddToFunc GrowDownFunc
               + I windowid $0 (PlacedByButton 3) \
               Resize bottomright keep -0p

           Now, whenever a window is created and the user presses button 3 to finish initial placement, the
           window is automatically enlarged until it hits the bottom screen border.

           <u>Old</u> <u>placement</u> <u>styles</u> DumbPlacement / SmartPlacement / SmartPlacementOff, CleverPlacement /
           CleverPlacementOff, ActivePlacement / RandomPlacement, ActivePlacementsHonorsStartsOnPage /
           ActivePlacementsHonorsStartsOnPageOff are still supported but will be removed in the future. The old
           and new styles can be translated according to the following table:

               Style * DumbPlacement, RandomPlacement
               --&gt;
               Style * CascadePlacement

               Style * DumbPlacement, ActivePlacement
               --&gt;
               Style * ManualPlacement

               Style * SmartPlacement, \
               RandomPlacement, CleverPlacementOff
               --&gt;
               Style * TileCascadePlacement

               Style * SmartPlacement, \
               ActivePlacement, CleverPlacementOff
               --&gt;
               Style * TileManualPlacement

               Style * SmartPlacement, CleverPlacement
               --&gt;
               Style * MinOverlapPlacement

               Style * SmartPlacement, \
               ActivePlacement, CleverPlacement
               --&gt;
               Style * MinOverlapPercentPlacement

               Style * ActivePlacementsHonorsStartsOnPage
               --&gt;
               Style * ManualPlacementsHonorsStartsOnPage

               Style * ActivePlacementsHonorsStartsOnPageOff
               --&gt;
               Style * ManualPlacementsHonorsStartsOnPageOff

       <b>Placement</b> <b>policy</b> <b>options</b> <b>and</b> <b>window</b> <b>stacking</b>
           <u>!UsePPosition</u> instructs fvwm to ignore the program specified position (PPosition hint) when adding
           new windows. Using PPosition is required for some applications, but if you do not have one of those
           it’s a real headache. Many programs set PPosition to something obnoxious like 0,0 (upper left
           corner). Note: <u>!UsePPosition</u> is equivalent to the deprecated option <u>!UsePPosition</u>

           <u>!UseUSPosition</u> works like <u>!UsePPosition</u> but applies suppresses using the user specified position
           indicated by the program (USPosition hint). It is generally a bad thing to override the user’s
           choice, but some applications misuse the USPosition hint to force their windows to a certain spot on
           the screen without the user’s consent. Note: <u>!UseUSPosition</u> is equivalent to the deprecated option
           <u>!USPosition</u>

           <u>NoUseTransientPPosition</u> and <u>UseTransientPPosition</u> work like <u>!UsePPosition</u> and <u>UsePPosition</u> but apply
           only to transient windows. Note: <u>!UseTransientPPosition</u> is equivalent to the deprecated option
           <u>!TransientPPosition</u>

           <u>NoUseIconPosition</u> instructs fvwm to ignore the program specified icon position (IconPosition hint)
           when iconifying the window. Note: <u>!UseIconPosition</u> is equivalent to the deprecated option
           <u>!IconPosition</u>

           <u>StartsOnDesk</u> takes a numeric argument which is the desktop number on which the window should be
           initially placed. Note that standard Xt programs can also specify this via a resource (e.g. "-xrm
           '*Desk: 1'").

           <u>StartsOnPage</u> takes 1, 2, or 3 numeric arguments. If one or three arguments are given, the first (or
           only) argument is the desktop number. If three arguments are given, the 2nd and 3rd arguments
           identify the x,y page position on the virtual window. If two arguments are given, they specify the
           page position, and indicate no desk preference. If only one argument is given, <u>StartsOnPage</u> functions
           exactly like <u>StartsOnDesk</u>. For those standard Xt programs which understand this usage, the starting
           desk/page can also be specified via a resource (e.g., "-xrm '*page: 1 0 2'"). <u>StartsOnPage</u> in
           conjunction with <u>SkipMapping</u> is a useful technique when you want to start an app on some other page
           and continue with what you were doing, rather than waiting for it to appear.

           <u>StartsOnScreen</u> takes one argument. It must be a valid RandR name. A new window is placed on the
           specified screen. The default is to place windows on the screen that contains the mouse pointer at
           the time the window is created. However, those windows which are not placed by fvwm (i.e., those with
           a USPosition hint from a user specified geometry) are normally placed in a position relative to all
           identified screens.

           <u>StartsOnPageIncludesTransients</u> causes the <u>StartsOnPage</u> style to be applied even for transient
           windows. This is not usually useful, since transients are usually pop ups that you want to appear in
           your visible viewport; but occasionally an application uses a transient for something like a startup
           window that needs to be coerced into place.

           <u>ManualPlacementIgnoresStartsOnPage</u> suppresses <u>StartsOnPage</u> or <u>StartsOnDesk</u> placement in the event
           that both <u>ManualPlacement</u> and <u>SkipMapping</u> are in effect when a window is created. This prevents you
           from interactively placing a window and then wondering where it disappeared to, because it got placed
           on a different desk or page. <u>ManualPlacementHonorsStartsOnPage</u> allows this to happen anyway. The
           option has no effect if <u>SkipMapping</u> is not in effect, because fvwm switches to the proper desk/page
           to perform interactive placement. The default is <u>ManualPlacementIgnoresStartsOnPage</u>;
           <u>ManualPlacementHonorsStartsOnPage</u> matches the way the old <u>StartsOnDesk</u> style used to handle the
           situation.

           <u>CaptureHonorsStartsOnPage</u> causes the initial capture (of an already existing window) at startup to
           place the window according to the <u>StartsOnPage</u> and <u>StartsOnScreen</u> desk, page and screen
           specification. <u>CaptureIgnoresStartsOnPage</u> causes fvwm to ignore these settings (including
           <u>StartsOnDesk</u>) on initial capture. The default is <u>CaptureIgnoresStartsOnPage</u>.

           <u>RecaptureHonorsStartsOnPage</u> causes a window to be placed according to, or revert to, the <u>StartsOnPage</u>
           and <u>StartsOnScreen</u> desk, page and screen specification on <b>Restart</b>. <u>RecaptureIgnoresStartsOnPage</u>
           causes fvwm to respect the current window position on <b>Restart</b>. The default is
           <u>RecaptureIgnoresStartsOnPage</u>.

           <u>Layer</u> accepts one optional argument: a non-negative integer. This is the layer the window is put in.
           If no argument is given, any previously set value is deleted and the default layer is implied.

           <u>StaysOnTop</u> puts the window in the top layer. This layer can be changed by the command <b>DefaultLayers</b>;
           the default is 6.

           <u>StaysPut</u> puts the window in the put layer. This layer can be changed by the command <b>DefaultLayers</b>;
           the default is 4.

           <u>StaysOnBottom</u> puts the window in the bottom layer. This layer can be changed by the command
           <b>DefaultLayers</b>; the default is 2.

           <u>StartsLowered</u> instructs fvwm to put the window initially at the bottom of its layer rather than the
           default <u>StartsRaised</u>.

           <u>StartShaded</u> tells fvwm to shade the window. An optional direction argument may be given, which can be
           one of "<u>North</u>", "<u>South</u>", "<u>West</u>", "<u>East</u>", "<u>NorthWest</u>", "<u>NorthEast</u>", "<u>SouthWest</u>", "<u>SouthEast</u>" or if no
           direction is given, the default is to shade north.

           <u>SkipMapping</u> tells fvwm not to switch to the desk the window is on when it gets mapped initially
           (useful with <u>StartsOnDesk</u> or <u>StartsOnPage</u>).

           <u>KeepWindowGroupsOnDesk</u> makes new windows that have the window group hint set appear on the same desk
           as the other windows of the same group. Since this behavior may be confusing, the default setting is
           <u>ScatterWindowGroups</u>. The window group hint is ignored when placing windows in this case.

       <b>Transient</b> <b>windows</b>
           <u>DecorateTransient</u> causes transient windows, which are normally left undecorated, to be given the
           usual fvwm decorations (title bar, buttons, etc.). Note that some pop-up windows, such as the xterm
           menus, are not managed by the window manager and still do not receive decorations. <u>NakedTransient</u>
           (the default) causes transient windows not to be given the standard decorations. You can only bind
           keys or mouse buttons to the sides and the client part of an undecorated window ('S' and ´W' contexts
           in bindings, see <b>Mouse</b> and <u>Key</u> commands).

           A window with the <u>RaiseTransient</u> style that has transient windows raises all its transients when it
           is raised. The <u>DontRaiseTransient</u> style disables this behavior. All windows are then treated as if
           they had no transients.

           A window with the <u>LowerTransient</u> style that has transient windows lowers all its transients when it
           is lowered. The <u>DontLowerTransient</u> style disables this behavior. All windows are then treated as if
           they had no transients.

           The <u>StackTransientParent</u> style augments <u>RaiseTransient</u> and <u>LowerTransient</u> styles. Raising a window
           with <u>StackTransientParent</u> style transfers the raise action to the main window if the window being
           raised is a transient and its main window has <u>RaiseTransient</u> style; this effect makes raise on a
           transient act just like raise on its main - the whole group is raised. Similar behavior holds for
           lowering a whole group of transients when the main has <u>LowerTransient</u> style. <u>DontStackTransientParent</u>
           turns this behavior off. <u>(Dont)StackTransientParent</u> has no effect if <u>RaiseTransient</u> and
           <u>LowerTransient</u> are not used.

           A reasonable emulation of Motif raise/lower on transients is possible like this

               Style * RaiseTransient
               Style * LowerTransient
               Style * StackTransientParent

       <b>Extended</b> <b>Window</b> <b>Manager</b> <b>Hints</b> <b>styles</b>
           To understand the used terminology in this sub section, please read the <b>Extended</b> <b>Window</b> <b>Manager</b> <b>Hints</b>
           section.

           <u>EWMHDonateIcon</u> instructs fvwm to set the application ewmh icon hint with the icon that is used by
           fvwm if the application does not provide such hint (and if the icon used by fvwm is not an icon
           window). <u>EWMHDonateMiniIcon</u> does the same thing for mini icons. This allows compliant pager, taskbar,
           iconbox ...etc to display the same (mini) icons as fvwm. Note that on some hardware (e.g., 8-bit
           displays) these styles can slow down window mapping and that in general only one of these styles is
           needed by a compliant application. <u>EWMHDontDonateIcon</u> and <u>EWMHDontDonateMiniIcon</u> restore the defaults
           which are to not set any ewmh (mini) icons hints.

           By default, if an application provides an ewmh icon hint of small size (i.e., height and width less
           than or equal to 22), then fvwm uses this icon as its mini icon. <u>EWMHMiniIconOverride</u> instructs fvwm
           to ignore ewmh icons and to use the mini icon provided by the <u>MiniIcon</u> style. <u>EWMHNoMiniIconOverride</u>
           restores the default.

           <u>EWMHUseStackingOrderHints</u> causes fvwm to use EWMH hints and respect EWMH hints which change the
           window layer. <u>EWMHIgnoreStackingOrderHints</u> causes fvwm to ignore EWMH layer hints.

           An application can ask for some reserved space on the desktop by a hint. In the EWMH terminology such
           a hint is called a strut and it is used to compute the working area and may be used for window
           placement and in the maximize command. <u>EWMHIgnoreStrutHints</u> causes fvwm to ignore such hints, as
           <u>EWMHUseStrutHints</u>, causes fvwm to use it which is the default.

           <u>EWMHIgnoreStateHints</u> causes fvwm to ignore initial EWMH state hints when a new window is mapped. The
           default <u>EWMHUseStateHints</u> causes fvwm to accept such hints.

           <u>EWMHIgnoreWindowType</u> causes fvwm to ignore EWMH window type specification. The default
           <u>!EWMHIgnoreWindowType</u> causes fvwm to style windows of specified types as such.

           <u>EWMHMaximizeIgnoreWorkingArea</u> causes fvwm to ignore the EWMH working area when it executes a <b>Maximize</b>
           command. With <u>EWMHMaximizeUseWorkingArea</u> the EWMH working area is used as with
           <u>EWMHMaximizeUseDynamicWorkingArea</u> the EWMH dynamic working area is used (the default).

           <u>EWMHPlacementIgnoreWorkingArea</u> causes fvwm to ignore the EWMH working area when it places (or places
           again) a window. With <u>EWMHPlacementUseWorkingArea</u> the EWMH working area is taken in account as with
           <u>EWMHPlacementUseDynamicWorkingArea</u> the EWMH dynamic working area is taken in account (the default).
           Note that with the <u>MinOverlapPlacement</u> and <u>MinOverlapPercentPlacement</u> placement policy, the way the
           EWMH (dynamic) working area is taken in account is configurable with the <u>MinOverlapPlacementPenalties</u>
           style.

       <b>Miscellaneous</b>
           The <u>BackingStore</u>, <u>BackingStoreOff</u> and <u>BackingStoreWindowDefault</u> determine if the X server uses
           backing store for the window or not. <u>BackingStore</u> means that the X server tries to keep the obscured
           parts of a window in memory. This is usually slower if the client runs on the same machine as the X
           server, but can be much faster if the connection is slow (see also <u>SaveUnder</u> below). <u>BackingStoreOff</u>
           disables backing store for the window. By default, fvwm does not enable or disable backing store
           itself but leaves is as the window requested it. To revert back to the application’s choice, use the
           <u>BackingStoreWindowDefault</u> style.

           Note: This style is useless if the X server does not allow backing store.

           <u>SaveUnder</u> enables the corresponding window attribute in the X server. For a window using this style,
           the X server tries to store the graphics below it in memory which is usually slower if the client
           runs on the same machine as the X server. <u>SaveUnder</u> may speed up fvwm if the connection to the X
           server is slow (e.g. over a modem link). To disable save under, use the <u>SaveUnderOff</u> style. This is
           the default. See also <u>BackingStore</u> above.

           Note: This style is useless if the X server does not allow save under.

           <u>ParentalRelativity</u> enables clients that use a background pixmap of type <u>ParentRelative</u> to achieve
           transparency. Fvwm modules that support transparent colorsets require this setting. <u>Opacity</u> is the
           default and should be used for all non-transparent clients for better performance.

           <u>MwmDecor</u> makes fvwm attempt to recognize and respect the mwm decoration hints that applications
           occasionally use. To switch this style off, use the <u>NoDecorHint</u> style.

           <u>MwmFunctions</u> makes fvwm attempt to recognize and respect the mwm prohibited operations hints that
           applications occasionally use. <u>HintOverride</u> makes fvwm shade out operations that mwm would prohibit,
           but it lets you perform the operation anyway. <u>NoFuncHint</u> allows turns off the mwm hints completely.

           <u>OLDecor</u> makes fvwm attempt to recognize and respect the olwm and olvwm hints that many older XView
           and OLIT applications use. Switch this option off with <u>NoOLDecor</u>.

           <u>UseDecor</u> This style is deprecated and will be removed in the future. There are plans to replace it
           with a more flexible solution in fvwm-3.0.

           <u>UseDecor</u> accepts one argument: the name of a decor created with <b>AddToDecor</b>. If no decor name is
           specified, the "Default" decor is used. Windows do not actually contain decors, but are always
           assigned to one. If the decor is later modified with <b>AddToDecor</b>, the changes are visible for all
           windows which are assigned to it. The decor for a window can be reassigned with <b>ChangeDecor</b>.

           <u>UseStyle</u> This style is deprecated and will be removed in the future. There are plans to replace it
           with a more flexible solution in fvwm-3.0.

           <u>UseStyle</u> takes one arg, which is the name of another style. That way you can have unrelated window
           names easily inherit similar traits without retyping. For example:

               Style rxvt UseStyle XTerm

           Warning: If a style is built from one or more parent styles and the parent styles are changed, the
           derived style is not modified. To achieve this you have to issue the <u>UseStyle</u> line again.

           <u>Unmanaged</u> Windows with the <u>Unmanaged</u> style option are ignored by fvwm. They are not decorated, can
           not be moved or resized, etc. You probably want to use <b>Bugopts</b> <b>RaiseOverUnmanaged</b> too. This option
           can be turned off with the <u>!Unmanaged</u> style.

           <u>State</u> sets the initial value of one of the 32 user defined states which are associated with each
           window. The state number ranges from 0 to 31 and must be given as an argument. The states have no
           meaning in fvwm, but they can be checked in conditional commands like <b>Next</b> with the <u>State</u> condition
           and manipulated with the <b>State</b> command.

               # turn on state 11 for xterms ...
               Style xterm State 11
               # ... but not for rxvts.
               Style rxvt !State 11

           Windows with the <u>WindowListSkip</u> styles do not appear in the menu that is created with the <b>WindowList</b>
           command or the lists shown in modules like <b>FvwmIconMan</b>. In the modules, the style can usually be
           ignored with an option. Please refer to the man page of the module in question for further
           information. To disable this feature, use the default style <u>WindowListHit</u>.

           The styles <u>CirculateSkip</u> and <u>CirculateHit</u> control whether the window is considered by conditional
           commands, for example <b>Next</b>, <u>Prev</u> or <u>All</u>. Windows with <u>CirculateSkip</u>, are never selected by
           conditional commands. However, the styles can be overridden explicitly in the condition with the
           <u>CirculateHit</u>, <u>CirculateHitIcon</u> or <u>CirculateHitShaded</u> conditions, and some conditional commands, e.g.
           <b>Current</b> and <u>All</u>, do this by default. The styles <u>CirculateSkipIcon</u>, <u>CirculateHitIcon</u>,
           <u>CirculateSkipShaded</u> and <u>CirculateHitShaded</u> work like <u>CirculateSkip</u> and <u>CirculateHit</u> but apply only to
           iconic or shaded windows. Note: if multiple ...Skip... options are combined, windows are only
           selected if they match none of the given conditions. So, with

               Style * CirculateSkipIcon, CirculateSkipShaded

           only windows that are neither iconic nor shaded are selected. Note: For historical reasons, the
           conditional commands understand the names of these styles as condition names. Take care not to
           confuse them.

       <b>Examples</b>

               # Change default fvwm behavior to no title-
               # bars on windows! Also define a default icon.

               Style *       !Title,                      \
                             Icon unknown1.xpm,           \
                             BorderWidth 4,               \
                             HandleWidth 5

               # now, window specific changes:
               Style Fvwm* !Handles, Sticky,              \
                           WindowListSkip,                \
                           BorderWidth 0
               Style FvwmPager   StaysOnTop, BorderWidth 0
               Style *lock       !Handles, Sticky,        \
                                 StaysOnTop, WindowListSkip
               Style xbiff       Sticky, WindowListSkip
               Style FvwmButtons !Handles, Sticky,        \
                                 WindowListSkip
               Style sxpm        !Handles

               # Put title-bars back on xterms only!
               Style xterm     Title, Color black/grey

               Style rxvt        Icon term.xpm
               Style xterm       Icon rterm.xpm
               Style xcalc       Icon xcalc.xpm
               Style xbiff       Icon mail1.xpm
               Style xmh         Icon mail1.xpm,         \
                                 StartsOnDesk 2
               Style xman        Icon xman.xpm
               Style matlab      Icon math4.xpm,         \
                                 StartsOnDesk 3
               Style xmag        Icon magnifying_glass2.xpm
               Style xgraph      Icon graphs.xpm
               Style FvwmButtons Icon toolbox.xpm
               Style Maker       StartsOnDesk 1
               Style signal      StartsOnDesk 3

               # Fire up Netscape on the second desk, in the
               # middle of my 3x3 virtual desktop, and do not
               # bother me with it...
               Style Netscape* SkipMapping,              \
                         StartsOnPage 1 1 1

           Note that all properties for a window are or’ed together. In the above example "FvwmPager" gets the
           property <u>StaysOnTop</u> via an exact window name match but also gets <u>!Handles</u>, <u>Sticky</u> and <u>WindowListSkip</u>
           by a match to "Fvwm*". It gets <u>!Title</u> by virtue of a match to "*". If conflicting styles are
           specified for a window, then the last style specified is used.

       <b>WindowStyle</b> <u>options</u>
           sets attributes (styles) on the selected window. The <u>options</u> are exactly the same as for the <b>Style</b>
           command.

</pre><h4><b>WINDOW</b> <b>STYLES</b></h4><pre>
       <b>AddButtonStyle</b> button [<u>state</u>] [<u>style</u>] [-- [!]<u>flag</u> ...]
           Adds a button style to <u>button</u>. <u>button</u> can be a button number, or one of "<u>All</u>", "<u>Left</u>" or "<u>Right</u>".
           <u>state</u> can be "<u>ActiveUp</u>", "<u>ActiveDown</u>", "<u>InactiveUp</u>" or "<u>InactiveDown</u>", or "<u>Active</u>" (the same as both
           "ActiveUp" and "ActiveDown") or "<u>Inactive</u>" (the same as both "InactiveUp" and "InactiveDown") or any
           of these 6 with "<u>Toggled</u>" prepended. The "Active" states apply to the focused window, the "Inactive"
           ones apply to all other windows. The "Up" states apply to the non pressed buttons, the "Down" ones
           apply to pressed buttons. The "Toggled" prefix refers to maximized, shaded or sticky windows that
           have the corresponding <u>MwmDecor...</u> button style set. Additionally, the following shortcuts may be
           used: "<u>AllNormal</u>", "<u>AllToggled</u>", "<u>AllActive</u>", "<u>AllInactive</u>", "<u>AllUp</u>", "<u>AllDown</u>". They are actually
           different masks for 4 individual states from 8 total. These are supported too: "<u>AllActiveUp</u>",
           "<u>AllActiveDown</u>", "<u>AllInactiveUp</u>", "<u>AllInactiveDown</u>".

           If <u>state</u> is omitted, then the style is added to every state. If the <u>style</u> and <u>flags</u> are enclosed in
           parentheses, then multiple <u>state</u> definitions can be placed on a single line. <u>Flags</u> for additional
           button styles cannot be changed after definition.

           Buttons are drawn in the order of definition, beginning with the most recent button style, followed
           by those added with <b>AddButtonStyle</b>. To clear the button style stack, change style flags, or for
           descriptions of available styles and flags, see the <b>ButtonStyle</b> command.

           Examples:

               **ButtonStyle** 1 Pixmap led.xpm -- Top Left
               **ButtonStyle** 1 ActiveDown HGradient 8 grey black
               **ButtonStyle All** --  UseTitleStyle
               AddButtonStyle 1 \
                       ActiveUp (Pixmap a.xpm) \
                       ActiveDown (Pixmap b.xpm -- Top)
               AddButtonStyle 1 Vector 4 50x30@1 70x70@0 30x70@0 50x30@1

           Initially for this example all button states are set to a pixmap. The second line replaces the
           "ActiveDown" state with a gradient (it overrides the pixmap assigned to it in the line before, which
           assigned the same style to every state). Then, the <u>UseTitleStyle</u> flag is set for all buttons, which
           causes fvwm to draw any styles set with <b>TitleStyle</b> before drawing the buttons. Finally,
           <b>AddButtonStyle</b> is used to place additional pixmaps for both "ActiveUp" and "ActiveDown" states and a
           vector button style is drawn on top of all states.

       <b>AddTitleStyle</b> [<u>state</u>] [<u>style</u>] [-- [!]<u>flag</u> ...]
           Adds a title style to the title-bar. <u>state</u> can be "<u>ActiveUp</u>", "<u>ActiveDown</u>", "<u>InactiveUp</u>" or
           "<u>InactiveDown</u>", or "<u>Active</u>" (the same as both "ActiveUp" and "ActiveDown") or "<u>Inactive</u>" (the same as
           both "InactiveUp" and "InactiveDown") or any of these 6 with "Toggled" prepended. If <u>state</u> is
           omitted, then the style is added to every state. If the <u>style</u> and <u>flags</u> are enclosed in parentheses,
           then multiple <u>state</u> definitions can be placed on a single line. This command is quite similar to the
           <b>AddButtonStyle</b> command.

           Title-bars are drawn in the order of definition, beginning with the most recent <b>TitleStyle</b>, followed
           by those added with <b>AddTitleStyle</b>. To clear the title style stack, change style flags, or for the
           descriptions of available styles and flags, see the <b>TitleStyle</b> and <b>ButtonStyle</b> commands.

       <b>AddToDecor</b> <u>decor</u>
           This command is deprecated and will be removed in the future. There are plans to replace it with a
           more flexible solution in fvwm-3.0.

           Add or divert commands to the decor named <u>decor</u>. A decor is a name given to the set of commands which
           affect button styles, title-bar styles and border styles. If <u>decor</u> does not exist it is created;
           otherwise the existing <u>decor</u> is modified.

           New decors start out exactly like the "default" decor without any style definitions. A given decor
           may be applied to a set of windows with the <u>UseDecor</u> option of the <b>Style</b> command. Modifying an
           existing decor affects all windows which are currently assigned to it.

           <b>AddToDecor</b> is similar in usage to the <b>AddToMenu</b> and <b>AddToFunc</b> commands, except that menus and
           functions are replaced by <b>ButtonStyle</b>, <b>AddButtonStyle</b>, <b>TitleStyle</b>, <b>AddTitleStyle</b> and <b>BorderStyle</b>
           commands. Decors created with <b>AddToDecor</b> can be manipulated with <b>ChangeDecor</b>, <b>DestroyDecor</b>,
           <b>UpdateDecor</b> and the <b>Style</b> option.

           The following example creates a decor "FlatDecor" and style "FlatStyle". They are distinct entities:

               AddToDecor FlatDecor
               + ButtonStyle All Active (-- flat) Inactive (-- flat)
               + TitleStyle  -- flat
               + BorderStyle -- HiddenHandles NoInset

               Style FlatStyle \
                       UseDecor FlatDecor, HandleWidth 4, Colorset 0

               Style xterm UseStyle FlatStyle

           An existing window’s decor may be reassigned with <b>ChangeDecor</b>. A decor can be destroyed with
           <b>DestroyDecor</b>.

               DestroyDecor FlatDecor
               AddToDecor FlatDecor ...

               Style FlatStyle UseDecor FlatDecor

           and now apply the style again:

               Style xterm UseStyle FlatStyle

       <b>BorderStyle</b> <u>state</u> [<u>style</u>] [-- [!]<u>flag</u> ...]
           Defines a border style for windows. <u>state</u> can be either "<u>Active</u>" or "<u>Inactive</u>". If <u>state</u> is omitted,
           then the style is set for both states. If the <u>style</u> and <u>flags</u> are enclosed in parentheses, then
           multiple <u>state</u> definitions can be specified per line.

           <u>style</u> is a subset of the available button styles, and can only be <u>TiledPixmap</u> (uniform pixmaps which
           match the bevel colors work best this way) or <u>Colorset</u>. If a '!' is prefixed to any <u>flag</u>, the
           behavior is negated. If <u>style</u> is not specified, then one can change flags without resetting the
           style.

           The <u>HiddenHandles</u> flag hides the corner handle dividing lines on windows with handles (this option
           has no effect for !<u>Handles</u> windows). By default, <u>HiddenHandles</u> is disabled.

           The <u>NoInset</u> flag supplements <u>HiddenHandles</u>. If given, the inner bevel around the window frame is not
           drawn. If <u>HiddenHandles</u> is not specified, the frame looks a little strange.

           <u>Raised</u> causes a raised relief pattern to be drawn (default). <u>Sunk</u> causes a sunken relief pattern to
           be drawn. <u>Flat</u> inhibits the relief pattern from being drawn.

           To decorate the active and inactive window borders with a textured pixmap, one might specify:

               BorderStyle Active TiledPixmap marble.xpm
               BorderStyle Inactive TiledPixmap granite.xpm
               BorderStyle Active -- HiddenHandles NoInset

           To clear the style for both states:

               BorderStyle Simple

           To clear for a single state:

               BorderStyle Active Simple

           To unset a flag for a given state:

               BorderStyle Inactive -- !NoInset

           title-bar buttons can inherit the border style with the <u>UseBorderStyle</u> flag (see <b>ButtonStyle</b>).

       <b>ButtonState</b> [ActiveDown <u>bool</u>] [Inactive <u>bool</u>] [InactiveDown <u>bool</u>]
           The <b>ButtonState</b> command controls which states of the window titles and title buttons are used. The
           default is to use all four states: "ActiveUp", "ActiveDown", "InactiveUp" and "InactiveDown" (see
           <b>ButtonStyle</b> and <b>TitleStyle</b> commands). The <u>bool</u> argument after the key word controls if the designated
           state is used ("True") or not ("False"). The <u>bool</u> flag is the same as other commands, and not limited
           to just "True" or "False"; "Yes" and "No" may also be used. The "ActiveUp" state cannot be
           deactivated. If no arguments are provided or the given arguments are invalid, the default is
           restored.

           If <u>ActiveDown</u> argument is "False", no different button style for the pressed down buttons used,
           instead "ActiveUp" state is used even when button is pressed.

           If <u>Inactive</u> argument is "False", focused and unfocused windows look similarly, the corresponding
           "Active" states are always used.

           If <u>InactiveDown</u> argument is "False" (only applied when <u>Inactive</u> is "True"), the pressed titles and
           title buttons in non-focused windows are drawn using "InactiveUp" or "ActiveUp" states depending on
           the values of the other key words.

       <b>ButtonStyle</b> button [<u>state</u>] [<u>style</u>] [-- [!]<u>flag</u> ...]
           Sets the button style for a title-bar button. <u>button</u> is the title-bar button number between 0 and 9,
           or one of "<u>All</u>", "<u>Left</u>", "<u>Right</u>", or "<u>Reset</u>". Button numbering is described in the <b>Mouse</b> command
           section. If the <u>style</u> and <u>flags</u> are enclosed in parentheses, then multiple <u>state</u> definitions can be
           specified per line.

           <u>state</u> refers to which button state should be set. Button states are defined as follows: "<u>ActiveUp</u>"
           and "<u>ActiveDown</u>" refer to the un-pressed and pressed states for buttons on active windows; while the
           "<u>InactiveUp</u>" and "<u>InactiveDown</u>" states denote buttons on inactive windows. The shortcut "<u>Active</u>"
           denotes both "ActiveUp" and "ActiveDown" states. Shortcut "<u>Inactive</u>" denotes both "InactiveUp" and
           "InactiveDown" states. The similar state names like just described, but with the "Toggled" prefix are
           used instead for title buttons which have one of the <u>MwmDecorMax</u>, <u>MwmDecorShade</u>, <u>MwmDecorStick</u> or
           <u>MwmDecorLayer</u> hints, if the window is maximized, shaded, sticky or placed on specific layer,
           respectively.

               AddToDecor Default
               + ButtonStyle 6                   \
                 Vector 4 50x25@1 85x75@0 15x75@0 50x25@1
               + ButtonStyle 6 ToggledActiveUp   \
                 Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
               + ButtonStyle 6 ToggledActiveDown \
                 Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
               + ButtonStyle 6 ToggledInactive   \
                 Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
               + ButtonStyle 6 - MwmDecorShade
               Mouse 0 6 N WindowShade

           Additionally, the following shortcuts may be used: "<u>AllNormal</u>", "<u>AllToggled</u>", "<u>AllActive</u>",
           "<u>AllInactive</u>", "<u>AllUp</u>", "<u>AllDown</u>". They are actually different masks for 4 individual states from 8
           total. These are supported too: "<u>AllActiveUp</u>", "<u>AllActiveDown</u>", "<u>AllInactiveUp</u>", "<u>AllInactiveDown</u>".

           If <u>state</u> is specified, that particular button state is set. If <u>state</u> is omitted, every state is set.
           Specifying a style destroys the current style (use <b>AddButtonStyle</b> to avoid this).

           If <u>style</u> is omitted, then state-dependent flags can be set for the primary button style without
           destroying the current style. Examples (each line should be considered independent):

               ButtonStyle Left -- flat
               ButtonStyle All ActiveUp (-- flat) Inactive (-- flat)

           The first line sets every state of the left buttons to flat, while the second sets only the
           "ActiveUp" and "Inactive" states of every button to flat (only flags are changed; the buttons'
           individual styles are not changed).

           If you want to reset all buttons to their defaults:

               ButtonStyle Reset

           To reset the "ActiveUp" button state of button 1 to the default:

               ButtonStyle 1 ActiveUp Default

           To reset all button states of button 1 to the default of button number 2:

               ButtonStyle 1 Default 2

           For any button, multiple <u>state</u> definitions can be given on one line by enclosing the <u>style</u> and <u>flags</u>
           in parentheses. If only one definition per line is given the parentheses can be omitted.

           <u>flags</u> affect the specified <u>state</u>. If a '!' is prefixed to any <u>flag</u>, its behavior is negated. The
           available state-dependent flags for all styles are described here (the <b>ButtonStyle</b> entry deals with
           state-independent flags).

           <u>Raised</u> causes a raised relief pattern to be drawn.

           <u>Sunk</u> causes a sunken relief pattern to be drawn.

           <u>Flat</u> inhibits the relief pattern from being drawn.

           <u>UseTitleStyle</u> causes the given button state to render the current title style before rendering the
           buttons' own styles. The <u>Raised</u>, <u>Flat</u> and <u>Sunk</u> <b>TitleStyle</b> flags are ignored since they are redundant
           in this context.

           <u>UseBorderStyle</u> causes the button to inherit the decorated <b>BorderStyle</b> options.

           <u>Raised</u>, <u>Sunk</u> and <u>Flat</u> are mutually exclusive, and can be specified for the initial <b>ButtonStyle</b> only.
           <u>UseTitleStyle</u> and <u>UseBorderStyle</u> are also mutually exclusive (both can be off however). The default
           is <u>Raised</u> with both <u>UseBorderStyle</u> <u>and</u> <u>UseTitleStyle</u> left unset.

           <b>Important</b>

           for the "ActiveDown" and "InactiveDown" states: When a button is pressed, the relief is inverted.
           Because of this, to obtain the raised look in "ActiveDown" or "InactiveDown" states you must specify
           the opposite of the desired relief (i.e. <u>Sunk</u> for "ActiveDown" or "InactiveDown"). This behavior is
           consistent, but may seem confusing at first. The same applies to the "Toggled" states.

           Button styles are classified as non-destructive, partially destructive, or fully destructive.
           Non-destructive styles do not affect the image. Partially destructive styles can obscure some or all
           parts of the underlying image (i.e. <u>Pixmap</u>). Fully destructive styles obscure the entire underlying
           image (i.e. <u>Solid</u> or one of the <u>gradient</u> styles). Thus, if stacking styles with <b>AddButtonStyle</b> (or
           <b>AddTitleStyle</b> for title-bars), use care in sequencing styles to minimize redraw.

           The available styles are:

           <u>Simple</u>, <u>Default</u>, <u>Solid</u>, <u>Colorset</u>, <u>Vector</u>, <u>?Gradient</u>, <u>Pixmap</u>, <u>AdjustedPixmap</u>, <u>ShrunkPixmap</u>,
           <u>StretchedPixmap</u>, <u>TiledPixmap</u>, <u>MiniIcon</u>

           The description of these styles and their arguments follow:

           The <u>Simple</u> style does nothing. There are no arguments, and this style is an example of a
           non-destructive button style.

           The <u>Default</u> style conditionally accepts one argument: a number which specifies the default button
           number to load. If the style command given is <b>ButtonStyle</b> or <b>AddButtonStyle</b>, the argument is optional
           (if given, it overrides the current button). If a command other than <b>ButtonStyle</b> or <b>AddButtonStyle</b> is
           used, the number must be specified.

           The <u>Solid</u> style fills the button with a solid color. The relief border color is not affected. The
           color is specified as a single argument. This style is fully destructive.

           The <u>Colorset</u> <u>cs</u> [<u>alpha</u>] style fills the button with the Colorset <u>cs</u>. The optional <u>alpha</u> argument is a
           percentage between 0 and 100. It causes fvwm to merge the colorset background onto the button using
           this percentage. If the percentage is 0 the colorset background is hidden and if it is 100 the
           colorset background is fully applied. The default is 100. So, the destructiveness depends on the
           <u>alpha</u> argument.

           The <u>Vector</u> <u>num</u> <u>X</u><b>[</b><u>offset</u><b>p]x</b><u>Y</u><b>[</b><u>offset</u><b>p]@C</b> <b>...</b> style draws a line pattern. Since this is a standard
           button style, the keyword <u>Vector</u> is optional, <u>num</u> is a number of point specifications of the form
           <u>X</u><b>[</b><u>offset</u><b>p]x</b><u>Y</u><b>[</b><u>offset</u><b>p]@C</b> <b>...</b> <u>X</u> and <u>Y</u> are point coordinates inside the button, given in percents (from
           0 to 100). An optional absolute <u>offset</u> in pixels, can be given as "+&lt;offset&gt;p" for a positive or
           "-&lt;offset&gt;p" for a negative offset.

           <u>C</u> specifies a line color (0 - the shadow color, 1 - the highlight color, 2 - the background color, 3
           - the foreground color, 4 - only move the point, do not draw). The first point color is not used. You
           can use up to 10000 points in a line pattern. This style is partially destructive.

           The specification is a little cumbersome:

               ButtonStyle 2 Vector 4 50x30@1 70x70@0 30x70@0 50x30@1

           then the button 2 decoration uses a 4-point pattern consisting of a line from (x=50,y=30) to (70,70)
           in the shadow color (@0), and then to (30,70) in the shadow color, and finally to (50,30) in the
           highlight color (@1). Is that too confusing? See the fvwm web pages for some examples with
           screenshots.

           A more complex example of <u>Vector</u>:

               ButtonStyle 8 Vector 10 45x65@2 45x75@3 \
               20x75@3 20x50@3 35x50@3 35x65@1 35x25@1 \
               75x25@1 75x65@0 35x65@0
               ButtonStyle 0 Vector 10 45x65@2 45x75@0 \
               20x75@0 20x50@1 45x50@1 45x65@0 75x65@3 \
               75x25@3 35x25@3 35x47@3

           The <u>Gradient</u> styles denote color gradients. Fill in the question mark with any one of the defined
           gradient types. Please refer to the <b>Color</b> <b>Gradients</b> section for a description of the gradient syntax.
           The gradient styles are fully destructive.

           The <u>Pixmap</u> style displays a pixmap. A pixmap should be specified as an argument. For example, the
           following would give button number 2 the same pixmap for all 4 states (2 active and 2 inactive), and
           button number 4 all different pixmaps.

               ButtonStyle 2 Pixmap my_pixmap.xpm
               ButtonStyle 4 \
               ActiveUp (Pixmap activeup.xpm) \
               ActiveDown (Pixmap activedown.xpm) \
               Inactive (Pixmap inactiveup.xpm)
               ButtonStyle 4 \
               InactiveDown Pixmap inactivedown.xpm

           The pixmap specification can be given as an absolute or relative pathname (see <b>ImagePath</b>). If the
           pixmap cannot be found, the button style reverts to <u>Simple</u>. Flags specific to the <u>Pixmap</u> style are
           <u>Left</u>, <u>Right</u>, <u>Top</u>, and <u>Bottom</u>. These can be used to justify the pixmap (default is centered for both
           directions). Pixmap transparency is used for the color "None." This style is partially destructive.

           The <u>AdjustedPixmap</u> style is similar to the <u>Pixmap</u> style. But the image is resized to exactly fit the
           button.

           The <u>ShrunkPixmap</u> style is similar to the <u>Pixmap</u> style. But if the image is bigger than the button the
           image is resized to fit into the button.

           The <u>StretchedPixmap</u> style is similar to the <u>Pixmap</u> style. But if the image is smaller than the button
           the image is resized to cover the button.

           The <u>TiledPixmap</u> style accepts a pixmap to be tiled as the button background. One pixmap is specified
           as an argument. Pixmap transparency is not used. This style is fully destructive.

           The <u>MiniIcon</u> style draws the window’s miniature icon in the button, which is specified with the
           <u>MiniIcon</u> option of the <b>Style</b> command. This button style accepts no arguments. Example:

               Style *     MiniIcon mini-bx2.xpm
               Style xterm MiniIcon mini-term.xpm
               Style Emacs MiniIcon mini-doc.xpm

               ButtonStyle 1 MiniIcon

       <b>ButtonStyle</b> <u>button</u> - [!]<u>flag</u> ...
           Sets state-independent flags for the specified <u>button</u>. State-independent flags affect button
           behavior. Each <u>flag</u> is separated by a space. If a '!' is prefixed to the flag then the behavior is
           negated. The special flag <u>Clear</u> clears any existing flags.

           The following flags are usually used to tell fvwm which buttons should be affected by mwm function
           hints (see <u>MwmFunctions</u> option of the <b>Style</b> command. This is not done automatically since you might
           have buttons bound to complex functions, for instance.

           <u>MwmDecorMenu</u> should be assigned to title-bar buttons which display a menu. The default assignment is
           the leftmost button. When a window with the <u>MwmFunctions</u> <b>Style</b> option requests not to show this
           button, it is hidden.

           <u>MwmDecorMin</u> should be assigned to title-bar buttons which minimize or iconify the window. The default
           assignment is the second button over from the rightmost button. When a window with the <u>MwmFunctions</u>
           <b>Style</b> option requests not to show this button, it is hidden.

           <u>MwmDecorMax</u> should be assigned to title-bar buttons which maximize the window. The default assignment
           is the rightmost button. When a window with the <u>MwmFunctions</u> <b>Style</b> option requests not to show this
           button, it is hidden. When the window is maximized, the vector pattern on the button looks pressed
           in.

           <u>MwmDecorShade</u> should be assigned to title-bar buttons which shade the window (see <b>WindowShade</b>
           command). When the window is shaded, the vector pattern on the button looks pressed in.

           <u>MwmDecorStick</u> should be assigned to title-bar buttons which make the window sticky. When the window
           is sticky, the vector pattern on the button looks pressed in.

           The flag <u>MwmDecorLayer</u> <u>layer</u> should be assigned to title-bar buttons which place the window in the
           layer numbered <u>layer</u>. When the window is on that specific layer, the vector pattern on the button
           looks pressed in.

       <b>ChangeDecor</b> <u>decor</u>
           This command is deprecated and will be removed in the future. There are plans to replace it with a
           more flexible solution in fvwm-3.0.

           Changes the decor of a window to <u>decor</u>. <u>decor</u> is "Default" or the name of a decor defined with
           <b>AddToDecor</b>. If <u>decor</u> is invalid, nothing occurs. If called from somewhere in a window or its border,
           then that window is affected. If called from the root window the user is allowed to select the target
           window. <b>ChangeDecor</b> only affects attributes which can be set using the <b>AddToDecor</b> command.

               ChangeDecor CustomDecor1

       <b>DestroyDecor</b> [recreate] <u>decor</u>
           This command is deprecated and will be removed in the future. There are plans to replace it with a
           more flexible solution in fvwm-3.0.

           Deletes the <u>decor</u> defined with <b>AddToDecor</b>, so that subsequent references to it are no longer valid.
           Windows using this <u>decor</u> revert to the "Default" decor. The optional parameter <u>recreate</u> tells fvwm
           not to throw away the decor completely but to throw away only its contents. If the decor is created
           again later, windows do not use it before the <u>UseDecor</u> style is applied again unless the decor was
           destroyed with the <u>recreate</u> option. The decor named "Default" cannot be destroyed.

               DestroyDecor CustomDecor1

       <b>TitleStyle</b> [<u>justification</u>] [Height [<u>num</u>]] [MinHeight [<u>num</u>]]
           Sets attributes for the title-bar. Justifications can be <u>Centered</u>, <u>RightJustified</u> or <u>LeftJustified</u>.
           <u>Height</u> sets the title bar’s height to an amount in pixels. <u>MinHeight</u> sets the minimal height in
           pixels of the title bar. Defaults are <u>Centered</u>, the window’s font height and no minimal height. To
           reset the font height to the default value, omit the <u>num</u> argument after the <u>Height</u> keyword. The
           <u>MinHeight</u> height is reset by <u>Height</u> or if given with no argument. Example:

               TitleStyle LeftJustified Height 24

       <b>TitleStyle</b> [<u>state</u>] [<u>style</u>] [-- [!]<u>flag</u> ...]
           Sets the style for the title-bar. See also <b>AddTitleStyle</b> and <b>ButtonStyle</b> <u>state</u> can be one of
           "<u>ActiveUp</u>", "<u>ActiveDown</u>", "<u>InactiveUp</u>", or "<u>InactiveDown</u>". Shortcuts like "<u>Active</u>" and "<u>Inactive</u>" are
           allowed. The states with the "Toggled" prefix are allowed too, the title itself does not use
           "Toggled" states, but these states are used for the buttons with <b>ButtonStyle</b> <u>UseTitleStyle</u>. If <u>state</u>
           is omitted, then the <u>style</u> is added to every state. If parentheses are placed around the <u>style</u> and
           <u>flags</u>, then multiple state definitions can be given per line. <u>style</u> can be omitted so that flags can
           be set while not destroying the current style.

           If a '!' is prefixed to any <u>flag</u>, its behavior is negated. Valid flags for each state include <u>Raised</u>,
           <u>Flat</u> and <u>Sunk</u> (these are mutually exclusive). The default is <u>Raised</u>. See the note in <b>ButtonStyle</b>
           regarding the "<u>ActiveDown</u>" state. Examples:

               TitleStyle ActiveUp HGradient 16 navy black
               TitleStyle \
               ActiveDown (Solid red -- flat) \
               Inactive (TiledPixmap wood.xpm)
               TitleStyle \
               ActiveUp (-- Flat) \
               ActiveDown (-- Raised) \
               InactiveUp (-- Flat) \
               InactiveDown (-- Sunk)

           This sets the "ActiveUp" state to a horizontal gradient, the "ActiveDown" state to solid red, and the
           "Inactive" states to a tiled wood pixmap. Finally, "ActiveUp" and "InactiveUp" are set to look flat,
           while "ActiveDown" set to be sunk (the <u>Raised</u> flag for the "ActiveDown" state causes it to appear
           sunk due to relief inversion), and "InactiveDown" is set to look raised. An example which sets flags
           for all states:

               TitleStyle -- flat

           For a flattened look:

               TitleStyle -- flat
               ButtonStyle All Active (-- flat) Inactive (-- flat)

           <b>TitleStyle</b> accepts all the <b>ButtonStyle</b> styles and arguments:

           <u>Simple</u>, <u>Default</u>, <u>Solid</u>, <u>Colorset</u>, <u>Vector</u>, <u>?Gradient</u>, <u>Pixmap</u>, <u>AdjustedPixmap</u>, <u>ShrunkPixmap</u>,
           <u>StretchedPixmap</u>, <u>TiledPixmap</u>, <u>MiniIcon</u>.

           See the <b>ButtonStyle</b> command for a description of all these styles and their arguments.

           In addition to these styles <b>TitleStyle</b> accepts a powerful <u>MultiPixmap</u> option. This allows you to
           specify different pixmaps, colorsets or colors for different parts of the titlebar. Some of them are
           tiled or stretched to fit a particular space; others are discrete "transition" images. The definable
           <u>sections</u> are:

           <u>Main</u>
               The full titlebar

           <u>LeftMain</u>
               Left of title text

           <u>RightMain</u>
               Right of title text

           <u>UnderText</u>
               Underneath title text

           <u>LeftOfText</u>
               just to the left of the title text

           <u>RightOfText</u>
               just to the right of the title text

           <u>LeftEnd</u>
               at the far left end of the titlebar (just after left buttons if any)

           <u>RightEnd</u>
               at the far right end of the titlebar (just before right buttons if any)

           <u>Buttons</u>
               under buttons in case of <u>UseTitleStyle</u>

           <u>LeftButtons</u>
               under left buttons in case of <u>UseTitleStyle</u>

           <u>RightButtons</u>
               under right buttons in case of <u>UseTitleStyle</u>

           None of these are mandatory except for <u>Main</u> (or, if you do not define <u>Main</u> you must define both
           <u>LeftMain</u> and <u>RightMain</u>). If no <u>Buttons</u> pixmaps are defined and <u>UseTitleStyle</u> is specified for one or
           more buttons, <u>Main</u>, <u>LeftMain</u> or <u>RightMain</u> are used as appropriate.

           The syntax for this style type is:

               MultiPixmap section style arg, ...

           continuing for whatever you want to define. The <u>style</u> can be either <u>TiledPixmap</u>, <u>AdjustedPixmap</u>,
           <u>Colorset</u> or <u>Solid</u>. See the <b>ButtonStyle</b> command for the description of these styles. In the case of a
           transition section, <u>LeftEnd</u>, <u>LeftOfText</u>, <u>RightOfText</u> or <u>RightEnd</u>, <u>AdjustedPixmap</u> only resize the
           pixmap in the "y" direction. For the <u>Colorset</u> and <u>Solid</u> styles a width of the half of the title bar
           height is assumed for the transition sections.

           An example:

               MultiPixmap Main AdjustedPixmap foo.xpm, \
                     UnderText TiledPixmap bar.xpm, \
                     Buttons Colorset 2

           Note that the old syntax is still supported: if the style is omitted, <u>TiledPixmap</u> is assumed and
           adding "(stretched)" between the section and the file name implies <u>AdjustedPixmap</u>.

       <b>UpdateDecor</b> [<u>decor</u>]
           This command is deprecated and will be removed in the future. There are plans to replace it with a
           more flexible solution in fvwm-3.0.

           This command is kept mainly for backward compatibility. Since all elements of a decor are updated
           immediately when they are changed, this command is mostly useless.

           Updates window decorations. <u>decor</u> is an optional argument which specifies the <u>decor</u> to update. If
           given, only windows which are assigned to that particular <u>decor</u> are updated. This command is useful,
           for instance, after a <b>ButtonStyle</b>, <b>TitleStyle</b> or <b>BorderStyle</b> (possibly used in conjunction with
           <b>AddToDecor</b>). Specifying an invalid decor results in all windows being updated.

                                                   2025-02-22                                     <u><a href="../man1/FVWM3STYLES.1.html">FVWM3STYLES</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>