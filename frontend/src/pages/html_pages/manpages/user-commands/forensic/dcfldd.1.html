<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dcfldd - enhanced version of dd for forensics and security</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/dcfldd">dcfldd_1.9.2-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>dcfldd</b> - enhanced version of dd for forensics and security

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>dcfldd</b> [OPTION]...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Copy a file, converting and formatting according to the options.

       <b>dcfldd</b> was initially developed at Department of Defense Computer Forensics Lab (DCFL). This tool is based
       on the dd program with the following additional features:

       •  Hashing  on-the-fly: <b>dcfldd</b> can hash the input data as it is being transferred, helping to ensure data
          integrity.

       •  Status output: <b>dcfldd</b> can update the user of its progress in terms of the amount of  data  transferred
          and how much longer operation will take.

       •  Flexible disk wipes: <b>dcfldd</b> can be used to wipe disks quickly and with a known pattern if desired.

       •  Image/wipe verify: <b>dcfldd</b> can verify that a target drive is a bit-for-bit match of the specified input
          file or pattern.

       •  Multiple outputs: <b>dcfldd</b> can output to multiple files or disks at the same time.

       •  Split  output:  <b>dcfldd</b>  can  split  output  to multiple files with more configurability than the split
          command.

       •  Piped output and logs: <b>dcfldd</b> can send all its log data and  output  to  commands  as  well  as  files
          natively.

       •  When  dd uses a default block size (bs, ibs, obs) of 512 bytes, <b>dcfldd</b> uses 32768 bytes (32 KiB) which
          is HUGELY more efficient.

       •  The following options are present in <b>dcfldd</b> but not in  dd:  ALGORITHMlog:,  errlog,  hash,  hashconv,
          hashformat,  hashlog,  hashlog:,  hashwindow,  limit,  of:,  pattern,  sizeprobe,  split, splitformat,
          statusinterval, textpattern, totalhashformat, verifylog, verifylog:, vf.

       <b>dcfldd</b> supports the following letters to specify amount of data: k for kilo, M for Mega, G  for  Giga,  T
       for Tera, P for Peta, E for Exa, Z for Zetta and Y for Yotta. E.g. 10M is equal to 10 MiB. See the BLOCKS
       AND BYTES section to get other possibilities.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>bs=BYTES</b>
              Force  ibs=BYTES  and  obs=BYTES.  Default  value  is 32768 (32KiB). See BLOCKS AND BYTES section.
              Warning: the block size will be created in RAM. Make sure  you  have  sufficient  amount  of  free
              memory.

       <b>cbs=BYTES</b>
              Convert BYTES bytes at a time. (see BLOCKS AND BYTES section)

       <b>conv=KEYWORDS</b>
              Convert the file as per the comma separated keyword list.

       <b>count=BLOCKS</b>
              Copy only BLOCKS input blocks. (see BLOCKS AND BYTES section)

       <b>limit=BYTES</b>
              Similar to count but using BYTES instead of BLOCKS. (see BLOCKS AND BYTES section)

       <b>ibs=BYTES</b>
              Read BYTES bytes at a time. (see BLOCKS AND BYTES section)

       <b>if=FILE</b>
              Read from FILE instead of stdin. (see BLOCKS AND BYTES section)

       <b>obs=BYTES</b>
              Write BYTES bytes at a time. (see BLOCKS AND BYTES section)

       <b>of=FILE</b>
              Write  to  FILE  instead  of  stdout.  NOTE:  of=FILE may be used several times to write output to
              multiple files simultaneously.

       <b>of:=COMMAND</b>
              Exec and write output to process COMMAND.

       <b>seek=BLOCKS</b>
              Skip BLOCKS obs-sized blocks at start of output. (see BLOCKS AND BYTES section)

       <b>skip=BLOCKS</b>
              Skip BLOCKS ibs-sized blocks at start of input. (see BLOCKS AND BYTES section)

       <b>pattern=HEX</b>
              Use the specified binary pattern as input. You can use a byte only.

       <b>textpattern=TEXT</b>
              Use repeating TEXT as input. You can use a character only.

       <b>errlog=FILE</b>
              Send error messages to FILE as well as stderr.

       <b>hash=NAME</b>
              Do hash calculation in parallel with the disk reading. Either md5, sha1, sha256, sha384 or  sha512
              can  be  used. Default algorithm is md5. To select multiple algorithms to run simultaneously enter
              the names in a comma separated list.

       <b>hashlog=FILE</b>
              Send hash output to FILE instead of stderr. If you are using multiple hash algorithms you can send
              each to a  separate  file  using  the  convention  ALGORITHMlog=FILE,  for  example  md5log=FILE1,
              sha1log=FILE2, etc.

       <b>hashwindow=BYTES</b>
              Perform  a  hash  on  every BYTES amount of data. The partial results will be shown in screen. The
              default hash is md5 but you can use hash= option to choose other.

       <b>hashlog:=COMMAND</b>
              Exec and write hashlog to process COMMAND.

       <b>ALGORITHMlog:=COMMAND</b>
              Also works in the same fashion of hashlog:=COMMAND.

       <b>hashconv=[before|after]</b>
              Perform the hashing before or after the conversions.

       <b>hashformat=FORMAT</b>
              Display each hashwindow according to FORMAT the hash format mini-language is described below.

       <b>totalhashformat=FORMAT</b>
              Display the total hash value according to FORMAT the hash format mini-language is described below.

       <b>status=[on|off]</b>
              Display a continual status message on stderr. Default state is "on".

       <b>statusinterval=N</b>
              Update the status message every N blocks. Default value is 256.

       <b>sizeprobe=[if|of|BYTES]</b>
              Determine the size of the input or output file or an amount of BYTES for use with status messages.
              This option gives you a percentage indicator around the sizeprobe value. WARNING: do not use  this
              option against a tape device. (see BLOCKS AND BYTES section)

       <b>split=BYTES</b>
              Write every BYTES amount of data to a new file. This operation applies to any of=FILE that follows
              (split= must be put before of=). (see BLOCKS AND BYTES section)

       <b>splitformat=[TEXT|MAC|WIN]</b>
              The file extension format for split operation. You may use "a" for letters and "n" for numbers. If
              you  use annn, an extension started as a000 will be appended; the last possible extension for this
              format will be z999.  splitformat=an will provide a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b0,  b1,
              b2,  b3...  If  nothing  is specified the default format is "nnn". NOTE: the split and splitformat
              options take effect only for output files (option of=) specified AFTER these options appear in the
              command line (e.g. split=50M splitformat=annn of=/tmp/test.iso).  Likewise,  you  may  specify  it
              several  times for different output files within the same command line. You may use as many digits
              in any combination you would like. E.g. "anaannnaana" would be valid,  but  a  quite  insane  (see
              BLOCKS  AND  BYTES  section).   Other possible approach is MAC. If "MAC" is used, a suffix dmg and
              several dmgpart will be appended. In other words, it will generate a partial disk image file, used
              by the Mac OS X operating system. dmgpart files are usually  provided  with  a  corresponding  dmg
              file,  which  is the master file for the split archive.  If dmg is opened in Mac OS X, all dmgpart
              will be read too. The last option is WIN, which will automatically output file naming of  foo.001,
              foo.002, ..., foo.999, foo.1000, ....

       <b>vf=FILE</b>
              Verify that FILE matches the specified input.

       <b>verifylog=FILE</b>
              Send verify results to FILE instead of stderr.

       <b>verifylog:=COMMAND</b>
              Exec and write verify results to process COMMAND.

       <b>diffwr=[on|off]</b>
              Only  write  to output if destination block content differs. This operation applies to any of=FILE
              that follows (diffwr= must be put before any of=).

       <b>--help</b> Display a help page and exit.

       <b>--version</b>
              Output version information and exit.

</pre><h4><b>BLOCKS</b> <b>AND</b> <b>BYTES</b></h4><pre>
       BLOCKS and BYTES may be followed by the following multiplicative suffixes: xM M, c 1,  w  2,  b  512,  kD
       1000, k 1024, MD 1,000,000, M 1,048,576, GD 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y.

</pre><h4><b>KEYWORDS</b></h4><pre>
       Each KEYWORD may be:

       <b>ascii</b>  From EBCDIC to ASCII.

       <b>ebcdic</b> From ASCII to EBCDIC.

       <b>ibm</b>    From ASCII to alternated EBCDIC.

       <b>block</b>  Pad newline-terminated records with spaces to cbs-size.

       <b>unblock</b>
              Replace trailing spaces in cbs-size records with newline.

       <b>lcase</b>  Change upper case to lower case.

       <b>notrunc</b>
              Do not truncate the output file.

       <b>ucase</b>  Change lower case to upper case.

       <b>swab</b>   Swap every pair of input bytes.

       <b>noerror</b>
              Continue after read errors.

       <b>sync</b>   Pad  every  input  block  with  NULs to ibs-size. When used with block or unblock, pad with spaces
              rather than NULs.

</pre><h4><b>FORMAT</b></h4><pre>
       The structure of FORMAT may contain any valid text and special variables. The built-in variables are  the
       following format: #variable_name#. To pass FORMAT strings to the program from a command line, it may be

       <b>necessary</b> <b>to</b> <b>surround</b> <b>your</b> <b>FORMAT</b> <b>strings</b> <b>with</b> <b>"quotes."</b>
              The built-in variables are listed below:

       <b>window_start</b>
              The beginning byte offset of the hashwindow.

       <b>window_end</b>
              The ending byte offset of the hashwindow.

       <b>block_start</b>
              The beginning block (by input blocksize) of the window.

       <b>block_end</b>
              The ending block (by input blocksize) of the hash window.

       <b>hash</b>   The hash value.

       <b>algorithm</b>
              The name of the hash algorithm.

       For example, the default FORMAT for hashformat and totalhashformat are:

           hashformat="#window_start# - #window_end#: #hash#" totalhashformat="Total (#algorithm#): #hash#"

       The FORMAT structure accepts the following escape codes:

       <b>\n</b>     Newline

       <b>\t</b>     Tab

       <b>\r</b>     Carriage return

       <b>\</b>      Insert the '\' character

       <b>##</b>     Insert the '#' character as text, not a variable

</pre><h4><b>EXAMPLES</b></h4><pre>
       Each following line will create a 100 MiB file containing zeros:

           $ dcfldd if=/dev/zero of=test bs=1M count=100
           $ dcfldd if=/dev/zero of=test bs=100M count=1
           $ dcfldd if=/dev/zero of=test bs=50M count=2
           $ dcfldd if=/dev/zero of=test limit=100M

       To  create  a copy (forensics image) from a disk called /dev/sdb inside a file, using input/output blocks
       of 4096 bytes (4 KiB) instead of 32 KiB (default):

           $ dcfldd if=/dev/sdb bs=4096 of=sdb.img

       As the last example, plus calculating MD5 and SHA256 hashes,  putting  the  results  inside  sdb.md5  and
       sdb.sha256.  It  is  very  useful  for forensics works because the hashes will be processed in real time,
       avoiding a waste of time to make something as 'dd + md5 + sha256'. Considering that I/O disk is very slow
       and RAM is very fast, the hashes will be calculated, bit per bit in memory, when the next portion of  the
       disk is read. When all disk was read, all hashes are now ready.

           $ dcfldd if=/dev/sdb bs=4096 hash=md5,sha256 md5log=sdb.md5 sha256log=sdb.sha256 of=sdb.img

       To validate the image file against the original source:

           $ dcfldd if=/dev/sdb vf=sdb.img

       Splitting  the image in 500 MiB slices, using the default bs value (32 KiB). Note that split= must be put
       before of= to work:

           $ dcfldd if=/dev/sdb split=500M of=sdb.img

       At the last example, using from a0000 up to z9999 as suffix for each split file:

           $ dcfldd if=/dev/sdb split=500M splitformat=annnn of=sdb.img

       Now, <b>dcfldd</b> will work byte per byte (bs=1) and will hop 1056087439 bytes. After this, <b>dcfldd</b> will collect
       200000 bytes and write the results to a file called airplane.jpg.

           $ dcfldd if=/dev/sda3 bs=1 skip=1056087439 count=200000 of=airplane.jpg

       In the last example, the same result could be  obtained  using  "limit"  instead  of  "count".  The  main
       difference  is that count uses 200000*bs and limit uses 200000 bytes (regardless of the value declared in
       bs option):

           $ dcfldd if=/dev/sda3 bs=1 skip=1056087439 limit=200000 of=airplane.jpg

       To write something inside a file, you can use seek. Suppose you want to  write  a  message  from  a  file
       called message.txt inside a file called target.iso, hopping 200000 bytes from start of file:

           $ dcfldd if=message.txt bs=1 seek=200000 of=target.iso

       <b>dcfldd</b> also can send a result to be processed by an external command:

           $ dcfldd if=text.txt  of:="cat | sort -u"

       To convert a file from ASCII to EBCDIC:

           $ dcfldd if=text.asc conv=ebcdic of=text.ebcdic

       To convert a file from EBCDIC to ASCII:

           $ dcfldd if=text.ebcdic conv=ascii of=text.asc

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/dd.1.html">dd</a></b>(1)

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs at https://github.com/resurrecting-open-source-projects/<b>dcfldd</b>/issues

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>dcfldd</b> was originally written by Nicholas Harbour. Currently is maintained by some volunteers.

       GNU dd was written by Paul Rubin, David MacKenzie and Stuart Kemp.

       This manpage was written by dd authors, Nicholas Harbour, Joao Eriberto Mota Filho and others.

dcfldd-1.9.2                                       20 Oct 2024                                         <u><a href="../man1/dcfldd.1.html">dcfldd</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>