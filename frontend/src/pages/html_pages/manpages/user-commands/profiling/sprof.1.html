<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sprof - read and display shared object profiling data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sprof - read and display shared object profiling data

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>sprof</b> [<u>option</u>]... <u>shared-object-path</u> [<u>profile-data-path</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sprof</b>  command  displays a profiling summary for the shared object (shared library) specified as its
       first command-line argument.  The profiling summary is created using previously generated profiling  data
       in  the  (optional)  second command-line argument.  If the profiling data pathname is omitted, then <b>sprof</b>
       will attempt to deduce it using the soname of the shared  object,  looking  for  a  file  with  the  name
       <u>&lt;soname&gt;.profile</u> in the current directory.

</pre><h4><b>OPTIONS</b></h4><pre>
       The following command-line options specify the profile output to be produced:

       <b>--call-pairs</b>
       <b>-c</b>     Print  a  list of pairs of call paths for the interfaces exported by the shared object, along with
              the number of times each path is used.

       <b>--flat-profile</b>
       <b>-p</b>     Generate a flat profile of all of the functions in the monitored object, with counts and ticks.

       <b>--graph</b>
       <b>-q</b>     Generate a call graph.

       If none of the above options is specified, then the default behavior is to display a flat profile  and  a
       call graph.

       The following additional command-line options are available:

       <b>--help</b>
       <b>-?</b>     Display a summary of command-line options and arguments and exit.

       <b>--usage</b>
              Display a short usage message and exit.

       <b>--version</b>
       <b>-V</b>     Display the program version and exit.

</pre><h4><b>STANDARDS</b></h4><pre>
       GNU.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  example demonstrates the use of <b>sprof</b>.  The example consists of a main program that calls
       two functions in a shared object.  First, the code of the main program:

           $ <b>cat</b> <b>prog.c</b>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

           void x1(void);
           void x2(void);

           int
           main(int argc, char *argv[])
           {
               x1();
               x2();
               exit(EXIT_SUCCESS);
           }

       The functions <u>x1</u>() and <u>x2</u>() are defined in the following source file that is used to construct the shared
       object:

           $ <b>cat</b> <b>libdemo.c</b>
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           void
           consumeCpu1(int lim)
           {
               for (unsigned int j = 0; j &lt; lim; j++)
                getppid();
           }

           void
           x1(void) {
               for (unsigned int j = 0; j &lt; 100; j++)
                <a href="../man200000/consumeCpu1.200000.html">consumeCpu1</a>(200000);
           }

           void
           consumeCpu2(int lim)
           {
               for (unsigned int j = 0; j &lt; lim; j++)
                getppid();
           }

           void
           x2(void)
           {
               for (unsigned int j = 0; j &lt; 1000; j++)
                <a href="../man10000/consumeCpu2.10000.html">consumeCpu2</a>(10000);
           }

       Now we construct the shared object with the real name <u>libdemo.so.1.0.1</u>, and the soname <u>libdemo.so.1</u>:

           $ <b>cc</b> <b>-g</b> <b>-fPIC</b> <b>-shared</b> <b>-Wl,-soname,libdemo.so.1</b> <b>\</b>
                   <b>-o</b> <b>libdemo.so.1.0.1</b> <b>libdemo.c</b>

       Then we construct symbolic links for the library soname and the library linker name:

           $ <b>ln</b> <b>-sf</b> <b>libdemo.so.1.0.1</b> <b>libdemo.so.1</b>
           $ <b>ln</b> <b>-sf</b> <b>libdemo.so.1</b> <b>libdemo.so</b>

       Next, we compile the main program, linking it against the  shared  object,  and  then  list  the  dynamic
       dependencies of the program:

           $ <b>cc</b> <b>-g</b> <b>-o</b> <b>prog</b> <b>prog.c</b> <b>-L.</b> <b>-ldemo</b>
           $ <b>ldd</b> <b>prog</b>
                linux-vdso.so.1 =&gt;  (0x00007fff86d66000)
                libdemo.so.1 =&gt; not found
                libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fd4dc138000)
                <a href="file:/lib64/ld-linux-x86-64.so.2">/lib64/ld-linux-x86-64.so.2</a> (0x00007fd4dc51f000)

       In  order  to  get  profiling  information  for  the  shared  object,  we define the environment variable
       <b>LD_PROFILE</b> with the soname of the library:

           $ <b>export</b> <b>LD_PROFILE=libdemo.so.1</b>

       We then define the environment variable <b>LD_PROFILE_OUTPUT</b>  with  the  pathname  of  the  directory  where
       profile output should be written, and create that directory if it does not exist already:

           $ <b>export</b> <b>LD_PROFILE_OUTPUT=$(pwd)/prof_data</b>
           $ <b>mkdir</b> <b>-p</b> <b>$LD_PROFILE_OUTPUT</b>

       <b>LD_PROFILE</b>  causes  profiling output to be <u>appended</u> to the output file if it already exists, so we ensure
       that there is no preexisting profiling data:

           $ <b>rm</b> <b>-f</b> <b>$LD_PROFILE_OUTPUT/$LD_PROFILE.profile</b>

       We then run the program to produce the profiling output, which is written to  a  file  in  the  directory
       specified in <b>LD_PROFILE_OUTPUT</b>:

           $ <b>LD_LIBRARY_PATH=.</b> <b>./prog</b>
           $ <b>ls</b> <b>prof_data</b>
           libdemo.so.1.profile

       We then use the <b>sprof</b> <b>-p</b> option to generate a flat profile with counts and ticks:

           $ <b>sprof</b> <b>-p</b> <b>libdemo.so.1</b> <b>$LD_PROFILE_OUTPUT/libdemo.so.1.profile</b>
           Flat profile:

           Each sample counts as 0.01 seconds.
             %   cumulative   self              self     total
            time   seconds   seconds    calls  us/call  us/call  name
            60.00      0.06     0.06      100   600.00           consumeCpu1
            40.00      0.10     0.04     1000    40.00           consumeCpu2
             0.00      0.10     0.00        1     0.00           x1
             0.00      0.10     0.00        1     0.00           x2

       The <b>sprof</b> <b>-q</b> option generates a call graph:

           $ <b>sprof</b> <b>-q</b> <b>libdemo.so.1</b> <b>$LD_PROFILE_OUTPUT/libdemo.so.1.profile</b>

           index % time    self  children    called     name

                           0.00    0.00      100/100         x1 [1]
           [0]    100.0    0.00    0.00      100         consumeCpu1 [0]
           -----------------------------------------------
                           0.00    0.00        1/1           &lt;UNKNOWN&gt;
           [1]      0.0    0.00    0.00        1         x1 [1]
                           0.00    0.00      100/100         consumeCpu1 [0]
           -----------------------------------------------
                           0.00    0.00     1000/1000        x2 [3]
           [2]      0.0    0.00    0.00     1000         consumeCpu2 [2]
           -----------------------------------------------
                           0.00    0.00        1/1           &lt;UNKNOWN&gt;
           [3]      0.0    0.00    0.00        1         x2 [3]
                           0.00    0.00     1000/1000        consumeCpu2 [2]
           -----------------------------------------------

       Above  and  below,  the "&lt;UNKNOWN&gt;" strings represent identifiers that are outside of the profiled object
       (in this example, these are instances of <u>main()</u>).

       The <b>sprof</b> <b>-c</b> option generates a list of call pairs and the number of their occurrences:

           $ <b>sprof</b> <b>-c</b> <b>libdemo.so.1</b> <b>$LD_PROFILE_OUTPUT/libdemo.so.1.profile</b>
           &lt;UNKNOWN&gt;                  x1                                 1
           x1                         consumeCpu1                      100
           &lt;UNKNOWN&gt;                  x2                                 1
           x2                         consumeCpu2                     1000

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/gprof.1.html">gprof</a></b>(1), <b><a href="../man1/ldd.1.html">ldd</a></b>(1), <b><a href="../man8/ld.so.8.html">ld.so</a></b>(8)

Linux man-pages 6.9.1                              2024-06-15                                           <u><a href="../man1/sprof.1.html">sprof</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>