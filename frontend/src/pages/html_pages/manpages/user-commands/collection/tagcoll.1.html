<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tagcoll - Perform various operations on a tagged collection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/tagcoll">tagcoll_2.0.14-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tagcoll - Perform various operations on a tagged collection

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tagcoll</b> [options] &lt;command&gt; [options and arguments]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>tagcoll</b> is a commandline utility to manage tagged collections.

       A  tagged  collection is a set of items in which each item is associated with a set of zero or more tags,
       in no particular order.

       <b>tagcoll</b> can take a tagged collection  and  perform  various  complex  operations  on  it,  like  applying
       transformations,  finding  implicit implications between tags and building a smart intuitive hierarchy to
       navigate the items.

</pre><h4><b>COMMANDS</b></h4><pre>
       <b>tagcoll</b> accepts a non-switch argument, that indicates what is the operation that should be performed:

       <b>help</b> [command]
              With no arguments, print a summary of available commands.  If given a command  name  as  argument,
              print detailed informations about that command.

       <b>copy</b> or <b>cat</b> [files...]
              Output  the normalized collection on standard output, applying transformations if requested.  This
              is the default action if no other switches are provided.  A normalized collection is a  collection
              in which an item appears in just one line.

       <b>reverse</b> [files...]
              Output the inbound collection "reversed" from the tags point of view, that is, associating to each
              tag the list of items associated to it in the input.
              The --untagged-tag switch can be used to provide a name to which untagged items will be associated
              in the output.

       <b>diff</b> &lt;file1&gt; &lt;file2&gt;
              Output a tag patch file with the differences between two files (requires two file arguments).
              The  output  tag  patch  file  can then be applied when reading a collection with the --patch-with
              option.

       <b>related</b> &lt;item&gt; [files...]
              Output a list of the items that are related to the given item or list of items.  If more than  one
              items are to be specified, separate them with commas.
              The  --distance  option  can be used to control how closely related the output items shold be from
              the item(s) specified.

       <b>implications</b> [files...]
              Output a list of all implicit implications between tags contained in the  hierarchy.   Implication
              is defined such that tag A implies tag B if every item tagged with A is also tagged with B.
              Implications can be used to discover implicit hierarchical relationships between tags.
              The  output  is  one  line  per  tag,  with just tags that have implications, with the name of the
              package, a colon and a comma-separated list of all implied tags.

       <b>hierarchy</b> [files...]
              Organize the collection in an intuitively  navigable  hierarchy.   The  output  is  one  line  per
              package, with the package name prepended by the path to the item in the hierarchy.
              A detailed description of the hierarchy generation algorithm is found in the tagbk-draft.pdf draft
              paper available in this package; if you want to understand what are the goals of the algorithm and
              how it works, please give it a read.

       <b>cleanhierarchy</b> [files...]
              Like hiearchy, but in every node it merges tags which are attached to the same set of items.

       <b>dischierarchy</b> [files...]
              The tree starts with an empty tag set, and branches with the most discriminant tags.

       <b>findspecials</b> [files...]
              generate  a  smart  hierarchy  and  print,  for each toplevel tag, what are the items that make it
              toplevel instead of going below another tag

       <b>grep</b> &lt;expression&gt; [files...]
              output the collection of tags that match the given tag expression

       <b>test</b> [files...]
              perform internal tests and timings

</pre><h4><b>OPTIONS</b></h4><pre>
       This program follows the usual GNU command line syntax, with long options starting with two dashes (`-').

       Every one of the commands listed above has its own set of options.  To keep this  manpage  readable,  all
       the  options  are  presented  together.   Please refer to "<b>tagcoll</b> help <u>command</u>" to see which options are
       accepted by a given command.

       Help options:

       <b>-h,</b> <b>-?,</b> <b>--help</b>
              print commandline help and exit.

       <b>--version</b>
              print the program version and exit.

       <b>--manpage=</b><u>[hooks]</u>
              output the tagcoll manpage and exit.

       <b>Options</b> <b>for</b> <b>command</b> <b>help</b>
       <b>Options</b> <b>for</b> <b>command</b> <b>copy</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling transformations of output data:

       <b>-g,</b> <b>--group,</b> <b>--group-items</b>
              group items with the same tagset in the output collection.

       <b>--redundant</b>
              when implications are provided, expand them explicitly in the output.

       <b>-i,</b> <b>--items</b>
              output only the names of the items, without the tags.

       <b>-c,</b> <b>--count</b>
              output the count of tags instead of the tags.

       <b>Options</b> <b>for</b> <b>command</b> <b>reverse</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling transformations of output data:

       <b>-g,</b> <b>--group,</b> <b>--group-items</b>
              group items with the same tagset in the output collection.

       <b>--redundant</b>
              when implications are provided, expand them explicitly in the output.

       <b>-i,</b> <b>--items</b>
              output only the names of the items, without the tags.

       <b>-c,</b> <b>--count</b>
              output the count of tags instead of the tags.

       Other options:

       <b>--untagged-tag=</b><u>&lt;tag&gt;</u>
              set item name to use for associating untagged items when using  the  "reverse"  command.   If  not
              specified, untagged items are not included in the output.  <b>Options</b> <b>for</b> <b>command</b> <b>diff</b>
              <b>Options</b> <b>for</b> <b>command</b> <b>related</b>

              Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Other options:

       <b>-d</b> <u>&lt;val&gt;</u><b>,</b> <b>--distance=</b><u>&lt;val&gt;</u>
              set  the  maximum  distance to use for the "related" command (defaults to 0).  <b>Options</b> <b>for</b> <b>command</b>
              <b>implications</b>

              Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       <b>Options</b> <b>for</b> <b>command</b> <b>hierarchy</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling generation of tag hierarchies:

       <b>--flatten-threshold=</b><u>&lt;val&gt;</u>
              set the number of total items below which a branch is flattened when using the "hierarchy" command
              (defaults to 0, meaning "don't flatten").

       <b>-f</b> <u>&lt;val&gt;</u><b>,</b> <b>--filter=</b><u>&lt;val&gt;</u>
              filter out the tags with cardinality less than the given value (defaults to not filter;  currently
              only works when building hierarchies).

       <b>Options</b> <b>for</b> <b>command</b> <b>cleanhierarchy</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling generation of tag hierarchies:

       <b>--flatten-threshold=</b><u>&lt;val&gt;</u>
              set the number of total items below which a branch is flattened when using the "hierarchy" command
              (defaults to 0, meaning "don't flatten").

       <b>-f</b> <u>&lt;val&gt;</u><b>,</b> <b>--filter=</b><u>&lt;val&gt;</u>
              filter  out the tags with cardinality less than the given value (defaults to not filter; currently
              only works when building hierarchies).

       <b>Options</b> <b>for</b> <b>command</b> <b>dischierarchy</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling generation of tag hierarchies:

       <b>--flatten-threshold=</b><u>&lt;val&gt;</u>
              set the number of total items below which a branch is flattened when using the "hierarchy" command
              (defaults to 0, meaning "don't flatten").

       <b>-f</b> <u>&lt;val&gt;</u><b>,</b> <b>--filter=</b><u>&lt;val&gt;</u>
              filter out the tags with cardinality less than the given value (defaults to not filter;  currently
              only works when building hierarchies).

       <b>Options</b> <b>for</b> <b>command</b> <b>findspecials</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling generation of tag hierarchies:

       <b>--flatten-threshold=</b><u>&lt;val&gt;</u>
              set the number of total items below which a branch is flattened when using the "hierarchy" command
              (defaults to 0, meaning "don't flatten").

       <b>-f</b> <u>&lt;val&gt;</u><b>,</b> <b>--filter=</b><u>&lt;val&gt;</u>
              filter  out the tags with cardinality less than the given value (defaults to not filter; currently
              only works when building hierarchies).

       <b>Options</b> <b>for</b> <b>command</b> <b>grep</b>

       Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

       Options controlling transformations of output data:

       <b>-g,</b> <b>--group,</b> <b>--group-items</b>
              group items with the same tagset in the output collection.

       <b>--redundant</b>
              when implications are provided, expand them explicitly in the output.

       <b>-i,</b> <b>--items</b>
              output only the names of the items, without the tags.

       <b>-c,</b> <b>--count</b>
              output the count of tags instead of the tags.

       Other options:

       <b>-v,</b> <b>--invert-match</b>
              invert the sense of matching, to select non-matching lines.

       <b>-q,</b> <b>--quiet</b>
              do not write anything to standard output, but exit with 0 if any  match  is  found.   <b>Options</b>  <b>for</b>
              <b>command</b> <b>test</b>

              Options controlling transformations of input data:

       <b>--derived=</b><u>expand</u> <u>derived</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>list</u>

       <b>--implications-from=</b><u>use</u> <u>an</u> <u>external</u> <u>list</u> <u>of</u> <u>implications</u>

       <b>--rename-from=</b><u>rename</u> <u>tags</u> <u>using</u> <u>the</u> <u>given</u> <u>mapping</u> <u>list</u>

       <b>-p</b> <u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b> <b>--patch-with=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u><b>,</b>
       <b>--patch=</b><u>apply</u> <u>patches</u> <u>from</u> <u>the</u> <u>given</u> <u>tag</u> <u>patch</u> <u>file</u>

       <b>--remove-unfaceted=</b><u>while</u> <u>parsing,</u> <u>remove</u> <u>all</u> <u>tags</u> <u>with</u> <u>no</u> <u>facet</u> <u>part</u>

       <b>--remove-tags=</b><u>&lt;expression&gt;</u>
              while parsing, remove all tags matching the given tag expression.

</pre><h4><b>Format</b> <b>of</b> <b>the</b> <b>tagged</b> <b>collection</b> <b>input</b></h4><pre>
       A  sequence  of lines describing the tagged items.  Order of tags does not matter.  Each line starts with
       the item name, optionally followed by tag names.

       Tag names are separated by the item name by a colon and one or more spaces or tabs.

       Tag names are separated by each others using a comma followed by one or more spaces.

       Item names can contain colons, but not followed by a space or tab, and cannot end in a colon.  "ui:gnome"
       is ok, "ui:" is not.

       Tag names can contain commas, but not followed by a space, and cannot end in a comma.  "cult,religion" is
       ok, "cult," is not.

       An item with tags tag1, tag2, ..., tagN is represented as:

            item: tag1, tag2, ..., tagN

       An item with just tag1 is represented as:

            item: tag1

       An item without tags is represented as:

            item:

       or just as:

            item

       An example input:

            mutt: clients/mail/net
            sylpheed: clients/mail/net
            procmail: filters/mail/net
            spamassassin: filters/mail/net
            spamfilter: filters/mail/net
            bulkmail: lists/mail/net
            mailman: lists/mail/net
            smartlist: lists/mail/net
            xeukleides: educational
            new-package-not-yet-categorized:
            another-uncategorized

</pre><h4><b>Format</b> <b>for</b> <b>the</b> <b>explicit</b> <b>implications</b> <b>input</b></h4><pre>
       The format for the explicit implications is the same as the one for the tagged collection: put  the  name
       of a tag at the left of the colon and the names of the tags it implies to the right.

       Example:

            C: language, devel
            gnome: gui, ui, x11

</pre><h4><b>Format</b> <b>for</b> <b>the</b> <b>rename</b> <b>mapping</b> <b>input</b></h4><pre>
       The  format for the rename mappings is the same as the one for the tagged collection: put the new name of
       the tags at the left of the colon and the names of the old tags to be renamed on the right.

       Example:

            mp3: MP3
            language: languages, devel::language, devel::languages

</pre><h4><b>Format</b> <b>for</b> <b>the</b> <b>tag</b> <b>patch</b> <b>file</b></h4><pre>
       The format for the rename mappings is the same as the one for the tagged collection,  but  the  tags  are
       listed  prepended  with a `<b>+</b>' or `<b>-</b>' sign.  A tag prepended with a `<b>+</b>' sign is added to the item, while a
       tag with a `<b>-</b>' sign is removed from it.

       Example:

            cappuccino: +essential
            emacs: +otheros, -editor

</pre><h4><b>Format</b> <b>for</b> <b>the</b> <b>derived</b> <b>tag</b> <b>list</b></h4><pre>
       The format for the derived tag list is a line-oriented format with a derived tag per line.   The  derived
       tag  name  starts  as the begining of the line and is separated by his tag expression by colon and space,
       just like the tagged collection items.

       The tag expression is an expression composed of tags and the operators `&amp;&amp;' (and), `||' (or),  '!'  (not)
       and the parenthesis '(' and ')'.

       Example:

            userlevel::novice: !specialized &amp;&amp; (interface::gui || interface::curses)

       The  tag  at the left of the colon is added when the set of tags of an item matches the expression at the
       right of the colon.

</pre><h4><b>EXAMPLES</b></h4><pre>
       # Output the collection in normal form
       tagcoll copy collection-file

       # Output the items associated to a given tag
       tagcoll reverse collection-file | grep ^tag:

       # Produce tag patch data describing the tag difference between two collections
       tagcoll diff coll1 coll2

       # Apply a tag patch file to coll1
       tagcoll --patch-with=tagpatch copy coll1 &gt; collection-file

       # Show the minimal set of implicit implications contained in the collection
       tagcoll implications collection-file

       # Show the implicit implications contained in the collection, fully expanded
       tagcoll --expanded-output implications collection-file

       # Build a smart hierarchy with the collection
       tagcoll hierarchy collection-file

       # Build a cleaner smart hierarchy with the collection (yoy might like to tweak
       # the parameters)
       tagcoll -f 5 --flatten-threshold=5 cleanhierarchy collection-file

       # Apply some transformations to the collection and build a smart hierarchy with
       # them
       tagcoll --implications-from=explicit-implications-file \
            --rename-from=rename-map \
            --patch-with=patch-file \
            hierarchy collection-file

       # Merge the contents two collections
       cat coll1 coll2 | tagcoll copy &gt; merged

       # Merge the contents two collections and apply an external patch
       cat coll1 coll2 | tagcoll --patch-with=patch-file copy &gt; merged

       # Build a smart hierarchy out of the implicit implications contained in the
       # collection
       tagcoll implications collection-file | tagcoll hierarchy

       # Build a smart hierarchy out of the combination of explicit implications and
       # the implicit implications contained in the collection
       tagcoll --implications-from=explicit-implications-file \
            implications collection-file | tagcoll hierarchy

       # Show all the items similar to "mutt"
       tagcoll related mutt collection-file

       # Show all the items similar to "mutt" and "mozilla-browser"
       tagcoll related mutt,mozilla-browser collection-file

       # Show all the items similar to "mutt", with at most two differences
       # in the tag set
       tagcoll --distance=2 related mutt collection-file

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The <b>tagbk</b> draft paper in /usr/share/doc/tagcoll.

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>tagcoll</b> is maintained by <a href="mailto:enrico@enricozini.org">enrico@enricozini.org</a>.

       This manpage has been automatically generated by the tagcoll program.

2.0.14                                           March 22, 2020                                       <u><a href="../man1/TAGCOLL.1.html">TAGCOLL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>