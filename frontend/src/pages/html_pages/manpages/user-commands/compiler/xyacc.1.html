<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xyacc - SPP modified yacc compiler compiler [IRAF]</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/iraf-dev">iraf-dev_2.18.1~rc1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       xyacc - SPP modified yacc compiler compiler [IRAF]

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>xyacc</b> [<u>options</u>] <u>file</u>

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-b</b> <u>file_prefix</u>
              Specify a file_prefix for output files

       <b>-d</b>     Also produce a header file <b>y.tab.h</b>.

       <b>-l</b>     Don't generate '#line' directives

       <b>-P</b> <u>parser</u>
              Specify parser file (default <b>boot$xyacc/yaccpar.x</b>)

       <b>-Q</b><u>(y/n)</u>
              Flag  for  version stamping. The <b>-Qy</b> option puts the version stamping information in <b>y.tab.c</b>. This
              allows you to know what version of yacc built the file. The <b>-Qn</b> option  (the  default)  writes  no
              version information.

       <b>-t</b>     Compiles runtime debugging code by default.

       <b>-v</b>     Prepares  the  file  <b>y.output</b>,  which contains a description of the parsing tables and a report on
              conflicts generated by ambiguities in the grammar.

       <b>-V</b>     Output version information and exit

       <b>-Y</b> <u>dir</u> Specify location of <b>yaccpar.x</b> (default <b>boot$xyacc</b>).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The yacc command converts a context-free grammar into a  set  of  tables  for  a  simple  automaton  that
       executes  an <a href="../man1/LALR.1.html">LALR</a>(1) parsing algorithm. The grammar can be ambiguous. Specified precedence rules are used
       to break ambiguities.

       This is a version of yacc that has been modified to produce SPP language parsers.  For the most part,  it
       should follow the operation of standard yacc, with the differences noted below.

       Input files should follow the yacc convention of ending in .y.

</pre><h4><b>DIFFERENCES</b></h4><pre>
       <b>(1)</b>    The  Yacc  input syntax is unmodified, except that the comment convention is now as in SPP, rather
              than C (i.e., use #, rather than /*..*/).  All defines, actions, etc. are of course given  in  the
              SPP language.

       <b>(2)</b>    The  Yacc  output  file  is  "ytab.x",  rather  than "y.tab.c".  The token defs file "y.tab.h" now
              contains SPP  defines,  rather  than  C  #defines.   The  states  file  "y.output"  is  completely
              unmodified.

       <b>(3)</b>    The  global  declarations  section  %{  .. %} had to be changed somewhat because SPP does not have
              global variables.  The section is now divided into two  subsections.   The  first  is  for  global
              defines,  includes,  etc.  which  go  into the header area of the ytab.x file.  Then follows a %L,
              telling Yacc that the local declarations for the parser procedure  follow.   This  second  section
              should  contain  variable  and  function declarations required for the user supplied actions (code
              fragments to be executed when a rule of the grammar is recognized) in the yyparse procedure.

       <b>(4)</b>    The global declarations section MUST contain the following two defines:

              <b>YYMAXDEPTH</b> Depth of the parser stacks; determines the maximum complexity of a  language  construct
              which can be parsed.  A typical value is 150.

              <b>YYOPLEN</b>  The  length, in struct units, of a token operand value structure.  You define the operand
              structure to be whatever you wish; all the parser needs to know is how big  an  element  is.   The
              lexical  analyzer  and  the  actions,  both  of  which  are  supplied by the user, use the operand
              structure for communications.  Operand structures are always referred to by a Mem pointer.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/yacc.1.html">yacc</a></b>(1), <b><a href="../man1/xpp.1.html">xpp</a></b>(1), <b><a href="../man1/rpp.1.html">rpp</a></b>(1).

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written by Zed Pobre &lt;<a href="mailto:zed@debian.org">zed@debian.org</a>&gt;, for the Debian GNU/Linux system (but  may  be
       used by others).  It includes text from the README file for xyacc in the IRAF sources.

IRAF 2.17                                           June 2021                                           <u><a href="../man1/XYACC.1.html">XYACC</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>