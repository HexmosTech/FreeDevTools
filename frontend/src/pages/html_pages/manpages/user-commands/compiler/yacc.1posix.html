<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix">manpages-posix_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       yacc — yet another compiler compiler (<b>DEVELOPMENT</b>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       yacc <b>[</b>-dltv<b>]</b> <b>[</b>-b <u>file_prefix</u><b>]</b> <b>[</b>-p <u>sym_prefix</u><b>]</b> <u>grammar</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>yacc</u>  utility shall read a description of a context-free grammar in <u>grammar</u> and write C source code,
       conforming to the ISO C standard, to a code file, and optionally header information into a  header  file,
       in  the  current  directory. The generated source code shall not depend on any undefined, unspecified, or
       implementation-defined behavior, except in cases where it is copied directly from the  supplied  grammar,
       or  in  cases  that  are documented by the implementation. The C code shall define a function and related
       routines and macros for an automaton that executes  a  parsing  algorithm  meeting  the  requirements  in
       <u>Algorithms</u>.

       The form and meaning of the grammar are described in the EXTENDED DESCRIPTION section.

       The  C  source code and header file shall be produced in a form suitable as input for the C compiler (see
       <u>c99</u>).

</pre><h4><b>OPTIONS</b></h4><pre>
       The <u>yacc</u> utility shall conform to the Base Definitions volume  of  POSIX.1‐2017,  <u>Section</u>  <u>12.2</u>,  <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>, except for Guideline 9.

       The following options shall be supported:

       <b>-b</b> <u>file_prefix</u>
                 Use <u>file_prefix</u> instead of <b>y</b> as the prefix for all output filenames. The code file <b>y.tab.c</b>, the
                 header  file <b>y.tab.h</b> (created when <b>-d</b> is specified), and the description file <b>y.output</b> (created
                 when  <b>-v</b>  is  specified),  shall  be  changed  to  <u>file_prefix</u><b>.tab.c</b>,  <u>file_prefix</u><b>.tab.h</b>,   and
                 <u>file_prefix</u><b>.output</b>, respectively.

       <b>-d</b>        Write the header file; by default only the code file is written. See the OUTPUT FILES section.

       <b>-l</b>        Produce  a code file that does not contain any <b>#line</b> constructs. If this option is not present,
                 it is unspecified whether the code file or header file contains <b>#line</b> directives.  This  should
                 only be used after the grammar and the associated actions are fully debugged.

       <b>-p</b> <u>sym_prefix</u>
                 Use  <u>sym_prefix</u> instead of <b>yy</b> as the prefix for all external names produced by <u>yacc</u>.  The names
                 affected shall include the functions <u>yyparse</u>(),  <u>yylex</u>(),  and  <u>yyerror</u>(),  and  the  variables
                 <u>yylval</u>,  <u>yychar</u>,  and  <u>yydebug</u>.   (In  the remainder of this section, the six symbols cited are
                 referenced using their default names only as a notational convenience.) Local names may also be
                 affected by the <b>-p</b> option; however, the <b>-p</b> option shall not affect <b>#define</b> symbols generated by
                 <u>yacc</u>.

       <b>-t</b>        Modify conditional compilation directives to permit compilation of debugging code in  the  code
                 file.  Runtime  debugging statements shall always be contained in the code file, but by default
                 conditional compilation directives prevent their compilation.

       <b>-v</b>        Write a file containing a description of the parser and a  report  of  conflicts  generated  by
                 ambiguities in the grammar.

</pre><h4><b>OPERANDS</b></h4><pre>
       The following operand is required:

       <u>grammar</u>   A  pathname  of a file containing instructions, hereafter called <u>grammar</u>, for which a parser is
                 to be created. The format for the grammar is described in the EXTENDED DESCRIPTION section.

</pre><h4><b>STDIN</b></h4><pre>
       Not used.

</pre><h4><b>INPUT</b> <b>FILES</b></h4><pre>
       The file <u>grammar</u> shall be a text file formatted as specified in the EXTENDED DESCRIPTION section.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       The following environment variables shall affect the execution of <u>yacc</u>:

       <u>LANG</u>      Provide a default value for the internationalization variables that are unset or null. (See the
                 Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>8.2</u>, <u>Internationalization</u>  <u>Variables</u>  for  the
                 precedence   of   internationalization  variables  used  to  determine  the  values  of  locale
                 categories.)

       <u>LC_ALL</u>    If set to a non-empty string value, override the values of all the  other  internationalization
                 variables.

       <u>LC_CTYPE</u>  Determine  the  locale  for the interpretation of sequences of bytes of text data as characters
                 (for example, single-byte as opposed to multi-byte characters in arguments and input files).

       <u>LC_MESSAGES</u>
                 Determine the locale that should be used to  affect  the  format  and  contents  of  diagnostic
                 messages written to standard error.

       <u>NLSPATH</u>   Determine the location of message catalogs for the processing of <u>LC_MESSAGES</u>.

       The  <u>LANG</u>  and  <u>LC_*</u>  variables  affect  the execution of the <u>yacc</u> utility as stated. The <u>main</u>() function
       defined in <u>Yacc</u> <u>Library</u> shall call:

           setlocale(LC_ALL, "")

       and thus the program generated by <u>yacc</u> shall also be affected by  the  contents  of  these  variables  at
       runtime.

</pre><h4><b>ASYNCHRONOUS</b> <b>EVENTS</b></h4><pre>
       Default.

</pre><h4><b>STDOUT</b></h4><pre>
       Not used.

</pre><h4><b>STDERR</b></h4><pre>
       If  shift/reduce  or  reduce/reduce conflicts are detected in <u>grammar</u>, <u>yacc</u> shall write a report of those
       conflicts to the standard error in an unspecified format.

       Standard error shall also be used for diagnostic messages.

</pre><h4><b>OUTPUT</b> <b>FILES</b></h4><pre>
       The code file, the header file, and the description file shall be text files. All are  described  in  the
       following sections.

   <b>Code</b> <b>File</b>
       This  file  shall  contain  the  C  source code for the <u>yyparse</u>() function. It shall contain code for the
       various semantic actions with  macro  substitution  performed  on  them  as  described  in  the  EXTENDED
       DESCRIPTION  section.  It  also  shall  contain a copy of the <b>#define</b> statements in the header file. If a
       <b>%union</b> declaration is used, the declaration for YYSTYPE shall also be included in this file.

   <b>Header</b> <b>File</b>
       The header file shall contain <b>#define</b> statements that associate the token numbers with the  token  names.
       This  allows  source files other than the code file to access the token codes. If a <b>%union</b> declaration is
       used, the declaration for YYSTYPE and an <u>extern</u> <u>YYSTYPE</u> <u>yylval</u> declaration shall also be included in this
       file.

   <b>Description</b> <b>File</b>
       The description file shall be a text file containing a description of the state machine corresponding  to
       the  parser, using an unspecified format. Limits for internal tables (see <u>Limits</u>) shall also be reported,
       in an implementation-defined manner. (Some implementations may use dynamic allocation techniques and have
       no specific limit values to report.)

</pre><h4><b>EXTENDED</b> <b>DESCRIPTION</b></h4><pre>
       The <u>yacc</u> command accepts a language that is used to define a grammar for a target language to  be  parsed
       by  the  tables  and  code  generated by <u>yacc</u>.  The language accepted by <u>yacc</u> as a grammar for the target
       language is described below using the <u>yacc</u> input language itself.

       The input <u>grammar</u> includes rules describing the input structure of the target language  and  code  to  be
       invoked  when  these  rules  are  recognized  to  provide  the associated semantic action. The code to be
       executed shall appear as bodies of text that are intended to be C-language code.  These  bodies  of  text
       shall not contain C-language trigraphs. The C-language inclusions are presumed to form a correct function
       when  processed by <u>yacc</u> into its output files. The code included in this way shall be executed during the
       recognition of the target language.

       Given a grammar, the <u>yacc</u> utility generates the files described in the OUTPUT  FILES  section.  The  code
       file  can be compiled and linked using <u>c99</u>.  If the declaration and programs sections of the grammar file
       did not include definitions of <u>main</u>(), <u>yylex</u>(), and <u>yyerror</u>(), the compiled output requires linking  with
       externally supplied versions of those functions. Default versions of <u>main</u>() and <u>yyerror</u>() are supplied in
       the <u>yacc</u> library and can be linked in by using the <b>-l</b> <b>y</b> operand to <u>c99</u>.  The <u>yacc</u> library interfaces need
       not support interfaces with other than the default <b>yy</b> symbol prefix. The application provides the lexical
       analyzer function, <u>yylex</u>(); the <u>lex</u> utility is specifically designed to generate such a routine.

   <b>Input</b> <b>Language</b>
       The  application  shall  ensure  that  every  specification  file  consists  of  three sections in order:
       <u>declarations</u>, <u>grammar</u> <u>rules</u>, and <u>programs</u>, separated by double  &lt;percent-sign&gt;  characters  (<b>"%%"</b>).   The
       declarations  and  programs  sections  can  be  empty.  If  the  latter is empty, the preceding <b>"%%"</b> mark
       separating it from the rules section can be omitted.

       The input is free form text following the structure of the grammar defined below.

   <b>Lexical</b> <b>Structure</b> <b>of</b> <b>the</b> <b>Grammar</b>
       The &lt;blank&gt;, &lt;newline&gt;, and &lt;form-feed&gt; character shall be ignored, except  that  the  application  shall
       ensure  that  they do not appear in names or multi-character reserved symbols. Comments shall be enclosed
       in <b>"/*</b> <b>...</b> <b>*/"</b>, and can appear wherever a name is valid.

       Names are of arbitrary length, made up of letters, periods  (<b>'.'</b>),  underscores  (<b>'_'</b>),  and  non-initial
       digits.  Uppercase  and  lowercase  letters  are  distinct.   Conforming applications shall not use names
       beginning in <b>yy</b> or <b>YY</b> since the <u>yacc</u> parser uses such names. Many of the names appear in the final output
       of <u>yacc</u>, and thus they should be chosen to conform with any additional rules created by the C compiler to
       be used. In particular they appear in <b>#define</b> statements.

       A literal shall consist of a single character enclosed in single-quote  characters.  All  of  the  escape
       sequences supported for character constants by the ISO C standard shall be supported by <u>yacc</u>.

       The relationship with the lexical analyzer is discussed in detail below.

       The application shall ensure that the NUL character is not used in grammar rules or literals.

   <b>Declarations</b> <b>Section</b>
       The  declarations  section  is  used  to  define the symbols used to define the target language and their
       relationship with each other. In particular, much of  the  additional  information  required  to  resolve
       ambiguities in the context-free grammar for the target language is provided here.

       Usually  <u>yacc</u>  assigns  the  relationship  between  the  symbolic names it generates and their underlying
       numeric value. The declarations section makes it possible to control the assignment of these values.

       It is also possible to keep semantic information associated with the tokens currently on the parse  stack
       in  a user-defined C-language <b>union</b>, if the members of the union are associated with the various names in
       the grammar. The declarations section provides for this as well.

       The first group of declarators below all take a list of names as arguments. That list can  optionally  be
       preceded  by  the  name  of  a  C union member (called a <u>tag</u> below) appearing within <b>'&lt;'</b> and <b>'&gt;'</b>.  (As an
       exception to the typographical conventions of the rest of this volume of POSIX.1‐2017, in this case &lt;<u>tag</u>&gt;
       does not represent a metavariable, but the literal angle bracket characters surrounding  a  symbol.)  The
       use  of  <u>tag</u> specifies that the tokens named on this line shall be of the same C type as the union member
       referenced by <u>tag</u>.  This is discussed in more detail below.

       For lists used to define tokens, the first appearance of a given token can  be  followed  by  a  positive
       integer  (as  a  string  of  decimal  digits).   If this is done, the underlying value assigned to it for
       lexical purposes shall be taken to be that number.

       The following declares <u>name</u> to be a token:

           %token <b>[</b>&lt;<u>tag</u>&gt;<b>]</b> <u>name</u> <b>[</b><u>number</u><b>]</b> <b>[</b><u>name</u> <b>[</b><u>number</u><b>]]</b>...

       If <u>tag</u> is present, the C type for all tokens on this line shall be declared to be the type referenced  by
       <u>tag</u>.  If a positive integer, <u>number</u>, follows a <u>name</u>, that value shall be assigned to the token.

       The following declares <u>name</u> to be a token, and assigns precedence to it:

           %left <b>[</b>&lt;<u>tag</u>&gt;<b>]</b> <u>name</u> <b>[</b><u>number</u><b>]</b> <b>[</b><u>name</u> <b>[</b><u>number</u><b>]]</b>...
           %right <b>[</b>&lt;<u>tag</u>&gt;<b>]</b> <u>name</u> <b>[</b><u>number</u><b>]</b> <b>[</b><u>name</u> <b>[</b><u>number</u><b>]]</b>...

       One  or  more  lines, each beginning with one of these symbols, can appear in this section. All tokens on
       the same line have the same precedence level and associativity; the lines  are  in  order  of  increasing
       precedence  or binding strength.  <b>%left</b> denotes that the operators on that line are left associative, and
       <b>%right</b> similarly denotes right associative operators. If <u>tag</u> is present, it shall declare a  C  type  for
       <u>name</u>s as described for <b>%token</b>.

       The following declares <u>name</u> to be a token, and indicates that this cannot be used associatively:

           %nonassoc <b>[</b>&lt;<u>tag</u>&gt;<b>]</b> <u>name</u> <b>[</b><u>number</u><b>]</b> <b>[</b><u>name</u> <b>[</b><u>number</u><b>]]</b>...

       If  the  parser encounters associative use of this token it reports an error. If <u>tag</u> is present, it shall
       declare a C type for <u>name</u>s as described for <b>%token</b>.

       The following declares that union member <u>name</u>s are non-terminals, and thus it is required to have  a  <u>tag</u>
       field at its beginning:

           %type &lt;<u>tag</u>&gt; <u>name</u>...

       Because it deals with non-terminals only, assigning a token number or using a literal is also prohibited.
       If  this  construct  is  present, <u>yacc</u> shall perform type checking; if this construct is not present, the
       parse stack shall hold only the <b>int</b> type.

       Every name used in <u>grammar</u> not defined by a <b>%token</b>, <b>%left</b>, <b>%right</b>, or <b>%nonassoc</b> declaration is assumed to
       represent a non-terminal symbol. The <u>yacc</u> utility shall report an error for any non-terminal symbol  that
       does not appear on the left side of at least one grammar rule.

       Once  the type, precedence, or token number of a name is specified, it shall not be changed. If the first
       declaration of a token does not assign a token number, <u>yacc</u>  shall  assign  a  token  number.  Once  this
       assignment is made, the token number shall not be changed by explicit assignment.

       The following declarators do not follow the previous pattern.

       The  following  declares the non-terminal <u>name</u> to be the <u>start</u> <u>symbol</u>, which represents the largest, most
       general structure described by the grammar rules:

           %start <u>name</u>

       By default, it is the left-hand side of the first grammar rule; this default can be overridden with  this
       declaration.

       The following declares the <u>yacc</u> value stack to be a union of the various types of values desired.

           %union { <u>body</u> <u>of</u> <u>union</u> (<u>in</u> <u>C</u>) }

       The body of the union shall not contain unbalanced curly brace preprocessing tokens.

       By  default,  the  values  returned by actions (see below) and the lexical analyzer shall be of type <b>int</b>.
       The <u>yacc</u> utility keeps track of types, and it shall insert corresponding union member names in  order  to
       perform strict type checking of the resulting parser.

       Alternatively,  given  that  at  least one &lt;<u>tag</u>&gt; construct is used, the union can be declared in a header
       file (which shall be included in the declarations section by using a <b>#include</b>  construct  within  <b>%{</b>  and
       <b>%}</b>),  and a <b>typedef</b> used to define the symbol YYSTYPE to represent this union. The effect of <b>%union</b> is to
       provide the declaration of YYSTYPE directly from the <u>yacc</u> input.

       C-language declarations and definitions can appear in the declarations section, enclosed by the following
       marks:

           %{ ... %}

       These statements shall be copied into the code file, and have global scope within it so that they can  be
       used  in  the rules and program sections. The statements shall not contain <b>"%}"</b> outside a comment, string
       literal, or multi-character constant.

       The application shall ensure that the declarations section is terminated by the token <b>%%</b>.

   <b>Grammar</b> <b>Rules</b> <b>in</b> <b>yacc</b>
       The rules section defines the context-free grammar to be accepted by the  function  <u>yacc</u>  generates,  and
       associates  with  those  rules  C-language  actions and additional precedence information. The grammar is
       described below, and a formal definition follows.

       The rules section is comprised of one or more grammar rules. A grammar rule has the form:

           A : BODY ;

       The symbol <b>A</b> represents a non-terminal name, and <b>BODY</b> represents  a  sequence  of  zero  or  more  <u>name</u>s,
       <u>literal</u>s,  and  <u>semantic</u>  <u>action</u>s that can then be followed by optional <u>precedence</u> <u>rule</u>s.  Only the names
       and literals participate in the formation of the grammar; the semantic actions and precedence  rules  are
       used in other ways. The &lt;colon&gt; and the &lt;semicolon&gt; are <u>yacc</u> punctuation. If there are several successive
       grammar  rules with the same left-hand side, the &lt;vertical-line&gt; (<b>'|'</b>) can be used to avoid rewriting the
       left-hand side; in this case the &lt;semicolon&gt; appears only after the last rule. The BODY part can be empty
       (or empty of names and literals) to indicate that the non-terminal symbol matches the empty string.

       The <u>yacc</u> utility assigns a unique number to each rule. Rules using the vertical bar notation are distinct
       rules. The number assigned to the rule appears in the description file.

       The elements comprising a BODY are:

       <u>name</u>, <u>literal</u>
                 These form the rules of the grammar: <u>name</u> is either a <u>token</u> or a <u>non-terminal</u>;  <u>literal</u>  stands
                 for itself (less the lexically required quotation marks).

       <u>semantic</u> <u>action</u>
                 With  each  grammar  rule, the user can associate actions to be performed each time the rule is
                 recognized in the input process. (Note that the word ``action'' can also refer to  the  actions
                 of the parser—shift, reduce, and so on.)

                 These  actions  can return values and can obtain the values returned by previous actions. These
                 values are kept in objects of type YYSTYPE (see <b>%union</b>).  The result value of the action  shall
                 be  kept  on  the  parse  stack  with  the  left-hand side of the rule, to be accessed by other
                 reductions as part of their right-hand side. By using the &lt;<u>tag</u>&gt;  information  provided  in  the
                 declarations  section,  the  code  generated  by  <u>yacc</u> can be strictly type checked and contain
                 arbitrary information. In addition, the lexical analyzer can provide the same kinds  of  values
                 for tokens, if desired.

                 An action is an arbitrary C statement and as such can do input or output, call subprograms, and
                 alter  external  variables.  An action is one or more C statements enclosed in curly braces <b>'{'</b>
                 and <b>'}'</b>.  The statements shall not contain unbalanced curly brace preprocessing tokens.

                 Certain pseudo-variables can be used in the  action.  These  are  macros  for  access  to  data
                 structures known internally to <u>yacc</u>.

                 $$        The value of the action can be set by assigning it to $$. If type checking is enabled
                           and  the  type of the value to be assigned cannot be determined, a diagnostic message
                           may be generated.

                 $<u>number</u>   This refers to the value returned by the component specified by the token  <u>number</u>  in
                           the right side of a rule, reading from left to right; <u>number</u> can be zero or negative.
                           If  <u>number</u> is zero or negative, it refers to the data associated with the name on the
                           parser's stack preceding the leftmost symbol of the current  rule.   (That  is,  <b>"$0"</b>
                           refers  to the name immediately preceding the leftmost name in the current rule to be
                           found on the parser's stack and <b>"$-1"</b> refers to the symbol to <u>its</u>  left.)  If  <u>number</u>
                           refers  to an element past the current point in the rule, or beyond the bottom of the
                           stack, the result is undefined. If type checking is enabled and the type of the value
                           to be assigned cannot be determined, a diagnostic message may be generated.

                 $&lt;<u>tag</u>&gt;<u>number</u>
                           These correspond exactly to the corresponding symbols without the <u>tag</u> inclusion,  but
                           allow  for  strict type checking (and preclude unwanted type conversions). The effect
                           is that the macro is expanded to use <u>tag</u> to select an element from the YYSTYPE  union
                           (using <u>dataname.tag</u>).  This is particularly useful if <u>number</u> is not positive.

                 $&lt;<u>tag</u>&gt;$   This  imposes  on the reference the type of the union member referenced by <u>tag</u>.  This
                           construction is applicable when a reference to a left context  value  occurs  in  the
                           grammar, and provides <u>yacc</u> with a means for selecting a type.

                 Actions  can  occur  anywhere  in  a  rule  (not  just at the end); an action can access values
                 returned by actions to its left, and in turn the value it returns can be accessed by actions to
                 its right. An action appearing in the middle of a rule shall be  equivalent  to  replacing  the
                 action with a new non-terminal symbol and adding an empty rule with that non-terminal symbol on
                 the left-hand side. The semantic action associated with the new rule shall be equivalent to the
                 original  action.  The  use  of  actions  within rules might introduce conflicts that would not
                 otherwise exist.

                 By default, the value of a rule shall be the value of the first element in  it.  If  the  first
                 element  does  not  have  a  type  (particularly in the case of a literal) and type checking is
                 turned on by <b>%type</b>, an error message shall result.

       <u>precedence</u>
                 The keyword <b>%prec</b> can be used to change the  precedence  level  associated  with  a  particular
                 grammar  rule.  Examples  of  this are in cases where a unary and binary operator have the same
                 symbolic representation, but need to be given different precedences, or where the  handling  of
                 an  ambiguous  if-else  construction  is  necessary.  The  reserved  symbol  <b>%prec</b>  can  appear
                 immediately after the body of the grammar rule and can  be  followed  by  a  token  name  or  a
                 literal.  It  shall  cause  the  precedence of the grammar rule to become that of the following
                 token name or literal. The action for the rule as a whole can follow <b>%prec</b>.

       If a program section follows, the application shall ensure that the grammar rules are terminated by <b>%%</b>.

   <b>Programs</b> <b>Section</b>
       The <u>programs</u> section can include the definition of the lexical analyzer <u>yylex</u>(), and any other functions;
       for example, those used in the actions specified in the grammar rules.  It  is  unspecified  whether  the
       programs  section  precedes  or  follows  the  semantic  actions  in  the  output file; therefore, if the
       application contains any macro definitions and declarations intended to apply to the code in the semantic
       actions, it shall place them within <b>"%{</b> <b>...</b> <b>%}"</b> in the declarations section.

   <b>Input</b> <b>Grammar</b>
       The following input to <u>yacc</u> yields a parser for the input to <u>yacc</u>.  This formal syntax  takes  precedence
       over the preceding text syntax description.

       The lexical structure is defined less precisely; <u>Lexical</u> <u>Structure</u> <u>of</u> <u>the</u> <u>Grammar</u> defines most terms. The
       correspondence between the previous terms and the tokens below is as follows.

       <b>IDENTIFIER</b>  This  corresponds  to  the  concept  of  <u>name</u>, given previously. It also includes literals as
                   defined previously.

       <b>C_IDENTIFIER</b>
                   This is a name, and additionally it is known to be followed by a &lt;colon&gt;.  A  literal  cannot
                   yield this token.

       <b>NUMBER</b>      A string of digits (a non-negative decimal integer).

       <b>TYPE</b>, <b>LEFT</b>, <b>MARK</b>, <b>LCURL</b>, <b>RCURL</b>
                   These correspond directly to <b>%type</b>, <b>%left</b>, <b>%%</b>, <b>%{</b>, and <b>%}</b>.

       <b>{</b> <b>...</b> <b>}</b>     This indicates C-language source code, with the possible inclusion of <b>'$'</b> macros as discussed
                   previously.

           /* Grammar for the input to yacc. */
           /* Basic entries. */
           /* The following are recognized by the lexical analyzer. */

           %token    IDENTIFIER      /* Includes identifiers and literals */
           %token    C_IDENTIFIER    /* identifier (but not literal)
                                        followed by a :. */
           %token    NUMBER          /* [0-9][0-9]* */

           /* Reserved words : %type=&gt;TYPE %left=&gt;LEFT, and so on */

           %token    LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION

           %token    MARK            /* The %% mark. */
           %token    LCURL           /* The %{ mark. */
           %token    RCURL           /* The %} mark. */

           /* 8-bit character literals stand for themselves; */
           /* tokens have to be defined for multi-byte characters. */

           %start    spec

           %%

           spec  : defs MARK rules tail
                 ;
           tail  : MARK
                 {
                   /* In this action, set up the rest of the file. */
                 }
                 | /* Empty; the second MARK is optional. */
                 ;
           defs  : /* Empty. */
                 |    defs def
                 ;
           def   : START IDENTIFIER
                 |    UNION
                 {
                   /* Copy union definition to output. */
                 }
                 |    LCURL
                 {
                   /* Copy C code to output file. */
                 }
                   RCURL
                 |    rword tag nlist
                 ;
           rword : TOKEN
                 | LEFT
                 | RIGHT
                 | NONASSOC
                 | TYPE
                 ;
           tag   : /* Empty: union tag ID optional. */
                 | '&lt;' IDENTIFIER '&gt;'
                 ;
           nlist : nmno
                 | nlist nmno
                 ;
           nmno  : IDENTIFIER         /* Note: literal invalid with % type. */
                 | IDENTIFIER NUMBER  /* Note: invalid with % type. */
                 ;

           /* Rule section */

           rules : C_IDENTIFIER rbody prec
                 | rules  rule
                 ;
           rule  : C_IDENTIFIER rbody prec
                 | '|' rbody prec
                 ;
           rbody : /* empty */
                 | rbody IDENTIFIER
                 | rbody act
                 ;
           act   : '{'
                   {
                     /* Copy action, translate $$, and so on. */
                   }
                   '}'
                 ;
           prec  : /* Empty */
                 | PREC IDENTIFIER
                 | PREC IDENTIFIER act
                 | prec ';'
                 ;

   <b>Conflicts</b>
       The parser produced for an input grammar may contain states in which conflicts occur. The conflicts occur
       because  the  grammar is not <a href="../man1/LALR.1.html">LALR</a>(1). An ambiguous grammar always contains at least one <a href="../man1/LALR.1.html">LALR</a>(1) conflict.
       The <u>yacc</u> utility shall resolve all conflicts, using either default  rules  or  user-specified  precedence
       rules.

       Conflicts are either shift/reduce conflicts or reduce/reduce conflicts. A shift/reduce conflict is where,
       for  a  given  state  and  lookahead  symbol,  both  a  shift  action and a reduce action are possible. A
       reduce/reduce conflict is where, for a given state and lookahead  symbol,  reductions  by  two  different
       rules are possible.

       The rules below describe how to specify what actions to take when a conflict occurs. Not all shift/reduce
       conflicts  can  be successfully resolved this way because the conflict may be due to something other than
       ambiguity, so incautious use of these facilities can cause the language accepted by the parser to be much
       different from that which was intended. The description file  shall  contain  sufficient  information  to
       understand  the cause of the conflict. Where ambiguity is the reason either the default or explicit rules
       should be adequate to produce a working parser.

       The declared precedences and associativities (see <u>Declarations</u>  <u>Section</u>)  are  used  to  resolve  parsing
       conflicts as follows:

        1. A  precedence  and  associativity  is  associated  with  each  grammar rule; it is the precedence and
           associativity of the last token or literal in the body of the rule. If the <b>%prec</b> keyword is used,  it
           overrides this default. Some grammar rules might not have both precedence and associativity.

        2. If  there  is a shift/reduce conflict, and both the grammar rule and the input symbol have precedence
           and associativity associated with them, then the conflict is resolved in favor of the  action  (shift
           or  reduce)  associated  with  the  higher  precedence.  If  the  precedences  are the same, then the
           associativity is used; left associative implies reduce, right associative  implies  shift,  and  non-
           associative implies an error in the string being parsed.

        3. When there is a shift/reduce conflict that cannot be resolved by rule 2, the shift is done. Conflicts
           resolved this way are counted in the diagnostic output described in <u>Error</u> <u>Handling</u>.

        4. When  there  is a reduce/reduce conflict, a reduction is done by the grammar rule that occurs earlier
           in the input sequence. Conflicts resolved this way are counted in the diagnostic output described  in
           <u>Error</u> <u>Handling</u>.

       Conflicts  resolved  by  precedence  or  associativity  shall  not  be  counted  in  the shift/reduce and
       reduce/reduce conflicts reported by <u>yacc</u> on either standard error or in the description file.

   <b>Error</b> <b>Handling</b>
       The token <b>error</b> shall be reserved for error handling. The name <b>error</b> can be used  in  grammar  rules.  It
       indicates  places  where  the parser can recover from a syntax error. The default value of <b>error</b> shall be
       256. Its value can be changed using a <b>%token</b> declaration. The lexical  analyzer  should  not  return  the
       value of <b>error</b>.

       The  parser  shall  detect  a  syntax  error  when  it is in a state where the action associated with the
       lookahead symbol is <b>error</b>.  A semantic action  can  cause  the  parser  to  initiate  error  handling  by
       executing  the  macro  YYERROR.  When YYERROR is executed, the semantic action passes control back to the
       parser. YYERROR cannot be used outside of semantic actions.

       When the parser  detects  a  syntax  error,  it  normally  calls  <u>yyerror</u>()  with  the  character  string
       <b>"syntax</b> <b>error"</b>  as  its  argument.  The  call  shall not be made if the parser is still recovering from a
       previous error when the error is detected. The parser is considered to  be  recovering  from  a  previous
       error  until  the  parser  has  shifted over at least three normal input symbols since the last error was
       detected or a semantic action has executed the macro <u>yyerrok</u>.  The parser shall not call  <u>yyerror</u>()  when
       YYERROR is executed.

       The macro function YYRECOVERING shall return 1 if a syntax error has been detected and the parser has not
       yet fully recovered from it.  Otherwise, zero shall be returned.

       When a syntax error is detected by the parser, the parser shall check if a previous syntax error has been
       detected.  If  a  previous error was detected, and if no normal input symbols have been shifted since the
       preceding error was detected, the parser checks if the lookahead symbol is an endmarker (see <u>Interface</u> <u>to</u>
       <u>the</u> <u>Lexical</u> <u>Analyzer</u>).  If it is, the parser shall return with a non-zero value. Otherwise, the lookahead
       symbol shall be discarded and normal parsing shall resume.

       When YYERROR is executed or when the parser detects a  syntax  error  and  no  previous  error  has  been
       detected, or at least one normal input symbol has been shifted since the previous error was detected, the
       parser  shall  pop  back one state at a time until the parse stack is empty or the current state allows a
       shift over <b>error</b>.  If the parser empties the  parse  stack,  it  shall  return  with  a  non-zero  value.
       Otherwise,  it  shall  shift  over  <b>error</b> and then resume normal parsing. If the parser reads a lookahead
       symbol before the error was detected, that symbol shall still be the lookahead  symbol  when  parsing  is
       resumed.

       The  macro  <u>yyerrok</u>  in a semantic action shall cause the parser to act as if it has fully recovered from
       any previous errors. The macro <u>yyclearin</u> shall cause the parser to discard the current  lookahead  token.
       If the current lookahead token has not yet been read, <u>yyclearin</u> shall have no effect.

       The  macro  YYACCEPT  shall cause the parser to return with the value zero. The macro YYABORT shall cause
       the parser to return with a non-zero value.

   <b>Interface</b> <b>to</b> <b>the</b> <b>Lexical</b> <b>Analyzer</b>
       The <u>yylex</u>() function is an integer-valued function that returns a <u>token</u> <u>number</u> representing the  kind  of
       token  read. If there is a value associated with the token returned by <u>yylex</u>() (see the discussion of <u>tag</u>
       above), it shall be assigned to the external variable <u>yylval</u>.

       If the parser and <u>yylex</u>() do not agree on these token numbers, reliable communication between them cannot
       occur. For (single-byte character) literals, the token is simply the numeric value of  the  character  in
       the  current  character set.  The numbers for other tokens can either be chosen by <u>yacc</u>, or chosen by the
       user. In either case, the <b>#define</b> construct of C is  used  to  allow  <u>yylex</u>()  to  return  these  numbers
       symbolically.  The  <b>#define</b>  statements  are  put into the code file, and the header file if that file is
       requested. The set of characters permitted by <u>yacc</u> in an identifier is larger than that permitted  by  C.
       Token names found to contain such characters shall not be included in the <b>#define</b> declarations.

       If the token numbers are chosen by <u>yacc</u>, the tokens other than literals shall be assigned numbers greater
       than  256,  although  no  order  is implied. A token can be explicitly assigned a number by following its
       first appearance in the declarations section with a number. Names  and  literals  not  defined  this  way
       retain their default definition. All token numbers assigned by <u>yacc</u> shall be unique and distinct from the
       token  numbers  used for literals and user-assigned tokens. If duplicate token numbers cause conflicts in
       parser generation, <u>yacc</u> shall report an error; otherwise, it is unspecified whether the token  assignment
       is accepted or an error is reported.

       The  end of the input is marked by a special token called the <u>endmarker</u>, which has a token number that is
       zero or negative. (These values are invalid for any other token.) All lexical analyzers shall return zero
       or negative as a token number upon reaching the end of their input. If the tokens up to,  but  excluding,
       the  endmarker  form a structure that matches the start symbol, the parser shall accept the input. If the
       endmarker is seen in any other context, it shall be considered an error.

   <b>Completing</b> <b>the</b> <b>Program</b>
       In addition to <u>yyparse</u>() and <u>yylex</u>(), the functions <u>yyerror</u>() and <u>main</u>() are required to make a  complete
       program. The application can supply <u>main</u>() and <u>yyerror</u>(), or those routines can be obtained from the <u>yacc</u>
       library.

   <b>Yacc</b> <b>Library</b>
       The following functions shall appear only in the <u>yacc</u> library accessible through the <b>-l</b> <b>y</b> operand to <u>c99</u>;
       they can therefore be redefined by a conforming application:

       <b>int</b> <u>main</u>(<b>void</b>)
             This  function  shall  call <u>yyparse</u>() and exit with an unspecified value. Other actions within this
             function are unspecified.

       <b>int</b> <u>yyerror</u>(<b>const</b> <b>char</b> *<u>s</u>)
             This function shall write the NUL-terminated argument to standard error, followed by a &lt;newline&gt;.

       The order of the <b>-l</b> <b>y</b> and <b>-l</b> <b>l</b> operands given to <u>c99</u> is significant; the application shall either provide
       its own <u>main</u>() function or ensure that <b>-l</b> <b>y</b> precedes <b>-l</b> <b>l</b>.

   <b>Debugging</b> <b>the</b> <b>Parser</b>
       The parser generated by <u>yacc</u> shall have diagnostic facilities in it that can  be  optionally  enabled  at
       either compile time or at runtime (if enabled at compile time).  The compilation of the runtime debugging
       code  is  under  the  control  of  YYDEBUG,  a  preprocessor symbol. If YYDEBUG has a non-zero value, the
       debugging code shall be included. If its value is zero, the code shall not be included.

       In parsers where the debugging code has been included, the external <b>int</b>  <u>yydebug</u>  can  be  used  to  turn
       debugging  on (with a non-zero value) and off (zero value) at runtime. The initial value of <u>yydebug</u> shall
       be zero.

       When <b>-t</b> is specified, the code file shall be built such that,  if  YYDEBUG  is  not  already  defined  at
       compilation  time  (using  the <u>c99</u> <b>-D</b> YYDEBUG option, for example), YYDEBUG shall be set explicitly to 1.
       When <b>-t</b> is not specified, the code file shall be built such that, if YYDEBUG is not already  defined,  it
       shall be set explicitly to zero.

       The  format  of the debugging output is unspecified but includes at least enough information to determine
       the shift and reduce actions, and the input symbols. It also provides information about error recovery.

   <b>Algorithms</b>
       The parser constructed by <u>yacc</u> implements an <a href="../man1/LALR.1.html">LALR</a>(1) parsing algorithm as documented in  the  literature.
       It is unspecified whether the parser is table-driven or direct-coded.

       A  parser  generated  by <u>yacc</u> shall never request an input symbol from <u>yylex</u>() while in a state where the
       only actions other than the error action are reductions by a single rule.

       The literature of parsing theory defines these concepts.

   <b>Limits</b>
       The <u>yacc</u> utility may have several internal tables. The minimum maximums for these tables are shown in the
       following table. The exact meaning of these values is implementation-defined.  The  implementation  shall
       define  the  relationship  between  these  values  and  between  them  and  any  error  messages that the
       implementation may generate should it run out of space for any internal structure. An implementation  may
       combine  groups of these resources into a single pool as long as the total available to the user does not
       fall below the sum of the sizes specified by this section.

                                            <b>Table:</b> <b>Internal</b> <b>Limits</b> <b>in</b> <u>yacc</u>
                              ┌────────────┬─────────┬────────────────────────────────┐
                              │            │ <b>Minimum</b> │                                │
                              │   <b>Limit</b>    │ <b>Maximum</b> │          <b>Description</b>           │
                              ├────────────┼─────────┼────────────────────────────────┤
                              │ {NTERMS}   │   126   │ Number of tokens.              │
                              │ {NNONTERM} │   200   │ Number of non-terminals.       │
                              │ {NPROD}    │   300   │ Number of rules.               │
                              │ {NSTATES}  │   600   │ Number of states.              │
                              │ {MEMSIZE}  │  5200   │ Length of rules. The total     │
                              │            │         │ length, in names (tokens and   │
                              │            │         │ non-terminals), of all the     │
                              │            │         │ rules of the grammar. The      │
                              │            │         │ left-hand side is counted for  │
                              │            │         │ each rule, even if it is not   │
                              │            │         │ explicitly repeated, as        │
                              │            │         │ specified in <u>Grammar</u> <u>Rules</u> <u>in</u>  │
                              │            │         │ <u>yacc</u>.                          │
                              │ {ACTSIZE}  │  4000   │ Number of actions. ``Actions'' │
                              │            │         │ here (and in the description   │
                              │            │         │ file) refer to parser actions  │
                              │            │         │ (shift, reduce, and so on) not │
                              │            │         │ to semantic actions defined in │
                              │            │         │ <u>Grammar</u> <u>Rules</u> <u>in</u> <u>yacc</u>.         │
                              └────────────┴─────────┴────────────────────────────────┘

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The following exit values shall be returned:

        0    Successful completion.

       &gt;0    An error occurred.

</pre><h4><b>CONSEQUENCES</b> <b>OF</b> <b>ERRORS</b></h4><pre>
       If any errors are encountered, the run is aborted and <u>yacc</u> exits with a  non-zero  status.  Partial  code
       files  and  header files may be produced. The summary information in the description file shall always be
       produced if the <b>-v</b> flag is present.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Historical implementations experience name  conflicts  on  the  names  <b>yacc.tmp</b>,  <b>yacc.acts</b>,  <b>yacc.debug</b>,
       <b>y.tab.c</b>,  <b>y.tab.h</b>,  and  <b>y.output</b>  if  more than one copy of <u>yacc</u> is running in a single directory at one
       time. The <b>-b</b> option was added to overcome this problem. The related problem  of  allowing  multiple  <u>yacc</u>
       parsers  to  be  placed  in  the same file was addressed by adding a <b>-p</b> option to override the previously
       hard-coded <b>yy</b> variable prefix.

       The description of the <b>-p</b> option specifies the minimal set of function  and  variable  names  that  cause
       conflict  when  multiple  parsers  are linked together. YYSTYPE does not need to be changed. Instead, the
       programmer can use <b>-b</b> to give the header files for different parsers different names, and then  the  file
       with  the  <u>yylex</u>() for a given parser can include the header for that parser. Names such as <u>yyclearerr</u> do
       not need to be changed because they are used only in the  actions;  they  do  not  have  linkage.  It  is
       possible  that  an  implementation  has other names, either internal ones for implementing things such as
       <u>yyclearerr</u>, or providing non-standard features that it wants to change with <b>-p</b>.

       Unary operators that are the same token as a binary operator in general need their  precedence  adjusted.
       This  is  handled  by the <b>%prec</b> advisory symbol associated with the particular grammar rule defining that
       unary operator. (See <u>Grammar</u> <u>Rules</u> <u>in</u> <u>yacc</u>.)  Applications are not required  to  use  this  operator  for
       unary operators, but the grammars that do not require it are rare.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Access  to  the  <u>yacc</u>  library  is obtained with library search operands to <u>c99</u>.  To use the <u>yacc</u> library
       <u>main</u>():

           c99 y.tab.c -l y

       Both the <u>lex</u> library and the <u>yacc</u> library contain <u>main</u>().  To access the <u>yacc</u> <u>main</u>():

           c99 y.tab.c lex.yy.c -l y -l l

       This ensures that the <u>yacc</u> library is searched first, so that its <u>main</u>() is used.

       The historical <u>yacc</u> libraries have contained  two  simple  functions  that  are  normally  coded  by  the
       application programmer. These functions are similar to the following code:

           #include &lt;<a href="file:/usr/include/locale.h">locale.h</a>&gt;
           int main(void)
           {
               extern int yyparse();

               setlocale(LC_ALL, "");

               /* If the following parser is one created by lex, the
                  application must be careful to ensure that LC_CTYPE
                  and LC_COLLATE are set to the POSIX locale. */
               (void) yyparse();
               return (0);
           }

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

           int yyerror(const char *msg)
           {
               (void) fprintf(stderr, "%s\n", msg);
               return (0);
           }

</pre><h4><b>RATIONALE</b></h4><pre>
       The  references  in  <b>Referenced</b>  <b>Documents</b>  may  be  helpful  in  constructing  the parser generator. The
       referenced DeRemer and Pennello article (along with the works it references)  describes  a  technique  to
       generate  parsers that conform to this volume of POSIX.1‐2017. Work in this area continues to be done, so
       implementors should consult current literature before doing any new implementations. The  original  Knuth
       article  is  the theoretical basis for this kind of parser, but the tables it generates are impractically
       large for reasonable grammars and should not be used. The ``equivalent to''  wording  is  intentional  to
       assure that the best tables that are <a href="../man1/LALR.1.html">LALR</a>(1) can be generated.

       There  has  been  confusion between the class of grammars, the algorithms needed to generate parsers, and
       the algorithms needed to parse the languages. They are all reasonably orthogonal. In particular, a parser
       generator that accepts the full range of <a href="../man1/LR.1.html">LR</a>(1) grammars need not generate a table any more  complex  than
       one that accepts <a href="../man1/SLR.1.html">SLR</a>(1) (a relatively weak class of LR grammars) for a grammar that happens to be <a href="../man1/SLR.1.html">SLR</a>(1).
       Such  an implementation need not recognize the case, either; table compression can yield the <a href="../man1/SLR.1.html">SLR</a>(1) table
       (or one even smaller than that) without recognizing that the grammar is <a href="../man1/SLR.1.html">SLR</a>(1).  The speed  of  an  <a href="../man1/LR.1.html">LR</a>(1)
       parser  for  any  class  is  dependent  more  upon  the table representation and compression (or the code
       generation if a direct parser is generated) than upon the class  of  grammar  that  the  table  generator
       handles.

       The  speed  of  the parser generator is somewhat dependent upon the class of grammar it handles. However,
       the original Knuth article algorithms for constructing LR  parsers  were  judged  by  its  author  to  be
       impractically  slow  at  that time. Although full LR is more complex than <a href="../man1/LALR.1.html">LALR</a>(1), as computer speeds and
       algorithms improve, the difference (in terms of acceptable wall-clock execution time)  is  becoming  less
       significant.

       Potential  authors  are  cautioned  that  the  referenced  DeRemer  and Pennello article previously cited
       identifies a bug (an over-simplification of the computation of <a href="../man1/LALR.1.html">LALR</a>(1) lookahead sets)  in  some  of  the
       <a href="../man1/LALR.1.html">LALR</a>(1)  algorithm statements that preceded it to publication. They should take the time to seek out that
       paper, as well as current relevant work, particularly Aho's.

       The <b>-b</b> option was added to provide a portable method for permitting <u>yacc</u> to  work  on  multiple  separate
       parsers  in the same directory. If a directory contains more than one <u>yacc</u> grammar, and both grammars are
       constructed at the same time (by, for example, a parallel <u>make</u>  program),  conflict  results.  While  the
       solution  is  not  historical  practice,  it  corrects  a known deficiency in historical implementations.
       Corresponding changes were made to all sections that referenced the filenames  <b>y.tab.c</b>  (now  ``the  code
       file''), <b>y.tab.h</b> (now ``the header file''), and <b>y.output</b> (now ``the description file'').

       The  grammar  for <u>yacc</u> input is based on System V documentation. The textual description shows there that
       the <b>';'</b> is required at the end of the rule. The grammar and the implementation do not require this.  (The
       use of <b>C_IDENTIFIER</b> causes a reduce to occur in the right place.)

       Also,  in that implementation, the constructs such as <b>%token</b> can be terminated by a &lt;semicolon&gt;, but this
       is not permitted by the grammar. The keywords such as <b>%token</b> can also appear in uppercase, which is again
       not discussed. In most places where <b>'%'</b> is used, &lt;backslash&gt; can be substituted, and there are  alternate
       spellings for some of the symbols (for example, <b>%LEFT</b> can be <b>"%&lt;"</b> or even <b>"\&lt;"</b>).

       Historically,  &lt;<u>tag</u>&gt; can contain any characters except <b>'&gt;'</b>, including white space, in the implementation.
       However,  since  the  <u>tag</u>  must  reference  an  ISO C  standard  union  member,  in  practice  conforming
       implementations  need  to  support  only  the  set  of  characters for ISO C standard identifiers in this
       context.

       Some historical implementations are known to accept actions that are terminated by a  period.  Historical
       implementations  often allow <b>'$'</b> in names. A conforming implementation does not need to support either of
       these behaviors.

       Deciding when to use <b>%prec</b> illustrates the difficulty in specifying the behavior of <u>yacc</u>.  There  may  be
       situations  in  which  the  <u>grammar</u> is not, strictly speaking, in error, and yet <u>yacc</u> cannot interpret it
       unambiguously. The resolution of ambiguities in  the  grammar  can  in  many  instances  be  resolved  by
       providing  additional  information, such as using <b>%type</b> or <b>%union</b> declarations. It is often easier and it
       usually yields a smaller parser to take this alternative when it is appropriate.

       The size and execution time of a program produced without the runtime debugging code is  usually  smaller
       and slightly faster in historical implementations.

       Statistics messages from several historical implementations include the following types of information:

           <u>n</u>/512 terminals, <u>n</u>/300 non-terminals
           <u>n</u>/600 grammar rules, <u>n</u>/1500 states
           <u>n</u> shift/reduce, <u>n</u> reduce/reduce conflicts reported
           <u>n</u>/350 working sets used
           Memory: states, etc. <u>n</u>/15000, parser <u>n</u>/15000
           <u>n</u>/600 distinct lookahead sets
           <u>n</u> extra closures
           <u>n</u> shift entries, <u>n</u> exceptions
           <u>n</u> goto entries
           <u>n</u> entries saved by goto default
           Optimizer space used: input <u>n</u>/15000, output <u>n</u>/15000
           <u>n</u> table entries, <u>n</u> zero
           Maximum spread: <u>n</u>, Maximum offset: <u>n</u>

       The  report of internal tables in the description file is left implementation-defined because all aspects
       of these limits  are  also  implementation-defined.  Some  implementations  may  use  dynamic  allocation
       techniques and have no specific limit values to report.

       The  format of the <b>y.output</b> file is not given because specification of the format was not seen to enhance
       applications portability. The listing is primarily intended to help human users understand and debug  the
       parser; use of <b>y.output</b> by a conforming application script would be unusual. Furthermore, implementations
       have  not  produced  consistent  output  and  no  popular format was apparent. The format selected by the
       implementation should be human-readable, in addition to the requirement that it be a text file.

       Standard error reports are not specifically described because  they  are  seldom  of  use  to  conforming
       applications and there was no reason to restrict implementations.

       Some  implementations recognize <b>"={"</b> as equivalent to <b>'{'</b> because it appears in historical documentation.
       This construction was recognized and documented as obsolete as long ago as 1978, in the referenced  <u>Yacc:</u>
       <u>Yet</u> <u>Another</u> <u>Compiler-Compiler</u>. This volume of POSIX.1‐2017 chose to leave it as obsolete and omit it.

       Multi-byte  characters  should  be recognized by the lexical analyzer and returned as tokens. They should
       not be returned as multi-byte character literals. The token <b>error</b> that is  used  for  error  recovery  is
       normally  assigned  the  value  256 in the historical implementation. Thus, the token value 256, which is
       used in many multi-byte character sets, is not available for use as the value of a user-defined token.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>c99</u>, <u>lex</u>

       The Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>8</u>,  <u>Environment</u>  <u>Variables</u>,  <u>Section</u>  <u>12.2</u>,  <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                          <u><a href="../man1POSIX/YACC.1POSIX.html">YACC</a></u>(1POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>