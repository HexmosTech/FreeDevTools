<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mcs - Turbo C# Compiler</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/mono-mcs">mono-mcs_6.12.0.199+dfsg-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mcs - Turbo C# Compiler

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>mcs</b> [option] [source-files]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       mcs  is  the  Turbo  C#  compiler  (also  known  as the Mono C# compiler), it is an implementation of the
       ECMA-334 language specification.  You can pass one or more options to drive the compiler, and  a  set  of
       source  files.   Extra  options  or  arguments  can  be  provided in a response file.  Response files are
       referenced by prepending the @ symbol to the response file name.

       The <u>mcs</u> compiler is used to compile against  the  latest  Mono  Base  Class  Library  version  and  fully
       implements C# 1.0, 2.0, 3.0, 4.0, 5.0 and 6.0 specifications with partial support for C# 7.0.

       See the section on packages for more information.

       The  Turbo  C# compiler accepts the same command line options that the Microsoft C# compiler does.  Those
       options can start with a slash or a dash (/checked is the same as -checked).  Additionally some  GNU-like
       options  are  supported,  those  begin  with "--".  All MCS-specific flags which are not available in the
       Microsoft C# compiler are available only with the GNU-style options.

       C# source files must end with a ".cs" extension.  Compilation of C# source code requires  all  the  files
       that make up a library, module or executable to be provided on the command line.  There is no support for
       partial  compilation.   To  achieve the benefits of partial compilation, you should compile programs into
       their own assemblies, and later reference them with the "-r" flag.

       The Turbo C# compiler generates images (.exe files) that contain CIL byte code that can  be  executed  by
       any  system  that  implements a Common Language Infrastructure virtual machine such as the Microsoft .NET
       runtime engine on Windows or the Mono runtime engine on Unix systems.  Executables are  not  bound  to  a
       specific CPU or operating system.

       The  Turbo  C#  compiler  by  default  only  references  three  assemblies:  mscorlib.dll, System.dll and
       System.Xml.dll.   If you want to reference extra libraries you must manually specify them using the -pkg:
       command line option or the -r: command line option.  Alternatively if you want to get all of  the  System
       libraries, you can use the -pkg:dotnet command line option.

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>--about</u>
              Displays information about the Turbo C# compiler

       <u>--addmodule:MODULE1[,MODULE2]</u>
              Includes  the  specified  modules  in  the resulting assembly.  Modules are created by calling the
              compiler with the -target:module option

       <u>-checked,</u> <u>-checked+</u>
              Sets the default compilation mode to `checked'.  This makes all the math operations  checked  (the
              default is unchecked).

       <u>-checked-</u>
              Sets  the  default  compilation mode to `unchecked'.  This makes all the math operations unchecked
              (this is the default).

       <u>-clscheck-,</u> <u>-clscheck+</u>
              Disables or enables the Common Language Specification (CLS) checks (it is enabled by default).

              The Common Language Specification (CLS) defines an  interoperable  subset  of  types  as  well  as
              conventions  that  compilers  (CLS  producers)  and developers must follow to expose code to other
              programming languages (CLS consumers).

       <u>-codepage:ID</u>
              Specifies the code page used to process the input files from the point it  is  specified  on.   By
              default  files will be processed in the environment-dependent native code page.  The compiler will
              also automatically detect Unicode files that have an embedded byte mark at the beginning.

              Other popular encodings are 28591 (Latin1), 1252 (iso-8859-1) and 65001 (UTF-8).

              MCS supports a couple of shorthands: "utf8" can be used to specify  utf-8  instead  of  using  the
              cryptic 65001 and "reset" restores the automatic handling of code pages.  These shorthands are not
              available on the Microsoft compiler.

       <u>-define:SYMLIST,</u> <u>-d:SYMLIST</u>
              Defines  the symbol listed by the semi-colon separated list SYMLIST SYMBOL.  This can be tested in
              the source code by the pre-processor, or can be used by methods that have  been  tagged  with  the
              Conditional attribute.

       <u>-debug,</u> <u>-debug+</u>
              Generate  debugging  information.  To  obtain stack traces with debugging information, you need to
              invoke the mono runtime with the `--debug' flag. The debugging information is stored in a MDB file
              located in same output folder as produced assembly.

       <u>-debug-</u>
              Do not generate debugging information.

       <u>-delaysign+</u>
              Only embed the strongname public key into the assembly. The actual signing must be done in a later
              stage using the SN tool. This is useful to protect the private key during development.  Note  that
              delay  signing  can  only be done using a strongname key file (not a key container). The option is
              equivalent to including [assembly: AssemblyDelaySign (true)] in your source code. Compiler  option
              takes precedence over the attributes.

       <u>-delaysign-</u>
              Default.  Strongname (sign) the assembly using the strong name key file (or container). The option
              is equivalent to including [assembly: AssemblyDelaySign (false)] in  your  source  code.  Compiler
              option takes precedence over the attributes.

       <u>-doc:FILE</u>
              Extracts the C#/XML documentation from the source code and stores in in the given FILE.

       <u>-errorreport</u>
              This  flag  is  ignored by Mono's C# compiler and is present only to allow MCS to be used as a CSC
              replacement for msbuild/xbuild.

       <u>--fatal</u>
              This is used for debugging the compiler.  This makes the error emission generate an exception that
              can be caught by a debugger.

       <u>-filealign</u>
              This flag is ignored by Mono's C# compiler and is present only to allow MCS to be used  as  a  CSC
              replacement for msbuild/xbuild.

       <u>-fullpaths</u>
              Any  source  code error or warning issued by the compiler includes file name only by default. This
              option causes compiler to issue absolute file path instead.

       <u>-keyfile:KEYFILE</u>
              Strongname (sign) the output assembly using the key pair present in the specified strong name  key
              file  (snk).  A full key pair is required by default (or when using delaysign-). A file containing
              only the public key can be used with delaysign+. The option is equivalent to including  [assembly:
              AssemblyKeyFile  ("KEYFILE")]  in  your  source  code.   Compiler option takes precedence over the
              attributes.

       <u>-keycontainer:CONTAINER</u>
              Strongname (sign) the output assembly using the key pair present in the specified container.  Note
              that  delaysign+  is  ignored  when  using  key  containers. The option is equivalent to including
              [assembly: AssemblyKeyName ("CONTAINER")] in your source code. Compiler  option  takes  precedence
              over the attributes.

       <u>-langversion:TEXT</u>
              The  option  specifies the version of the language to use. The feature set is different in each C#
              version. This switch can be used to force the compiler to allow only a  subset  of  the  features.
              The possible values are:

              <u>Default</u>
                     Instruct  compiler  to  use  the  latest  version.  Equivalent  is to omit the switch (this
                     currently defaults to the C# 6.0 language specification).

              <u>ISO-1</u>  Restrict compiler to use only first ISO standardized features.  The usage of features  such
                     as generics, static classes, anonymous methods will lead to error.

              <u>ISO-2</u>  Restrict compiler to use only the second ISO standardized features.  This allows the use of
                     generics, static classes, iterators and anonymous methods for example.

              <u>3</u>      Restrict the compiler to use only the features available in C# 3.0 (a superset of ISO-1 and
                     ISO-2).

              <u>4</u>      Restrict the compiler to use only the features available in C# 4.0 specification.

              <u>5</u>      Restrict the compiler to use only the features available in C# 5.0 specification.

              <u>6</u>      Restrict the compiler to use only the features available in C# 6.0 specification.

              <u>experimental</u>
                     Enables unstable features from upcoming versions of the language.

              Notice  that this flag only restricts the language features available to the programmer. A version
              of produced assemblies can be controlled using <u>SDK</u> option.

       <u>-lib:PATHLIST</u>
              Each path specified in the comma-separated list will direct the compiler to look for libraries  in
              that specified path.

       <u>-L</u> <u>PATH</u>
              Directs  the compiler to look for libraries in the specified path.  Multiple paths can be provided
              by using the option multiple times.

       <u>-main:CLASS</u>
              Tells the compiler which CLASS contains the entry point. Useful when  you  are  compiling  several
              classes with a Main method.

       <u>-nostdlib,</u> <u>-nostdlib+</u>
              Use  this flag if you want to compile the core library.  This makes the compiler load its internal
              types from the assembly being compiled.

       <u>-noconfig,</u> <u>-noconfig+</u>
              Disables the default compiler configuration to be loaded.  The compiler by default has  references
              to the system assemblies.

       <u>-nowarn:WARNLIST</u>
              Makes the compiler ignore warnings specified in the comma-separated list WARNLIST&gt;

       <u>-optimize,</u> <u>-optimize+,</u> <u>-optimize-</u>
              Controls  compiler  code  generation optimizations on the code. Using -optimize or -optimize+ will
              turn on optimizations, -optimize- will turn it off.  The default  in  mcs  is  to  optimize-.  The
              option  can be mixed with -debug but for the best debugging experience it is recommended leave the
              options off.

       <u>-out:FNAME,</u> <u>-o</u> <u>FNAME</u>
              Names the output file to be generated.

       <u>--parse</u>
              Used for benchmarking.  The compiler will only parse its input files.

       <u>-pathmap:K=V[,Kn=Vn]</u>
              Sets a mapping for source path names used in generated output.

       <u>-pkg:package1[,packageN]</u>
              Reference assemblies for the given packages.

              The compiler will invoke pkg-config --libs on the set of packages specified on the command line to
              obtain libraries and directories to compile the code.

              This is typically used with third party components, like this:

                        $ mcs -pkg:gtk-sharp demo.cs

              <u>-pkg:dotnet</u>
                     This will instruct the compiler to reference the System.* libraries available on a  typical
                     dotnet framework installation, notice that this does not include all of the Mono libraries,
                     only the System.* ones.  This is a convenient shortcut for those porting code.

       <u>-platform:ARCH</u>
              Used  to  specify the target platform. The possible values are: anycpu, anycpu32bitpreferred, arm,
              x86, x64 or itanium. The default option is anycpu.

       <u>-resource:RESOURCE[,ID]</u>
              Embeds to the given resource file.  The optional ID can be used to give a different  name  to  the
              resource.  If not specified, the resource name will be the file name.

       <u>-linkresource:RESOURCE[,ID]</u>
              Links  to  the  specified  RESOURCE.   The  optional  ID  can be used to give a name to the linked
              resource.

       <u>-r:ASSEMBLY1[,ASSEMBLY2],</u> <u>-reference</u> <u>ASSEMBLY1[,ASSEMBLY2]</u>
              Reference the named assemblies.  Use this to use classes from the named assembly in your  program.
              The  assembly  will  be  loaded from either the system directory where all the assemblies live, or
              from the path explicitly given with the -L option.

              You can also use a semicolon to separate the assemblies instead of a comma.

       <u>-reference:ALIAS=ASSEMBLY</u>
              Extern alias reference support for C#.

              If you have different assemblies that provide the same types, the extern alias support allows  you
              to  provide names that your software can use to tell those appart.    The types from ASSEMBLY will
              be exposed as ALIAS, then on the C# source code, you need to do:

                   extern alias ALIAS;
              To bring it into your namespace.   For example, to cope with two graphics  libraries  that  define
              "Graphics.Point",  one  in "OpenGL.dll" and one in "Postscript.dll", you would invoke the compiler
              like this:

                   mcs -r:Postscript=Postscript.dll -r:OpenGL=OpenGL.dll

              And in your source code, you would write:

                   extern alias Postscript;
                   extern alias OpenGL;

                   class X {
                        // This is a Graphics.Point from Postscrip.dll
                        Postscript.Point p = new Postscript.Point ();

                        // This is a Graphics.Point from OpenGL.dll
                        OpenGL.Point p = new OpenGL.Point ();
                   }

       <u>-recurse:PATTERN,</u> <u>--recurse</u> <u>PATTERN</u>
              Does recursive compilation using the specified pattern.  In Unix the shell will perform  globbing,
              so you might want to use it like this:

                 $ mcs -recurse:'*.cs'

       <u>-sdk:VERSION</u>
              Used  to  specify  the  version  of  Base Class Library assemblies used for compilation. Following
              predefined values are valid: 2, 4 (default) as well as any custom value.  The  predefined  version
              number means which custom value is specified mcs will try to find Base Class Libraries in the mono
              installed location PREFIX/lib/mono/&lt;value&gt;.

       <u>--shell</u>
              Starts  up  the compiler in interactive mode, providing a C# shell for statements and expressions.
              A shortcut is to use the <u>csharp</u> command directly.

       <u>--stacktrace</u>
              Generates a stack trace at the time the error is reported, useful for debugging the compiler.

       <u>-target:KIND,</u> <u>-t:KIND</u>
              Used to specify the desired target.  The possible  values  are:  exe  (plain  executable),  winexe
              (Windows.Forms executable), library (component libraries) and module (partial library).

       <u>--timestamp</u>
              Another debugging flag.  Used to display the times at various points in the compilation process.

       <u>-unsafe,</u> <u>-unsafe+</u>
              Enables compilation of unsafe code.

       <u>-v</u>     Debugging. Turns on verbose yacc parsing.

       <u>--version</u>
              Shows the compiler version.

       <u>-warnaserror,</u> <u>-warnaserror+</u>
              All compilers warnings will be reported as errors.

       <u>-warnaserror:W1,[Wn],</u> <u>-warnaserror+:W1,[Wn]</u>
              Treats one or more compiler warnings as errors.

       <u>-warnaserror-:W1,[Wn]</u>
              Sets  one  or  more compiler warnings to be always threated as warnings.  Becomes useful when used
              together with -warnaserror.

       <u>-warn:LEVEL</u>
              Sets the warning level.  0 is the lowest warning level, and 4 is the highest.  The default is 4.

       <u>-win32res:FILE</u>
              Specifies a Win32 resource file (.res) to be bundled into the resulting assembly.

       <u>-win32icon:FILE</u>
              Attaches the icon specified in FILE on the output into the resulting assembly.

       <u>--</u>     Use this to stop option parsing, and allow option-looking parameters to be passed on  the  command
              line.

</pre><h4><b>PACKAGES</b> <b>AND</b> <b>LIBRARIES</b></h4><pre>
       When  referencing  an  assembly, if the name of the assembly is a path, the compiler will try to load the
       assembly specified in the path.   If it does not, then the compiler will try loading  the  assembly  from
       the  current  directory,  the  compiler  base  directory and if the assembly is not found in any of those
       places in the directories specified as arguments to the -lib: command argument.

       The compiler uses the library path to locate libraries,  and  is  able  to  reference  libraries  from  a
       particular  package if that directory is used.  To simplify the use of packages, the C# compiler includes
       the -pkg: command line option that is used to load specific collections of libraries.

       Libraries visible to the compiler are stored relative to the installation prefix  under  PREFIX/lib/mono/
       called the PACKAGEBASE and the defaults for mcs, gmcs and smcs are as follows:

       <u>mcs</u>    References the PACKAGEBASE/1.0 directory

       <u>gmcs</u>   References the PACKAGEBASE/2.0 directory

       <u>smcs</u>   References the PACKAGEBASE/2.1 directory

       Those  are  the  only  runtime  profiles that exist.  Although other directories exist (like 3.0 and 3.5)
       those are not really runtime profiles, they are merely placeholders for extra libraries that build on the
       2.0 foundation.

       Software providers will distribute software that is installed  relative  to  the  PACKAGEBASE  directory.
       This  is  integrated  into  the  <u>gacutil</u>  tool  that  not only installs public assemblies into the Global
       Assembly Cache (GAC) but also installs them into the PACKAGEBASE/PKG directory (where  PKG  is  the  name
       passed to the -package flag to gacutil).

       As a developer, if you want to consume the Gtk# libraries, you would invoke the compiler like this:

            $ mcs -pkg:gtk-sharp-2.0 main.cs

       The  -pkg: option instructs the compiler to fetch the definitions for gtk-sharp-2.0 from pkg-config, this
       is equivalent to passing to the C# compiler the output of:

            $ pkg-config --libs gtk-sharp-2.0

       Usually this merely references the libraries from PACKAGEBASE/PKG.

       Although there are directory names for 3.0 and 3.5, that does  not  mean  that  there  are  3.0  and  3.5
       compiler  editions  or profiles.   Those are merely new libraries that must be manually referenced either
       with the proper -pkg: invocation, or by referencing the libraries directly.

</pre><h4><b>SPECIAL</b> <b>DEFINES</b></h4><pre>
       The <b>TRACE</b> and <b>DEBUG</b> defines have a special meaning to the compiler.

       By default calls to methods and properties in the System.Diagnostics.Trace class are not generated unless
       the TRACE symbol is defined (either through a "#define TRACE") in your  source  code,  or  by  using  the
       <u>--define</u> <u>TRACE</u> in the command line.

       By default calls to methods and properties in the System.Diagnostics.Debug class are not generated unless
       the  DEBUG  symbol  is  defined  (either  through a "#define DEBUG") in your source code, or by using the
       <u>--define</u> <u>DEBUG</u> in the command line.

       Note that the effect of defining TRACE and DEBUG is a global setting, even if they are only defined in  a
       single file.

</pre><h4><b>DEBUGGING</b> <b>SUPPORT</b></h4><pre>
       When  using  the  "-debug"  flag,  MCS  will  generate  a  file with the extension .mdb that contains the
       debugging information for the generated assembly.  This file is consumed by the Mono debugger (mdb).

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       <u>MCS_COLORS</u>
              If this variable is set, it contains a string in the form "foreground,background"  that  specifies
              which color to use to display errors on some terminals.

              The background is optional and defaults to your terminal current background.   The possible colors
              for  foreground  are:  <b>black,</b>  <b>red,</b>  <b>brightred,</b>  <b>green,</b>  <b>brightgreen,</b>  <b>yellow,</b> <b>brightyellow,</b> blue,
              brightblue, magenta, brightmagenta, cyan, brightcyan, grey, white and brightwhite.

              The possible colors for background are: black, red, green, yellow, blue, magenta, cyan,  grey  and
              white.

              For example, you could set these variable from your shell:
                   export MCS_COLORS
                   MCS_COLORS=errors=brightwhite,red

              You can disable the built-in color scheme by setting this variable to "disable".

</pre><h4><b>NOTES</b></h4><pre>
       During  compilation  the  MCS  compiler  defines the __MonoCS__ symbol, this can be used by pre-processor
       instructions to compile Mono C# compiler specific code.   Please note that this symbol is  only  to  test
       for the compiler, and is not useful to distinguish compilation or deployment platforms.

</pre><h4><b>AUTHORS</b></h4><pre>
       The  Mono  C#  Compiler  was written by Miguel de Icaza, Ravi Pratap, Martin Baulig, Marek Safar and Raja
       Harinath.  The development was funded by Ximian, Novell and Marek Safar.

</pre><h4><b>LICENSE</b></h4><pre>
       The Mono Compiler Suite is released under the terms of the GNU GPL or  the  MIT  X11.   Please  read  the
       accompanying  `COPYING'  file  for  details.   Alternative  licensing  for the compiler is available from
       Xamarin.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/csharp.1.html">csharp</a>(1), <a href="../man1/mono.1.html">mono</a>(1), <a href="../man1/pkg-config.1.html">pkg-config</a>(1), <a href="../man1/sn.1.html">sn</a>(1)

</pre><h4><b>BUGS</b></h4><pre>
       To report bugs in the compiler, you must file them on  our  bug  tracking  system,  at:  <a href="http://www.mono">http://www.mono</a>-
       project.com/community/bugs/

</pre><h4><b>MAILING</b> <b>LIST</b></h4><pre>
       The Mono Mailing lists are listed at <a href="http://www.mono-project.com/community/help/mailing-lists/">http://www.mono-project.com/community/help/mailing-lists/</a>

</pre><h4><b>MORE</b> <b>INFORMATION</b></h4><pre>
       The   Mono   C#   compiler   was  developed  by  Novell,  Inc  (<a href="http://www.novell.com">http://www.novell.com</a>)  and  Xamarin  Inc
       (<a href="http://www.xamarin.com">http://www.xamarin.com</a>)   is   based   on   the   ECMA   C#   language    standard    available    here:
       <a href="http://www.ecma.ch/ecma1/STAND/ecma-334.htm">http://www.ecma.ch/ecma1/STAND/ecma-334.htm</a>

       The    home   page   for   the   Mono   C#   compiler   is   at   <a href="http://www.mono-project.com/docs/about">http://www.mono-project.com/docs/about</a>-
       mono/languages/csharp/

                                                 6 January 2001                                           <u><a href="../man1/mcs.1.html">mcs</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>