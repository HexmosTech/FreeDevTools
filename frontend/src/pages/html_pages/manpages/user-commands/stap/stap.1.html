<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>stap - systemtap script translator/driver</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/systemtap">systemtap_5.1-4.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       stap - systemtap script translator/driver

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>stap</b> [ <u>OPTIONS</u> ] <u>FILENAME</u> [ <u>ARGUMENTS</u> ]
       <b>stap</b> [ <u>OPTIONS</u> ] <b>-</b> [ <u>ARGUMENTS</u> ]
       <b>stap</b> [ <u>OPTIONS</u> ] <b>-e</b> <u>SCRIPT</u> [ <u>ARGUMENTS</u> ]
       <b>stap</b> [ <u>OPTIONS</u> ] <b>-l</b> <u>PROBE</u> [ <u>ARGUMENTS</u> ]
       <b>stap</b> [ <u>OPTIONS</u> ] <b>-L</b> <u>PROBE</u> [ <u>ARGUMENTS</u> ]
       <b>stap</b> [ <u>OPTIONS</u> ] <b>--dump-probe-types</b>
       <b>stap</b> [ <u>OPTIONS</u> ] <b>--dump-probe-aliases</b>
       <b>stap</b> [ <u>OPTIONS</u> ] <b>--dump-functions</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>stap</u>  program  is the front-end to the Systemtap tool.  It accepts probing instructions written in a
       simple domain-specific language, translates those instructions into C code, compiles  this  C  code,  and
       loads  the  resulting  module into a running Linux kernel or a Dyninst user-space mutator, to perform the
       requested system trace/probe functions.  You can supply the script  in  a  named  file  (FILENAME),  from
       standard input (use - instead of FILENAME), or from the command line (using -e SCRIPT).  The program runs
       until  it  is  interrupted  by  the user, or if the script voluntarily invokes the <u>exit()</u> function, or by
       sufficient number of soft errors.

       The language, which is described the <u>SCRIPT</u>  <u>LANGUAGE</u>  section  below,  is  strictly  typed,  expressive,
       declaration  free,  procedural,  prototyping-friendly,  and inspired by <u>awk</u> and <u>C</u>.  It allows source code
       points or events in the system to be associated with handlers, which are subroutines  that  are  executed
       synchronously.  It is somewhat similar conceptually to "breakpoint command lists" in the <u>gdb</u> debugger.

</pre><h4><b>DOCUMENTATION</b> <b>OVERVIEW</b></h4><pre>
       systemtap  comes  with a variety of educational, documentation and reference resources.  They come online
       and/or packaged for offline use.  Some systemtap  diagnostic  warning/error  messages  specially  suggest
       reading  a  man  page  by  including a string like [man error::pass5].  For online documentation, see the
       project web site, https://sourceware.org/systemtap/

       ┌───────────────────────────┬──────────────────────────────────────────────────────┐
       │ <b>man</b> <b>pages</b>                 │                                                      │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stap (this page)          │ language syntax, concepts, operation, options        │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ error::*                  │ further explanation of error conditions              │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ warning::*                │ further explanation of warning conditions            │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stapprobes                │ probe points and their $context variables            │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stapref                   │ quick reference to language syntax                   │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stappaths                 │ list of directories, including books &amp; references    │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stap-prep                 │ program to install auxiliary dependencies like  ker‐ │
       │                           │ nel debuginfo                                        │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ tapset::*                 │ generated list of tapsets                            │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ probe::*                  │ generated list of tapset probe aliases               │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ function::*               │ generated list of tapset functions                   │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ macro::*                  │ generated list of tapset macros                      │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stapvars                  │ some of the tapset global variables                  │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ staprun, stapdyn, stapbpf │ programs for executing compiled systemtap scripts    │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ systemtap                 │ initscript, boot-time probing                        │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stap-server               │ compilation server                                   │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ stapex                    │ a few very basic script examples                     │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ <b>books</b>                     │                                                      │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ Beginner's Guide          │ tutorial book, language essentials, examples         │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ Tutorial                  │ shorter tutorial, exercises                          │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ Language Reference        │ detailed language manual, covers statistics/analysis │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ Tapset Reference          │ the tapset man pages, reformatted into a book        │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ <b>references</b>                │                                                      │
       ├───────────────────────────┼──────────────────────────────────────────────────────┤
       │ example scripts           │ over a hundred directly usable sysadmin tools, toys, │
       │                           │ hacks to learn from                                  │
       └───────────────────────────┴──────────────────────────────────────────────────────┘

</pre><h4><b>OPTIONS</b></h4><pre>
       The systemtap translator supports the following options.  Any other option prints a list of supported op‐
       tions.  Options may be given on the command line, as usual.  If the file $SYSTEMTAP_DIR/rc exist, options
       are  also  loaded  from there and interpreted first.  ($SYSTEMTAP_DIR defaults to $HOME/.systemtap if un‐
       set.)

       In some cases, the default value of an option depends on particular system configuration and  thus  can't
       be mentioned here directly.  In some of those cases running "stap --help" might display the default.

       <b>-</b>      Use standard input instead of a given FILENAME as probe language input, unless -e SCRIPT is given.

       <b>-h</b> <b>--help</b>
              Show help message.

       <b>-V</b> <b>--version</b>
              Show version message.

       <b>-p</b> <u>NUM</u> Stop after pass NUM.  The passes are numbered 1-5: parse, elaborate, translate, compile, run.  See
              the <b>PROCESSING</b> section for details.

       <b>-v</b>     Increase  verbosity  for  all passes.  Produce a larger volume of informative (?) output each time
              option repeated.

       <b>--vp</b> <b>ABCDE</b>
              Increase verbosity on a per-pass basis.  For example, "--vp 002" adds 2 units of verbosity to pass
              3 only.  The combination "-v --vp 00004" adds 1 unit of verbosity for all passes, and 4  more  for
              pass 5.

       <b>-k</b>     Keep  the  temporary  directory  after all processing.  This may be useful in order to examine the
              generated C code, or to reuse the compiled kernel object.

       <b>-g</b>     Guru mode.  Enable parsing of unsafe expert-level constructs like embedded C.

       <b>-P</b>     Prologue-searching mode.  This is equivalent to --prologue-searching=always.  Activate  heuristics
              to work around incorrect debugging information for function parameter $context variables.

       <b>-u</b>     Unoptimized  mode.   Disable unused code elision and many other optimizations during elaboration /
              translation.

       <b>-w</b>     Suppressed warnings mode.  Disables all warning messages.

       <b>-W</b>     Treat all warnings as errors.

       <b>-b</b>     Use bulk mode (percpu files) for kernel-to-user data transfer.  Use the <u>stap-merge</u> program to mul‐
              tiplex them back together later.

       <b>-i</b> <b>--interactive</b>
              Interactive mode. Enable an interface to build the systemtap script incrementally and interactive‐
              ly.

       <b>-t</b>     Collect timing information on the number of times probe executes and average amount of time  spent
              in each probe-point. Also shows the derivation for each probe-point.

       <b>-s</b> <u>NUM</u> Use  NUM megabyte buffers for kernel-to-user data transfer per processor.  The default is 16MB, or
              less on smaller memory machines.

       <b>-I</b> <u>DIR</u> Add the given directory to the tapset search directory.  See the description of  pass  2  for  de‐
              tails.

       <b>-D</b> <u>NAME=VALUE</u>
              Add the given C preprocessor directive to the module Makefile.  These can be used to override lim‐
              it parameters described below.

       <b>-B</b> <u>NAME=VALUE</u>
              In kernel-runtime mode, add the given make directive to the kernel module build's make invocation.
              These can be used to add or override kconfig options.  For example, use

              <b>-B</b> <b>CONFIG_DEBUG_INFO=y</b>

              to add debugging information.

       <b>-B</b> <u>FLAG</u>
              In  dyninst-runtime  mode,  add  the  given parameter to the compiler CFLAGS used for building the
              dyninst shared library.  For example, use

              <b>-B</b> <b>-g</b>

              to add debugging information.

       <b>-a</b> <u>ARCH</u>
              Use a cross-compilation mode for the given target  architecture.   This  requires  access  to  the
              cross-compiler and the kernel build tree, and goes along with the

              <b>-B</b> <b>CROSS_COMPILE=arch-tool-prefix-</b>
              and
              <b>-r</b> <b>/build/tree</b>

              options.

       <b>--modinfo</b> <u>NAME=VALUE</u>
              Add  the  name/value pair as a MODULE_INFO macro call to the generated module.  This may be useful
              to inform or override various module-related checks in the kernel.

       <b>-G</b> <u>NAME=VALUE</u>
              Sets the value of global variable NAME to VALUE when staprun is invoked.  This applies  to  scalar
              variables declared global in the script/tapset.

       <b>-R</b> <u>DIR</u> Look for the systemtap runtime sources in the given directory.  Your DIR default can be seen using
              "stap --help".

       <b>-r</b> <u>/DIR</u>
              Build for kernel in given build tree. Can also be set with the <u>SYSTEMTAP_RELEASE</u> environment vari‐
              able.

       <b>-r</b> <u>RELEASE</u>
              Build for kernel in build tree <b>/lib/modules/RELEASE/build</b>.  Can also be set with the <u>SYSTEMTAP_RE‐</u>
              <u>LEASE</u> environment variable.

       <b>-m</b> <u>MODULE</u>
              Use  the  given  name for the generated kernel object module, instead of a unique randomized name.
              The generated kernel object module is copied to the current directory.

       <b>-d</b> <u>MODULE</u>
              Add symbol/unwind information for the given module into the kernel object module.  This may enable
              symbolic tracebacks from those modules/programs, even if they do not have an explicit probe placed
              into them.

       <b>--ldd</b>  Add symbol/unwind information for all user-space shared libraries suspected by ldd to be necessary
              for user-space binaries being probed or listed with the -d option.  Caution:  this  can  make  the
              probe modules considerably larger.  Note that this option does not deal with kernel-space modules:
              see instead --all-modules below.

       <b>--all-modules</b>
              Equivalent  to  specifying  "-dkernel" and a "-d" for each kernel module that is currently loaded.
              Caution: this can make the probe modules considerably larger.

       <b>-o</b> <u>FILE</u>
              Send standard output to named file. In bulk mode, percpu files will  start  with  FILE_  (FILE_cpu
              with -F) followed by the cpu number.  This supports <a href="../man3/strftime.3.html">strftime</a>(3) formats for FILE.

       <b>-c</b> <u>CMD</u> Start  the  probes, run CMD, and exit when CMD finishes.  This also has the effect of setting tar‐
              get() to the pid of that process.  Note that many probe types trigger independently of  this  set‐
              ting.  Consider including something like this to focus your script.

                 probe FOO { if (pid() != target()) next; .... }

       <b>-x</b> <u>PID</u> Sets target() to PID.  The script runs independently of the PID's lifespan.

       <b>-e</b> <u>SCRIPT</u>
              Run the given SCRIPT specified on the command line.

       <b>-E</b> <u>SCRIPT</u>
              Run  the  given  SCRIPT  specified.  This  SCRIPT is run in addition to the main script specified,
              through -e, or as a script file. This option can be repeated to run multiple scripts, and  can  be
              used in listing mode (-l/-L).

       <b>-l</b> <u>PROBE</u>
              Instead  of running a probe script, just list all available probe points matching the given single
              probe point.  The pattern may include wildcards and  aliases,  but  not  comma-separated  multiple
              probe points.  The process result code will indicate failure if there are no matches.

              % stap -e 'probe syscall.* { }'
              [...]
              % stap -l 'syscall.*'
              syscall.accept
              [...]
              syscall.writev

       <b>-L</b> <u>PROBE</u>
              Similar  to  "-l", but list matching probe points plus their available context variables.  When -v
              is set with -L, the output includes duplicate probe points which are distinguished by their PC ad‐
              dress.

              % stap -L 'process("/lib64/libpython*.so.*").mark("*")'
              process("/usr/lib64/libpython2.7.so.1.0").mark("function__entry") $arg1:long $arg2:long $arg3:long
              process("/usr/lib64/libpython2.7.so.1.0").mark("function__return") $arg1:long $arg2:long $arg3:long
              process("/usr/lib64/libpython3.6m.so.1.0").mark("function__entry") $arg1:long $arg2:long $arg3:long
              process("/usr/lib64/libpython3.6m.so.1.0").mark("function__return") $arg1:long $arg2:long $arg3:long
              process("/usr/lib64/libpython3.6m.so.1.0").mark("gc__done") $arg1:long
              process("/usr/lib64/libpython3.6m.so.1.0").mark("gc__start") $arg1:long
              process("/usr/lib64/libpython3.6m.so.1.0").mark("line") $arg1:long $arg2:long $arg3:long

       <b>-F</b>     Without -o option, load module and start probes, then detach from the module  leaving  the  probes
              running.  With -o option, run staprun in background as a daemon and show its pid.

       <b>-S</b> <u>size[,N]</u>
              Sets  the maximum size of output file and the maximum number of output files.  If the size of out‐
              put file will exceed <b>size</b> megabytes, systemtap switches output file to the next file. And  if  the
              number  of output files exceed <b>N</b> , systemtap removes the oldest output file. You can omit the sec‐
              ond argument.

       <b>-T</b> <u>TIMEOUT</u>
              Exit the script after TIMEOUT seconds.

       <b>--skip-badvars</b>
              Ignore unresolvable or run-time-inaccessible context variables and substitute with 0, without  er‐
              rors.

       <b>--prologue-searching</b>[=<u>WHEN</u>]
              Prologue-searching  mode.  Activate heuristics to work around incorrect debugging information  for
              function  parameter $context variables. WHEN can be either "never", "always", or "auto" (i.e.  en‐
              abled  by heuristic). If WHEN is missing, then "always" is assumed. If the option is missing, then
              "auto" is assumed.

       <b>--suppress-handler-errors</b>
              Wrap all probe handlers into something like this

              try { ... } catch { next }

              block, which causes any runtime errors to be quietly suppressed.  Suppressed errors do  not  count
              against  <b>MAXERRORS</b>  limits.  In this mode, the <b>MAXSKIPPED</b> limits are also suppressed, so that many
              errors and skipped probes may be accumulated during a script's runtime.  Any overall  counts  will
              still be reported at shutdown.

       <b>--compatible</b> <u>VERSION</u>
              Suppress  recent script language or tapset changes which are incompatible with given older version
              of systemtap.  This may be useful if a much older systemtap script fails to run.  See the DEPRECA‐
              TION section for more details.

       <b>--check-version</b>
              This option is used to check if the active script has any constructs that may be systemtap version
              specific.  See the DEPRECATION section for more details.

       <b>--clean-cache</b>
              This option prunes stale entries from the cache directory.  This is  normally  done  automatically
              after  successful  runs, but this option will trigger the cleanup manually and then exit.  See the
              CACHING section for more details about cache limits.

       <b>--color</b>[=<u>WHEN</u>], <b>--colour</b>[=<u>WHEN</u>]
              This option controls coloring of error messages. WHEN can be either "never", "always",  or  "auto"
              (i.e.  enable  only if at a terminal). If WHEN is missing, then "always" is assumed. If the option
              is missing, then "auto" is assumed.

              Colors can be modified using the SYSTEMTAP_COLORS environment variable. The format must be of  the
              form  <b>key1=val1:key2=val2:key3=val3</b> ...etc.  Valid keys are "error", "warning", "source", "caret",
              and "token".  Values constitute Select Graphic Rendition (SGR) parameter(s). Consult the  documen‐
              tation  of  your terminal for the SGRs it supports. As an example, the default colors would be ex‐
              pressed as <b>error=01;31:warning=00;33:source=00;34:caret=01:token=01</b>.  If SYSTEMTAP_COLORS  is  ab‐
              sent, the default colors will be used. If it is empty or invalid, coloring is turned off.

       <b>--disable-cache</b>
              This option disables all use of the cache directory.  No files will be either read from or written
              to the cache.

       <b>--poison-cache</b>
              This option treats files in the cache directory as invalid.  No files will be read from the cache,
              but  resulting  files  from this run will still be written to the cache.  This is meant as a trou‐
              bleshooting aid when stap's cached behavior seems to be misbehaving.  If it  helped,  there  is  a
              probably a bug in systemtap that the developers would like you to report.

       <b>--privilege</b>[=<u>stapusr</u> | =<u>stapsys</u> | =<u>stapdev</u>]
              This  option instructs <u>stap</u> to examine the script looking for constructs which are not allowed for
              the specified privilege level (see <u>UNPRIVILEGED</u> <u>USERS</u>).  Compilation fails if any such  constructs
              are used.  If <u>stapusr</u> or <u>stapsys</u> are specified when using a compile server (see <u>--use-server</u>), the
              server  will  examine  the  script and, if compilation succeeds, the server will cryptographically
              sign the resulting kernel module, certifying that is it safe for use by  users  at  the  specified
              privilege level.

              If  <u>--privilege</u>  has  not  been specified, <u>-pN</u> has not been specified with N &lt; 5, and the invoking
              user is not <u>root</u>, and is not a member of the group <u>stapdev</u>, then <u>stap</u> will automatically  add  the
              appropriate <u>--privilege</u> option to the options already specified.

       <b>--unprivileged</b>
              This option is equivalent to <u>--privilege=stapusr</u>.

       <b>--use-server</b>[=<u>HOSTNAME</u>[<u>:PORT</u>] | =<u>IP_ADDRESS</u>[<u>:PORT</u>] | =<u>CERT_SERIAL</u>]
              Specify compile-server(s) to be used for compilation and/or in conjunction with <u>--list-servers</u> and
              <u>--trust-servers</u>  (see below) for listing. If no argument is supplied, then the default in unprivi‐
              leged mode (see <u>--privilege</u>) is to select compatible servers which are trusted as SSL peers and as
              module signers and currently online. Otherwise the default is to select compatible  servers  which
              are  trusted  as SSL peers and currently online.  <u>--use-server</u> may be specified more than once, in
              which case a list of servers is accumulated in the order specified. Servers may  be  specified  by
              host  name, ip address, or by certificate serial number (obtained using <u>--list-servers</u>).  The lat‐
              ter is most commonly used when adding or revoking trust in a server (see  <u>--trust-servers</u>  below).
              If  a  server  is specified by host name or ip address, then an optional port number may be speci‐
              fied. This is useful for accessing servers which are not on the local network or to specify a par‐
              ticular server.

              IP addresses may be IPv4 or IPv6 addresses.

              If a particular IPv6 address is link local and exists on more than one interface, the intended in‐
              terface may be specified by appending the address with a percent sign (%) followed by the intended
              interface name. For example, "fe80::5eff:35ff:fe07:55ca%eth0".

              In order to specify a port number with an IPv6 address, it is necessary to enclose  the  IPv6  ad‐
              dress  in  square brackets ([]) in order to separate the port number from the rest of the address.
              For example, "[fe80::5eff:35ff:fe07:55ca]:5000" or "[fe80::5eff:35ff:fe07:55ca%eth0]:5000".

              If <u>--use-server</u> has not been specified, <u>-pN</u> has not been specified with N &lt; 5,  and  the  invoking
              user  not  <u>root</u>,  is not a member of the group <u>stapdev</u>, but is a member of the group <u>stapusr</u>, then
              <u>stap</u> will automatically add <u>--use-server</u> to the options already specified.

       <b>--use-server-on-error</b>[=<b>yes</b>|=<b>no</b>]
              Instructs stap to retry compilation of a script using a compile server if compilation on the local
              host fails in a manner which suggests that it might succeed using a server.  If this option is not
              specified, the default is <u>no</u>.  If no argument is provided, then the default  is  <u>yes</u>.  Compilation
              will  be  retried  for certain types of errors (e.g. insufficient data or resources) which may not
              occur during re-compilation by a compile server. Compile servers will  be  selected  automatically
              for the re-compilation attempt as if <u>--use-server</u> was specified with no arguments.

       <b>--list-servers</b><u>[=SERVERS]</u>
              Display the status of the requested <u>SERVERS</u>, where <u>SERVERS</u> is a comma-separated list of server at‐
              tributes.  The  list  of attributes is combined to filter the list of servers displayed. Supported
              attributes are:

              <b>all</b>    specifies all known servers (trusted SSL peers, trusted module signers, online servers).

              <b>specified</b>
                     specifies servers specified using <u>--use-server</u>.

              <b>online</b> filters the output by retaining information about servers which are currently online.

              <b>trusted</b>
                     filters the output by retaining information about servers which are trusted as SSL peers.

              <b>signer</b> filters the output by retaining information about servers which are trusted as module sign‐
                     ers (see <u>--privilege</u>).

              <b>compatible</b>
                     filters the output by retaining information about servers which  are  compatible  with  the
                     current kernel release and architecture.

              If  no  argument  is  provided, then the default is <b>specified</b>.  If no servers were specified using
              <u>--use-server</u>, then the default servers for <u>--use-server</u> are listed.

              Note that <u>--list-servers</u> uses the <u>avahi-daemon</u> service to detect online servers. If  this  service
              is  not  available,  then  <u>--list-servers</u>  will  fail  to  detect any <u>online</u> servers. In order for
              <u>--list-servers</u> to detect servers listening on IPv6 addresses, the <u>avahi-daemon</u> configuration  file
              <u>/etc/avahi/avahi-daemon.conf</u>  must  contain  an  active  "use-ipv6=yes"  line. The service must be
              restarted after adding this line in order for IPv6 to be enabled.

       <b>--trust-servers</b><u>[=TRUST_SPEC]</u>
              Grant or revoke trust in compile-servers, specified using <u>--use-server</u> as specified by TRUST_SPEC,
              where TRUST_SPEC is a comma-separated list specifying the trust which is to be granted or revoked.
              Supported elements are:

              <b>ssl</b>    trust the specified servers as SSL peers.

              <b>signer</b> trust the specified servers as module signers (see <u>--privilege</u>).   Only  root  can  specify
                     <b>signer.</b>

              <b>all-users</b>
                     grant  trust  as an ssl peer for all users on the local host. The default is to grant trust
                     as an ssl peer for the current user only. Trust as a module signer is  always  granted  for
                     all users. Only root can specify <b>all-users</b>.

              <b>revoke</b> revoke the specified trust. The default is to grant it.

              <b>no-prompt</b>
                     do  not  prompt the user for confirmation before carrying out the requested action. The de‐
                     fault is to prompt the user for confirmation.

              If no argument is provided, then  the  default  is  <b>ssl</b>.   If  no  servers  were  specified  using
              <u>--use-server</u>, then no trust will be granted or revoked.

              Unless  <b>no-prompt</b> has been specified, the user will be prompted to confirm the trust to be granted
              or revoked before the operation is performed.

       <b>--sign-module</b>
              Sign the module with a MOK (Machine Owner Key) on UEFI/SecureBoot  systems.   See  the  SECUREBOOT
              section for more details.

       <b>--dump-probe-types</b>
              Dumps  a  list  of  supported probe types and exits. If <u>--privilege=stapusr</u> is also specified, the
              list will be limited to probe types available to unprivileged users.

       <b>--dump-probe-aliases</b>
              Dumps a list of all probe aliases found in library files and exits.

       <b>--dump-functions</b>
              Dumps a list of all the public functions found in library files and exits. Also includes their pa‐
              rameters and types. A function of type 'unknown' indicates a function that does not return a  val‐
              ue.  Note  that  not  all  function/parameter  types may be resolved (these are also shown by 'un‐
              known'). This features is very memory-intensive and thus may not work properly  with  <u>--use-server</u>
              if  the  target server imposes an rlimit on process memory (i.e. through the <u>~stap-server/.system‐</u>
              <u>tap/rc</u> configuration file, see <u><a href="../man8/stap-server.8.html">stap-server</a></u>(8)).

       <b>--remote</b> <u>URL</u>
              Set the execution target to the given host.  This option may be repeated to target multiple execu‐
              tion targets.  Passes 1-4 are completed locally as normal to build the script,  and  then  pass  5
              will copy the module to the target and run it.  Acceptable URL forms include:

              <b>[USER@]HOSTNAME</b>, <b>ssh://[USER@]HOSTNAME</b>
                     This mode uses ssh, optionally using a username not matching your own. If a custom ssh_con‐
                     fig file is in use, add <b>SendEnv</b> <b>LANG</b> to retain internationalization functionality.

              <b>libvirt://DOMAIN</b>, <b>libvirt://DOMAIN/LIBVIRT_URI</b>
                     This  mode  uses <u>stapvirt</u> to execute the script on a domain managed by libvirt. Optionally,
                     LIBVIRT_URI may be specified to connect to a specific driver and/or a remote host. For  ex‐
                     ample, to connect to the local privileged QEMU driver, use:

                     --remote libvirt://MyDomain/qemu:///system

                     See  the page at &lt;<a href="http://libvirt.org/uri.html">http://libvirt.org/uri.html</a>&gt; for supported URIs. Also see <u><a href="../man1/stapvirt.1.html">stapvirt</a></u>(1) for
                     more information on how to prepare the domain for stap probing.

              <b>unix:PATH</b>
                     This mode connects to a UNIX socket. This can be used with a QEMU  virtio-serial  port  for
                     executing scripts inside a running virtual machine.

              <b>direct://</b>
                     Special loopback mode to run on the local host.

       <b>--remote-prefix</b>
              Prefix  each line of remote output with "N: ", where N is the index of the remote execution target
              from which the given line originated.

       <b>--download-debuginfo</b><u>[=OPTION]</u>
              Enable, disable or set a timeout for the automatic debuginfo downloading feature offered  by  abrt
              as specified by OPTION, where OPTION is one of the following:

              <b>yes</b>    enable  automatic downloading of debuginfo with no timeout. This is the same as not provid‐
                     ing an OPTION value to <u>--download-debuginfo</u>

              <b>no</b>     explicitly disable automatic downloading of debuginfo. This is the same as  not  using  the
                     option at all.

              <b>ask</b>    show abrt output, and ask before continuing download. No timeout will be set.

              <b>&lt;timeout&gt;</b>
                     specify  a  timeout  as  a positive number to stop the download if it is taking longer than
                     &lt;timeout&gt; seconds.

       <b>--rlimit-as</b><u>=NUM</u>
              Specify the maximum size of the process's virtual memory (address space), in bytes.

       <b>--rlimit-cpu</b><u>=NUM</u>
              Specify the CPU time limit, in seconds.

       <b>--rlimit-nproc</b><u>=NUM</u>
              Specify the maximum number of processes that can be created.

       <b>--rlimit-stack</b><u>=NUM</u>
              Specify the maximum size of the process stack, in bytes.

       <b>--rlimit-fsize</b><u>=NUM</u>
              Specify the maximum size of files that the process may create, in bytes.

       <b>--sysroot</b><u>=DIR</u>
              Specify sysroot directory where target files (executables, libraries, etc.)  are located.  With <u>-r</u>
              <u>RELEASE</u>, the sysroot will be searched for the appropriate kernel build directory.  With  <u>-r</u>  <u>/DIR</u>,
              however, the sysroot will not be used to find the kernel build.

       <b>--sysenv</b><u>=VAR=VALUE</u>
              Provide an alternate value for an environment variable where the value on a remote system differs.
              Path  variables  (e.g. PATH, LD_LIBRARY_PATH) are assumed to be relative to the directory provided
              by <u>--sysroot</u>, if provided.

       <b>--suppress-time-limits</b>
              Disable -DSTP_OVERLOAD related options as well as -DMAXACTION and -DMAXTRYLOCK.  This  option  re‐
              quires guru mode.

       <b>--runtime</b><u>=MODE</u>
              Set  the  pass-5  runtime  mode.  Valid options are <u>kernel</u> (default), <u>dyninst</u> and <u>bpf</u>.  See <b>ALTER‐</b>
              <b>NATE</b> <b>RUNTIMES</b> below for more information.

       <b>--dyninst</b>
              Shorthand for <u>--runtime=dyninst</u>.

       <b>--bpf</b>  Shorthand for <u>--runtime=bpf</u>.

       <b>--save-uprobes</b>
              On machines that require SystemTap to build its own uprobes module (kernels prior to version 3.5),
              this option instructs SystemTap to also save a copy of the module in the current directory (creat‐
              ing a new "uprobes" directory first).

       <b>--target-namespaces</b><u>=PID</u>
              Allow for a set of target namespaces to be set based on the namespaces the given PID is  in.  This
              is for namespace-aware tapset functions. If the target namespaces was not set, the target defaults
              to the stap process' namespaces.

       <b>--monitor</b><u>=INTERVAL</u>
              Enables  an  interface to display status information about the module(uptime, module name, invoker
              uid, memory sizes, global variables, list of probes with their statistics). An  optional  argument
              INTERVAL  can  be supplied to set the refresh rate in seconds of the status window. The module can
              also be controlled by a list of commands using the following keys:

              <b>c</b>      Resets all global variables to their initial values or zeroes them if they did not have  an
                     initial value.

              <b>s</b>      Rotates the attribute used to sort the list of probes.

              <b>t</b>      Brings up a prompt to allow toggling(on/off) of probes by index. Probe points are still af‐
                     fected by their conditions.

              <b>r</b>      Resumes the script by toggling on all probes.

              <b>p</b>      Pauses the script by toggling off all probes.

              <b>x</b>      Hides/shows the status window. This allows for more output to be seen.

              <b>navigation-keys</b>
                     The navigation keys can be used to scroll up and down the windows.

              <b>Tab</b>    Toggle scrolling between status and output windows.

       <b>--example</b>
              This  option is used to run example scripts without having to enter the entire path to the script.
              Example scripts can be found in the directory specified in the <u><a href="../man7/stappaths.7.html">stappaths</a></u>(7) manual page.

       <b>--no-global-var-display</b>
              This option is used to disable the automatic logging of unused global variables at the  end  of  a
              stap session.

       <b>--language-server</b>
              Language server mode. Start a language server which will communicate via stdio. The language serv‐
              er will respect stap verbosity.

       <b>--build-as</b>
              Execute  passes  1-4 under specified user to increase safety.  This approach may have limitations.
              Unprivileged users might not have access to kallsyms or /proc.   At  the  RPM  install  time,  the
              stapunpriv user is created, so stap can be invoked with --build-as=stapunpriv.

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Any  additional  arguments on the command line are passed to the script parser for substitution.  See be‐
       low.

</pre><h4><b>SCRIPT</b> <b>LANGUAGE</b></h4><pre>
       The systemtap script language resembles <u>awk</u> and <u>C</u>.  There are two main outermost constructs:  probes  and
       functions.  Within these, statements and expressions use C-like operator syntax and precedence.

   <b>GENERAL</b> <b>SYNTAX</b>
       Whitespace is ignored.  Three forms of comments are supported:
              <b>#</b> ... shell style, to the end of line, except for $# and @#
              <b>//</b> ... C++ style, to the end of line
              <b>/*</b> ... C style ... <b>*/</b>
       Literals  are  either  strings  enclosed  in double-quotes (passing through the usual C escape codes with
       backslashes, and with adjacent string literals glued together, also as in C), or  integers  (in  decimal,
       hexadecimal,  or octal, using the same notation as in C).  All strings are limited in length to some rea‐
       sonable value (a few hundred bytes).  Integers are 64-bit signed quantities, although the parser also ac‐
       cepts (and wraps around) values above positive 2**63.

       In addition, script arguments given at the end of the command line may be inserted.  Use <b>$1</b> <b>...</b> <b>$&lt;NN&gt;</b> for
       insertion unquoted, <b>@1</b> <b>...</b> <b>@&lt;NN&gt;</b> for insertion as a string literal.  The number of arguments may  be  ac‐
       cessed  through  <b>$#</b> (as an unquoted number) or through <b>@#</b> (as a quoted number).  These may be used at any
       place a token may begin, including within the preprocessing stage.  Reference to an argument  number  be‐
       yond what was actually given is an error.

   <b>PREPROCESSING</b>
       A simple conditional preprocessing stage is run as a part of parsing.  The general form is similar to the
       cond <b>?</b> exp1 <b>:</b> exp2 ternary operator:

              <b>%(</b> CONDITION <b>%?</b> TRUE-TOKENS <b>%)</b>
              <b>%(</b> CONDITION <b>%?</b> TRUE-TOKENS <b>%:</b> FALSE-TOKENS <b>%)</b>

       The CONDITION is either an expression whose format is determined by its first keyword, or a string liter‐
       als  comparison  or a numeric literals comparison.  It can be also composed of many alternatives and con‐
       junctions of CONDITIONs (meant as in previous sentence) using || and &amp;&amp; respectively.  However, parenthe‐
       ses are not supported yet, so remembering that conjunction takes precedence over  alternative  is  impor‐
       tant.

       If  the  first  part  is the identifier <b>kernel_vr</b> or <b>kernel_v</b> to refer to the kernel version number, with
       ("2.6.13-1.322FC3smp") or without ("2.6.13") the release code suffix, then the second part is one of  the
       six standard numeric comparison operators <b>&lt;</b>, <b>&lt;=</b>, <b>==</b>, <b>!=</b>, <b>&gt;</b>, and <b>&gt;=</b>, and the third part is a string liter‐
       al that contains an RPM-style version-release value.  The condition is deemed satisfied if the version of
       the  target kernel (as optionally overridden by the <b>-r</b> option) compares to the given version string.  The
       comparison is performed by the glibc function <b>strverscmp</b>.  As a special case, if the operator is for sim‐
       ple equality (<b>==</b>), or inequality (<b>!=</b>), and the third part contains any wildcard characters (<b>*</b> or <b>?</b> or <b>[</b>),
       then the expression is treated as a wildcard (mis)match as evaluated by <b>fnmatch</b>.

       If, on the other hand, the first part is the identifier <b>arch</b> to refer to the processor  architecture  (as
       named  by the kernel build system ARCH/SUBARCH), then the second part is one of the two string comparison
       operators <b>==</b> or <b>!=</b>, and the third part is a string literal for matching it.  This comparison is  a  wild‐
       card (mis)match.

       Similarly,  if  the  first part is an identifier like <b>CONFIG_something</b> to refer to a kernel configuration
       option, then the second part is <b>==</b> or <b>!=</b>, and the third part is a string literal for matching  the  value
       (commonly  "y"  or  "m").  Nonexistent or unset kernel configuration options are represented by the empty
       string.  This comparison is also a wildcard (mis)match.

       If the first part is the identifier <b>systemtap_v</b>, the test refers to the systemtap compatibility  version,
       which may be overridden for old scripts with the <b>--compatible</b> flag.  The comparison operator is as is for
       <b>kernel_v</b> and the right operand is a version string.  See also the DEPRECATION section below.

       If  the first part is the identifier <b>systemtap_privilege</b>, the test refers to the privilege level that the
       systemtap script is compiled with. Here the second part is <b>==</b> or <b>!=</b>, and the third part is a string  lit‐
       eral, either "stapusr" or "stapsys" or "stapdev".

       If  the  first  part  is the identifier <b>guru_mode</b>, the test refers to if the systemtap script is compiled
       with guru_mode. Here the second part is <b>==</b> or <b>!=</b>, and the third part is a number, either 1 or 0.

       If the first part is the identifier <b>runtime</b>, the test refers to the systemtap runtime  mode.  See  <b>ALTER‐</b>
       <b>NATE</b> <b>RUNTIMES</b>  below for more information on runtimes.  The second part is one of the two string compari‐
       son operators <b>==</b> or <b>!=</b>, and the third part is a string literal for matching it.   This  comparison  is  a
       wildcard (mis)match.

       Otherwise, the CONDITION is expected to be a comparison between two string literals or two numeric liter‐
       als.  In this case, the arguments are the only variables usable.

       The  TRUE-TOKENS  and FALSE-TOKENS are zero or more general parser tokens (possibly including nested pre‐
       processor conditionals), and are passed into the input stream if the condition is true or false.  For ex‐
       ample, the following code induces a parse error unless the target kernel version is newer than 2.6.5:

              %( kernel_v &lt;= "2.6.5" %? **ERROR** %) # invalid token sequence

       The following code might adapt to hypothetical kernel version drift:

              probe kernel.function (
                %( kernel_v &lt;= "2.6.12" %? "__mm_do_fault" %:
                   %( kernel_vr == "2.6.13*smp" %? "do_page_fault" %:
                      UNSUPPORTED %) %)
              ) { /* ... */ }

              %( arch == "ia64" %?
                 probe syscall.vliw = kernel.function("vliw_widget") {}
              %)

   <b>PREPROCESSOR</b> <b>MACROS</b>
       The preprocessor also supports a simple macro facility, run as a separate pass before conditional prepro‐
       cessing.

       Macros are defined using the following construct:

              @define NAME %( BODY %)
              @define NAME(PARAM_1, PARAM_2, ...) %( BODY %)

       Macros, and parameters inside a macro body, are both invoked by prefixing the macro name with an  @  sym‐
       bol:

              @define foo %( x %)
              @define add(a,b) %( ((@a)+(@b)) %)

                 @foo = @add(2,2)

       Macro expansion is currently performed in a separate pass before conditional compilation. Therefore, both
       TRUE-  and  FALSE-tokens in conditional expressions will be macroexpanded regardless of how the condition
       is evaluated. This can sometimes lead to errors:

              // The following results in a conflict:
              %( CONFIG_UPROBE == "y" %?
                  @define foo %( process.syscall %)
              %:
                  @define foo %( **ERROR** %)
              %)

              // The following works properly as expected:
              @define foo %(
                %( CONFIG_UPROBE == "y" %? process.syscall %: **ERROR** %)
              %)

       The first example is incorrect because both @defines are evaluated in a pass prior to the conditional be‐
       ing evaluated.

       Normally, a macro definition is local to the file it occurs in. Thus, defining a macro in a  tapset  does
       not  make  it  available to the user of the tapset. Publically available library macros can be defined by
       including .stpm files on the tapset search path. These files may only contain @define  constructs,  which
       become  visible  across  all tapsets and user scripts. Optionally, within the .stpm files, a public macro
       definition can be surrounded by a preprocessor conditional as described above.

   <b>CONSTANTS</b>
       Tapsets or guru-mode user scripts can access header file constant tokens, typically macros, using  built-
       in @const() operator.  The respective header file inclusion is possible either via the tapset library, or
       using a top-level guru mode embedded-C construct.  This results in appropriate embedded C pragma comments
       setting.

              @const("STP_SKIP_BADVARS")

   <b>VARIABLES</b>
       Identifiers for variables and functions are an alphanumeric sequence, and may include <b>_</b> and <b>$</b> characters.
       They  may not start with a plain digit, as in C.  Each variable is by default local to the probe or func‐
       tion statement block within which it is mentioned, and therefore its scope and lifetime is limited  to  a
       particular probe or function invocation.

       Scalar variables are implicitly typed as either string or integer.  Associative arrays also have a string
       or  integer value, and a tuple of strings and/or integers serving as a key.  Here are a few basic expres‐
       sions.

              var1 = 5
              var2 = "bar"
              array1 [pid()] = "name"     # single numeric key
              array2 ["foo",4,i++] += 5   # vector of string/num/num keys
              if (["hello",5,4] in array2) println ("yes")  # membership test

       The translator performs <u>type</u> <u>inference</u> on all identifiers, including array indexes and  function  parame‐
       ters.  Inconsistent type-related use of identifiers signals an error.

       Variables  may  be  declared global, so that they are shared amongst all probes and functions and live as
       long as the entire systemtap session.  There is one namespace for all  global  variables,  regardless  of
       which script file they are found within.  Concurrent access to global variables is automatically protect‐
       ed with locks, see the <b>SAFETY</b> <b>AND</b> <b>SECURITY</b> section for more details.  A global declaration may be written
       at the outermost level anywhere, not within a block of code.  Global variables which are written but nev‐
       er read will be displayed automatically at session shutdown.  The translator will infer for each its val‐
       ue  type,  and  if  it is used as an array, its key types.  Optionally, scalar globals may be initialized
       with a string or number literal.  The following declaration marks variables as global.

              <b>global</b> var1<b>,</b> var2<b>,</b> var3=4

       Global variables can also be set as module options. One can do this by either using the -G option, or the
       module must first be compiled using stap -p4.  Global variables can then be set on the command line  when
       calling staprun on the module generated by stap -p4. See <u><a href="../man8/staprun.8.html">staprun</a></u>(8) for more information.

       The  scope of a global variable may be limited to a tapset or user script file using private keyword. The
       global keyword is optional when defining a private global variable. Following declaration marks var1  and
       var2 private globals.

              <b>private</b> global <b>var1=2</b>
              <b>private</b> var2

       Arrays  are  limited in size by the MAXMAPENTRIES variable -- see the <b>SAFETY</b> <b>AND</b> <b>SECURITY</b> section for de‐
       tails.  Optionally, global arrays may be declared with a maximum size in brackets,  overriding  MAXMAPEN‐
       TRIES  for  that  array  only.   Note that this doesn't indicate the type of keys for the array, just the
       size.

              <b>global</b> tiny_array[10]<b>,</b> normal_array<b>,</b> big_array[50000]

       Arrays may be configured for wrapping using the '%' suffix.  This causes older elements to be overwritten
       if more elements are inserted than the array can hold. This works for  both  associative  and  statistics
       typed arrays.

              <b>global</b> wrapped_array1%[10]<b>,</b> wrapped_array2%

       Many  types  of  probe points provide context variables, which are run-time values, safely extracted from
       the kernel or userspace program being probed.  These are prefixed with  the  <b>$</b>  character.   The  CONTEXT
       VARIABLES  section in <u><a href="../man3stap/stapprobes.3stap.html">stapprobes</a></u>(3stap) lists what is available for each type of probe point.  These con‐
       text variables become normal string or numeric scalars once they are stored in normal  script  variables.
       See  the TYPECASTING section below on how to to turn them back into typed pointers for further processing
       as context variables.  There is some automation to help!

   <b>STATEMENTS</b>
       Statements enable procedural control flow.  They may occur within functions and probe handlers.  The  to‐
       tal number of statements executed in response to any single probe event is limited to some number defined
       by the MAXACTION macro in the translated C code, and is in the neighbourhood of 1000.

       EXP    Execute the string- or integer-valued expression and throw away the value.

       <b>{</b> STMT1 STMT2 ... <b>}</b>
              Execute  each statement in sequence in this block.  Note that separators or terminators are gener‐
              ally not necessary between statements.

       <b>;</b>      Null statement, do nothing.  It is useful as an optional separator between statements  to  improve
              syntax-error detection and to handle certain grammar ambiguities.

       <b>if</b> (EXP) STMT1 [ <b>else</b> STMT2 ]
              Compare integer-valued EXP to zero.  Execute the first (non-zero) or second STMT (zero).

       <b>while</b> (EXP) STMT
              While integer-valued EXP evaluates to non-zero, execute STMT.

       <b>for</b> (EXP1; EXP2; EXP3) STMT
              Execute  EXP1 as initialization.  While EXP2 is non-zero, execute STMT, then the iteration expres‐
              sion EXP3.

       <b>foreach</b> (VAR <b>in</b> ARRAY [ <b>limit</b> EXP ]) STMT
              Loop over each element of the named global array, assigning current key to VAR.  The array may not
              be modified within the statement.  By adding a single <b>+</b> or <b>-</b> operator after the VAR or  the  ARRAY
              identifier, the iteration will proceed in a sorted order, by ascending or descending index or val‐
              ue.   If  the array contains statistics aggregates, adding the desired <b>@operator</b> between the ARRAY
              identifier and the <b>+</b> or <b>-</b> will specify the sorting aggregate function.  See the STATISTICS section
              below for the ones available.  Default is <b>@count</b>.  Using the optional  <b>limit</b>  keyword  limits  the
              number of loop iterations to EXP times.  EXP is evaluated once at the beginning of the loop.

       <b>foreach</b> ([VAR1, VAR2, ...] <b>in</b> ARRAY [ <b>limit</b> EXP ]) STMT
              Same  as above, used when the array is indexed with a tuple of keys.  A sorting suffix may be used
              on at most one VAR or ARRAY identifier.

       <b>foreach</b> ([VAR1, VAR2, ...] <b>in</b> ARRAY [INDEX1, INDEX2, ...] [ <b>limit</b> EXP ]) STMT
              Same as above, where iterations are limited to elements in the array where the keys match the  in‐
              dex  values specified. The symbol * can be used to specify an index and will be treated as a wild‐
              card.

       <b>foreach</b> (VAR0 = VAR <b>in</b> ARRAY [ <b>limit</b> EXP ]) STMT
              This variant of foreach saves current value into VAR0 on each iteration, so it is the same as  AR‐
              RAY[VAR].  This also works with a tuple of keys.  Sorting suffixes on VAR0 have the same effect as
              on ARRAY.

       <b>foreach</b> (VAR0 = VAR <b>in</b> ARRAY [INDEX1, INDEX2, ...] [ <b>limit</b> EXP ]) STMT
              Same  as above, where iterations are limited to elements in the array where the keys match the in‐
              dex values specified. The symbol * can be used to specify an index and will be treated as a  wild‐
              card.

       <b>break</b>, <b>continue</b>
              Exit or iterate the innermost nesting loop (<b>while</b> or <b>for</b> or <b>foreach</b>) statement.

       <b>return</b> EXP
              Return  EXP  value from enclosing function.  If the function's value is not taken anywhere, then a
              return statement is not needed, and the function will have a special "unknown" type with no return
              value.

       <b>next</b>   Return now from enclosing probe handler.  This is especially useful in probe  aliases  that  apply
              event  filtering predicates. When used in functions, the execution will be immediately transferred
              to the next overloaded function.

       <b>try</b> { STMT1 } <b>catch</b> { STMT2 }
              Run the statements in the first block.  Upon any run-time errors, abort STMT1 and start  executing
              STMT2.  Any errors in STMT2 will propagate to outer try/catch blocks, if any.

       <b>try</b> { STMT1 } <b>catch</b>(VAR) { STMT2 }
              Same as above, plus assign the error message to the string scalar variable VAR.

       <b>delete</b> ARRAY[INDEX1, INDEX2, ...]
              Remove  from  ARRAY  the element specified by the index tuple.  If the index tuple contains a * in
              place of an index, the * is treated as a wildcard and all elements with keys that match the  index
              tuple  will  be  removed from ARRAY.  The value will no longer be available, and subsequent itera‐
              tions will not report the element.  It is not an error to delete an element that does not exist.

       <b>delete</b> ARRAY
              Remove all elements from ARRAY.

       <b>delete</b> SCALAR
              Removes the value of SCALAR.  Integers and strings are cleared to 0  and  ""  respectively,  while
              statistics are reset to the initial empty state.

   <b>EXPRESSIONS</b>
       Systemtap  supports a number of operators that have the same general syntax, semantics, and precedence as
       in C and awk.  Arithmetic is performed as per typical C rules for signed integers.  Division by  zero  or
       overflow is detected and results in an error.

       binary numeric operators
              <b>*</b> <b>/</b> <b>%</b> <b>+</b> <b>-</b> <b>&gt;&gt;</b> <b>&lt;&lt;</b> <b>&amp;</b> <b>^</b> <b>|</b> <b>&amp;&amp;</b> <b>||</b>

       binary string operators
              <b>.</b>  (string concatenation)

       numeric assignment operators
              <b>=</b> <b>*=</b> <b>/=</b> <b>%=</b> <b>+=</b> <b>-=</b> <b>&gt;&gt;=</b> <b>&lt;&lt;=</b> <b>&amp;=</b> <b>^=</b> <b>|=</b>

       string assignment operators
              <b>=</b> <b>.=</b>

       unary numeric operators
              <b>+</b> <b>-</b> <b>!</b> <b>~</b> <b>++</b> <b>--</b>

       binary numeric, string comparison or regex matching operators
              <b>&lt;</b> <b>&gt;</b> <b>&lt;=</b> <b>&gt;=</b> <b>==</b> <b>!=</b> <b>=~</b> <b>!~</b>

       ternary operator
              cond <b>?</b> exp1 <b>:</b> exp2

       grouping operator
              <b>(</b> exp <b>)</b>

       function call
              fn <b>(</b>[ arg1, arg2, ... ]<b>)</b>

       array membership check
              exp <b>in</b> array
              <b>[</b>exp1<b>,</b> exp2<b>,</b> <b>...</b> <b>]</b> <b>in</b> array
              <b>[</b>*<b>,</b> *<b>,</b> <b>...</b> <b>]</b> <b>in</b> array

   <b>REGULAR</b> <b>EXPRESSION</b> <b>MATCHING</b>
       The scripting language supports regular expression matching.  The basic syntax is as follows:

              <b>exp</b> =~ <b>regex</b>
              <b>exp</b> !~ <b>regex</b>

       (The first operand must be an expression evaluating to a string; the second operand must be a string lit‐
       eral containing a syntactically valid regular expression.)

       The  regular  expression  syntax  supports  POSIX  Extended  Regular Expression features as documented in
       <u><a href="../man1/grep.1.html">grep</a></u>(1) except for subexpression reuse ("\1") functionality.

       After a successful match, the contents of the matched string and subexpressions can  be  extracted  using
       the matched() and ngroups() tapset functions as follows:

              if ("an example string" =~ "str(ing)") {
                <a href="../man0/matched.0.html">matched</a>(0) // -&gt; returns "string", the matched substring
                <a href="../man1/matched.1.html">matched</a>(1) // -&gt; returns "ing", the 1st matched subexpression
                ngroups()  // -&gt; returns 2, the number of matched groups
              }

   <b>PROBES</b>
       The  main construct in the scripting language identifies probes.  Probes associate abstract events with a
       statement block ("probe handler") that is to be executed when any of those  events  occur.   The  general
       syntax is as follows:

              <b>probe</b> PROBEPOINT [<b>,</b> PROBEPOINT] <b>{</b> [STMT ...] <b>}</b>
              <b>probe</b> PROBEPOINT [<b>,</b> PROBEPOINT] <b>if</b> <b>(</b>CONDITION<b>)</b> <b>{</b> [STMT ...] <b>}</b>

       Events  are  specified  in  a special syntax called "probe points".  There are several varieties of probe
       points defined by the translator, and tapset scripts may define further ones using aliases.  Probe points
       may be wildcarded, grouped, or listed in preference sequences, or declared  optional.   More  details  on
       probe point syntax and semantics are listed on the <u><a href="../man3stap/stapprobes.3stap.html">stapprobes</a></u>(3stap) manual page.

       The  probe handler is interpreted relative to the context of each event.  For events associated with ker‐
       nel code, this context may include <u>variables</u> defined in the <u>source</u> <u>code</u> at  that  spot.   These  "context
       variables"  are  presented to the script as variables whose names are prefixed with "$".  They may be ac‐
       cessed only if the kernel's compiler preserved them despite optimization.  This is  the  same  constraint
       that  a  debugger  user  faces  when working with optimized code.  In addition, the objects must exist in
       paged-in memory at the moment of the systemtap probe handler's  execution,  because  systemtap  must  not
       cause  (suppresses)  any  additional  paging.   Some probe types have very little context.  See the <u>stap‐</u>
       <u><a href="../man3stap/probes.3stap.html">probes</a></u>(3stap) man pages to see the kinds of context variables available at each kind of probe point.   As
       of  systemtap version 4.3, functions called from the handlers of some probe point types may also refer to
       context variables.  These are treated as if a clone of that function was inlined into the  calling  probe
       handler and $variables evaluated in its context.

       Probes  may be decorated with an <u>arming</u> <u>condition</u>, consisting of a simple boolean expression on read-only
       global script variables.  While disarmed (inactive, condition evaluates to false), some probe  types  re‐
       duce  or  eliminate their run-time overheads.  When an arming condition evaluates to true, probes will be
       <u>soon</u> re-armed, and their probe handlers will start getting called as the events fire.  (Some  events  may
       be  lost  during  the  arming  interval.  If this is unacceptable, do not use arming conditions for those
       probes.)  Example of the syntax:

              probe timer.us(TIMER) if (enabled) {
              }

       New probe points may be defined using "aliases".  Probe point aliases look similar to probe  definitions,
       but  instead of activating a probe at the given point, it just defines a new probe point name as an alias
       to an existing one. There are two types of alias, i.e. the prologue style and the  epilogue  style  which
       are identified by "=" and "+=" respectively.

       For  prologue  style alias, the statement block that follows an alias definition is implicitly added as a
       prologue to any probe that refers to the alias. While for the epilogue style alias, the  statement  block
       that  follows  an  alias  definition  is  implicitly added as an epilogue to any probe that refers to the
       alias.  For example:

              probe syscall.read = kernel.function("sys_read") {
                fildes = $fd
                if (execname() == "init") next  # skip rest of probe
              }

       defines a new probe point <u>syscall.read</u>, which expands  to  <u>kernel.function("sys_read")</u>,  with  the  given
       statement  as  a  prologue, which is useful to predefine some variables for the alias user and/or to skip
       probe processing entirely based on some conditions.  And

              probe syscall.read += kernel.function("sys_read") {
                if (tracethis) println ($fd)
              }

       defines a new probe point with the given statement as an epilogue, which is useful to take actions  based
       upon  variables set or left over by the the alias user.  Please note that in each case, the statements in
       the alias handler block are treated ordinarily, so that variables assigned there constitute mere initial‐
       ization, not a macro substitution.

       Aliases can also be defined to include both a prologue and an epilogue.

              probe syscall.read = kernel.function("sys_read") {
                fildes = $fd
                if (execname() == "init") next
              },{
                if (tracethis) println ($fd)
              }

       An alias is used just like a built-in probe type.

              probe syscall.read {
                printf("reading fd=%d\n", fildes)
                if (fildes &gt; 10) tracethis = 1
              }

       Probes with an alias can make use of the @probewrite predicate. This check is used to  detect  whether  a
       script variable or target variable has been written to in the probe handler body.

       @probewrite(var)
              expands to 1 iff var has been written to in the probe handler body, otherwise it expands to 0.

       In the following example, @probewrite(var) expands to 1 because var has been written to in the probe han‐
       dler body and consequently, the conditional statement will run.

              probe foo = begin { var = 0 }, { if (@probewrite(var)) println(var) }

              probe foo {
                var = 1
              }

   <b>FUNCTIONS</b>
       Systemtap  scripts may define subroutines to factor out common work.  Functions take any number of scalar
       (integer or string) arguments, and must return a single scalar (integer or string).  An example  function
       declaration looks like this:

              function thisfn (arg1, arg2) {
                 return arg1 + arg2
              }

       Note the general absence of type declarations, which are instead inferred by the translator.  However, if
       desired, a function definition may include explicit type declarations for its return value and/or its ar‐
       guments.  This is especially helpful for embedded-C functions.  In the following example, the type infer‐
       ence engine need only infer type type of arg2 (a string).

              function thatfn:string (arg1:long, arg2) {
                 return sprint(arg1) . arg2
              }

       Functions  may call others or themselves recursively, up to a fixed nesting limit.  This limit is defined
       by the MAXNESTING macro in the translated C code and is in the neighbourhood of 10.

       Functions may be marked private using the private keyword to limit their scope  to  the  tapset  or  user
       script file they are defined in. An example definition of a private function follows:

              private function three:long () { return 3 }

       Functions  terminating without reaching an explicit return statement will return an implicit 0 or "", de‐
       termined by type inference.

       Functions may be overloaded during both runtime and compile time.

       Runtime overloading allows the executed function to be selected while the module is running based on run‐
       time conditions and is achieved using the "next" statement in script functions and  STAP_NEXT  macro  for
       embedded-C functions. For example,

              function f() { if (condition) next; print("first function") }
              function f() %{ STAP_NEXT; print("second function") %}
              function f() { print("third function") }

       During  a  functioncall  f(), the execution will transfer to the third function if condition evaluates to
       true and print "third function". Note that the second function is unconditionally nexted.

       Parameter overloading allows the function to be executed to be selected at compile time based on the num‐
       ber of arguments provided to the functioncall. For example,

              function g() { print("first function") }
              function g(x) { print("second function") }
              g() -&gt; "first function"
              <a href="../man1/g.1.html">g</a>(1) -&gt; "second function"

       Note that runtime overloading does not occur in the above example, as exactly one function  will  be  re‐
       solved for the functioncall. The use of a next statement inside a function while no more overloads remain
       will  trigger a runtime exception Runtime overloading will only occur if the functions have the same ari‐
       ty, functions with the same name but different number of parameters are completely unrelated.

       Execution order is determined by a priority value which may be specified.  If  no  explicit  priority  is
       specified,  user  script  functions are given a higher priority than library functions. User script func‐
       tions and library functions are assigned a default priority value of 0  and  1  respectively.   Functions
       with the same priority are executed in declaration order. For example,

              function f():3 { if (condition) next; print("first function") }
              function f():1 { if (condition) next; print("second function") }
              function f():2 { print("third function") }

       Since  the  second function has highest priority, it is executed first.  The first function is never exe‐
       cuted as there no "next" statements in the third function to transfer execution.

   <b>PRINTING</b>
       There are a set of function names that are specially treated by the translator.  They format  values  for
       printing  to  the  standard systemtap output stream in a more convenient way (note that data generated in
       the kernel module need to get transferred to user-space in order to get printed).

         The <u>sprint*</u> variants return the formatted string instead of printing it.

       <b>print</b>, <b>sprint</b>
              Print one or more values of any type, concatenated directly together.

       <b>println</b>, <b>sprintln</b>
              Print values like <u>print</u> and <u>sprint</u>, but also append a newline.

       <b>printd</b>, <b>sprintd</b>
              Take a string delimiter and two or more values of any type, and print the values with  the  delim‐
              iter interposed.  The delimiter must be a literal string constant.

       <b>printdln</b>, <b>sprintdln</b>
              Print values with a delimiter like <u>printd</u> and <u>sprintd</u>, but also append a newline.

       <b>printf</b>, <b>sprintf</b>
              Take  a  formatting string and a number of values of corresponding types, and print them all.  The
              format must be a literal string constant.

       The <u>printf</u> formatting directives similar to those of C, except that they are fully  type-checked  by  the
       translator:

              %b     Writes a binary blob of the value given, instead of ASCII text.  The width specifier deter‐
                     mines  the number of bytes to write; valid specifiers are %b %1b %2b %4b %8b.  Default (%b)
                     is 8 bytes.

              %c     Character.

              %d,%i  Signed decimal.

              %m     Safely reads kernel (without #) or user (with #) memory at the given address,  outputs  its
                     content.  The optional precision specifier (not field width) determines the number of bytes
                     to  read  -  default is 1 byte.  %10.4m prints 4 bytes of the memory in a 10-character-wide
                     field.  Note, on some architectures user memory can still be read without #.

              %M     Same as %m, but outputs in hexadecimal.  The minimal size of output is double the  optional
                     precision specifier - default is 1 byte (2 hex chars).  %10.4M prints 4 bytes of the memory
                     as  8  hexadecimal characters in a 10-character-wide field.   %.*M hex-dumps a given number
                     of bytes from a given buffer.

              %o     Unsigned octal.

              %p     Unsigned pointer address.

              %s     String.

              %u     Unsigned decimal.

              %x     Unsigned hex value, in all lower-case.

              %X     Unsigned hex value, in all upper-case.

              %%     Writes a %.

       The <u>#</u> flag selects the alternate forms.  For octal, this prefixes a 0.  For hex, this prefixes 0x or  0X,
       depending  on  case.   For characters, this escapes non-printing values with either C-like escapes or raw
       octal.  In the case of %#m/%#M, this safely accesses user space memory rather than kernel space memory.

       Examples:

              a = "alice", b = "bob", p = 0x1234abcd, i = 123, j = -1, id[a] = 1234, id[b] = 4567
              print("hello")
                   Prints: hello
              println(b)
                   Prints: bob\n
              println(a . " is " . <a href="../man16/sprint.16.html">sprint</a>(16))
                   Prints: alice is 16
              foreach (name in id)  printdln("|", strlen(name), name, id[name])
                   Prints: 5|alice|1234\n3|bob|4567
              printf("%c is %s; %x or %X or %p; %d or %u\n",97,a,p,p,p,j,j)
                   Prints: a is alice; 1234abcd or 1234ABCD or 0x1234abcd; -1 or 18446744073709551615\n
              printf("2 bytes of kernel buffer at address %p: %2m", p, p)
                   Prints: 2 byte of kernel buffer at address 0x1234abcd: &lt;binary data&gt;
              printf("%4b", p)
                   Prints (these values as binary data): 0x1234abcd
              printf("%#o %#x %#X\n", 1, 2, 3)
                   Prints: 01 0x2 0X3
              printf("%#c %#c %#c\n", 0, 9, 42)
                   Prints: \000 \t *

   <b>STATISTICS</b>
       It is often desirable to collect statistics in a way that avoids the penalties  of  repeatedly  exclusive
       locking  the  global  variables  those numbers are being put into.  Systemtap provides a solution using a
       special operator to accumulate values, and several pseudo-functions to  extract  the  statistical  aggre‐
       gates.

       The  aggregation  operator is <u>&lt;&lt;&lt;</u>, and resembles an assignment, or a C++ output-streaming operation.  The
       left operand specifies a scalar or array-index lvalue, which must be declared global.  The right  operand
       is  a  numeric expression.  The meaning is intuitive: add the given number to the pile of numbers to com‐
       pute statistics of.  (The specific list of statistics to gather is given separately,  by  the  extraction
       functions.)

              foo &lt;&lt;&lt; 1
              stats[pid()] &lt;&lt;&lt; memsize

       The extraction functions are also special.  For each appearance of a distinct extraction function operat‐
       ing  on  a given identifier, the translator arranges to compute a set of statistics that satisfy it.  The
       statistics system is thereby "on-demand".  Each execution of an extraction function causes  the  aggrega‐
       tion to be computed for that moment across all processors.

       Here  is  the set of extractor functions.  The first argument of each is the same style of lvalue used on
       the left hand side of the accumulate operation.   The  <u>@count(v)</u>,  <u>@sum(v)</u>,  <u>@min(v)</u>,  <u>@max(v)</u>,  <u>@avg(v)</u>,
       @variance(v[,  b])  extractor  functions compute the number/total/minimum/maximum/average/variance of all
       accumulated values.  The resulting values are all simple integers.  Arrays containing aggregates  may  be
       sorted and iterated.  See the <b>foreach</b> construct above.

       Variance  uses  Welford's online algorithm.  The calculations are based on integer arithmetic, and so may
       suffer from low precision and overflow.  To improve this, @variance(v[, b]) accepts an optional parameter
       b, the bit-shift, ranging from 0 (default) to 62, for internal scaling.  Only one value of bit-shift  may
       be used with given global variable.  A larger bitshift value increases precision, but increases the like‐
       lihood of overflow.

              $ stap -e \
              &gt; 'global x probe oneshot { for(i=1;i&lt;=5;i++) x&lt;&lt;&lt;i println(@variance(x)) }'
              12
              $ stap -e \
              &gt; 'global x probe oneshot { for(i=1;i&lt;=5;i++) x&lt;&lt;&lt;i println(@variance(x,1)) }'
              2
              $ python3 -c 'import statistics; print(statistics.variance([1, 2, 3, 4, 5]))'
              2.5
              $

       Overflow  (from internal multiplication of large numbers) may occur and may cause a negative variance re‐
       sult.  Consider normalizing your input data.  Adding or subtracting a fixed value from all  variance  in‐
       puts preserves the original variance.  Dividing the variance inputs by a fixed value shrinks the original
       variance by that value squared.

       Histograms  are  also  available,  but are more complicated because they have a vector rather than scalar
       value.  <u>@hist_linear(v,start,stop,interval)</u> represents a linear histogram from "start" to "stop"  (inclu‐
       sive)  by  increments of "interval".  The interval must be positive. Similarly, <u>@hist_log(v)</u> represents a
       base-2 logarithmic histogram. Printing a histogram with the <u>print</u> family of functions renders a histogram
       object as a tabular "ASCII art" bar chart.

              probe timer.profile {
                x[1] &lt;&lt;&lt; pid()
                x[2] &lt;&lt;&lt; uid()
                y &lt;&lt;&lt; tid()
              }
              global x // an array containing aggregates
              global y // a scalar
              probe end {
                foreach ([i] in x @count+) {
                   printf ("x[%d]: avg %d = sum %d / count %d\n",
                           i, @avg(x[i]), @sum(x[i]), @count(x[i]))
                   println (@hist_log(x[i]))
                }
                println ("y:")
                println (@hist_log(y))
              }

       The counts of each histogram bucket may be individually accessed via the <b>[index]</b> operator.   Each  bucket
       is  addressed  from  1 through N (for each natural bucket).  In addition bucket #0 counts all the samples
       beneath the start value, and bucket #N+1 counts all the samples above the stop value.  Histogram  buckets
       (including the two out-of-range buckets) may also be iterated with <b>foreach</b>.

              global x
              probe oneshot {
                x &lt;&lt;&lt; -100
                x &lt;&lt;&lt; 1
                x &lt;&lt;&lt; 2
                x &lt;&lt;&lt; 3
                x &lt;&lt;&lt; 100
                foreach (bucket in @hist_linear(x,1,3,1))
                  // expecting   1 out-of-range-low bucket
                  //             3 payload buckets
                  //             1 out-of-range-high bucket
                  printf("bucket %d count %d\n",
                         bucket, @hist_linear(x,1,3,1)[bucket])
              }

   <b>TYPECASTING</b>
       Once  a pointer (see the CONTEXT VARIABLES section of <u><a href="../man3stap/stapprobes.3stap.html">stapprobes</a></u>(3stap)) has been saved into a script in‐
       teger variable, the translator <b>attempts</b> <b>to</b> keep the type information necessary  to  access  members  from
       that pointer.

       The translator attempts to track DWARF typing associated with script variables assigned from addresses of
       context  $variables, @cast or @var operators.  Depending on the complexity of the script code, this asso‐
       ciation may pass to related variables, so that <u>-&gt;</u> and <u>[]</u> operators may be used on them, just  as  on  the
       original context variable.  For example:

              foo = $param-&gt;foo; printf("x:%d y:%d\n", foo-&gt;x, foo-&gt;y)
              printf("my value is %d\n", ($type == 42 ? $foo : $bar)-&gt;value)
              printf("my parent pid is %d\n", task_parent(task_current())-&gt;tgid)

       However,  if  this  association heuristic doesn't work for a script, using the <u>@cast()</u> operator tells the
       translator how to interpret the number as a typed pointer.

              @cast(p, "type_name"[, "module"])-&gt;member

       This will interpret <u>p</u> as a pointer to a struct/union named <u>type_name</u> and dereference  the  <u>member</u>  value.
       Further  <u>-&gt;subfield</u> expressions may be appended to dereference more levels. Note that for direct derefer‐
       encing of a pointer {kernel,user}_{char,int,...}($p) should be used.  (Refer to <a href="../man5/stapfuncs.5.html">stapfuncs</a>(5) for more de‐
       tails.)  NOTE: the same dereferencing operator <u>-&gt;</u> is used to refer to both direct containment or  pointer
       indirection.   Systemtap  automatically determines which.  The optional <u>module</u> tells the translator where
       to look for information about that type.  Multiple modules may be specified as a list with <u>:</u>  separators.
       If  the module is not specified, it will default either to the probe module for dwarf probes, or to "ker‐
       nel" for functions and all other probes types.

       Previously up to systemtap version 4.2, "kernel" was inferred if unspecified.   Use  --compatible=4.2  to
       activate this default.

       The  translator  can create its own module with type information from a header surrounded by angle brack‐
       ets, in case normal debuginfo is not available.  For kernel headers, prefix it with "kernel" to  use  the
       appropriate  build  system.   All other headers are built with default GCC parameters into a user module.
       Multiple headers may be specified in sequence to resolve a codependency.

              @cast(tv, "timeval", "&lt;sys/time.h&gt;")-&gt;tv_sec
              @cast(task, "task_struct", "kernel&lt;linux/sched.h&gt;")-&gt;tgid
              @cast(task, "task_struct",
                    "kernel&lt;linux/sched.h&gt;&lt;linux/fs_struct.h&gt;")-&gt;fs-&gt;umask

       Values acquired by <b>@cast</b> may be pretty-printed by the <b>$</b> and <b>$$</b> suffix operators,  the  same  way  as  de‐
       scribed in the CONTEXT VARIABLES section of the <u><a href="../man3stap/stapprobes.3stap.html">stapprobes</a></u>(3stap) manual page.

       When  in  guru mode, the translator will also allow scripts to assign new values to members of typecasted
       pointers.

       Typecasting is also useful in the case of <u>void*</u> members whose type may be determinable at runtime.

              probe foo {
                if ($var-&gt;type == 1) {
                  value = @cast($var-&gt;data, "type1")-&gt;bar
                } else {
                  value = @cast($var-&gt;data, "type2")-&gt;baz
                }
                print(value)
              }

   <b>EMBEDDED</b> <b>C</b>
       When in guru mode, the translator accepts embedded C code in the top level of the script.  Such  code  is
       enclosed between <u>%{</u> and <u>%}</u> markers, and is transcribed verbatim, without analysis, in some sequence, into
       the  top  level  of the generated C code.  At the outermost level, this may be useful to add <u>#include</u> in‐
       structions, and any auxiliary definitions for use by other embedded code.

       Another place where embedded code is permitted is as a function body.  In this case, the script  language
       body is replaced entirely by a piece of C code enclosed again between <u>%{</u> and <u>%}</u> markers.  This C code may
       do  anything  reasonable  and safe.  There are a number of undocumented but complex safety constraints on
       atomicity, concurrency, resource consumption, and run time limits, so this is an advanced technique.

       The memory locations set aside for input and  output  values  are  made  available  to  it  using  macros
       <u>STAP_ARG_*</u>  and  <u>STAP_RETVALUE</u>.   Errors  may  be  signalled  with STAP_ERROR. Output may be written with
       STAP_PRINTF. The function may return early with STAP_RETURN.  Here are some examples:

              function integer_ops (val) %{
                STAP_PRINTF("%d\n", STAP_ARG_val);
                STAP_RETVALUE = STAP_ARG_val + 1;
                if (STAP_RETVALUE == 4)
                    STAP_ERROR("wrong guess: %d", (int) STAP_RETVALUE);
                if (STAP_RETVALUE == 3)
                    <a href="../man0/STAP_RETURN.0.html">STAP_RETURN</a>(0);
                STAP_RETVALUE ++;
              %}
              function string_ops (val) %{
                strlcpy (STAP_RETVALUE, STAP_ARG_val, MAXSTRINGLEN);
                strlcat (STAP_RETVALUE, "one", MAXSTRINGLEN);
                if (strcmp (STAP_RETVALUE, "three-two-one"))
                    STAP_RETURN("parameter should be three-two-");
              %}
              function no_ops () %{
                  STAP_RETURN(); /* function inferred with no return value */
              %}

       The function argument and return value types have to be inferred by the translator from the call sites in
       order for this to work. The user should examine C code generated for ordinary  script-language  functions
       in order to write compatible embedded-C ones.

       The last place where embedded code is permitted is as an expression rvalue.  In this case, the C code en‐
       closed  between  <u>%{</u> and <u>%}</u> markers is interpreted as an ordinary expression value.  It is assumed to be a
       normal 64-bit signed number, unless the marker <u>/*</u> <u>string</u> <u>*/</u> is included, in which case it's treated as  a
       string.

              function add_one (val) {
                return val + %{ 1 %}
              }
              function add_string_two (val) {
                return val . %{ /* string */ "two" %}
              }
              @define SOME_STAP_MACRO %( %{ SOME_C_MACRO %} %)
              probe begin {
                    printf("SOME_C_MACRO has value: %d\n", @SOME_STAP_MACRO);
              }

       The embedded-C code may contain markers to assert optimization and safety properties.

       <u>/*</u> <u>pure</u> <u>*/</u>
              means  that  the C code has no side effects and may be elided entirely if its value is not used by
              script code.

       <u>/*</u> <u>stable</u> <u>*/</u>
              means that the C code always has the same value (in any given probe handler  invocation),  so  re‐
              peated  calls may be automatically replaced by memoized values.  Such functions must take no para‐
              meters, and also be <u>pure</u>.

       <u>/*</u> <u>unprivileged</u> <u>*/</u>
              means that the C code is so safe that even unprivileged users are permitted to use it.

       <u>/*</u> <u>myproc-unprivileged</u> <u>*/</u>
              means that the C code is so safe that even unprivileged users are permitted to  use  it,  provided
              that the target of the current probe is within the user's own process.

       <u>/*</u> <u>guru</u> <u>*/</u>
              means  that the C code is so unsafe that a systemtap user must specify <u>-g</u> (guru mode) to use this.
              (Tapsets are permitted and presumed to call them safely.)

       <u>/*</u> <u>unmangled</u> <u>*/</u>
              in an embedded-C function, means that the legacy (pre-1.8) argument access syntax should  be  made
              available  inside  the  function. Hence, in addition to <u>STAP_ARG_foo</u> and <u>STAP_RETVALUE</u> one can use
              <u>THIS-&gt;foo</u> and <u>THIS-&gt;</u><b>__</b><u>retvalue</u> respectively inside the function. This is useful  for  quickly  mi‐
              grating code written for SystemTap version 1.7 and earlier.

       <u>/*</u> <u>unmodified-fnargs</u> <u>*/</u>
              in  an embedded-C function, means that the function arguments are not modified inside the function
              body.

       <u>/*</u> <u>string</u> <u>*/</u>
              in embedded-C expressions only, means that the expression has <u>const</u> <u>char</u>  <u>*</u>  type  and  should  be
              treated as a string value, instead of the default long numeric.

       Script  level  global  variables may be accessed in embedded-C functions and blocks. To read or write the
       global variable <u>var</u> , the <u>/*</u> <u>pragma:read:var</u> <u>*/</u> or <u>/*</u> <u>pragma:write:var</u> <u>*/</u> marker must be first placed  in
       the embedded-C function or block. This provides the macros <u>STAP_GLOBAL_GET_*</u> and <u>STAP_GLOBAL_SET_*</u> macros
       to allow reading and writing, respectively. For example:

              global var
              global var2[100]
              function increment() %{
                  /* pragma:read:var */ /* pragma:write:var */
                  /* pragma:read:var2 */ /* pragma:write:var2 */
                  STAP_GLOBAL_SET_var(STAP_GLOBAL_GET_var()+1); /<a href="file:/var">/var</a>++
                  STAP_GLOBAL_SET_var2(1, 1, STAP_GLOBAL_GET_var2(1, 1)+1); //var2[1,1]++
              %}

       Variables may be read and set in both embedded-C functions and expressions.  Strings returned from embed‐
       ded-C code are decayed to pointers. Variables must also be assigned at script level to allow for type in‐
       ference. Map assignment does not return the value written, so chaining does not work.

   <b>BUILT-INS</b>
       A  set of builtin probe point aliases are provided by the scripts installed in the directory specified in
       the <u><a href="../man7/stappaths.7.html">stappaths</a></u>(7) manual page.  The functions are described in the <u><a href="../man3stap/stapprobes.3stap.html">stapprobes</a></u>(3stap) manual page.

   <b>DEREFERENCING</b>
       Integers can be dereferenced from pointers saved as a script integer variables  using  the  <u>@kderef()</u>  or
       <u>@uderef()</u>  operators.   <u>@kderef()</u> is used for kernel space addresses and <u>@uderef()</u> is used for user space
       addresses.

              @kderef(SIZE, addr)
              @uderef(SIZE, addr)

       This will interpret <u>addr</u> as a kernel/user address and read <u>SIZE</u> bytes starting  at  that  address.   <u>SIZE</u>
       should be either 1, 2, 4 or 8 bytes.

   <b>REGISTERS</b>
       The  value  stored  within  a  register can be accessed using the <u>@kregister()</u> or <u>@uregister()</u> operators.
       <u>@kregister()</u> is used for kernel space registers and <u>@uregister()</u> is used for user  space  registers.  The
       register of interest is specified using its DWARF number.

              @<a href="../man0/kregister.0.html">kregister</a>(0)
              @<a href="../man5/uregister.5.html">uregister</a>(5)

</pre><h4><b>PROCESSING</b></h4><pre>
       The translator begins pass 1 by parsing the given input script, and all scripts (files named <u>*.stp</u>) found
       in a tapset directory.  The directories listed with <b>-I</b> are processed in sequence, each processed in "guru
       mode".   For  each  directory,  a  number  of subdirectories are also searched.  These subdirectories are
       derived from the selected kernel version (the <b>-R</b> option), in order to allow more  kernel-version-specific
       scripts  to  override  less specific ones.  For example, for a kernel version <u>2.6.12-23.FC3</u> the following
       patterns would be searched, in sequence: <u>2.6.12-23.FC3/*.stp</u>, <u>2.6.12/*.stp</u>, <u>2.6/*.stp</u>, and finally <u>*.stp</u>.
       Stopping the translator after pass 1 causes it to print the parse trees.

       In pass 2, the translator analyzes the  input  script  to  resolve  symbols  and  types.   References  to
       variables, functions, and probe aliases that are unresolved internally are satisfied by searching through
       the  parsed  tapset script files.  If any tapset script file is selected because it defines an unresolved
       symbol, then the entirety of that file is added to  the  translator's  resolution  queue.   This  process
       iterates until all symbols are resolved and a subset of tapset script files is selected.

       Next,  all  probe  point descriptions are validated against the wide variety supported by the translator.
       Probe points that refer to code locations ("synchronous probe points")  require  the  appropriate  kernel
       debugging  information  to  be installed.  In the associated probe handlers, target-side variables (whose
       names begin with "$") are found and have their run-time locations decoded.

       Next, all probes and functions are analyzed for optimization opportunities, in order to remove variables,
       expressions, and functions that have no useful  value  and  no  side-effect.   Embedded-C  functions  are
       assumed  to  have  side-effects unless they include the magic string <b>/*</b> <b>pure</b> <b>*/</b>.  Since this optimization
       can hide latent code errors such as type mismatches or invalid $context variables, it  sometimes  may  be
       useful to disable the optimizations with the <b>-u</b> option.

       Finally,  all  variable,  function, parameter, array, and index types are inferred from context (literals
       and operators).  Stopping the translator after pass 2 causes it to list all the  probes,  functions,  and
       variables, along with all inferred types.  Any inconsistent or unresolved types cause an error.

       In  pass  3,  the  translator writes C code that represents the actions of all selected script files, and
       creates a <u>Makefile</u> to build that into  a  kernel  object.   These  files  are  placed  into  a  temporary
       directory.  Stopping the translator at this point causes it to print the contents of the C file.

       In  pass 4, the translator invokes the Linux kernel build system to create the actual kernel object file.
       This involves running <u>make</u> in the  temporary  directory,  and  requires  a  kernel  module  build  system
       (headers,  config  and Makefiles) to be installed in the usual spot <u>/lib/modules/VERSION/build</u>.  Stopping
       the translator after pass 4 is the last chance before running the kernel object.  This may be  useful  if
       you want to archive the file.

       In  pass  5,  the translator invokes the systemtap auxiliary program <u>staprun</u> program for the given kernel
       object.  This program arranges to load the module then communicates with it, copying trace data from  the
       kernel into temporary files, until the user sends an interrupt signal.  Any run-time error encountered by
       the probe handlers, such as running out of memory, division by zero, exceeding nesting or runtime limits,
       results  in  a  soft error indication.  Soft errors in excess of MAXERRORS block of all subsequent probes
       (except error-handling probes), and terminate the session.  Finally,  <u>staprun</u>  unloads  the  module,  and
       cleans up.

   <b>ABNORMAL</b> <b>TERMINATION</b>
       One  should avoid killing the stap process forcibly, for example with SIGKILL, because the stapio process
       (a child process of the stap process) and the loaded module may be left running on the system.   If  this
       happens, send SIGTERM or SIGINT to any remaining stapio processes, then use rmmod to unload the systemtap
       module.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See  the <u><a href="../man3stap/stapex.3stap.html">stapex</a></u>(3stap) manual page for a brief collection of samples, or a large set of installed samples
       under the systemtap documentation/testsuite directories.  See <u><a href="../man7stap/stappaths.7stap.html">stappaths</a></u>(7stap) for the likely location of
       these on the system.

</pre><h4><b>CACHING</b></h4><pre>
       The systemtap translator caches the pass 3 output (the generated C code)  and  the  pass  4  output  (the
       compiled  kernel  module)  if  pass  4  completes successfully.  This cached output is reused if the same
       script is translated again assuming the same  conditions  exist  (same  kernel  version,  same  systemtap
       version,  etc.).  Cached files are stored in the <u>$SYSTEMTAP_DIR/cache</u> directory. The cache can be limited
       by having the file <u>cache_mb_limit</u> placed in the cache directory (shown above) containing  only  an  ASCII
       integer  representing  how  many  MiB the cache should not exceed. In the absence of this file, a default
       will be created with the limit set to 256MiB.  This is a 'soft' limit in that the cache will  be  cleaned
       after  a  new  entry  is  added  if  the  cache  clean  interval is exceeded, so the total cache size may
       temporarily exceed this limit. This interval can be specified by having the  file  <u>cache_clean_interval_s</u>
       placed in the cache directory (shown above) containing only an ASCII integer representing the interval in
       seconds. In the absence of this file, a default will be created with the interval set to 300 s.

</pre><h4><b>SAFETY</b> <b>AND</b> <b>SECURITY</b></h4><pre>
       Systemtap  may  be used as a powerful administrative tool.  It can expose kernel internal data structures
       and potentially private user information.  (In <b>dyninst</b> runtime mode,  this  is  not  the  case,  see  the
       <u>ALTERNATE</u> <u>RUNTIMES</u> section below.)

       The  translator  asserts many safety constraints during compilation and more during run-time.  It aims to
       ensure that no handler routine  can  run  for  very  long,  allocate  boundless  memory,  perform  unsafe
       operations,  or  in  unintentionally  interfere  with  the  system.   Uses of script global variables are
       automatically read/write locked as appropriate, to  protect  against  manipulation  by  concurrent  probe
       handlers.   Locks  are  taken  so  as  to  run the global-variable manipulation portion of probe handlers
       atomically (locks are taken all-or-none).  Deadlocks are detected with timeouts.   Use  the  <b>-t</b>  flag  to
       receive  reports  of  excessive lock contention.  Experimenting with scripts is therefore generally <b>safe</b>.
       The guru-mode <b>-g</b> option allows administrators to bypass most safety measures, which permits  invasive  or
       state-changing  operations,  embedded-C  code,  and  increases  the  risk of upset.  By default, overload
       prevention is turned on for all modules.  If you would like  to  disable  overload  processing,  use  the
       <b>--suppress-time-limits</b> option.

       Errors that are caught at run time normally result in a clean script shutdown and a pass-5 error message.
       The <b>--suppress-handler-errors</b> option lets scripts tolerate soft errors without shutting down.

   <b>PERMISSIONS</b>
       For  the  normal  linux-kernel-module runtime, to run the kernel objects systemtap builds, a user must be
       one of the following:

       •   the root user;

       •   a member of the <u>stapdev</u> and <u>stapusr</u> groups;

       •   a member of the <u>stapsys</u> and <u>stapusr</u> groups; or

       •   a member of the <u>stapusr</u> group.

       The root user or a user who is a member of both the <u>stapdev</u> and <u>stapusr</u> groups  can  build  and  run  any
       systemtap script.

       A  user  who  is a member of both the <u>stapsys</u> and <u>stapusr</u> groups can only use pre-built modules under the
       following conditions:

       •   The  module  has  been  signed  by  a  trusted  signer.  Trusted  signers  are   normally   systemtap
           compile-servers  which  sign  modules when the <u>--privilege</u> option is specified by the client. See the
           <u><a href="../man8/stap-server.8.html">stap-server</a></u>(8) manual page for more information.

       •   The module was built using the <u>--privilege=stapsys</u> or the <u>--privilege=stapusr</u> options.

       Members of only the <u>stapusr</u> group can only use pre-built modules under the following conditions:

       •   The module is located in the /lib/modules/VERSION/systemtap directory.  This directory must be  owned
           by root and not be world writable.

       or

       •   The   module   has  been  signed  by  a  trusted  signer.  Trusted  signers  are  normally  systemtap
           compile-servers which sign modules when the <u>--privilege</u> option is specified by the  client.  See  the
           <u><a href="../man8/stap-server.8.html">stap-server</a></u>(8) manual page for more information.

       •   The module was built using the --privilege=stapusr option.

       The kernel modules generated by <u>stap</u> program are run by the <u>staprun</u> program.  The latter is a part of the
       Systemtap package, dedicated to module loading and unloading (but only in the white zone), and kernel-to-
       user  data transfer.  Since <u>staprun</u> does not perform any additional security checks on the kernel objects
       it is given, it would be unwise for a system administrator to add  untrusted  users  to  the  <u>stapdev</u>  or
       <u>stapusr</u> groups.

   <b>SECUREBOOT</b>
       If  the  current system has SecureBoot turned on in the UEFI firmware, all kernel modules must be signed.
       (Some kernels may allow disabling SecureBoot long after booting with a  key  sequence  such  as  SysRq-X,
       making  it  unnecessary  to sign modules.)  There are two ways to sign a systemtap module.  The systemtap
       compile server can sign modules with a MOK (Machine Owner Key) that  it  has  in  common  with  a  client
       system.  For example:

              stap --use-server=HOSTNAME:PORT -e 'SCRIPT'
              # If there is no mok key in common with the server's systemtap mok key
              # list and the client's mok database then the user is directed by stap
              # to invoke:
              sudo mokutil --import signing_key.x509
              # then after rebooting the system:
              stap --use-server=HOSTNAME:PORT -e 'SCRIPT'
              # will use the server to build and sign the module and the module will run
              # on the client

       Another  way to sign modules is to use the stap --sign-module option, which uses a MOK on the client sys‐
       tem without using a server.  For example:

              stap --sign-module -e 'SCRIPT'
              # If there is no systemtap mok key in the system mok database
              # then the user is directed by stap to invoke:
              sudo mokutil --import /home/USER/.systemtap/ssl/server/moks/FINGERPRINT/signing_key.x509
              # then after rebooting the system:
              stap --sign-module -e 'SCRIPT'
              # will sign and run the module

       See the following wiki page for more details:

              <b>https://sourceware.org/systemtap/wiki/SecureBoot</b>

       Some kernels do not let systemtap guess whether module module signing is in effect.   On  such  machines,
       set the SYSTEMTAP_SIGN environment variable to any value while running stap.

   <b>RESOURCE</b> <b>LIMITS</b>
       Many  resource  use  limits  are  set by macros in the generated C code.  These may be overridden with <b>-D</b>
       flags.  A selection of these is as follows:

       MAXNESTING
              Maximum number of nested function calls.  Default determined by script analysis, with a  bonus  10
              slots added for recursive scripts.

       MAXSTRINGLEN
              Maximum length of strings, default 128.

       MAXTRYLOCK
              Maximum number of iterations to wait for locks on global variables before declaring possible dead‐
              lock and skipping the probe, default 1000.

       MAXACTION
              Maximum  number  of  statements to execute during any single probe hit (with interrupts disabled),
              default 1000.  Note that for straight-through probe handlers lacking loops or  recursion,  due  to
              optimization, this parameter may be interpreted too conservatively.

       MAXACTION_INTERRUPTIBLE
              Maximum  number of statements to execute during any single probe hit which is executed with inter‐
              rupts enabled (such as begin/end probes), default (MAXACTION * 10).

       MAXBACKTRACE
              Maximum number of stack frames that will be be processed by the stap runtime unwinder as  produced
              by the backtrace functions in the [u]context-unwind.stp tapsets, default 20.

       MAXMAPENTRIES
              Maximum  number  of  rows  in any single global array, default 2048.  Individual arrays may be de‐
              clared with a larger or smaller limit instead:

              global big[10000],little[5]

              or denoted with <u>%</u> to make them wrap-around (replace old entries) automatically, as in

              global big%

              or both.

       MAPHASHBIAS
              The number of powers-of-two to add or subtract from the natural size of  the  hash  table  backing
              each global associative array.  Default is 0.  Try small positive numbers to get extra performance
              at  the  cost  of  more memory consumption, because that should reduce hash table collisions.  Try
              small negative numbers for the opposite tradeoff.

       MAXERRORS
              Maximum number of soft errors before an exit is triggered, default 0, which means that  the  first
              error  will  exit  the script.  Note that with the <b>--suppress-handler-errors</b> option, this limit is
              not enforced.

       MAXSKIPPED
              Maximum number of skipped probes before an exit is triggered, default 100.  Running systemtap with
              -t (timing) mode gives more details about skipped probes.  With the default -DINTERRUPTIBLE=1 set‐
              ting, probes skipped due to reentrancy are not accumulated against this limit.  Note that with the
              <b>--suppress-handler-errors</b> option, this limit is not enforced.

       MINSTACKSPACE
              Minimum number of free kernel stack bytes required in order to run a probe handler, default  1024.
              This number should be large enough for the probe handler's own needs, plus a safety margin.

       MAXUPROBES
              Maximum number of concurrently armed user-space probes (uprobes), default somewhat larger than the
              number  of  user-space  probe points named in the script.  This pool needs to be potentially large
              because individual uprobe objects (about 64 bytes each) are allocated for each  process  for  each
              matching script-level probe.

       STP_MAXMEMORY
              Maximum  amount  of memory (in kilobytes) that the systemtap module should use, default unlimited.
              The memory size includes the size of the module itself, plus any additional allocations.  This on‐
              ly tracks direct allocations by the systemtap runtime.  This does not track  indirect  allocations
              (as done by kprobes/uprobes/etc. internals).

       STP_OVERLOAD_THRESHOLD, STP_OVERLOAD_INTERVAL
              Maximum number of machine cycles spent in probes on any cpu per given interval, before an overload
              condition is declared and the script shut down.  The defaults are 500 million and 1 billion, so as
              to limit stap script cpu consumption at around 50%.

       STP_PROCFS_BUFSIZE
              Size  of procfs probe read buffers (in bytes).  Defaults to <u>MAXSTRINGLEN</u>.  This value can be over‐
              ridden on a per-procfs file basis using the procfs read probe <u>.maxsize(MAXSIZE)</u> parameter.

       With scripts that contain probes on any interrupt path, it is possible that those interrupts may occur in
       the middle of another probe handler.  The probe in the interrupt handler would be skipped in this case to
       avoid reentrance.  To work around this issue, execute stap with the option <b>-DINTERRUPTIBLE=0</b> to mask  in‐
       terrupts  throughout the probe handler.  This does add some extra overhead to the probes, but it may pre‐
       vent reentrance for common problem cases.  However, probes in NMI handlers and in  the  callpath  of  the
       stap runtime may still be skipped due to reentrance.

       In  case  something  goes  wrong  with <u>stap</u> or <u>staprun</u> after a probe has already started running, one may
       safely kill both user processes, and remove the active probe kernel module with <u>rmmod</u>.  Any pending trace
       messages may be lost.

</pre><h4><b>UNPRIVILEGED</b> <b>USERS</b></h4><pre>
       Systemtap exposes kernel internal data structures and potentially private user  information.  Because  of
       this,  use  of  systemtap's  full capabilities are restricted to root and to users who are members of the
       groups stapdev and stapusr.

       However, a restricted set of systemtap's features can be made available to trusted,  unprivileged  users.
       These  users  are members of the group stapusr only, or members of the groups stapusr and stapsys.  These
       users can load systemtap modules which have been compiled and  certified  by  a  trusted  systemtap  com‐
       pile-server. See the descriptions of the options <u>--privilege</u> and <u>--use-server</u>. See <u>README.unprivileged</u> in
       the systemtap source code for information about setting up a trusted compile server.

       The  restrictions  enforced  when  <u>--privilege=stapsys</u>  is specified are designed to prevent unprivileged
       users from:

              •   harming the system maliciously.

       The restrictions enforced when <u>--privilege=stapusr</u> is specified  are  designed  to  prevent  unprivileged
       users from:

              •   harming the system maliciously.

              •   gaining access to information which would not normally be available to an unprivileged user.

              •   disrupting  the performance of processes owned by other users of the system.  Some overhead to
                  the system in general is unavoidable since the unprivileged  user's probes will  be  triggered
                  at  the  appropriate  times.  What  we would like to avoid is targeted interruption of another
                  user's processes which would not normally be possible by an unprivileged user.

   <b>PROBE</b> <b>RESTRICTIONS</b>
       A member of the groups stapusr and stapsys may use all probe points.

       A member of only the group stapusr may use only the following probes:

              •   begin, begin(n)

              •   end, end(n)

              •   error(n)

              •   never

              •   process.*, where the target process is owned by the user.

              •   timer.{jiffies,s,sec,ms,msec,us,usec,ns,nsec}(n)*

              •   timer.hz(n)

   <b>SCRIPT</b> <b>LANGUAGE</b> <b>RESTRICTIONS</b>
       The following scripting language features are unavailable to all unprivileged users:

              •   any feature enabled by the Guru Mode (-g) option.

              •   embedded C code.

   <b>RUNTIME</b> <b>RESTRICTIONS</b>
       The following runtime restrictions are placed upon all unprivileged users:

              •   Only the default runtime code (see <u>-R</u>) may be used.

       Additional restrictions are placed on members of only the group stapusr:

              •   Probing of processes owned by other users is not permitted.

              •   Access of kernel memory (read and write) is not permitted.

   <b>COMMAND</b> <b>LINE</b> <b>OPTION</b> <b>RESTRICTIONS</b>
       Some command line options provide access to features which must not  be  available  to  all  unprivileged
       users:

              •   -g may not be specified.

              •   The following options may not be used by the compile-server client:

                      -a, -B, -D, -I, -r, -R

   <b>ENVIRONMENT</b> <b>RESTRICTIONS</b>
       The following environment variables must not be set for all unprivileged users:

              SYSTEMTAP_RUNTIME
              SYSTEMTAP_TAPSET
              SYSTEMTAP_DEBUGINFO_PATH

   <b>TAPSET</b> <b>RESTRICTIONS</b>
       In  general, tapset functions are only available for members of the group stapusr when they do not gather
       information that an ordinary program running with that user's privileges would be denied access to.

       There are two categories of unprivileged tapset functions. The first category consists of  utility  func‐
       tions that are unconditionally available to all users; these include such things as:

              cpu:long ()
              exit ()
              str_replace:string (prnt_str:string, srch_str:string, rplc_str:string)

       The  second category consists of so-called <u>myproc-unprivileged</u> functions that can only gather information
       within their own processes. Scripts that wish to use these functions must test the result of  the  tapset
       function  <u>is_myproc</u> and only call these functions if the result is 1. The script will exit immediately if
       any of these functions are called by an unprivileged user within a probe within a process  which  is  not
       owned by that user. Examples of <u>myproc-unprivileged</u> functions include:

              print_usyms (stk:string)
              user_int:long (addr:long)
              usymname:string (addr:long)

       A  compile  error is triggered when any function not in either of the above categories is used by members
       of only the group stapusr.

       No other built-in tapset functions may be used by members of only the group stapusr.

</pre><h4><b>ALTERNATE</b> <b>RUNTIMES</b></h4><pre>
       As described above, systemtap's default runtime mode involves building and loading kernel  modules,  with
       various  security  tradeoffs  presented.   Systemtap  now  includes  two  new  prototype backends: <u>--run‐</u>
       <u>time=dyninst</u> and <u>--runtime=bpf</u>.

       <u>--runtime=dyninst</u> uses Dyninst to instrument a user's own processes at runtime. This backend does not use
       kernel modules, and does not require root privileges, but is restricted with  respect  to  the  kinds  of
       probes  and other constructs that a script may use. <u>dyninst</u> runtime operates in target-attach mode, so it
       does require a <u>-c</u> <u>COMMAND</u> or <u>-x</u> <u>PID</u> process.  For example:

              stap --runtime=dyninst -c 'stap -V' \
                   -e 'probe process.function("main")
                       { println("hi from dyninst!") }'

       It may be necessary to disable a conflicting selinux check with

              # setsebool allow_execstack 1

       <u>--runtime=bpf</u> compiles the user script into extended Berkeley Packet Filter (eBPF) programs instead of  a
       kernel  module. eBPF programs are verified by the kernel for safety and are executed by an in-kernel vir‐
       tual machine.  This runtime is in an early stage of development and currently lacks support for a  number
       of features available in the default runtime. Please see the <u><a href="../man8/stapbpf.8.html">stapbpf</a></u>(8) man page for more information.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The systemtap translator generally returns with a success code of 0 if the requested script was processed
       and  executed  successfully through the requested pass.  Otherwise, errors may be printed to stderr and a
       failure code is returned.  Use <u>-v</u> or <u>-vp</u> <u>N</u> to increase (global or per-pass)  verbosity  to  identify  the
       source of the trouble.

       In listings mode (<u>-l</u> and <u>-L</u>), error messages are normally suppressed.  A success code of 0 is returned if
       at least one matching probe was found.

       A script executing in pass 5 that is interrupted with ^C / SIGINT is considered to be successful.

</pre><h4><b>DEPRECATION</b></h4><pre>
       Over  time, some features of the script language and the tapset library may undergo incompatible changes,
       so that a script written against an old version of systemtap may no longer run.  In these cases,  it  may
       help  to  run  systemtap  with  the <u>--compatible</u> <u>VERSION</u> flag, specifying the last known working version.
       Running systemtap with the <u>--check-version</u> flag will output a warning if any possible  incompatible  ele‐
       ments have been parsed.  Deprecation historical details may be found in the NEWS file.

       The purpose of deprecation facility is to improve the experience of scripts written for newer versions of
       systemtap  (by adding better alternatives and removing conflicting or messy older alternatives), while at
       the same time permitting scripts written for older versions of systemtap to continue  running.   Depreca‐
       tion  is  thus  intended a <u>service</u> <u>to</u> <u>users</u> (and an inconvenience to systemtap's developers), rather than
       the other way around.

       Please note that underscore-prefixed identifiers in the tapset sometimes undergo such  changes  that  are
       difficult to preserve compatibility for, even with the deprecation mechanisms.  Avoid relying on these in
       your scripts; instead propose them for promotion to non-underscored status.

</pre><h4><b>FILES</b></h4><pre>
       Important files and their corresponding paths can be located in the
              stappaths (7) manual page.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3stap/stapprobes.3stap.html">stapprobes</a></u>(3stap),
       <u>function::*</u>(3stap),
       <u>probe::*</u>(3stap),
       <u>tapset::*</u>(3stap),
       <u><a href="../man7/stappaths.7.html">stappaths</a></u>(7),
       <u><a href="../man8/staprun.8.html">staprun</a></u>(8),
       <u><a href="../man8/stapdyn.8.html">stapdyn</a></u>(8),
       <u><a href="../man8/systemtap.8.html">systemtap</a></u>(8),
       <u><a href="../man3stap/stapvars.3stap.html">stapvars</a></u>(3stap),
       <u><a href="../man3stap/stapex.3stap.html">stapex</a></u>(3stap),
       <u><a href="../man8/stap-server.8.html">stap-server</a></u>(8),
       <u><a href="../man1/stap-prep.1.html">stap-prep</a></u>(1),
       <u><a href="../man1/stapref.1.html">stapref</a></u>(1),
       <u><a href="../man1/awk.1.html">awk</a></u>(1),
       <u><a href="../man1/gdb.1.html">gdb</a></u>(1)

</pre><h4><b>BUGS</b></h4><pre>
       Use  the  Bugzilla  link  of the project web page or our mailing list.  <b><a href="http://sourceware.org/systemtap/">http://sourceware.org/systemtap/</a></b>,
       <b>&lt;<a href="mailto:systemtap@sourceware.org">systemtap@sourceware.org</a>&gt;</b>.

       <u>error::<a href="../man7stap/reporting.7stap.html">reporting</a></u>(7stap), <b>https://sourceware.org/systemtap/wiki/HowToReportBugs</b>

                                                                                                         <u><a href="../man1/STAP.1.html">STAP</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>