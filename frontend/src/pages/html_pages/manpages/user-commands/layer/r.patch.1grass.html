<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>r.patch   -  Creates  a  composite raster map layer by using known category values from one (or more) map</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/grass-doc">grass-doc_8.4.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>r.patch</b>   -  Creates  a  composite raster map layer by using known category values from one (or more) map
       layer(s) to fill in areas of "no data" in another map layer.

</pre><h4><b>KEYWORDS</b></h4><pre>
       raster, geometry, mosaicking, merge, patching, aggregation, series, parallel

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>r.patch</b>
       <b>r.patch</b> <b>--help</b>
       <b>r.patch</b> [-<b>zs</b>] <b>input</b>=<u>name</u>[,<u>name</u>,...] <b>output</b>=<u>name</u>  [<b>nprocs</b>=<u>integer</u>]   [<b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>]   [--<b>overwrite</b>]
       [--<b>help</b>]  [--<b>verbose</b>]  [--<b>quiet</b>]  [--<b>ui</b>]

   <b>Flags:</b>
       <b>-z</b>
           Use zero (0) for transparency instead of NULL

       <b>-s</b>
           Do not create color and category files

       <b>--overwrite</b>
           Allow output files to overwrite existing files

       <b>--help</b>
           Print usage summary

       <b>--verbose</b>
           Verbose module output

       <b>--quiet</b>
           Quiet module output

       <b>--ui</b>
           Force launching GUI dialog

   <b>Parameters:</b>
       <b>input</b>=<u>name[,name</u>,...] <b>[required]</b>
           Name of raster maps to be patched together

       <b>output</b>=<u>name</u> <b>[required]</b>
           Name for resultant raster map

       <b>nprocs</b>=<u>integer</u>
           Number of threads for parallel computing
           Default: <u>1</u>

       <b>memory</b>=<u>memory</u> <u>in</u> <u>MB</u>
           Maximum memory to be used (in MB)
           Cache size for raster rows
           Default: <u>300</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The GRASS program <u>r.patch</u> allows the user to build a new raster  map  the  size  and  resolution  of  the
       current region by assigning known data values from input raster maps to the cells in this region.
       In  case  of  overlapping input raster maps this is done by filling in "no data" cells, those that do not
       yet contain data, contain NULL data, or, optionally contain 0 data, with the data from  the  first  input
       map.  Once this is done the remaining holes are filled in by the next input map, and so on.
       In case of adjacent input raster maps the output map contains the map mosaic.

       Hence this command is useful for

           •   making a composite raster map layer from two or more adjacent map layers,

           •   for filling in "holes" in a raster map layer’s data (e.g., in digital elevation data), or

           •   for updating an older map layer with more recent data.
       The current geographic region definition and mask settings are respected.

       <u>Figure:</u> <u>Result</u> <u>of</u> <u>patching</u> <u>of</u> <u>two</u> <u>raster</u> <u>maps</u> <u>containing</u> <u>NULLs</u> <u>using</u> <u>the</u> <u>default</u> <u>settings.</u>

   <b>Stacking</b> <b>order</b>
       The  first  <u>name</u>  listed  in  the string <b>input=</b><u>name</u>,<u>name</u>,<u>name</u>,... is the name of the first map whose data
       values will be used to fill in cells in the current region.  Then, the second through the last input maps
       (..., <u>name</u>, <u>name</u>, ...) will be used, in order, to supply data values for the remaining  "no  data"  cells
       (or cells with value 0 with <b>-z</b> flag).

       In other words, the first raster map is used first and if it had some "no data" cells, then second raster
       map  is  used  for  these cells, then the third and so on.  So the formal command line syntax can be also
       written as <b>input=</b><u>primary</u>,<u>secondary</u>,<u>tertiary</u>,...  For two raster maps, the first one can be viewed as  the
       primary one or the default one and the second one as the secondary one or a fallback.

       <u>Figure:</u> <u>Result</u> <u>of</u> <u>patching</u> <u>of</u> <u>two</u> <u>raster</u> <u>maps</u> <u>using</u> <u>the</u> <b>-z</b> flag to treat zeros as NULLs. Note the value 1
       being  preserved  from  the first raster while the value 6 is taken from the second raster instead of the
       value 0 from the first raster because zeros are replaced with the <b>-z</b> flag active.

   <b>Relation</b> <b>to</b> <b>SQL</b> <b>COALESCE()</b> <b>function</b>
       The module is corresponds to the SQL COALESCE() function.  This function takes two or more arguments  and
       returns a copy of its first non-NULL argument. If all arguments are NULL, the function returns NULL.

       The  <u>r.patch</u>  module  iterates  over  all cells and for each cell of the output raster map uses the first
       corresponding non-NULL cell in the series of the input raster maps.

   <b>Example</b> <b>of</b> <b>filling</b> <b>areas</b>
       Below, the raster map layer on the far left is <b>patched</b> with the middle (<u>patching</u>) raster  map  layer,  to
       produce  the  <u>composite</u>  raster map layer on the right.  The example assumes zero values to be treated as
       NULLs (<b>-z</b> flag).
         1 1 1 0 2 2 0 0    0 0 1 1 0 0 0 0    1 1 1 1 2 2 0 0
         1 1 0 2 2 2 0 0    0 0 1 1 0 0 0 0    1 1 1 2 2 2 0 0
         3 3 3 3 2 2 0 0    0 0 0 0 0 0 0 0    3 3 3 3 2 2 0 0
         3 3 3 3 0 0 0 0    4 4 4 4 4 4 4 4    3 3 3 3 4 4 4 4
         3 3 3 0 0 0 0 0    4 4 4 4 4 4 4 4    3 3 3 4 4 4 4 4
         0 0 0 0 0 0 0 0    4 4 4 4 4 4 4 4    4 4 4 4 4 4 4 4
       Switching the <u>patched</u> and the <u>patching</u> raster map layers produces the following results:
         0 0 1 1 0 0 0 0    1 1 1 0 2 2 0 0    1 1 1 1 2 2 0 0
         0 0 1 1 0 0 0 0    1 1 0 2 2 2 0 0    1 1 1 1 2 2 0 0
         0 0 0 0 0 0 0 0    3 3 3 3 2 2 0 0    3 3 3 3 2 2 0 0
         4 4 4 4 4 4 4 4    3 3 3 3 0 0 0 0    4 4 4 4 4 4 4 4
         4 4 4 4 4 4 4 4    3 3 3 0 0 0 0 0    4 4 4 4 4 4 4 4
         4 4 4 4 4 4 4 4    0 0 0 0 0 0 0 0    4 4 4 4 4 4 4 4

</pre><h4><b>NOTES</b></h4><pre>
       Frequently, this program is used to  patch  together  adjacent  map  layers  which  have  been  digitized
       separately.  The program <u>v.mkgrid</u> can be used to make adjacent maps align neatly.

       The  user  should check the current geographic region settings before running <u>r.patch</u>, to ensure that the
       region boundaries encompass all of the data desired to be included in the composite  map  and  to  ensure
       that  the  region resolution is the resolution of the desired data. To set the geographic region settings
       to one or several raster maps, the <u>g.region</u> program can be used:
       g.region raster=map1[,map2[,...]]

       Use of <u>r.patch</u> is generally followed by use of the GRASS programs <u>g.remove</u> and <u>g.rename</u>; <u>g.remove</u> is used
       to remove the original (un-patched) raster map layers, while <u>g.rename</u> is  used  to  then  assign  to  the
       newly-created composite (patched) raster map layer the name of the original raster map layer.

       <u>r.patch</u>  reads  the  existing category label files and color tables from the <u>input</u> maps and creates these
       files for the patched, composite <u>output</u> map.   This  can  be  quite  time  consuming  for  certain  maps,
       especially  if  there  are  many  different  category  values across the patched maps. The <u>-s</u> flag allows
       disabling the reading and creation of these support files,  meaning that the  <u>output</u>  map  will  have  no
       category labels and no explicit color table.

       Number  of  raster  maps to be processed is given by the limit of the operating system. For example, both
       the hard and soft limits are typically 1024. The soft limit can be  changed  with  e.g.  ulimit  -n  1500
       (UNIX-based operating systems) but not higher than the hard limit. If it is too low, you can as superuser
       add an entry in
       <a href="file:/etc/security/limits.conf">/etc/security/limits.conf</a>
       # &lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;
       your_username  hard    nofile          1500
       This  would raise the hard limit to 1500 file. Be warned that more files open need more RAM. See also the
       Wiki page Hints for large raster data processing.

       Operating systems usually limit the length of the command line which limits the number  of  input  raster
       maps  user  can  pass to the module using the option <b>input</b>. In that case, <u>r.series</u> can be used instead of
       <u>r.patch</u>.

   <b>PERFORMANCE</b>
       By specifying the number of parallel processes with <b>nprocs</b> option, <u>r.patch</u> can run significantly  faster,
       see benchmarks below.
       <u>Figure:</u>  <u>Benchmark</u> <u>on</u> <u>the</u> <u>left</u> <u>shows</u> <u>execution</u> <u>time</u> <u>for</u> <u>different</u> <u>number</u> <u>of</u> <u>cells,</u> <u>benchmark</u> <u>on</u> <u>the</u> <u>right</u>
       <u>shows</u> <u>execution</u> <u>time</u> <u>for</u> <u>different</u> <u>memory</u> <u>size</u> <u>for</u> <u>5000x5000</u> <u>raster.</u>  <u>See</u>  <u>benchmark</u>  <u>scripts</u>  <u>in</u>  <u>source</u>
       <u>code.</u>  <u>(Intel</u> <u>Core</u> <u>i9-10940X</u> <u>CPU</u> <u>@</u> <u>3.30GHz</u> <u>x</u> <u>28)</u>

       To  reduce  the  memory  requirements  to  minimum,  set option <b>memory</b> to zero.  To take advantage of the
       parallelization, GRASS GIS needs to compiled with OpenMP enabled.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Example</b> <b>with</b> <b>three</b> <b>maps</b>
       The input are three maps called roads, water and forest. Primarily, we want to use the values from roads,
       then from water and if no other values are available we want to use forest.  First we set the computation
       region assuming that the all three maps fully overlap and have the same resolution (so we can safely  use
       the just the one without further modifications of the region).  Then we perform the patching.
       g.region raster=roads
       r.patch input=roads,water,forest output=result

   <b>Map</b> <b>mosaic</b> <b>example</b> <b>using</b> <b>Bash</b> <b>syntax</b>
       Create  a list of maps matching a pattern, extend the region to include them all, and patch them together
       to create a mosaic. Overlapping maps will be used in the order listed.
       MAPS=`g.list type=raster separator=comma pat="map_*"`
       g.region raster=$MAPS -p
       r.patch input=$MAPS output=maps_mosaic

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        <u>g.region,</u> <u>g.remove,</u> <u>g.rename,</u> <u>r.mapcalc,</u> <u>r.support,</u> <u>r.series,</u> <u>v.mkgrid</u>

       Hints for large raster data processing

</pre><h4><b>AUTHORS</b></h4><pre>
       Michael Shapiro, U.S. Army Construction Engineering Research Laboratory
       Huidae Cho (-z flag and performance improvement)
       Aaron Saw Min Sern (OpenMP support).

</pre><h4><b>SOURCE</b> <b>CODE</b></h4><pre>
       Available at: r.patch source code (history)

       Accessed: Friday Apr 04 01:19:24 2025

       Main index | Raster index | Topics index | Keywords index | Graphical index | Full index

       © 2003-2025 GRASS Development Team, GRASS GIS 8.4.1 Reference Manual

GRASS 8.4.1                                                                                      <u><a href="../man1grass/r.patch.1grass.html">r.patch</a></u>(1grass)
</pre>
 </div>
</div></section>
</div>
</body>
</html>