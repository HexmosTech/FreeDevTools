<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>futhark-bench - benchmark Futhark programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/futhark">futhark_0.25.27-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       futhark-bench - benchmark Futhark programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       futhark bench [options…] programs…

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  tool  is  the  recommended  way  to  benchmark  Futhark  programs.  Programs are compiled using the
       specified backend (<b>c</b> by default), then run a number of times for each test case, and the arithmetic  mean
       runtime and 95% confidence interval printed on standard output.  Refer to <u>futhark-test</u> for information on
       how  to  format  test  data.  A program will be ignored if it contains no data sets - it will not even be
       compiled.

       If compilation of a program fails, then <b>futhark</b> <b>bench</b> will abort immediately.  If execution of a test set
       fails, an error message will be printed and benchmarking will continue (and <b>--json</b> will write the  file),
       but a non-zero exit code will be returned at the end.

</pre><h4><b>METHODOLOGY</b></h4><pre>
       For  each  program  and dataset, <b>futhark</b> <b>bench</b> first does a single “warmup” run that is discarded.  After
       that it uses a two-phase technique.

       1. The <u>initial</u> <u>phase</u> performs ten runs (change with <b>-r</b>), or perform runs for  at  least  half  a  second,
          whichever  takes  longer.   If  the  resulting  measurements  are  sufficiently  statistically  robust
          (determined using standard deviation and autocorrelation metrics), the results are  produced  and  the
          second phase is not entered.  Otherwise, the results are discarded and the second phase entered.

       2. The  <u>convergence</u>  <u>phase</u> keeps performing runs until a measurement of sufficient statistical quality is
          reached.

       The notion of “sufficient statistical quality” is based on heuristics.  The intent is that <b>futhark</b>  <b>bench</b>
       will  in  most cases do <u>the</u> <u>right</u> <u>thing</u> by default, both when benchmarking both long-running programs and
       short-running  programs.   If  you  want  complete  control,   disable   the   convergence   phase   with
       <b>--no-convergence-phase</b> and set the number of runs you want with <b>-r</b>.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>--backend=</b><u>name</u>
              The backend used when compiling Futhark programs (without leading <b>futhark</b>, e.g. just <b>opencl</b>).

       <b>--cache-extension=</b><u>EXTENSION</u>
              For  a  program  <b>foo.fut</b>,  pass  <b>--cache-file</b>  <b>foo.fut.EXTENSION</b>.  By default, <b>--cache-file</b> is not
              passed.

       <b>--concurrency=</b><u>NUM</u>
              The number of benchmark programs to  prepare  concurrently.   Defaults  to  the  number  of  cores
              available.   <u>Prepare</u>  means to compile the benchmark, as well as generate any needed datasets.  In
              some cases, this generation can take too much memory, in which  case  lowering  <b>--concurrency</b>  may
              help.

       <b>--convergence-max-seconds=</b><u>NUM</u>
              Don’t  run  the  convergence phase for longer than this.  This does not mean that the measurements
              have converged.  Defaults to 300 seconds (five minutes).

       <b>--entry-point=</b><u>name</u>
              Only run entry points with this name.

       <b>--exclude-case=</b><u>TAG</u>
              Do not run test cases that contain the given tag.  Cases  marked  with  “nobench”,  “disable”,  or
              “no_foo” (where <u>foo</u> is the backend used) are ignored by default.

       <b>--futhark=</b><u>program</u>
              The  program used to perform operations (eg. compilation).  Defaults to the binary running <b>futhark</b>
              <b>bench</b> itself.

       <b>--ignore-files=</b><u>REGEX</u>
              Ignore files whose path match the given regular expression.

       <b>--json=</b><u>file</u>
              Write raw results in JSON format to the specified file.

       <b>--no-tuning</b>
              Do not look for tuning files.

       <b>--no-convergence-phase</b>
              Do not run the convergence phase.

       <b>--pass-option=</b><u>opt</u>
              Pass an option to benchmark programs that are being run.  For example, we might want to run OpenCL
              programs on a specific device:

                 futhark bench prog.fut --backend=opencl --pass-option=-dHawaii

       <b>--pass-compiler-option=</b><u>opt</u>
              Pass an extra option to the compiler when compiling the programs.

       <b>--profile</b>
              Enable profiling for the binary (by passing <b>--profiling</b> and  <b>--logging</b>)  and  store  the  recorded
              information in the file indicated by <b>--json</b> (which is required), along with the other benchmarking
              results.

       <b>--runner=</b><u>program</u>
              If  set  to  a non-empty string, compiled programs are not run directly, but instead the indicated
              <u>program</u> is run with its first argument being the path to the compiled Futhark  program.   This  is
              useful  for compilation targets that cannot be executed directly (as with <u>futhark-pyopencl</u> on some
              platforms), or when you wish to run the program on a remote machine.

       <b>--runs=</b><u>count</u>
              The number of runs per data set.

       <b>--skip-compilation</b>
              Do not run the compiler, and instead assume that each benchmark program has already been  compiled
              into a server-mode executable. Use with caution.

       <b>--spec-file=</b><u>FILE</u>
              Ignore  the test specification in the program file(s), and instead load them from this other file.
              These external test specifications use the  same  syntax  as  normal,  but  <u>without</u>  line  comment
              prefixes.  A <b>==</b> is still expected.

       <b>--timeout=</b><u>seconds</u>
              If  the  runtime  for a dataset exceeds this integral number of seconds, it is aborted.  Note that
              the time is allotted not <u>per</u> <u>run</u>, but for <u>all</u> <u>runs</u> for a dataset.  A twenty second limit  for  ten
              runs thus means each run has only two seconds (minus initialisation overhead).

              A negative timeout means to wait indefinitely.

       <b>-v</b>, <b>--verbose</b>
              Print  verbose information about what the benchmark is doing.  Pass multiple times to increase the
              amount of information printed.

       <b>--tuning=</b><u>EXTENSION</u>
              For each program being run, look for a tuning file with this extension, which is suffixed  to  the
              name  of  the program.  For example, given <b>--tuning=tuning</b> (the default), the program <b>foo.fut</b> will
              be passed the tuning file <b>foo.fut.tuning</b> if it exists.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following program benchmarks how quickly we can sum arrays of different sizes:

          -- How quickly can we reduce arrays?
          --
          -- ==
          -- nobench input { 0i64 }
          -- output { 0i64 }
          -- input { 100i64 }
          -- output { 4950i64 }
          -- compiled input { 10000i64 }
          -- output { 49995000i64 }
          -- compiled input { 1000000i64 }
          -- output { 499999500000i64 }

          let main(n: i64): i64 =
            reduce (+) 0 (iota n)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>futhark-c</u>, <u>futhark-test</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2013-2020, DIKU, University of Copenhagen

0.25.27                                           Mar 02, 2025                                  <u><a href="../man1/FUTHARK-BENCH.1.html">FUTHARK-BENCH</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>