<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pvm_shmd - PVM shared memory (2) daemon</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pvm-dev">pvm-dev_3.4.6-3.2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pvm_shmd - PVM shared memory (2) daemon

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>pvm_shmd</b> <b>[</b> <b>-options</b> <b>]</b> <b>[</b> <b>hostfile</b> <b>]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Pvm_shmd</u>  is  a  daemon  process which maintains and handles the usage of shared memory resources (memory
       segments, semaphores, message queues) on a particular PVM host.  One <u>pvm_shmd</u> must run on each host in  a
       virtual  machine that wants to use the shmd shared memory message passing layer. The <u>shmd</u> message passing
       layer allows local processes to a host to use shared memory for message passing on that  host  ONLY.  See
       the shmd directory README for further notes and restrictions.

       The daemon can be started manually as with any other PVM task.  Only one <u>pvm_shmd</u> can be active per host.
       If the <u>pvm_shmd</u> detects another <u>pvm_shmd</u> it will shutdown.

       The  <u>pvm_shmd</u>  can be killed from the PVM console by using the reset command.  Local and remote pvm_shmds
       can also be started from the PVM console program <u>pvm</u>.

       The name of the daemon executable is <u>pvm_shmd</u>.

</pre><h4><b>Shared</b> <b>Resource</b> <b>Usage</b></h4><pre>
       The <u>pvm_shmd</u> will attempt to create upto <u>MAXSEG</u> shared memory segments of upto <u>MAXPAGES</u> memory  pages  in
       size. The size of each memory page is architecture dependent(see <a href="../man3C/getpagesize.3C.html">getpagesize</a>(3C)).  The segments are then
       numbered  0..N-1 where N is the number of segments created.  The first segement (0) has the shared memory
       control structure placed in its head. This structure allows alien processes to located the  other  shared
       memory segments and any required controlling information.

       The  message  passing  layer, allocates memory from these segments asynchronously without any interaction
       with the <u>pvm_shmd</u> using semaphores to protect data during updates to any associated structures.  For each
       segment there is an associated page map of which processes have currently locked a page.  Each  page  map
       for  a segment has a separate semaphore protecting it. The semaphores are accessed with the SEM_UNDO flag
       set so that if  a  process  holding  a  semaphore  should  die,  the  OS  (should)  reset  the  semaphore
       automatically, thus allowing any waiting/blocked processes to continue.

       The  <u>pvm_shmd</u>  only maintains the segments and their allocation page map(s).  Thus if a process allocated
       pages in a segment and then exits, it is the <u>pvm_shmd</u> that detects this  and  then  frees  the  allocated
       pages.

       The  <u>pvm_shmd</u>  can have its status checked at any time by using the <u>pvm_shmd_stat</u> process to kick it into
       reporting onto either stdio or the pvm log file (pvml.uid) its internal state.

       The shared memory and all associated processes can be cleared by sending the <u>pvm_shmd</u> a HUP signal.

       Sending the <u>pvm_shmd</u> a TERM signal will just cause it to clear any shared resources and then exit.

       The <u>pvm_shmd</u> cannot catch the KILL signal.

       If the <u>pvm_shmd</u> is killed without clearing all of its shared resources these can be  cleared  by  calling
       <u>ipcfree</u> which resides in the pvm3/lib directory.

</pre><h4><b>Message</b> <b>Passing</b> <b>using</b> <b>SHMD</b></h4><pre>
       The <u>pvm_shmd</u> handles resources that are used by special versions of pvm_psend() and pvm_precv() stored in
       the libpvmshmd.a library. Thus to use these facilities, applications have to link to this library instead
       of the usual libpvm3.a library.

</pre><h4><b>OPTIONS</b></h4><pre>
       The following options may be specified on the command line when starting the pvm_shmd:

       -debug=<u>level</u>
               Sets the <u>pvm_shmd</u> debug level.  Used to debug the pvm_shmd or libpvmshmd (not intended to be used
               to debug application programs).

       -maxsegs=<u>maxsegs</u>
               Sets  the  maximum number of segments that the <u>pvm_shmd</u> can create. This is used to over-ride the
               compiled in value from shmd.h. Note that the value cannot be above  the  MAXSEGS  in  the  shmd.h
               file.

       -maxpages=<u>maxpages</u>
               Sets  the  maximum  segment  size  to  <u>maxpages</u>  pages  of memory. This value cannot be above the
               compiled value MAXPAGES in shmd.h or the actual OS defined limit.

</pre><h4><b>NOTES</b></h4><pre>
       Remember that <u>pvm_shmd</u> allocated memory from the VM available on the machine. Allocating  more  segements
       improves  performance as there is less sharing of segments (semaphores for their page maps). Although you
       must remember to leave some memory available for normal program and OS  system  usage,  as  the  <u>pvm_shmd</u>
       allocated memory is *ONLY* used for message passing.

</pre><h4><b>FILES</b></h4><pre>
         $PVM_ROOT/lib/$PVM_ARCH/pvm_shmd PVM shared memory daemon executable
         $PVM_ROOT/shmd/shmd.h Shared Memory hard limits header file
         /tmp/pvml.<u>uid</u> Pvmd runtime error log

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1PVM/pvm.1PVM.html">pvm</a>(1PVM), <a href="../man1PVM/pvmd.1PVM.html">pvmd</a>(1PVM), <a href="../man3C/getpagesize.3C.html">getpagesize</a>(3C), <a href="../man1/ipcs.1.html">ipcs</a>(1), <a href="../man2/msgctl.2.html">msgctl</a>(2), <a href="../man2/semctl.2.html">semctl</a>(2), <a href="../man2/shmctl.2.html">shmctl</a>(2), <a href="../man5/signal.5.html">signal</a>(5)

G.E.Fagg                                         11 March, 1999                                   <u><a href="../man1PVM/PVM_SHMD.1PVM.html">PVM_SHMD</a></u>(1PVM)
</pre>
 </div>
</div></section>
</div>
</body>
</html>