<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fst-compiler, fst-compiler-utf8 - Two compilers for SFST programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/sfst">sfst_1.7.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fst-compiler, fst-compiler-utf8 - Two compilers for SFST programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>fst-compiler</b> <u>grammar-file</u> [ <u>output-file</u> ]
       <b>fst-compiler-utf8</b> <u>grammar-file</u> [ <u>output-file</u> ]

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-c</b>     Store the transducer in compact format which is used by fst-infl2.

       <b>-l</b>     Store the transducer in lowmem format.

       <b>-s</b>     Switch  surface  and analysis layer of the transducer. You have to use this switch in order to use
              <u>fst-infl</u> <u>(fst-infl2,</u> <u>fst-infl3)</u> for generation rather than analysis.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>fst-compiler</b> is a compiler for finite-state transducer programs. It generates a  minimized  finite  state
       transducer  which can be used with <u>fst-mor,</u> <u>fst-infl,</u> <u>fst-print,</u> <u>fst-compare,</u> <u>fst-parse,</u> and <u>fst-lattice.</u>
       The compact transducer representation which is generated with the -c flag,  is  supported  by  <u>fst-infl2,</u>
       <u>fst-train,</u>  and <u>fst-match.</u>  The memory-efficient transducer representation which is generated with the -l
       flag, is only supported by <u>fst-infl3.</u>

       The first program argument is the name of a file which contains the transducer program.  The  programming
       language  is  described  below.  The  second  argument  is  the  name  of the file to which the resulting
       transducer will be written in binary form. If a second argument is missing, the output will be written to
       <u>stdout.</u>

       <u>fst-compiler-utf8</u> differs from <u>fst-compiler</u> only in the character encoding.   <u>fst-compiler-utf8</u>  supports
       UTF8  encoding  of  the  source  files  whereas <u>fst-compiler</u> is to be used for 8-Bit character codes like
       latin1 which are an extension of the ASCII  code.  Information  about  the  encoding  is  stored  in  the
       transducer files and used by the other SFST programs.

</pre><h4><b>FILE</b> <b>FORMATS</b></h4><pre>
       A  transducer program consists of an (optional) sequence of <u>alphabet</u> and <u>variable</u> definitions followed by
       a single <u>transducer</u> <u>expression</u> which defines the result transducer.

       Alphabet

       An alphabet definition consists of the keyword ALPHABET followed by = and some transducer expression e.g.

           ALPHABET = [a-z]:[A-Z]

       This command redefines the alphabet as the set of symbol  pairs  occurring  on  the  transitions  of  the
       transducer. Occurrences of two-level operators, negation operators and unquoted periods always have to be
       preceded by an alphabet definition.

       Variables

       There are two different types of variables.  <u>Symbol</u> <u>set</u> <u>variables</u> are enclosed by hash signs (#) and take
       symbol sequences (see below) as values:

           #UC# = A-Z
           #LC# = a-z

       <u>Transducer</u> <u>variables</u> are enclosed by dollar signs and take transducer expressions as values:

           $MAP$ = [a-z]:[A-Z]+
           $MAP$ = [#LC#]:[#UC#]+

       Variables whose name starts with the symbol `=' are special <u>agreement</u> variables. If an agreement variable
       occurs  more  than  once  in  a  transducer  expression, it will always have the same value. Consider the
       following transducer program:

           $=1$ = [abc]
           $=1$ X $=1$

       The result transducer  recognizes  the  strings  aXa,  bXb,  and  cXc.  Only  acyclic  transducers  (i.e.
       transducers with a finite set of string mappings) can be assigned to agreement variables.

       Symbols

       A symbol is either

       - a single character like A s 5,

       - a quoted character like \* or \_,

       - a multi-character symbol like &lt;X&gt; or &lt;ab.c5&gt; (which is always
         enclosed in angle brackets) or

       - a backslash followed by a number which is the numeric code of the
         designated character

       - the null symbol &lt;&gt;.

       Symbol sequence

       A  symbol sequence is a sequence of characters, multi-character symbols and character ranges, e.g. a-z \.
       &lt;x&gt;.

       symbol range

       A symbol range is either

       - a single symbol

       - a symbol sequence enclosed in square brackets like [A-Za-z] or

       - a symbol sequence starting with ^ and enclosed in  square  brackets  like  [^A-Za-z]  (designating  the
       complement of [a-zA-Z]) or

       - the period (which represents any symbol from the alphabet)

       Transducer expressions

       A transducer expression (TE) is recursively defined as follows:

       - A pair of two symbol ranges separated by a colon is a TE.

         [a-z]:[a-Z]

       - A single symbol range like [a-z] is a TE.
        It is a short form for [a-z]:[a-z].

       - Two symbol sequences enclosed in braces and separated by a colon are
        a TE. {a[bc]}:{def} is equivalent to a:d b:e &lt;&gt;:f | a:d c:e &lt;&gt;:f.

       - X Y is a TE if X and Y are TEs.
        (Blanks are ignored unless they are quoted.)

       - (X) is a TE if X is a TE.

       - X op is a TE is X is a TE and op is either * (Kleene's star operator), +
        (Kleene's plus operator), or ? (optionality operator)

       - op X is a TE is X is a TE and op is either ! (negation operator), ^
        (target language extraction operator), _ (source language extraction operator), or ^_ (source and target
        switch operator).

       - X op Y is a TE is X and Y are TEs and op is either &amp; (conjunction
        operator), | (disjunction operator), || (composition operator), or - (subtraction operator)

       - L x op y R is a TE if L and R are TEs, x and y are symbol ranges and
        op  is  either  =&gt;  (two-level  restriction), &lt;= (two-level coercion), or &lt;=&gt; (two-level restriction and
        coercion).

       - X op L__R is a TE if X, L and R are TEs and op is either ^-&gt; (upward
        replacement), _-&gt; (downward replacement), /-&gt; (leftward replacement)  or  \-&gt;  (rightward  replacement).
        Furthermore,  L  and  R  must  define  automata  (i.e.  which  map their strings onto themselves). These
        operators correspond to Karttunen's replace operators. If the arrow is followed by a question mark  (?),
        the replacement becomes optional.

       - X &lt;&lt; l is a TE if X is a TE, and l is either of the form
        a or the form a:b where a and b are single characters or symbols. The result is a transducer where l was
        freely inserted into X. The transducer ab &lt;&lt; c for instance is equivalent to c*ac*bc*.

       - X op Y L1__R2, ... , LN__RN is a TE if X,Y, L1 through LN and R1
        through  RN  are  TEs,  and  op  is either =&gt; (general restriction), &lt;= (general coercion), ^=&gt; (general
        surface restriction), ^&lt;= (general surface coercion), ^&lt;=&gt; (general surface restriction  and  coercion),
        _=&gt;  (general  deep  restriction),  _&lt;=  (general  deep  coercion),  _&lt;=&gt;  (general deep restriction and
        coercion). (These operators were implemented following a suggestion by Anssi Yli-Jyra.)

       - "fname" is a TE. The compiler reads the file named fname and turns
        it into a transducer of the form line1|line2|line3|... where linex is the x-th line  of  the  file.  All
        characters  other  than  : and \ are interpreted literally (i.e. not as operators). This TE is typically
        used e.g. to read morpheme list from a file.

       - "&lt;fname&gt;" is a TE. The compiler reads a pre-compiled transducer from
        the file named fname. This

       Further Features

       Comments start with the symbol % and extend up to the end of the line.  Blanks are  ignored  unless  they
       are quoted. Expressions terminate at the end of a line unless the end of line is preceded by a backslash.
       The command

       #include "fname"

       can be used to insert source code from a file named fname.  The command

       RE &gt;&gt; "fname"

       stores the regular expression RE in the file fname.  The command

       #use hopcroft

       tells the compiler to use the Hopcroft minimisation algorithm from now on, and

       #use default

       switches back to the default minimisation algorithm (Brzozowski).  The command

</pre><h4><b>EXAMPLE</b></h4><pre>
       Here  is  an  example of a simple transducer program. Assuming that the file "adj-stems" contains the two
       lines

          easy
          late
          big

       this transducer will correctly analyze the adjective forms easy, easier, easiest  and  late,  later,  and
       latest.

       ALPHABET = [a-zA-Z] y:i e:&lt;&gt; &lt;ADJ&gt;:&lt;&gt;

       $R$ = y&lt;=&gt;i (&lt;ADJ&gt;:&lt;&gt; e)

       $R2$ = e&lt;=&gt;&lt;&gt; (&lt;ADJ&gt;:&lt;&gt; e)

       $R$ = $R$ &amp; $R2$

       $Stems$ = "adj-stems"

       $S$ = $Stems$ &lt;ADJ&gt; (&lt;pos&gt;:&lt;&gt;|&lt;cmp&gt;:{er}|&lt;sup&gt;:{est})

       $S$ || $R$

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       <b>fst-compiler</b> returns 0 unless some error occurs.

</pre><h4><b>BUGS</b></h4><pre>
       The  compiler gets the operator precedence wrong in case of two-level rules and interprets the expression
       "ab c&lt;=&gt;d ef" as "a(b c&lt;=&gt;d (ef))". Therefore, you should always surround the left context  of  two-level
       rules with parenthesis: (ab) c&lt;=&gt;d (ef)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       fst-mor,  fst-infl,  fst-infl2,  fst-infl3,  fst-print, fst-compact, fst-parse, fst-compare, fst-compact,
       fst-lowmem, fst-lattice, fst-train

</pre><h4><b>AUTHOR</b></h4><pre>
       Helmut Schmid, Institute for Computational Linguistics, University of Stuttgart,  Email:  <a href="mailto:schmid@ims.uni">schmid@ims.uni</a>-
       stuttgart.de, This software is available under the GNU Public License.

                                                  December 2004                                  <u><a href="../man1/fst-compiler.1.html">fst-compiler</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>