<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>postfwd2 - postfix firewall daemon</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/postfwd">postfwd_1.35-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       postfwd2 - postfix firewall daemon

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>postfwd2</b> [OPTIONS] [SOURCE1, SOURCE2, ...]

               Ruleset: (at least one, multiple use is allowed):
               -f, --file &lt;file&gt;               reads rules from &lt;file&gt;
               -r, --rule &lt;rule&gt;               adds &lt;rule&gt; to config
               -s, --scores &lt;v&gt;=&lt;r&gt;            returns &lt;r&gt; when score exceeds &lt;v&gt;

               Server:
               -i, --interface &lt;dev&gt;           listen on interface &lt;dev&gt;
               -p, --port &lt;port&gt;               listen on port &lt;port&gt;
                   --proto &lt;proto&gt;             socket type (tcp or unix)
                   --server_socket &lt;sock&gt;      e.g. tcp:127.0.0.1:10045
               -u, --user &lt;name&gt;               set uid to user &lt;name&gt;
               -g, --group &lt;name&gt;              set gid to group &lt;name&gt;
                   --umask &lt;mask&gt;              umask for master filepermissions
                   --server_umask &lt;mask&gt;       umask for server filepermissions
                   --pidfile &lt;path&gt;            create pidfile under &lt;path&gt;
                   --min_servers &lt;i&gt;           spawn at least &lt;i&gt; children
                   --max_servers &lt;i&gt;           do not spawn more than &lt;i&gt; children
                   --min_spare_servers &lt;i&gt;     minimum idle children
                   --max_spare_servers &lt;i&gt;     maximum idle children

               Cache:
               -c, --cache &lt;int&gt;               sets the request-cache timeout to &lt;int&gt; seconds
                   --cleanup-requests &lt;int&gt;    cleanup interval in seconds for request cache
                   --cache_interface &lt;dev&gt;     listen on interface &lt;dev&gt;
                   --cache_port &lt;port&gt;         listen on port &lt;port&gt;
                   --cache_proto &lt;proto&gt;       socket type (tcp or unix)
                   --cache_socket &lt;sock&gt;       e.g. tcp:127.0.0.1:10043
                   --cache_umask &lt;mask&gt;        umask for cache filepermissions
                   --cacheid &lt;list&gt;            list of request items for cache-id
                   --cache-rdomain-only        skip recipient localpart for cache-id
                   --cache-no-sender           skip sender address for cache-id
                   --cache-no-size             skip size for cache-id
                   --no_parent_request_cache   disable parent request cache
                   --no_parent_rate_cache      disable parent rate cache
                   --no_parent_dns_cache       disable parent dns cache (default)
                   --no_parent_cache           disable all parent caches

               Rates:
                   --cleanup-rates &lt;int&gt;       cleanup interval in seconds for rate cache

               Control:
               -k, --kill, --stop              terminate postfwd2
                   --reload, --hup             reload postfwd2
                   --watchdog &lt;w&gt;              watchdog timer in seconds
                   --respawn &lt;r&gt;               respawn delay in seconds
                   --failures &lt;f&gt;              max respawn failure counter
                   --daemons &lt;list&gt;            list of daemons to start
                   --dumpcache                 show cache contents
                   --dumpstats                 show statistics
               -R, --chroot &lt;path&gt;             chroot to &lt;path&gt; before start
                   --delcache &lt;item&gt;           removes an item from the request cache
                   --delrate &lt;item&gt;            removes an item from the rate cache

               DNS:
               -n, --nodns                     skip any dns based test
                   --dns_timeout &lt;i&gt;           dns query timeout in seconds
                   --dns_timeout_max &lt;i&gt;       disable dnsbl after &lt;i&gt; timeouts
                   --dns_timeout_interval &lt;i&gt;  re-enable dnsbl after &lt;i&gt; seconds
                   --cache-rbl-timeout &lt;i&gt;     default dns ttl if not specified in ruleset
                   --cache-rbl-default &lt;s&gt;     default dns pattern if not specified in ruleset
                   --cleanup-rbls &lt;i&gt;          cleanup old dns cache items every &lt;i&gt; seconds
                   --dns_async_txt             perform dnsbl A and TXT lookups simultaneously
                   --dns_max_ns_lookups        max names to look up with sender_ns_addrs
                   --dns_max_mx_lookups        max names to look up with sender_mx_addrs

               Optional:
               -t, --test                      testing, always returns "dunno"
               -S, --summary &lt;i&gt;               show stats every &lt;i&gt; seconds
                   --noidlestats               disables statistics when idle
                   --norulestats               disables per rule statistics
               -I, --instantcfg                reloads ruleset on every new request
                   --config_timeout &lt;i&gt;        parser timeout in seconds
                   --keep_rates                do not clear rate limit counters on reload
                   --save_rates &lt;file&gt;         save and load rate limits on disk
                   --fast_limit_evaluation     evaluate rate limits before ruleset is parsed
                                               (please note the limitations)

               Plugins:
                   --plugins &lt;file&gt;            loads postfwd plugins from file

               Logging:
               -l, --logname &lt;label&gt;           label for syslog messages
                   --facility &lt;s&gt;              use syslog facility &lt;s&gt;
                   --socktype &lt;s&gt;              use syslog socktype &lt;s&gt;
                   --nodnslog                  do not log dns results
                   --anydnslog                 log any dns (even cached) results
                   --norulelog                 do not log rule actions
                   --nolog|--perfmon           no logging at all
               -v, --verbose                   verbose logging, use twice to increase
                   --debug &lt;s&gt;                 list of debugging classes

               Information (use only at command-line!):
               -h, --help                      display this help and exit
               -m, --manual                    shows program manual
               -V, --version                   output version information and exit
               -D, --defaults                  show postfwd2 settings and exit
               -C, --showconfig                show postfwd2 ruleset and exit (-v allowed)
               -L, --stdout                    redirect syslog messages to stdout
               -q, --quiet                     no syslogging, no stdout (-P works for compatibility)

               Obsolete (only for compatibility with postfwd v1):
               -d|--daemon, --shortlog, --dns_queuesize, --dns_retries

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>INTRODUCTION</b>
       postfwd2 is written to combine complex postfix restrictions in a ruleset similar to those of the most
       firewalls.  The program uses the postfix policy delegation protocol to control access to the mail system
       before a message has been accepted (please visit &lt;<a href="http://www.postfix.org/SMTPD_POLICY_README.html">http://www.postfix.org/SMTPD_POLICY_README.html</a>&gt; for
       more information).

       postfwd2 allows you to choose an action (e.g. reject, dunno) for a combination of several smtp parameters
       (like sender and recipient address, size or the client's TLS fingerprint). Also it offers simple
       macros/acls which should allow straightforward and easy-to-read configurations.

       <u>Features:</u>

       * Complex combinations of smtp parameters

       * Combined RBL/RHSBL lookups with arbitrary actions depending on results

       * Scoring system

       * Date/time based rules

       * Macros/ACLs, Groups, Negation

       * Compare request attributes (e.g. client_name and helo_name)

       * Internal caching for requests and dns lookups

       * Built in statistics for rule efficiency analysis

   <b>CONFIGURATION</b>
       A configuration line consists of optional item=value pairs, separated by semicolons (`;`) and the
       appropriate desired action:

               [ &lt;item1&gt;=&lt;value&gt;; &lt;item2&gt;=&lt;value&gt;; ... ] action=&lt;result&gt;

       <u>Example:</u>

               client_address=192.168.1.1 ; sender==<a href="mailto:no@bad.local">no@bad.local</a> ; action=REJECT

       This will deny all mail from 192.168.1.1 with envelope sender <a href="mailto:no@bad.local">no@bad.local</a>. The order of the elements is
       not important. So the following would lead to the same result as the previous example:

               action=REJECT ; client_address=192.168.1.1 ; sender==<a href="mailto:no@bad.local">no@bad.local</a>

       The way how request items are compared to the ruleset can be influenced in the following way:

               ====================================================================
                ITEM == VALUE                true if ITEM equals VALUE
                ITEM =&gt; VALUE                true if ITEM &gt;= VALUE
                ITEM =&lt; VALUE                true if ITEM &lt;= VALUE
                ITEM &gt;  VALUE                true if ITEM &gt;  VALUE
                ITEM &lt;  VALUE                true if ITEM &lt;  VALUE
                ITEM =~ VALUE                true if ITEM ~= /^VALUE$/i
                ITEM != VALUE                false if ITEM equals VALUE
                ITEM !&gt; VALUE                false if ITEM &gt;= VALUE
                ITEM !&lt; VALUE                false if ITEM &lt;= VALUE
                ITEM !~ VALUE                false if ITEM ~= /^VALUE$/i
                ITEM =  VALUE                default behaviour (see ITEMS section)
               ====================================================================

       To identify single rules in your log files, you may add an unique identifier for each of it:

               id=R_001 ; action=REJECT ; client_address=192.168.1.1 ; sender==<a href="mailto:no@bad.local">no@bad.local</a>

       You may use these identifiers as target for the `<u>jump()</u>` command (see ACTIONS section below). Leading or
       trailing whitespace characters will be ignored. Use '#' to comment your configuration. Others will
       appreciate.

       A ruleset consists of one or multiple rules, which can be loaded from files or passed as command line
       arguments. Please see the COMMAND LINE section below for more information on this topic.

       Since postfwd version 1.30 rules spanning span multiple lines can be defined by prefixing the following
       lines with one or multiple whitespace characters (or '}' for macros):

               id=RULE001
                       client_address=192.168.1.0/24
                       sender==<a href="mailto:no@bad.local">no@bad.local</a>
                       action=REJECT no access

       postfwd versions prior to 1.30 require trailing ';' and '\'-characters:

               id=RULE001; \
                       client_address=192.168.1.0/24; \
                       sender==<a href="mailto:no@bad.local">no@bad.local</a>; \
                       action=REJECT no access

   <b>ITEMS</b>
               id                      - a unique rule id, which can be used for log analysis
                                         ids also serve as targets for the "jump" command.

               date, time              - a time or date range within the specified rule shall hit
                                         # FORMAT:
                                         # Feb, 29th
                                         date=29.02.2008
                                         # Dec, 24th - 26th
                                         date=24.12.2008-26.12.2008
                                         # from today until Nov, 23rd
                                         date=-23.09.2008
                                         # from April, 1st until today

                                         date=01.04.2008-
               days, months            - a range of weekdays (Sun-Sat) or months (Jan-Dec)
                                         within the specified rule shall hit

               score                   - when the specified score is hit (see ACTIONS section)
                                         the specified action will be returned to postfix
                                         scores are set global until redefined!

               request_score           - this value allows one to access a request's score. it
                                         may be used as variable ($$request_score).

               rbl, rhsbl,             - query the specified RBLs/RHSBLs, possible values are:
               rhsbl_client,             &lt;name&gt;[/&lt;reply&gt;/&lt;maxcache&gt;, &lt;name&gt;/&lt;reply&gt;/&lt;maxcache&gt;]
               rhsbl_sender,             (defaults: reply=^127\.0\.0\.\d+$ maxcache=3600)
               rhsbl_reverse_client      the results of all rhsbl_* queries will be combined
                                         in rhsbl_count (see below).

               rblcount, rhsblcount    - minimum RBL/RHSBL hitcounts to match. if not specified
                                         a single RBL/RHSBL hit will match the rbl/rhsbl items.
                                         you may specify 'all' to evaluate all items, and use
                                         it as variable in an action (see ACTIONS section)
                                         (default: 1)

               sender_localpart,       - the local-/domainpart of the sender address
               sender_domain

               recipient_localpart,    - the local-/domainpart of the recipient address
               recipient_domain

               helo_address            - postfwd2 tries to look up the helo_name. use
                                         helo_address=!!(0.0.0.0/0) to check for unknown.
                                         Please do not use this for positive access control
                                         (whitelisting), as it might be forged.

               sender_ns_names,        - postfwd2 tries to look up the names/ip addresses
               sender_ns_addrs           of the nameservers for the sender domain part.
                                         Please do not use this for positive access control
                                         (whitelisting), as it might be forged.

               sender_mx_names,        - postfwd2 tries to look up the names/ip addresses
               sender_mx_addrs           of the mx records for the sender domain part.
                                         Please do not use this for positive access control
                                         (whitelisting), as it might be forged.

               version                 - postfwd2 version, contains "postfwd2 n.nn"
                                         this enables version based checks in your rulesets
                                         (e.g. for migration). works with old versions too,
                                         because a non-existing item always returns false:
                                         # version &gt;= 1.10
                                         id=R01; version~=1\.[1-9][0-9]; sender_domain==some.org \
                                               ; action=REJECT sorry no access

               ratecount               - only available for rate(), size() and rcpt() actions.
                                         contains the actual limit counter:
                                               id=R01; action=rate(sender/200/600/REJECT limit of 200 exceeded [$$ratecount hits])
                                               id=R02; action=rate(sender/100/600/WARN limit of 100 exceeded [$$ratecount hits])

       Besides these you can specify any attribute of the postfix policy delegation protocol.  Feel free to
       combine them the way you need it (have a look at the EXAMPLES section below).

       Most values can be specified as regular expressions (PCRE). Please see the table below for details:

               # ==========================================================
               # ITEM=VALUE                            TYPE
               # ==========================================================
               id=something                            mask = string
               date=01.04.2007-22.04.2007              mask = date (DD.MM.YYYY-DD.MM.YYYY)
               time=08:30:00-17:00:00                  mask = time (HH:MM:SS-HH:MM:SS)
               days=Mon-Wed                            mask = weekdays (Mon-Wed) or numeric (1-3)
               months=Feb-Apr                          mask = months (Feb-Apr) or numeric (1-3)
               score=5.0                               mask = maximum floating point value
               rbl=zen.spamhaus.org                    mask = &lt;name&gt;/&lt;reply&gt;/&lt;maxcache&gt;[,...]
               rblcount=2                              mask = numeric, will match if rbl hits &gt;= 2
               helo_address=&lt;a.b.c.d/nn&gt;               mask = CIDR[,CIDR,...]
               sender_ns_names=some.domain.tld         mask = PCRE
               sender_mx_names=some.domain.tld         mask = PCRE
               sender_ns_addrs=&lt;a.b.c.d/nn&gt;            mask = CIDR[,CIDR,...]
               sender_mx_addrs=&lt;a.b.c.d/nn&gt;            mask = CIDR[,CIDR,...]
               # ------------------------------
               # Postfix version 2.1 and later:
               # ------------------------------
               client_address=&lt;a.b.c.d/nn&gt;             mask = CIDR[,CIDR,...]
               client_name=another.domain.tld          mask = PCRE
               reverse_client_name=another.domain.tld  mask = PCRE
               helo_name=some.domain.tld               mask = PCRE
               sender=<a href="mailto:foo@bar.tld">foo@bar.tld</a>                      mask = PCRE
               recipient=<a href="mailto:bar@foo.tld">bar@foo.tld</a>                   mask = PCRE
               recipient_count=5                       mask = numeric, will match if recipients &gt;= 5
               # ------------------------------
               # Postfix version 2.2 and later:
               # ------------------------------
               sasl_method=plain                       mask = PCRE
               sasl_username=you                       mask = PCRE
               sasl_sender=                            mask = PCRE
               size=12345                              mask = numeric, will match if size &gt;= 12345
               ccert_subject=blackhole.nowhere.local   mask = PCRE (only if tls verified)
               ccert_issuer=John+20Doe                 mask = PCRE (only if tls verified)
               ccert_fingerprint=AA:BB:CC:DD:EE:...    mask = PCRE (do NOT use "..." here)
               # ------------------------------
               # Postfix version 2.3 and later:
               # ------------------------------
               encryption_protocol=TLSv1/SSLv3         mask = PCRE
               encryption_cipher=DHE-RSA-AES256-SHA    mask = PCRE
               encryption_keysize=256                  mask = numeric, will match if keysize &gt;= 256
               ...

       the current list can be found at &lt;<a href="http://www.postfix.org/SMTPD_POLICY_README.html">http://www.postfix.org/SMTPD_POLICY_README.html</a>&gt;. Please read carefully
       about which attribute can be used at which level of the smtp transaction (e.g. size will only work
       reliably at END-OF-MESSAGE level).  Pattern matching is performed case insensitive.

       Multiple use of the same item is allowed and will compared as logical OR, which means that this will work
       as expected:

               id=TRUST001; action=OK; encryption_keysize=64
                       ccert_fingerprint=11:22:33:44:55:66:77:88:99
                       ccert_fingerprint=22:33:44:55:66:77:88:99:00
                       ccert_fingerprint=33:44:55:66:77:88:99:00:11
                       sender=@domain\.local$

       client_address, rbl and rhsbl items may also be specified as whitespace-or-comma-separated values:

               id=SKIP01; action=dunno
                       client_address=192.168.1.0/24, 172.16.254.23
               id=SKIP02; action=dunno
                       client_address= 10.10.3.32 10.216.222.0/27

       The following items must be unique:

               id, minimum and maximum values, rblcount and rhsblcount

       Any item can be negated by preceding '!!' to it, e.g.:

               id=HOST001 ;  hostname == !!secure.trust.local ;  action=REJECT only secure.trust.local please

       or using the right compare operator:

               id=HOST001 ;  hostname != secure.trust.local ;  action=REJECT only secure.trust.local please

       To avoid confusion with regexps or simply for better visibility you can use '!!(...)':

               id=USER01 ;  sasl_username =~ !!( /^(bob|alice)$/ )  ;  action=REJECT who is that?

       Request attributes can be compared by preceding '$$' characters, e.g.:

               id=R-003 ;  client_name = !! $$helo_name      ;  action=WARN helo does not match DNS
               # or
               id=R-003 ;  client_name = !!($$(helo_name))   ;  action=WARN helo does not match DNS

       This is only valid for PCRE values (see list above). The comparison will be performed as case insensitive
       exact match.  Use the '-vv' option to debug.

       These special items will be reset for any new rule:

               rblcount        - contains the number of RBL answers
               rhsblcount      - contains the number of RHSBL answers
               matches         - contains the number of matched items
               dnsbltext       - contains the dns TXT part of all RBL and RHSBL replies in the form
                                 rbltype:rblname:&lt;txt&gt;; rbltype:rblname:&lt;txt&gt;; ...

       These special items will be changed for any matching rule:

               request_hits    - contains ids of all matching rules

       This means that it might be necessary to save them, if you plan to use these values in later rules:

               # set vals
               id=RBL01 ; rhsblcount=all; rblcount=all
                       action=set(HIT_rhls=$$rhsblcount,HIT_rbls=$$rblcount,HIT_txt=$$dnsbltext)
                       rbl=list.dsbl.org, bl.spamcop.net, dnsbl.sorbs.net, zen.spamhaus.org
                       rhsbl_client=rddn.dnsbl.net.au, rhsbl.ahbl.org, rhsbl.sorbs.net
                       rhsbl_sender=rddn.dnsbl.net.au, rhsbl.ahbl.org, rhsbl.sorbs.net

               # compare
               id=RBL02 ; HIT_rhls&gt;=1 ; HIT_rbls&gt;=1 ; action=554 5.7.1 blocked using $$HIT_rhls RHSBLs and $$HIT_rbls RBLs [INFO: $$HIT_txt]
               id=RBL03 ; HIT_rhls&gt;=2               ; action=554 5.7.1 blocked using $$HIT_rhls RHSBLs [INFO: $$HIT_txt]
               id=RBL04 ; HIT_rbls&gt;=2               ; action=554 5.7.1 blocked using $$HIT_rbls RBLs [INFO: $$HIT_txt]

   <b>FILES</b>
       Since postfwd1 v1.15 and postfwd2 v0.18 long item lists can be stored in separate files:

               id=R001 ;  ccert_fingerprint==file:/etc/postfwd/wl_ccerts ;  action=DUNNO

       postfwd2 will read a list of items (one item per line) from /etc/postfwd/wl_ccerts. comments are allowed:

               # client1
               11:22:33:44:55:66:77:88:99
               # client2
               22:33:44:55:66:77:88:99:00
               # client3
               33:44:55:66:77:88:99:00:11

       To use existing tables in key=value format, you can use:

               id=R001 ;  ccert_fingerprint==table:/etc/postfwd/wl_ccerts ;  action=DUNNO

       This will ignore the right-hand value. Items can be mixed:

               id=R002 ;  action=REJECT
                       client_name==unknown
                       client_name==file:/etc/postfwd/blacklisted

       and for non pcre (comma separated) items:

               id=R003 ;  action=REJECT
                       client_address==10.1.1.1, file:/etc/postfwd/blacklisted

               id=R004 ;  action=REJECT
                       rbl=myrbl.home.local, zen.spamhaus.org, file:/etc/postfwd/rbls_changing

       You can check your configuration with the --show_config option at the command line:

               # postfwd2 --showconfig --rule='action=DUNNO; client_address=10.1.0.0/16, file:/etc/postfwd/wl_clients, 192.168.2.1'

       should give something like:

               Rule   0: id-&gt;"R-0"; action-&gt;"DUNNO"; client_address-&gt;"=;10.1.0.0/16, =;194.123.86.10, =;186.4.6.12, =;192.168.2.1"

       If a file can not be read, it will be ignored:

               # postfwd2 --showconfig --rule='action=DUNNO; client_address=10.1.0.0/16, file:/etc/postfwd/wl_clients, 192.168.2.1'
               [LOG warning]: error: file /etc/postfwd/wl_clients not found - file will be ignored ?
               Rule   0: id-&gt;"R-0"; action-&gt;"DUNNO"; client_address-&gt;"=;10.1.0.0/16, =;192.168.2.1"

       File items are evaluated at configuration stage. Therefore postfwd2 needs to be reloaded if a file has
       changed

       If you want to specify a file, that will be reloaded for each request, you can use lfile: and ltable:

               id=R001; client_address=lfile:/etc/postfwd/client_whitelist; action=dunno

       This will check the modification time of /etc/postfwd/client_whitelist every time the rule is evaluated
       and reload it as necessary. Of course this might increase the system load, so please use it with care.

       The --showconfig option illustrates the difference:

               ## evaluated at configuration stage
               # postfwd2 --nodaemon -L --rule='client_address=table:/etc/postfwd/clients; action=dunno' -C
               Rule   0: id-&gt;"R-0"; action-&gt;"dunno"; client_address-&gt;"=;1.1.1.1, =;1.1.1.2, =;1.1.1.3"

               ## evaluated for any rulehit
               # postfwd2 --nodaemon -L --rule='client_address=ltable:/etc/postfwd/clients; action=dunno' -C
               Rule   0: id-&gt;"R-0"; action-&gt;"dunno"; client_address-&gt;"=;ltable:/etc/postfwd/clients"

       Files can refer to other files. The following is valid.

               -- FILE /etc/postfwd/rules.cf --
               id=R01; client_address=file:/etc/postfwd/clients_master.cf; action=DUNNO

               -- FILE /etc/postfwd/clients_master.cf --
               192.168.1.0/24
               file:/etc/postfwd/clients_east.cf
               file:/etc/postfwd/clients_west.cf

               -- FILE /etc/postfwd/clients_east.cf --
               192.168.2.0/24

               -- FILE /etc/postfwd/clients_west.cf --
               192.168.3.0/24

       Note that there is currently no loop detection (/a/file calls /a/file) and that this feature is only
       available with postfwd1 v1.15 and postfwd2 v0.18 and higher.

   <b>ACTIONS</b>
       <u>General</u>

       Actions will be executed, when all rule items have matched a request (or at least one of any item list).
       You can refer to request attributes by preceding $$ characters, like:

               id=R-003; client_name = !!$$helo_name; action=WARN helo '$$helo_name' does not match DNS '$$client_name'
               # or
               id=R-003; client_name = !!$$helo_name; action=WARN helo '$$(helo_name)' does not match DNS '$$(client_name)'

       <u>postfix</u> <u>actions</u>

       Actions will be replied to postfix as result to policy delegation requests. Any action that postfix
       understands is allowed - see "man 5 access" or &lt;<a href="http://www.postfix.org/access.5.html">http://www.postfix.org/access.5.html</a>&gt; for a description.
       If no action is specified, the postfix WARN action which simply logs the event will be used for the
       corresponding rule.

       postfwd2 will return dunno if it has reached the end of the ruleset and no rule has matched. This can be
       changed by placing a last rule containing only an action statement:

               ...
               action=dunno ; sender=@domain.local     # sender is ok
               action=reject                           # default deny

       <u>postfwd2</u> <u>actions</u>

       postfwd2 actions control the behaviour of the program. Currently you can specify the following:

               jump (&lt;id&gt;)
               jumps to rule with id &lt;id&gt;, use this to skip certain rules.
               you can jump backwards - but remember that there is no loop
               detection at the moment! jumps to non-existing ids will be skipped.

               score (&lt;score&gt;)
               the request's score will be modified by the specified &lt;score&gt;,
               which must be a floating point value. the modificator can be either
                       +n.nn   adds n.nn to current score
                       -n.nn   sustracts n.nn from the current score
                       *n.nn   multiplies the current score by n.nn
                       /n.nn   divides the current score through n.nn
                       =n.nn   sets the current score to n.nn
               if the score exceeds the maximum set by `--scores` option (see
               COMMAND LINE) or the score item (see ITEMS section), the action
               defined for this case will be returned (default: 5.0=&gt;"REJECT postfwd2 score exceeded").

               set (&lt;item&gt;=&lt;value&gt;,&lt;item&gt;=&lt;value&gt;,...)
               this command allows you to insert or override request attributes, which then may be
               compared to your further ruleset. use this to speed up repeated comparisons to large item lists.
               please see the EXAMPLES section for more information. you may separate multiple key=value pairs
               by "," characters.

               rate (&lt;item&gt;/&lt;max&gt;/&lt;time&gt;/&lt;action&gt;)
               this command creates a counter for the given &lt;item&gt;, which will be increased any time a request
               containing it arrives. if it exceeds &lt;max&gt; within &lt;time&gt; seconds it will return &lt;action&gt; to postfix.
               rate counters are very fast as they are executed before the ruleset is parsed.
               please note that &lt;action&gt; was limited to postfix actions (no postfwd actions) for postfwd versions &lt;1.33!
                   # no more than 3 requests per 5 minutes
                   # from the same "unknown" client
                   id=RATE01 ;  client_name==unknown
                      action=rate(client_address/3/300/450 4.7.1 sorry, max 3 requests per 5 minutes)

               size (&lt;item&gt;/&lt;max&gt;/&lt;time&gt;/&lt;action&gt;)
               this command works similar to the rate() command with the difference, that the rate counter is
               increased by the request's size attribute. to do this reliably you should call postfwd2 from
               smtpd_end_of_data_restrictions. if you want to be sure, you could check it within the ruleset:
                  # size limit 1.5mb per hour per client
                  id=SIZE01 ;  protocol_state==END-OF-MESSAGE ;  client_address==!!(10.1.1.1)
                     action=size(client_address/1572864/3600/450 4.7.1 sorry, max 1.5mb per hour)

               rcpt (&lt;item&gt;/&lt;max&gt;/&lt;time&gt;/&lt;action&gt;)
               this command works similar to the rate() command with the difference, that the rate counter is
               increased by the request's recipient_count attribute. to do this reliably you should call postfwd
               from smtpd_data_restrictions or smtpd_end_of_data_restrictions. if you want to be sure, you could
               check it within the ruleset:
                  # recipient count limit 3 per hour per client
                  id=RCPT01 ;  protocol_state==END-OF-MESSAGE ;  client_address==!!(10.1.1.1)
                     action=rcpt(client_address/3/3600/450 4.7.1 sorry, max 3 recipients per hour)

               rate5321,size5321,rcpt5321 (&lt;item&gt;/&lt;max&gt;/&lt;time&gt;/&lt;action&gt;)
               same as the corresponding non-5321 functions, with the difference that the localpart of
               sender oder recipient addresses are evaluated case-sensitive according to rfc5321. That
               means that requests from <a href="mailto:bob@example.local">bob@example.local</a> and <a href="mailto:BoB@example.local">BoB@example.local</a> will be treated differently

               ask (&lt;addr&gt;:&lt;port&gt;[:&lt;ignore&gt;])
               allows one to delegate the policy decision to another policy service (e.g. postgrey). the first
               and the second argument (address and port) are mandatory. a third optional argument may be
               specified to tell postfwd2 to ignore certain answers and go on parsing the ruleset:
                  # example1: query postgrey and return it's answer to postfix
                  id=GREY; client_address==10.1.1.1; action=ask(127.0.0.1:10031)
                  # example2: query postgrey but ignore it's answer, if it matches 'DUNNO'
                  # and continue parsing postfwd's ruleset
                  id=GREY; client_address==10.1.1.1; action=ask(127.0.0.1:10031:^dunno$)

               mail(server/helo/from/to/subject/body)
               This command is deprecated. You should try to use the sendmail() action instead.
               Very basic mail command, that sends a message with the given arguments. LIMITATIONS:
               This basically performs a telnet. No authentication or TLS are available. Additionally it does
               not track notification state and will notify you any time, the corresponding rule hits.

               sendmail(sendmail-path::from::to::subject::body)
               Mail command, that uses an existing sendmail binary and sends a message with the given arguments.
               LIMITATIONS: The command does not track notification state and will notify you any time, the
               corresponding rule hits (which could mean 100 mails for a mail with 100 recipients at RCPT stage).

               wait (&lt;delay&gt;)
               pauses the program execution for &lt;delay&gt; seconds. use this for
               delaying or throtteling connections.

               note (&lt;string&gt;)
               just logs the given string and continues parsing the ruleset.
               if the string is empty, nothing will be logged (noop).

               quit (&lt;code&gt;)
               terminates the program with the given exit-code. postfix doesn`t
               like that too much, so use it with care.

       You can reference to request attributes, like

               id=R-HELO ;  helo_name=^[^\.]+$ ;  action=REJECT invalid helo '$$helo_name'

   <b>MACROS/ACLS</b>
       Multiple use of long items or combinations of them may be abbreviated by macros. Those must be prefixed
       by '&amp;&amp;' (two '&amp;' characters).  First the macros have to be defined as follows:

               &amp;&amp;RBLS { rbl=zen.spamhaus.org,list.dsbl.org,bl.spamcop.net,dnsbl.sorbs.net,ix.dnsbl.manitu.net; };

       Then these may be used in your rules, like:

               &amp;&amp;RBLS ;  client_name=^unknown$                         ; action=REJECT
               &amp;&amp;RBLS ;  client_name=(\d+[\.-_]){4}                    ; action=REJECT
               &amp;&amp;RBLS ;  client_name=[\.-_](adsl|dynamic|ppp|)[\.-_]   ; action=REJECT

       Macros can contain actions, too:

               # definition
               &amp;&amp;GONOW { action=REJECT your request caused our spam detection policy to reject this message. More info at <a href="http://www.domain.local">http://www.domain.local</a>; };
               # rules
               &amp;&amp;GONOW ;  &amp;&amp;RBLS ;  client_name=^unknown$
               &amp;&amp;GONOW ;  &amp;&amp;RBLS ;  client_name=(\d+[\.-_]){4}
               &amp;&amp;GONOW ;  &amp;&amp;RBLS ;  client_name=[\.-_](adsl|dynamic|ppp|)[\.-_]

       Macros can contain macros, too:

               # definition
               &amp;&amp;RBLS{
                       rbl=zen.spamhaus.org
                       rbl=list.dsbl.org
                       rbl=bl.spamcop.net
                       rbl=dnsbl.sorbs.net
                       rbl=ix.dnsbl.manitu.net
               };
               &amp;&amp;DYNAMIC{
                       client_name=^unknown$
                       client_name=(\d+[\.-_]){4}
                       client_name=[\.-_](adsl|dynamic|ppp|)[\.-_]
               };
               &amp;&amp;GOAWAY { &amp;&amp;RBLS; &amp;&amp;DYNAMIC; };
               # rules
               &amp;&amp;GOAWAY ; action=REJECT dynamic client and listed on RBL

       Basically macros are simple text substitutions - see the "PARSER" section for more information.

   <b>PLUGINS</b>
       <b>Description</b>

       The plugin interface allow you to define your own checks and enhance postfwd's functionality. Feel free
       to share useful things!

       <b>Warning</b>

       Note that the plugin interface is still at devel stage. Please test your plugins carefully, because
       errors may cause postfwd to break! It is also allowed to override attributes or built-in functions, but
       be sure that you know what you do because some of them are used internally.

       Please keep security in mind, when you access sensible resources and never, ever run postfwd as
       privileged user! Also never trust your input (especially hostnames, and e-mail addresses).

       <b>ITEMS</b>

       Item plugins are perl subroutines which integrate additional attributes to requests before they are
       evaluated against postfwd's ruleset like any other item of the policy delegation protocol. This allows
       you to create your own checks.

       plugin-items can not be used selective. these functions will be executed for every request postfwd
       receives, so keep performance in mind.

               SYNOPSIS: %result = postfwd_items_plugin{&lt;name&gt;}(%request)

       means that your subroutine, called &lt;name&gt;, has access to a hash called %request, which contains all
       request attributes, like $request{client_name} and must return a value in the following form:

               save: $result{&lt;item&gt;} = &lt;value&gt;

       this creates the new item &lt;item&gt; containing &lt;value&gt;, which will be integrated in the policy delegation
       request and therefore may be used in postfwd's ruleset.

               # do NOT remove the next line
               %postfwd_items_plugin = (

                       # EXAMPLES - integrated in postfwd. no need to activate them here.

                               # allows one to check postfwd version in ruleset
                               "version" =&gt; sub {
                                       my(%request) = @_;
                                       my(%result) = (
                                               "version" =&gt; $NAME." ".$VERSION,
                                       );
                                       return %result;
                               },

                               # sender_domain and recipient_domain
                               "address_parts" =&gt; sub {
                                       my(%request) = @_;
                                       my(%result) = ();
                                       $request{sender} =~ /@([^@]*)$/;
                                       $result{sender_domain} = ($1 || '');
                                       $request{recipient} =~ /@([^@]*)$/;
                                       $result{recipient_domain} = ($1 || '');
                                       return %result;
                               },

               # do NOT remove the next line
               );

       <b>COMPARE</b>

       Compare plugins allow you to define how your new items should be compared to the ruleset.  These are
       optional. If you don't specify one, the default (== for exact match, =~ for PCRE, ...)  will be used.

               SYNOPSIS:  &lt;item&gt; =&gt; sub { return &amp;{$postfwd_compare{&lt;type&gt;}}(@_); },

               # do NOT remove the next line
               %postfwd_compare_plugin = (

                       EXAMPLES - integrated in postfwd. no need to activate them here.

                               # Simple example
                               # SYNOPSIS:  &lt;result&gt; = &lt;item&gt; (return &amp;{$postfwd_compare{&lt;type&gt;}}(@_))
                               "client_address"  =&gt; sub { return &amp;{$postfwd_compare{cidr}}(@_); },
                               "size"            =&gt; sub { return &amp;{$postfwd_compare{numeric}}(@_); },
                               "recipient_count" =&gt; sub { return &amp;{$postfwd_compare{numeric}}(@_); },

                               # Complex example
                               # SYNOPSIS:  &lt;result&gt; = &lt;item&gt;(&lt;operator&gt;, &lt;ruleset value&gt;, &lt;request value&gt;, &lt;request&gt;)
                               "numeric" =&gt; sub {
                                       my($cmp,$val,$myitem,%request) = @_;
                                       my($myresult) = undef;  $myitem ||= "0"; $val ||= "0";
                                       if ($cmp eq '==') {
                                               $myresult = ($myitem == $val);
                                       } elsif ($cmp eq '=&lt;') {
                                               $myresult = ($myitem &lt;= $val);
                                       } elsif ($cmp eq '=&gt;') {
                                               $myresult = ($myitem &gt;= $val);
                                       } elsif ($cmp eq '&lt;') {
                                               $myresult = ($myitem &lt; $val);
                                       } elsif ($cmp eq '&gt;') {
                                               $myresult = ($myitem &gt; $val);
                                       } elsif ($cmp eq '!=') {
                                               $myresult = not($myitem == $val);
                                       } elsif ($cmp eq '!&lt;') {
                                               $myresult = not($myitem &lt;= $val);
                                       } elsif ($cmp eq '!&gt;') {
                                               $myresult = not($myitem &gt;= $val);
                                       } else {
                                               $myresult = ($myitem &gt;= $val);
                                       };
                                       return $myresult;
                               },

               # do NOT remove the next line
               );

       <b>ACTIONS</b>

       Action plugins allow to define new postfwd actions. By setting the $stop-flag you can decide to continue
       or to stop parsing the ruleset.

               SYNOPSIS:  (&lt;stop rule parsing&gt;, &lt;next rule index&gt;, &lt;return action&gt;, &lt;logprefix&gt;, &lt;request&gt;) =
                               &lt;action&gt; (&lt;current rule index&gt;, &lt;current time&gt;, &lt;command name&gt;, &lt;argument&gt;, &lt;logprefix&gt;, &lt;request&gt;)

               # do NOT remove the next line
               %postfwd_actions_plugin = (

                       # EXAMPLES - integrated in postfwd. no need to activate them here.

                               # note(&lt;logstring&gt;) command
                               "note"  =&gt; sub {
                                       my($index,$now,$mycmd,$myarg,$myline,%request) = @_;
                                       my($myaction) = 'dunno'; my($stop) = 0;
                                       log_info "[RULES] ".$myline." - note: ".$myarg if $myarg;
                                       return ($stop,$index,$myaction,$myline,%request);
                               },

                               # skips next &lt;myarg&gt; rules
                               "skip" =&gt; sub {
                                       my($index,$now,$mycmd,$myarg,$myline,%request) = @_;
                                       my($myaction) = 'dunno'; my($stop) = 0;
                                       $index += $myarg if ( $myarg and not(($index + $myarg) &gt; $#Rules) );
                                       return ($stop,$index,$myaction,$myline,%request);
                               },

                               # dumps current request contents to syslog
                               "dumprequest" =&gt; sub {
                                       my($index,$now,$mycmd,$myarg,$myline,%request) = @_;
                                       my($myaction) = 'dunno'; my($stop) = 0;
                                       map { log_info "[DUMP] rule=$index, Attribute: $_=$request{$_}" } (keys %request);
                                       return ($stop,$index,$myaction,$myline,%request);
                               },

               # do NOT remove the next line
               );

   <b>COMMAND</b> <b>LINE</b>
       <u>Ruleset</u>

       The following arguments are used to specify the source of the postfwd2 ruleset. This means that at least
       one of the following is required for postfwd2 to work.

               -f, --file &lt;file&gt;
               Reads rules from &lt;file&gt;. Please see the CONFIGURATION section
               below for more information.

               -r, --rule &lt;rule&gt;
               Adds &lt;rule&gt; to ruleset. Remember that you might have to quote
               strings that contain whitespaces or shell characters.

       <u>Scoring</u>

               -s, --scores &lt;val&gt;=&lt;action&gt;
               Returns &lt;action&gt; to postfix, when the request's score exceeds &lt;val&gt;

       Multiple usage is allowed. Just chain your arguments, like:

               postfwd2 -r "&lt;item&gt;=&lt;value&gt;;action=&lt;result&gt;" -f &lt;file&gt; -f &lt;file&gt; ...
                 or
               postfwd2 --scores 4.5="WARN high score" --scores 5.0="REJECT postfwd2 score too high" ...

       In case of multiple scores, the highest match will count. The order of the arguments will be reflected in
       the postfwd2 ruleset.

       <u>Networking</u>

       postfwd2 can be run as daemon so that it listens on the network for incoming requests.  The following
       arguments will control it's behaviour in this case.

               -d, --daemon
               postfwd2 will run as daemon and listen on the network for incoming
               queries (default 127.0.0.1:10045).

               -i, --interface &lt;dev&gt;
               Bind postfwd2 to the specified interface (default 127.0.0.1).

               -p, --port &lt;port&gt;
               postfwd2 listens on the specified port (default tcp/10045).

               --proto &lt;type&gt;
               The protocol type for postfwd's socket. Currently you may use 'tcp' or 'unix' here.
               To use postfwd2 with a unix domain socket, run it as follows:
                   postfwd2 --proto=unix --port=/somewhere/postfwd.socket

               -u, --user &lt;name&gt;
               Changes real and effective user to &lt;name&gt;.

               -g, --group &lt;name&gt;
               Changes real and effective group to &lt;name&gt;.

               --umask &lt;mask&gt;
               Changes the umask for filepermissions of the master process (pidfile).
               Attention: This is umask, not chmod - you have to specify the bits that
               should NOT apply. E.g.: umask 077 equals to chmod 700.

               --cache_umask &lt;mask&gt;
               Changes the umask for filepermissions of the cache process (unix domain socket).

               --server_umask &lt;mask&gt;
               Changes the umask for filepermissions of the server process (unix domain socket).

               -R, --chroot &lt;path&gt;
               Chroot the process to the specified path.
               Please look at <a href="http://postfwd.org/postfwd2-chroot.html">http://postfwd.org/postfwd2-chroot.html</a> before use!

               --pidfile &lt;path&gt;
               The process id will be saved in the specified file.

               --facility &lt;f&gt;
               sets the syslog facility, default is 'mail'

               --socktype &lt;s&gt;
               sets the Sys::Syslog socktype to 'native', 'inet' or 'unix'.
               Default is to auto-detect this depening on module version and os.

               -l, --logname &lt;label&gt;
               Labels the syslog messages. Useful when running multiple
               instances of postfwd.

               --loglen &lt;int&gt;
               Truncates any syslog message after &lt;int&gt; characters.

       <u>Plugins</u>

               --plugins &lt;file&gt;
               Loads postfwd plugins from file. Please see <a href="http://postfwd.org/postfwd.plugins">http://postfwd.org/postfwd.plugins</a>
               or the plugins.postfwd.sample that is available from the tarball for more info.

       <u>Optional</u> <u>arguments</u>

       These parameters influence the way postfwd2 is working. Any of them can be combined.

               -v, --verbose
               Verbose logging displays a lot of useful information but can cause
               your logfiles to grow noticeably. So use it with caution. Set the option
               twice (-vv) to get more information (logs all request attributes).

               -c, --cache &lt;int&gt;    (default=600)
               Timeout for request cache, results for identical requests will be
               cached until config is reloaded or this time (in seconds) expired.
               A setting of 0 disables this feature.

               --cache-no-size
               Ignores size attribute for cache comparisons which will lead to better
               cache-hit rates. You should set this option, if you don't use the size
               item in your ruleset.

               --cache-no-sender
               Ignores sender address for cache comparisons which will lead to better
               cache-hit rates. You should set this option, if you don't use the sender
               item in your ruleset.

               --cache-rdomain-only
               This will strip the localpart of the recipient's address before filling the
               cache. This may considerably increase cache-hit rates.

               --cache-rbl-timeout &lt;timeout&gt;     (default=3600)
               This default value will be used as timeout in seconds for rbl cache items,
               if not specified in the ruleset.

               --cache-rbl-default &lt;pattern&gt;    (default=^127\.0\.0\.\d+$)
               Matches &lt;pattern&gt; to rbl/rhsbl answers (regexp) if not specified in the ruleset.

               --cacheid &lt;item&gt;, &lt;item&gt;, ...
               This csv-separated list of request attributes will be used to construct
               the request cache identifier. Use this only, if you know exactly what you
               are doing. If you, for example, use postfwd2 only for RBL/RHSBL control,
               you may set this to
                       postfwd2 --cache=3600 --cacheid=client_name,client_address
               This increases efficiency of caching and improves postfwd's performance.
               Warning: You should list all items here, which are used in your ruleset!

               --cleanup-requests &lt;interval&gt;    (default=600)
               The request cache will be searched for timed out items after this &lt;interval&gt; in
               seconds. It is a minimum value. The cleanup process will only take place, when
               a new request arrives.

               --cleanup-rbls &lt;interval&gt;    (default=600)
               The rbl cache will be searched for timed out items after this &lt;interval&gt; in
               seconds. It is a minimum value. The cleanup process will only take place, when
               a new request arrives.

               --cleanup-rates &lt;interval&gt;    (default=600)
               The rate cache will be searched for timed out items after this &lt;interval&gt; in
               seconds. It is a minimum value. The cleanup process will only take place, when
               a new request arrives.

               -S, --summary &lt;int&gt;    (default=600)
               Shows some usage statistics (program uptime, request counter, matching rules)
               every &lt;int&gt; seconds. This option is included by the -v switch.
               This feature uses the alarm signal, so you can force postfwd2 to dump the stats
               using `kill -ALRM &lt;pid&gt;` (where &lt;pid&gt; is the process id of postfwd).

               Example:
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Counters: 213000 seconds uptime, 39 rules
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Requests: 71643 overall, 49 last interval, 62.88% cache hits
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Averages: 20.18 overall, 4.90 last interval, 557.30 top
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Contents: 44 cached requests, 239 cached dnsbl results
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Rule ID: R-001   matched: 2704 times
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Rule ID: R-002   matched: 9351 times
               Aug 19 12:39:45 mail1 postfwd[666]: [STATS] Rule ID: R-003   matched: 3116 times
               ...

               --no-rulestats
               Disables per rule statistics. Keeps your log clean, if you do not use them.
               This option has no effect without --summary or --verbose set.

               -L, --stdout
               Redirects all syslog messages to stdout for debugging. Never use this with postfix!

               -t, --test
               In test mode postfwd2 always returns "dunno", but logs according
               to it`s ruleset. -v will be set automatically with this option.

               -n, --nodns
               Disables all DNS based checks like RBL checks. Rules containing
               such elements will be ignored.

               -n, --nodnslog
               Disables logging of dns events.

               --dns_timeout     (default: 14)
               Sets the timeout for asynchonous dns queries in seconds. This value will apply to
               all dns items in a rule.

               --dns_timeout_max    (default: 10)
               Sets the maximum timeout counter for dnsbl lookups. If the timeouts exceed this value
               the corresponding dnsbl will be deactivated for a while (see --dns_timeout_interval).

               --dns_timeout_interval    (default=1200)
               The dnsbl timeout counter will be cleaned after this interval in seconds. Use this
               in conjunction with the --dns_timeout_max parameter.

               --dns_async_txt
               Perform dnsbl A and TXT lookups simultaneously (otherwise only for listings with at
               least one A record). This needs more network bandwidth due to increased queries but
               might increase throughput because the lookups can be parallelized.

               --dns_max_ns_lookups     (default=0)
               maximum ns names to lookup up with sender_ns_addrs item. use 0 for no maximum.

               --dns_max_mx_lookups     (default=0)
               maximum mx names to lookup up with sender_mx_addrs item. use 0 for no maximum.

               -I, --instantcfg
               The config files, specified by -f will be re-read for every request
               postfwd2 receives. This enables on-the-fly configuration changes
               without restarting. Though files will be read only if necessary
               (which means their access times changed since last read) this might
               significantly increase system load.

               --config_timeout    (default=3)
               timeout in seconds to parse a single configuration line. if exceeded, the rule will
               be skipped. this is used to prevent problems due to large files or loops.

               --keep_rates    (default=0)
               With this option set postfwd2 does not clear the rate limit counters on reload. Please
               note that you have to restart (not reload) postfwd with this option if you change
               any rate limit rules.

               --save_rates    (default=none)
               With this option postfwd saves existing rate limit counters to disk and reloads them
               on program start. This allows persistent rate limits across program restarts or reboots.
               Please note that postfwd needs read and write access to the specified file.

               --fast_limit_evaluation    (default=0)
               Once a ratelimit was set by the ruleset, future requests will be evaluated against it
               before consulting the ruleset. This mode was the default behaviour until v1.30.
               With this mode rate limits will be faster, but also eventually set up
               whitelisting-rules within the ruleset might not work as expected.
               LIMITATIONS: This option does not allow nested postfwd commands like
                       action=rate(sender/3/60/<a href="../man3/wait.3.html">wait</a>(3))
               This option doe not work with the strict-rfc5321 rate() functions.

       <u>Informational</u> <u>arguments</u>

       These arguments are for command line usage only. Never ever use them with postfix!

               -C, --showconfig
               Displays the current ruleset. Use -v for verbose output.

               -V, --version
               Displays the program version.

               -h, --help
               Shows program usage.

               -m, --manual
               Displays the program manual.

               -D, --defaults
               displays complete postfwd2 settings.

               -P, --perfmon
               This option turns of any syslogging and output. It is included
               for performance testing.

               --dumpstats
               Displays program usage statistics.

               --dumpcache
               Displays cache contents.

               --delcache &lt;item&gt;
               Removes an item from the request cache. Use --dumpcache to identify objects.
               E.g.:
                       # postfwd --dumpcache
                       ...
                       %rate_cache -&gt; %sender=<a href="mailto:gmato@jqvo.org">gmato@jqvo.org</a> -&gt; %RATE002+2_600 -&gt; @count    -&gt; '1'
                       %rate_cache -&gt; %sender=<a href="mailto:gmato@jqvo.org">gmato@jqvo.org</a> -&gt; %RATE002+2_600 -&gt; @maxcount -&gt; '2'
                       ...
                       # postfwd --delrate="sender=<a href="mailto:gmato@jqvo.org">gmato@jqvo.org</a>"
                       rate cache item 'sender=<a href="mailto:gmato@jqvo.org">gmato@jqvo.org</a>' removed

               --delrate &lt;item&gt;
               Removes an item from the rate cache. Use --dumpcache to identify objects.

   <b>REFRESH</b>
       In daemon mode postfwd2 reloads it's ruleset after receiving a HUP signal. Please see the description of
       the '-I' switch to have your configuration refreshed for every request postfwd2 receives.

   <b>EXAMPLES</b>
               ## whitelisting
               # 1. networks 192.168.1.0/24, 192.168.2.4
               # 2. client_names *.gmx.net and *.gmx.de
               # 3. sender *@someshop.tld from 11.22.33.44
               id=WL001; action=dunno ; client_address=192.168.1.0/24, 192.168.2.4
               id=WL002; action=dunno ; client_name=\.gmx\.(net|de)$
               id=WL003; action=dunno ; sender=@someshop\.tld$ ; client_address=11.22.33.44

               ## TLS control
               # 1. *@authority.tld only with correct TLS fingerprint
               # 2. *@secret.tld only with keysizes &gt;=64
               id=TL001; action=dunno                          ; sender=@authority\.tld$ ; ccert_fingerprint=AA:BB:CC..
               id=TL002; action=REJECT wrong TLS fingerprint   ; sender=@authority\.tld$
               id=TL003; action=REJECT tls keylength &lt; 64      ; sender=@secret\.tld$ ; encryption_keysize=64

               ## Combined RBL checks
               # This will reject mail if
               # 1. listed on ix.dnsbl.manitu.net
               # 2. listed on zen.spamhaus.org (sbl and xbl, dns cache timeout 1200s instead of 3600s)
               # 3. listed on min 2 of bl.spamcop.net, list.dsbl.org, dnsbl.sorbs.net
               # 4. listed on bl.spamcop.net and one of rhsbl.ahbl.org, rhsbl.sorbs.net
               id=RBL01 ; action=REJECT listed on ix.dnsbl.manitu.net  ; rbl=ix.dnsbl.manitu.net
               id=RBL02 ; action=REJECT listed on zen.spamhaus.org     ; rbl=zen.spamhaus.org/127.0.0.[2-8]/1200
               id=RBL03 ; action=REJECT listed on too many RBLs        ; rblcount=2 ; rbl=bl.spamcop.net, list.dsbl.org, dnsbl.sorbs.net
               id=RBL04 ; action=REJECT combined RBL+RHSBL check       ; rbl=bl.spamcop.net ; rhsbl=rhsbl.ahbl.org, rhsbl.sorbs.net

               ## Message size (requires message_size_limit to be set to 30000000)
               # 1. 30MB for systems in *.customer1.tld
               # 2. 20MB for SASL user joejob
               # 3. 10MB default
               id=SZ001; protocol_state==END-OF-MESSAGE; action=DUNNO; size&lt;=30000000 ; client_name=\.customer1.tld$
               id=SZ002; protocol_state==END-OF-MESSAGE; action=DUNNO; size&lt;=20000000 ; sasl_username==joejob
               id=SZ002; protocol_state==END-OF-MESSAGE; action=DUNNO; size&lt;=10000000
               id=SZ100; protocol_state==END-OF-MESSAGE; action=REJECT message too large

               ## Selective Greylisting
               ##
               ## Note that postfwd does not include greylisting. This setup requires a running postgrey service
               ## at port 10031 and the following postfix restriction class in your main.cf:
               ##
               ##      smtpd_restriction_classes = check_postgrey, ...
               ##      check_postgrey = check_policy_service inet:127.0.0.1:10031
               #
               # 1. if listed on zen.spamhaus.org with results 127.0.0.10 or .11, dns cache timeout 1200s
               # 2. Client has no rDNS
               # 3. Client comes from several dialin domains
               id=GR001; action=check_postgrey ; rbl=dul.dnsbl.sorbs.net, zen.spamhaus.org/127.0.0.1[01]/1200
               id=GR002; action=check_postgrey ; client_name=^unknown$
               id=GR003; action=check_postgrey ; client_name=\.(t-ipconnect|alicedsl|ish)\.de$

               ## Date Time
               date=24.12.2007-26.12.2007          ;  action=450 4.7.1 office closed during christmas
               time=04:00:00-05:00:00              ;  action=450 4.7.1 maintenance ongoing, try again later
               time=-07:00:00 ;  sasl_username=jim ;  action=450 4.7.1 to early for you, jim
               time=22:00:00- ;  sasl_username=jim ;  action=450 4.7.1 to late now, jim
               months=-Apr                         ;  action=450 4.7.1 see you in may
               days=!!Mon-Fri                      ;  action=check_postgrey

               ## Usage of jump
               # The following allows a message size of 30MB for different
               # users/clients while others will only have 10MB.
               id=R001 ; action=jump(R100) ; sasl_username=^(Alice|Bob|Jane)$
               id=R002 ; action=jump(R100) ; client_address=192.168.1.0/24
               id=R003 ; action=jump(R100) ; ccert_fingerprint=AA:BB:CC:DD:...
               id=R004 ; action=jump(R100) ; ccert_fingerprint=AF:BE:CD:DC:...
               id=R005 ; action=jump(R100) ; ccert_fingerprint=DD:CC:BB:DD:...
               id=R099 ; protocol_state==END-OF-MESSAGE; action=REJECT message too big (max. 10MB); size=10000000
               id=R100 ; protocol_state==END-OF-MESSAGE; action=REJECT message too big (max. 30MB); size=30000000

               ## Usage of score
               # The following rejects a mail, if the client
               # - is listed on 1 RBL and 1 RHSBL
               # - is listed in 1 RBL or 1 RHSBL and has no correct rDNS
               # - other clients without correct rDNS will be greylist-checked
               # - some whitelists are used to lower the score
               id=S01 ; score=2.6              ; action=check_postgrey
               id=S02 ; score=5.0              ; action=REJECT postfwd score too high
               id=R00 ; action=score(-1.0)     ; rbl=exemptions.ahbl.org,list.dnswl.org,query.bondedsender.org,spf.trusted-forwarder.org
               id=R01 ; action=score(2.5)      ; rbl=bl.spamcop.net, list.dsbl.org, dnsbl.sorbs.net
               id=R02 ; action=score(2.5)      ; rhsbl=rhsbl.ahbl.org, rhsbl.sorbs.net
               id=N01 ; action=score(-0.2)     ; client_name==$$helo_name
               id=N02 ; action=score(2.7)      ; client_name=^unknown$
               ...

               ## Usage of rate and size
               # The following temporary rejects requests from "unknown" clients, if they
               # 1. exceeded 30 requests per hour or
               # 2. tried to send more than 1.5mb within 10 minutes
               id=RATE01 ;  client_name==unknown ;  protocol_state==RCPT
                       action=rate(client_address/30/3600/450 4.7.1 sorry, max 30 requests per hour)
               id=SIZE01 ;  client_name==unknown ;  protocol_state==END-OF-MESSAGE
                       action=size(client_address/1572864/600/450 4.7.1 sorry, max 1.5mb per 10 minutes)

               ## Macros
               # definition
               &amp;&amp;RBLS { rbl=zen.spamhaus.org,list.dsbl.org,bl.spamcop.net,dnsbl.sorbs.net,ix.dnsbl.manitu.net; };
               &amp;&amp;GONOW { action=REJECT your request caused our spam detection policy to reject this message. More info at <a href="http://www.domain.local">http://www.domain.local</a>; };
               # rules
               &amp;&amp;GONOW ;  &amp;&amp;RBLS ;  client_name=^unknown$
               &amp;&amp;GONOW ;  &amp;&amp;RBLS ;  client_name=(\d+[\.-_]){4}
               &amp;&amp;GONOW ;  &amp;&amp;RBLS ;  client_name=[\.-_](adsl|dynamic|ppp|)[\.-_]

               ## Groups
               # definition
               &amp;&amp;RBLS{
                       rbl=zen.spamhaus.org
                       rbl=list.dsbl.org
                       rbl=bl.spamcop.net
                       rbl=dnsbl.sorbs.net
                       rbl=ix.dnsbl.manitu.net
               };
               &amp;&amp;RHSBLS{
                       ...
               };
               &amp;&amp;DYNAMIC{
                       client_name==unknown
                       client_name~=(\d+[\.-_]){4}
                       client_name~=[\.-_](adsl|dynamic|ppp|)[\.-_]
                       ...
               };
               &amp;&amp;BAD_HELO{
                       helo_name==my.name.tld
                       helo_name~=^([^\.]+)$
                       helo_name~=\.(local|lan)$
                       ...
               };
               &amp;&amp;MAINTENANCE{
                       date=15.01.2007
                       date=15.04.2007
                       date=15.07.2007
                       date=15.10.2007
                       time=03:00:00 - 04:00:00
               };
               # rules
               id=COMBINED    ;  &amp;&amp;RBLS ;  &amp;&amp;DYNAMIC ;  action=REJECT dynamic client and listed on RBL
               id=MAINTENANCE ;  &amp;&amp;MAINTENANCE       ;  action=DEFER maintenance time - please try again later

               # now with the set() command, note that long item
               # lists don't have to be compared twice
               id=RBL01    ;  &amp;&amp;RBLS      ;  action=set(HIT_rbls=1)
               id=HELO01   ;  &amp;&amp;BAD_HELO  ;  action=set(HIT_helo=1)
               id=DYNA01   ;  &amp;&amp;DYNAMIC   ;  action=set(HIT_dyna=1)
               id=REJECT01 ;  HIT_rbls==1 ;  HIT_helo==1  ; action=REJECT please see <a href="http://some.org/info">http://some.org/info</a>?reject=01 for more info
               id=REJECT02 ;  HIT_rbls==1 ;  HIT_dyna==1  ; action=REJECT please see <a href="http://some.org/info">http://some.org/info</a>?reject=02 for more info
               id=REJECT03 ;  HIT_helo==1 ;  HIT_dyna==1  ; action=REJECT please see <a href="http://some.org/info">http://some.org/info</a>?reject=03 for more info

               ## combined with enhanced rbl features
               #
               id=RBL01 ; rhsblcount=all ; rblcount=all ; &amp;&amp;RBLS ; &amp;&amp;RHSBLS
                    action=set(HIT_dnsbls=$$rhsblcount,HIT_dnsbls+=$$rblcount,HIT_dnstxt=$$dnsbltext)
               id=RBL02 ; HIT_dnsbls&gt;=2  ; action=554 5.7.1 blocked using $$HIT_dnsbls DNSBLs [INFO: $$HIT_dnstxt]

   <b>PARSER</b>
       <u>Configuration</u>

       The postfwd2 ruleset can be specified at the commandline (-r option) or be read from files (-f). The
       order of your arguments will be kept. You should check the parser with the -C | --showconfig switch at
       the command line before applying a new config. The following call:

               postfwd2 --showconfig \
                       -r "id=TEST; recipient_count=100; action=WARN mail with 100+ recipients" \
                       -f /etc/postfwd.cf \
                       -r "id=DEFAULT; action=dunno";

       will produce the following output:

               Rule   0: id-&gt;"TEST" action-&gt;"WARN mail with 100+ recipients"; recipient_count-&gt;"100"
               ...
               ... &lt;content of /etc/postfwd.cf&gt; ...
               ...
               Rule &lt;n&gt;: id-&gt;"DEFAULT" action-&gt;"dunno"

       Multiple items of the same type will be added to lists (see the "ITEMS" section for more info):

               postfwd2 --showconfig \
                       -r "client_address=192.168.1.0/24; client_address=172.16.26.32; action=dunno"

       will result in:

               Rule   0: id-&gt;"R-0"; action-&gt;"dunno"; client_address-&gt;"192.168.1.0/24, 172.16.26.32"

       Macros are evaluated at configuration stage, which means that

               postfwd2 --showconfig \
                       -r "&amp;&amp;RBLS { rbl=bl.spamcop.net; client_name=^unknown$; };" \
                       -r "id=RBL001; &amp;&amp;RBLS; action=REJECT listed on spamcop and bad rdns";

       will result in:

               Rule   0: id-&gt;"RBL001"; action-&gt;"REJECT listed on spamcop and bad rdns"; rbl-&gt;"bl.spamcop.net"; client_name-&gt;"^unknown$"

       <u>Request</u> <u>processing</u>

       When a policy delegation request arrives it will be compared against postfwd`s ruleset. To inspect the
       processing in detail you should increase verbority using use the "-v" or "-vv" switch. "-L" redirects log
       messages to stdout.

       Keeping the order of the ruleset in general, items will be compared in random order, which basically
       means that

               id=R001; action=dunno; client_address=192.168.1.1; sender=<a href="mailto:bob@alice.local">bob@alice.local</a>

       equals to

               id=R001; sender=<a href="mailto:bob@alice.local">bob@alice.local</a>; client_address=192.168.1.1; action=dunno

       Lists will be evaluated in the specified order. This allows one to place faster expressions at first:

               postfwd2 --nodaemon -vv -L -r "id=RBL001; rbl=localrbl.local zen.spamhaus.org; action=REJECT" /some/where/request.sample

       produces the following

               [LOGS info]: compare rbl: "remotehost.remote.net[68.10.1.7]"  -&gt;  "localrbl.local"
               [LOGS info]: count1 rbl:  "2"  -&gt;  "0"
               [LOGS info]: query rbl:   localrbl.local 7.1.10.68 (7.1.10.68.localrbl.local)
               [LOGS info]: count2 rbl:  "2"  -&gt;  "0"
               [LOGS info]: match rbl:   FALSE
               [LOGS info]: compare rbl: "remotehost.remote.net[68.10.1.7]"  -&gt;  "zen.spamhaus.org"
               [LOGS info]: count1 rbl:  "2"  -&gt;  "0"
               [LOGS info]: query rbl:   zen.spamhaus.org 7.1.10.68 (7.1.10.68.zen.spamhaus.org)
               [LOGS info]: count2 rbl:  "2"  -&gt;  "0"
               [LOGS info]: match rbl:   FALSE
               [LOGS info]: Action: dunno

       The negation operator !!(&lt;value&gt;) has the highest priority and therefore will be evaluated first. Then
       variable substitutions are performed:

               postfwd2 --nodaemon -vv -L -r "id=TEST; action=REJECT; client_name=!!($$heloname)" /some/where/request.sample

       will give

               [LOGS info]: compare client_name:     "unknown"  -&gt;  "!!($$helo_name)"
               [LOGS info]: negate client_name:      "unknown"  -&gt;  "$$helo_name"
               [LOGS info]: substitute client_name:  "unknown"  -&gt;  "english-breakfast.cloud8.net"
               [LOGS info]: match client_name:  TRUE
               [LOGS info]: Action: REJECT

       <u>Ruleset</u> <u>evaluation</u>

       A rule hits when all items (or at least one element of a list for each item) have matched. As soon as one
       item (or all elements of a list) fails to compare against the request attribute the parser will jump to
       the next rule in the postfwd2 ruleset.

       If a rule matches, there are two options:

       * Rule returns postfix action (dunno, reject, ...)  The parser stops rule processing and returns the
       action to postfix. Other rules will not be evaluated.

       * Rule returns postfwd2 action (<u>jump()</u>, <u>note()</u>, ...)  The parser evaluates the given action and continues
       with the next rule (except for the <u>jump()</u> or <u>quit()</u> actions - please see the "ACTIONS" section for more
       information). Nothing will be sent to postfix.

       If no rule has matched and the end of the ruleset is reached postfwd2 will return dunno without logging
       anything unless in verbose mode. You may place a last catch-all rule to change that behaviour:

               ... &lt;your rules&gt; ...
               id=DEFAULT ;  action=dunno

       will log any request that passes the ruleset without having hit a prior rule.

   <b>DEBUGGING</b>
       To debug special steps of the parser the '--debug' switch takes a list of debug classes. Currently the
       following classes are defined:

               all cache config debugdns devel dns getcache getdns
               getdnspacket rates request setcache setdns
               parent_cache parent_dns_cache parent_rate_cache parent_request_cache
               child_cache  child_dns_cache  child_rate_cache  child_request_cache

   <b>INTEGRATION</b>
       <u>Integration</u> <u>via</u> <u>daemon</u> <u>mode</u>

       The common way to use postfwd2 is to start it as daemon, listening at a specified tcp port.  postfwd2
       will spawn multiple child processes which communicate with a parent cache. This is the preferred way to
       use postfwd2 in high volume environments. Start postfwd2 with the following parameters:

               postfwd2 -d -f /etc/postfwd.cf -i 127.0.0.1 -p 10045 -u nobody -g nobody -S

       For efficient caching you should check if you can use the options --cacheid, --cache-rdomain-only,
       --cache-no-sender and --cache-no-size.

       Now check your syslogs (default facility "mail") for a line like:

               Aug  9 23:00:24 mail postfwd[5158]: postfwd2 n.nn ready for input

       and use `netstat -an|grep 10045` to check for something like

               tcp  0  0  127.0.0.1:10045  0.0.0.0:*  LISTEN

       If everything works, open your postfix main.cf and insert the following

               127.0.0.1:10045_time_limit      = 3600                                          &lt;--- integration
               smtpd_recipient_restrictions    = permit_mynetworks                             &lt;--- recommended
                                                 reject_unauth_destination                     &lt;--- recommended
                                                 check_policy_service inet:127.0.0.1:10045     &lt;--- integration

       Reload your configuration with `postfix reload` and watch your logs. In it works you should see lines
       like the following in your mail log:

               Aug  9 23:01:24 mail postfwd[5158]: rule=22, id=ML_POSTFIX, client=english-breakfast.cloud9.net[168.100.1.7], sender=<a href="mailto:owner-postfix-users@postfix.tld">owner-postfix-users@postfix.tld</a>, recipient=<a href="mailto:someone@domain.local">someone@domain.local</a>, helo=english-breakfast.cloud9.net, proto=ESMTP, state=RCPT, action=dunno

       If you want to check for size or rcpt_count items you must integrate postfwd2 in smtp_data_restrictions
       or smtpd_end_of_data_restrictions. Of course you can also specify a restriction class and use it in your
       access tables. First create a file /etc/postfix/policy containing:

               domain1.local           postfwdcheck
               domain2.local           postfwdcheck
               ...

       Then postmap that file (`postmap hash:/etc/postfix/policy`), open your main.cf and enter

               # Restriction Classes
               smtpd_restriction_classes       = postfwdcheck, &lt;some more&gt;...                          &lt;--- integration
               postfwdcheck                    = check_policy_service inet:127.0.0.1:10045             &lt;--- integration

               127.0.0.1:10045_time_limit      = 3600                                                  &lt;--- integration
               smtpd_recipient_restrictions    = permit_mynetworks,                                    &lt;--- recommended
                                                 reject_unauth_destination,                            &lt;--- recommended
                                                 ...                                                   &lt;--- optional
                                                 check_recipient_access hash:/etc/postfix/policy,      &lt;--- integration
                                                 ...                                                   &lt;--- optional

       Reload postfix and watch your logs.

   <b>TESTING</b>
       First you have to create a ruleset (see Configuration section). Check it with

               postfwd2 -f /etc/postfwd.cf -C

       There is an example policy request distributed with postfwd, called 'request.sample'.  Simply change it
       to meet your requirements and use

               postfwd2 -f /etc/postfwd.cf &lt;request.sample

       You should get an answer like

               action=&lt;whateveryouconfigured&gt;

       For network tests I use netcat:

               nc 127.0.0.1 10045 &lt;request.sample

       to send a request to postfwd. If you receive nothing, make sure that postfwd2 is running and listening on
       the specified network settings.

   <b>PERFORMANCE</b>
       Some of these proposals might not match your environment. Please check your requirements and test new
       options carefully!

               - use caching options
               - use the correct match operator ==, &lt;=, &gt;=
               - use ^ and/or $ in regular expressions
               - use item lists (faster than single rules)
               - use set() action on repeated item lists
               - use jumps and rate limits
               - use a pre-lookup rule for rbl/rhsbls with empty note() action

   <b>SEE</b> <b>ALSO</b>
       See &lt;<a href="http://www.postfix.org/SMTPD_POLICY_README.html">http://www.postfix.org/SMTPD_POLICY_README.html</a>&gt; for a description of how Postfix policy servers
       work.

</pre><h4><b>LICENSE</b></h4><pre>
       postfwd2 is free software and released under BSD license, which basically means that you can do what you
       want as long as you keep the copyright notice:

       Copyright (c) 2009, Jan Peter Kessler All rights reserved.

       Redistribution and use in source and binary forms, with or without modification, are permitted provided
       that the following conditions are met:

        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in
          the documentation and/or other materials provided with the
          distribution.
        * Neither the name of the authors nor the names of his contributors
          may be used to endorse or promote products derived from this
          software without specific prior written permission.

       THIS SOFTWARE IS PROVIDED BY ME ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
       DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
       CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
       OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
       WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
       OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jan Peter Kessler &lt;info (AT) postfwd (DOT) org&gt;. Let me know, if you have any suggestions.

perl v5.14.2                                       2013-04-18                             <u><a href="../man1/POSTFWD2-ALL-IN-ONE.1.html">POSTFWD2-ALL-IN-ONE</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>