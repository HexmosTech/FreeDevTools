<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix">manpages-posix_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       bc — arbitrary-precision arithmetic language

</pre><h4><b>SYNOPSIS</b></h4><pre>
       bc <b>[</b>-l<b>]</b> <b>[</b><u>file</u>...<b>]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>bc</u>  utility  shall  implement  an arbitrary precision calculator. It shall take input from any files
       given, then read from the standard input. If the standard input and standard output to <u>bc</u> are attached to
       a terminal, the invocation of <u>bc</u> shall be considered to be <u>interactive</u>,  causing  behavioral  constraints
       described in the following sections.

</pre><h4><b>OPTIONS</b></h4><pre>
       The <u>bc</u> utility shall conform to the Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>12.2</u>, <u>Utility</u> <u>Syntax</u>
       <u>Guidelines</u>.

       The following option shall be supported:

       <b>-l</b>        (The  letter ell.) Define the math functions and initialize <u>scale</u> to 20, instead of the default
                 zero; see the EXTENDED DESCRIPTION section.

</pre><h4><b>OPERANDS</b></h4><pre>
       The following operand shall be supported:

       <u>file</u>      A pathname of a text file containing <u>bc</u> program statements. After all <u>file</u>s have been read,  <u>bc</u>
                 shall read the standard input.

</pre><h4><b>STDIN</b></h4><pre>
       See the INPUT FILES section.

</pre><h4><b>INPUT</b> <b>FILES</b></h4><pre>
       Input  files  shall be text files containing a sequence of comments, statements, and function definitions
       that shall be executed as they are read.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       The following environment variables shall affect the execution of <u>bc</u>:

       <u>LANG</u>      Provide a default value for the internationalization variables that are unset or null. (See the
                 Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>8.2</u>, <u>Internationalization</u>  <u>Variables</u>  for  the
                 precedence   of   internationalization  variables  used  to  determine  the  values  of  locale
                 categories.)

       <u>LC_ALL</u>    If set to a non-empty string value, override the values of all the  other  internationalization
                 variables.

       <u>LC_CTYPE</u>  Determine  the  locale  for the interpretation of sequences of bytes of text data as characters
                 (for example, single-byte as opposed to multi-byte characters in arguments and input files).

       <u>LC_MESSAGES</u>
                 Determine the locale that should be used to  affect  the  format  and  contents  of  diagnostic
                 messages written to standard error.

       <u>NLSPATH</u>   Determine the location of message catalogs for the processing of <u>LC_MESSAGES</u>.

</pre><h4><b>ASYNCHRONOUS</b> <b>EVENTS</b></h4><pre>
       Default.

</pre><h4><b>STDOUT</b></h4><pre>
       The  output  of the <u>bc</u> utility shall be controlled by the program read, and consist of zero or more lines
       containing the value of all executed expressions without assignments. The  radix  and  precision  of  the
       output  shall  be controlled by the values of the <b>obase</b> and <b>scale</b> variables; see the EXTENDED DESCRIPTION
       section.

</pre><h4><b>STDERR</b></h4><pre>
       The standard error shall be used only for diagnostic messages.

</pre><h4><b>OUTPUT</b> <b>FILES</b></h4><pre>
       None.

</pre><h4><b>EXTENDED</b> <b>DESCRIPTION</b></h4><pre>
   <b>Grammar</b>
       The grammar in this section and the lexical conventions in the following section shall together  describe
       the  syntax  for  <u>bc</u> programs. The general conventions for this style of grammar are described in <u>Section</u>
       <u>1.3</u>, <u>Grammar</u> <u>Conventions</u>.  A valid program can be represented as the non-terminal symbol <b>program</b>  in  the
       grammar. This formal syntax shall take precedence over the text syntax description.

           %token    EOF NEWLINE STRING LETTER NUMBER

           %token    MUL_OP
           /*        '*', '/', '%'                           */

           %token    ASSIGN_OP
           /*        '=', '+=', '-=', '*=', '/=', '%=', '^=' */

           %token    REL_OP
           /*        '==', '&lt;=', '&gt;=', '!=', '&lt;', '&gt;'        */

           %token    INCR_DECR
           /*        '++', '--'                              */

           %token    Define    Break    Quit    Length
           /*        'define', 'break', 'quit', 'length'     */

           %token    Return    For    If    While    Sqrt
           /*        'return', 'for', 'if', 'while', 'sqrt'  */

           %token    Scale    Ibase    Obase    Auto
           /*        'scale', 'ibase', 'obase', 'auto'       */

           %start    program

           %%

           program              : EOF
                                | input_item program
                                ;

           input_item           : semicolon_list NEWLINE
                                | function
                                ;

           semicolon_list       : /* empty */
                                | statement
                                | semicolon_list ';' statement
                                | semicolon_list ';'
                                ;

           statement_list       : /* empty */
                                | statement
                                | statement_list NEWLINE
                                | statement_list NEWLINE statement
                                | statement_list ';'
                                | statement_list ';' statement
                                ;

           statement            : expression
                                | STRING
                                | Break
                                | Quit
                                | Return
                                | Return '(' return_expression ')'
                                | For '(' expression ';'
                                      relational_expression ';'
                                      expression ')' statement
                                | If '(' relational_expression ')' statement
                                | While '(' relational_expression ')' statement
                                | '{' statement_list '}'
                                ;

           function             : Define LETTER '(' opt_parameter_list ')'
                                      '{' NEWLINE opt_auto_define_list
                                      statement_list '}'
                                ;

           opt_parameter_list   : /* empty */
                                | parameter_list
                                ;

           parameter_list       : LETTER
                                | define_list ',' LETTER
                                ;

           opt_auto_define_list : /* empty */
                                | Auto define_list NEWLINE
                                | Auto define_list ';'
                                ;

           define_list          : LETTER
                                | LETTER '[' ']'
                                | define_list ',' LETTER
                                | define_list ',' LETTER '[' ']'
                                ;

           opt_argument_list    : /* empty */
                                | argument_list
                                ;

           argument_list        : expression
                                | LETTER '[' ']' ',' argument_list
                                ;

           relational_expression : expression
                                | expression REL_OP expression
                                ;

           return_expression    : /* empty */
                                | expression
                                ;

           expression           : named_expression
                                | NUMBER
                                | '(' expression ')'
                                | LETTER '(' opt_argument_list ')'
                                | '-' expression
                                | expression '+' expression
                                | expression '-' expression
                                | expression MUL_OP expression
                                | expression '^' expression
                                | INCR_DECR named_expression
                                | named_expression INCR_DECR
                                | named_expression ASSIGN_OP expression
                                | Length '(' expression ')'
                                | Sqrt '(' expression ')'
                                | Scale '(' expression ')'
                                ;

           named_expression     : LETTER
                                | LETTER '[' expression ']'
                                | Scale
                                | Ibase
                                | Obase
                                ;

   <b>Lexical</b> <b>Conventions</b> <b>in</b> <b>bc</b>
       The lexical conventions for <u>bc</u> programs, with respect to the preceding grammar, shall be as follows:

        1. Except  as  noted,  <u>bc</u>  shall  recognize the longest possible token or delimiter beginning at a given
           point.

        2. A comment shall consist of any characters  beginning  with  the  two  adjacent  characters  <b>"/*"</b>  and
           terminated by the next occurrence of the two adjacent characters <b>"*/"</b>.  Comments shall have no effect
           except to delimit lexical tokens.

        3. The &lt;newline&gt; shall be recognized as the token <b>NEWLINE</b>.

        4. The token <b>STRING</b> shall represent a string constant; it shall consist of any characters beginning with
           the  double-quote character (<b>'"'</b>) and terminated by another occurrence of the double-quote character.
           The value of the string is the sequence of all characters between, but not including, the two double-
           quote characters. All characters shall be taken literally from the input, and  there  is  no  way  to
           specify a string containing a double-quote character. The length of the value of each string shall be
           limited to {BC_STRING_MAX} bytes.

        5. A  &lt;blank&gt;  shall have no effect except as an ordinary character if it appears within a <b>STRING</b> token,
           or to delimit a lexical token other than <b>STRING</b>.

        6. The combination of a &lt;backslash&gt; character immediately followed by a &lt;newline&gt; shall have  no  effect
           other than to delimit lexical tokens with the following exceptions:

            *  It shall be interpreted as the character sequence <b>"\&lt;newline&gt;"</b> in <b>STRING</b> tokens.

            *  It shall be ignored as part of a multi-line <b>NUMBER</b> token.

        7. The token <b>NUMBER</b> shall represent a numeric constant. It shall be recognized by the following grammar:

               NUMBER  : integer
                       | '.' integer
                       | integer '.'
                       | integer '.' integer
                       ;

               integer : digit
                       | integer digit
                       ;

               digit   : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
                       | 8 | 9 | A | B | C | D | E | F
                       ;

        8. The  value  of a <b>NUMBER</b> token shall be interpreted as a numeral in the base specified by the value of
           the internal register <b>ibase</b> (described below). Each of the <b>digit</b> characters shall have the value from
           0 to 15 in the order listed here, and the &lt;period&gt; character shall represent  the  radix  point.  The
           behavior  is  undefined  if  digits  greater than or equal to the value of <b>ibase</b> appear in the token.
           However, note the exception for single-digit values being assigned to <b>ibase</b> and <b>obase</b> themselves,  in
           <u>Operations</u> <u>in</u> <u>bc</u>.

        9. The following keywords shall be recognized as tokens:
           <b>auto</b>     <b>ibase</b>    <b>length</b>   <b>return</b>   <b>while</b>
           <b>break</b>    <b>if</b>       <b>obase</b>    <b>scale</b>
           <b>define</b>   <b>for</b>      <b>quit</b>     <b>sqrt</b>

       10. Any of the following characters occurring anywhere except within a keyword shall be recognized as the
           token <b>LETTER</b>:

               a b c d e f g h i j k l m n o p q r s t u v w x y z

       11. The  following  single-character  and  two-character  sequences  shall  be  recognized  as  the token
           <b>ASSIGN_OP</b>:

               =   +=   -=   *=   /=   %=   ^=

       12. If an <b>'='</b> character, as the beginning of a token, is followed by a <b>'-'</b> character with no  intervening
           delimiter, the behavior is undefined.

       13. The following single-characters shall be recognized as the token <b>MUL_OP</b>:

               *   /   %

       14. The following single-character and two-character sequences shall be recognized as the token <b>REL_OP</b>:

               ==   &lt;=   &gt;=   !=   &lt;   &gt;

       15. The following two-character sequences shall be recognized as the token <b>INCR_DECR</b>:

               ++   --

       16. The following single characters shall be recognized as tokens whose names are the character:

               &lt;newline&gt;  (  )  ,  +  -  ;  [  ]  ^  {  }

       17. The token <b>EOF</b> is returned when the end of input is reached.

   <b>Operations</b> <b>in</b> <b>bc</b>
       There  are three kinds of identifiers: ordinary identifiers, array identifiers, and function identifiers.
       All three types consist of single lowercase letters.  Array  identifiers  shall  be  followed  by  square
       brackets  (<b>"[]"</b>).   An array subscript is required except in an argument or auto list.  Arrays are singly
       dimensioned and can contain up to {BC_DIM_MAX} elements. Indexing shall begin at  zero  so  an  array  is
       indexed  from  0  to  {BC_DIM_MAX}-1.   Subscripts  shall be truncated to integers. The application shall
       ensure that function identifiers are followed by parentheses, possibly  enclosing  arguments.  The  three
       types of identifiers do not conflict.

       The  following table summarizes the rules for precedence and associativity of all operators. Operators on
       the same line shall have the same precedence; rows are in order of decreasing precedence.

                                                <b>Table:</b> <b>Operators</b> <b>in</b> <u>bc</u>
                                    ┌───────────────────────────┬───────────────┐
                                    │         <b>Operator</b>          │ <b>Associativity</b> │
                                    ├───────────────────────────┼───────────────┤
                                    │ ++, --                    │ N/A           │
                                    │ unary -                   │ N/A           │
                                    │ ^                         │ Right to left │
                                    │ *, /, %                   │ Left to right │
                                    │ +, binary -               │ Left to right │
                                    │ =, +=, -=, *=, /=, %=, ^= │ Right to left │
                                    │ ==, &lt;=, &gt;=, !=, &lt;, &gt;      │ None          │
                                    └───────────────────────────┴───────────────┘

       Each expression or named expression has a <u>scale</u>, which is the number of  decimal  digits  that  shall  be
       maintained as the fractional portion of the expression.

       <u>Named</u>  <u>expressions</u>  are places where values are stored. Named expressions shall be valid on the left side
       of an assignment. The value of a named expression shall be the value stored in the  place  named.  Simple
       identifiers  and  array elements are named expressions; they have an initial value of zero and an initial
       scale of zero.

       The internal registers <b>scale</b>, <b>ibase</b>, and <b>obase</b> are all named expressions.  The  scale  of  an  expression
       consisting of the name of one of these registers shall be zero; values assigned to any of these registers
       are truncated to integers. The <b>scale</b> register shall contain a global value used in computing the scale of
       expressions  (as  described  below).  The  value  of  the  register  <b>scale</b>  is  limited  to  0  ≤ <b>scale</b> ≤
       {BC_SCALE_MAX} and shall have a default value of zero. The <b>ibase</b> and <b>obase</b> registers are  the  input  and
       output number radix, respectively. The value of <b>ibase</b> shall be limited to:

           2 ≤ ibase ≤ 16

       The value of <b>obase</b> shall be limited to:

           2 ≤ obase ≤ {BC_BASE_MAX}

       When  either  <b>ibase</b> or <b>obase</b> is assigned a single <b>digit</b> value from the list in <u>Lexical</u> <u>Conventions</u> <u>in</u> <u>bc</u>,
       the value shall be assumed in hexadecimal. (For example, <b>ibase</b>=A sets to  base  ten,  regardless  of  the
       current <b>ibase</b> value.) Otherwise, the behavior is undefined when digits greater than or equal to the value
       of <b>ibase</b> appear in the input. Both <b>ibase</b> and <b>obase</b> shall have initial values of 10.

       Internal  computations  shall be conducted as if in decimal, regardless of the input and output bases, to
       the  specified  number  of  decimal  digits.  When  an  exact  result  is  not  achieved  (for   example,
       <b>scale</b>=0; 3.2/1)<b>,</b> the result shall be truncated.

       For  all  values  of  <b>obase</b>  specified  by this volume of POSIX.1‐2017, <u>bc</u> shall output numeric values by
       performing each of the following steps in order:

        1. If the value is less than zero, a &lt;hyphen-minus&gt; (<b>'-'</b>) character shall be output.

        2. One of the following is output, depending on the numerical value:

            *  If the absolute value of the numerical value is greater than or equal to one, the integer portion
               of the value shall be output as a series of digits appropriate to  <b>obase</b>  (as  described  below),
               most  significant digit first. The most significant non-zero digit shall be output next, followed
               by each successively less significant digit.

            *  If the absolute value of the numerical value is less than one but greater than zero and the scale
               of the numerical value is greater than zero, it is unspecified whether the character 0 is output.

            *  If the numerical value is zero, the character 0 shall be output.

        3. If the scale of the value is greater than zero  and  the  numeric  value  is  not  zero,  a  &lt;period&gt;
           character  shall  be output, followed by a series of digits appropriate to <b>obase</b> (as described below)
           representing the most significant portion of the fractional part of the value. If  <u>s</u>  represents  the
           scale  of the value being output, the number of digits output shall be <u>s</u> if <b>obase</b> is 10, less than or
           equal to <u>s</u> if <b>obase</b> is greater than 10, or greater than or equal to <u>s</u> if <b>obase</b> is less than  10.  For
           <b>obase</b>  values  other  than 10, this should be the number of digits needed to represent a precision of
           10<u>s</u>.

       For <b>obase</b> values from 2 to 16, valid digits are the first <b>obase</b> of the single characters:

           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F

       which represent the values zero to 15, inclusive, respectively.

       For bases greater than 16, each digit shall be written as a separate  multi-digit  decimal  number.  Each
       digit except the most significant fractional digit shall be preceded by a single &lt;space&gt;.  For bases from
       17  to  100,  <u>bc</u>  shall  write two-digit decimal numbers; for bases from 101 to 1000, three-digit decimal
       strings, and so on. For example, the decimal number 1024 in base 25 would be written as:

            01 15 24

       and in base 125, as:

            008 024

       Very large numbers shall be split across lines with 70 characters per line in  the  POSIX  locale;  other
       locales  may  split  at  different  character  boundaries.  Lines  that  are  continued  shall end with a
       &lt;backslash&gt;.

       A function call shall consist of a function name followed by parentheses containing  a  &lt;comma&gt;-separated
       list  of  expressions,  which  are  the  function arguments. A whole array passed as an argument shall be
       specified by the array name followed by empty square brackets. All function arguments shall be passed  by
       value.  As  a result, changes made to the formal parameters shall have no effect on the actual arguments.
       If the function terminates by executing a <b>return</b> statement, the value of the function shall be the  value
       of  the  expression  in  the  parentheses  of  the  <b>return</b> statement or shall be zero if no expression is
       provided or if there is no <b>return</b> statement.

       The result of <b>sqrt</b>(<u>expression</u>) shall be the square root of the expression. The result shall be  truncated
       in  the  least significant decimal place. The scale of the result shall be the scale of the expression or
       the value of <b>scale</b>, whichever is larger.

       The result of <b>length</b>(<u>expression</u>) shall  be  the  total  number  of  significant  decimal  digits  in  the
       expression. The scale of the result shall be zero.

       The  result  of  <b>scale</b>(<u>expression</u>) shall be the scale of the expression. The scale of the result shall be
       zero.

       A numeric constant shall be an expression. The scale shall be the number of digits that follow the  radix
       point in the input representing the constant, or zero if no radix point appears.

       The  sequence  ( <u>expression</u> )  shall  be  an expression with the same value and scale as <u>expression</u>.  The
       parentheses can be used to alter the normal precedence.

       The semantics of the unary and binary operators are as follows:

       -<u>expression</u>
             The result shall be the negative of the <u>expression</u>.  The scale of the result shall be the scale  of
             <u>expression</u>.

       The unary increment and decrement operators shall not modify the scale of the named expression upon which
       they operate. The scale of the result shall be the scale of that named expression.

       ++<u>named-expression</u>
             The  named  expression  shall  be  incremented  by  one. The result shall be the value of the named
             expression after incrementing.

       --<u>named-expression</u>
             The named expression shall be decremented by one. The result  shall  be  the  value  of  the  named
             expression after decrementing.

       <u>named-expression</u>++
             The  named  expression  shall  be  incremented  by  one. The result shall be the value of the named
             expression before incrementing.

       <u>named-expression</u>--
             The named expression shall be decremented by one. The result  shall  be  the  value  of  the  named
             expression before decrementing.

       The exponentiation operator, &lt;circumflex&gt; (<b>'^'</b>), shall bind right to left.

       <u>expression</u>^<u>expression</u>
             The  result  shall  be  the  first <u>expression</u> raised to the power of the second <u>expression</u>.  If the
             second expression is not an integer, the behavior is undefined.  If <u>a</u> is  the  scale  of  the  left
             expression and <u>b</u> is the absolute value of the right expression, the scale of the result shall be:

                 if b &gt;= 0 min(a * b, max(scale, a)) if b &lt; 0 scale

       The multiplicative operators (<b>'*'</b>, <b>'/'</b>, <b>'%'</b>) shall bind left to right.

       <u>expression</u>*<u>expression</u>
             The  result  shall  be  the  product  of  the two expressions. If <u>a</u> and <u>b</u> are the scales of the two
             expressions, then the scale of the result shall be:

                 min(a+b,max(scale,a,b))

       <u>expression</u>/<u>expression</u>
             The result shall be the quotient of the two expressions. The scale of the result shall be the value
             of <b>scale</b>.

       <u>expression</u>%<u>expression</u>
             For expressions <u>a</u> and <u>b</u>, <u>a</u>%<u>b</u> shall be evaluated equivalent to the steps:

              1. Compute <u>a</u>/<u>b</u> to current scale.

              2. Use the result to compute:

                     a - (a / b) * b

                 to scale:

                     max(scale + scale(b), scale(a))

             The scale of the result shall be:

                 max(scale + scale(b), scale(a))

             When <b>scale</b> is zero, the <b>'%'</b> operator is the mathematical remainder operator.

       The additive operators (<b>'+'</b>, <b>'-'</b>) shall bind left to right.

       <u>expression</u>+<u>expression</u>
             The result shall be the sum of the two expressions. The scale of the result shall be the maximum of
             the scales of the expressions.

       <u>expression</u>-<u>expression</u>
             The result shall be the difference of the two expressions. The scale of the  result  shall  be  the
             maximum of the scales of the expressions.

       The assignment operators (<b>'='</b>, <b>"+="</b>, <b>"-="</b>, <b>"*="</b>, <b>"/="</b>, <b>"%="</b>, <b>"^="</b>) shall bind right to left.

       <u>named-expression</u>=<u>expression</u>
             This  expression  shall  result  in assigning the value of the expression on the right to the named
             expression on the left. The scale of both the named expression and the result shall be the scale of
             <u>expression</u>.

       The compound assignment forms:

           <u>named-expression</u> &lt;<u>operator</u>&gt;= <u>expression</u>

       shall be equivalent to:

           <u>named-expression</u>=<u>named-expression</u> &lt;<u>operator</u>&gt; <u>expression</u>

       except that the <u>named-expression</u> shall be evaluated only once.

       Unlike all other operators, the relational operators (<b>'&lt;'</b>, <b>'&gt;'</b>, <b>"&lt;="</b>, <b>"&gt;="</b>, <b>"=="</b>,  <b>"!="</b>)  shall  be  only
       valid as the object of an <b>if</b>, <b>while</b>, or inside a <b>for</b> statement.

       <u>expression1</u>&lt;<u>expression2</u>
             The  relation  shall  be  true  if  the  value  of  <u>expression1</u>  is strictly less than the value of
             <u>expression2</u>.

       <u>expression1</u>&gt;<u>expression2</u>
             The relation shall be true if the value of <u>expression1</u>  is  strictly  greater  than  the  value  of
             <u>expression2</u>.

       <u>expression1</u>&lt;=<u>expression2</u>
             The  relation  shall  be  true  if  the  value of <u>expression1</u> is less than or equal to the value of
             <u>expression2</u>.

       <u>expression1</u>&gt;=<u>expression2</u>
             The relation shall be true if the value of <u>expression1</u> is greater than or equal  to  the  value  of
             <u>expression2</u>.

       <u>expression1</u>==<u>expression2</u>
             The relation shall be true if the values of <u>expression1</u> and <u>expression2</u> are equal.

       <u>expression1</u>!=<u>expression2</u>
             The relation shall be true if the values of <u>expression1</u> and <u>expression2</u> are unequal.

       There  are only two storage classes in <u>bc</u>: global and automatic (local).  Only identifiers that are local
       to a function need be declared with the <b>auto</b> command. The arguments to a function shall be local  to  the
       function.   All  other  identifiers  are  assumed  to  be  global  and  available  to  all functions. All
       identifiers, global and local, have initial values  of  zero.  Identifiers  declared  as  auto  shall  be
       allocated  on  entry  to  the function and released on returning from the function. They therefore do not
       retain values between function calls. Auto arrays shall be specified by the array name followed by  empty
       square  brackets.  On  entry  to a function, the old values of the names that appear as parameters and as
       automatic variables shall be pushed onto a stack. Until the function returns, reference  to  these  names
       shall refer only to the new values.

       References  to  any  of these names from other functions that are called from this function also refer to
       the new value until one of those functions uses the same name for a local variable.

       When a statement is an expression, unless the main operator is an assignment, execution of the  statement
       shall write the value of the expression followed by a &lt;newline&gt;.

       When a statement is a string, execution of the statement shall write the value of the string.

       Statements  separated  by  &lt;semicolon&gt;  or  &lt;newline&gt;  characters  shall  be executed sequentially. In an
       interactive invocation of <u>bc</u>, each time a &lt;newline&gt; is read that satisfies the grammatical production:

           input_item : semicolon_list NEWLINE

       the sequential list of statements making up the <b>semicolon_list</b> shall  be  executed  immediately  and  any
       output produced by that execution shall be written without any delay due to buffering.

       In an <b>if</b> statement (<b>if</b>(<u>relation</u>) <u>statement</u>), the <u>statement</u> shall be executed if the relation is true.

       The  <b>while</b>  statement (<b>while</b>(<u>relation</u>) <u>statement</u>) implements a loop in which the <u>relation</u> is tested; each
       time the <u>relation</u> is true, the <u>statement</u> shall be executed and the <u>relation</u> retested. When  the  <u>relation</u>
       is false, execution shall resume after <u>statement</u>.

       A <b>for</b> statement(<b>for</b>(<u>expression</u>; <u>relation</u>; <u>expression</u>) <u>statement</u>) shall be the same as:

           <u>first-expression</u>
           while (<u>relation</u>) {
               <u>statement</u>
               <u>last-expression</u>
           }

       The application shall ensure that all three expressions are present.

       The <b>break</b> statement shall cause termination of a <b>for</b> or <b>while</b> statement.

       The  <b>auto</b>  statement  (<b>auto</b> <u>identifier</u> <b>[</b>,<u>identifier</u><b>]</b> ...) shall cause the values of the identifiers to be
       pushed down.  The identifiers can be ordinary identifiers or array identifiers. Array  identifiers  shall
       be  specified by following the array name by empty square brackets. The application shall ensure that the
       <b>auto</b> statement is the first statement in a function definition.

       A <b>define</b> statement:

           define <u>LETTER</u> ( <u>opt_parameter_list</u> ) {
               <u>opt_auto_define_list</u>
               <u>statement_list</u>
           }

       defines a function named <b>LETTER</b>.  If a function named <b>LETTER</b> was previously defined, the <b>define</b> statement
       shall replace the previous definition. The expression:

           LETTER ( <u>opt_argument_list</u> )

       shall invoke the function named <b>LETTER</b>.  The behavior is undefined if the  number  of  arguments  in  the
       invocation  does  not match the number of parameters in the definition. Functions shall be defined before
       they are invoked. A function shall be considered to be defined within its own body,  so  recursive  calls
       are  valid.  The values of numeric constants within a function shall be interpreted in the base specified
       by the value of the <b>ibase</b> register when the function is invoked.

       The <b>return</b> statements (<b>return</b> and <b>return</b>(<u>expression</u>)) shall cause termination of a function,  popping  of
       its  auto  variables, and specification of the result of the function. The first form shall be equivalent
       to <b><a href="../man0/return.0.html">return</a></b>(0).  The value and scale of the result returned by the function shall be the value and scale of
       the expression returned.

       The <b>quit</b> statement (<b>quit</b>) shall stop execution of a <u>bc</u> program at the point where the statement occurs in
       the input, even if it occurs in a function definition, or in an <b>if</b>, <b>for</b>, or <b>while</b> statement.

       The following functions shall be defined when the <b>-l</b> option is specified:

       <b>s</b>( <u>expression</u> )
             Sine of argument in radians.

       <b>c</b>( <u>expression</u> )
             Cosine of argument in radians.

       <b>a</b>( <u>expression</u> )
             Arctangent of argument.

       <b>l</b>( <u>expression</u> )
             Natural logarithm of argument.

       <b>e</b>( <u>expression</u> )
             Exponential function of argument.

       <b>j</b>( <u>expression1</u>, <u>expression2</u> )
             Bessel function of <u>expression2</u> of the first kind of integer order <u>expression1</u>.

       The scale of the result returned by these functions shall be the value of the <b>scale</b> register at the  time
       the  function  is  invoked.  The  value  of the <b>scale</b> register after these functions have completed their
       execution shall be the same value it had upon invocation. The behavior  is  undefined  if  any  of  these
       functions is invoked with an argument outside the domain of the mathematical function.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The following exit values shall be returned:

       0         All input files were processed successfully.

       <u>unspecified</u>
                 An error occurred.

</pre><h4><b>CONSEQUENCES</b> <b>OF</b> <b>ERRORS</b></h4><pre>
       If  any  <u>file</u>  operand  is  specified  and the named file cannot be accessed, <u>bc</u> shall write a diagnostic
       message to standard error and terminate without any further action.

       In an interactive invocation of <u>bc</u>, the utility should print an error message and recover  following  any
       error in the input. In a non-interactive invocation of <u>bc</u>, invalid input causes undefined behavior.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Automatic variables in <u>bc</u> do not work in exactly the same way as in either C or PL/1.

       For  historical  reasons,  the  exit  status  from <u>bc</u> cannot be relied upon to indicate that an error has
       occurred.  Returning zero after an  error  is  possible.  Therefore,  <u>bc</u>  should  be  used  primarily  by
       interactive  users (who can react to error messages) or by application programs that can somehow validate
       the answers returned as not including error messages.

       The <u>bc</u> utility always uses the &lt;period&gt; (<b>'.'</b>)  character to represent a radix point,  regardless  of  any
       decimal-point character specified as part of the current locale. In languages like C or <u>awk</u>, the &lt;period&gt;
       character  is  used  in  program source, so it can be portable and unambiguous, while the locale-specific
       character is used in input and output. Because there is no distinction between source and  input  in  <u>bc</u>,
       this arrangement would not be possible. Using the locale-specific character in <u>bc</u>'s input would introduce
       ambiguities  into the language; consider the following example in a locale with a &lt;comma&gt; as the decimal-
       point character:

           define f(a,b) {
               ...
           }
           ...

           f(1,2,3)

       Because of such ambiguities, the &lt;period&gt; character is used  in  input.  Having  input  follow  different
       conventions from output would be confusing in either pipeline usage or interactive usage, so the &lt;period&gt;
       is also used in output.

</pre><h4><b>EXAMPLES</b></h4><pre>
       In the shell, the following assigns an approximation of the first ten digits of <b>'π'</b> to the variable <u>x</u>:

           x=$(printf "%s\n" 'scale = 10; 104348/33215' | bc)

       The following <u>bc</u> program prints the same approximation of <b>'π'</b>, with a label, to standard output:

           scale = 10
           "pi equals "
           104348 / 33215

       The  following  defines a function to compute an approximate value of the exponential function (note that
       such a function is predefined if the <b>-l</b> option is specified):

           scale = 20
           define e(x){
               auto a, b, c, i, s
               a = 1
               b = 1
               s = 1
               for (i = 1; 1 == 1; i++){
                   a = a*x
                   b = b*i
                   c = a/b
                   if (c == 0) {
                        return(s)
                   }
                   s = s+c
               }
           }

       The following prints approximate values of the exponential function of the first ten integers:

           for (i = 1; i &lt;= 10; ++i) {
               e(i)
           }

</pre><h4><b>RATIONALE</b></h4><pre>
       The <u>bc</u> utility is implemented historically as a front-end processor for <u>dc</u>; <u>dc</u> was  not  selected  to  be
       part  of  this  volume  of  POSIX.1‐2017  because  <u>bc</u>  was  thought to have a more intuitive programmatic
       interface. Current implementations that implement <u>bc</u> using <u>dc</u> are expected to be compliant.

       The exit status for error conditions has been left unspecified for several reasons:

        *  The <u>bc</u> utility is used in both interactive and non-interactive situations.  Different exit codes  may
           be appropriate for the two uses.

        *  It  is  unclear when a non-zero exit should be given; divide-by-zero, undefined functions, and syntax
           errors are all possibilities.

        *  It is not clear what utility the exit status has.

        *  In the 4.3 BSD, System V, and Ninth Edition implementations, <u>bc</u> works in conjunction with <u>dc</u>.  The <u>dc</u>
           utility is the parent, <u>bc</u> is the child. This was done to cleanly terminate <u>bc</u> if <u>dc</u> aborted.

       The decision to have <u>bc</u> exit upon encountering an inaccessible input file is based on the belief that  <u>bc</u>
       <u>file1</u>  <u>file2</u>  is used most often when at least <u>file1</u> contains data/function declarations/initializations.
       Having <u>bc</u> continue with prerequisite files missing is probably not useful. There is no implication in the
       CONSEQUENCES OF ERRORS section that <u>bc</u> must check all its files for accessibility before opening  any  of
       them.

       There  was  considerable debate on the appropriateness of the language accepted by <u>bc</u>.  Several reviewers
       preferred to see either a pure subset of the C language  or  some  changes  to  make  the  language  more
       compatible  with C.  While the <u>bc</u> language has some obvious similarities to C, it has never claimed to be
       compatible with any version of C. An interpreter for a subset of C might be a  very  worthwhile  utility,
       and  it could potentially make <u>bc</u> obsolete. However, no such utility is known in historical practice, and
       it was not within the scope of this volume of POSIX.1‐2017 to define such a language and utility. If  and
       when  they  are defined, it may be appropriate to include them in a future version of this standard. This
       left the following alternatives:

        1. Exclude any calculator language from this volume of POSIX.1‐2017.

           The consensus of the standard developers was that a simple programmatic calculator language  is  very
           useful  for  both applications and interactive users. The only arguments for excluding any calculator
           were that it would become obsolete if and when a C-compatible one emerged, or that the absence  would
           encourage  the  development  of such a C-compatible one. These arguments did not sufficiently address
           the needs of current application developers.

        2. Standardize the historical <u>dc</u>, possibly with minor modifications.

           The consensus of the standard developers was that <u>dc</u> is a fundamentally less usable language and that
           that would be far too severe a penalty for avoiding the issue of being similar  to  but  incompatible
           with C.

        3. Standardize the historical <u>bc</u>, possibly with minor modifications.

           This  was  the  approach  taken.  Most of the proponents of changing the language would not have been
           satisfied until most or all of the incompatibilities with C were resolved. Since most of the  changes
           considered most desirable would break historical applications and require significant modification to
           historical  implementations, almost no modifications were made. The one significant modification that
           was made was the replacement of the historical <u>bc</u> assignment operators <b>"=+"</b>, and so on, with the more
           modern <b>"+="</b>, and so on. The older versions are considered to be fundamentally flawed because  of  the
           lexical ambiguity in uses like <u>a</u>=-1.

           In order to permit implementations to deal with backwards-compatibility as they see fit, the behavior
           of  this  one ambiguous construct was made undefined. (At least three implementations have been known
           to support this change already, so the degree of change involved should not be great.)

       The <b>'%'</b> operator is the mathematical remainder operator when <b>scale</b> is zero. The behavior of this operator
       for other values of <b>scale</b> is from historical implementations of <u>bc</u>, and has been maintained for the  sake
       of historical applications despite its non-intuitive nature.

       Historical  implementations  permit  setting  <b>ibase</b> and <b>obase</b> to a broader range of values. This includes
       values less than 2, which were not seen as sufficiently useful to standardize. These  implementations  do
       not  interpret  input  properly  for  values  of  <b>ibase</b> that are greater than 16. This is because numeric
       constants  are  recognized  syntactically,  rather  than  lexically,  as  described  in  this  volume  of
       POSIX.1‐2017.  They  are  built from lexical tokens of single hexadecimal digits and &lt;period&gt; characters.
       Since &lt;blank&gt; characters between tokens are not visible at the syntactic level, it  is  not  possible  to
       recognize the multi-digit ``digits'' used in the higher bases properly. The ability to recognize input in
       these  bases  was not considered useful enough to require modifying these implementations.  Note that the
       recognition of numeric constants at the syntactic level is not a problem with conformance to this  volume
       of POSIX.1‐2017, as it does not impact the behavior of conforming applications (and correct <u>bc</u> programs).
       Historical implementations also accept input with all of the digits <b>'0'</b>-<b>'9'</b> and <b>'A'</b>-<b>'F'</b> regardless of the
       value  of  <b>ibase</b>;  since digits with value greater than or equal to <b>ibase</b> are not really appropriate, the
       behavior when they appear is undefined, except for the common case of:

           ibase=8;
               /* Process in octal base. */
           ...
           ibase=A
               /* Restore decimal base. */

       In some historical implementations, if the expression to be written is an uninitialized array element,  a
       leading  &lt;space&gt;  and/or  up  to  four leading 0 characters may be output before the character zero. This
       behavior is considered a bug; it is unlikely that any currently conforming application relies on:

           echo 'b[3]' | bc

       returning 00000 rather than 0.

       Exact calculation of the number of fractional digits to output for a given value in a base other than  10
       can  be  computationally  expensive.   Historical implementations use a faster approximation, and this is
       permitted. Note that the requirements apply only to values of <b>obase</b>  that  this  volume  of  POSIX.1‐2017
       requires  implementations to support (in particular, not to 1, 0, or negative bases, if an implementation
       supports them as an extension).

       Historical implementations of <u>bc</u> did not allow array parameters to be passed as the last parameter  to  a
       function. New implementations are encouraged to remove this restriction even though it is not required by
       the grammar.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>1.3</u>, <u>Grammar</u> <u>Conventions</u>, <u>awk</u>

       The  Base  Definitions  volume  of  POSIX.1‐2017, <u>Chapter</u> <u>8</u>, <u>Environment</u> <u>Variables</u>, <u>Section</u> <u>12.2</u>, <u>Utility</u>
       <u>Syntax</u> <u>Guidelines</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                            <u><a href="../man1POSIX/BC.1POSIX.html">BC</a></u>(1POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>