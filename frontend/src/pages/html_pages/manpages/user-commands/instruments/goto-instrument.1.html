<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>goto-instrument - Perform analysis or instrumentation of goto binaries</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/cbmc">cbmc_6.4.1-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       goto-instrument - Perform analysis or instrumentation of goto binaries

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>goto-instrument</b> <b>[-?]</b> <b>[-h]</b> <b>[--help]</b>
              show help

       <b>goto-instrument</b> <b>--version</b>
              show version and exit

       <b>goto-instrument</b> <b>[options]</b> <u>in</u> [<u>out</u>]
              perform analysis or instrumentation

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>goto-instrument</b>  reads  a  GOTO  binary,  performs  a  given  program transformation, and then writes the
       resulting program as GOTO binary on disk.

</pre><h4><b>OPTIONS</b></h4><pre>
   <b>Dump</b> <b>Source:</b>
       <b>--dump-c</b>
              generate C source

       <b>--dump-c-type-header</b> <u>m</u>
              generate a C header for types local in <u>m</u>

       <b>--dump-cpp</b>
              generate C++ source

       <b>--no-system-headers</b>
              generate C source expanding libc includes

       <b>--use-all-headers</b>
              generate C source with all includes

       <b>--harness</b>
              include input generator in output

       <b>--horn</b> print program as constrained horn clauses

   <b>Diagnosis:</b>
       <b>--show-properties</b>
              show the properties, but don't run analysis

       <b>--document-properties-html</b>
              generate HTML property documentation

       <b>--document-properties-latex</b>
              generate Latex property documentation

       <b>--show-symbol-table</b>
              show loaded symbol table

       <b>--list-symbols</b>
              list symbols with type information

       <b>--show-goto-functions</b>
              show loaded goto program

       <b>--list-goto-functions</b>
              list loaded goto functions

       <b>--count-eloc</b>
              count effective lines of code

       <b>--list-eloc</b>
              list full path names of lines containing code

       <b>--print-global-state-size</b>
              count the total number of bits of global objects

       <b>--print-path-lengths</b>
              print statistics about control-flow graph paths

       <b>--show-locations</b>
              show all source locations

       <b>--dot</b>  generate CFG graph in DOT format

       <b>--print-internal-representation</b>
              show verbose internal representation of the program

       <b>--list-undefined-functions</b>
              list functions without body

       <b>--list-calls-args</b>
              list all function calls with their arguments

       <b>--call-graph</b>
              show graph of function calls

       <b>--reachable-call-graph</b>
              show graph of function calls potentially reachable from main function

       <b>--show-class-hierarchy</b>
              show the class hierarchy

       <b>--validate-goto-model</b>
              enable additional well-formedness checks on the goto program

       <b>--validate-ssa-equation</b>
              enable additional well-formedness checks on the SSA representation

       <b>--validate-goto-binary</b>
              check the well-formedness of the passed in GOTO binary and then exit

       <b>--interpreter</b>
              do concrete execution

   <b>Data-flow</b> <b>analyses:</b>
       <b>--show-struct-alignment</b>
              show struct members that might be concurrently accessed

       <b>--show-threaded</b>
              show instructions that may be executed by more than one thread

       <b>--show-local-safe-pointers</b>
              show pointer expressions that are trivially dominated by a not-null check

       <b>--show-safe-dereferences</b>
              show pointer expressions that are trivially  dominated  by  a  not-null  check  *and*  used  as  a
              dereference operand

       <b>--show-value-sets</b>
              show points-to information (using value sets)

       <b>--show-global-may-alias</b>
              show may-alias information over globals

       <b>--show-local-bitvector-analysis</b>
              show procedure-local pointer analysis

       <b>--escape-analysis</b>
              perform escape analysis

       <b>--show-escape-analysis</b>
              show results of escape analysis

       <b>--custom-bitvector-analysis</b>
              perform configurable bitvector analysis

       <b>--show-custom-bitvector-analysis</b>
              show results of configurable bitvector analysis

       <b>--interval-analysis</b>
              perform interval analysis

       <b>--show-intervals</b>
              show results of interval analysis

       <b>--show-uninitialized</b>
              show maybe-uninitialized variables

       <b>--show-points-to</b>
              show points-to information

       <b>--show-rw-set</b>
              show read-write sets

       <b>--show-call-sequences</b>
              show function call sequences

       <b>--show-reaching-definitions</b>
              show reaching definitions

       <b>--show-dependence-graph</b>
              show program-dependence graph

       <b>--show-sese-regions</b>
              show single-entry-single-exit regions

   <b>Safety</b> <b>checks:</b>
       <b>--no-assertions</b>
              ignore user assertions

       <b>--bounds-check</b>
              enable array bounds checks

       <b>--pointer-check</b>
              enable pointer checks

       <b>--memory-leak-check</b>
              enable memory leak checks

       <b>--memory-cleanup-check</b>
              Enable  memory  cleanup  checks:  assert that all dynamically allocated memory is explicitly freed
              before terminating the program.

       <b>--div-by-zero-check</b>
              enable division by zero checks for integer division

       <b>--float-div-by-zero-check</b>
              enable division by zero checks for floating-point division

       <b>--signed-overflow-check</b>
              enable signed arithmetic over- and underflow checks

       <b>--unsigned-overflow-check</b>
              enable arithmetic over- and underflow checks

       <b>--pointer-overflow-check</b>
              enable pointer arithmetic over- and underflow checks

       <b>--conversion-check</b>
              check whether values can be represented after type cast

       <b>--undefined-shift-check</b>
              check shift greater than bit-width

       <b>--float-overflow-check</b>
              check floating-point for +/-Inf

       <b>--nan-check</b>
              check floating-point for NaN

       <b>--enum-range-check</b>
              checks that all enum type expressions have values in the enum range

       <b>--pointer-primitive-check</b>
              checks that all pointers in pointer primitives are valid or null

       <b>--retain-trivial-checks</b>
              include checks that are trivially true

       <b>--error-label</b> label
              check that label is unreachable

       <b>--no-built-in-assertions</b>
              ignore assertions in built-in library

       <b>--no-assertions</b>
              ignore user assertions

       <b>--no-assumptions</b>
              ignore user assumptions

       <b>--assert-to-assume</b>
              convert user assertions to assumptions

       <b>--uninitialized-check</b>
              add checks for uninitialized locals (experimental)

       <b>--stack-depth</b> n
              add check that call stack size of non-inlined functions never exceeds n

       <b>--race-check</b>
              add floating-point data race checks

   <b>Semantic</b> <b>transformations:</b>
       <b>--nondet-volatile</b>
       <b>--nondet-volatile-variable</b> <u>variable</u>
              By default, <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1) treats volatile variables the same as non-volatile  variables.   That  is,  it
              assumes  that  a volatile variable does not change between subsequent reads, unless it was written
              to by the program. With the above options, <b>goto-instrument</b> can be  instructed  to  instrument  the
              given  goto  program  such  as  to  (1) make reads from all volatile expressions non-deterministic
              (<b>--nondet-volatile</b>),    (2)    make    reads    from    specific    variables    non-deterministic
              (<b>--nondet-volatile-variable</b>),  or  (3)  model  reads  from  specific  variables  by  given  models
              (<b>--nondet-volatile-model</b>).

              Below we give two usage examples for the  options.  Consider  the  following  test,  for  function
              <u>get_celsius</u> and with harness <u>test_get_celsius</u>:

                  <b>#include</b> &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
                  <b>#include</b> &lt;<a href="file:/usr/include/limits.h">limits.h</a>&gt;
                  <b>#include</b> &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;

                  <b>//</b> <b>hardware</b> <b>sensor</b> <b>for</b> <b>temperature</b> <b>in</b> <b>kelvin</b>
                  <b>extern</b> <b>volatile</b> uint16_t temperature;

                  int <b>get_celsius</b>() {
                    <b>if</b> (temperature &gt; (1000 + 273)) {
                      <b>return</b> INT_MIN; <b>//</b> <b>value</b> <b>indicating</b> <b>error</b>
                    }
                    <b>return</b> temperature - 273;
                  }

                  void <b>test_get_celsius</b>() {
                    int t = <b>get_celsius</b>();
                    <b>assert</b>(t == INT_MIN || t &lt;= 1000);
                    <b>assert</b>(t == INT_MIN || t &gt;= -273);
                  }

              Here the variable <u>temperature</u> corresponds to a hardware sensor. It returns the current temperature
              on  each read. The <u>get_celsius</u> function converts the value in Kelvin to degrees Celsius, given the
              value is in the expected range.  However, it has a bug where it reads <u>temperature</u>  a  second  time
              after  the  check,  which may yield a value for which the check would not succeed.  Verifying this
              program as is with <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1) would yield a verification success. We can use <b>goto-instrument</b> to  make
              reads from <u>temperature</u> non-deterministic:

                  goto-cc -o get_celsius_test.gb get_celsius_test.c
                  goto-instrument --nondet-volatile-variable temperature \
                    get_celsius_test.gb get_celsius_test-mod.gb
                  cbmc --function test_get_celsius get_celsius_test-mod.gb

              Here the final invocation of <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1) correctly reports a verification failure.

       <b>--nondet-volatile-model</b> <u>variable</u>:<u>model</u>
              Simply  treating volatile variables as non-deterministic may for some use cases be too inaccurate.
              Consider the following test, for function <u>get_message</u> and with harness <u>test_get_message</u>:

                  <b>#include</b> &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
                  <b>#include</b> &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;

                  <b>extern</b> <b>volatile</b> uint32_t clock;

                  <b>typedef</b> <b>struct</b> message {
                    uint32_t timestamp;
                    void *data;
                  } message_t;

                  void *<b>read_data</b>();

                  message_t <b>get_message</b>() {
                    message_t msg;
                    msg.timestamp = clock;
                    msg.data = <b>read_data</b>();
                    <b>return</b> msg;
                  }

                  void <b>test_get_message</b>() {
                    message_t msg1 = <b>get_message</b>();
                    message_t msg2 = <b>get_message</b>();
                    <b>assert</b>(msg1.timestamp &lt;= msg2.timestamp);
                  }

              The harness verifies that <u>get_message</u> assigns non-decreasing time stamps to the returned messages.
              However, simply treating <u>clock</u> as non-deterministic would not  suffice  to  prove  this  property.
              Thus, we can supply a model for reads from <u>clock</u>:

                  <b>//</b> <b>model</b> <b>for</b> <b>reads</b> <b>of</b> <b>the</b> <b>variable</b> <b>clock</b>
                  uint32_t <b>clock_read_model</b>() {
                    <b>static</b> uint32_t clock_value = 0;
                    uint32_t increment;
                    <b>__CPROVER_assume</b>(increment &lt;= 100);
                    clock_value += increment;
                    <b>return</b> clock_value;
                  }

              The model is stateful in that it keeps the current clock value between invocations in the variable
              <u>clock_value</u>. On each invocation, it increments the clock by a non-deterministic value in the range
              0  to  100.  We  can  tell  <b>goto-instrument</b>  to  use the model <u>clock_read_model</u> for reads from the
              variable <u>clock</u> as follows:

                  goto-cc -o get_message_test.gb get_message_test.c
                  goto-instrument --nondet-volatile-model clock:clock_read_model \
                    get_message_test.gb get_message_test-mod.gb
                  cbmc --function get_message_test get_message_test-mod.gb

              Now the final invocation of <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1) reports verification success.

       <b>--isr</b> <u>function</u>
              instruments an interrupt service routine

       <b>--mmio</b> instruments memory-mapped I/O

       <b>--nondet-static</b>
              add nondeterministic initialization of variables with static lifetime

       <b>--nondet-static-exclude</b> <u>e</u>
              same as nondet-static except for the variable <u>e</u> (use multiple times if required)

       <b>--nondet-static-matching</b> <u>r</u>
              add nondeterministic initialization of variables with static lifetime matching regex <u>r</u>

       <b>--function-enter</b> <u>f</u>
       <b>--function-exit</b> <u>f</u>
       <b>--branch</b> <u>f</u>
              instruments a call to <u>f</u> at the beginning, the exit, or a branch point, respectively

       <b>--splice-call</b> <u>caller</u>,<u>callee</u>
              prepends a call to <u>callee</u> in the body of <u>caller</u>

       <b>--check-call-sequence</b> <u>seq</u>
              instruments checks to assert that all call sequences match <u>seq</u>

       <b>--undefined-function-is-assume-false</b>
              convert each call to an undefined function to assume(false)

       <b>--insert-final-assert-false</b> <u>function</u>
              generate assert(false) at end of <u>function</u>

       <b>--generate-function-body</b> <u>regex</u>
              This transformation inserts implementations of functions without definition,  i.e.,  a  body.  The
              behavior of the generated function is chosen via <b>--generate-function-body-options</b> <u>option</u>:

       <b>--generate-function-body-options</b> <u>option</u>
              One     of    <b>assert-false</b>,    <b>assume-false</b>,    <b>nondet-return</b>,    <b>assert-false-assume-false</b>    and
              <b>havoc</b>[,<b>params:</b><u>regex</u>][,<b>globals:</b><u>regex</u>][,<b>params:</b><u>p_n1</u>;<u>p_n2</u>;..]  (default: <b>nondet-return</b>)

              <b>assert-false</b>: The body consists of a single command: <b><a href="../man0/assert.0.html">assert</a>(0)</b>.

              <b>assume-false</b>: The body consists of a single command: <b><a href="../man0/assume.0.html">assume</a>(0)</b>.

              <b>assert-false-assume-false</b>: Two commands as above.

              <b>nondet-return</b>: The generated function returns a non-deterministic value of its return type.

              <b>havoc</b>[,<b>params:</b><u>p-regex</u>][,<b>globals:</b><u>g-regex</u>]:  Assign  non-deterministic  values  to  the  targets  of
              pointer-to-non-constant  parameters  matching  the  regular  expression  <u>p-regex</u>, and non-constant
              globals matching <u>g-regex</u>, and then (in case of non-void function) returning as with <b>nondet-return</b>.
              The following example demonstrates the use:

                  <b>//</b> <b>main.c</b>
                  int global;
                  <b>const</b> int c_global;
                  int <b>function</b>(int *param, <b>const</b> int *c_param);

              Often we want to avoid overwriting internal symbols, i.e., those with an <b>__</b> prefix, which is  done
              using the pattern <b>(?!__)</b>.

                  goto-cc main.c -o main.gb
                  goto-instrument main.gb main-out.gb \
                    --generate-function-body-options 'havoc,params:(?!__).*,globals:(?!__).*' \
                    --generate-funtion-body function

              This leads to a GOTO binary equivalent to the following C code:

                  <b>//</b> <b>main-mod.c</b>
                  int <b>function</b>(int *param, <b>const</b> int *c_param) {
                    *param = <b>nondet_int</b>();
                    global = <b>nondet_int</b>();
                    <b>return</b> <b>nondet_int</b>();
                  }

              The  parameters  should  that should be non-deterministically updated can be specified either by a
              regular expression (as above) or by a semicolon-separated  list  of  their  numbers.  For  example
              <u>havoc,params:0;3;4</u> will assign non-deterministic values to the first, fourth, and fifth parameter.

              Note that only parameters of pointer type can be havoced and <b>goto-instrument</b> will produce an error
              report  if given a parameter number associated with a non-pointer parameter. Requesting to havoc a
              parameter with a number higher than the number of parameters a  given  function  takes  will  also
              results in an error report.

       <b>--generate-havocing-body</b> <u>option</u> <u>fun_name</u>,<b>params:</b><u>p_n1</u>;<u>p_n2</u>;..
       <b>--generate-havocing-body</b> <u>option</u> <u>fun_name</u>[,<u>call-site-id</u>,<b>params:</b><u>p_n1</u>;<u>p_n2</u>;..&gt;]+
              Request  a  different  implementation  for a number of call-sites of a single function. The option
              <b>--generate-havocing-body</b> inserts new functions for selected call-sites and replaces the  calls  to
              the origin function with calls to the respective new functions.

                  <b>//</b> <b>main.c</b>
                  int <b>function</b>(int *first, int *second, int *third);

                  int <b>main</b>() {
                    int a = 10;
                    int b = 10;
                    int c = 10;
                    <b>function</b>(&amp;a, &amp;b, &amp;c);
                    <b>function</b>(&amp;a, &amp;b, &amp;c);
                  }

              The user can specify different behavior for each call-site as follows:

                  goto-cc main.c -o main.gb
                  goto-instrument main.gb  main-mod.gb \
                    --generate-havocing-body 'function,1,params:0;2,2,params:1'

              This results in a GOTO binary equivalent to:

                  <b>//</b> <b>main-mod.c</b>
                  int <b>function_1</b>(int *first, int *second, int *third) {
                    *first = <b>nondet_int</b>();
                    *third = <b>nondet_int</b>();
                  }

                  int <b>function_2</b>(int *first, int *second, int *third) { *second = <b>nondet_int</b>(); }

                  int <b>main</b>() {
                    int a = 10;
                    int b = 10;
                    int c = 10;
                    <b>function_1</b>(&amp;a, &amp;b, &amp;c);
                    <b>function_2</b>(&amp;a, &amp;b, &amp;c);
                  }

       <b>--restrict-function-pointer</b>
              <u>pointer_name</u>/<u>target</u>[,<u>targets</u>]*  Replace  function  pointers by a user-defined set of targets. This
              may be required when <b>--remove-function-pointers</b> creates to large a set of direct calls.   Consider
              the  example  presented  for  <b>--remove-function-pointers</b>.  Assume  that  <u>call</u>  will always receive
              pointers to either <u>f</u> or <u>g</u> during actual executions of the program, and symbolic execution for <u>h</u> is
              too expensive to simply ignore the cost of its branch.

              To facilitate the controlled replace, we will label the places in  each  function  where  function
              pointers are being called, to this pattern:

              <u>function-name</u>.<b>function_pointer_call</b>.<u>N</u>

              where  <u>N</u>  is  refers  to the <u>N</u>-th function call via a function pointer in <u>function-name</u>, i.e., the
              first call to a function pointer in a function will have <u>N=1</u>, the fifth <u>N=5</u>  etc.   Alternatively,
              if the calls carry labels in the source code, we can also refer to a function pointer as

              <u>function-name</u>.<u>label</u>

              To implement this assumption that the first call to a function pointer in function <u>call</u> an only be
              a call to <u>f</u> or <u>g</u>, use

                  goto-instrument --restrict-function-pointer \
                    call.function_pointer_call.1/f,g in.gb out.gb

              The resulting output (written to GOTO binary <u>out.gb</u>) looks similar to the original example, except
              now there will not be a call to <u>h</u>:

                  void <b>call</b>(fptr_t fptr) {
                    int r;
                    <b>if</b> (fptr == &amp;f) {
                      r = <b><a href="../man10/f.10.html">f</a></b>(10);
                    } <b>else</b> <b>if</b> (fptr == &amp;g) {
                      r = <b><a href="../man10/g.10.html">g</a></b>(10);
                    } <b>else</b> {
                      <b>//</b> <b>sanity</b> <b>check</b>
                      <b>assert</b>(false);
                      <b>assume</b>(false);
                    }
                    <b>return</b> r;
                  }

              As another example imagine we have a simple virtual filesystem API and implementation like this:

                  <b>typedef</b> <b>struct</b> filesystem_t filesystem_t;
                  <b>struct</b> filesystem_t {
                    int (*open)(filesystem_t *filesystem, <b>const</b> char *file_name);
                  };

                  int <b>fs_open</b>(filesystem_t *filesystem, <b>const</b> char *file_name) {
                    filesystem-&gt;<b>open</b>(filesystem, file_name);
                  }

                  int <b>nullfs_open</b>(filesystem_t *filesystem, <b>const</b> char *file_name) { <b>return</b> -1; }

                  filesystem_t nullfs_val = {.open = nullfs_open};
                  filesystem *<b>const</b> nullfs = &amp;nullfs_val;

                  filesystem_t *<b>get_fs_impl</b>() {
                    <b>//</b> <b>some</b> <b>fancy</b> <b>logic</b> <b>to</b> <b>determine</b>
                    <b>//</b> <b>which</b> <b>filesystem</b> <b>we're</b> <b>getting</b> <b>-</b>
                    <b>//</b> <b>in-memory,</b> <b>backed</b> <b>by</b> <b>a</b> <b>database,</b> <b>OS</b> <b>file</b> <b>system</b>
                    <b>//</b> <b>-</b> <b>but</b> <b>in</b> <b>our</b> <b>case,</b> <b>we</b> <b>know</b> <b>that</b>
                    <b>//</b> <b>it</b> <b>always</b> <b>ends</b> <b>up</b> <b>being</b> <b>nullfs</b>
                    <b>//</b> <b>for</b> <b>the</b> <b>cases</b> <b>we</b> <b>care</b> <b>about</b>
                    <b>return</b> nullfs;
                  }
                  int <b>main</b>(void) {
                    filesystem_t *fs = <b>get_fs_impl</b>();
                    <b>assert</b>(<b>fs_open</b>(fs, "hello.txt") != -1);
                  }

              In  this  case,  the assumption is that in function <u>main</u>, <u>fs</u> can be nothing other than <u>nullfs</u>. But
              perhaps due to the logic being too complicated, symbolic execution ends up being unable to  figure
              this out, so in the call to <u>fs_open</u> we end up branching on all functions matching the signature of
              <u>filesystem_t::open</u>, which could be quite a few functions within the program.  Worst of all, if its
              address   is   ever   taken   in   the   program,   as   far   as  function  pointer  removal  via
              <b>--remove-function-pointers</b> is concerned it could be <u>fs_open</u> itself due to  it  having  a  matching
              signature,  leading  to symbolic execution being forced to follow a potentially infinite recursion
              until its unwind limit.

              In this case we can again restrict the function pointer to the value which we know it will have:

                  goto-instrument --restrict-function-pointer \
                    fs_open.function_pointer_call.1/nullfs_open in.gb out.gb

       <b>--function-pointer-restrictions-file</b> <u>file_name</u>
              If you have many places where you want to restrict function pointers, it'd be a nuisance  to  have
              to  specify  them  all  on  the  command  line. In these cases, you can specify a file to load the
              restrictions from instead, which you can give the name of a JSON file with this format:

                  {
                    "function_call_site_name": ["function1", "function2", ...],
                     ...
                  }

              If you pass in multiple files, or a  mix  of  files  and  command  line  restrictions,  the  final
              restrictions will be a set union of all specified restrictions.

              Note  that  if  something  goes  wrong  during  type checking (i.e., making sure that all function
              pointer replacements refer to functions in the symbol table that have the correct type), the error
              message will refer to the command line option <b>--restrict-function-pointer</b>  regardless  of  whether
              the restriction in question came from the command line or a file.

       <b>--restrict-function-pointer-by-name</b> <u>symbol_name</u>/<u>target</u>[,<u>targets</u>]*
              Restrict  a  function  pointer  where  <u>symbol_name</u> is the unmangled name, before labeling function
              pointers.

       <b>--remove-calls-no-body</b>
              remove calls to functions without a body

       <b>--add-library</b>
              add models of C library functions

       <b>--malloc-may-fail</b>
              allow malloc calls to return a null pointer

       <b>--malloc-fail-assert</b>
              set malloc failure mode to assert-then-assume

       <b>--malloc-fail-null</b>
              set malloc failure mode to return null

       <b>--no-malloc-may-fail</b>
              do not allow malloc calls to fail by default

       <b>--string-abstraction</b>
              track C string lengths and zero-termination

       <b>--model-argc-argv</b> <u>n</u>
              Create up to <u>n</u> non-deterministic C strings as entries to <u>argv</u> and set <u>argc</u> accordingly. In absence
              of such modelling, <u>argv</u> is left uninitialized except for a terminating <b>NULL</b> pointer. Consider  the
              following example:

                  <b>//</b> <b>needs_argv.c</b>
                  <b>#include</b> &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;

                  int <b>main</b>(int argc, char *argv[]) {
                    <b>if</b> (argc &gt;= 2)
                      <b>assert</b>(argv[1] != 0);

                    <b>return</b> 0;
                  }

              If  <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1)  is  run  directly on this example, it will report a failing assertion for the lack of
              modeling of <u>argv</u>. To make the assertion succeed, as expected, use:

                  goto-cc needs_argv.c
                  goto-instrument --model-argc-argv 2 a.out a.out
                  cbmc a.out

       <b>--remove-function-body</b> <u>f</u>
              remove the implementation of function <u>f</u> (may be repeated)

       <b>--replace-calls</b> <u>f</u>:<u>g</u>
              replace calls to <u>f</u> with calls to <u>g</u>

       <b>--max-nondet-tree-depth</b> <u>N</u>
              limit size of nondet (e.g. input) object tree; at level N pointers are set to null

       <b>--min-null-tree-depth</b> <u>N</u>
              minimum level at which a pointer can first be NULL in a recursively nondet initialized struct

   <b>Semantics-preserving</b> <b>transformations:</b>
       <b>--ensure-one-backedge-per-target</b>
              transform loop bodies such that there is a single edge back to the loop head

       <b>--drop-unused-functions</b>
              drop functions trivially unreachable from main function

       <b>--remove-pointers</b>
              converts pointer arithmetic to base+offset expressions

       <b>--constant-propagator</b>
              propagate constants and simplify expressions

       <b>--inline</b>
              perform full inlining

       <b>--partial-inline</b>
              perform partial inlining

       <b>--function-inline</b> <u>function</u>
              transitively inline all calls <u>function</u> makes

       <b>--no-caching</b>
              disable caching of intermediate results during transitive function inlining

       <b>--log</b> <u>file</u>
              log in JSON format which code segments were inlined, use with <b>--function-inline</b>

       <b>--remove-function-pointers</b>
              Resolve calls via function pointers to direct function calls. Candidate functions are chosen based
              on their signature and whether or not they have their address taken somewhere in the  program  The
              following  example  illustrates  the  approach  taken.  Given  that there are functions with these
              signatures available in the program:

                  int <b>f</b>(int x);
                  int <b>g</b>(int x);
                  int <b>h</b>(int x);

              And we have a call site like this:

                  <b>typedef</b> int (*fptr_t)(int x);
                  void <b>call</b>(fptr_t fptr) {
                    int r = <b><a href="../man10/fptr.10.html">fptr</a></b>(10);
                    <b>assert</b>(r &gt; 0);
                  }

              Function pointer removal will turn this into code similar to this:

                  void <b>call</b>(fptr_t fptr) {
                    int r;
                    <b>if</b> (fptr == &amp;f) {
                      r = <b><a href="../man10/f.10.html">f</a></b>(10);
                    } <b>else</b> <b>if</b> (fptr == &amp;g) {
                      r = <b><a href="../man10/g.10.html">g</a></b>(10);
                    } <b>else</b> <b>if</b> (fptr == &amp;h) {
                      r = <b><a href="../man10/h.10.html">h</a></b>(10);
                    } <b>else</b> {
                      <b>//</b> <b>sanity</b> <b>check</b>
                      <b>assert</b>(false);
                      <b>assume</b>(false);
                    }
                    <b>return</b> r;
                  }

              Beware that there may be many functions matching a particular signature, and some of them  may  be
              costly  to  a  subsequently  run  analysis. Consider using <b>--restrict-function-pointer</b> to manually
              specify this set of functions, or <b>--value-set-fi-fp-removal</b>.

       <b>--remove-const-function-pointers</b>
              remove function pointers that are constant or constant part of an array

       <b>--value-set-fi-fp-removal</b>
              Build a flow-insensitive value set and replace function pointers by  a  case  statement  over  the
              possible  assignments. If the set of possible assignments is empty the function pointer is removed
              using the standard <b>--remove-function-pointers</b> pass.

   <b>Loop</b> <b>information</b> <b>and</b> <b>transformations:</b>
       <b>--show-loops</b>
              show the loops in the program

       <b>--unwind</b> <u>nr</u>
              unwind all loops <u>nr</u> times

       <b>--unwindset</b> [<u>T</u>:]<u>L</u>:<u>B</u>,...
              unwind loop <u>L</u> with a bound of <u>B</u> (optionally restricted to thread <u>T</u>) (use <b>--show-loops</b> to  get  the
              loop IDs)

       <b>--unwindset-file</b> <u>file</u>
              read unwindset from file

       <b>--partial-loops</b>
              permit paths that execute loops only partially (up to the given unwinding bound) and then continue
              beyond  the  loop  even  when  the  loop  condition  would still hold (such paths may be spurious,
              resulting in false alarms)

       <b>--no-unwinding-assertions</b>
              do not generate unwinding assertions

       <b>--unwinding-assertions</b>
              generate unwinding assertions (which are enabled by default;  overrides  <b>--no-unwinding-assertions</b>
              when both of these are given)

       <b>--continue-as-loops</b>
              add loop for remaining iterations after unwound part

       <b>--k-induction</b> <u>k</u>
              check loops with k-induction

       <b>--step-case</b>
              k-induction: do step-case

       <b>--base-case</b>
              k-induction: do base-case

       <b>--havoc-loops</b>
              over-approximate all loops

       <b>--accelerate</b>
              add loop accelerators

       <b>--z3</b>   use Z3 when computing loop accelerators

       <b>--skip-loops</b> <u>loop-ids</u>
              add gotos to skip selected loops during execution

       <b>--show-lexical-loops</b>
              Show  lexical  loops.   A lexical loop is a block of goto program instructions with a single entry
              edge at the top and a single backedge leading from bottom to top, where "top" and  "bottom"  refer
              to program order. The loop may have holes: instructions which sit in between the top and bottom in
              program  order, but which can't reach the loop backedge. Lexical loops are a subset of the natural
              loops, which are cheaper to compute and include most natural loops generated from typical C code.

       <b>--show-natural-loops</b>
              Show natural loop heads.  A natural loop is when the nodes and edges of a  graph  make  one  self-
              encapsulating circle with no incoming edges from external nodes. For example A -&gt; B -&gt; C -&gt; D -&gt; A
              is  a  natural loop, but if B has an incoming edge from X, then it isn't a natural loop, because X
              is an external node. Outgoing edges don't affect the natural-ness of a loop.

   <b>Memory</b> <b>model</b> <b>instrumentations:</b>
       <b>--mm</b> [<b>tso</b>|<b>pso</b>|<b>rmo</b>|<b>power</b>]
              Instruments the program so that it can be verified for different weak memory models with a  model-
              checker verifying sequentially consistent programs.

       <b>--scc</b>  detects critical cycles per SCC (one thread per SCC)

       <b>--one-event-per-cycle</b>
              only instruments one event per cycle

       <b>--minimum-interference</b>
              instruments an optimal number of events

       <b>--my-events</b>
              only instruments events whose ids appear in inst.evt

       <b>--read-first</b>, <b>--write-first</b>
              only instrument cycles where a read or write occurs as first event, respectively

       <b>--max-var</b> <u>N</u>
              limit cycles to <u>N</u> variables read/written

       <b>--max-po-trans</b> <u>N</u>
              limit cycles to <u>N</u> program-order edges

       <b>--ignore-arrays</b>
              instrument arrays as a single object

       <b>--cav11</b>
              always instrument shared variables, even when they are not part of any cycle

       <b>--force-loop-duplication</b>, <b>--no-loop-duplication</b>
              optional program transformation to construct cycles in program loops

       <b>--cfg-kill</b>
              enables symbolic execution used to reduce spurious cycles

       <b>--no-dependencies</b>
              no dependency analysis

       <b>--no-po-rendering</b>
              no representation of the threads in the dot

       <b>--hide-internals</b>
              do not include thread-internal (Rfi) events in dot output

       <b>--render-cluster-file</b>
              clusterises the dot by files

       <b>--render-cluster-function</b>
              clusterises the dot by functions

   <b>Slicing:</b>
       <b>--fp-reachability-slice</b> <u>f</u>
              Remove  instructions  that  cannot  appear on a trace that visits all given functions. The list of
              functions has to be given as a comma separated list <u>f</u>.

       <b>--reachability-slice</b>
              remove instructions that cannot appear on a trace from entry point to a property

       <b>--reachability-slice-fb</b>
              remove instructions that cannot appear on a trace from entry point through a property

       <b>--full-slice</b>
              slice away instructions that don't affect assertions

       <b>--property</b> <u>id</u>
              slice with respect to specific property <u>id</u> only

       <b>--slice-global-inits</b>
              slice away initializations of unused global variables

       <b>--aggressive-slice</b>
              remove bodies of any functions not on the  shortest  path  between  the  start  function  and  the
              function containing the property(s)

       <b>--aggressive-slice-call-depth</b> <u>n</u>
              used  with <b>--aggressive-slice,</b> <b>preserves</b> <b>all</b> <b>functions</b> <b>within</b> <u>n</u> function calls of the functions on
              the shortest path

       <b>--aggressive-slice-preserve-function</b> <u>f</u>
              force the aggressive slicer to preserve function <u>f</u>

       <b>--aggressive-slice-preserve-functions-containing</b> <u>f</u>
              force the aggressive slicer to preserve all functions with names containing <u>f</u>

       <b>--aggressive-slice-preserve-all-direct-paths</b>
              force aggressive slicer to preserve all direct paths

   <b>Code</b> <b>contracts:</b>
       <b>--apply-loop-contracts</b>

       <b>-disable-loop-contracts-side-effect-check</b>
              UNSOUND OPTION. Disable checking the absence of side effects in loop contract clauses. In  absence
              of  such checking, loop contracts clauses will accept more expressions, such as pure functions and
              statement expressions.  But user have to make sure the loop contracts are side-effect free by them
              self to get a sound result.

       <b>-loop-contracts-no-unwind</b>
              do not unwind transformed loops

       <b>-loop-contracts-file</b> <u>file</u>
              annotate loop contracts from the file to the goto program

       <b>--replace-call-with-contract</b> <u>fun</u>
              replace calls to <u>fun</u> with <u>fun</u>'s contract

       <b>--enforce-contract</b> <u>fun</u>
              wrap <u>fun</u> with an assertion of its contract

       <b>--enforce-contract-rec</b> <u>fun</u>
              wrap <u>fun</u> with an assertion of its contract that can handle recursive calls

       <b>--dfcc</b> <u>fun</u>
              instrument dynamic frame condition checks method using <u>fun</u> as entry point

   <b>User-interface</b> <b>options:</b>
       <b>--flush</b>
              flush every line of output

       <b>--xml</b>  output files in XML where supported

       <b>--xml-ui</b>
              use XML-formatted output

       <b>--json-ui</b>
              use JSON-formatted output

       <b>--verbosity</b> <u>n</u>
              verbosity level

       <b>--timestamp</b> [<b>monotonic</b>|<b>wall</b>]
              Print microsecond-precision timestamps.  <b>monotonic</b>: stamps increase monotonically.  <b>wall</b>: ISO-8601
              wall clock timestamps.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       All tools honor the TMPDIR environment variable when generating temporary files and directories.

</pre><h4><b>BUGS</b></h4><pre>
       If you encounter a problem please create an issue at <b>https://github.com/diffblue/cbmc/issues</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/cbmc.1.html">cbmc</a></b>(1), <b><a href="../man1/goto-cc.1.html">goto-cc</a></b>(1)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2008-2013, Daniel Kroening

goto-instrument-5.59.0                              June 2022                                 <u><a href="../man1/GOTO-INSTRUMENT.1.html">GOTO-INSTRUMENT</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>