<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jshon — JSON parser for the shell</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/jshon">jshon_20131010-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jshon — JSON parser for the shell

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>jshon</b> -[P|S|Q|V|C|I|0] [-F path] -[t|l|k|u|p|a] -[s|n] value -[e|i|d] index

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>jshon</b>  parses,  reads and creates JSON.  It is designed to be as usable as possible from within the shell
       and replaces fragile adhoc parsers made from grep/sed/awk as well as heavyweight  one-line  parsers  made
       from perl/python.

       <b>jshon</b> loads json text from stdin, performs actions, then displays the last action on stdout.  Some of the
       options   output  json,  others  output  plain  text  summaries.   Because  Bash  has  very  poor  nested
       datastructures, <b>jshon</b> does not return the JSON as a native object as a typical  library  would.   Instead
       <b>jshon</b> retains a history of edits in a stack, and you manipulate the topmost JSON element.

</pre><h4><b>ACTIONS</b></h4><pre>
       Each action takes the form of a short option.  Some require arguments.  While many instances of <b>jshon</b> can
       be  piped  through  each other, actions should be chained sequentially to reduce calls.  All examples use
       this json sample:

         {"a":1,"b":[true,false,null,"str"],"c":{"d":4,"e":5}}
         jshon [actions] &lt; sample.json

       Most common read-only uses will only need several <b>-e</b> actions and one <b>-a</b> in the middle of them.

       <b>-t</b>  (type) returns string, object, array, number, bool, null

             jshon -t -&gt; object

       <b>-l</b>  (length) returns an integer.  Only works on string, object, array.

             jshon -l -&gt; 3

       <b>-k</b>  (keys) returns a newline separated list of keys.  Only works on object.

             jshon -k -&gt; a b c

       <b>-e</b> <b>index</b>
           (extract) returns json value at "index".  Only works on object, array.  The index of an array  is  an
           integer.

             jshon -e c -&gt; {"d":4,"e":5}

       <b>-a</b>  (across)  maps  the remaining actions across the selected element.  Only works on objects and arrays.
           Multiple <b>-a</b> calls can be nested, though the need is rare in practice.

             jshon -e b -a -t -&gt; bool bool null string

       <b>-s</b> <b>value</b>
           (string) returns a json encoded string.  Can later be (-i)nserted to an existing structure.

             jshon -s "back\slash" -&gt; "back\\slash"

       <b>-n</b> <b>value</b>
           (nonstring/number) returns a json element.  Can later be (-i)nserted to an existing structure.  Valid
           values are 'true', 'false', 'null', 'array', 'object', integers and floats.  Abbreviations t,  f,  n,
           [] and {} respectively also work.

             jshon -n object -&gt; {}

       <b>-u</b>  (unstring) returns a decoded string.  Only works on simple types: string, int, real, boolean, null.

             jshon -e b -e 3 -u -&gt; str

       <b>-p</b>  (pop)  pops  the  last  manipulation  from  the  stack, rewinding the history.  Useful for extracting
           multiple values from one object.

            jshon -e c -e d -u -p -e e -u -&gt; 4 5

       <b>-d</b> <b>index</b>
           (delete) removes an item in an array or object.  Negative array indexes will wrap around.

             jshon -d b -&gt; {"a":1,"c":{"d":4,"e":5}}

       <b>-i</b> <b>index</b>
           (insert) is complicated.  It is the reverse of extract.  Extract  puts  a  json  sub-element  on  the
           stack.   Insert  removes  a  sub-element from the stack, and inserts that bit of json into the larger
           array/object underneath.  Use extract to dive into the json tree, delete/string/nonstring  to  change
           things, and insert to push the changes back into the tree.

             jshon -e a -i a -&gt; the orginal json
             jshon -s one -i a -&gt; {"a":"one", ...}

           Arrays  are  handled  in a special manner.  Passing integers will insert a value without overwriting.
           Negative integers are acceptable, as is the string 'append'.  To  overwrite  a  value  in  an  array:
           delete the index, <b>-n/s</b> the new value, and then insert at the index.

             jshon -e b -d 0 -s q -i 0 -&gt; {"b":"q",false,null,"str"}

</pre><h4><b>NON-MANIPULATION</b></h4><pre>
       There are several meta-options that do not directly edit json.  Call these at most once per invocation.

       <b>-F</b> <b>&lt;path&gt;</b>
           (file) reads from a file instead of stdin.  The only non-manipulation option to take an argument.

       <b>-P</b>  (jsonp) strips a jsonp callback before continuing normally.

       <b>-S</b>  (sort) returns json sorted by key, instead of the original ordering.

       <b>-Q</b>  (quiet)  disables  error reporting on stderr, so you don't have to sprinkle "2&gt; /dev/null" throughout
           your script.

       <b>-V</b>  (by-value) enables pass-by-value on the edit history stack.   In  extreme  cases  with  thousands  of
           deeply  nested values this may result in <b>jshon</b> running several times slower while using several times
           more memory.  However by-value is safer than by-reference and generally causes  less  surprise.   By-
           reference  is  enabled  by default because there is no risk during read-only operations and generally
           makes editing json more convenient.

            jshon    -e c -n 7 -i d -p   -&gt; c["d"] == 7
            jshon -V -e c -n 7 -i d -p   -&gt; c["d"] == 5
            jshon -V -e c -n 7 -i d -i c -&gt; c["d"] == 7

           With <b>-V</b> , changes must be manually inserted back through the stack instead of simply popping off  the
           intermediate values.

       <b>-C</b>  (continue)  on  potentially recoverable errors.  For example, extracting values that don't exist will
           add 'null' to the edit stack instead of aborting.  Behavior may change in the future.

       <b>-I</b>  (in-place) file editing.  Requires a file to modify and so only works with -F.   This  is  meant  for
           making  slight  changes to a json file.  When used, normal output is suppressed and the bottom of the
           edit stack is written out.

       <b>-0</b>  (null delimiters)  Changes the delimiter of -u from a newline to a null.  This option only affects -u
           because that is the only time a newline may legitimately appear in the output.

       <b>--version</b>
           Returns a YYYYMMDD timestamp and exits.

</pre><h4><b>OTHER</b> <b>TOOLS</b></h4><pre>
       <b>jshon</b> always outputs one field per line.  Many unix tools expect multiple tab separated fields per  line.
       Pipe the output through 'paste' to fix this.  However, paste can not handle empty lines so pad those with
       a placeholder.  Here is an example:

         jshon ... | sed 's/^$/-/' | paste -s -d '\t\t\n'

       This replaces blanks with '-' and merges every three lines into one.

       There  are  more and more tools that produce json output.  Often these use a line-oriented json/plaintext
       hybrid where each line is an independent json structure.  Sadly this means the output as a whole  is  not
       legitimate  json.  Either loop though the data line by line (calling <b>jshon</b> once for each line) or convert
       it to a legitimate json array.  For example:

         while read line; do jshon &lt;&lt;&lt; "$line"; done &lt; &lt;(journalctl -o json)

         journalctl -o json | sed -e '1i[' -e '$!s/$/,/' -e '$a]' | jshon

</pre><h4><b>GOLF</b></h4><pre>
       If you care about extremely short one  liners,  arguments  can  be  condensed  when  it  does  not  cause
       ambiguity.  The example from <b>-p(op)</b> can be golfed as follows:

        jshon -e c -e d -u -p -e e -u == jshon -ec -ed -upee -u

       I  do  not  recommend doing this (it makes things much harder to understand) but some people golf despite
       the consequences.

</pre><h4><b>CREATING</b> <b>JSON</b></h4><pre>
       <b>jshon</b> can create json by passing an empty object as input:

        jshon -s one -i a &lt;&lt;&lt; "{}"

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>jshon</b> was written by Kyle Keen &lt;<a href="mailto:keenerd@gmail.com">keenerd@gmail.com</a>&gt; with patches  from  Dave  Reisner  &lt;<a href="mailto:d@falconindy.com">d@falconindy.com</a>&gt;,
       AndrewF (BSD, OSX, jsonp, sorting), and Jean-Marc A (solaris).

</pre><h4><b>BUGS</b></h4><pre>
       Numerous!  Floats may lose precision.  Could be more convenient to use.  Documentation is brief.

                                                September 1, 2013                                       <u><a href="../man1/JSHON.1.html">JSHON</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>