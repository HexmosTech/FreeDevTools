<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>keyctl - key management facility control</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/keyutils">keyutils_1.6.3-4ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       keyctl - key management facility control

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>keyctl</b> --version
       <b>keyctl</b> supports [&lt;cap&gt; | --raw]
       <b>keyctl</b> id [&lt;keyring&gt;]
       <b>keyctl</b> show [-x] [&lt;keyring&gt;]
       <b>keyctl</b> add [-x] &lt;type&gt; &lt;desc&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl</b> padd [-x] &lt;type&gt; &lt;desc&gt; &lt;keyring&gt;
       <b>keyctl</b> request &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl</b> request2 &lt;type&gt; &lt;desc&gt; &lt;info&gt; [&lt;dest_keyring&gt;]
       <b>keyctl</b> prequest2 &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl</b> update [-x] &lt;key&gt; &lt;data&gt;
       <b>keyctl</b> pupdate [-x] &lt;key&gt;
       <b>keyctl</b> newring &lt;name&gt; &lt;keyring&gt;
       <b>keyctl</b> revoke &lt;key&gt;
       <b>keyctl</b> clear &lt;keyring&gt;
       <b>keyctl</b> link &lt;key&gt; &lt;keyring&gt;
       <b>keyctl</b> unlink &lt;key&gt; [&lt;keyring&gt;]
       <b>keyctl</b> move [-f] &lt;key&gt; &lt;from_keyring&gt; &lt;to_keyring&gt;
       <b>keyctl</b> search &lt;keyring&gt; &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl</b> restrict_keyring &lt;keyring&gt; [&lt;type&gt; [&lt;restriction&gt;]]
       <b>keyctl</b> read &lt;key&gt;
       <b>keyctl</b> pipe &lt;key&gt;
       <b>keyctl</b> print &lt;key&gt;
       <b>keyctl</b> list &lt;keyring&gt;
       <b>keyctl</b> rlist &lt;keyring&gt;
       <b>keyctl</b> describe &lt;keyring&gt;
       <b>keyctl</b> rdescribe &lt;keyring&gt; [sep]
       <b>keyctl</b> chown &lt;key&gt; &lt;uid&gt;
       <b>keyctl</b> chgrp &lt;key&gt; &lt;gid&gt;
       <b>keyctl</b> setperm &lt;key&gt; &lt;mask&gt;
       <b>keyctl</b> new_session [&lt;name&gt;]
       <b>keyctl</b> session
       <b>keyctl</b> session - [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]
       <b>keyctl</b> session &lt;name&gt; [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]
       <b>keyctl</b> instantiate [-x] &lt;key&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl</b> pinstantiate [-x] &lt;key&gt; &lt;keyring&gt;
       <b>keyctl</b> negate &lt;key&gt; &lt;timeout&gt; &lt;keyring&gt;
       <b>keyctl</b> reject &lt;key&gt; &lt;timeout&gt; &lt;error&gt; &lt;keyring&gt;
       <b>keyctl</b> timeout &lt;key&gt; &lt;timeout&gt;
       <b>keyctl</b> security &lt;key&gt;
       <b>keyctl</b> reap [-v]
       <b>keyctl</b> purge &lt;type&gt;
       <b>keyctl</b> purge [-i] [-p] &lt;type&gt; &lt;desc&gt;
       <b>keyctl</b> purge -s &lt;type&gt; &lt;desc&gt;
       <b>keyctl</b> get_persistent &lt;keyring&gt; [&lt;uid&gt;]
       <b>keyctl</b> dh_compute &lt;private&gt; &lt;prime&gt; &lt;base&gt;
       <b>keyctl</b> dh_compute_kdf &lt;private&gt; &lt;prime&gt; &lt;base&gt; &lt;output_length&gt; &lt;hash_type&gt;
       <b>keyctl</b> dh_compute_kdf_oi [-x] &lt;private&gt; &lt;prime&gt; &lt;base&gt; &lt;output_length&gt; &lt;hash_type&gt;
       <b>keyctl</b> pkey_query &lt;key&gt; &lt;pass&gt; [k=v]*
       <b>keyctl</b> pkey_encrypt &lt;key&gt; &lt;pass&gt; &lt;datafile&gt; [k=v]* &gt;&lt;encfile&gt;
       <b>keyctl</b> pkey_decrypt &lt;key&gt; &lt;pass&gt; &lt;encfile&gt; [k=v]* &gt;&lt;datafile&gt;
       <b>keyctl</b> pkey_sign &lt;key&gt; &lt;pass&gt; &lt;datafile&gt; [k=v]* &gt;&lt;sigfile&gt;
       <b>keyctl</b> pkey_decrypt &lt;key&gt; &lt;pass&gt; &lt;datafile&gt; &lt;sigfile&gt; [k=v]*
       <b>keyctl</b> watch [-f&lt;filters&gt;] &lt;key&gt;
       <b>keyctl</b> watch_add &lt;fd&gt; &lt;key&gt;
       <b>keyctl</b> watch_rm &lt;fd&gt; &lt;key&gt;
       <b>keyctl</b> watch_session [-f &lt;filters&gt;] [-n &lt;name&gt;] \
                       &lt;notifylog&gt; &lt;gclog&gt; &lt;fd&gt; &lt;prog&gt; [&lt;arg1&gt; &lt;arg2&gt; ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  program  is  used  to  control  the  key  management  facility  in  various ways using a variety of
       subcommands.

</pre><h4><b>KEY</b> <b>IDENTIFIERS</b></h4><pre>
       The key identifiers passed to or returned from keyctl are, in  general,  positive  integers.  There  are,
       however, some special values with special meanings that can be passed as arguments:

       No key: <b>0</b>

       Thread keyring: <b>@t</b> or <b>-1</b>
              Each  thread  may  have  its  own  keyring.  This is searched first, before all others. The thread
              keyring is replaced by (v)fork, exec and clone.

       Process keyring: <b>@p</b> or <b>-2</b>
              Each process (thread group) may have its own keyring. This is shared  between  all  members  of  a
              group  and  will  be searched after the thread keyring. The process keyring is replaced by (v)fork
              and exec.

       Session keyring: <b>@s</b> or <b>-3</b>
              Each process subscribes to a session keyring that is inherited across  (v)fork,  exec  and  clone.
              This  is  searched  after the process keyring. Session keyrings can be named and an extant keyring
              can be joined in place of a process's current session keyring.

       User specific keyring: <b>@u</b> or <b>-4</b>
              This keyring is shared between all the processes owned by a particular  user.  It  isn't  searched
              directly, but is normally linked to from the session keyring.

       User default session keyring: <b>@us</b> or <b>-5</b>
              This  is  the  default  session  keyring  for  a particular user. Login processes that change to a
              particular user will bind to this session until another session is set.

       Group specific keyring: <b>@g</b> or <b>-6</b>
              This is a place holder for a group specific keyring, but is not actually implemented  yet  in  the
              kernel.

       Assumed request_key authorisation key: <b>@a</b> or <b>-7</b>
              This selects the authorisation key provided to the <b>request_key</b>() helper to permit it to access the
              callers keyrings and instantiate the target key.

       Keyring by name: <b>%:&lt;name&gt;</b>
              A named keyring.  This will be searched for in the process's keyrings and in <u><a href="file:/proc/keys">/proc/keys</a></u>.

       Key by name: <b>%&lt;type&gt;:&lt;name&gt;</b>
              A  named  key  of  the  given  type.   This  will be searched for in the process's keyrings and in
              <u><a href="file:/proc/keys">/proc/keys</a></u>.

</pre><h4><b>COMMAND</b> <b>SYNTAX</b></h4><pre>
       Any non-ambiguous shortening of a command name may be used  in  lieu  of  the  full  command  name.  This
       facility  should  not  be  used  in  scripting  as  new  commands  may be added in future that then cause
       ambiguity.

   <b>Display</b> <b>the</b> <b>package</b> <b>version</b> <b>number</b>
       <b>keyctl</b> <b>--version</b>

       This command prints the package version number and build date and exits:

              $ keyctl --version
              keyctl from keyutils-1.5.3 (Built 2011-08-24)

   <b>Query</b> <b>subsystem</b> <b>capabilities</b>
       <b>keyctl</b> supports
       <b>keyctl</b> supports --raw
       <b>keyctl</b> supports &lt;cap&gt;

       This command can list the available capabilities:

              $ keyctl supports
              have_capabilities=0
              have_persistent_keyrings=1
              have_dh_compute=1
              have_public_key=1

       produce a raw hex dump of the capabilities list:

              $ keyctl supports --raw
              ff0f

       or query a specific capability:

              $ keyctl supports pkey
              echo $?
              0

       which exits 0 if the capability is supported, 1 if it isn't and 3 if the name  is  not  recognised.   The
       capabilities supported are:

       <b>capabilities</b>
              The  kernel  supports capability querying.  If not, the other capabilities will be queried as best
              libkeyutils can manage.

       <b>persistent_keyrings</b>
              The kernel supports persistent keyrings.

       <b>dh_compute</b>
              The kernel supports Diffie-Hellman computation operations.

       <b>public_key</b>
              The kernel supports public key operations.

       <b>big_key_type</b>
              The kernel supports the big_key key type.

       <b>key_invalidate</b>
              The kernel supports the invalidate key operaiton.

       <b>restrict_keyring</b>
              The kernel supports the restrict_keyring operation.

       <b>move_key</b>
              The kernel supports the move key operation.

       <b>ns_keyring_name</b>
              Keyring names are segregated according to the user-namespace in which the keyrings are created.

       <b>ns_key_tag</b>
              Keys can get tagged with namespace tags, allowing keys with the same  type  and  description,  but
              different  namespaces  to coexist in the same keyring.  Tagging is done automatically according to
              the key type.

   <b>Show</b> <b>actual</b> <b>key</b> <b>or</b> <b>keyring</b> <b>ID</b>
       <b>keyctl</b> <b>id</b> <b>[&lt;key&gt;]</b>

       This command looks up the real ID of a key or keyring from the identifier given,  which  is  typically  a
       symbolic  ID  such  as  "@s" indicating the session keyring, but can also be a numeric ID or "%type:desc"
       notation.  If a special keyring is specified that isn't created yet, an error will be given  rather  than
       causing that keyring to be created.

   <b>Show</b> <b>process</b> <b>keyrings</b>
       <b>keyctl</b> <b>show</b> <b>[-x]</b> <b>[&lt;keyring&gt;]</b>

       By  default  this  command  recursively  shows what keyrings a process is subscribed to and what keys and
       keyrings they contain.  If a keyring is specified then that keyring will be dumped  instead.   If  <b>-x</b>  is
       specified then the keyring IDs will be dumped in hex instead of decimal.

   <b>Add</b> <b>a</b> <b>key</b> <b>to</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>add</b> [-x] &lt;type&gt; &lt;desc&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl</b> <b>padd</b> [-x] &lt;type&gt; &lt;desc&gt; &lt;keyring&gt;

       This command creates a key of the specified type and description; instantiates it with the given data and
       attaches it to the specified keyring. It then prints the new key's ID on stdout:

              $ keyctl add user mykey stuff @u
              26

       The <b>padd</b> variant of the command reads the data from stdin rather than taking it from the command line:

              $ echo -n stuff | keyctl padd user mykey @u 26

       If <b>-x</b> is given, then the data is hex-decoded with whitespace being discarded.

   <b>Request</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>request</b> &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl</b> <b>request2</b> &lt;type&gt; &lt;desc&gt; &lt;info&gt; [&lt;dest_keyring&gt;]
       <b>keyctl</b> <b>prequest2</b> &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]

       These  three  commands  request  the  lookup  of  a  key of the given type and description. The process's
       keyrings will be searched, and if a match is found the matching key's ID will be printed to  stdout;  and
       if a destination keyring is given, the key will be added to that keyring also.

       If  there is no key, the first command will simply return the error ENOKEY and fail. The second and third
       commands will create a partial key with the type and description, and call out to <u>/sbin/request-key</u>  with
       that  key  and  the  extra  information  supplied.  This will then attempt to instantiate the key in some
       manner, such that a valid key is obtained.

       The third command is like the second, except that the callout information is read from stdin rather  than
       being passed on the command line.

       If  a  valid  key  is obtained, the ID will be printed and the key attached as if the original search had
       succeeded.

       If there wasn't a valid key obtained, a temporary negative  key  will  be  attached  to  the  destination
       keyring if given and the error "Requested key not available" will be given.

              $ keyctl request2 user debug:hello wibble
              23
              $ echo -n wibble | keyctl prequest2 user debug:hello
              23
              $ keyctl request user debug:hello
              23

   <b>Update</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>update</b> [-x] &lt;key&gt; &lt;data&gt;
       <b>keyctl</b> <b>pupdate</b> [-x] &lt;key&gt;

       This  command  replaces the data attached to a key with a new set of data. If the type of the key doesn't
       support update then error "Operation not supported" will be returned.

              $ keyctl update 23 zebra

       The <b>pupdate</b> variant of the command reads the data from stdin rather than taking it from the command line:

              $ echo -n zebra | keyctl pupdate 23
              $ echo 616263313233 | keyctl pupdate -x 23

       If <b>-x</b> is given, then the data is hex-decoded with whitespace being discarded.

   <b>Create</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>newring</b> &lt;name&gt; &lt;keyring&gt;

       This command creates a new keyring of the specified name and attaches it to the specified keyring. The ID
       of the new keyring will be printed to stdout if successful.

              $ keyctl newring squelch @us
              27

   <b>Revoke</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>revoke</b> &lt;key&gt;

       This command marks a key as being revoked. Any further operations on that key (apart from  unlinking  it)
       will return error "Key has been revoked".

              $ keyctl revoke 26
              $ keyctl describe 26
              keyctl_describe: Key has been revoked

   <b>Clear</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>clear</b> &lt;keyring&gt;

       This  command  unlinks  all  the  keys attached to the specified keyring. Error "Not a directory" will be
       returned if the key specified is not a keyring.

              $ keyctl clear 27

   <b>Link</b> <b>a</b> <b>key</b> <b>to</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>link</b> &lt;key&gt; &lt;keyring&gt;

       This command makes a link from the key to the keyring if there's enough capacity to do so. Error  "Not  a
       directory"  will  be  returned  if  the  destination  is not a keyring. Error "Permission denied" will be
       returned if the key doesn't have link permission or the keyring  doesn't  have  write  permission.  Error
       "File  table overflow" will be returned if the keyring is full. Error "Resource deadlock avoided" will be
       returned if an attempt was made to introduce a recursive link.

              $ keyctl link 23 27
              $ keyctl link 27 27
              keyctl_link: Resource deadlock avoided

   <b>Unlink</b> <b>a</b> <b>key</b> <b>from</b> <b>a</b> <b>keyring</b> <b>or</b> <b>the</b> <b>session</b> <b>keyring</b> <b>tree</b>
       <b>keyctl</b> <b>unlink</b> &lt;key&gt; [&lt;keyring&gt;]

       If the keyring is specified, this command removes a link to the  key  from  the  keyring.  Error  "Not  a
       directory"  will  be  returned  if  the  destination  is not a keyring. Error "Permission denied" will be
       returned if the keyring doesn't have write permission. Error "No such file or directory" will be returned
       if the key is not linked to by the keyring.

       If the keyring is not specified, this command performs a depth-first search of the session  keyring  tree
       and  removes  all  the links to the nominated key that it finds (and that it is permitted to remove).  It
       prints the number of successful unlinks before exiting.

              $ keyctl unlink 23 27

   <b>Move</b> <b>a</b> <b>key</b> <b>between</b> <b>keyrings.</b>
       <b>keyctl</b> <b>move</b>  [-f] &lt;key&gt; &lt;from_keyring&gt; &lt;to_keyring&gt;

       This command moves a key  from  one  keyring  to  another,  atomically  combining  "keyctl  unlink  &lt;key&gt;
       &lt;from_keyring&gt;" and "keyctl link &lt;key&gt; &lt;to_keyring&gt;".

       If  the  "-f"  flag is present, any matching key will be displaced from "to_keyring"; if not present, the
       command will fail with the error message "File exists" if the key would otherwise  displace  another  key
       from "to_keyring".

              $ keyctl move 23 27 29
              $ keyctl move -f 71 @u @s

   <b>Search</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>search</b> &lt;keyring&gt; &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]

       This command non-recursively searches a keyring for a key of a particular type and description. If found,
       the  ID  of  the key will be printed on stdout and the key will be attached to the destination keyring if
       present. Error "Requested key not available" will be returned if the key is not found.

              $ keyctl search @us user debug:hello
              23
              $ keyctl search @us user debug:bye
              keyctl_search: Requested key not available

   <b>Restrict</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>restrict_keyring</b> &lt;keyring&gt; [&lt;type&gt; [&lt;restriction&gt;]]

       This command limits the linkage of keys to the given keyring using a  provided  restriction  scheme.  The
       scheme  is  associated  with  a  given  key type, with further details provided in the restriction option
       string.  Options typically contain a restriction name possibly followed by key ids or other data relevant
       to the restriction. If no restriction scheme is provided, the keyring will reject all links.

              $ keyctl restrict_keyring $1 asymmetric builtin_trusted

   <b>Read</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>read</b> &lt;key&gt;
       <b>keyctl</b> <b>pipe</b> &lt;key&gt;
       <b>keyctl</b> <b>print</b> &lt;key&gt;

       These commands read the payload of a key. "read" prints it on stdout as a hex dump, "pipe" dumps the  raw
       data  to  stdout  and  "print"  dumps  it  to  stdout directly if it's entirely printable or as a hexdump
       preceded by ":hex:" if not.

       If the key type does not support reading of the payload, then error "Operation  not  supported"  will  be
       returned.

              $ keyctl read 26
              1 bytes of data in key:
              62
              $ keyctl print 26
              b
              $ keyctl pipe 26
              $

   <b>List</b> <b>a</b> <b>keyring</b>
       <b>keyctl</b> <b>list</b> &lt;keyring&gt;
       <b>keyctl</b> <b>rlist</b> &lt;keyring&gt;

       These  commands  list  the  contents of a key as a keyring. "list" pretty prints the contents and "rlist"
       just produces a space-separated list of key IDs.

       No attempt is made to check that the specified keyring is a keyring.

              $ keyctl list @us
              2 keys in keyring:
                     22: vrwsl----------  4043    -1 keyring: _uid.4043
                     23: vrwsl----------  4043  4043 user: debug:hello
              $ keyctl rlist @us
              22 23

   <b>Describe</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>describe</b> &lt;keyring&gt;
       <b>keyctl</b> <b>rdescribe</b> &lt;keyring&gt; [sep]

       These commands fetch a description of a keyring. "describe" pretty prints the  description  in  the  same
       fashion as the "list" command; "rdescribe" prints the raw data returned from the kernel.

              $ keyctl describe @us
                     -5: vrwsl----------  4043    -1 keyring: _uid_ses.4043
              $ keyctl rdescribe @us
              keyring;4043;-1;3f1f0000;_uid_ses.4043

       The  raw string is "&lt;type&gt;;&lt;uid&gt;;&lt;gid&gt;;&lt;perms&gt;;&lt;description&gt;", where <u>uid</u> and <u>gid</u> are the decimal user and
       group IDs, <u>perms</u> is the permissions mask in hex, <u>type</u> and <u>description</u> are the type name  and  description
       strings (neither of which will contain semicolons).

   <b>Change</b> <b>the</b> <b>access</b> <b>controls</b> <b>on</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>chown</b> &lt;key&gt; &lt;uid&gt;
       <b>keyctl</b> <b>chgrp</b> &lt;key&gt; &lt;gid&gt;

       These  two  commands  change the UID and GID associated with evaluating a key's permissions mask. The UID
       also governs which quota a key is taken out of.

       The chown command is not currently supported; attempting it will earn the error "Operation not supported"
       at best.

       For non-superuser users, the GID may only be set to the process's GID or a GID in  the  process's  groups
       list. The superuser may set any GID it likes.

              $ sudo keyctl chown 27 0
              keyctl_chown: Operation not supported
              $ sudo keyctl chgrp 27 0

   <b>Set</b> <b>the</b> <b>permissions</b> <b>mask</b> <b>on</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>setperm</b> &lt;key&gt; &lt;mask&gt;

       This  command  changes the permission control mask on a key. The mask may be specified as a hex number if
       it begins "0x", an octal number if it begins "0" or a decimal number otherwise.

       The hex numbers are a combination of:

              Possessor UID       GID       Other     Permission Granted
              ========  ========  ========  ========  ==================
              01000000  00010000  00000100  00000001  View
              02000000  00020000  00000200  00000002  Read
              04000000  00040000  00000400  00000004  Write
              08000000  00080000  00000800  00000008  Search
              10000000  00100000  00001000  00000010  Link
              20000000  00200000  00002000  00000020  Set Attribute
              3f000000  003f0000  00003f00  0000003f  All

       <u>View</u> permits the type, description and other parameters of a key to be viewed.

       <u>Read</u> permits the payload (or keyring list) to be read if supported by the type.

       <u>Write</u> permits the payload (or keyring list) to be modified or updated.

       <u>Search</u> on a key permits it to be found when a keyring to which it is linked is searched.

       <u>Link</u> permits a key to be linked to a keyring.

       <u>Set</u> <u>Attribute</u> permits a key to have its owner, group membership, permissions mask and timeout changed.

              $ keyctl setperm 27 0x1f1f1f00

   <b>Start</b> <b>a</b> <b>new</b> <b>session</b> <b>with</b> <b>fresh</b> <b>keyrings</b>
       <b>keyctl</b> <b>session</b>
       <b>keyctl</b> <b>session</b> - [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]
       <b>keyctl</b> <b>session</b> &lt;name&gt; [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]

       These commands join or create a new keyring and then run a shell or other program with  that  keyring  as
       the session key.

       The  variation  with  no  arguments  just  creates  an anonymous session keyring and attaches that as the
       session keyring; it then exec's $SHELL.

       The variation with a dash in place of a name creates an anonymous session keyring and  attaches  that  as
       the session keyring; it then exec's the supplied command, or $SHELL if one isn't supplied.

       The  variation  with  a name supplied creates or joins the named keyring and attaches that as the session
       keyring; it then exec's the supplied command, or $SHELL if one isn't supplied.

              $ keyctl rdescribe @s
              keyring;4043;-1;3f1f0000;_uid_ses.4043

              $ keyctl session
              Joined session keyring: 28

              $ keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;_ses.24082

              $ keyctl session -
              Joined session keyring: 29
              $ keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;_ses.24139

              $ keyctl session - keyctl rdescribe @s
              Joined session keyring: 30
              keyring;4043;4043;3f1f0000;_ses.24185

              $ keyctl session fish
              Joined session keyring: 34
              $ keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;fish

              $ keyctl session fish keyctl rdesc @s
              Joined session keyring: 35
              keyring;4043;4043;3f1f0000;fish

   <b>Instantiate</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>instantiate</b> [-x] &lt;key&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl</b> <b>pinstantiate</b> [-x] &lt;key&gt; &lt;keyring&gt;
       <b>keyctl</b> <b>negate</b> &lt;key&gt; &lt;timeout&gt; &lt;keyring&gt;
       <b>keyctl</b> <b>reject</b> &lt;key&gt; &lt;timeout&gt; &lt;error&gt; &lt;keyring&gt;

       These commands are used to attach data to a partially set up key (as created by the kernel and passed  to
       <u>/sbin/request-key</u>).   "instantiate"  marks  a  key  as  being valid and attaches the data as the payload.
       "negate" and "reject" mark a key as invalid and sets a timeout on it so that it'll go away after a while.
       This prevents a lot of quickly sequential requests from slowing the system down overmuch  when  they  all
       fail,  as all subsequent requests will then fail with error "Requested key not found" (if negated) or the
       specified error (if rejected) until the negative key has expired.

       Reject's error argument can either be a UNIX error number or one of '<b>rejected</b>', '<b>expired</b>' or '<b>revoked</b>'.

       The newly instantiated key will be attached to the specified keyring.

       These commands may only be run from the program run by request-key - a special authorisation key  is  set
       up  by the kernel and attached to the request-key's session keyring. This special key is revoked once the
       key to which it refers has been instantiated one way or another.

              $ keyctl instantiate $1 "Debug $3" $4
              $ keyctl negate $1 30 $4
              $ keyctl reject $1 30 64 $4

       The <b>pinstantiate</b> variant of the command reads the data from stdin rather than taking it from the  command
       line:

              $ echo -n "Debug $3" | keyctl pinstantiate $1 $4

       If <b>-x</b> is given, then the data is hex-decoded with whitespace being discarded:

              $ echo 01 02 03 04 | keyctl pinstantiate -x $1 $4

   <b>Set</b> <b>the</b> <b>expiry</b> <b>time</b> <b>on</b> <b>a</b> <b>key</b>
       <b>keyctl</b> <b>timeout</b> &lt;key&gt; &lt;timeout&gt;

       This  command is used to set the timeout on a key, or clear an existing timeout if the value specified is
       zero. The timeout is given as a number of seconds into the future.

              $ keyctl timeout $1 45

   <b>Retrieve</b> <b>a</b> <b>key's</b> <b>security</b> <b>context</b>
       <b>keyctl</b> <b>security</b> &lt;key&gt;

       This command is used to retrieve a key's LSM security context.  The label is printed on stdout.

              $ keyctl security @s
              unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

   <b>Give</b> <b>the</b> <b>parent</b> <b>process</b> <b>a</b> <b>new</b> <b>session</b> <b>keyring</b>
       <b>keyctl</b> <b>new_session</b> <b>[&lt;name&gt;]</b>

       This command is used to give the invoking process (typically a shell) a new session  keyring,  discarding
       its  old session keyring.  If a name is given, the keyring is given that name, otherwise it will be given
       a name of "_ses" and will not be manually joinable.

              $  keyctl session foo
              Joined session keyring: 723488146
              $  keyctl show
              Session Keyring
                     -3 --alswrv      0     0  keyring: foo
              $  keyctl new_session
              490511412
              $  keyctl show
              Session Keyring
                     -3 --alswrv      0     0  keyring: _ses

       Note that this affects the <u>parent</u> of the process that invokes the system call, and  so  may  only  affect
       processes  with  matching  credentials.   Furthermore,  the  change  does not take effect till the parent
       process next transitions from kernel space to user space - typically when the <b>wait</b>() system call returns.

   <b>Remove</b> <b>dead</b> <b>keys</b> <b>from</b> <b>the</b> <b>session</b> <b>keyring</b> <b>tree</b>
       <b>keyctl</b> <b>reap</b>

       This command performs a depth-first search of the caller's session keyring tree and  attempts  to  unlink
       any key that it finds that is inaccessible due to expiry, revocation, rejection or negation.  It does not
       attempt to remove live keys that are unavailable simply due to a lack of granted permission.

       A  key that is designated reapable will only be removed from a keyring if the caller has Write permission
       on that keyring, and only keyrings that grant Search permission to the caller will be searched.

       The command prints the number of keys reaped before it exits.  If the <b>-v</b> flag is passed then  the  reaped
       keys are listed as they're being reaped, together with the success or failure of the unlink.

   <b>Remove</b> <b>matching</b> <b>keys</b> <b>from</b> <b>the</b> <b>session</b> <b>keyring</b> <b>tree</b>
       <b>keyctl</b> purge &lt;type&gt;
       <b>keyctl</b> purge [-i] [-p] &lt;type&gt; &lt;desc&gt;
       <b>keyctl</b> purge -s &lt;type&gt; &lt;desc&gt;

       These  commands  perform  a depth-first search to find matching keys in the caller's session keyring tree
       and attempts to unlink them.  The number of keys successfully unlinked is printed at the end.

       The keyrings must grant Read and View permission to the caller to be searched, and the keys to be removed
       must also grant View permission.  Keys can only be removed from keyrings that grant Write permission.

       The first variant purges all keys of the specified type.

       The second variant purges all keys of the specified type that also match the given description literally.
       The -i flag allows a case-independent match and the -p flag allows a prefix match.

       The third variant purges all keys of the specified type and matching description  using  the  key  type's
       comparator  in  the  kernel  to  match  the description.  This permits the key type to match a key with a
       variety of descriptions.

   <b>Get</b> <b>persistent</b> <b>keyring</b>
       <b>keyctl</b> get_persistent &lt;keyring&gt; [&lt;uid&gt;]

       This command gets the persistent keyring for either the current UID or the specified UID and attaches  it
       to the nominated keyring.  The persistent keyring's ID will be printed on stdout.

       The  kernel will create the keyring if it doesn't exist and every time this command is called, will reset
       the expiration timeout on the keyring to the value in:

              <a href="file:/proc/sys/kernel/keys/persistent_keyring_expiry">/proc/sys/kernel/keys/persistent_keyring_expiry</a>

       (by default three days).  Should the timeout be reached, the  persistent  keyring  will  be  removed  and
       everything it pins can then be garbage collected.

       If a UID other than the process's real or effective UIDs is specified, then an error will be given if the
       process does not have the CAP_SETUID capability.

   <b>Compute</b> <b>a</b> <b>Diffie-Hellman</b> <b>shared</b> <b>secret</b> <b>or</b> <b>public</b> <b>key</b>
       <b>keyctl</b> dh_compute &lt;private&gt; &lt;prime&gt; &lt;base&gt;

       This  command  computes  either  a  Diffie-Hellman  shared  secret or the public key corresponding to the
       provided private key using the payloads of three keys. The computation is:

              base ^ private (mod prime)

       The three inputs must be user keys with read permission. If the provided base  key  contains  the  shared
       generator  value,  the  public key will be computed.  If the provided base key contains the remote public
       key value, the shared secret will be computed.

       The result is printed to stdout as a hex dump.

              $ keyctl dh_compute $1 $2 $3
              8 bytes of data in result:
              00010203 04050607

   <b>Compute</b> <b>a</b> <b>Diffie-Hellman</b> <b>shared</b> <b>secret</b> <b>and</b> <b>derive</b> <b>key</b> <b>material</b>
       <b>keyctl</b> dh_compute_kdf &lt;private&gt; &lt;prime&gt; &lt;base&gt; &lt;output_length&gt; &lt;hash_type&gt;

       This command computes a Diffie-Hellman shared secret and derives key  material  from  the  shared  secret
       using  a  key  derivation function (KDF).  The shared secret is derived as outlined above and is input to
       the KDF using the specified hash type. The hash type must point to a hash name known to the kernel crypto
       API.

       The operation derives key material of the length specified by the caller.

       The operation is compliant to the specification of SP800-56A.

       The result is printed to stdout as hex dump.

   <b>Compute</b> <b>a</b> <b>Diffie-Hellman</b> <b>shared</b> <b>secret</b> <b>and</b> <b>apply</b> <b>KDF</b> <b>with</b> <b>other</b> <b>input</b>
       <b>keyctl</b> dh_compute_kdf_oi [-x] &lt;private&gt; &lt;prime&gt; &lt;base&gt; &lt;output_length&gt; &lt;hash_type&gt;

       This command is identical to the command  <u>dh_compute_kdf</u>  to  generate  a  Diffie-Hellman  shared  secret
       followed  by  a  key derivation operation. This command allows the caller to provide the other input data
       (OI data) compliant to SP800-56A via stdin.

       If <b>-x</b> is given, then the data passed to stdin is hex-decoded with whitespace being discarded.

   <b>Perform</b> <b>public-key</b> <b>operations</b> <b>with</b> <b>an</b> <b>asymmetric</b> <b>key</b>
       <b>keyctl</b> pkey_query &lt;key&gt; &lt;pass&gt; [k=v]*
       <b>keyctl</b> pkey_encrypt &lt;key&gt; &lt;pass&gt; &lt;datafile&gt; [k=v]* &gt; &lt;encfile&gt;
       <b>keyctl</b> pkey_decrypt &lt;key&gt; &lt;pass&gt; &lt;encfile&gt; [k=v]* &gt; &lt;datafile&gt;
       <b>keyctl</b> pkey_sign &lt;key&gt; &lt;pass&gt; &lt;datafile&gt; [k=v]* &gt; &lt;sigfile&gt;
       <b>keyctl</b> pkey_verify &lt;key&gt; &lt;pass&gt; &lt;datafile&gt; &lt;sigfile&gt; [k=v]*

       These commands query an asymmetric key, encrypt data with it, decrypt  the  encrypted  data,  generate  a
       signature over some data and verify that signature.  For encrypt, decrypt and sign, the resulting data is
       written to stdout; verify reads the data and the signature files and compares them.

       [<b>!</b>]  NOTE  that  the  data  is of very limited capacity, with no more bits than the size of the key.  For
       signatures, the caller is expected to digest the actual data and pass in the result of the digest as  the
       datafile.  The name of the digest should be specified on the end of the command line as "hash=&lt;name&gt;".

       The  <u>key</u>  ID  indicates the key to use; <u>pass</u> is a placeholder for future password provision and should be
       "0" for the moment; <u>datafile</u> is the unencrypted data to be encrypted, signed or  to  have  its  signature
       checked; <u>encfile</u> is a file containing encrypted data; and <u>sigfile</u> is a file containing a signature.

       A  list  of parameters in "key[=val]" form can be included on the end of the command line.  These specify
       things like the digest algorithm used ("hash=&lt;name&gt;") or the encoding form ("enc=&lt;type&gt;").

              k=`keyctl padd asymmetric "" @s &lt;key.pkcs8.der`
              keyctl pkey_query $k 0 enc=pkcs1 hash=sha256
              keyctl pkey_encrypt $k 0 foo.hash enc=pkcs1 &gt;foo.enc
              keyctl pkey_decrypt $k 0 foo.enc enc=pkcs1 &gt;foo.hash
              keyctl pkey_sign $k 0 foo.hash enc=pkcs1 hash=sha256 &gt;foo.sig
              keyctl pkey_verify $k 0 foo.hash foo.sig enc=pkcs1 hash=sha256

       See <a href="../man7/asymmetric-key.7.html">asymmetric-key</a>(7) for more information.

   <b>Change</b> <b>notifications</b>
       <b>keyctl</b> watch [-f&lt;filters&gt;] &lt;key&gt;
       <b>keyctl</b> watch_session [-f &lt;filters&gt;] [-n &lt;name&gt;] \
                       &lt;notifylog&gt; &lt;gclog&gt; &lt;fd&gt; &lt;prog&gt; [&lt;arg1&gt; &lt;arg2&gt; ...]  <b>keyctl</b> watch_add &lt;fd&gt; &lt;key&gt;
       <b>keyctl</b> watch_rm &lt;fd&gt; &lt;key&gt;

       The <b>watch</b> command watches a single key, printing notifications to stdout  until  the  key  is  destroyed.
       Filters  can be employed to cut down the events that will be delivered.  The <u>filter</u> string is a series of
       letters, each one of which enables a particular event subtype:

              <b>i</b> - The key has been instantiated
              <b>p</b> - The key has been updated
              <b>l</b> - A link has been added to a keyring
              <b>n</b> - A link has been removed from a keyring
              <b>c</b> - A keyring has been cleared
              <b>r</b> - A key has been revoked
              <b>v</b> - A key has been invalidated
              <b>s</b> - A key has had its attributes changed

       The output of the command looks like:

              &lt;<u>keyid</u>&gt; &lt;<u>event</u>&gt; [&lt;<u>aux</u>&gt;]

       Where <u>keyid</u> is the primary subject of the notification, <u>op</u> is the event and <u>aux</u> is the secondary  key  if
       there  is one (such as link where the primary key is the keyring secondary key is the key being linked in
       to it).  For example:

              255913279 link 340681059
              255913279 clr

       An additional notication is generated when a key being watched is garbage collected, e.g.:

              255913279 gc

       The <b>watch_session</b> command creates a new session  keyring,  with  name  <u>name</u>  if  given,  watches  it  for
       notifications and runs program <u>prog</u> with it.  The program is given the specified arguments.

       A  second  process  is  forked off to monitor the notifications.  The output from that is directed to the
       files <u>notifylog</u> for most notifications and <u>gclog</u> for key removal notifications  (which  are  asynchronous
       and may be deferred).

       The <b><a href="../man7/watch_queue.7.html">watch_queue</a></b>(7) device is exported to the program attached to fd number <u>fd</u>.  This can be passed by the
       other two commands.

       The  <b>watch_add</b> command adds a watch on <u>key</u> to the <b>watch_queue</b> attached to <u>fd</u> as exported by watch_session
       and the <b>watch_rm</b> caommand removes it.  A watch_queue can handle multiple keys and even  non-keys  sources
       as well.

</pre><h4><b>ERRORS</b></h4><pre>
       There are a number of common errors returned by this program:

       "Not a directory" - a key wasn't a keyring.

       "Requested key not found" - the looked for key isn't available.

       "Key has been revoked" - a revoked key was accessed.

       "Key has expired" - an expired key was accessed.

       "Permission denied" - permission was denied by a UID/GID/mask combination.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/keyctl.1.html">keyctl</a></b>(1), <b><a href="../man2/keyctl.2.html">keyctl</a></b>(2), <b><a href="../man2/request_key.2.html">request_key</a></b>(2), <b><a href="../man3/keyctl.3.html">keyctl</a></b>(3), <b><a href="../man5/request-key.conf.5.html">request-key.conf</a></b>(5), <b><a href="../man7/keyrings.7.html">keyrings</a></b>(7), <b><a href="../man8/request-key.8.html">request-key</a></b>(8)

Linux                                              20 Feb 2014                                         <u><a href="../man1/KEYCTL.1.html">KEYCTL</a></u>(1)
</pre>
 </div>
</div></section>
</div>
</body>
</html>